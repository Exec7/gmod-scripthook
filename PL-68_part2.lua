--Stealed clientside server code by exechack.cc
--Hostname: [PL] [PixelMod] PelugeRP SWRP | .gg/pixelmod - Part 2/10 - 06/04/2025


--PATH lua/autorun/adverts.lua:
if SERVER then
    
    hook.Add("PlayerInitialSpawn", "SWVAdverts", function(p)
        if(game.SinglePlayer()) then
            if(cookie.GetString("SWServer") != "1") then
                timer.Simple(30, function()
                    p:ChatPrint("Join the official Star Wars Vehicles server here: 185.44.76.33:27165");
                    cookie.Set("SWServer","1");
                end);
            end
        end
    end)

end
--PATH lua/autorun/arccw_autorun.lua:
AddCSLuaFile()

-- the main object
ArcCW = {}

ArcCWInstalled = true

ArcCW.GenerateAttEntities = true

for _, v in pairs(file.Find("arccw/shared/*", "LUA")) do
    include("arccw/shared/" .. v)
    AddCSLuaFile("arccw/shared/" .. v)
end

for _, v in pairs(file.Find("arccw/client/*", "LUA")) do
    AddCSLuaFile("arccw/client/" .. v)
    if CLIENT then
        include("arccw/client/" .. v)
    end
end

-- TODO: Remove SP check after upcoming June 2023 update
if SERVER or game.SinglePlayer() then
    for _, v in pairs(file.Find("arccw/server/*", "LUA")) do
        include("arccw/server/" .. v)
    end
end

-- if you want to override arccw functions, put your override files in the arccw/mods directory so it will be guaranteed to override the base

for _, v in pairs(file.Find("arccw/mods/shared/*", "LUA")) do
    include("arccw/mods/shared/" .. v)
    AddCSLuaFile("arccw/mods/shared/" .. v)
end

for _, v in pairs(file.Find("arccw/mods/client/*", "LUA")) do
    AddCSLuaFile("arccw/mods/client/" .. v)
    if CLIENT then
        include("arccw/mods/client/" .. v)
    end
end

-- TODO: Remove SP check after upcoming June 2023 update
if SERVER or game.SinglePlayer() then
    for _, v in pairs(file.Find("arccw/mods/server/*", "LUA")) do
        include("arccw/mods/server/" .. v)
    end
end
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/arccw/shared/arccw_kraken_republic_sounds.lua:
-- Interaction
sound.Add( {
    name = "ArcCW_Kraken.Grab",
    channel = CHAN_ITEM + 6,
    volume = 0.5,
    level = 120,
    pitch = {90, 115},
    sound = {
        "shared/manual_reset_1.mp3",
        "shared/manual_reset_2.mp3",
        "shared/manual_reset_3.mp3",
        "shared/manual_reset_4.mp3",
    }
} )


sound.Add( {
    name = "ArcCW_Kraken.Overheat",
    channel = CHAN_ITEM + 6,
    volume = 0.5,
    level = 120,
    pitch = {90, 115},
    sound = {
        "shared/overheat/overheat_1.wav",
        "shared/overheat/overheat_2.wav",
        "shared/overheat/overheat_3.wav",
        "shared/overheat/overheat_4.wav",
        "shared/overheat/overheat_5.wav",
        "shared/overheat/overheat_6.wav",
        "shared/overheat/overheat_7.wav",
        "shared/overheat/overheat_8.wav",
        "shared/overheat/overheat_9.wav",
        "shared/overheat/overheat_10.wav",
        "shared/overheat/overheat_11.wav",
        "shared/overheat/overheat_12.wav",
        "shared/overheat/overheat_13.wav",
        "shared/overheat/overheat_14.wav",
        "shared/overheat/overheat_15.wav",
        "shared/overheat/overheat_16.wav",
        "shared/overheat/overheat_17.wav",
        "shared/overheat/overheat_18.wav",
        "shared/overheat/overheat_19.wav",
        "shared/overheat/overheat_20.wav",
        "shared/overheat/overheat_21.wav",
    }
} )

sound.Add( {
    name = "ArcCW_Kraken.OverheatFix",
    channel = CHAN_ITEM + 6,
    volume = 0.5,
    level = 120,
    pitch = {90, 115},
    sound = {
        "shared/overheat/overheat_fix_1.wav",
        "shared/overheat/overheat_fix_2.wav",
        "shared/overheat/overheat_fix_3.wav",
        "shared/overheat/overheat_fix_4.wav",
    }
} )

sound.Add( {
    name = "ArcCW_Kraken.OverheatReplenished",
    channel = CHAN_ITEM + 6,
    volume = 0.5,
    level = 120,
    pitch = {90, 115},
    sound = {
        "shared/overheat/overheat_replenished_1.wav",
        "shared/overheat/overheat_replenished_2.wav",
        "shared/overheat/overheat_replenished_3.wav",
        "shared/overheat/overheat_replenished_4.wav",
        "shared/overheat/overheat_replenished_5.wav",
    }
} )


sound.Add( {
    name = "ArcCW_Kraken.OverheatWarn",
    channel = CHAN_ITEM + 6,
    volume = 0.5,
    level = 120,
    pitch = {90, 115},
    sound = {
        "shared/overheat/overheat_warning_1.wav",
        "shared/overheat/overheat_warning_2.wav",
        "shared/overheat/overheat_warning_3.wav",
        "shared/overheat/overheat_warning_4.wav",
        "shared/overheat/overheat_warning_5.wav",
    }
} )

sound.Add( {
    name = "ArcCW_Kraken.ShotgunLoad",
    channel = CHAN_ITEM + 6,
    volume = 0.5,
    level = 120,
    pitch = {90, 115},
    sound = {
        "arccw/kraken/republic/sb2/load1.wav",
        "arccw/kraken/republic/sb2/load2.wav",
        "arccw/kraken/republic/sb2/load3.wav",
        "arccw/kraken/republic/sb2/load4.wav",
        "arccw/kraken/republic/sb2/load5.wav",
        "arccw/kraken/republic/sb2/load6.wav"
    }
} )


-- Weapons
sound.Add( {
    name = "ArcCW_Kraken.SW_B2HAND",
    channel = CHAN_WEAPON + 6,
    volume = 1.0,
    level = 140,
    pitch = {95, 105},
    sound = {
        "arccw/kraken/republic/b2/sw01_weapons_blasters_e5-b2_laser_close_var_01_01.wav",
        "arccw/kraken/republic/b2/sw01_weapons_blasters_e5-b2_laser_close_var_01_02.wav",
        "arccw/kraken/republic/b2/sw01_weapons_blasters_e5-b2_laser_close_var_01_03.wav",
        "arccw/kraken/republic/b2/sw01_weapons_blasters_e5-b2_laser_close_var_01_04.wav",
        "arccw/kraken/republic/b2/sw01_weapons_blasters_e5-b2_laser_close_var_01_05.wav",
        "arccw/kraken/republic/b2/sw01_weapons_blasters_e5-b2_laser_close_var_01_05.wav",
    }
} )
sound.Add( {
    name = "ArcCW_Kraken.SW_HEALINGDARTS",
    channel = CHAN_WEAPON + 6,
    volume = 1.0,
    level = 140,
    pitch = {95, 105},
    sound = {
        "arccw/kraken/republic/heal/combatheal_var_01.mp3",
        "arccw/kraken/republic/heal/combatheal_var_02.mp3",
        "arccw/kraken/republic/heal/combatheal_var_03.mp3",
        "arccw/kraken/republic/heal/combatheal_var_04.mp3",
        "arccw/kraken/republic/heal/combatheal_var_05.mp3",
        "arccw/kraken/republic/heal/combatheal_var_06.mp3",
        "arccw/kraken/republic/heal/combatheal_var_07.mp3",
        "arccw/kraken/republic/heal/combatheal_var_08.mp3",
    }
} )
sound.Add( {
    name = "ArcCW_Kraken.SW_E5C",
    channel = CHAN_WEAPON + 6,
    volume = 1.0,
    level = 140,
    pitch = {95, 105},
    sound = {
        "arccw/kraken/republic/e5c/sw02_weapons_blasters_e-5c_laser_close_var_02_01.wav",
        "arccw/kraken/republic/e5c/sw02_weapons_blasters_e-5c_laser_close_var_02_02.wav",
        "arccw/kraken/republic/e5c/sw02_weapons_blasters_e-5c_laser_close_var_02_03.wav",
        "arccw/kraken/republic/e5c/sw02_weapons_blasters_e-5c_laser_close_var_02_04.wav",
        "arccw/kraken/republic/e5c/sw02_weapons_blasters_e-5c_laser_close_var_02_05.wav",
        "arccw/kraken/republic/e5c/sw02_weapons_blasters_e-5c_laser_close_var_02_06.wav",
        "arccw/kraken/republic/e5c/sw02_weapons_blasters_e-5c_laser_close_var_02_07.wav",
    }
} )
sound.Add( {
    name = "ArcCW_Kraken.SW_E5S",
    channel = CHAN_WEAPON + 6,
    volume = 1.0,
    level = 140,
    pitch = {95, 105},
    sound = {
        "arccw/kraken/republic/e5s/sw02_weapons_blasters_e5s_laser_close_var_01_01.wav",
        "arccw/kraken/republic/e5s/sw02_weapons_blasters_e5s_laser_close_var_01_02.wav",
        "arccw/kraken/republic/e5s/sw02_weapons_blasters_e5s_laser_close_var_01_03.wav",
        "arccw/kraken/republic/e5s/sw02_weapons_blasters_e5s_laser_close_var_01_04.wav",
        "arccw/kraken/republic/e5s/sw02_weapons_blasters_e5s_laser_close_var_01_05.wav",
    }
} )
sound.Add( {
    name = "ArcCW_Kraken.SW_SB2",
    channel = CHAN_WEAPON + 6,
    volume = 1.0,
    level = 140,
    pitch = {95, 105},
    sound = {
        "arccw/kraken/republic/sb2/sb2.wav",
        "arccw/kraken/republic/sb2/sb2.wav",
        "arccw/kraken/republic/sb2/sb2.wav",
        "arccw/kraken/republic/sb2/sb2.wav",
    }
} )
sound.Add( {
    name = "ArcCW_Kraken.SW_E5BX",
    channel = CHAN_WEAPON + 6,
    volume = 1.0,
    level = 140,
    pitch = {95, 105},
    sound = {
        "arccw/kraken/republic/e-5/sw02_weapons_blasters_e5_bx_laser_close_var_01_01.wav",
        "arccw/kraken/republic/e-5/sw02_weapons_blasters_e5_bx_laser_close_var_01_02.wav",
        "arccw/kraken/republic/e-5/sw02_weapons_blasters_e5_bx_laser_close_var_01_03.wav",
        "arccw/kraken/republic/e-5/sw02_weapons_blasters_e5_bx_laser_close_var_01_04.wav",
        "arccw/kraken/republic/e-5/sw02_weapons_blasters_e5_bx_laser_close_var_01_05.wav",
    }
} )
sound.Add( {
    name = "ArcCW_Kraken.SW_RG4D",
    channel = CHAN_WEAPON + 6,
    volume = 1.0,
    level = 140,
    pitch = {95, 105},
    sound = {
        "arccw/kraken/republic/rg-4d/sw02_weapons_blasters_rg-4d_laser_close_var_01_01.wav",
        "arccw/kraken/republic/rg-4d/sw02_weapons_blasters_rg-4d_laser_close_var_01_02.wav",
        "arccw/kraken/republic/rg-4d/sw02_weapons_blasters_rg-4d_laser_close_var_01_03.wav",
        "arccw/kraken/republic/rg-4d/sw02_weapons_blasters_rg-4d_laser_close_var_01_04.wav",
        "arccw/kraken/republic/rg-4d/sw02_weapons_blasters_rg-4d_laser_close_var_01_05.wav",
        "arccw/kraken/republic/rg-4d/sw02_weapons_blasters_rg-4d_laser_close_var_01_06.wav",
        "arccw/kraken/republic/rg-4d/sw02_weapons_blasters_rg-4d_laser_close_var_01_07.wav",
        "arccw/kraken/republic/rg-4d/sw02_weapons_blasters_rg-4d_laser_close_var_01_08.wav",
        "arccw/kraken/republic/rg-4d/sw02_weapons_blasters_rg-4d_laser_close_var_01_09.wav",
        "arccw/kraken/republic/rg-4d/sw02_weapons_blasters_rg-4d_laser_close_var_01_10.wav",
        "arccw/kraken/republic/rg-4d/sw02_weapons_blasters_rg-4d_laser_close_var_01_11.wav",
        "arccw/kraken/republic/rg-4d/sw02_weapons_blasters_rg-4d_laser_close_var_01_12.wav",
    }
} )
sound.Add( {
    name = "ArcCW_Kraken.SW_E5",
    channel = CHAN_WEAPON + 6,
    volume = 1.0,
    level = 140,
    pitch = {95, 105},
    sound = {
        "arccw/kraken/republic/e-5/sw02_weapons_blasters_e5_laser_close_var_04_01.wav",
        "arccw/kraken/republic/e-5/sw02_weapons_blasters_e5_laser_close_var_04_02.wav",
        "arccw/kraken/republic/e-5/sw02_weapons_blasters_e5_laser_close_var_04_03.wav",
        "arccw/kraken/republic/e-5/sw02_weapons_blasters_e5_laser_close_var_04_04.wav",
        "arccw/kraken/republic/e-5/sw02_weapons_blasters_e5_laser_close_var_04_05.wav",
        "arccw/kraken/republic/e-5/sw02_weapons_blasters_e5_laser_close_var_04_06.wav",
    }
} )
sound.Add( {
    name = "ArcCW_Kraken.SW_DC15SA",
    channel = CHAN_WEAPON + 6,
    volume = 1.0,
    level = 140,
    pitch = {95, 105},
    sound = {
        "arccw/kraken/republic/dc15sa/dc15sa.wav",
        "arccw/kraken/republic/dc15sa/dc15sa.wav",
        "arccw/kraken/republic/dc15sa/dc15sa.wav",
        "arccw/kraken/republic/dc15sa/dc15sa.wav",
    }
} )
sound.Add( {
    name = "ArcCW_Kraken.SW_WESTAR",
    channel = CHAN_WEAPON + 6,
    volume = 1.0,
    level = 140,
    pitch = {95, 105},
    sound = {
        "arccw/kraken/republic/m5/m5.wav",
        "arccw/kraken/republic/m5/m5.wav",
        "arccw/kraken/republic/m5/m5.wav",
        "arccw/kraken/republic/m5/m5.wav",
    }
} )
sound.Add( {
    name = "ArcCW_Kraken.SW_E9",
    channel = CHAN_WEAPON + 6,
    volume = 1.0,
    level = 140,
    pitch = {95, 105},
    sound = {
        "arccw/kraken/republic/e-series/e11.wav",
        "arccw/kraken/republic/e-series/e11.wav",
        "arccw/kraken/republic/e-series/e11.wav",
        "arccw/kraken/republic/e-series/e11.wav",
        "arccw/kraken/republic/e-series/e11.wav",
        "arccw/kraken/republic/e-series/e11.wav",
    }
} )
sound.Add( {
    name = "ArcCW_Kraken.SW_Z6",
    channel = CHAN_WEAPON + 6,
    volume = 1.0,
    level = 140,
    pitch = {95, 105},
    sound = {
        "arccw/kraken/republic/z6rotaryblaster/sw02_blasters_z6rotaryblaster_laser_close_var_01_02.wav",
        "arccw/kraken/republic/z6rotaryblaster/sw02_blasters_z6rotaryblaster_laser_close_var_01_03.wav",
        "arccw/kraken/republic/z6rotaryblaster/sw02_blasters_z6rotaryblaster_laser_close_var_01_04.wav",
        "arccw/kraken/republic/z6rotaryblaster/sw02_blasters_z6rotaryblaster_laser_close_var_01_05.wav",
        "arccw/kraken/republic/z6rotaryblaster/sw02_blasters_z6rotaryblaster_laser_close_var_01_06.wav",
        "arccw/kraken/republic/z6rotaryblaster/sw02_blasters_z6rotaryblaster_laser_close_var_01_07.wav",
        "arccw/kraken/republic/z6rotaryblaster/sw02_blasters_z6rotaryblaster_laser_close_var_01_08.wav",
    }
} )
sound.Add( {
    name = "ArcCW_Kraken.SW_DC17M_SNIPER",
    channel = CHAN_WEAPON + 6,
    volume = 1.0,
    level = 140,
    pitch = {95, 105},
    sound = {
        "arccw/kraken/republic/dc17m_sniper_fire0.wav",
        "arccw/kraken/republic/dc17m_sniper_fire0.wav",
        "arccw/kraken/republic/dc17m_sniper_fire0.wav",
        "arccw/kraken/republic/dc17m_sniper_fire0.wav",
        "arccw/kraken/republic/dc17m_sniper_fire0.wav",
        "arccw/kraken/republic/dc17m_sniper_fire0.wav",
    }
} )
sound.Add( {
    name = "ArcCW_Kraken.SW_DC17",
    channel = CHAN_WEAPON + 6,
    volume = 1.0,
    level = 140,
    pitch = {95, 105},
    sound = {
        "arccw/kraken/republic/dc17/sw02_weapons_blasters_dc17_laser_close_var_07_01.wav",
        "arccw/kraken/republic/dc17/sw02_weapons_blasters_dc17_laser_close_var_07_02.wav",
        "arccw/kraken/republic/dc17/sw02_weapons_blasters_dc17_laser_close_var_07_03.wav",
        "arccw/kraken/republic/dc17/sw02_weapons_blasters_dc17_laser_close_var_07_04.wav",
        "arccw/kraken/republic/dc17/sw02_weapons_blasters_dc17_laser_close_var_07_05.wav",
        "arccw/kraken/republic/dc17/sw02_weapons_blasters_dc17_laser_close_var_07_06.wav",
        "arccw/kraken/republic/dc17/sw02_weapons_blasters_dc17_laser_close_var_07_07.wav",
        "arccw/kraken/republic/dc17/sw02_weapons_blasters_dc17_laser_close_var_07_08.wav",
        "arccw/kraken/republic/dc17/sw02_weapons_blasters_dc17_laser_close_var_07_09.wav"
    }
} )
sound.Add( {
    name = "ArcCW_Kraken.SW_DC17M",
    channel = CHAN_WEAPON + 6,
    volume = 1.0,
    level = 140,
    pitch = {95, 105},
    sound = {
        "arccw/kraken/republic/dc17m/sw02_weapons_blasters_dc17m_laser_close_var_01_01.wav",
        "arccw/kraken/republic/dc17m/sw02_weapons_blasters_dc17m_laser_close_var_01_02.wav",
        "arccw/kraken/republic/dc17m/sw02_weapons_blasters_dc17m_laser_close_var_01_03.wav",
        "arccw/kraken/republic/dc17m/sw02_weapons_blasters_dc17m_laser_close_var_01_04.wav",
        "arccw/kraken/republic/dc17m/sw02_weapons_blasters_dc17m_laser_close_var_01_05.wav",
    }
} )
sound.Add( {
    name = "ArcCW_Kraken.SW_DC15A",
    channel = CHAN_WEAPON + 6,
    volume = 1.0,
    level = 140,
    pitch = {95, 105},
    sound = {
        "arccw/kraken/republic/dc15/sw02_weapons_blasters_dc15_laser_close_var_03_01.wav",
        "arccw/kraken/republic/dc15/sw02_weapons_blasters_dc15_laser_close_var_03_02.wav",
        "arccw/kraken/republic/dc15/sw02_weapons_blasters_dc15_laser_close_var_03_03.wav",
        "arccw/kraken/republic/dc15/sw02_weapons_blasters_dc15_laser_close_var_03_04.wav",
        "arccw/kraken/republic/dc15/sw02_weapons_blasters_dc15_laser_close_var_03_05.wav",
        "arccw/kraken/republic/dc15/sw02_weapons_blasters_dc15_laser_close_var_03_06.wav",
        "arccw/kraken/republic/dc15/sw02_weapons_blasters_dc15_laser_close_var_03_07.wav",
        "arccw/kraken/republic/dc15/sw02_weapons_blasters_dc15_laser_close_var_03_08.wav",
        "arccw/kraken/republic/dc15/sw02_weapons_blasters_dc15_laser_close_var_03_09.wav"
    }
} )
sound.Add( {
    name = "ArcCW_Kraken.SW_DC15X",
    channel = CHAN_WEAPON + 6,
    volume = 1.0,
    level = 140,
    pitch = {95, 105},
    sound = {
        "arccw/kraken/republic/dlt19x/sw02_weapons_blaster_dlt19x_laser_close_var_01_01.wav",
        "arccw/kraken/republic/dlt19x/sw02_weapons_blaster_dlt19x_laser_close_var_01_02.wav",
        "arccw/kraken/republic/dlt19x/sw02_weapons_blaster_dlt19x_laser_close_var_01_03.wav",
        "arccw/kraken/republic/dlt19x/sw02_weapons_blaster_dlt19x_laser_close_var_01_04.wav",
    }
} )
sound.Add( {
    name = "ArcCW_Kraken.SW_DP23",
    channel = CHAN_WEAPON + 6,
    volume = 1.0,
    level = 140,
    pitch = {95, 105},
    sound = {
        "arccw/kraken/republic/dp23.wav",
        "arccw/kraken/republic/dp23.wav",
        "arccw/kraken/republic/dp23.wav",
        "arccw/kraken/republic/dp23.wav",
    }
} )
sound.Add( {
    name = "ArcCW_Kraken.SW_VALKEN",
    channel = CHAN_WEAPON + 6,
    volume = 1.0,
    level = 140,
    pitch = {95, 105},
    sound = {
        "arccw/kraken/republic/valken38/sw02_weapons_blasters_valken-38x_laser_close_var_01_01.wav",
        "arccw/kraken/republic/valken38/sw02_weapons_blasters_valken-38x_laser_close_var_01_02.wav",
        "arccw/kraken/republic/valken38/sw02_weapons_blasters_valken-38x_laser_close_var_01_03.wav",
        "arccw/kraken/republic/valken38/sw02_weapons_blasters_valken-38x_laser_close_var_01_04.wav",
        "arccw/kraken/republic/valken38/sw02_weapons_blasters_valken-38x_laser_close_var_01_05.wav",
    }
} )
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/serv_statuseffects.lua:
return gluapack()()
--PATH lua/arccw/shared/sh_acwcommon.lua:
ArcCW.EnableCustomization = true
ArcCW.PresetPath          = "arccw_presets/"

ArcCW.NoDraw = true

ArcCW.HUToM    = 0.0254 -- 1 / 12 * 0.3048
ArcCW.MOAToAcc = 0.00092592592 -- 10 / 180 / 60
ArcCW.RecoilUnit = 41.4 -- lbfps

ArcCW.STATE_IDLE      = 0
ArcCW.STATE_SIGHTS    = 1
ArcCW.STATE_SPRINT    = 2
ArcCW.STATE_DISABLE   = 3
ArcCW.STATE_CUSTOMIZE = 4
ArcCW.STATE_BIPOD     = 5

ArcCW.SCROLL_NONE = 0
ArcCW.SCROLL_ZOOM = 1

ArcCW.FLASH_ATT_CONSTANT = 0
ArcCW.FLASH_ATT_LINEAR = 1
ArcCW.FLASH_ATT_QUADRATIC = 2

ArcCW.VolumetricLightModel = "models/effects/vol_light256x384.mdl"
ArcCW.VolumetricLightX = 256
ArcCW.VolumetricLightY = 256
ArcCW.VolumetricLightZ = 384

-- Special clip size denoting an bottomless clip
ArcCW.BottomlessMagicNumber = -1

COND_WEAPON_HAS_LOS = 41
COND_WEAPON_SIGHT_OCCLUDED = 45

ArcCW.ShellSoundsTable = {
    "weapons/arccw/casings/casing_556_1.wav",
    "weapons/arccw/casings/casing_556_2.wav",
    "weapons/arccw/casings/casing_556_3.wav",
    "weapons/arccw/casings/casing_556_4.wav"
}

ArcCW.MediumShellSoundsTable = {
    "weapons/arccw/casings/casing_308_1.wav",
    "weapons/arccw/casings/casing_308_2.wav",
    "weapons/arccw/casings/casing_308_3.wav",
    "weapons/arccw/casings/casing_308_4.wav"
}

ArcCW.PistolShellSoundsTable = {
    "weapons/arccw/casings/casing_9mm_1.wav",
    "weapons/arccw/casings/casing_9mm_2.wav",
    "weapons/arccw/casings/casing_9mm_3.wav",
    "weapons/arccw/casings/casing_9mm_4.wav"
}

ArcCW.TinyShellSoundsTable = {
    "weapons/arccw/casings/casing_22_1.wav",
    "weapons/arccw/casings/casing_22_2.wav",
    "weapons/arccw/casings/casing_22_3.wav",
    "weapons/arccw/casings/casing_22_4.wav"
}

ArcCW.ShotgunShellSoundsTable = {
    "weapons/arccw/casings/casing_12ga_1.wav",
    "weapons/arccw/casings/casing_12ga_2.wav",
    "weapons/arccw/casings/casing_12ga_3.wav",
    "weapons/arccw/casings/casing_12ga_4.wav"
}

ArcCW.RicochetSounds = {
    "weapons/arccw/ricochet01.wav",
    "weapons/arccw/ricochet02.wav",
    "weapons/arccw/ricochet03.wav",
    "weapons/arccw/ricochet04.wav",
    "weapons/arccw/ricochet05.wav"
 }

ArcCW.ReloadTimeTable = {
    [ACT_HL2MP_GESTURE_RELOAD_AR2]      = 2,
    [ACT_HL2MP_GESTURE_RELOAD_SMG1]     = 2,
    [ACT_HL2MP_GESTURE_RELOAD_PISTOL]   = 1.5,
    [ACT_HL2MP_GESTURE_RELOAD_REVOLVER] = 2.5,
    [ACT_HL2MP_GESTURE_RELOAD_SHOTGUN]  = 2.5,
    [ACT_HL2MP_GESTURE_RELOAD_DUEL]     = 3.25,
}

ArcCW.LimbCompensation = {
    [1] = {
        [HITGROUP_HEAD]     = 1 / 2,
        [HITGROUP_LEFTARM]  = 1 / 0.25,
        [HITGROUP_RIGHTARM] = 1 / 0.25,
        [HITGROUP_LEFTLEG]  = 1 / 0.25,
        [HITGROUP_RIGHTLEG] = 1 / 0.25,
        [HITGROUP_GEAR]     = 1 / 0.25,
    },
    ["terrortown"] = {
        [HITGROUP_HEAD]     = 1 / 2.5, -- ArcCW's sh_ttt.lua line 5!!!
        [HITGROUP_LEFTARM]  = 1 / 0.55,
        [HITGROUP_RIGHTARM] = 1 / 0.55,
        [HITGROUP_LEFTLEG]  = 1 / 0.55,
        [HITGROUP_RIGHTLEG] = 1 / 0.55,
        [HITGROUP_GEAR]     = 1 / 0.55,
    },
}

ArcCW.ReplaceWeapons = {
    ["weapon_pistol"]    = true,
    ["weapon_smg1"]      = true,
    ["weapon_ar2"]       = true,
    ["weapon_shotgun"]   = true,
    ["weapon_357"]       = true,
    ["weapon_alyxgun"]   = true,
    ["weapon_crossbow"]  = true,
    ["weapon_rpg"]       = true,
    ["weapon_annabelle"] = true,
}

ArcCW.MeleeDamageTypes = {
    [DMG_GENERIC] = "dmg.generic",
    [DMG_BULLET] = "dmg.bullet",
    [DMG_SLASH] = "dmg.slash",
    [DMG_CLUB] = "dmg.club",
    [DMG_SHOCK] = "dmg.shock",
}

ArcCW.PenTable = {
   [MAT_ANTLION]     = 1,
   [MAT_BLOODYFLESH] = 1,
   [MAT_CONCRETE]    = 0.75,
   [MAT_DIRT]        = 0.5,
   [MAT_EGGSHELL]    = 1,
   [MAT_FLESH]       = 0.1,
   [MAT_GRATE]       = 1,
   [MAT_ALIENFLESH]  = 0.25,
   [MAT_CLIP]        = 1000,
   [MAT_SNOW]        = 0.25,
   [MAT_PLASTIC]     = 0.5,
   [MAT_METAL]       = 1.5,
   [MAT_SAND]        = 0.25,
   [MAT_FOLIAGE]     = 0.5,
   [MAT_COMPUTER]    = 0.25,
   [MAT_SLOSH]       = 1,
   [MAT_TILE]        = 0.5,
   [MAT_GRASS]       = 0.5,
   [MAT_VENT]        = 0.75,
   [MAT_WOOD]        = 0.5,
   [MAT_DEFAULT]     = 0.75,
   [MAT_GLASS]       = 0.025,
   [MAT_WARPSHIELD]  = 1
}

ArcCW.Colors = {
    POS     = Color(25, 225, 25),
    MINIPOS = Color(75, 225, 75),
    NEU     = Color(225, 225, 225),
    MININEG = Color(225, 75, 75),
    NEG     = Color(225, 25, 25),
    COSM    = Color(100, 100, 225)
}

ArcCW.LHIKBones = {
    "ValveBiped.Bip01_L_UpperArm",
    "ValveBiped.Bip01_L_Forearm",
    "ValveBiped.Bip01_L_Wrist",
    "ValveBiped.Bip01_L_Ulna",
    "ValveBiped.Bip01_L_Hand",
    "ValveBiped.Bip01_L_Finger4",
    "ValveBiped.Bip01_L_Finger41",
    "ValveBiped.Bip01_L_Finger42",
    "ValveBiped.Bip01_L_Finger3",
    "ValveBiped.Bip01_L_Finger31",
    "ValveBiped.Bip01_L_Finger32",
    "ValveBiped.Bip01_L_Finger2",
    "ValveBiped.Bip01_L_Finger21",
    "ValveBiped.Bip01_L_Finger22",
    "ValveBiped.Bip01_L_Finger1",
    "ValveBiped.Bip01_L_Finger11",
    "ValveBiped.Bip01_L_Finger12",
    "ValveBiped.Bip01_L_Finger0",
    "ValveBiped.Bip01_L_Finger01",
    "ValveBiped.Bip01_L_Finger02"
}
--PATH lua/arccw/shared/sh_ammo.lua:
ArcCW.AmmoEntToArcCW = {
    -- TTT
    ["item_ammo_pistol_ttt"] = "arccw_ammo_pistol",
    ["item_ammo_smg1_ttt"] = "arccw_ammo_smg1",
    ["item_ammo_revolver_ttt"] = "arccw_ammo_357",
    ["item_ammo_357_ttt"] = "arccw_ammo_sniper",
    ["item_box_buckshot_ttt"] = "arccw_ammo_buckshot",

    -- HL2
    ["item_ammo_357"] = "arccw_ammo_357",
    ["item_ammo_357_large"] = "arccw_ammo_357_large",
    ["item_ammo_ar2"] = "arccw_ammo_ar2",
    ["item_ammo_ar2_large"] = "arccw_ammo_ar2_large",
    ["item_ammo_pistol"] = "arccw_ammo_pistol",
    ["item_ammo_pistol_large"] = "arccw_ammo_pistol_large",
    ["item_ammo_smg1"] = "arccw_ammo_smg1",
    ["item_ammo_smg1_large"] = "arccw_ammo_smg1_large",
    ["item_ammo_smg1_grenade"] = "arccw_ammo_smg1_grenade",
    ["item_ammo_crossbow"] = "arccw_ammo_sniper",
    ["item_box_buckshot"] = "arccw_ammo_buckshot",
    ["item_ammo_ar2_altfire"] = "arccw_ammo_smg1_grenade",

    -- HL:S
    ["ammo_357"] = "arccw_ammo_357",
    ["ammo_crossbow"] = "arccw_ammo_sniper",
    ["ammo_glockclip"] = "arccw_ammo_pistol",
    ["ammo_9mmbox"] = "arccw_ammo_ar2",
    ["ammo_mp5clip"] = "arccw_ammo_smg1",
    ["ammo_mp5grenades"] = "arccw_ammo_smg1_grenade",
    ["ammo_rpgclip"] = "arccw_ammo_smg1_grenade_large",
    ["ammo_buckshot"] = "arccw_ammo_buckshot",
    ["ammo_gaussclip"] = "arccw_ammo_ar2_large"
}

function ArcCW:AddGrenadeAmmo()
    if ArcCW.ConVars["equipmentammo"]:GetBool() and !ArcCW.ConVars["equipmentsingleton"]:GetBool() then
        for i, k in pairs(weapons.GetList()) do
            local class = k.ClassName
            local wpntbl = weapons.Get(class)
            if !wpntbl.ArcCW then continue end

            if (wpntbl.Throwing or wpntbl.Disposable) and !wpntbl.Singleton and !wpntbl.DoNotEquipmentAmmo then
                -- ammoid check will cause inconsistency between SV/CL on map change
                -- Initialize is only run once anyways, so it should be fine
                --local ammoid = game.GetAmmoID(class)
                --if ammoid == -1 then
                    -- if ammo type does not exist, build it
                    game.AddAmmoType({
                        name = class,
                    })
                    print("ArcCW adding ammo type " .. class)
                    if CLIENT then
                        language.Add(class .. "_ammo", wpntbl.PrintName)
                    end
                    ArcCW.LangTable["en"]["ammo." .. class] = wpntbl.PrintName
                --end

                k.Primary.Ammo = class
                k.OldAmmo = class
            end
        end
    end
end

hook.Add("Initialize", "ArcCW_AddGrenadeAmmo", ArcCW.AddGrenadeAmmo)

if SERVER then
    hook.Add( "OnEntityCreated", "ArcCW_AmmoReplacement", function(ent)
        if ((engine.ActiveGamemode() == "terrortown" and ArcCW.ConVars["ttt_ammo"]:GetBool()) or
            (engine.ActiveGamemode() != "terrortown" and ArcCW.ConVars["ammo_replace"]:GetBool()))
                and ArcCW.AmmoEntToArcCW[ent:GetClass()] then
            timer.Simple(0, function()
                if !IsValid(ent) then return end
                local ammoent = ents.Create(ArcCW.AmmoEntToArcCW[ent:GetClass()])
                ammoent:SetPos(ent:GetPos())
                ammoent:SetAngles(ent:GetAngles())
                ammoent:Spawn()
                SafeRemoveEntityDelayed(ent, 0) -- remove next tick
                if engine.ActiveGamemode() == "terrortown" then
                    -- Setting owner prevents pickup
                    if IsValid(ent:GetOwner()) then
                        ammoent:SetOwner(ent:GetOwner())
                        timer.Simple(2, function()
                            if IsValid(ammoent) then ammoent:SetOwner(nil) end
                        end)
                        ammoent.AmmoCount = ent.AmmoAmount
                    end
                    --[[]
                    if ent:GetClass() == "item_ammo_pistol_ttt" and ent.AmmoCount == 20 then
                        -- Extremely ugly hack: TTT pistol ammo only gives 20 rounds but we want it to be 30
                        -- Because most SMGs use pistol ammo (unlike vanilla TTT) and it runs out quickly
                        ammoent.AmmoCount = 30
                    end
                    ]]
                    ammoent:SetNWInt("truecount", ammoent.AmmoCount)
                end
            end)
        end
    end)
end
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/arccw/shared/sh_k_explosives_effects.lua:
game.AddParticles( "particles/apex_fx.pcf" )
game.AddParticles( "particles/melee_fx.pcf" )
--game.AddParticles( "particles/muzzleflashes_new.pcf" )

-- Melee FX
PrecacheParticleSystem("weapon_melee_blur")
PrecacheParticleSystem("weapon_melee_blur_2")
PrecacheParticleSystem("weapon_melee_blur_machete")
PrecacheParticleSystem("weapon_melee_blur_katana")
PrecacheParticleSystem("weapon_melee_blur_fireaxe")
PrecacheParticleSystem("weapon_melee_blur_crowbar")
PrecacheParticleSystem("weapon_melee_blur_frying_pan")

--NEW MUZZLES
PrecacheParticleSystem("wpn_muzzleflash_mgl_FULL")

--TRACERS
PrecacheParticleSystem("tfa_apex_tracer_anvil")
PrecacheParticleSystem("tfa_apex_tracer_ar")
PrecacheParticleSystem("tfa_apex_tracer_hmg")
PrecacheParticleSystem("tfa_apex_tracer_hmg_rampage")
PrecacheParticleSystem("tfa_apex_tracer_pistol")
PrecacheParticleSystem("tfa_apex_tracer_shotgun")
PrecacheParticleSystem("tfa_apex_tracer_smg")
PrecacheParticleSystem("tfa_apex_tracer_sniper")

--MUZZLES
PrecacheParticleSystem("tfa_apex_muzzle_ar")
PrecacheParticleSystem("tfa_apex_muzzle_barrel")
PrecacheParticleSystem("tfa_apex_muzzle_dmr")
PrecacheParticleSystem("tfa_apex_muzzle_dmr_charged")
PrecacheParticleSystem("tfa_apex_muzzle_hmg")
PrecacheParticleSystem("tfa_apex_muzzle_pistol")
PrecacheParticleSystem("tfa_apex_muzzle_shotgun")
PrecacheParticleSystem("tfa_apex_muzzle_smg")
PrecacheParticleSystem("tfa_apex_muzzle_sniper")

--ENERGY MUZZLES
PrecacheParticleSystem("tfa_apex_energy_muzzle_big") 
PrecacheParticleSystem("tfa_apex_energy_muzzle_medium")
PrecacheParticleSystem("tfa_apex_energy_muzzle_havoc")
PrecacheParticleSystem("tfa_apex_energy_muzzle_ttake")
PrecacheParticleSystem("tfa_apex_energy_muzzle_shotgun")
PrecacheParticleSystem("tfa_apex_energy_muzzle_lstar")
PrecacheParticleSystem("tfa_apex_chargerifle_muzzle")
PrecacheParticleSystem("tfa_apex_chargerifle_muzzle_charge")

--ENERGY TRACERS
PrecacheParticleSystem("tfa_apex_energy_tracer_ar")
PrecacheParticleSystem("tfa_apex_energy_tracer_mach")
PrecacheParticleSystem("tfa_apex_energy_tracer_rifle")
PrecacheParticleSystem("tfa_apex_energy_tracer_shotgun")
PrecacheParticleSystem("tfa_apex_energy_tracer_smg") 
PrecacheParticleSystem("tfa_apex_havoc_beam_charged")
PrecacheParticleSystem("tfa_apex_lstar_projectile")
PrecacheParticleSystem("tfa_apex_lstar_projectile_lite")
PrecacheParticleSystem("tfa_apex_lstar_projectile_og")
PrecacheParticleSystem("tfa_apex_chargerifle_beam")
PrecacheParticleSystem("tfa_apex_chargerifle_maxbeam")

-- MISC
PrecacheParticleSystem("tfa_apex_lstar_explode_core")
PrecacheParticleSystem("tfa_apex_arcstar_explode")
PrecacheParticleSystem("tfa_apex_frag_explode")
PrecacheParticleSystem("grenade_final")
PrecacheParticleSystem("tfa_apex_arcstar_impact")
PrecacheParticleSystem("tfa_apex_bocek_impact")
PrecacheParticleSystem("tfa_apex_bocek_trail")
PrecacheParticleSystem("tfa_apex_bullet_trail")
PrecacheParticleSystem("tfa_apex_bullet_energy_trail")
PrecacheParticleSystem("tfa_apex_bullet_sent_trail")


-- Precache Particles MW2019
local particlefiles = {
	"mw2019_effects.pcf",
	"mw2019_tracer.pcf",
	"mw2019_rockettrail.pcf",
	"mw2019_explosions_pak.pcf",
}

for k, v in pairs(particlefiles) do
	game.AddParticles("particles/"..v)
end

local particlenames = {
    "mw2019_tracer",
    "mw2019_tracer_fast",
	"mw2019_tracer_slow",
	"mw2019_tracer_small",
	"mw2019_tracer_inc",
	"weapon_tracers_incendiary",
	"thermite_thrown_trail",
	"smoke_thrown_trail",
	"grenadetrail",
	"rockettrail",
	"smoketrail",
	"Generic_explo_emp",
	"Generic_explo_flash",
	"Generic_explo_vhigh",
	"Generic_explo_high",
	"Generic_explo_mid",
	"Generic_explo_tiny"
}

for k, v in pairs(particlenames) do
	PrecacheParticleSystem(v)
end

-- Others
GSORParticleFiles = {}
table.insert(GSORParticleFiles, #GSORParticleFiles, "csgo_inferno_fx")
table.insert(GSORParticleFiles, #GSORParticleFiles, "arc9_gsr_nadefx")

GSORParticleEffects = {}
table.insert(GSORParticleEffects, #GSORParticleEffects, "bumpmine_active")
table.insert(GSORParticleEffects, #GSORParticleEffects, "bumpmine_active_glow")
table.insert(GSORParticleEffects, #GSORParticleEffects, "bumpmine_active_glow2")
table.insert(GSORParticleEffects, #GSORParticleEffects, "bumpmine_active_glow_outer")
table.insert(GSORParticleEffects, #GSORParticleEffects, "bumpmine_detonate")
table.insert(GSORParticleEffects, #GSORParticleEffects, "bumpmine_player_trail")
table.insert(GSORParticleEffects, #GSORParticleEffects, "grenade_explosion_01")
table.insert(GSORParticleEffects, #GSORParticleEffects, "weapon_sensorgren_beeplight")
table.insert(GSORParticleEffects, #GSORParticleEffects, "weapon_sensorgren_detonate")
table.insert(GSORParticleEffects, #GSORParticleEffects, "weapon_molotov_thrown")
//EXPLOSION_FX
table.insert(GSORParticleEffects, #GSORParticleEffects, "c4_timer_light")
table.insert(GSORParticleEffects, #GSORParticleEffects, "c4_timer_light_trigger")
table.insert(GSORParticleEffects, #GSORParticleEffects, "c4_timer_light_held")
table.insert(GSORParticleEffects, #GSORParticleEffects, "c4_timer_light_dropped")
table.insert(GSORParticleEffects, #GSORParticleEffects, "explosion_c4_500")
table.insert(GSORParticleEffects, #GSORParticleEffects, "explosion_coop_mission_c4")
table.insert(GSORParticleEffects, #GSORParticleEffects, "explosion_basic")
table.insert(GSORParticleEffects, #GSORParticleEffects, "explosion_hegrenade_interior")
table.insert(GSORParticleEffects, #GSORParticleEffects, "explosion_hegrenade_brief")
table.insert(GSORParticleEffects, #GSORParticleEffects, "explosion_smoke_disperse")
table.insert(GSORParticleEffects, #GSORParticleEffects, "explosion_smokegrenade")
table.insert(GSORParticleEffects, #GSORParticleEffects, "explosion_smokegrenade_fallback")
table.insert(GSORParticleEffects, #GSORParticleEffects, "explosion_smokegrenade_CT")
table.insert(GSORParticleEffects, #GSORParticleEffects, "HE_shockwave")
//INFERNO FX
table.insert(GSORParticleEffects, #GSORParticleEffects, "molotov_explosion")
table.insert(GSORParticleEffects, #GSORParticleEffects, "molotov_fire01")
table.insert(GSORParticleEffects, #GSORParticleEffects, "molotov_groundfire")
table.insert(GSORParticleEffects, #GSORParticleEffects, "molotov_fire_main_gm")
table.insert(GSORParticleEffects, #GSORParticleEffects, "molotov_fire_child_gm")
table.insert(GSORParticleEffects, #GSORParticleEffects, "molotov_groundfire_00HIGH")
table.insert(GSORParticleEffects, #GSORParticleEffects, "molotov_groundfire_00MEDIUM")
table.insert(GSORParticleEffects, #GSORParticleEffects, "extinguish_fire")
table.insert(GSORParticleEffects, #GSORParticleEffects, "explosion_molotov_air")
table.insert(GSORParticleEffects, #GSORParticleEffects, "incgrenade_thrown_trail")
table.insert(GSORParticleEffects, #GSORParticleEffects, "weapon_molotov_held")
//SMOKE FX
table.insert(GSORParticleEffects, #GSORParticleEffects, "explosion_child_smoke03e")
table.insert(GSORParticleEffects, #GSORParticleEffects, "explosion_child_core06b")
table.insert(GSORParticleEffects, #GSORParticleEffects, "explosion_child_smoke07b")
table.insert(GSORParticleEffects, #GSORParticleEffects, "explosion_child_smoke07c")
table.insert(GSORParticleEffects, #GSORParticleEffects, "explosion_child_distort01c")

for k, v in pairs(GSORParticleFiles) do
	game.AddParticles("particles/" .. v .. ".pcf")
end

for k, v in pairs(GSORParticleEffects) do
	PrecacheParticleSystem(v)
end

-- FX
game.AddParticles( "particles/csgo_weapon_fx.pcf" )
game.AddParticles( "particles/csgo_explosions_fx.pcf" )

PrecacheParticleSystem("pb_ins2_muzzleflash_tracer")
PrecacheParticleSystem("weapon_muzzle_flash_attach_comp")
PrecacheParticleSystem("weapon_muzzle_flash_assaultrifle")
PrecacheParticleSystem("weapon_muzzle_flash_assaultrifle_comp")
PrecacheParticleSystem("weapon_muzzle_flash_assaultrifle_silenced")
PrecacheParticleSystem("weapon_muzzle_flash_assaultrifle_silenced2")
PrecacheParticleSystem("weapon_muzzle_flash_shotgun_parent_silenced")
PrecacheParticleSystem("weapon_muzzle_flash_awp")
PrecacheParticleSystem("weapon_muzzle_flash_autoshotgun")
PrecacheParticleSystem("weapon_muzzle_flash_huntingrifle")
PrecacheParticleSystem("weapon_muzzle_flash_huntingrifle_FP")
PrecacheParticleSystem("weapon_muzzle_flash_magnum")
PrecacheParticleSystem("weapon_muzzle_flash_pistol")
PrecacheParticleSystem("weapon_muzzle_flash_pistol_silenced")
PrecacheParticleSystem("weapon_muzzle_flash_pistol_elite")
PrecacheParticleSystem("weapon_muzzle_flash_shotgun")
PrecacheParticleSystem("weapon_muzzle_flash_shotgun2")
PrecacheParticleSystem("weapon_muzzle_flash_smg")
PrecacheParticleSystem("weapon_muzzle_flash_para")
PrecacheParticleSystem("weapon_muzzle_flash_para_FP")
PrecacheParticleSystem("weapon_muzzle_flash_taser")
PrecacheParticleSystem("weapon_muzzle_flash_HE")
PrecacheParticleSystem("weapon_shell_casing_50cal")
PrecacheParticleSystem("weapon_shell_casing_9mm")
PrecacheParticleSystem("weapon_shell_casing_9mm_FP")
PrecacheParticleSystem("weapon_shell_casing_rifle")
PrecacheParticleSystem("weapon_shell_casing_shotgun")
PrecacheParticleSystem("weapon_shell_casing_50cal_fallback")
PrecacheParticleSystem("weapon_shell_casing_9mm_fallback")
PrecacheParticleSystem("weapon_shell_casing_rifle_fallback")
PrecacheParticleSystem("weapon_shell_casing_shotgun_fallback")
PrecacheParticleSystem("weapon_muzzle_smoke")
PrecacheParticleSystem("weapon_muzzle_smoke_long")
PrecacheParticleSystem("weapon_muzzle_smoke_pistols")
PrecacheParticleSystem("muzzle_smoke_trace")
PrecacheParticleSystem("weapon_muzzle_flash_smoke_small")
PrecacheParticleSystem("weapon_muzzle_flash_smoke_small2")
PrecacheParticleSystem("weapon_muzzle_flash_smoke_small3")
PrecacheParticleSystem("weapon_muzzle_flash_smoke_small4")
PrecacheParticleSystem("weapon_muzzle_flash_smoke_medium")
PrecacheParticleSystem("weapon_sensorgren_beeplight")
PrecacheParticleSystem("weapon_sensorgren_detonate")
PrecacheParticleSystem("weapon_tracers")
PrecacheParticleSystem("weapon_tracers_50cal")
PrecacheParticleSystem("weapon_tracers_mach")
PrecacheParticleSystem("weapon_tracers_pistol")
PrecacheParticleSystem("weapon_tracers_taser")

-- Grenades
PrecacheParticleSystem("explosion_basic")
PrecacheParticleSystem("explosion_hegrenade_brief")
PrecacheParticleSystem("explosion_hegrenade_interior")
PrecacheParticleSystem("explosion_basic_water")
PrecacheParticleSystem("explosion_c4_500")
PrecacheParticleSystem("explosion_c4_500_fallback")
PrecacheParticleSystem("explosion_smokegrenade")
PrecacheParticleSystem("explosion_child_smoke03e")
PrecacheParticleSystem("explosion_child_core06b")
PrecacheParticleSystem("explosion_child_smoke07b")
PrecacheParticleSystem("explosion_child_smoke07c")
PrecacheParticleSystem("explosion_child_distort01c")

PrecacheParticleSystem("muzzle_weapon_smoke_v2_direction")
PrecacheParticleSystem("muzzle_weapon_smoke_v2")
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/arccw/shared/sh_k_explosives_hooks.lua:
return gluapack()()
--PATH lua/arccw/shared/sh_loadatts.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/15a_barrel_short.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/15s_mag_ext.lua:
att.PrintName = "15s Extended Magazine"
att.SortOrder = 100
att.Icon = nil
att.Description = "Extended magazine for DC-15s"
att.Desc_Pros = {}
att.Desc_Cons = {}

att.Slot = "15s_mag"
att.ActivateElements = {"15s_mag_ext"}

att.AutoStats = true
att.HideIfBlocked = true
att.Override_ClipSize = 60

att.Mult_SightTime = 1.05
att.Mult_Sway = 2.1
att.Mult_SpeedMult = 0.95
att.Mult_ShootSpeedMult = 0.95
att.Mult_DrawTime = 1.25
att.Mult_HolsterTime = 1.25
att.Mult_HipDispersion = 1.3

--PATH addons/[bronie] arccw-special-forces-v3-1/lua/arccw/shared/attachments/a180_barrel_extended.lua:
return gluapack()()
--PATH addons/[bronie] arccw-special-forces-v3-1/lua/arccw/shared/attachments/a280cfe_stock_heavy.lua:
att.PrintName = "Heavy Stock"
att.Icon = Material("entities/kraken/sops/atts/cfe_heavystock.png", "mips smooth")
att.Description = "Heavy stocK. Improves recoil."
att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.AutoStats = true
att.Slot = "cfe_stock"
att.ActivateElements = {"a280cfe_stock_heavy"}

att.Mult_SightTime = 1.25
att.Mult_Recoil = 0.7
att.Mult_MoveDispersion = 1.15
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/ammo_explosive_mod.lua:
att.PrintName = "Explosive Mod"
att.Icon = Material("entities/acwatt_go_ammo_blanks.png", "mips smooth")
att.Description = "Explosive rounds"
att.Desc_Pros = {
}
att.Desc_Cons = {
}

att.AutoStats = true
att.Slot = "special_ammo"

att.Mult_ShootPitch = 0.9
att.Mult_ShootVol = 1.3
att.Mult_Penetration = 0
att.Mult_Damage = 4
att.Mult_Range = 0.7

att.Override_DamageType = DMG_BURN

att.Override_Tracer = "tfa_tracer_yellow" -- tracer effect name

att.Hook_GetCapacity = function(wep, cap)
    return math.Clamp(math.Round(wep.RegularClipSize * 1), 1, 12)
end

att.Hook_BulletHit = function(wep, data)
    local ent = data.tr.Entity
    util.BlastDamage(wep, wep:GetOwner(), data.tr.HitPos, 96, wep:GetDamage(data.range))
    if ent:IsValid() and ent:GetClass() == "npc_helicopter" then
        data.dmgtype = DMG_AIRBOAT
    end
end
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/ammo_gl_stun.lua:
att.PrintName = "Stun Grenade Launcher"
att.Icon = Material("interfaz/armas/sw_stungrenade.png")
att.Description = "Throwable grenade with stun capacity."
att.Desc_Pros = {}
att.Desc_Cons = {}
att.Desc_Neutrals = {}
att.AutoStats = true
att.Slot = "ammo_rocket"

att.SortOrder = 1738
att.Override_ShootEntity = "tfa_battlefront_ent_nade_stun"
att.Mult_SightTime = 1.25
att.Mult_SpeedMult = 0.8
att.Mult_SightedSpeedMult = 0.85
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/ammo_hammershot.lua:
att.PrintName = "Hammershot Module"
att.Icon = Material("interfaz/armas/sw_hammershot.png")
att.Description = "Higher damage at cost of lower fire-ratio."
att.Override_MuzzleEffect = "wpn_muzzleflash_dc17_orange"
att.Override_Tracer = "tracer_orange"
att.Mult_ShootPitch = 0.6

att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.NotForNPCs = true
att.AutoStats = true
att.Slot = "ammo"

att.Reload = 1
att.Mult_DamageMin = 1.18
att.Mult_Recoil = 1.29
att.Mult_SightTime = 1.2
att.Mult_RPM = 0.63
att.Mult_Damage = 1.27
att.Mult_MuzzleVelocity = 1.28
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/arccw/shared/attachments/ammunition_ap.lua:
att.PrintName = "APCR Projectile"
att.Description = "APCR (Armored Piercing Capped Rigid) rounds are designed to penetrate armor using a core of harder material, often tungsten or steel, encased in a metal cap. The cap helps the core maintain its shape and effectiveness upon impact."
att.Icon = Material("entities/kraken/ap_ammo.png")

att.AutoStats = true
att.Slot = "k_rocket_ammo"

att.Override_ShootEntity = "rocket_ap"
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/arccw/shared/attachments/ammunition_heat.lua:
att.PrintName = "HEAT Projectile"
att.Description = "HEAT (High Explosive Anti-Tank) rounds use a shaped charge to focus explosive energy on a small point, allowing them to penetrate light armored vehicles."
att.Icon = Material("entities/kraken/heat_ammo.png")

att.AutoStats = true
att.Slot = "k_rocket_ammo"

att.Override_ShootEntity = "rocket_heat"
--PATH lua/arccw/shared/attachments/bipod.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/default.lua:
return gluapack()()
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/arccw/shared/attachments/mode_charged.lua:
att.PrintName = "Charged Mode"
att.Icon = Material("entities/arccw/kraken/republic-arsenal/atts/charged2.png")
att.Description = "Set the weapon mode to charged shot. Designed for pistols. It will greatly improve its performance at long range, but it loses proficiency at short range."

att.Slot = "sw_mode_pistol"

att.Override_MuzzleEffect = "blaster_muzzle_red"
att.Override_Tracer = "tracer_red"
att.Override_DamageType = DMG_BLAST
att.Override_AmmoPerShot = 3
att.Mult_RPM = 0.7
att.MuzzleFlashColor = Color(250, 0, 0)

att.Desc_Pros = {}
att.Desc_Cons = {}

att.NotForNPCs = true
att.AutoStats = true
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/arccw/shared/attachments/mode_scatter.lua:
return gluapack()()
--PATH lua/arccw/shared/attachments/muzzle_a280_mod.lua:
return gluapack()()
--PATH lua/arccw/shared/attachments/optic_dc15a_scope.lua:
return gluapack()()
--PATH lua/arccw/shared/attachments/optic_e11_scope.lua:
return gluapack()()
--PATH lua/arccw/shared/attachments/optic_ee4_scope.lua:
att.PrintName = "EE-4 Magnifying Optic"
att.Icon = Material("entities/dlt19x_icon.png")
att.Description = "High-magnification sniper rifle scope for long range combat."

att.SortOrder = 9

att.Desc_Pros = {
    "autostat.holosight",
    "autostat.zoom",
}
att.Desc_Cons = {
}
att.AutoStats = true
att.Slot = "optic"

att.Model = "models/atts/ee4_carbine_scope.mdl"
att.ModelOffset = Vector(0, 0, -0)
att.AdditionalSights = {
    {
        Pos = Vector(-0.005, 9, -1.11),
        Ang = Angle(0, 0, 0),
        Magnification = 1.5,
        ScrollFunc = ArcCW.SCROLL_ZOOM,
        ZoomLevels = 10,
        ZoomSound = "weapons/arccw/fiveseven/fiveseven_slideback.wav",
        IgnoreExtra = true
    }
}

att.ScopeGlint = false

att.Holosight = true
att.HolosightReticle = Material("scope/star_ret.png", "smooth")
att.HolosightNoFlare = true
att.HolosightSize = 10
att.HolosightBone = "holosight"
att.HolosightPiece = "models/atts/ee4_carbine_scope_hsp.mdl"
att.Colorable = false

att.HolosightMagnification = 0
att.HolosightBlackbox = true

att.HolosightConstDist = 44

att.HolosightMagnificationMin = 2
att.HolosightMagnificationMax = 3
att.HoloSightColorable = false

att.Mult_SightTime = 1.35
att.Mult_SightedSpeedMult = 0.8
att.Mult_SpeedMult = 0.9
--PATH lua/arccw/shared/attachments/optic_s5_scope.lua:
return gluapack()()
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/arccw/shared/attachments/perk_clonebarc.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/perk_ondamove.lua:
att.PrintName = "On the Move"

att.Icon = Material("interfaz/iconos/kraken/sith merc arsenal/2232225357_452121849.png")
att.Description = "Expert training in high-verticality maneuvers and countless moving-while-shooting drills allow you to aim steadily even while moving between cover, across open ground, or while mid-air."
att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
}
att.Slot = "perk"

att.AutoStats = true
att.SortOrder = 4

att.Mult_JumpDispersion = 0
att.Mult_MoveDispersion = .4

att.NotForNPCs = true
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/perk_sledge.lua:
att.PrintName = "Sledge"

att.Icon = Material("interfaz/iconos/kraken/jedi guns dirty fighting/4248266477_2454428744.png")
att.Description = "With the proper technique and upper body strength, you can more quickly and effectively use your weapon as a melee."
att.Desc_Pros = {
    "More Melee Damage and less time to do a new attack."
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
}
att.Slot = "perk"

att.AutoStats = true
att.Mult_MeleeDamage = 1.35
att.Mult_MeleeTime = .67

att.NotForNPCs = true
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/perk_strafe.lua:
att.PrintName = "Strafe"

att.Icon = Material("interfaz/iconos/kraken/sith merc arsenal/2758039414_661058070.png")
att.Description = "Active experience in simulated combat drills has conditioned you to shoot while walking towards the enemy. When firing, you can walk at your normal speed."
att.Desc_Pros = {
    "Better shoot speed and less time to aim."
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
}
att.Slot = "perk"

att.AutoStats = true

att.Override_ShootSpeedMult = 1
att.Mult_SightedSpeedMult = 1.2

att.NotForNPCs = true
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/st_cr2.lua:
att.PrintName = "CR-2 Stock"
att.PrintName = "CR-2 Stock"
att.Icon = Material("interfaz/iconos/kraken/jedi vang shield specialist/4102273676_3304716367.png")
att.Description = ""
att.Desc_Pros = {}
att.Desc_Cons = {}
att.Desc_Neutrals = {}
att.Slot = "stock"

att.Model = "models/sw_battlefront/weapons/mods/cr2_stock_default.mdl"
att.DroppedModel = "models/Items/BoxSRounds.mdl"
att.OffsetAng = Angle(0, 0, 0)
att.ModelOffset = Vector(0, 0, 0)
att.ModelScale = Vector(1, 1, 1)

att.AutoStats = true
att.HideIfBlocked = true

att.Mult_Damage = 1.05
att.Mult_SightTime = 1.05
att.Mult_Sway = 1.0
att.Mult_RPM = 1.2
att.Mult_SpeedMult = 1.1

att.Mult_DrawTime = 1.1
att.Mult_HolsterTime = 1.05

att.Mult_HipDispersion = 1.05

--[[]
att.Override_Jamming = true
att.Override_HeatCapacity = 200
att.Override_HeatDissipation = 4
att.Override_HeatDelayTime = 3
]]

--PATH lua/arccw/shared/attachments/sw_b2_rocket.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/sw_mag_dc15a_75mag.lua:
att.PrintName = "SW-Half Drum Magazine"
att.AbbrevName = "75-Round Mag"
att.SortOrder = 100
att.Icon = nil
att.Description = "Half Drum magazine, ideal for additional fire support. Slight Bulky construction and additional ammo capacity increases weight, making the weapon difficult to handle"
att.Desc_Pros = {}
att.Desc_Cons = {}

att.Desc_Neutrals = {}
att.Slot = "dc15a_magazine_75"

att.Model = "models/weapons/arccw/atts/magazine/rt97c_mag_half.mdl"
att.DroppedModel = "models/Items/BoxSRounds.mdl"
att.OffsetAng = Angle(0, 0, -90)
att.ModelOffset = Vector(4.2, 0, -0.33)

att.AutoStats = true

att.HideIfBlocked = true

att.Override_ClipSize = 75

att.Mult_SightTime = 1.05
att.Mult_Sway = 2.1

att.Mult_SpeedMult = 0.95
att.Mult_ShootSpeedMult = 0.95

att.Mult_DrawTime = 1.25
att.Mult_HolsterTime = 1.25

att.Mult_HipDispersion = 1.3

--[[]
att.Override_Jamming = true
att.Override_HeatCapacity = 200
att.Override_HeatDissipation = 4
att.Override_HeatDelayTime = 3
]]

--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/sw_mag_dc17m_60mag.lua:
att.PrintName = "SW-Extended Magazine"
att.AbbrevName = "60-Round Mag"
att.SortOrder = 100
att.Icon = nil
att.Description = "Extended magazine, ideal for additional fire support. Slight Bulky construction and additional ammo capacity increases weight, making the weapon difficult to handle"
att.Desc_Pros = {}
att.Desc_Cons = {}

att.Desc_Neutrals = {}
att.Slot = "dc17m_ext"

att.Model = "models/arccw/cs574/dc17m/dc17m_magext.mdl"
att.DroppedModel = "models/Items/BoxSRounds.mdl"
att.OffsetAng = Angle(0, 0, 90)
att.ModelOffset = Vector(-0.5, -6.5, -3)
att.ModelScale = Vector(1, 1, 1)

att.AutoStats = true

att.HideIfBlocked = true

att.Override_ClipSize = 60

att.Mult_SightTime = 1.05
att.Mult_Sway = 2.1

att.Mult_SpeedMult = 0.95
att.Mult_ShootSpeedMult = 0.95

att.Mult_DrawTime = 1.25
att.Mult_HolsterTime = 1.25

att.Mult_HipDispersion = 1.3

--[[]
att.Override_Jamming = true
att.Override_HeatCapacity = 200
att.Override_HeatDissipation = 4
att.Override_HeatDelayTime = 3
]]

--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/sw_stock_e11r.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/sw_stock_e11r.lua:
att.PrintName = "SW-Stock E-11R"
att.AbbrevName = "E11-r Stock"
att.SortOrder = 100
att.Icon = nil
att.Description = "Better control."
att.Desc_Pros = {}
att.Desc_Cons = {}

att.Desc_Neutrals = {}
att.Slot = "e11r_stock"

att.Model = "models/arccw/sw_battlefront/props/e11r_stock/e11r_stock.mdl"
att.DroppedModel = "models/Items/BoxSRounds.mdl"
att.OffsetAng = Angle(-90, 0, 0)
att.ModelOffset = Vector(-0.1, -12, -0.3)
att.ModelScale = Vector(1, 1, 1)

att.AutoStats = true

att.HideIfBlocked = true

att.Mult_SightTime = 1.05
att.Mult_Sway = 1.1

att.Mult_SpeedMult = 1.1

att.Mult_DrawTime = 1.1
att.Mult_HolsterTime = 1.05

att.Mult_HipDispersion = 1.05

--[[]
att.Override_Jamming = true
att.Override_HeatCapacity = 200
att.Override_HeatDissipation = 4
att.Override_HeatDelayTime = 3
]]

--PATH lua/arccw/shared/sh_util.lua:
-- Works around the 10 bodygroup limit on ENTITY:SetBodyGroups()
function ArcCW.SetBodyGroups(mdl, bodygroups)
    mdl:SetBodyGroups(bodygroups)
    local len = string.len(bodygroups or "")
    for i = 10, len - 1 do
        mdl:SetBodygroup(i, tonumber(string.sub(bodygroups, i + 1, i + 2)))
    end
end

-- doesn't work
function ArcCW.RotateAroundPoint(pos, ang, point, offset, offset_ang)
    local v = Vector(0, 0, 0)
    v = v + (point.x * ang:Right())
    v = v + (point.y * ang:Forward())
    v = v + (point.z * ang:Up())

    local newang = Angle()
    newang:Set(ang)

    newang:RotateAroundAxis(ang:Right(), offset_ang.p)
    newang:RotateAroundAxis(ang:Forward(), offset_ang.r)
    newang:RotateAroundAxis(ang:Up(), offset_ang.y)

    v = v + newang:Right() * offset.x
    v = v + newang:Forward() * offset.y
    v = v + newang:Up() * offset.z

    -- v:Rotate(offset_ang)

    v = v - (point.x * newang:Right())
    v = v - (point.y * newang:Forward())
    v = v - (point.z * newang:Up())

    return v + pos, newang
end

function ArcCW.RotateAroundPoint2(pos, ang, point, offset, offset_ang)

    -- debugoverlay.Cross(point, 1, 1, Color(255, 0, 0), true)

    local mat = Matrix()
    mat:SetTranslation(pos)
    mat:SetAngles(ang)
    -- debugoverlay.Cross(pos, 1.5, 1, Color(0, 0, 255), true)
    -- debugoverlay.Line(mat:GetTranslation(), mat:GetTranslation() + ang:Forward() * 32, 1, color_white, true)
    -- debugoverlay.Line(mat:GetTranslation(), point, 1, Color(255, 150, 150), true)

    mat:Translate(point)
    -- debugoverlay.Cross(mat:GetTranslation(), 2, 1, Color(255, 0, 255), true)

    local rot_mat = Matrix()
    rot_mat:SetAngles(offset_ang)
    rot_mat:Invert()
    mat:Mul(rot_mat)

    --mat:Rotate(offset_ang)
    mat:Translate(-point)

    mat:Translate(offset)

    -- debugoverlay.Cross(mat:GetTranslation(), 1, 1, Color(0, 255, 0), true)
    -- debugoverlay.Line(mat:GetTranslation(), mat:GetTranslation() + mat:GetAngles():Forward() * 8, 1, Color(0, 255, 0), true)

    return mat:GetTranslation(), mat:GetAngles()
end

-- See https://wiki.facepunch.com/gmod/Entity:GetAttachment
function ArcCW.FormatViewModelAttachment(nFOV, vOrigin, bFrom)
    local vEyePos = EyePos()
    local aEyesRot = EyeAngles()
    local vOffset = vOrigin - vEyePos
    local vForward = aEyesRot:Forward()
    local nViewX = math.tan(nFOV * math.pi / 360)

    if nViewX == 0 then
        vForward:Mul(vForward:Dot(vOffset))
        vEyePos:Add(vForward)

        return vEyePos
    end

    -- FIXME: LocalPlayer():GetFOV() should be replaced with EyeFOV() when it's binded
    local nWorldX = math.tan(LocalPlayer():GetFOV() * math.pi / 360)

    if nWorldX == 0 then
        vForward:Mul(vForward:Dot(vOffset))
        vEyePos:Add(vForward)

        return vEyePos
    end

    local vRight = aEyesRot:Right()
    local vUp = aEyesRot:Up()

    if bFrom then
        local nFactor = nWorldX / nViewX
        vRight:Mul(vRight:Dot(vOffset) * nFactor)
        vUp:Mul(vUp:Dot(vOffset) * nFactor)
    else
        local nFactor = nViewX / nWorldX
        vRight:Mul(vRight:Dot(vOffset) * nFactor)
        vUp:Mul(vUp:Dot(vOffset) * nFactor)
    end

    vForward:Mul(vForward:Dot(vOffset))
    vEyePos:Add(vRight)
    vEyePos:Add(vUp)
    vEyePos:Add(vForward)

    return vEyePos
end
--PATH lua/arccw/client/cl_ttt.lua:
return gluapack()()
--PATH lua/arccw/client/cl_vrmod.lua:
return gluapack()()
--PATH lua/autorun/arfegle.lua:
list.Set( "PlayerOptionsModel", "arfegle", "models/wf/arfeagle/arfeagle.mdl" )
player_manager.AddValidModel( "arfegle", "models/wf/arfeagle/arfeagle.mdl" )

--PATH lua/autorun/armand.lua:
return gluapack()()
--PATH lua/autorun/aura_lvs_display_handler.lua:
if (CLIENT) then
	AddCSLuaFile("aura_lvs_display_gui/imgui.lua")

	local imgui = include("aura_lvs_display_gui/imgui.lua")

	aura_lvs_display_entities = aura_lvs_display_entities or {}
	local aura_lvs_display_vehicles = aura_lvs_display_vehicles or {}
	local aura_lvs_display_vehicle_count = 0
	local viewDist = 250000
	local max_vehicle_per_page = 8
	local max_pages = 1

	local baseWidth = 850
	local baseHeight = 500
	local displayMaterial = Material("sprites/lfs_display_image.png")
	local start_ang = Angle(0,90,90)

	local start_x = -baseWidth / 2
	local start_y = -baseHeight / 2

	local border = 5
	local max_driver_name = 23
	local max_vehicle_name = 22

	-- GOD I LOVE UI MATH :DDDDDDDDD
	-- For sure this could be optimized but idc its 3 AM
	local box_dimensions = 
	{
		[1] = {["x"] = start_x + border, ["y"] = start_y +56, ["w"] = baseWidth - (border*2), ["h"] = 50},
		[2] = {["x"] = start_x + border, ["y"] = start_y +56, ["w"] = (baseWidth - border*2) / 3, ["h"] = baseHeight - 120},
		[3] = {["x"] = start_x + border + (baseWidth - border*2) / 3 - 2, ["y"] = start_y +56, ["w"] = (baseWidth - border*2) / 6+2, ["h"] = baseHeight - 120},
		[4] = {["x"] = start_x + border + (baseWidth - border*2) / 2 - 2, ["y"] = start_y +56, ["w"] = (baseWidth - border*2) / 6+2, ["h"] = baseHeight - 120},
		[5] = {["x"] = start_x + border + (baseWidth - border*2) / 3*2 - 2, ["y"] = start_y +56, ["w"] = (baseWidth - border*2) / 3+2, ["h"] = baseHeight - 120},
		[6] = {["x"] = start_x + border, ["y"] = -start_y - 60, ["w"] = (baseWidth - border*2) / 3 -1, ["h"] = 50},
		[7] = {["x"] = start_x + border + (baseWidth - border*2) / 3*2 - 2, ["y"] = -start_y - 60, ["w"] = (baseWidth - border*2) / 3+1, ["h"] = 50},
	}

	local previous_clicked = CurTime()
	local next_clicked = CurTime()

	local grab_lvs_ships = CurTime()
	local lvs_list_update_time = 2

	
	surface.CreateFont( "LVS_List_Display_Font_1", {
	    font = "roboto",
	    italic = true,
	    size = 35 * (ScrW() / 1920),
	    weight = 1000 * (ScrW() / 1920),
	    antialias = true,
	} )

	surface.CreateFont( "LVS_List_Display_Font_2", {
	    font = "roboto",
	    italic = true,
	    size = 20 * (ScrW() / 1920),
	    weight = 1000 * (ScrW() / 1920),
	    antialias = true,
	} )

	hook.Add( "OnEntityCreated", "Aura_LVS_Display_Entity_Create", function( ent )
		timer.Simple(.1, function()
			if (!IsValid(ent)) then return end
			if (ent:GetClass() == "aura_lvs_display_panel") then
				-- Grab a list of all the table entities around the map
				aura_lvs_display_entities = ents.FindByClass("aura_lvs_display_panel")
				return
			end
		end)
	end)

	hook.Add("PostDrawOpaqueRenderables", "Aura_LVS_Display_List_Drawer", function()
		-- Should try and implement a check to NOT run any rendering or even scanning of entities if the player is not close enough to the table, since this is all clientside
		if (#aura_lvs_display_entities == 0) then
			return
		end

		local ply = LocalPlayer()
		
		local ship_num = 0
		local name = ""
		local health = 0
		local maxhealth = 0
		local shield = 0
		local maxshield = 0
		local driver = ""
		local ship = 0

		local y_pos = start_y + 130

		local ang = start_ang

		local hp_percent = 0
		local shield_percent = 0

		-- We only want to update positions so many times a second so that we can preserve performance
		if (grab_lvs_ships < CurTime()) then
			grab_lvs_ships = CurTime() + lvs_list_update_time
			aura_lvs_display_vehicles = LVS:GetVehicles()
			aura_lvs_display_vehicle_count = table.Count(aura_lvs_display_vehicles)
			aura_lvs_display_vehicles = table.ClearKeys(aura_lvs_display_vehicles)
			max_pages = math.max(math.ceil(aura_lvs_display_vehicle_count  / max_vehicle_per_page),1)
		end

		-- Loop through our table list
		for k,v in ipairs(aura_lvs_display_entities) do
			if (IsValid(v)) then
				 y_pos = start_y + 130
				if (!v.ENABLED or v:GetPos():DistToSqr(ply:GetPos()) >= viewDist) then continue end
				v.current_page = v.current_page or 1

	            if imgui.Entity3D2D(v, v:GetForward() + v:GetUp() * 78, ang, 0.1) then
					surface.SetDrawColor( 0, 0, 0, 255 )
		        	surface.SetMaterial(displayMaterial)
		        	surface.DrawTexturedRect(start_x, start_y, baseWidth,baseHeight)
		        	surface.SetDrawColor( 255, 255, 255, 255 )

		        	draw.SimpleText( "Vehicles Detected: ".. aura_lvs_display_vehicle_count, "LVS_List_Display_Font_1", 0, -240, Color(255, 255, 255, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)
		        	surface.DrawOutlinedRect(box_dimensions[1].x, box_dimensions[1].y, box_dimensions[1].w, box_dimensions[1].h, 2)

		        	surface.DrawOutlinedRect(box_dimensions[2].x, box_dimensions[2].y, box_dimensions[2].w, box_dimensions[2].h, 2)
		        	surface.DrawOutlinedRect(box_dimensions[3].x, box_dimensions[3].y, box_dimensions[3].w, box_dimensions[3].h, 2)
		        	surface.DrawOutlinedRect(box_dimensions[4].x, box_dimensions[4].y, box_dimensions[4].w, box_dimensions[4].h, 2)
		        	surface.DrawOutlinedRect(box_dimensions[5].x, box_dimensions[5].y, box_dimensions[5].w, box_dimensions[5].h, 2)

		        	draw.SimpleText("Vehicle", "LVS_List_Display_Font_2", start_x + 10, start_y + 80, Color(255, 255, 255, 255), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
		        	draw.SimpleText("Health", "LVS_List_Display_Font_2", box_dimensions[3].x + 10, start_y + 80, Color(255, 255, 255, 255), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
		        	draw.SimpleText("Shield", "LVS_List_Display_Font_2", box_dimensions[4].x + 10, start_y + 80, Color(255, 255, 255, 255), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
		        	draw.SimpleText("Operator", "LVS_List_Display_Font_2", box_dimensions[5].x + 10, start_y + 80, Color(255, 255, 255, 255), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)

		        	if imgui.xTextButton("Previous", "LVS_List_Display_Font_2", box_dimensions[6].x, box_dimensions[6].y, box_dimensions[6].w, box_dimensions[6].h, 2, Color(255,255,255,255), Color(255,255,255,150), Color(0,255,55)) then
		        		if (previous_clicked < CurTime()) then
			        		previous_clicked = CurTime() + .1
			        		v.current_page = v.current_page-1
			        		if (v.current_page == 0) then
			        			v.current_page = max_pages
			        		end
			        	end
			        end

			        if imgui.xTextButton("Next", "LVS_List_Display_Font_2", box_dimensions[7].x, box_dimensions[7].y, box_dimensions[7].w, box_dimensions[7].h, 2, Color(255,255,255,255), Color(255,255,255,150), Color(0,255,55)) then
			        	if (next_clicked < CurTime()) then
			        		next_clicked = CurTime() + .1
			        		v.current_page = v.current_page+1
			        		if (v.current_page > max_pages) then
			        			v.current_page = 1
			        		end
			        	end
			        end

			        draw.SimpleText(v.current_page .. "/" .. max_pages, "LVS_List_Display_Font_2", 0, box_dimensions[7].y + box_dimensions[7].h/2, Color(255, 255, 255, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)

					for i = 1, max_vehicle_per_page do
						ship_num = i + ((v.current_page - 1) * max_vehicle_per_page)
						if (IsValid(aura_lvs_display_vehicles[ship_num])) then
							ship = aura_lvs_display_vehicles[ship_num]
							name = ship.PrintName or "UNKNOWN"
							health = ship:GetHP() or 1
							maxhealth = ship:GetMaxHP() or 1
							shield = ship:GetShield() or 1
							maxshield = ship:GetMaxShield() or 1

							hp_percent = math.Round((health / maxhealth) * 100) .. "%"
							
							if (maxshield == 0) then
								shield_percent = "NA"
							else
								shield_percent = math.Round((shield / maxshield) * 100) .. "%"
							end
							driver = "None"
							if (ship:GetAITEAM() == v.AITEAM) then
								if (ship.GetDriver) then
									if (ship:GetDriver():IsPlayer()) then
										driver = ship:GetDriver():Nick()
									elseif (ship:GetAI()) then
										driver = "Autopilot"
									end
								else
									driver = "Unknown"
								end
							else
								driver = "Unknown"
							end

							if (string.len(driver) > max_driver_name) then
								driver = string.sub(driver, 1, max_driver_name) .. "..."
							end

							if (string.len(name) > max_vehicle_name) then
								name = string.sub(name, 1, max_vehicle_name) .. "..."
							end

							draw.SimpleText(name, "LVS_List_Display_Font_2", start_x + 10, y_pos, Color(255, 255, 255, 255), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
							draw.SimpleText(hp_percent, "LVS_List_Display_Font_2", box_dimensions[3].x + 10, y_pos, Color(255, 255, 255, 255), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
							draw.SimpleText(shield_percent, "LVS_List_Display_Font_2", box_dimensions[4].x + 10, y_pos, Color(255, 255, 255, 255), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
							draw.SimpleText(driver, "LVS_List_Display_Font_2", box_dimensions[5].x + 10, y_pos, Color(255, 255, 255, 255), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)

							y_pos = y_pos + 40

						end
					end
		        imgui.End3D2D()
		    	end
			end
		end
	end)
end
--PATH lua/autorun/aussi_cgi501st_arms.lua:
return gluapack()()
--PATH lua/autorun/aussi_cgirc_arms.lua:
list.Set( "PlayerOptionsModel", "Republic Commando (CGI)", "models/aussiwozzi/cgi/commando/rc_plain.mdl" )
player_manager.AddValidModel( "Republic Commando (CGI)", "models/aussiwozzi/cgi/commando/rc_plain.mdl" )
player_manager.AddValidHands( "Republic Commando (CGI)", "models/aussiwozzi/cgi/commando/commando_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Republic Commando Delta Boss (CGI)", "models/aussiwozzi/cgi/commando/rc_boss.mdl" )
player_manager.AddValidModel( "Republic Commando Delta Boss (CGI)", "models/aussiwozzi/cgi/commando/rc_boss.mdl" )
player_manager.AddValidHands( "Republic Commando Delta Boss (CGI)", "models/aussiwozzi/cgi/commando/boss_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Republic Commando Delta Fixer (CGI)", "models/aussiwozzi/cgi/commando/rc_Fixer.mdl" )
player_manager.AddValidModel( "Republic Commando Delta Fixer (CGI)", "models/aussiwozzi/cgi/commando/rc_Fixer.mdl" )
player_manager.AddValidHands( "Republic Commando Delta Fixer (CGI)", "models/aussiwozzi/cgi/commando/Fixer_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Republic Commando Delta Sev (CGI)", "models/aussiwozzi/cgi/commando/rc_Sev.mdl" )
player_manager.AddValidModel( "Republic Commando Delta Sev (CGI)", "models/aussiwozzi/cgi/commando/rc_Sev.mdl" )
player_manager.AddValidHands( "Republic Commando Delta Sev (CGI)", "models/aussiwozzi/cgi/commando/Sev_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Republic Commando Delta Scorch (CGI)", "models/aussiwozzi/cgi/commando/rc_scorch.mdl" )
player_manager.AddValidModel( "Republic Commando Delta Scorch (CGI)", "models/aussiwozzi/cgi/commando/rc_scorch.mdl" )
player_manager.AddValidHands( "Republic Commando Delta Scorch (CGI)", "models/aussiwozzi/cgi/commando/scorch_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Republic Commando Omega Niner (CGI)", "models/aussiwozzi/cgi/commando/rc_niner.mdl" )
player_manager.AddValidModel( "Republic Commando Omega Niner (CGI)", "models/aussiwozzi/cgi/commando/rc_niner.mdl" )
player_manager.AddValidHands( "Republic Commando Omega Niner (CGI)", "models/aussiwozzi/cgi/commando/omega_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Republic Commando Omega Darman (CGI)", "models/aussiwozzi/cgi/commando/rc_Darman.mdl" )
player_manager.AddValidModel( "Republic Commando Omega Darman (CGI)", "models/aussiwozzi/cgi/commando/rc_Darman.mdl" )
player_manager.AddValidHands( "Republic Commando Omega Darman (CGI)", "models/aussiwozzi/cgi/commando/omega_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Republic Commando Omega Fi (CGI)", "models/aussiwozzi/cgi/commando/rc_Fi.mdl" )
player_manager.AddValidModel( "Republic Commando Omega Fi (CGI)", "models/aussiwozzi/cgi/commando/rc_Fi.mdl" )
player_manager.AddValidHands( "Republic Commando Omega Fi (CGI)", "models/aussiwozzi/cgi/commando/omega_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Republic Commando Omega Atin (CGI)", "models/aussiwozzi/cgi/commando/rc_Atin.mdl" )
player_manager.AddValidModel( "Republic Commando Omega Atin (CGI)", "models/aussiwozzi/cgi/commando/rc_Atin.mdl" )
player_manager.AddValidHands( "Republic Commando Omega Atin (CGI)", "models/aussiwozzi/cgi/commando/omega_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Republic Commando Omega Corr (CGI)", "models/aussiwozzi/cgi/commando/rc_Corr.mdl" )
player_manager.AddValidModel( "Republic Commando Omega Corr (CGI)", "models/aussiwozzi/cgi/commando/rc_Corr.mdl" )
player_manager.AddValidHands( "Republic Commando Omega Corr (CGI)", "models/aussiwozzi/cgi/commando/Corr_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Republic Commando Aiwha Sarge (CGI)", "models/aussiwozzi/cgi/commando/rc_Sarge.mdl" )
player_manager.AddValidModel( "Republic Commando Aiwha Sarge (CGI)", "models/aussiwozzi/cgi/commando/rc_Sarge.mdl" )
player_manager.AddValidHands( "Republic Commando Aiwha Sarge (CGI)", "models/aussiwozzi/cgi/commando/Sarge_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Republic Commando Aiwha Zag (CGI)", "models/aussiwozzi/cgi/commando/rc_Zag.mdl" )
player_manager.AddValidModel( "Republic Commando Aiwha Zag (CGI)", "models/aussiwozzi/cgi/commando/rc_Zag.mdl" )
player_manager.AddValidHands( "Republic Commando Aiwha Zag (CGI)", "models/aussiwozzi/cgi/commando/Zag_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Republic Commando Aiwha Dikut (CGI)", "models/aussiwozzi/cgi/commando/rc_Dikut.mdl" )
player_manager.AddValidModel( "Republic Commando Aiwha Dikut (CGI)", "models/aussiwozzi/cgi/commando/rc_Dikut.mdl" )
player_manager.AddValidHands( "Republic Commando Aiwha Dikut (CGI)", "models/aussiwozzi/cgi/commando/Dikut_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Republic Commando Aiwha Tyto (CGI)", "models/aussiwozzi/cgi/commando/rc_tyto.mdl" )
player_manager.AddValidModel( "Republic Commando Aiwha Tyto (CGI)", "models/aussiwozzi/cgi/commando/rc_tyto.mdl" )
player_manager.AddValidHands( "Republic Commando Aiwha Tyto (CGI)", "models/aussiwozzi/cgi/commando/tyto_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Republic Commando Yayax Cov (CGI)", "models/aussiwozzi/cgi/commando/rc_yayax_cov.mdl" )
player_manager.AddValidModel( "Republic Commando Yayax Cov (CGI)", "models/aussiwozzi/cgi/commando/rc_yayax_cov.mdl" )
player_manager.AddValidHands( "Republic Commando Yayax Cov (CGI)", "models/aussiwozzi/cgi/commando/yayax_cov_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Republic Commando Yayax Dev (CGI)", "models/aussiwozzi/cgi/commando/rc_yayax_dev.mdl" )
player_manager.AddValidModel( "Republic Commando Yayax Dev (CGI)", "models/aussiwozzi/cgi/commando/rc_yayax_dev.mdl" )
player_manager.AddValidHands( "Republic Commando Yayax Dev (CGI)", "models/aussiwozzi/cgi/commando/yayax_dev_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Republic Commando Yayax Jind (CGI)", "models/aussiwozzi/cgi/commando/rc_yayax_jind.mdl" )
player_manager.AddValidModel( "Republic Commando Yayax Jind (CGI)", "models/aussiwozzi/cgi/commando/rc_yayax_jind.mdl" )
player_manager.AddValidHands( "Republic Commando Yayax Jind (CGI)", "models/aussiwozzi/cgi/commando/yayax_jind_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Republic Commando Yayax Yover (CGI)", "models/aussiwozzi/cgi/commando/rc_yayax_yover.mdl" )
player_manager.AddValidModel( "Republic Commando Yayax Yover (CGI)", "models/aussiwozzi/cgi/commando/rc_yayax_yover.mdl" )
player_manager.AddValidHands( "Republic Commando Yayax Yover (CGI)", "models/aussiwozzi/cgi/commando/yayax_yover_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Republic Commando HOPE Leader (CGI)", "models/aussiwozzi/cgi/commando/rc_hope_leader.mdl" )
player_manager.AddValidModel( "Republic Commando HOPE Leader (CGI)", "models/aussiwozzi/cgi/commando/rc_hope_leader.mdl" )
player_manager.AddValidHands( "Republic Commando HOPE Leader (CGI)", "models/aussiwozzi/cgi/commando/hope_leader_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Republic Commando HOPE Demo (CGI)", "models/aussiwozzi/cgi/commando/rc_hope_demo.mdl" )
player_manager.AddValidModel( "Republic Commando HOPE Demo (CGI)", "models/aussiwozzi/cgi/commando/rc_hope_demo.mdl" )
player_manager.AddValidHands( "Republic Commando HOPE Demo (CGI)", "models/aussiwozzi/cgi/commando/hope_demo_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Republic Commando HOPE Sniper (CGI)", "models/aussiwozzi/cgi/commando/rc_hope_sniper.mdl" )
player_manager.AddValidModel( "Republic Commando HOPE Sniper (CGI)", "models/aussiwozzi/cgi/commando/rc_hope_sniper.mdl" )
player_manager.AddValidHands( "Republic Commando HOPE Sniper (CGI)", "models/aussiwozzi/cgi/commando/hope_sniper_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Republic Commando HOPE Tech (CGI)", "models/aussiwozzi/cgi/commando/rc_hope_Tech.mdl" )
player_manager.AddValidModel( "Republic Commando HOPE Tech (CGI)", "models/aussiwozzi/cgi/commando/rc_hope_Tech.mdl" )
player_manager.AddValidHands( "Republic Commando HOPE Tech (CGI)", "models/aussiwozzi/cgi/commando/hope_Tech_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Republic Commando Foxtrot Gregor (CGI)", "models/aussiwozzi/cgi/commando/rc_gregor.mdl" )
player_manager.AddValidModel( "Republic Commando Foxtrot Gregor (CGI)", "models/aussiwozzi/cgi/commando/rc_gregor.mdl" )
player_manager.AddValidHands( "Republic Commando Foxtrot Gregor (CGI)", "models/aussiwozzi/cgi/commando/gregor_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Republic Commando Foxtrot Sniper (CGI)", "models/aussiwozzi/cgi/commando/rc_foxtrot_Sniper.mdl" )
player_manager.AddValidModel( "Republic Commando Foxtrot Sniper (CGI)", "models/aussiwozzi/cgi/commando/rc_foxtrot_Sniper.mdl" )
player_manager.AddValidHands( "Republic Commando Foxtrot Sniper (CGI)", "models/aussiwozzi/cgi/commando/foxtrot_Sniper_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Republic Commando Foxtrot Demo (CGI)", "models/aussiwozzi/cgi/commando/rc_foxtrot_Demo.mdl" )
player_manager.AddValidModel( "Republic Commando Foxtrot Demo (CGI)", "models/aussiwozzi/cgi/commando/rc_foxtrot_Demo.mdl" )
player_manager.AddValidHands( "Republic Commando Foxtrot Demo (CGI)", "models/aussiwozzi/cgi/commando/foxtrot_Demo_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Republic Commando Foxtrot Tech (CGI)", "models/aussiwozzi/cgi/commando/rc_foxtrot_Tech.mdl" )
player_manager.AddValidModel( "Republic Commando Foxtrot Tech (CGI)", "models/aussiwozzi/cgi/commando/rc_foxtrot_Tech.mdl" )
player_manager.AddValidHands( "Republic Commando Foxtrot Tech (CGI)", "models/aussiwozzi/cgi/commando/foxtrot_Tech_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Republic Commando Aquila Cabur (CGI)", "models/aussiwozzi/cgi/commando/rc_aquila_cabur.mdl" )
player_manager.AddValidModel( "Republic Commando Aquila Cabur (CGI)", "models/aussiwozzi/cgi/commando/rc_aquila_cabur.mdl" )
player_manager.AddValidHands( "Republic Commando Aquila Cabur (CGI)", "models/aussiwozzi/cgi/commando/aquila_cabur_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Republic Commando Aquila Cyarika (CGI)", "models/aussiwozzi/cgi/commando/rc_aquila_cyarika.mdl" )
player_manager.AddValidModel( "Republic Commando Aquila Cyarika (CGI)", "models/aussiwozzi/cgi/commando/rc_aquila_cyarika.mdl" )
player_manager.AddValidHands( "Republic Commando Aquila Cyarika (CGI)", "models/aussiwozzi/cgi/commando/aquila_cyarika_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Republic Commando Aquila Batnor (CGI)", "models/aussiwozzi/cgi/commando/rc_aquila_Batnor.mdl" )
player_manager.AddValidModel( "Republic Commando Aquila Batnor (CGI)", "models/aussiwozzi/cgi/commando/rc_aquila_Batnor.mdl" )
player_manager.AddValidHands( "Republic Commando Aquila Batnor (CGI)", "models/aussiwozzi/cgi/commando/aquila_Batnor_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Republic Commando Aquila Monarch (CGI)", "models/aussiwozzi/cgi/commando/rc_aquila_monarch.mdl" )
player_manager.AddValidModel( "Republic Commando Aquila Monarch (CGI)", "models/aussiwozzi/cgi/commando/rc_aquila_monarch.mdl" )
player_manager.AddValidHands( "Republic Commando Aquila Monarch (CGI)", "models/aussiwozzi/cgi/commando/aquila_monarch_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Republic Commando ION Climber (CGI)", "models/aussiwozzi/cgi/commando/rc_ion_climber.mdl" )
player_manager.AddValidModel( "Republic Commando ION Climber (CGI)", "models/aussiwozzi/cgi/commando/rc_ion_climber.mdl" )
player_manager.AddValidHands( "Republic Commando ION Climber (CGI)", "models/aussiwozzi/cgi/commando/climber_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Republic Commando ION Ras (CGI)", "models/aussiwozzi/cgi/commando/rc_ion_ras.mdl" )
player_manager.AddValidModel( "Republic Commando ION Ras (CGI)", "models/aussiwozzi/cgi/commando/rc_ion_ras.mdl" )
player_manager.AddValidHands( "Republic Commando ION Ras (CGI)", "models/aussiwozzi/cgi/commando/ion_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Republic Commando ION Trace (CGI)", "models/aussiwozzi/cgi/commando/rc_ion_trace.mdl" )
player_manager.AddValidModel( "Republic Commando ION Trace (CGI)", "models/aussiwozzi/cgi/commando/rc_ion_trace.mdl" )
player_manager.AddValidHands( "Republic Commando ION Trace (CGI)", "models/aussiwozzi/cgi/commando/ion_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Republic Commando ION Sniper (CGI)", "models/aussiwozzi/cgi/commando/rc_ion_sniper.mdl" )
player_manager.AddValidModel( "Republic Commando ION Sniper (CGI)", "models/aussiwozzi/cgi/commando/rc_ion_sniper.mdl" )
player_manager.AddValidHands( "Republic Commando ION Sniper (CGI)", "models/aussiwozzi/cgi/commando/ion_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Republic Commando Fisher (CGI)", "models/aussiwozzi/cgi/commando/rc_Fisher.mdl" )
player_manager.AddValidModel( "Republic Commando Fisher (CGI)", "models/aussiwozzi/cgi/commando/rc_Fisher.mdl" )
player_manager.AddValidHands( "Republic Commando Fisher (CGI)", "models/aussiwozzi/cgi/commando/Fisher_arms.mdl",0,"10000000" )

--PATH addons/[admin] awarn3/lua/includes/awarn3_localization.lua:
AddCSLuaFile()
--[[
      __          __              ____  
     /\ \        / /             |___ \ 
    /  \ \  /\  / /_ _ _ __ _ __   __) |
   / /\ \ \/  \/ / _` | '__| '_ \ |__ < 
  / ____ \  /\  / (_| | |  | | | |___) |
 /_/    \_\/  \/ \__,_|_|  |_| |_|____/ 

	AWarn3 by Mr.President
]]
MsgC( AWARN3_STATECOLOR, "[AWarn3] ", AWARN3_WHITE, "Loading Localization Module\n" )


AWarn.Localization = {}
AWarn.Localization.Languages = {}
AWarn.Localization.LangCodes = {}

function AWarn.Localization:RegisterLanguage( langCode, langName )
	AWarn.Localization.Languages[ langCode ] = {}
	AWarn.Localization.LangCodes[ langCode ] = langName
end

function AWarn.Localization:AddDefinition( langCode, defID, text )
	AWarn.Localization.Languages[ langCode ][ defID ] = text
end

function AWarn.Localization:LookupDefinition( langCode, defID )
	local defString = "NOT SET"
	
	if AWarn.Localization.Languages[ langCode ] then
		if AWarn.Localization.Languages[ langCode ][ defID ] then
			defString = AWarn.Localization.Languages[ langCode ][ defID ]
		else 
			defString = self:LookupFallbackDefinition( defID )
		end
	else
		defString = self:LookupFallbackDefinition( defID )
	end
	return defString
end

function AWarn.Localization:LookupFallbackDefinition( defID )
	local defString = "NOT SET"
	if AWarn.Localization.Languages[ "EN-US" ] then
		if AWarn.Localization.Languages[ "EN-US" ][ defID ] then
			defString = AWarn.Localization.Languages[ "EN-US" ][ defID ]
		end
	end
	return defString	
end

function AWarn.Localization:GetTranslation( defID )
	local langCode = "EN-US"
	if SERVER then
		langCode = AWarn:GetOption( "awarn_server_language" )
	else
		langCode = AWarn.SelectedLanguage or "EN-US"
	end
	return AWarn.Localization:LookupDefinition( langCode, defID )
end

function AWarn.Localization:LoadLanguages()
	local foundFiles, foundDirs = file.Find( "localizations/*.lua", "LUA" )
	for k, v in pairs( foundFiles ) do
		include( "localizations/".. v )
		if SERVER then
			AddCSLuaFile( "localizations/".. v )
		end
	end
end
AWarn.Localization:LoadLanguages()




--PATH addons/[admin] awarn3/lua/localizations/es-la.lua:
local language_code = "ES-LA"

AWarn.Localization:RegisterLanguage( language_code, "Latin Spanish" )

//Credit: https://www.gmodstore.com/users/76561198116817259

AWarn.Localization:AddDefinition( language_code, "welcome1", 					"Bienvenido a AWarn3!" )
AWarn.Localization:AddDefinition( language_code, "insufficientperms", 			"No tienes permisos para ejecutar este comando." )
AWarn.Localization:AddDefinition( language_code, "insufficientperms2", 			"No tienes permisos para ver las sanciones del jugador." )
AWarn.Localization:AddDefinition( language_code, "commandnonexist", 			"Este comando no existe." )
AWarn.Localization:AddDefinition( language_code, "invalidtargetid", 			"Objetivo no valido (ID)." )
AWarn.Localization:AddDefinition( language_code, "invalidtarget", 				"Objetivo no valido." )
AWarn.Localization:AddDefinition( language_code, "reasonrequired", 				"Razon requerida." )
AWarn.Localization:AddDefinition( language_code, "remove1activewarn", 			"Haz removido una sancion de " )
AWarn.Localization:AddDefinition( language_code, "deletedwarningid", 			"Sancion(ID) borrada" )
AWarn.Localization:AddDefinition( language_code, "removeallwarnings", 			"Haz removido todas las sanciones de" )
AWarn.Localization:AddDefinition( language_code, "deletedwarningsfor", 			"Todas las sanciones borradas por" )
AWarn.Localization:AddDefinition( language_code, "cantopenconsole", 			"No puedes abrir el menu desde la consola-servidor." )
AWarn.Localization:AddDefinition( language_code, "invalidoption", 				"Opcion no valida." )
AWarn.Localization:AddDefinition( language_code, "invalidoptionvaluetype",		"Opcion no valida (Tipo valor)." )
AWarn.Localization:AddDefinition( language_code, "optionsloaded",				"Opciones cargadas!" )
AWarn.Localization:AddDefinition( language_code, "nopunishment",				"No hay castigo para ese numero de sanciones." )
AWarn.Localization:AddDefinition( language_code, "punishmentsloaded",			"Castigos cargados!" )
AWarn.Localization:AddDefinition( language_code, "playernotallowedwarn",		"Este jugador no puede ser sancionad." )
AWarn.Localization:AddDefinition( language_code, "warnmessage1",				"Haz sido sancionado por %s. Sancion: %s." )
AWarn.Localization:AddDefinition( language_code, "warnmessage2",				"Haz sancionado a %s por %s" )
AWarn.Localization:AddDefinition( language_code, "warnmessage3",				"%s ha sidos sancionado por %s. Sancion: %s" )
AWarn.Localization:AddDefinition( language_code, "warnmessage4",				"Haz sido sancionado por %s." )
AWarn.Localization:AddDefinition( language_code, "warnmessage5",				"Haz sancionado a %s." )
AWarn.Localization:AddDefinition( language_code, "warnmessage6",				"%s ha sidos sancionado por %s." )
AWarn.Localization:AddDefinition( language_code, "joinmessage1",				"se ha unido al servidor con sanciones." )
AWarn.Localization:AddDefinition( language_code, "joinmessage2",				"Su ultima sancion fue:" )
AWarn.Localization:AddDefinition( language_code, "joinmessage3",				"Bienvenido al servidor! Parece que has sido sancionado antes." )
AWarn.Localization:AddDefinition( language_code, "joinmessage4",				"Puedes ver tus sanciones ingresando" )
AWarn.Localization:AddDefinition( language_code, "closemenu",					"Cerrar menu" )
AWarn.Localization:AddDefinition( language_code, "searchplayers",				"Buscar jugadores" )
AWarn.Localization:AddDefinition( language_code, "viewwarnings",				"Ver sanciones" )
AWarn.Localization:AddDefinition( language_code, "configuration",				"Configuracion" )
AWarn.Localization:AddDefinition( language_code, "clientoptions",				"Opciones de usuario" )
AWarn.Localization:AddDefinition( language_code, "serveroptions",				"Opciones del servidor" )
AWarn.Localization:AddDefinition( language_code, "colorcustomization",			"Personalizacion de Color" )
AWarn.Localization:AddDefinition( language_code, "colorselection",				"Seleccion de color" )
AWarn.Localization:AddDefinition( language_code, "languageconfiguration",		"Personalizacion de lenguaje" )
AWarn.Localization:AddDefinition( language_code, "selectlanguage",				"Seleccionar lenguaje" )
AWarn.Localization:AddDefinition( language_code, "enablekickpunish",			"Activar castigo con kick" )
AWarn.Localization:AddDefinition( language_code, "enablebanpunish",				"Activar castigo con ban" )
AWarn.Localization:AddDefinition( language_code, "enabledecay",					"Activar Deactivacion de sanciones" )
AWarn.Localization:AddDefinition( language_code, "resetafterban",				"Reiniciar sanciones activas luego de ban" )
AWarn.Localization:AddDefinition( language_code, "allowwarnadmins",				"Habilita sancionar staff" )
AWarn.Localization:AddDefinition( language_code, "pressenter",					"Toca enter para guardar los cambios" )
AWarn.Localization:AddDefinition( language_code, "entertosave",					"Enter para guardar" )
AWarn.Localization:AddDefinition( language_code, "chatprefix",					"Prefijo del chat" )
AWarn.Localization:AddDefinition( language_code, "warningdecayrate",			"Ratio de deactivacion de sancion (en minutos)" )
AWarn.Localization:AddDefinition( language_code, "serverlanguage",				"Lenguaje del servidor" )
AWarn.Localization:AddDefinition( language_code, "punishmentsconfiguration",	"Configuracion del castigo" )
AWarn.Localization:AddDefinition( language_code, "addpunishment",				"Agregar castigo" )
AWarn.Localization:AddDefinition( language_code, "warnings",					"Sanciones" )
AWarn.Localization:AddDefinition( language_code, "punishtype",					"Tipo de castigo" )
AWarn.Localization:AddDefinition( language_code, "punishlength",				"Duracion del castigo" )
AWarn.Localization:AddDefinition( language_code, "playermessage",				"Mensaje del jugador" )
AWarn.Localization:AddDefinition( language_code, "playername",					"Nombre del jugador" )
AWarn.Localization:AddDefinition( language_code, "messagetoplayer",				"Hablar con el jugador" )
AWarn.Localization:AddDefinition( language_code, "servermessage",				"Mensaje del servidor" )
AWarn.Localization:AddDefinition( language_code, "messagetoserver",				"Hablar al servidor" )
AWarn.Localization:AddDefinition( language_code, "deletewarning",				"Borrar sancion" )
AWarn.Localization:AddDefinition( language_code, "punishaddmenu",				"Agregar castigo MENU" )
AWarn.Localization:AddDefinition( language_code, "inminutes",					"En minutos" )
AWarn.Localization:AddDefinition( language_code, "0equalperma",					"0 = Permanente" )
AWarn.Localization:AddDefinition( language_code, "use%",						"Usa %s para mostrar el nombre del jugador" )
AWarn.Localization:AddDefinition( language_code, "setdefault",					"Establecer por defecto" )
AWarn.Localization:AddDefinition( language_code, "showingownwarnings",			"Mostrar tus propias sanciones" )
AWarn.Localization:AddDefinition( language_code, "warnedby",					"Sancionado por" )
AWarn.Localization:AddDefinition( language_code, "warningserver",				"Sancion del servidor" )
AWarn.Localization:AddDefinition( language_code, "warningreason",				"Motivo de sancion" )
AWarn.Localization:AddDefinition( language_code, "warningdate",					"Fecha" )
AWarn.Localization:AddDefinition( language_code, "nothing",						"NADA" )
AWarn.Localization:AddDefinition( language_code, "submit",						"Enviar" )
AWarn.Localization:AddDefinition( language_code, "connectedplayers",			"Jugadores conectados" )
AWarn.Localization:AddDefinition( language_code, "displaywarningsfor",			"Mostrandos sanciones de" )
AWarn.Localization:AddDefinition( language_code, "activewarnings",				"Sanciones activas" )
AWarn.Localization:AddDefinition( language_code, "selectedplayernowarnings",	"El jugador seleccionado no tiene un historial." )
AWarn.Localization:AddDefinition( language_code, "selectplayerseewarnings",		"Selecciona un jugador para ver sus sanciones." )
AWarn.Localization:AddDefinition( language_code, "warnplayer",					"Sancionar jugador" )
AWarn.Localization:AddDefinition( language_code, "reduceactiveby1",				"Reducir sanciones activas a 1" )
AWarn.Localization:AddDefinition( language_code, "playerwarningmenu",			"Menu de sanciones del jugador" )
AWarn.Localization:AddDefinition( language_code, "playersearchmenu",			"Menu de busqueda de jugadores" )
AWarn.Localization:AddDefinition( language_code, "warningplayer",				"Sancionando jugador" )
AWarn.Localization:AddDefinition( language_code, "excludeplayers",				"Excluir jugadores sin historial de sanciones" )
AWarn.Localization:AddDefinition( language_code, "searchforplayers",			"Busca jugadores por nombres o por SteamID64" )
AWarn.Localization:AddDefinition( language_code, "name",						"Nombre" )
AWarn.Localization:AddDefinition( language_code, "lastplayed",					"Ultima partida" )
AWarn.Localization:AddDefinition( language_code, "lastwarned",					"Ultima sancion" )
AWarn.Localization:AddDefinition( language_code, "never",						"Nunca" )
AWarn.Localization:AddDefinition( language_code, "playerid",					"ID Jugador" )
AWarn.Localization:AddDefinition( language_code, "lookupplayerwarnings",		"Buscar sanciones de este jugador" )
AWarn.Localization:AddDefinition( language_code, "servername",					"Nombre del servidor" )
AWarn.Localization:AddDefinition( language_code, "clientjoinmessage",			"Mostrar conteo de advertencia al jugador en unirse" )
AWarn.Localization:AddDefinition( language_code, "adminjoinmessage",			"Mostrar mensaje a los administradores cuando el jugador se une con advertencias" )
AWarn.Localization:AddDefinition( language_code, "punishmentoptions",			"Castigos" )
AWarn.Localization:AddDefinition( language_code, "kickpunishdescription",		"Si está habilitado, AWarn3 puede expulsar a los jugadores del servidor como castigo." )
AWarn.Localization:AddDefinition( language_code, "banpunishdescription",		"Si está habilitado, AWarn3 puede prohibir a los jugadores del servidor como castigo." )
AWarn.Localization:AddDefinition( language_code, "enabledecaydescription",		"Si está habilitado, las advertencias activas desaparecerán con el tiempo." )
AWarn.Localization:AddDefinition( language_code, "reasonrequireddescription",	"Si está habilitado, los administradores deberán proporcionar un motivo en su advertencia." )
AWarn.Localization:AddDefinition( language_code, "resetafterbandescription",	"Si está habilitado, las advertencias activas de un usuario se restablecerán a 0 después de que sean prohibidas por AWarn3." )
AWarn.Localization:AddDefinition( language_code, "logevents",					"Registrar eventos de advertencia." )
AWarn.Localization:AddDefinition( language_code, "logeventsdescription",		"Si está habilitado, las acciones dentro de AWarn3 se registrarán en un archivo de texto." )
AWarn.Localization:AddDefinition( language_code, "allowwarnadminsdescription",	"Si está habilitado, los administradores podrán advertir a otros administradores." )
AWarn.Localization:AddDefinition( language_code, "clientjoinmessagedescription","Si está habilitado, los usuarios que se unan al servidor verán un mensaje en el chat si tienen advertencias." )
AWarn.Localization:AddDefinition( language_code, "adminjoinmessagedescription",	"Si está habilitado, los administradores del servidor verán cuándo se une algún jugador que tenga advertencias." )
AWarn.Localization:AddDefinition( language_code, "chatprefixdescription",		"El comando de chat utilizado para los comandos de AWarn3. Predeterminado: !warn" )
AWarn.Localization:AddDefinition( language_code, "warningdecayratedescription",	"El tiempo (en minutos) que un jugador necesita estar conectado para que 1 advertencia activa decaiga." )
AWarn.Localization:AddDefinition( language_code, "servernamedescription",		"El nombre de este servidor. Esto es útil para configuraciones de múltiples servidores." )
AWarn.Localization:AddDefinition( language_code, "selectlanguagedescription",	"Este es el idioma en el que se mostrarán los mensajes del servidor." )
AWarn.Localization:AddDefinition( language_code, "theme",						"Tema de la interfaz" )
AWarn.Localization:AddDefinition( language_code, "themeselect",					"Seleccione el tema" )
AWarn.Localization:AddDefinition( language_code, "punishgroup",					"Grupo de castigo" )
AWarn.Localization:AddDefinition( language_code, "grouptoset",					"Agrupar para configurar" )
AWarn.Localization:AddDefinition( language_code, "viewnotes",					"Ver notas del jugador" )
AWarn.Localization:AddDefinition( language_code, "playernotes",					"Notas del jugador" )
AWarn.Localization:AddDefinition( language_code, "interfacecustomizations",		"Personalizaciones de interfaz" )
AWarn.Localization:AddDefinition( language_code, "enableblur",					"Habilitar desenfoque de fondo" )
AWarn.Localization:AddDefinition( language_code, "chooseapreset",				"Elija un ajuste preestablecido (opcional)" )
AWarn.Localization:AddDefinition( language_code, "warningpresets",				"Preajustes" )
AWarn.Localization:AddDefinition( language_code, "addeditpreset",				"Agregar/editar preajuste" )
AWarn.Localization:AddDefinition( language_code, "presetname",					"Nombre preestablecido" )
AWarn.Localization:AddDefinition( language_code, "presetreason",				"Razón preestablecida" )



--PATH addons/[admin] awarn3/lua/localizations/zh-cn.lua:
local language_code = "zh-CN"

--[[Chinese translation by 老子名叫李*天]]--
--https://www.gmodstore.com/users/76561198101134284

AWarn.Localization:RegisterLanguage( language_code, "Simplified Chinese" )

AWarn.Localization:AddDefinition( language_code, "welcome1", 					"欢迎来到AWarn3!" )
AWarn.Localization:AddDefinition( language_code, "insufficientperms", 			"没有足够权限" )
AWarn.Localization:AddDefinition( language_code, "insufficientperms2", 			"没有足够权限查看这个玩家的警告" )
AWarn.Localization:AddDefinition( language_code, "commandnonexist", 			"这个指令不存在" )
AWarn.Localization:AddDefinition( language_code, "invalidtargetid", 			"无效的对象或ID" )
AWarn.Localization:AddDefinition( language_code, "invalidtarget", 				"无效的对象" )
AWarn.Localization:AddDefinition( language_code, "reasonrequired", 				"需要警告理由" )
AWarn.Localization:AddDefinition( language_code, "remove1activewarn", 			"你从中删除了一个警告" )
AWarn.Localization:AddDefinition( language_code, "deletedwarningid", 			"删除警告ID" )
AWarn.Localization:AddDefinition( language_code, "removeallwarnings", 			"你从中移除了所有警告" )
AWarn.Localization:AddDefinition( language_code, "deletedwarningsfor", 			"为...删除所有警告" )
AWarn.Localization:AddDefinition( language_code, "cantopenconsole", 			"你不能从服务器控制台打开这个目录." )
AWarn.Localization:AddDefinition( language_code, "invalidoption", 				"无效设置." )
AWarn.Localization:AddDefinition( language_code, "invalidoptionvaluetype",		"无效的设置类型" )
AWarn.Localization:AddDefinition( language_code, "optionsloaded",				"配置加载完毕" )
AWarn.Localization:AddDefinition( language_code, "nopunishment",				"对此警告不做惩罚." )
AWarn.Localization:AddDefinition( language_code, "punishmentsloaded",			"惩罚已加载完毕" )
AWarn.Localization:AddDefinition( language_code, "playernotallowedwarn",		"这位玩家不允许被警告" )
AWarn.Localization:AddDefinition( language_code, "warnmessage1",				"你因 %s 被 %s 警告." )
AWarn.Localization:AddDefinition( language_code, "warnmessage2",				"你因 %s 被 %s 警告" )
AWarn.Localization:AddDefinition( language_code, "warnmessage3",				"%s 被 %s 警告因为 %s" )
AWarn.Localization:AddDefinition( language_code, "warnmessage4",				"你因 %s 被." )
AWarn.Localization:AddDefinition( language_code, "warnmessage5",				"你因 %s 被." )
AWarn.Localization:AddDefinition( language_code, "warnmessage6",				"%s 被 %s 警告" )
AWarn.Localization:AddDefinition( language_code, "joinmessage1",				"某人带着警告进入服务器" )
AWarn.Localization:AddDefinition( language_code, "joinmessage2",				"他们的最后一条警告是" )
AWarn.Localization:AddDefinition( language_code, "joinmessage3",				"欢迎回到服务器! 这个显示了你上次的警告" )
AWarn.Localization:AddDefinition( language_code, "joinmessage4",				"你可以随时在聊天栏查看你的警告" )
AWarn.Localization:AddDefinition( language_code, "closemenu",					"关闭目录" )
AWarn.Localization:AddDefinition( language_code, "searchplayers",				"搜索玩家" )
AWarn.Localization:AddDefinition( language_code, "viewwarnings",				"查看警告" )
AWarn.Localization:AddDefinition( language_code, "configuration",				"配置" )
AWarn.Localization:AddDefinition( language_code, "clientoptions",				"用户设置" )
AWarn.Localization:AddDefinition( language_code, "serveroptions",				"服务器设置" )
AWarn.Localization:AddDefinition( language_code, "colorcustomization",			"颜色定制" )
AWarn.Localization:AddDefinition( language_code, "colorselection",				"颜色选择" )
AWarn.Localization:AddDefinition( language_code, "languageconfiguration",		"自定义语言" )
AWarn.Localization:AddDefinition( language_code, "selectlanguage",				"选择一个语言" )
AWarn.Localization:AddDefinition( language_code, "enablekickpunish",			"启用kick处罚" )
AWarn.Localization:AddDefinition( language_code, "enablebanpunish",				"启用ban处罚" )
AWarn.Localization:AddDefinition( language_code, "enabledecay",					"启用警告消退时间" )
AWarn.Localization:AddDefinition( language_code, "resetafterban",				"在ban后重设警告" )
AWarn.Localization:AddDefinition( language_code, "allowwarnadmins",				"允许警告管理" )
AWarn.Localization:AddDefinition( language_code, "pressenter",					"按下enter保存改变" )
AWarn.Localization:AddDefinition( language_code, "entertosave",					"按enter" )
AWarn.Localization:AddDefinition( language_code, "chatprefix",					"聊天前缀" )
AWarn.Localization:AddDefinition( language_code, "warningdecayrate",			"警告消退时间 (分钟)" )
AWarn.Localization:AddDefinition( language_code, "serverlanguage",				"服务器语言" )
AWarn.Localization:AddDefinition( language_code, "punishmentsconfiguration",	"惩罚配置" )
AWarn.Localization:AddDefinition( language_code, "addpunishment",				"添加一个惩罚配置" )
AWarn.Localization:AddDefinition( language_code, "warnings",					"警告" )
AWarn.Localization:AddDefinition( language_code, "punishtype",					"惩罚类型" )
AWarn.Localization:AddDefinition( language_code, "punishlength",				"惩罚时间" )
AWarn.Localization:AddDefinition( language_code, "playermessage",				"玩家信息" )
AWarn.Localization:AddDefinition( language_code, "playername",					"玩家姓名" )
AWarn.Localization:AddDefinition( language_code, "messagetoplayer",				"给玩家发信息" )
AWarn.Localization:AddDefinition( language_code, "servermessage",				"服务器信息" )
AWarn.Localization:AddDefinition( language_code, "messagetoserver",				"给服务器发信息" )
AWarn.Localization:AddDefinition( language_code, "deletewarning",				"删除警告" )
AWarn.Localization:AddDefinition( language_code, "punishaddmenu",				"惩罚加入菜单" )
AWarn.Localization:AddDefinition( language_code, "inminutes",					"几分钟后" )
AWarn.Localization:AddDefinition( language_code, "0equalperma",					"0 = 永久" )
AWarn.Localization:AddDefinition( language_code, "use%",						"使用 %s 展示玩家的名称" )
AWarn.Localization:AddDefinition( language_code, "setdefault",					"默认设置" )
AWarn.Localization:AddDefinition( language_code, "showingownwarnings",			"显示你自己的警告" )
AWarn.Localization:AddDefinition( language_code, "warnedby",					"被警告" )
AWarn.Localization:AddDefinition( language_code, "warningserver",				"警告的服务器" )
AWarn.Localization:AddDefinition( language_code, "warningreason",				"警告理由" )
AWarn.Localization:AddDefinition( language_code, "warningdate",					"警告日期" )
AWarn.Localization:AddDefinition( language_code, "nothing",						"什么都没有" )
AWarn.Localization:AddDefinition( language_code, "submit",						"提交" )
AWarn.Localization:AddDefinition( language_code, "connectedplayers",			"已经连接服务器的玩家" )
AWarn.Localization:AddDefinition( language_code, "displaywarningsfor",			"显示警告" )
AWarn.Localization:AddDefinition( language_code, "activewarnings",				"启用警告" )
AWarn.Localization:AddDefinition( language_code, "selectedplayernowarnings",	"选出在记录上没有警告的玩家." )
AWarn.Localization:AddDefinition( language_code, "selectplayerseewarnings",		"选择一个玩家以查看其警告" )
AWarn.Localization:AddDefinition( language_code, "warnplayer",					"警告玩家" )
AWarn.Localization:AddDefinition( language_code, "reduceactiveby1",				"减少启用中的警告数量至1个" )
AWarn.Localization:AddDefinition( language_code, "playerwarningmenu",			"玩家警告目录" )
AWarn.Localization:AddDefinition( language_code, "playersearchmenu",			"玩家搜索目录" )
AWarn.Localization:AddDefinition( language_code, "warningplayer",				"警告中的玩家" )
AWarn.Localization:AddDefinition( language_code, "excludeplayers",				"包括没有警告历史的玩家" )
AWarn.Localization:AddDefinition( language_code, "searchforplayers",			"通过玩家名称或者steam64位ID搜索玩家" )
AWarn.Localization:AddDefinition( language_code, "name",						"名称" )
AWarn.Localization:AddDefinition( language_code, "lastplayed",					"最后游玩" )
AWarn.Localization:AddDefinition( language_code, "lastwarned",					"最后的警告" )
AWarn.Localization:AddDefinition( language_code, "never",						"绝不" )
AWarn.Localization:AddDefinition( language_code, "playerid",					"玩家 ID" )
AWarn.Localization:AddDefinition( language_code, "lookupplayerwarnings",		"查阅这位玩家的警告" )
AWarn.Localization:AddDefinition( language_code, "servername",					"服务器名称" )
AWarn.Localization:AddDefinition( language_code, "clientjoinmessage",			"加入时向玩家显示警告计数" )
AWarn.Localization:AddDefinition( language_code, "adminjoinmessage",			"当玩家加入警告时向管理员显示消息" )
AWarn.Localization:AddDefinition( language_code, "punishmentoptions",			"处罚" )
AWarn.Localization:AddDefinition( language_code, "kickpunishdescription",		"如果启用，作为惩罚，AWarn3 可以将玩家踢出服务器。" )
AWarn.Localization:AddDefinition( language_code, "banpunishdescription",		"如果启用，作为惩罚，AWarn3 可以禁止玩家进入服务器。" )
AWarn.Localization:AddDefinition( language_code, "enabledecaydescription",		"如果启用，活动警告将随着时间的推移而衰减。" )
AWarn.Localization:AddDefinition( language_code, "reasonrequireddescription",	"如果启用，管理员将需要在警告中提供原因。" )
AWarn.Localization:AddDefinition( language_code, "resetafterbandescription",	"如果启用，用户的活动警告在被 AWarn3 禁止后将重置为 0。" )
AWarn.Localization:AddDefinition( language_code, "logevents",					"记录警告事件。" )
AWarn.Localization:AddDefinition( language_code, "logeventsdescription",		"如果启用，则 AWarn3 中的操作将被记录到文本文件中。" )
AWarn.Localization:AddDefinition( language_code, "allowwarnadminsdescription",	"如果启用，管理员将能够警告其他管理员。" )
AWarn.Localization:AddDefinition( language_code, "clientjoinmessagedescription","如果启用，加入服务器的用户将在收到警告时在聊天中看到一条消息。" )
AWarn.Localization:AddDefinition( language_code, "adminjoinmessagedescription",	"如果启用，服务器上的管理员将看到任何有警告的玩家加入。" )
AWarn.Localization:AddDefinition( language_code, "chatprefixdescription",		"用于 AWarn3 命令的 chat 命令。 默认值： ！warn" )
AWarn.Localization:AddDefinition( language_code, "warningdecayratedescription",	"玩家需要连接的时间（以分钟为单位）才能使 1 个主动警告衰减。" )
AWarn.Localization:AddDefinition( language_code, "servernamedescription",		"此服务器的名称。 这对于多服务器设置很有用。" )
AWarn.Localization:AddDefinition( language_code, "selectlanguagedescription",	"这是服务器消息将使用的语言。" )
AWarn.Localization:AddDefinition( language_code, "theme",						"界面主题" )
AWarn.Localization:AddDefinition( language_code, "themeselect",					"选择主题" )
AWarn.Localization:AddDefinition( language_code, "punishgroup",					"惩戒组" )
AWarn.Localization:AddDefinition( language_code, "grouptoset",					"要设置的组" )
AWarn.Localization:AddDefinition( language_code, "viewnotes",					"查看玩家笔记" )
AWarn.Localization:AddDefinition( language_code, "playernotes",					"玩家笔记" )
AWarn.Localization:AddDefinition( language_code, "interfacecustomizations",		"界面定制" )
AWarn.Localization:AddDefinition( language_code, "enableblur",					"启用背景模糊" )
AWarn.Localization:AddDefinition( language_code, "chooseapreset",				"选择预设（可选）" )
AWarn.Localization:AddDefinition( language_code, "warningpresets",				"预设" )
AWarn.Localization:AddDefinition( language_code, "addeditpreset",				"添加/编辑预设" )
AWarn.Localization:AddDefinition( language_code, "presetname",					"预设名称" )
AWarn.Localization:AddDefinition( language_code, "presetreason",				"预设原因" )

--PATH addons/[admin] awarn3/lua/includes/sh_awarn3.lua:
return gluapack()()
--PATH addons/[admin] awarn3/lua/includes/awarn3_concommands.lua:
return gluapack()()
--PATH addons/[admin] awarn3/lua/includes/awarn3_permissions.lua:
return gluapack()()
--PATH addons/[admin] awarn3/lua/includes/vgui/aw3_menu_configuration_settings.lua:
AddCSLuaFile()

local logoImage = Material( "materials/vgui/awlogo.png", "noclamp smooth" )
local playerWarningsImage = Material( "materials/vgui/awarn3_playerwarnings.png", "noclamp smooth" )
local optionsImage = Material( "materials/vgui/aw3_options.png", "noclamp smooth" )
local deleteImage = Material( "materials/vgui/awarn3_delete.png", "noclamp smooth" )
local minusImage = Material( "materials/vgui/awarn3_minus.png", "noclamp smooth" )
local searchImage = Material( "materials/vgui/awarn3_search.png", "noclamp smooth" )
local punishmentOptionsImage = Material( "materials/vgui/aw3_punishment_options.png", "noclamp smooth" )
local serverOptionsImage = Material( "materials/vgui/aw3_server_options.png", "noclamp smooth" )
local userOptionsImage = Material( "materials/vgui/aw3_user_options.png", "noclamp smooth" )
local closeImage = Material( "materials/vgui/aw3_close.png", "noclamp smooth" )
local xImage = Material( "materials/vgui/aw3_x.png", "noclamp smooth" )

local function ScrWM()
	local wid = ScrW()
	if wid > 3840 then wid = 3840 end
	return wid
end

local function ScrHM()
	local hgt = ScrH()
	if hgt > 2160 then hgt = 2160 end
	return hgt
end

local function ScreenScale( size )
	return size * ( ScrWM() / 640.0 )	
end

local screenscale = ScreenScale( 0.4 )

local PANEL = {}
function PANEL:Init()
	self:SetDraggable( false )
	self:SetTitle( "" )
	self:ShowCloseButton( false )
	
end
function PANEL:Paint()
	--Render Invisible
	surface.SetDrawColor( 200, 100, 100, 0 )
	surface.DrawRect( 0, 0, self:GetWide(), self:GetTall() )
	
end
function PANEL:DrawElements()

	AWarn.punishmentCreationFields = {}

	local SettingsButtonsDock = vgui.Create( "DPanel", self )
	SettingsButtonsDock:SetWide( 80 * screenscale )
	SettingsButtonsDock:DockMargin( 4 * screenscale, -17, 0, 73 * screenscale)
	SettingsButtonsDock:DockPadding( 0, 4 * screenscale, 3 * screenscale, 0 )
	SettingsButtonsDock.Paint = function()
		surface.SetDrawColor( AWarn.Colors.COLOR_THEME_PRIMARY )
		surface.DrawRect( 0, 0, SettingsButtonsDock:GetWide() - 3 * screenscale, SettingsButtonsDock:GetTall() - 3 * screenscale )

		surface.SetDrawColor( AWarn.Colors.COLOR_THEME_PRIMARY_SHADOW )
		surface.DrawRect( SettingsButtonsDock:GetWide() - 3 * screenscale, 0, 3 * screenscale, SettingsButtonsDock:GetTall() - 1 )
		surface.DrawRect( 0, SettingsButtonsDock:GetTall() - 3 * screenscale, SettingsButtonsDock:GetWide() - 3 * screenscale, 3 * screenscale )
	end
	SettingsButtonsDock:Dock( LEFT )

	local navButton = vgui.Create( "awarn3_navbutton_settings", SettingsButtonsDock )
	navButton:SetText(AWarn.Localization:GetTranslation( "clientoptions" ))
	navButton:SetIcon( userOptionsImage )
	navButton:SetEnabled( true )
	navButton.OnSelected = function()
		self.UserSettingsMenuDock:Show()
		if AWarn:CheckPermission( LocalPlayer(), "awarn_options" ) then
			self.ServerSettingsMenuDock:Hide()
			self.PunishmentsSettingsMenuDock:Hide()
			self.PresetsMenuDock:Hide()
		end
	end
	AWarn.lastSelectedSettingsButton = navButton

	if AWarn:CheckPermission( LocalPlayer(), "awarn_options" ) then
		local navButton = vgui.Create( "awarn3_navbutton_settings", SettingsButtonsDock )
		navButton:SetText(AWarn.Localization:GetTranslation( "serveroptions" ))
		navButton:SetIcon( serverOptionsImage )
		navButton:SetEnabled( false )
		navButton.OnSelected = function()
			self.UserSettingsMenuDock:Hide()
			self.ServerSettingsMenuDock:Show()	
			self.PunishmentsSettingsMenuDock:Hide()	
			self.PresetsMenuDock:Hide()
		end

		local navButton = vgui.Create( "awarn3_navbutton_settings", SettingsButtonsDock )
		navButton:SetText(AWarn.Localization:GetTranslation( "punishmentoptions" ))
		navButton:SetIcon( punishmentOptionsImage )
		navButton:SetEnabled( false )
		navButton.OnSelected = function()
			self.UserSettingsMenuDock:Hide()
			self.ServerSettingsMenuDock:Hide()
			self.PunishmentsSettingsMenuDock:Show()
			self.PresetsMenuDock:Hide()
		end

		local navButton = vgui.Create( "awarn3_navbutton_settings", SettingsButtonsDock )
		navButton:SetText(AWarn.Localization:GetTranslation( "warningpresets" ))
		navButton:SetIcon( optionsImage )
		navButton:SetEnabled( false )
		navButton.OnSelected = function()
			self.UserSettingsMenuDock:Hide()
			self.ServerSettingsMenuDock:Hide()
			self.PunishmentsSettingsMenuDock:Hide()
			self.PresetsMenuDock:Show()
		end
	end

	self.SettingsMenuDockMain = vgui.Create( "DPanel", self )
	self.SettingsMenuDockMain:DockMargin(8, -17, 3, 73 * screenscale)
	self.SettingsMenuDockMain:DockPadding( 0, 0, 0, 0 )
	self.SettingsMenuDockMain.Paint = function()
		--surface.SetDrawColor( Color(255,0,0,200) )
		surface.DrawRect( 0, 0, self.SettingsMenuDockMain:GetWide(), self.SettingsMenuDockMain:GetTall() )
	end
	self.SettingsMenuDockMain:Dock( FILL )

	self.UserSettingsMenuDock = vgui.Create( "DPanel", self.SettingsMenuDockMain )
	self.UserSettingsMenuDock:DockMargin( 0,0,0,0 )
	self.UserSettingsMenuDock:DockPadding( 0, 10, 0, 0 )
	self.UserSettingsMenuDock.Paint = function()
		surface.SetDrawColor( AWarn.Colors.COLOR_THEME_PRIMARY )
		surface.DrawRect( 0, 0, self.SettingsMenuDockMain:GetWide() - 3 * screenscale, self.SettingsMenuDockMain:GetTall() - 3 * screenscale )

		surface.SetDrawColor( AWarn.Colors.COLOR_THEME_PRIMARY_SHADOW )
		surface.DrawRect( self.SettingsMenuDockMain:GetWide() - 3 * screenscale, 0, 3 * screenscale, self.SettingsMenuDockMain:GetTall() - 1 )
		surface.DrawRect( 0, self.SettingsMenuDockMain:GetTall() - 3 * screenscale, self.SettingsMenuDockMain:GetWide() - 3, 3 * screenscale )
	end
	self.UserSettingsMenuDock:Dock( FILL )
	
	self.ServerSettingsMenuDock = vgui.Create( "DScrollPanel", self.SettingsMenuDockMain )
	self.ServerSettingsMenuDock:DockMargin( 0,0,4*screenscale,0 )
	self.ServerSettingsMenuDock:DockPadding( 0, 10, 0, 10 )
	self.ServerSettingsMenuDock:GetCanvas():DockMargin( 0, 50*screenscale, 0, 150 * screenscale )
	
	
	self.ServerSettingsMenuDock.Paint = function()
		surface.SetDrawColor( AWarn.Colors.COLOR_THEME_PRIMARY )
		surface.DrawRect( 0, 0, self.SettingsMenuDockMain:GetWide() - 3 * screenscale, self.SettingsMenuDockMain:GetTall() - 3 * screenscale )

		surface.SetDrawColor( AWarn.Colors.COLOR_THEME_PRIMARY_SHADOW )
		surface.DrawRect( self.SettingsMenuDockMain:GetWide() - 3 * screenscale, 0, 3 * screenscale, self.SettingsMenuDockMain:GetTall() - 1 )
		surface.DrawRect( 0, self.SettingsMenuDockMain:GetTall() - 3 * screenscale, self.SettingsMenuDockMain:GetWide() - 3, 3 * screenscale )
	end
	self.ServerSettingsMenuDock:Dock( FILL )
	self.ServerSettingsMenuDock:Hide()
	
	local ScrollBar = self.ServerSettingsMenuDock:GetVBar()
	ScrollBar:SetHideButtons( true )
	ScrollBar:SetWidth( 6 * screenscale )
	function ScrollBar:Paint( w, h )
		surface.SetDrawColor( 0, 0, 0, 0 )
		surface.DrawRect( 0, 0, w, h )
	end
	function ScrollBar.btnGrip:Paint( w, h )
		surface.SetDrawColor( AWarn.Colors.COLOR_SELECTED )
		surface.DrawRect( 0, 0, w, h )
	end

	self.PunishmentsSettingsMenuDock = vgui.Create( "DPanel", self.SettingsMenuDockMain )
	self.PunishmentsSettingsMenuDock:DockMargin( 0,0,0,0 )
	self.PunishmentsSettingsMenuDock:DockPadding( 0, 0, 0, 0 )
	self.PunishmentsSettingsMenuDock.Paint = function()
		--Render Invisible
		--surface.SetDrawColor( Color(0,255,0,100) )
		--surface.DrawRect( 0, 0, self.PunishmentsSettingsMenuDock:GetWide(), self.PunishmentsSettingsMenuDock:GetTall() )
	end
	self.PunishmentsSettingsMenuDock:Dock( FILL )
	self.PunishmentsSettingsMenuDock:Hide()
	

	self.PresetsMenuDock = vgui.Create( "DPanel", self.SettingsMenuDockMain )
	self.PresetsMenuDock:DockMargin( 0,0,0,0 )
	self.PresetsMenuDock:DockPadding( 0, 0, 0, 0 )
	self.PresetsMenuDock.Paint = function()
		--Render Invisible
		--surface.SetDrawColor( Color(0,255,0,100) )
		--surface.DrawRect( 0, 0, self.PresetsMenuDock:GetWide(), self.PresetsMenuDock:GetTall() )
	end
	self.PresetsMenuDock:Dock( FILL )
	self.PresetsMenuDock:Hide()
	
	
	--Client Options
	
	local optionLabel = vgui.Create( "awarn3_configlabel", self.UserSettingsMenuDock )
	optionLabel:SetText( AWarn.Localization:GetTranslation( "languageconfiguration" ) )
	optionLabel:DockMargin( 10, 10 * screenscale, 0, 15 )
	optionLabel:Dock( TOP )
	
	local LanguageOptionsPanel = vgui.Create( "DPanel", self.UserSettingsMenuDock )
	LanguageOptionsPanel:DockPadding( 20, 0, 30 * screenscale, 0 )
	LanguageOptionsPanel.Paint = function()
		--Render Invisible
		--surface.SetDrawColor( 200, 200, 120, 0 )
		--surface.DrawRect( 0, 0, self:GetWide(), self:GetTall() )
	end
	LanguageOptionsPanel:SetHeight( 20 * screenscale )
	LanguageOptionsPanel:Dock( TOP )
	LanguageOptionsPanel:InvalidateParent( true )
	
	local comboBox = vgui.Create( "DComboBox", LanguageOptionsPanel )
	comboBox:SetWidth(180)
	comboBox:SetFont("AWarn3Label2")
	comboBox:SetValue( AWarn.SelectedLanguage or "EN-US")
	
	for k, v in pairs( AWarn.Localization.Languages ) do
		comboBox:AddChoice( AWarn.Localization.LangCodes[k], k )
	end	
	function comboBox:OnSelect( index, text, data )
		AWarn.SelectedLanguage = data
		comboBox:SetValue( data )
		LocalPlayer():SetPData( "awarn3_lang", data )
	end
	comboBox:Dock( RIGHT )
	
	local languageLabel = vgui.Create( "awarn3_configlabel", LanguageOptionsPanel )
	languageLabel:SetText( AWarn.Localization:GetTranslation( "selectlanguage" ) )
	languageLabel:SetFont( "AWarn3Label2" )
	languageLabel:Dock( FILL )
	languageLabel:SetWidth( 100 )
	
	local hdiv = vgui.Create( "awarn3_hdiv", self.UserSettingsMenuDock )
	hdiv:Dock( TOP )
	
	local optionLabel = vgui.Create( "awarn3_configlabel", self.UserSettingsMenuDock )
	optionLabel:SetText( AWarn.Localization:GetTranslation( "theme" ) )
	optionLabel:DockMargin( 10, 10 * screenscale, 0, 15 )
	optionLabel:Dock( TOP )
	
	local ThemeOptionsPanel = vgui.Create( "DPanel", self.UserSettingsMenuDock )
	ThemeOptionsPanel:DockPadding( 20, 0, 30 * screenscale, 0 )
	ThemeOptionsPanel.Paint = function()
		--Render Invisible
		--surface.SetDrawColor( 200, 200, 120, 50 )
		--surface.DrawRect( 0, 0, self:GetWide(), self:GetTall() )
	end
	ThemeOptionsPanel:SetHeight( 20 * screenscale )
	ThemeOptionsPanel:Dock( TOP )
	ThemeOptionsPanel:InvalidateParent( true )
	
	local comboBox = vgui.Create( "DComboBox", ThemeOptionsPanel )
	comboBox:SetWidth(180)
	comboBox:SetFont("AWarn3Label2")
	comboBox:SetValue( AWarn.SelectedTheme or "Light")
	
	for k, v in pairs( AWarn:ReturnThemes() ) do
		comboBox:AddChoice( v.name )
	end	
	function comboBox:OnSelect( index, text, data )
		AWarn.SelectedTheme = text
		LocalPlayer():SetPData( "awarn3_theme", text )
		AWarn:SetTheme( text )
	end
	comboBox:Dock( RIGHT )
	
	local ThemeSelectLabel = vgui.Create( "awarn3_configlabel", ThemeOptionsPanel )
	ThemeSelectLabel:SetText( AWarn.Localization:GetTranslation( "themeselect" ) )
	ThemeSelectLabel:SetFont( "AWarn3Label2" )
	ThemeSelectLabel:Dock( FILL )
	ThemeSelectLabel:SetWidth( 100 )
	
	local hdiv = vgui.Create( "awarn3_hdiv", self.UserSettingsMenuDock )
	hdiv:Dock( TOP )
	
	local optionLabel = vgui.Create( "awarn3_configlabel", self.UserSettingsMenuDock )
	optionLabel:SetText( AWarn.Localization:GetTranslation( "interfacecustomizations" ) )
	optionLabel:DockMargin( 10, 10 * screenscale, 0, 15 )
	optionLabel:Dock( TOP )
	
	local BlurOptionPanel = vgui.Create( "DPanel", self.UserSettingsMenuDock )
	BlurOptionPanel:DockPadding( 20, 0, 30 * screenscale, 0 )
	BlurOptionPanel.Paint = function()
		--Render Invisible
		--surface.SetDrawColor( 200, 200, 120, 50 )
		--surface.DrawRect( 0, 0, self:GetWide(), self:GetTall() )
	end
	BlurOptionPanel:SetHeight( 32 * screenscale )
	BlurOptionPanel:Dock( TOP )
	BlurOptionPanel:InvalidateParent( true )
	
	local BlurSelectLabel = vgui.Create( "awarn3_configlabel", BlurOptionPanel )
	BlurSelectLabel:SetText( AWarn.Localization:GetTranslation( "enableblur" ) )
	BlurSelectLabel:SetFont( "AWarn3Label2" )
	BlurSelectLabel:Dock( FILL )
	BlurSelectLabel:SetWidth( 100 )
	
	self.chkBox = vgui.Create( "awarn3_customcheckbox", BlurOptionPanel )
	self.chkBox:SetSize(52 * screenscale, 36 * screenscale)
	self.chkBox:SetValue( 0 )
	self.chkBox:DockMargin( 0, 4 * screenscale , 52 * screenscale, 4 * screenscale )
	self.chkBox:Dock( RIGHT )
	self.chkBox:SetValue( LocalPlayer():GetPData( "awarn3_blurbackground", true ) )
	self.chkBox:SetTooltip( AWarn.Localization:GetTranslation( "enableblur" ) )
	
	function self.chkBox:OnChange( val )
		LocalPlayer():SetPData( "awarn3_blurbackground", val )
	end	
	
	
	
	
	
	--Server Options	
	
	local kickToggle = vgui.Create( "awarn3_toggleoption", self.ServerSettingsMenuDock )
	kickToggle:SetPrimaryText( AWarn.Localization:GetTranslation( "enablekickpunish" ) )
	kickToggle:SetSecondaryText( AWarn.Localization:GetTranslation( "kickpunishdescription" ) )
	kickToggle:SetOptionString( "awarn_kick" )
	kickToggle:Dock( TOP )
	kickToggle:DrawElements()
	
	local hdiv = vgui.Create( "awarn3_hdiv", self.ServerSettingsMenuDock )
	hdiv:Dock( TOP )	
	
	local banToggle = vgui.Create( "awarn3_toggleoption", self.ServerSettingsMenuDock )
	banToggle:SetPrimaryText( AWarn.Localization:GetTranslation( "enablebanpunish" ) )
	banToggle:SetSecondaryText( AWarn.Localization:GetTranslation( "banpunishdescription" ) )
	banToggle:SetOptionString( "awarn_ban" )
	banToggle:Dock( TOP )
	banToggle:DrawElements()
	
	local hdiv = vgui.Create( "awarn3_hdiv", self.ServerSettingsMenuDock )
	hdiv:Dock( TOP )	
	
	local decayToggle = vgui.Create( "awarn3_toggleoption", self.ServerSettingsMenuDock )
	decayToggle:SetPrimaryText( AWarn.Localization:GetTranslation( "enabledecay" ) )
	decayToggle:SetSecondaryText( AWarn.Localization:GetTranslation( "enabledecaydescription" ) )
	decayToggle:SetOptionString( "awarn_decay" )
	decayToggle:Dock( TOP )
	decayToggle:DrawElements()
	
	local hdiv = vgui.Create( "awarn3_hdiv", self.ServerSettingsMenuDock )
	hdiv:Dock( TOP )	
	
	local reasonReqToggle = vgui.Create( "awarn3_toggleoption", self.ServerSettingsMenuDock )
	reasonReqToggle:SetPrimaryText( AWarn.Localization:GetTranslation( "reasonrequired" ) )
	reasonReqToggle:SetSecondaryText( AWarn.Localization:GetTranslation( "reasonrequireddescription" ) )
	reasonReqToggle:SetOptionString( "awarn_reasonrequired" )
	reasonReqToggle:Dock( TOP )
	reasonReqToggle:DrawElements()
	
	local hdiv = vgui.Create( "awarn3_hdiv", self.ServerSettingsMenuDock )
	hdiv:Dock( TOP )	
	
	local banWarnResetToggle = vgui.Create( "awarn3_toggleoption", self.ServerSettingsMenuDock )
	banWarnResetToggle:SetPrimaryText( AWarn.Localization:GetTranslation( "resetafterban" ) )
	banWarnResetToggle:SetSecondaryText( AWarn.Localization:GetTranslation( "resetafterbandescription" ) )
	banWarnResetToggle:SetOptionString( "awarn_reset_after_ban" )
	banWarnResetToggle:Dock( TOP )
	banWarnResetToggle:DrawElements()
	
	local hdiv = vgui.Create( "awarn3_hdiv", self.ServerSettingsMenuDock )
	hdiv:Dock( TOP )	
	
	local logEventsToggle = vgui.Create( "awarn3_toggleoption", self.ServerSettingsMenuDock )
	logEventsToggle:SetPrimaryText( AWarn.Localization:GetTranslation( "logevents" ) )
	logEventsToggle:SetSecondaryText( AWarn.Localization:GetTranslation( "logeventsdescription" ) )
	logEventsToggle:SetOptionString( "awarn_logging" )
	logEventsToggle:Dock( TOP )
	logEventsToggle:DrawElements()
	
	local hdiv = vgui.Create( "awarn3_hdiv", self.ServerSettingsMenuDock )
	hdiv:Dock( TOP )	
	
	local warnAdminsToggle = vgui.Create( "awarn3_toggleoption", self.ServerSettingsMenuDock )
	warnAdminsToggle:SetPrimaryText( AWarn.Localization:GetTranslation( "allowwarnadmins" ) )
	warnAdminsToggle:SetSecondaryText( AWarn.Localization:GetTranslation( "allowwarnadminsdescription" ) )
	warnAdminsToggle:SetOptionString( "awarn_allow_warn_admins" )
	warnAdminsToggle:Dock( TOP )
	warnAdminsToggle:DrawElements()
	
	local hdiv = vgui.Create( "awarn3_hdiv", self.ServerSettingsMenuDock )
	hdiv:Dock( TOP )
	
	local clientJoinMessageToggle = vgui.Create( "awarn3_toggleoption", self.ServerSettingsMenuDock )
	clientJoinMessageToggle:SetPrimaryText( AWarn.Localization:GetTranslation( "clientjoinmessage" ) )
	clientJoinMessageToggle:SetSecondaryText( AWarn.Localization:GetTranslation( "clientjoinmessagedescription" ) )
	clientJoinMessageToggle:SetOptionString( "awarn_joinmessageclient" )
	clientJoinMessageToggle:Dock( TOP )
	clientJoinMessageToggle:DrawElements()
	
	local hdiv = vgui.Create( "awarn3_hdiv", self.ServerSettingsMenuDock )
	hdiv:Dock( TOP )
	
	local adminJoinMessageToggle = vgui.Create( "awarn3_toggleoption", self.ServerSettingsMenuDock )
	adminJoinMessageToggle:SetPrimaryText( AWarn.Localization:GetTranslation( "adminjoinmessage" ) )
	adminJoinMessageToggle:SetSecondaryText( AWarn.Localization:GetTranslation( "adminjoinmessagedescription" ) )
	adminJoinMessageToggle:SetOptionString( "awarn_joinmessageadmin" )
	adminJoinMessageToggle:Dock( TOP )
	adminJoinMessageToggle:DrawElements()
	
	local hdiv = vgui.Create( "awarn3_hdiv", self.ServerSettingsMenuDock )
	hdiv:Dock( TOP )
	
	local removeWarningWhenDeleteWarningToggle = vgui.Create( "awarn3_toggleoption", self.ServerSettingsMenuDock )
	removeWarningWhenDeleteWarningToggle:SetPrimaryText( AWarn.Localization:GetTranslation( "removewhendeletewarning" ) )
	removeWarningWhenDeleteWarningToggle:SetSecondaryText( AWarn.Localization:GetTranslation( "removewhendeletewarningdescription" ) )
	removeWarningWhenDeleteWarningToggle:SetOptionString( "awarn_removewhendeletewarning" )
	removeWarningWhenDeleteWarningToggle:Dock( TOP )
	removeWarningWhenDeleteWarningToggle:DrawElements()
	
	local hdiv = vgui.Create( "awarn3_hdiv", self.ServerSettingsMenuDock )
	hdiv:Dock( TOP )
	
	local chatPrefixTextOption = vgui.Create( "awarn3_textoption", self.ServerSettingsMenuDock )
	chatPrefixTextOption:SetPrimaryText( AWarn.Localization:GetTranslation( "chatprefix" ) )
	chatPrefixTextOption:SetSecondaryText( AWarn.Localization:GetTranslation( "chatprefixdescription" ) )
	chatPrefixTextOption:SetOptionString( "awarn_chat_prefix" )
	chatPrefixTextOption:Dock( TOP )
	chatPrefixTextOption:StripSpaces( true )
	chatPrefixTextOption:DrawElements()
	
	local hdiv = vgui.Create( "awarn3_hdiv", self.ServerSettingsMenuDock )
	hdiv:Dock( TOP )
	
	local decayRateTextOption = vgui.Create( "awarn3_textoption", self.ServerSettingsMenuDock )
	decayRateTextOption:SetPrimaryText( AWarn.Localization:GetTranslation( "warningdecayrate" ) )
	decayRateTextOption:SetSecondaryText( AWarn.Localization:GetTranslation( "warningdecayratedescription" ) )
	decayRateTextOption:SetOptionString( "awarn_decayrate" )
	decayRateTextOption:Dock( TOP )
	decayRateTextOption:SetNumeric( true )
	decayRateTextOption:DrawElements()
	
	local hdiv = vgui.Create( "awarn3_hdiv", self.ServerSettingsMenuDock )
	hdiv:Dock( TOP )
	
	local serverNameTextOption = vgui.Create( "awarn3_textoption", self.ServerSettingsMenuDock )
	serverNameTextOption:SetPrimaryText( AWarn.Localization:GetTranslation( "servername" ) )
	serverNameTextOption:SetSecondaryText( AWarn.Localization:GetTranslation( "servernamedescription" ) )
	serverNameTextOption:SetOptionString( "awarn_server_name" )
	serverNameTextOption:Dock( TOP )
	serverNameTextOption:SetNumeric( false )
	serverNameTextOption:DrawElements()
	
	local hdiv = vgui.Create( "awarn3_hdiv", self.ServerSettingsMenuDock )
	hdiv:Dock( TOP )
	
	local serverLanguageComboOption = vgui.Create( "awarn3_combooption", self.ServerSettingsMenuDock )
	serverLanguageComboOption:SetPrimaryText( AWarn.Localization:GetTranslation( "selectlanguage" ) )
	serverLanguageComboOption:SetSecondaryText( AWarn.Localization:GetTranslation( "selectlanguagedescription" ) )
	serverLanguageComboOption:SetOptionString( "awarn_server_language" )
	serverLanguageComboOption:Dock( TOP )
	serverLanguageComboOption:SetOptionTable( AWarn.Localization.Languages )
	--serverLanguageComboOption.optionString = "awarn_server_language"
	serverLanguageComboOption:DrawElements()
	
	local hdiv = vgui.Create( "awarn3_hdiv", self.ServerSettingsMenuDock )
	hdiv:Dock( TOP )
	
	
	
	function AWarn:RefreshSettings()
		kickToggle:SetChecked( AWarn.Options.awarn_kick.value )
		banToggle:SetChecked( AWarn.Options.awarn_ban.value )
		decayToggle:SetChecked( AWarn.Options.awarn_decay.value )
		reasonReqToggle:SetChecked( AWarn.Options.awarn_reasonrequired.value )
		banWarnResetToggle:SetChecked( AWarn.Options.awarn_reset_after_ban.value )
		logEventsToggle:SetChecked( AWarn.Options.awarn_logging.value )
		warnAdminsToggle:SetChecked( AWarn.Options.awarn_allow_warn_admins.value )
		clientJoinMessageToggle:SetChecked( AWarn.Options.awarn_joinmessageclient.value )
		adminJoinMessageToggle:SetChecked( AWarn.Options.awarn_joinmessageadmin.value )
		removeWarningWhenDeleteWarningToggle:SetChecked( AWarn.Options.awarn_removewhendeletewarning.value )
		chatPrefixTextOption:SetValue( AWarn.Options.awarn_chat_prefix.value )
		decayRateTextOption:SetValue( AWarn.Options.awarn_decayrate.value )
		serverNameTextOption:SetValue( AWarn.Options.awarn_server_name.value )
		serverLanguageComboOption:SetValue( AWarn.Options.awarn_server_language.value )
	end
	
	local punishmentCardsPanel = vgui.Create( "DPanel", self.PunishmentsSettingsMenuDock)
	punishmentCardsPanel:Dock( FILL )
	punishmentCardsPanel:DockPadding( 0,5,0,10 )
	punishmentCardsPanel.Paint = function()
		surface.SetDrawColor( AWarn.Colors.COLOR_THEME_PRIMARY )
		surface.DrawRect( 0, 0, punishmentCardsPanel:GetWide() - 3 * screenscale, punishmentCardsPanel:GetTall() - 3 * screenscale )

		surface.SetDrawColor( AWarn.Colors.COLOR_THEME_PRIMARY_SHADOW )
		surface.DrawRect( punishmentCardsPanel:GetWide() - 3 * screenscale, 0, 3 * screenscale, punishmentCardsPanel:GetTall() - 1 )
		surface.DrawRect( 0, punishmentCardsPanel:GetTall() - 3 * screenscale, punishmentCardsPanel:GetWide() - 3 * screenscale, 3 * screenscale )
	end

	AWarn.menu.configurationview.PunishmentsCardsPanel = vgui.Create( "DScrollPanel", punishmentCardsPanel )
	AWarn.menu.configurationview.PunishmentsCardsPanel:Dock( FILL )
	AWarn.menu.configurationview.PunishmentsCardsPanel:DockPadding( 10,10,10,10 )
	AWarn.menu.configurationview.PunishmentsCardsPanel:GetCanvas():DockPadding( 0, 4 * screenscale, 4 * screenscale, 0 )
	AWarn.menu.configurationview.PunishmentsCardsPanel.Paint = function()
		--surface.SetDrawColor( Color(255,0,0,100) )
		--surface.DrawRect( 0, 0, AWarn.menu.configurationview.PunishmentsCardsPanel:GetWide() , AWarn.menu.configurationview.PunishmentsCardsPanel:GetTall() )
	end
		
	local ScrollBar = AWarn.menu.configurationview.PunishmentsCardsPanel:GetVBar()
	ScrollBar:SetHideButtons( true )
	ScrollBar:SetWidth( 6 * screenscale )
	function ScrollBar:Paint( w, h )
		surface.SetDrawColor( 0, 0, 0, 0 )
		surface.DrawRect( 0, 0, w, h )
	end
	function ScrollBar.btnGrip:Paint( w, h )
		surface.SetDrawColor( AWarn.Colors.COLOR_SELECTED )
		surface.DrawRect( 0, 0, w, h )
	end
	
	local punishmentCreationDock = vgui.Create( "DPanel", self.PunishmentsSettingsMenuDock)
	punishmentCreationDock:DockMargin( 0, 5 * screenscale, 0, 0 )
	punishmentCreationDock:Dock( BOTTOM )
	punishmentCreationDock:SetHeight( 195 * screenscale )
	punishmentCreationDock.Paint = function()
		--surface.SetDrawColor( Color(100,0,0,100) )
		--surface.DrawRect( 0, 0, punishmentCreationDock:GetWide() , punishmentCreationDock:GetTall() )
	end
	
	local punishmentCreationTypePanel = vgui.Create( "DPanel", punishmentCreationDock)
	punishmentCreationTypePanel:DockMargin( 0, 0, 5 * screenscale, 0 )
	punishmentCreationTypePanel:DockPadding( 10 * screenscale, 10 * screenscale, 10 * screenscale, 10 * screenscale )
	punishmentCreationTypePanel:SetWidth( 400 * screenscale )
	punishmentCreationTypePanel:Dock( LEFT )
	punishmentCreationTypePanel.Paint = function()
		surface.SetDrawColor( AWarn.Colors.COLOR_THEME_PRIMARY )
		surface.DrawRect( 0, 0, punishmentCreationTypePanel:GetWide() - 3 * screenscale, punishmentCreationTypePanel:GetTall() - 3 * screenscale )

		surface.SetDrawColor( AWarn.Colors.COLOR_THEME_PRIMARY_SHADOW )
		surface.DrawRect( punishmentCreationTypePanel:GetWide() - 3 * screenscale, 0, 3 * screenscale, punishmentCreationTypePanel:GetTall() - 1 )
		surface.DrawRect( 0, punishmentCreationTypePanel:GetTall() - 3 * screenscale, punishmentCreationTypePanel:GetWide() - 3 * screenscale, 3 * screenscale )
	end	
	
	local Label = vgui.Create( "awarn3_configlabel", punishmentCreationTypePanel )
	Label:SetText( AWarn.Localization:GetTranslation( "punishtype" ) )
	Label:DockMargin( 0, 0, 0, 6 * screenscale )
	Label:Dock( TOP )
	
	AWarn.punishmentCreationFields.pTypeDropdown = vgui.Create( "DComboBox", punishmentCreationTypePanel )
	AWarn.punishmentCreationFields.pTypeDropdown:SetValue( "Kick" )
	AWarn.punishmentCreationFields.pTypeDropdown:AddChoice( "Kick" )
	AWarn.punishmentCreationFields.pTypeDropdown:AddChoice( "Ban" )
	if CAMI then
		AWarn.punishmentCreationFields.pTypeDropdown:AddChoice( "Group" )
	end
	AWarn.punishmentCreationFields.pTypeDropdown:AddChoice( "Command" )
	
	AWarn.punishmentCreationFields.pTypeDropdown:SetHeight( 26 * screenscale )
	AWarn.punishmentCreationFields.pTypeDropdown:Dock( TOP )
	AWarn.punishmentCreationFields.pTypeDropdown:SetFont( "AWarn3Label2" )
	
	local Label = vgui.Create( "awarn3_configlabel", punishmentCreationTypePanel )
	Label:SetText( AWarn.Localization:GetTranslation( "activewarnings" ) )
	Label:DockMargin( 0, 10 * screenscale, 0, 6 * screenscale )
	Label:Dock( TOP )
	
	AWarn.punishmentCreationFields.pActiveWarningsTxtBox = vgui.Create( "DTextEntry", punishmentCreationTypePanel )
	AWarn.punishmentCreationFields.pActiveWarningsTxtBox:SetTextInset( 8, 0 )
	AWarn.punishmentCreationFields.pActiveWarningsTxtBox:SetHeight( 26 * screenscale )
	AWarn.punishmentCreationFields.pActiveWarningsTxtBox:SetFont( "AWarn3Label2" )
	AWarn.punishmentCreationFields.pActiveWarningsTxtBox:SetNumeric( true )
	AWarn.punishmentCreationFields.pActiveWarningsTxtBox:Dock( TOP )
	AWarn.punishmentCreationFields.pActiveWarningsTxtBox:SetValue( "1" )


	local dockmargin = 6 * screenscale
	local addPunishmentButton = vgui.Create( "awarn3_button", punishmentCreationTypePanel )
	addPunishmentButton:SetText( AWarn.Localization:GetTranslation( "addpunishment" ) )
	addPunishmentButton:Dock( BOTTOM )
	
	
	
	
	
	local CreationDetailsPanelDock = vgui.Create( "DPanel", punishmentCreationDock)
	CreationDetailsPanelDock:DockMargin( 0, 0, 0, 0 )
	CreationDetailsPanelDock:DockPadding( 0,0,0,0 )
	CreationDetailsPanelDock:Dock( FILL )
	CreationDetailsPanelDock.Paint = function()
		surface.SetDrawColor( AWarn.Colors.COLOR_THEME_PRIMARY )
		surface.DrawRect( 0, 0, CreationDetailsPanelDock:GetWide() - 3 * screenscale, CreationDetailsPanelDock:GetTall() - 3 * screenscale )

		surface.SetDrawColor( AWarn.Colors.COLOR_THEME_PRIMARY_SHADOW )
		surface.DrawRect( CreationDetailsPanelDock:GetWide() - 3 * screenscale, 0, 3 * screenscale, CreationDetailsPanelDock:GetTall() - 1 )
		surface.DrawRect( 0, CreationDetailsPanelDock:GetTall() - 3 * screenscale, CreationDetailsPanelDock:GetWide() - 3 * screenscale, 3 * screenscale )
	end
	
	local punishmentCreationDetailsPanel = vgui.Create( "DScrollPanel", CreationDetailsPanelDock)
	punishmentCreationDetailsPanel:DockMargin( 0, 0, 0, 8 * screenscale )
	punishmentCreationDetailsPanel:DockPadding( 10 * screenscale, 10 * screenscale, 10 * screenscale, 10 * screenscale )	
	punishmentCreationDetailsPanel:GetCanvas():DockPadding( 10 * screenscale, 10 * screenscale, 14 * screenscale, 10 * screenscale )
	punishmentCreationDetailsPanel:Dock( FILL )
	punishmentCreationDetailsPanel.Paint = function()
		--surface.SetDrawColor( Color(255,0,0,60) )
		--surface.DrawRect( 0, 0, punishmentCreationDetailsPanel:GetWide() - 3 * screenscale, punishmentCreationDetailsPanel:GetTall() - 3 * screenscale )
	end
		
	local ScrollBar = punishmentCreationDetailsPanel:GetVBar()
	ScrollBar:SetHideButtons( true )
	ScrollBar:SetWidth( 6 * screenscale )
	function ScrollBar:Paint( w, h )
		surface.SetDrawColor( 0, 0, 0, 0 )
		surface.DrawRect( 0, 0, w, h )
	end
	function ScrollBar.btnGrip:Paint( w, h )
		surface.SetDrawColor( AWarn.Colors.COLOR_SELECTED )
		surface.DrawRect( 0, 0, w, h )
	end
	
	local Label1 = vgui.Create( "awarn3_configlabel", punishmentCreationDetailsPanel )
	Label1:SetText( AWarn.Localization:GetTranslation( "messagetoplayer" ) )
	Label1:DockMargin( 0, 0, 0, 6 * screenscale )
	Label1:Dock( TOP )
	Label1:SetZPos( 1 )
	
	AWarn.punishmentCreationFields.pMessageToPlayerTxtBox = vgui.Create( "DTextEntry", punishmentCreationDetailsPanel )
	AWarn.punishmentCreationFields.pMessageToPlayerTxtBox:SetHeight( 26 * screenscale )
	AWarn.punishmentCreationFields.pMessageToPlayerTxtBox:SetFont( "AWarn3Label2" )
	AWarn.punishmentCreationFields.pMessageToPlayerTxtBox:SetNumeric( false )
	AWarn.punishmentCreationFields.pMessageToPlayerTxtBox:Dock( TOP )
	AWarn.punishmentCreationFields.pMessageToPlayerTxtBox:SetPlaceholderText( AWarn.Localization:GetTranslation( "use%" ) )
	AWarn.punishmentCreationFields.pMessageToPlayerTxtBox:SetZPos( 2 )
	
	local Label2 = vgui.Create( "awarn3_configlabel", punishmentCreationDetailsPanel )
	Label2:SetText( AWarn.Localization:GetTranslation( "messagetoserver" ) )
	Label2:DockMargin( 0, 10 * screenscale, 0, 6 * screenscale )
	Label2:Dock( TOP )
	Label2:SetZPos( 3 )
	
	AWarn.punishmentCreationFields.pMessageToServerTxtBox = vgui.Create( "DTextEntry", punishmentCreationDetailsPanel )
	AWarn.punishmentCreationFields.pMessageToServerTxtBox:SetHeight( 26 * screenscale )
	AWarn.punishmentCreationFields.pMessageToServerTxtBox:SetFont( "AWarn3Label2" )
	AWarn.punishmentCreationFields.pMessageToServerTxtBox:SetNumeric( false )
	AWarn.punishmentCreationFields.pMessageToServerTxtBox:Dock( TOP )
	AWarn.punishmentCreationFields.pMessageToServerTxtBox:SetPlaceholderText( AWarn.Localization:GetTranslation( "use%" ) )
	AWarn.punishmentCreationFields.pMessageToServerTxtBox:SetZPos( 4 )
	
	local Label3 = vgui.Create( "awarn3_configlabel", punishmentCreationDetailsPanel )
	Label3:SetText( AWarn.Localization:GetTranslation( "punishlength" ) .. "  (" .. AWarn.Localization:GetTranslation( "inminutes" ) .. ")")
	Label3:DockMargin( 0, 10 * screenscale, 0, 6 * screenscale )
	Label3:Dock( TOP )
	Label3:SetVisible( false )
	Label3:SetZPos( 5 )
	
	AWarn.punishmentCreationFields.pPunishmentLengthTxtBox = vgui.Create( "DTextEntry", punishmentCreationDetailsPanel )
	AWarn.punishmentCreationFields.pPunishmentLengthTxtBox:SetHeight( 26 * screenscale )
	AWarn.punishmentCreationFields.pPunishmentLengthTxtBox:SetFont( "AWarn3Label2" )
	AWarn.punishmentCreationFields.pPunishmentLengthTxtBox:SetNumeric( true )
	AWarn.punishmentCreationFields.pPunishmentLengthTxtBox:Dock( TOP )
	AWarn.punishmentCreationFields.pPunishmentLengthTxtBox:SetPlaceholderText( AWarn.Localization:GetTranslation( "0equalperma" ) )
	AWarn.punishmentCreationFields.pPunishmentLengthTxtBox:SetVisible( false )
	AWarn.punishmentCreationFields.pPunishmentLengthTxtBox:SetZPos( 6 )
	
	local Label4 = vgui.Create( "awarn3_configlabel", punishmentCreationDetailsPanel )
	Label4:SetText( AWarn.Localization:GetTranslation( "grouptoset" ) )
	Label4:DockMargin( 0, 10 * screenscale, 0, 6 * screenscale )
	Label4:Dock( TOP )
	Label4:SetVisible( false )
	Label4:SetZPos( 7 )
	
	AWarn.punishmentCreationFields.pPunishmentGroupDropdown = vgui.Create( "DComboBox", punishmentCreationDetailsPanel )
	AWarn.punishmentCreationFields.pPunishmentGroupDropdown:SetHeight( 26 * screenscale )
	AWarn.punishmentCreationFields.pPunishmentGroupDropdown:SetFont( "AWarn3Label2" )
	AWarn.punishmentCreationFields.pPunishmentGroupDropdown:Dock( TOP )
	AWarn.punishmentCreationFields.pPunishmentGroupDropdown:SetVisible( false )
	AWarn.punishmentCreationFields.pPunishmentGroupDropdown:SetZPos( 8 )
	if CAMI then
		for k, v in pairs( CAMI.GetUsergroups() ) do
			AWarn.punishmentCreationFields.pPunishmentGroupDropdown:AddChoice( k )
		end
		AWarn.punishmentCreationFields.pPunishmentGroupDropdown:SetValue( AWarn.punishmentCreationFields.pPunishmentGroupDropdown:GetOptionText(1) )
	end
	
	local Label5 = vgui.Create( "awarn3_configlabel", punishmentCreationDetailsPanel )
	Label5:SetText( AWarn.Localization:GetTranslation( "customcommand" ) )
	Label5:DockMargin( 0, 10 * screenscale, 0, 6 * screenscale )
	Label5:Dock( TOP )
	Label5:SetVisible( false )
	Label5:SetZPos( 9 )
	
	AWarn.punishmentCreationFields.pPunishmentCommandTxtBox = vgui.Create( "DTextEntry", punishmentCreationDetailsPanel )
	AWarn.punishmentCreationFields.pPunishmentCommandTxtBox:SetHeight( 26 * screenscale )
	AWarn.punishmentCreationFields.pPunishmentCommandTxtBox:SetFont( "AWarn3Label2" )
	AWarn.punishmentCreationFields.pPunishmentCommandTxtBox:SetNumeric( false )
	AWarn.punishmentCreationFields.pPunishmentCommandTxtBox:Dock( TOP )
	AWarn.punishmentCreationFields.pPunishmentCommandTxtBox:SetPlaceholderText( AWarn.Localization:GetTranslation( "customcommandplaceholder" ) )
	AWarn.punishmentCreationFields.pPunishmentCommandTxtBox:SetVisible( false )
	AWarn.punishmentCreationFields.pPunishmentCommandTxtBox:SetZPos( 11 )
	
	
	
	AWarn.punishmentCreationFields.pTypeDropdown.OnSelect = function( self, index, value )
		if value == "Ban" then
			AWarn.punishmentCreationFields.pPunishmentLengthTxtBox:SetVisible( true )
			AWarn.punishmentCreationFields.pPunishmentGroupDropdown:SetVisible( false )
			AWarn.punishmentCreationFields.pPunishmentCommandTxtBox:SetVisible( false )
			Label3:SetVisible( true )
			Label4:SetVisible( false )
			Label5:SetVisible( false )
		elseif value == "Kick" then
			AWarn.punishmentCreationFields.pPunishmentLengthTxtBox:SetVisible( false )
			AWarn.punishmentCreationFields.pPunishmentGroupDropdown:SetVisible( false )
			AWarn.punishmentCreationFields.pPunishmentCommandTxtBox:SetVisible( false )
			Label3:SetVisible( false )
			Label4:SetVisible( false )
			Label5:SetVisible( false )
		elseif value == "Group" then
			AWarn.punishmentCreationFields.pPunishmentLengthTxtBox:SetVisible( false )
			AWarn.punishmentCreationFields.pPunishmentGroupDropdown:SetVisible( true )
			AWarn.punishmentCreationFields.pPunishmentCommandTxtBox:SetVisible( false )
			Label3:SetVisible( false )
			Label4:SetVisible( true )
			Label5:SetVisible( false )
		elseif value == "Command" then
			AWarn.punishmentCreationFields.pPunishmentLengthTxtBox:SetVisible( false )
			AWarn.punishmentCreationFields.pPunishmentGroupDropdown:SetVisible( false )
			AWarn.punishmentCreationFields.pPunishmentCommandTxtBox:SetVisible( true )
			Label3:SetVisible( false )
			Label4:SetVisible( false )
			Label5:SetVisible( true )
		end
	end
	
	addPunishmentButton.OnSelected = function()

		if AWarn.punishmentCreationFields.pMessageToPlayerTxtBox:GetValue() == "" or AWarn.punishmentCreationFields.pMessageToServerTxtBox:GetValue() == "" then return end
		
		AWarn.Punishments[ tonumber( AWarn.punishmentCreationFields.pActiveWarningsTxtBox:GetValue() ) ] = { pType = AWarn.punishmentCreationFields.pTypeDropdown:GetValue():lower(), warnings = tonumber( AWarn.punishmentCreationFields.pActiveWarningsTxtBox:GetValue() ), pMessage = AWarn.punishmentCreationFields.pMessageToPlayerTxtBox:GetValue(), sMessage = AWarn.punishmentCreationFields.pMessageToServerTxtBox:GetValue() }
		
    if AWarn.punishmentCreationFields.pTypeDropdown:GetValue() == "Ban" then
			AWarn.Punishments[ tonumber( AWarn.punishmentCreationFields.pActiveWarningsTxtBox:GetValue() ) ].pLength = tonumber( AWarn.punishmentCreationFields.pPunishmentLengthTxtBox:GetValue() or 0 )
		end
		
		if AWarn.punishmentCreationFields.pTypeDropdown:GetValue() == "Group" then
			AWarn.Punishments[ tonumber( AWarn.punishmentCreationFields.pActiveWarningsTxtBox:GetValue() ) ].pGroup =  AWarn.punishmentCreationFields.pPunishmentGroupDropdown:GetValue()
		end
		
		if AWarn.punishmentCreationFields.pTypeDropdown:GetValue() == "Command" then
			AWarn.Punishments[ tonumber( AWarn.punishmentCreationFields.pActiveWarningsTxtBox:GetValue() ) ].pCommand =  AWarn.punishmentCreationFields.pPunishmentCommandTxtBox:GetValue()
		end
		
		
		
		AWarn:RefreshPunishments()
		AWarn:SavePunishments()
		timer.Simple( 0.1, function() AWarn3_ResetPunishmentCreationFields() end )
	end
	
	
	
	
	
	local presetCardsPanel = vgui.Create( "DPanel", self.PresetsMenuDock)
	presetCardsPanel:Dock( FILL )
	presetCardsPanel:DockMargin( 0, 0, 0, 4 * screenscale )
	presetCardsPanel.Paint = function()
		surface.SetDrawColor( AWarn.Colors.COLOR_THEME_PRIMARY )
		surface.DrawRect( 0, 0, presetCardsPanel:GetWide() - 3 * screenscale, presetCardsPanel:GetTall() - 3 * screenscale )

		surface.SetDrawColor( AWarn.Colors.COLOR_THEME_PRIMARY_SHADOW )
		surface.DrawRect( presetCardsPanel:GetWide() - 3 * screenscale, 0, 3 * screenscale, presetCardsPanel:GetTall() - 1 )
		surface.DrawRect( 0, presetCardsPanel:GetTall() - 3 * screenscale, presetCardsPanel:GetWide() - 3 * screenscale, 3 * screenscale )
	end

	AWarn.menu.configurationview.PresetsCardsPanel = vgui.Create( "DScrollPanel", presetCardsPanel )
	AWarn.menu.configurationview.PresetsCardsPanel:Dock( FILL )
	AWarn.menu.configurationview.PresetsCardsPanel:DockPadding( 10,10,10,10 )
	AWarn.menu.configurationview.PresetsCardsPanel:GetCanvas():DockPadding( 0, 4 * screenscale, 4 * screenscale, 0 )
		
	local ScrollBar = AWarn.menu.configurationview.PresetsCardsPanel:GetVBar()
	ScrollBar:SetHideButtons( true )
	ScrollBar:SetWidth( 6 * screenscale )
	function ScrollBar:Paint( w, h )
		surface.SetDrawColor( 0, 0, 0, 0 )
		surface.DrawRect( 0, 0, w, h )
	end
	function ScrollBar.btnGrip:Paint( w, h )
		surface.SetDrawColor( AWarn.Colors.COLOR_SELECTED )
		surface.DrawRect( 0, 0, w, h )
	end
	
	
	local presetCreationPanel = vgui.Create( "DPanel", self.PresetsMenuDock)
	presetCreationPanel:SetHeight( 100 * screenscale )
	presetCreationPanel:Dock( BOTTOM )
	presetCreationPanel.Paint = function()
		surface.SetDrawColor( AWarn.Colors.COLOR_THEME_PRIMARY )
		surface.DrawRect( 0, 0, presetCreationPanel:GetWide() - 3 * screenscale, presetCreationPanel:GetTall() - 3 * screenscale )

		surface.SetDrawColor( AWarn.Colors.COLOR_THEME_PRIMARY_SHADOW )
		surface.DrawRect( presetCreationPanel:GetWide() - 3 * screenscale, 0, 3 * screenscale, presetCreationPanel:GetTall() - 1 )
		surface.DrawRect( 0, presetCreationPanel:GetTall() - 3 * screenscale, presetCreationPanel:GetWide() - 3 * screenscale, 3 * screenscale )
	
	end
		
	local addEditPresetButton = vgui.Create( "awarn3_button", presetCreationPanel )
	addEditPresetButton:SetText( AWarn.Localization:GetTranslation( "addeditpreset" ) )
	addEditPresetButton:DockMargin( 8 * screenscale, 0, 10 * screenscale, 10 * screenscale )
	addEditPresetButton:Dock( BOTTOM )
	
	local presetCreationTextBoxesPanel = vgui.Create( "DPanel", presetCreationPanel)
	presetCreationTextBoxesPanel:SetHeight( 26 * screenscale )	
	presetCreationTextBoxesPanel:Dock( FILL )
	presetCreationTextBoxesPanel:DockMargin( 8 * screenscale, 8 * screenscale, 10 * screenscale, 10 * screenscale )
	presetCreationTextBoxesPanel:DockPadding(0,0,0,0 )
	presetCreationTextBoxesPanel.Paint = function()
		--surface.SetDrawColor( Color(255,255,255,100) )
		--surface.DrawRect( 0, 0, presetCreationTextBoxesPanel:GetWide(), presetCreationTextBoxesPanel:GetTall() )
		surface.SetFont( "AWarn3Label1" )
		surface.SetTextColor( AWarn.Colors.COLOR_LABEL_TEXT )
		local x = self.presetNameTxtBox:GetX()
		local text = AWarn.Localization:GetTranslation( "presetname" ) .. ":"
		local tW, tH = surface.GetTextSize( text )
		surface.SetTextPos( x , 0 )
		surface.DrawText( text )
		
		local x = self.presetValueTxtBox:GetX()
		local text = AWarn.Localization:GetTranslation( "presetreason" ) .. ":"
		local tW, tH = surface.GetTextSize( text )
		surface.SetTextPos( x , 0 )
		surface.DrawText( text )
	end	

	self.presetNameTxtBox = vgui.Create( "DTextEntry", presetCreationTextBoxesPanel )
	self.presetNameTxtBox:SetFont( "AWarn3Label2" )
	self.presetNameTxtBox:SetWide( 200 * screenscale )
	self.presetNameTxtBox:SetPlaceholderText( " " .. AWarn.Localization:GetTranslation( "presetname" ) )	
	self.presetNameTxtBox:DockMargin( 0, 25 * screenscale, 0, 0 )
	self.presetNameTxtBox:Dock( LEFT )

	self.presetValueTxtBox = vgui.Create( "DTextEntry", presetCreationTextBoxesPanel )
	self.presetValueTxtBox:SetFont( "AWarn3Label2" )
	self.presetValueTxtBox:SetPlaceholderText( " " .. AWarn.Localization:GetTranslation( "presetreason" ) )	
	self.presetValueTxtBox:DockMargin( 8 * screenscale, 25 * screenscale, 0, 0 )
	self.presetValueTxtBox:Dock( FILL )	
	
	addEditPresetButton.OnSelected = function()

		if AWarn.menu.configurationview.presetNameTxtBox:GetValue() == "" or AWarn.menu.configurationview.presetValueTxtBox:GetValue() == "" then return end
		
		AWarn.Presets[ AWarn.menu.configurationview.presetNameTxtBox:GetValue() ] = {
			pName = AWarn.menu.configurationview.presetNameTxtBox:GetValue(),
			pReason = AWarn.menu.configurationview.presetValueTxtBox:GetValue(),
		}		
		
		AWarn:RefreshPresets()
		AWarn:SavePresets()
		timer.Simple( 0.1, function() AWarn3_ResetPresetCreationFields() end )
	end

	
end
vgui.Register( "awarn3_configurationview", PANEL, "DFrame" )
	
function AWarn3_ResetPunishmentCreationFields()
	AWarn.punishmentCreationFields.pActiveWarningsTxtBox:SetValue("1")
	AWarn.punishmentCreationFields.pMessageToPlayerTxtBox:SetValue("")
	AWarn.punishmentCreationFields.pMessageToServerTxtBox:SetValue("")
	AWarn.punishmentCreationFields.pPunishmentLengthTxtBox:SetValue("")
	AWarn.punishmentCreationFields.pPunishmentCommandTxtBox:SetValue("")
end
	
function AWarn3_ResetPresetCreationFields()
	AWarn.menu.configurationview.presetNameTxtBox:SetValue("")
	AWarn.menu.configurationview.presetValueTxtBox:SetValue("")
end


local PANEL = {}
function PANEL:Init()
	self:SetHeight(45 * screenscale)
	self.MainText = "Option Title"
	self.SecondaryText = "Option Description String Goes Here"
	self.optionString = "nnn"
end
function PANEL:SetOptionString( str )
	self.optionString = str
end
function PANEL:GetOptionString()
	return self.optionString
end
function PANEL:SetPrimaryText( str )
	self.MainText = str
end
function PANEL:SetSecondaryText( str )
	self.SecondaryText = str
end
function PANEL:SetChecked( bool )
	self.chkBox:SetChecked( bool )
end
function PANEL:Paint()
	--surface.SetDrawColor( 200, 200, 120, 0 )
	--surface.DrawRect( 0, 0, self:GetWide(), self:GetTall() )
	
	surface.SetFont( "AWarn3ToggleText1" )
	surface.SetTextColor( AWarn.Colors.COLOR_LABEL_TEXT )
	surface.SetTextPos( 10 * screenscale, 7 * screenscale)
	surface.DrawText( self.MainText )
	surface.SetFont( "AWarn3ToggleText2" )
	surface.SetTextPos( 10* screenscale, 27 * screenscale)
	surface.DrawText( self.SecondaryText )
	
end
function PANEL:DrawElements()
	local chkBoxPanel = vgui.Create( "DPanel", self )
	chkBoxPanel:SetWidth(80 * screenscale)
	chkBoxPanel:DockMargin(0,14*screenscale,0,0)
	chkBoxPanel:Dock( RIGHT )
	chkBoxPanel.Paint = function()
	end
	
	self.chkBox = vgui.Create( "awarn3_customcheckbox", chkBoxPanel )
	self.chkBox:SetSize(48 * screenscale, 24 * screenscale)
	self.chkBox:SetValue( 0 )
	
	local function GetOptionString()
		return self.optionString
	end
	
	function self.chkBox:OnChange( val )
		AWarn:SendOptionUpdate( GetOptionString(), val )
	end
	
	local function SetInitialValue()
		self.chkBox:SetChecked( AWarn.Options[self.optionString].value )
	end
	--SetInitialValue()
end
vgui.Register( "awarn3_toggleoption", PANEL, "DPanel" )



local PANEL = {}
function PANEL:Init()
	self:SetHeight(45 * screenscale)
	self.MainText = "Option Title"
	self.SecondaryText = "Option Description String Goes Here"
	self.optionString = "nnn"
	self.numeric = false
	self.stripSpaces = false
end
function PANEL:SetOptionString( str )
	self.optionString = str
end
function PANEL:GetOptionString()
	return self.optionString
end
function PANEL:SetPrimaryText( str )
	self.MainText = str
end
function PANEL:SetSecondaryText( str )
	self.SecondaryText = str
end
function PANEL:SetValue( str )
	if self.stripSpaces then
		self.optionTextBox:SetValue( tostring(str):gsub( " ", "" ) )
	else
		self.optionTextBox:SetValue( tostring(str) )
	end
end
function PANEL:SetNumeric( bool )
	self.numeric = bool
end
function PANEL:StripSpaces( bool )
	self.stripSpaces = bool
end

function PANEL:Paint()
	--surface.SetDrawColor( 200, 200, 120, 0 )
	--surface.DrawRect( 0, 0, self:GetWide(), self:GetTall() )
	
	surface.SetFont( "AWarn3ToggleText1" )
	surface.SetTextColor( AWarn.Colors.COLOR_LABEL_TEXT )
	surface.SetTextPos( 10 * screenscale, 7 * screenscale)
	surface.DrawText( self.MainText )
	surface.SetFont( "AWarn3ToggleText2" )
	surface.SetTextPos( 10* screenscale, 27 * screenscale)
	surface.DrawText( self.SecondaryText )
		
	if self.optionTextBox:IsEditing() then
		surface.SetFont( "AWarn3CardText1" )
		local tW, tH = surface.GetTextSize( AWarn.Localization:GetTranslation( "pressenter" ) )
		
		local x = self:GetWide() - ( 210 * screenscale ) - tW
		local y = 16 * screenscale
		surface.SetTextColor( AWarn.Colors.COLOR_LABEL_VALUE_TEXT )
		surface.SetTextPos( x, y )
		surface.DrawText( AWarn.Localization:GetTranslation( "pressenter" ) )
	end
	
end
function PANEL:DrawElements()
	local txtBoxPanel = vgui.Create( "DPanel", self )
	txtBoxPanel:SetWidth(200 * screenscale)
	txtBoxPanel:DockMargin(0,7*screenscale,0,0)
	txtBoxPanel:Dock( RIGHT )
	txtBoxPanel.Paint = function()
		--surface.SetDrawColor( 200, 200, 120, 50 )
		--surface.DrawRect( 0, 0, txtBoxPanel:GetWide(), txtBoxPanel:GetTall() )
	end
	
	self.optionTextBox = vgui.Create( "DTextEntry", txtBoxPanel )
	self.optionTextBox:SetSize( 180 * screenscale, 30 * screenscale )
	self.optionTextBox:SetMultiline( false )
	self.optionTextBox:SetFont( "AWarn3Label2" )
	self.optionTextBox:SetPos( 0, 0 )	
	self.optionTextBox:SetEnterAllowed( true )
	self.optionTextBox:SetPlaceholderText( "Test" )
	self.optionTextBox:SetPaintBackground( true )
	self.optionTextBox:DockMargin(10,0,0,0)
	self.optionTextBox:SetNumeric( self.numeric )
	self.optionTextBox.OnEnter = function( val )
		self.optionTextBox:SetTextColor( Color( 0, 200, 0, 255 ) )
		if self.stripSpaces then
			self.optionTextBox:SetValue( val:GetText():gsub( " ", "" ) )
			AWarn:SendOptionUpdate( self.optionString, val:GetText():gsub( " ", "" ) )
		else
			self.optionTextBox:SetValue( val:GetText() )
			AWarn:SendOptionUpdate( self.optionString, val:GetText() )
		end
	end
	
	local function SetInitialValue()
		self.optionTextBox:SetValue( AWarn.Options[self.optionString].value )
	end
	--SetInitialValue()

end
vgui.Register( "awarn3_textoption", PANEL, "DPanel" )



local PANEL = {}
function PANEL:Init()
	self:SetHeight(45 * screenscale)
	self.MainText = "Option Title"
	self.SecondaryText = "Option Description String Goes Here"
	self.optionString = "nnn"
	self.optionTable = {}
end
function PANEL:SetOptionString( str )
	self.optionString = str
end
function PANEL:GetOptionString()
	return self.optionString
end
function PANEL:SetPrimaryText( str )
	self.MainText = str
end
function PANEL:SetSecondaryText( str )
	self.SecondaryText = str
end
function PANEL:SetOptionTable( tbl )
	self.optionTable = tbl
end
function PANEL:SetValue( str )
	self.comboBox:SetValue( str )
end

function PANEL:Paint()
	--surface.SetDrawColor( 200, 200, 120, 0 )
	--surface.DrawRect( 0, 0, self:GetWide(), self:GetTall() )
	
	surface.SetFont( "AWarn3ToggleText1" )
	surface.SetTextColor( AWarn.Colors.COLOR_LABEL_TEXT )
	surface.SetTextPos( 10 * screenscale, 7 * screenscale)
	surface.DrawText( self.MainText )
	surface.SetFont( "AWarn3ToggleText2" )
	surface.SetTextPos( 10* screenscale, 27 * screenscale)
	surface.DrawText( self.SecondaryText )
	
end
function PANEL:DrawElements()
	local cmboBoxPanel = vgui.Create( "DPanel", self )
	cmboBoxPanel:SetWidth(200 * screenscale)
	cmboBoxPanel:DockMargin(0,7*screenscale,0,0)
	cmboBoxPanel:Dock( RIGHT )
	cmboBoxPanel.Paint = function()
		--surface.SetDrawColor( 200, 200, 120, 50 )
		--surface.DrawRect( 0, 0, cmboBoxPanel:GetWide(), cmboBoxPanel:GetTall() )
	end
	
	self.comboBox = vgui.Create( "DComboBox", cmboBoxPanel )
	self.comboBox:SetWidth( 180 * screenscale )
	self.comboBox:SetHeight( 30 * screenscale )
	self.comboBox:SetValue( "EN-US" )
	self.comboBox:SetFont( "AWarn3Label2" )
	for k, v in pairs( self.optionTable ) do
		self.comboBox:AddChoice( AWarn.Localization.LangCodes[k], k )
	end
	function self.comboBox:OnSelect( index, text, data )
		local optionstring = self:GetParent():GetParent().optionString
		AWarn:SendOptionUpdate( optionstring, data )
	end
	
end
vgui.Register( "awarn3_combooption", PANEL, "DPanel" )
--PATH addons/[admin] awarn3/lua/includes/awarn3_easings.lua:
AddCSLuaFile()
local pow = math.pow
local sin = math.sin
local cos = math.cos
local pi = math.pi
local sqrt = math.sqrt
local abs = math.abs
local asin  = math.asin

local function linear(t, b, c, d)
  return c * t / d + b
end

local function inQuad(t, b, c, d)
  t = t / d
  return c * pow(t, 2) + b
end

local function outQuad(t, b, c, d)
  t = t / d
  return -c * t * (t - 2) + b
end

local function inOutQuad(t, b, c, d)
  t = t / d * 2
  if t < 1 then
    return c / 2 * pow(t, 2) + b
  else
    return -c / 2 * ((t - 1) * (t - 3) - 1) + b
  end
end

local function outInQuad(t, b, c, d)
  if t < d / 2 then
    return outQuad (t * 2, b, c / 2, d)
  else
    return inQuad((t * 2) - d, b + c / 2, c / 2, d)
  end
end

local function inCubic (t, b, c, d)
  t = t / d
  return c * pow(t, 3) + b
end

local function outCubic(t, b, c, d)
  t = t / d - 1
  return c * (pow(t, 3) + 1) + b
end

local function inOutCubic(t, b, c, d)
  t = t / d * 2
  if t < 1 then
    return c / 2 * t * t * t + b
  else
    t = t - 2
    return c / 2 * (t * t * t + 2) + b
  end
end

local function outInCubic(t, b, c, d)
  if t < d / 2 then
    return outCubic(t * 2, b, c / 2, d)
  else
    return inCubic((t * 2) - d, b + c / 2, c / 2, d)
  end
end

local function inQuart(t, b, c, d)
  t = t / d
  return c * pow(t, 4) + b
end

local function outQuart(t, b, c, d)
  t = t / d - 1
  return -c * (pow(t, 4) - 1) + b
end

local function inOutQuart(t, b, c, d)
  t = t / d * 2
  if t < 1 then
    return c / 2 * pow(t, 4) + b
  else
    t = t - 2
    return -c / 2 * (pow(t, 4) - 2) + b
  end
end

local function outInQuart(t, b, c, d)
  if t < d / 2 then
    return outQuart(t * 2, b, c / 2, d)
  else
    return inQuart((t * 2) - d, b + c / 2, c / 2, d)
  end
end

local function inQuint(t, b, c, d)
  t = t / d
  return c * pow(t, 5) + b
end

local function outQuint(t, b, c, d)
  t = t / d - 1
  return c * (pow(t, 5) + 1) + b
end

local function inOutQuint(t, b, c, d)
  t = t / d * 2
  if t < 1 then
    return c / 2 * pow(t, 5) + b
  else
    t = t - 2
    return c / 2 * (pow(t, 5) + 2) + b
  end
end

local function outInQuint(t, b, c, d)
  if t < d / 2 then
    return outQuint(t * 2, b, c / 2, d)
  else
    return inQuint((t * 2) - d, b + c / 2, c / 2, d)
  end
end

local function inSine(t, b, c, d)
  return -c * cos(t / d * (pi / 2)) + c + b
end

local function outSine(t, b, c, d)
  return c * sin(t / d * (pi / 2)) + b
end

local function inOutSine(t, b, c, d)
  return -c / 2 * (cos(pi * t / d) - 1) + b
end

local function outInSine(t, b, c, d)
  if t < d / 2 then
    return outSine(t * 2, b, c / 2, d)
  else
    return inSine((t * 2) -d, b + c / 2, c / 2, d)
  end
end

local function inExpo(t, b, c, d)
  if t == 0 then
    return b
  else
    return c * pow(2, 10 * (t / d - 1)) + b - c * 0.001
  end
end

local function outExpo(t, b, c, d)
  if t == d then
    return b + c
  else
    return c * 1.001 * (-pow(2, -10 * t / d) + 1) + b
  end
end

local function inOutExpo(t, b, c, d)
  if t == 0 then return b end
  if t == d then return b + c end
  t = t / d * 2
  if t < 1 then
    return c / 2 * pow(2, 10 * (t - 1)) + b - c * 0.0005
  else
    t = t - 1
    return c / 2 * 1.0005 * (-pow(2, -10 * t) + 2) + b
  end
end

local function outInExpo(t, b, c, d)
  if t < d / 2 then
    return outExpo(t * 2, b, c / 2, d)
  else
    return inExpo((t * 2) - d, b + c / 2, c / 2, d)
  end
end

local function inCirc(t, b, c, d)
  t = t / d
  return(-c * (sqrt(1 - pow(t, 2)) - 1) + b)
end

local function outCirc(t, b, c, d)
  t = t / d - 1
  return(c * sqrt(1 - pow(t, 2)) + b)
end

local function inOutCirc(t, b, c, d)
  t = t / d * 2
  if t < 1 then
    return -c / 2 * (sqrt(1 - t * t) - 1) + b
  else
    t = t - 2
    return c / 2 * (sqrt(1 - t * t) + 1) + b
  end
end

local function outInCirc(t, b, c, d)
  if t < d / 2 then
    return outCirc(t * 2, b, c / 2, d)
  else
    return inCirc((t * 2) - d, b + c / 2, c / 2, d)
  end
end

local function inElastic(t, b, c, d, a, p)
  if t == 0 then return b end

  t = t / d

  if t == 1  then return b + c end

  if not p then p = d * 0.3 end

  local s

  if not a or a < abs(c) then
    a = c
    s = p / 4
  else
    s = p / (2 * pi) * asin(c/a)
  end

  t = t - 1

  return -(a * pow(2, 10 * t) * sin((t * d - s) * (2 * pi) / p)) + b
end

-- a: amplitud
-- p: period
-- 76561198835351415
local function outElastic(t, b, c, d, a, p)
  if t == 0 then return b end

  t = t / d

  if t == 1 then return b + c end

  if not p then p = d * 0.3 end

  local s

  if not a or a < abs(c) then
    a = c
    s = p / 4
  else
    s = p / (2 * pi) * asin(c/a)
  end

  return a * pow(2, -10 * t) * sin((t * d - s) * (2 * pi) / p) + c + b
end

-- p = period
-- a = amplitud
local function inOutElastic(t, b, c, d, a, p)
  if t == 0 then return b end

  t = t / d * 2

  if t == 2 then return b + c end

  if not p then p = d * (0.3 * 1.5) end
  if not a then a = 0 end

  local s

  if not a or a < abs(c) then
    a = c
    s = p / 4
  else
    s = p / (2 * pi) * asin(c / a)
  end

  if t < 1 then
    t = t - 1
    return -0.5 * (a * pow(2, 10 * t) * sin((t * d - s) * (2 * pi) / p)) + b
  else
    t = t - 1
    return a * pow(2, -10 * t) * sin((t * d - s) * (2 * pi) / p ) * 0.5 + c + b
  end
end

-- a: amplitud
-- p: period
local function outInElastic(t, b, c, d, a, p)
  if t < d / 2 then
    return outElastic(t * 2, b, c / 2, d, a, p)
  else
    return inElastic((t * 2) - d, b + c / 2, c / 2, d, a, p)
  end
end

local function inBack(t, b, c, d, s)
  if not s then s = 1.70158 end
  t = t / d
  return c * t * t * ((s + 1) * t - s) + b
end

local function outBack(t, b, c, d, s)
  if not s then s = 1.70158 end
  t = t / d - 1
  return c * (t * t * ((s + 1) * t + s) + 1) + b
end

local function inOutBack(t, b, c, d, s)
  if not s then s = 1.70158 end
  s = s * 1.525
  t = t / d * 2
  if t < 1 then
    return c / 2 * (t * t * ((s + 1) * t - s)) + b
  else
    t = t - 2
    return c / 2 * (t * t * ((s + 1) * t + s) + 2) + b
  end
end

local function outInBack(t, b, c, d, s)
  if t < d / 2 then
    return outBack(t * 2, b, c / 2, d, s)
  else
    return inBack((t * 2) - d, b + c / 2, c / 2, d, s)
  end
end

local function outBounce(t, b, c, d)
  t = t / d
  if t < 1 / 2.75 then
    return c * (7.5625 * t * t) + b
  elseif t < 2 / 2.75 then
    t = t - (1.5 / 2.75)
    return c * (7.5625 * t * t + 0.75) + b
  elseif t < 2.5 / 2.75 then
    t = t - (2.25 / 2.75)
    return c * (7.5625 * t * t + 0.9375) + b
  else
    t = t - (2.625 / 2.75)
    return c * (7.5625 * t * t + 0.984375) + b
  end
end

local function inBounce(t, b, c, d)
  return c - outBounce(d - t, 0, c, d) + b
end

local function inOutBounce(t, b, c, d)
  if t < d / 2 then
    return inBounce(t * 2, 0, c, d) * 0.5 + b
  else
    return outBounce(t * 2 - d, 0, c, d) * 0.5 + c * .5 + b
  end
end

local function outInBounce(t, b, c, d)
  if t < d / 2 then
    return outBounce(t * 2, b, c / 2, d)
  else
    return inBounce((t * 2) - d, b + c / 2, c / 2, d)
  end
end

return {
  linear = linear,
  inQuad = inQuad,
  outQuad = outQuad,
  inOutQuad = inOutQuad,
  outInQuad = outInQuad,
  inCubic  = inCubic ,
  outCubic = outCubic,
  inOutCubic = inOutCubic,
  outInCubic = outInCubic,
  inQuart = inQuart,
  outQuart = outQuart,
  inOutQuart = inOutQuart,
  outInQuart = outInQuart,
  inQuint = inQuint,
  outQuint = outQuint,
  inOutQuint = inOutQuint,
  outInQuint = outInQuint,
  inSine = inSine,
  outSine = outSine,
  inOutSine = inOutSine,
  outInSine = outInSine,
  inExpo = inExpo,
  outExpo = outExpo,
  inOutExpo = inOutExpo,
  outInExpo = outInExpo,
  inCirc = inCirc,
  outCirc = outCirc,
  inOutCirc = inOutCirc,
  outInCirc = outInCirc,
  inElastic = inElastic,
  outElastic = outElastic,
  inOutElastic = inOutElastic,
  outInElastic = outInElastic,
  inBack = inBack,
  outBack = outBack,
  inOutBack = inOutBack,
  outInBack = outInBack,
  inBounce = inBounce,
  outBounce = outBounce,
  inOutBounce = inOutBounce,
  outInBounce = outInBounce,
}
--PATH lua/autorun/cdraw.lua:
if SERVER then return end

CDRAW = CDRAW or {}

local circle_cache = {}

function CDRAW.DrawCircle(x,y,radius,seg)
	local segstr = x..y..radius..seg
	if circle_cache[segstr] then
		surface.DrawPoly(circle_cache[segstr])
	else
		local cir = {}
		cir[#cir+1] = {x=x,y=y,u=0.5,v=0.5}
		for i = 0, seg do
			local a = math.rad((i/seg)*-360)
			cir[#cir+1] = {x=x+math.sin(a)*radius,y=y+math.cos(a)*radius,u=math.sin(a)/2+0.5,v=math.cos(a)/2+0.5}
		end
		local a = math.rad(0)
		cir[#cir+1] = {x=x+math.sin(a)*radius,y=y+math.cos(a)*radius,u=math.sin(a)/2+0.5,v=math.cos(a)/2+0.5}
		circle_cache[segstr] = cir
		surface.DrawPoly(cir)
	end
end

function CDRAW.DrawRect(col,x,y,w,h)
	x, y = math.Round(x), math.Round(y)
	w, h = math.Round(w), math.Round(h)
	surface.SetDrawColor(col.r,col.g,col.b,col.a)
	surface.DrawRect(x,y,w,h)
end

function CDRAW.GetTextSize(...)
	local aye = {...}
	surface.SetFont(aye[1])
	local legx, legy = 0, 0
	for i = 2, #aye do
		if isstring(aye[i]) then
			local xd, yd = surface.GetTextSize(tostring(aye[i]))
			legx = legx + xd
			legy = legy > yd and legy or yd
		end
	end
	return legx, legy
end

function CDRAW.DrawText(...)
	local aye = {...}
	surface.SetFont(aye[1])
	aye[2], aye[3] = math.Round(aye[2]), math.Round(aye[3])
	local oldx, oldy = 0, 0
	for i = 4, #aye do
		if istable(aye[i]) then
			surface.SetTextColor(aye[i].r,aye[i].g,aye[i].b,aye[i].a)
		else
			surface.SetTextPos(aye[2]+oldx,aye[3])
			surface.DrawText(aye[i])
			local _ox, _oy = surface.GetTextSize(aye[i])
			oldx, oldy = oldx+_ox, oldy+_oy
		end
	end
end

function CDRAW.DrawNiceText(Col,Off,Font,Text)
	local sw, sh = CDRAW.GetTextSize(Font,Text)
	CDRAW.DrawText(Font..'_blur',-sw/2,-sh/2-Off,Col,Text)
	CDRAW.DrawText(Font,-sw/2,-sh/2-Off,Col,Text)
end

return CDRAW
--PATH lua/autorun/cgi_cis_droids.lua:
return gluapack()()
--PATH lua/autorun/cis_leaders.lua:
return gluapack()()
--PATH lua/autorun/cis_leaders.lua:
--Add Playermodel
player_manager.AddValidModel( "Poggle the Lesser", "models/player/nsn/poggle.mdl" )
player_manager.AddValidModel( "Wat Tambor", "models/player/nsn/wattambor.mdl" )
player_manager.AddValidModel( "Nute Gunray", "models/player/nsn/gunray.mdl" )
--PATH addons/[technik] darkrp-city-worker/lua/autorun/cityworker_config.lua:
return gluapack()()
--PATH addons/[miecze] mexicano_drzewko/lua/autorun/cl_newdrzewko.lua:
if SERVER then return end
MX_LSCS = MX_LSCS or {}
MX_CatJedi = "JEDI"
MX_LSCS.mats = {}
local function AddMaterialsFromFolder(folder, tbl)
    tbl = tbl or MX_LSCS.mats
    local files, directories = file.Find(folder .. "/*", "GAME")
    for _, dir in ipairs(directories) do
        tbl[dir] = tbl[dir] or {}
        AddMaterialsFromFolder(folder .. "/" .. dir, tbl[dir])
    end
    for _, file in ipairs(files) do
        if string.GetExtensionFromFilename(file) == "png" then
            local materialName = string.StripExtension(file)
            tbl[materialName] = folder .. "/" .. file
        end
    end
end


AddMaterialsFromFolder("materials/fdrzewko")
if !MX_LSCS.mats["drzewko"] then
    LocalPlayer():ChatPrint("[Mexico Drzewko] Brak Contentu. Pobierz content!")
    return
end
local lock = Material(MX_LSCS.mats["drzewko"]["lock"])

surface.CreateFont( "drzewko_name", {
	font = "Arial", -- On Windows/macOS, use the font-name which is shown to you by your operating system Font Viewer. On Linux, use the file name
	extended = false,
	size = ScreenScale(5),
	weight = 1000,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
} )

surface.CreateFont( "drzewko_punkty", {
	font = "Arial", -- On Windows/macOS, use the font-name which is shown to you by your operating system Font Viewer. On Linux, use the file name
	extended = false,
	size = ScreenScale(14),
	weight = 1000,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
} )


local white = Color(255,255,255)
local grey = Color(168,168,168)
local punkty = 0
local owned = {} 

local cats = {
    ["HP"] = {275,411,MX_LSCS.mats["main"]["zdrowie"]},
    ["Moce"] = {830,411,MX_LSCS.mats["main"]["moce"]},
    ["Style Walki"] = {1385,411,MX_LSCS.mats["main"]["style"]},
}

local nazwapaint = function(self, w, h)
    if not self.cache then
        self.cache = {}
        local text = self.t
        surface.SetFont("drzewko_name")
        local maxWidth = self:GetWide()
        local lines = {}
        local currentLine = ""
        local currentWidth = 0

        for word in string.gmatch(text, "%S+") do
            local wordWidth = surface.GetTextSize(word .. " ")
            if currentWidth + wordWidth > maxWidth then
                table.insert(lines, currentLine)
                currentLine = word
                currentWidth = wordWidth
            else
                currentLine = currentLine .. " " .. word
                currentWidth = currentWidth + wordWidth
            end
        end
        table.insert(lines, currentLine)

        for i, line in ipairs(lines) do
            local lineWidth = surface.GetTextSize(line)
            table.insert(self.cache, {text = line, width = lineWidth})
        end
    end
    surface.SetFont("drzewko_name")
    local sizey = select(2, surface.GetTextSize("A"))
    local totalHeight = #self.cache * sizey
    local startY = (h - totalHeight) / 2

    for i, line in ipairs(self.cache) do
        draw.SimpleText(line.text, "drzewko_name", (w - line.width) / 2, startY + (i - 1) * sizey, white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)
    end
end
local function mainopen()
        if !MX_LSCS.abilities then
        MX_LSCS.abilities = {}
        for k,v in ipairs(MX_LSCS.Moce) do
            MX_LSCS.abilities[v.category] = MX_LSCS.abilities[v.category] or {}
            MX_LSCS.abilities[v.category][v.subcategory] = MX_LSCS.abilities[v.category][v.subcategory] or {}
            MX_LSCS.abilities[v.category][v.subcategory][MX_LSCS.Moce[k].tier or #MX_LSCS.abilities[v.category][v.subcategory]+1] = k
        end

    end
    net.Start("Drzewko_RequestTable")
    net.SendToServer()
    if IsValid(MX_LSCS.Derma) then MX_LSCS.Derma:Remove() end 
    MX_LSCS.Derma = vgui.Create("DFrame")
    local frame = MX_LSCS.Derma
    local x,y = ScrW()/1920,ScrH()/1080
    frame:SetSize(x*1920,y*1080)
    frame:SetPos(0,0)
    frame:SetTitle("")
    frame:MakePopup()
    frame:SetAlpha(0)
    frame.Paint = function(self,w,h) draw.RoundedBox(0,0,0,w,h,Color(0,0,0)) end
    frame:DockPadding(0,0,0,0)
    frame:ShowCloseButton(false)

    

    local main = vgui.Create("DPanel",frame)
    main:SetSize(frame:GetWide(),frame:GetTall())
    main:SetPos(0,0)
    main.Paint = nil

    
    local closeb = vgui.Create("DImageButton",frame)
    closeb:SetSize(x*85,x*85)
    closeb:SetPos(x*1787,y*39)
    closeb:SetImage(MX_LSCS.mats["main"]["close"])
    closeb.DoClick = function()
        frame:Remove()
    end

    local opencat = function(cat)
        local pan = vgui.Create("DPanPanel",main)
        pan:SetSize(x*1920,y*871)
        pan:SetPos(x*0,y*209)
        pan.Paint = function(self,w,h)
            draw.RoundedBox(0,0,0,w,h,Color(17,17,17))
        end
        local base = pan:Add("DImage")
        base:SetImage(MX_LSCS.mats["ogolne"]["holokron"])
        base:SetSize(x*111,y*111)
        base:SetPos(x*904,y*1973)
        
        local cof = pan:Add("DImageButton")
        cof:SetImage(MX_LSCS.mats["drzewko"]["cofnij"])
        cof:SetSize(x*133,y*133)
        cof:SetPos(x*1091,y*1973)
        
        cof.DoClick = function() 
            pan:SetMouseInputEnabled(false)
            main:AlphaTo(0,1,0,function()
                main:Clear()
                frame.main()
            end)
        end

        local branch = pan:Add("DPanel")
        branch:SetSize(x*2,y*0)
        branch:SetPos(x*958,(y*1837) + (y*149))
        branch.Paint = function(self,w,h)
            draw.RoundedBox(0,0,0,w,h,Color(92,203,255))
        end
        local num = 0
        local hight = -1
        local inde = -1
        local ab = {}
        pan.Update = function(self)
            for title,tab in pairs(ab) do
                k = tab[2]
                v = tab[1]
                local sciezka = MX_LSCS.Moce[v].sciezka
                local behind = MX_LSCS.Moce[v-1] and MX_LSCS.Moce[v-1].sciezka
                title.have = owned[sciezka]
                title.buyable = !(behind and !owned[behind]) or k == 1
            end
        end
        for k,p in pairs(MX_LSCS.abilities[cat]) do
            num = num + 1
            inde = -1
            if num % 2 == 1 then
                inde = 1
                hight = hight + 1
                branch:SetSize(branch:GetWide(),branch:GetTall() + (y*149))
                branch:SetPos(branch:GetX(),branch:GetY() - (y*149))
            end
            local branchto = pan:Add("DPanel")
                if num % 2 == 0 then
                    branchto:SetPos(x*890,branch:GetY())
                else
                    branchto:SetPos(x*960,branch:GetY())
                end
            branchto:SetSize(x*69,y*2)
            branchto.Paint = function(self,w,h)
                draw.RoundedBox(0,0,0,w,h,Color(92,203,255))
            end
            local t = 0
            local valy = -((y*149) * hight)
            for k,v in ipairs(p) do
                local img = MX_LSCS.Moce[v].icon
                local nazwa = MX_LSCS.Moce[v].name
                local cost = MX_LSCS.Moce[v].cost
                local sciezka = MX_LSCS.Moce[v].sciezka
                local behind = MX_LSCS.Moce[v-1] and MX_LSCS.Moce[v-1].sciezka
                local item = pan:Add("DImageButton")
                local title = vgui.Create("DPanel",item)
                item:SetSize(x*111,y*111)
                title:Dock(FILL)
                title:SetSize(x*111,y*111)
                title:SetMouseInputEnabled(false)
                title.t = nazwa or "PlaceHolder"
                title.have = owned[sciezka]
                title.buyable = !(behind and !owned[behind]) or k == 1
                ab[title] = {v,k}
                title.Paint = function(self,w,h)
                    
                    draw.RoundedBox(0,0,h/2 - h/6,w,h/3,Color(0,0,0,210))
                    if item:IsHovered() and !self.have and self.buyable then
                        draw.RoundedBox(0,0,h-h/4,w,h/4,Color(0,0,0,210))
                        draw.SimpleText("Koszt: " .. cost,"drzewko_name",w/2,h - h*0.05,white,TEXT_ALIGN_CENTER,TEXT_ALIGN_BOTTOM)
                    end
                    if k > 1 and !self.have and !self.buyable then
                        draw.RoundedBox(0,0,0,w,h,Color(0,0,0,201))
                        surface.SetMaterial(lock)
                        surface.SetDrawColor(white)
                        surface.DrawTexturedRect(0,0,w,h)
                    elseif self.have then
                            draw.RoundedBox(0,0,h-h/4,w,h/4,Color(0,0,0,210))
                            draw.SimpleText("POSIADANE","drzewko_name",w/2,h - h*0.05,white,TEXT_ALIGN_CENTER,TEXT_ALIGN_BOTTOM)
                    end

                    nazwapaint(self,w,h) end
                
                local val = ((x*147) * t) * inde

                local posx = x*799
                if inde == 1 then
                    posx = x*1029
                end
                item:SetPos(posx + val, (y*1782) + valy)
                timer.Simple(num/100,function()
                    if !IsValid(item) then return end
                    img = file.Exists(img,"GAME") and img or MX_LSCS.mats["ogolne"]["holokron"]
                    item:SetImage(img)
                end)
                item.DoClick = function(self)
                    if !owned[sciezka] and (!(behind and !owned[behind]) or k == 1) then
                        if LocalPlayer():GetNWInt("jedi_punkty") < cost then return end
                        owned[sciezka] = true
                        net.Start("DrzewoKupSkill")
                            net.WriteString(sciezka)
                        net.SendToServer()
                        pan:Update()
                    end
                end
                if t > 0 then
                    local pas = pan:Add("DPanel")
                    pas:SetSize(x*37,y*2)
                    if inde == -1 then
                        pas:SetPos(item:GetX() + item:GetWide(),item:GetY() + item:GetTall()/2)
                    else
                        pas:SetPos(item:GetX() - pas:GetWide(),item:GetY() + item:GetTall()/2)
                    end
                    pas.Paint = function(self,w,h)
                        draw.RoundedBox(0,0,0,w,h,Color(92,203,255))
                    end
                end

                t = t + 1
            end
            
        end

        pan:OnScroll( -(x*904)/2,-(base:GetY() + base:GetTall() + main:GetY()) )

        pan:Update()
        frame.pan = pan
    end


    local selectcat = function(self)
        frame.transition = true
        main.cat = self.id
        self:MoveTo(x*420,y*0,1,0,-1)
        main:AlphaTo(0,1,0.05)
        self:SizeTo(x*1080,y*1080,1,0,-1,function(anim,self)
            frame.transition = false
            main:Clear()
            main:AlphaTo(255,1,0)
            opencat(main.cat)
        end)
    end



    local mainmenu = function()
        frame:AlphaTo(255,0.5,0)
        main:AlphaTo(255,1,0)
        for k,v in pairs(cats) do
            local cat = vgui.Create("DImageButton",main)
            cat:SetSize(x*259,y*257)
            cat:SetPos(x*v[1],y*v[2])
            cat.id = k
            cat:SetImage(v[3])
            cat.Paint = function(self,w,h)
                if !frame.transition then 
                    if !self:IsHovered() and self:GetColor() ~= grey then
                        self:SetColor(grey)
                    elseif self:GetColor() ~= white then
                        self:SetColor(white)
                    end
                end
            end
            cat.DoClick = selectcat
        end
    end
    frame.main = mainmenu
    local point = vgui.Create("DImage",frame)
    point:SetSize(x*567,y*203)
    point:SetPos(x*676,y*-11)
    point:SetImage(MX_LSCS.mats["ogolne"]["punkty"])
    local points = vgui.Create("DPanel",frame)
    points:SetPos(x*912,y*95)
    points:SetSize(x*97,y*97)
    points.Paint = function(self,w,h)
        draw.SimpleText(LocalPlayer():GetNWInt("jedi_punkty",0),"drzewko_punkty",w/2,h/2,white,TEXT_ALIGN_CENTER,TEXT_ALIGN_CENTER)
    end


    mainmenu()
    

end

list.Set( "DesktopWindows", "LSCSDrzewko", {
	title = "[LSCS] Drzewko NewUI",
	icon = "lscs/ui/icon64.png",
	init = function( icon, window )
        local teamData = RPExtraTeams[LocalPlayer():Team()]
        if (teamData.category ~= MX_CatJedi and teamData.jedi ~= true) then 
            LocalPlayer():ChatPrint("Tylko dla Jedi!") 
            return 
        end
		
        mainopen()
	end
} )

function MX_LSCS.NewNET(tbl)
    if istable(tbl) then
        owned = {}
        for k,v in ipairs(tbl.kupione_upgradey) do
            owned[v] = true
        end
        punkty = tbl.jedi_punkty
        if IsValid(MX_LSCS.Derma) and IsValid(MX_LSCS.Derma.pan) and MX_LSCS.Derma.update ~= nil then
            MX_LSCS.Derma.pan.update()
        end
    end
end

concommand.Add( "drzewko_openmenu_new", function( ply, cmd, args )         
    local teamData = RPExtraTeams[ply:Team()]
    if (teamData.category ~= MX_CatJedi and teamData.jedi ~= true) then 
        ply:ChatPrint("Tylko dla Jedi!") 
        return 
    end 
    mainopen() 
end )

net.Receive("Drzewko_SendTable",function(len)
        local tbl = net.ReadTable()
	MX_LSCS.NewNET(tbl)
end)
--PATH lua/autorun/cl_roll.lua:
local curPitch = 0
local deg = 0
local inRoll = false

local function rollTo()

	deg = net.ReadInt(16)
	inRoll = true
	curPitch = deg-360

end
net.Receive("ClimbRoll", rollTo)

hook.Add("CalcView", "ClimbRollEffect", function(ply, pos, ang, fov)
	
	if (!inRoll) then return; end
	
	local view = GAMEMODE:CalcView(ply, pos, ang, fov)
	curPitch = math.Approach(curPitch, deg, FrameTime() * 625)
	if curPitch == deg then inRoll = false; end
	view.angles.p = curPitch
	return view
	
end)


--PATH lua/autorun/coolzkillchains.lua:
return gluapack()()
--PATH lua/autorun/crewman.lua:
player_manager.AddValidModel( "navy Crewman", 		"models/navy/gnavycrewman.mdl" );
list.Set( "PlayerOptionsModel", "navy Crewman", 	"models/navy/gnavycrewman.mdl" );
--PATH addons/[opt] decals/lua/decals/util/sh_util.lua:
function Decals.Authed( ply )
    return Decals.cfg.Allowed[ ply:SteamID() ] or Decals.cfg.Allowed[ ply:SteamID64() ] or Decals.cfg.Allowed[ ply:GetUserGroup() ]
end

--PATH addons/[opt] decals/lua/decals/util/cl_util.lua:
function Decals.Chat( text, ... )
    local c = 0
    local opts = { ... }
    local msg = text:gsub( "#", function() c = c + 1 return opts[ c ] end )

    return chat.AddText( Decals.cfg.Color, "[Decals] ", color_white, msg )
end

function Decals.NetChat()
    Decals.Chat( net.ReadString() )
end
net.Receive( "Decals.Chat", Decals.NetChat )

--PATH addons/[opt] decals/lua/decals/util/sh_properties.lua:
return gluapack()()
--PATH addons/[opt] decals/lua/decals/load/cl_load.lua:
Decals.Load = Decals.Load or {
    Materials = {},
    Valid = {
        jpg = true,
        jpeg = true,
        png = true
    }
}

function Decals.Load.Initialize()
    if !file.IsDir( "decals", "DATA" ) then
        file.CreateDir "decals"
    end
end

Decals.Load.Initialize()

function Decals.Load.URL( url, callback )
    if Decals.Load.Materials[ url ] then
        callback( Decals.Load.Materials[ url ] )

        return
    end

    local fileExt = url:GetExtensionFromFilename()

    if !fileExt then
        Decals.Chat( "# does not have a file extension! File extension must be either jpg, jpeg or png.", url )

        callback( nil )

        return
    end

    local fileName = "decals/" .. util.CRC( url ) .. "." .. fileExt

    if !Decals.Load.Valid[ fileExt:lower() ] then
        Decals.Chat( "# has an invalid file extension! File extension must be either jpg, jpeg or png.", url )

        callback( nil )

        return
    end

    if file.Exists( fileName, "DATA" ) then
        Decals.Load.Materials[ url ] = Material( "data/" .. fileName )

        callback( Decals.Load.Materials[ url ] )

        return
    end

    Decals.Load.Materials[ url ] = Material "icon16/error.png"

    http.Fetch( url, function( body )
        file.Write( fileName, body )

        Decals.Load.Materials[ url ] = Material( "data/" .. fileName )

        callback( Decals.Load.Materials[ url ] )
    end, function()
        Decals.Chat( "# failed to load!", url )

        callback( nil )
    end )
end

--PATH addons/!discordintegration/lua/discord/core/oop.lua:
Discord.OOP = {}
Discord.OOP.Classes = {}

function Discord.OOP:Register(class, tbl, inherit)
    tbl.class = class
    tbl.inherit = inherit
    self.Classes[class] = tbl
end

function Discord.OOP:New(class, ...)
    if not self.Classes[class] then return nil end

    local steps = {}
    local a = table.Copy(self.Classes[class])
    while(a) do
        table.insert(steps, a)

        if a.inherit then
            a = table.Copy(self.Classes[a.inherit])
        else
            a = nil
        end
    end
    steps = table.Reverse(steps)

    for _, class in ipairs(steps) do
        if class.Constructor then class:Constructor(...) end
    end

    steps = table.Reverse(steps)
    for _, class in ipairs(steps) do
        if _ == 1 then continue end

        steps[_ - 1].inherit = nil
        table.Merge(class, steps[_ - 1])
    end

    return steps[#steps]
end
--PATH addons/!discordintegration/lua/discord/core/classes/rpc.lua:
return gluapack()()
--PATH lua/autorun/dw_npc.lua:
local NPC = {
	Name = "Deathwatch Grunt (Friendly)",
	Class = "npc_citizen",
	Category = "CGI HD Deathwatch",
	Model = "models/dw_grunt/npc_deathwatch_grunt_f.mdl",
	KeyValues = { citizentype = CT_UNIQUE }
}
list.Set( "NPC", "npc_deathwatch_grunt_f", NPC )


local NPC = {
	Name = "Deathwatch Grunt (Hostile)",
	Class = "npc_combine_s",
	Category = "CGI HD Deathwatch",
	Model = "models/dw_grunt/npc_deathwatch_grunt_h.mdl",
}
list.Set( "NPC", "npc_deathwatch_grunt_h", NPC )

local NPC = {
	Name = "Deathwatch CPT (Friendly)",
	Class = "npc_citizen",
	Category = "CGI HD Deathwatch",
	Model = "models/dw_cpt/npc_deathwatch_cpt_f.mdl",
	KeyValues = { citizentype = CT_UNIQUE }
}
list.Set( "NPC", "npc_deathwatch_cpt_f", NPC )


local NPC = {
	Name = "Deathwatch CPT (Hostile)",
	Class = "npc_combine_s",
	Category = "CGI HD Deathwatch",
	Model = "models/dw_cpt/npc_deathwatch_cpt_h.mdl",
}
list.Set( "NPC", "npc_deathwatch_cpt_h", NPC )

local NPC = {
	Name = "Deathwatch Pre Vizsla (Friendly)",
	Class = "npc_citizen",
	Category = "CGI HD Deathwatch",
	Model = "models/dw_previzsla/npc_deathwatch_previzsla_f.mdl",
	KeyValues = { citizentype = CT_UNIQUE }
}
list.Set( "NPC", "npc_deathwatch_previzsla_f", NPC )


local NPC = {
	Name = "Deathwatch Pre Vizsla (Hostile)",
	Class = "npc_combine_s",
	Category = "CGI HD Deathwatch",
	Model = "models/dw_previzsla/npc_deathwatch_previzsla_h.mdl",
}
list.Set( "NPC", "npc_deathwatch_previzsla_h", NPC )

local NPC = {
	Name = "Deathwatch Bo Katan (Friendly)",
	Class = "npc_citizen",
	Category = "CGI HD Deathwatch",
	Model = "models/dw_bokatan/npc_deathwatch_bokatan_f.mdl",
	KeyValues = { citizentype = CT_UNIQUE }
}
list.Set( "NPC", "npc_deathwatch_bokatan_f", NPC )


local NPC = {
	Name = "Deathwatch Bo Katan (Hostile)",
	Class = "npc_combine_s",
	Category = "CGI HD Deathwatch",
	Model = "models/dw_bokatan/npc_deathwatch_bokatan_h.mdl",
}
list.Set( "NPC", "npc_deathwatch_bokatan_h", NPC )

local NPC = {
	Name = "Deathwatch Night Owl (Friendly)",
	Class = "npc_citizen",
	Category = "CGI HD Deathwatch",
	Model = "models/dw_nightowl/npc_deathwatch_nightowl_f.mdl",
	KeyValues = { citizentype = CT_UNIQUE }
}
list.Set( "NPC", "npc_deathwatch_nightowl_f", NPC )


local NPC = {
	Name = "Deathwatch Night Owl (Hostile)",
	Class = "npc_combine_s",
	Category = "CGI HD Deathwatch",
	Model = "models/dw_nightowl/npc_deathwatch_nightowl_h.mdl",
}
list.Set( "NPC", "npc_deathwatch_nightowl_h", NPC )

local NPC = {
	Name = "Maul Deathwatch Huntress (Friendly)",
	Class = "npc_citizen",
	Category = "CGI HD Deathwatch",
	Model = "models/dw_huntress/npc_deathwatch_maul_huntress_f.mdl",
	KeyValues = { citizentype = CT_UNIQUE }
}
list.Set( "NPC", "npc_deathwatch_maul_huntress_f", NPC )


local NPC = {
	Name = "Maul Deathwatch Huntress (Hostile)",
	Class = "npc_combine_s",
	Category = "CGI HD Deathwatch",
	Model = "models/dw_huntress/npc_deathwatch_maul_huntress_h.mdl",
}
list.Set( "NPC", "npc_deathwatch_maul_huntress_h", NPC )

local NPC = {
	Name = "Maul Deathwatch Brute (Friendly)",
	Class = "npc_citizen",
	Category = "CGI HD Deathwatch",
	Model = "models/dw_brute/npc_deathwatch_maul_brute_f.mdl",
	KeyValues = { citizentype = CT_UNIQUE }
}
list.Set( "NPC", "npc_deathwatch_maul_brute_f", NPC )


local NPC = {
	Name = "Maul Deathwatch Brute (Hostile)",
	Class = "npc_combine_s",
	Category = "CGI HD Deathwatch",
	Model = "models/dw_brute/npc_deathwatch_maul_brute_h.mdl",
}
list.Set( "NPC", "npc_deathwatch_maul_brute_h", NPC )

local NPC = {
	Name = "Maul Deathwatch SGT (Friendly)",
	Class = "npc_citizen",
	Category = "CGI HD Deathwatch",
	Model = "models/dw_sgt/npc_deathwatch_maul_sgt_f.mdl",
	KeyValues = { citizentype = CT_UNIQUE }
}
list.Set( "NPC", "npc_deathwatch_maul_sgt_f", NPC )


local NPC = {
	Name = "Maul Deathwatch SGT (Hostile)",
	Class = "npc_combine_s",
	Category = "CGI HD Deathwatch",
	Model = "models/dw_sgt/npc_deathwatch_maul_sgt_h.mdl",
}
list.Set( "NPC", "npc_deathwatch_maul_sgt_h", NPC )

local NPC = {
	Name = "Maul Deathwatch Gar Saxon (Friendly)",
	Class = "npc_citizen",
	Category = "CGI HD Deathwatch",
	Model = "models/dw_garsaxon/npc_deathwatch_maul_garsaxon_f.mdl",
	KeyValues = { citizentype = CT_UNIQUE }
}
list.Set( "NPC", "npc_deathwatch_maul_garsaxon_f", NPC )


local NPC = {
	Name = "Maul Deathwatch Gar Saxon (Hostile)",
	Class = "npc_combine_s",
	Category = "CGI HD Deathwatch",
	Model = "models/dw_garsaxon/npc_deathwatch_maul_garsaxon_h.mdl",
}
list.Set( "NPC", "npc_deathwatch_maul_garsaxon_h", NPC )


--PATH lua/autorun/explosives_particles.lua:
game.AddParticles( "particles/astw2_halo_flamethrower.pcf" )
-- game.AddParticles( "particles/gravity_hammer_fx.pcf" )
game.AddParticles( "particles/iv04_halo_reach_gravity_hammer_effects.pcf" )
game.AddParticles( "particles/iv04_halo_reach_explosions.pcf" )
game.AddParticles( "particles/astw2_halo_pack_muzzle_effects.pcf" )
game.AddParticles( "particles/astw2_halo_pack_muzzle_effects2.pcf" )
game.AddParticles( "particles/astw2_halo_pack_muzzle_effects_human_spv3.pcf" )
game.AddParticles( "particles/astw2_halo_pack_muzzle_effects_covie_spv3.pcf" )
game.AddParticles( "particles/astw2_halo_pack_weapon_projectiles.pcf" )
game.AddParticles( "particles/astw2_gravity_hammer_fx.pcf" )
game.AddParticles( "particles/astw2_halo_pack_explosions.pcf" )
game.AddParticles( "particles/simfphys_halo_muzzle_effects.pcf" )
game.AddParticles( "particles/astw2_halo_4_forerunner_fx.pcf" )
game.AddParticles( "particles/astw2_halo_3_equipment_fx.pcf" )
game.AddParticles( "particles/astw2_halo_3_equipment_explosion_fx.pcf" )
game.AddParticles( "particles/astw2_halo_tracer_fx.pcf" )

--TRACER EFFECTS
PrecacheParticleSystem( "astw2_halo_ce_tracer_ar" )
PrecacheParticleSystem( "astw2_halo_ce_tracer_particle_beam" )
PrecacheParticleSystem( "astw2_halo_ce_tracer_sniper" )
PrecacheParticleSystem( "astw2_halo_ce_tracer_shade" )
PrecacheParticleSystem( "astw2_halo_2_tracer_br" )
PrecacheParticleSystem( "astw2_halo_2_tracer_beam_rifle" )
PrecacheParticleSystem( "astw2_halo_2_tracer_sentinel_beam" )
PrecacheParticleSystem( "astw2_halo_2_tracer_sentinel_beam_blue" )
PrecacheParticleSystem( "astw2_halo_3_tracer_beam_rifle" )
PrecacheParticleSystem( "astw2_halo_2_tracer_carbine" )
PrecacheParticleSystem( "astw2_halo_3_tracer_carbine" )
PrecacheParticleSystem( "astw2_halo_3_tracer_sniper" )
PrecacheParticleSystem( "astw2_halo_3_tracer_sentinel_beam" )
PrecacheParticleSystem( "astw2_halo_3_tracer_spartan_laser" )

--CASING EFFECTS
PrecacheParticleSystem( "astw2_halo_ce_casing_pistol" )
PrecacheParticleSystem( "astw2_halo_ce_casing_rifle" )
PrecacheParticleSystem( "astw2_halo_ce_casing_sniper" )
PrecacheParticleSystem( "astw2_halo_ce_casing_shotgun" )

--IMPACT EFFECTS
PrecacheParticleSystem( "astw2_halo_2_turret_impact_fx" )
PrecacheParticleSystem( "astw2_halo_ce_plasma_rifle_impact_fx" )
PrecacheParticleSystem( "astw2_halo_ce_plasma_pistol_impact_fx" )

--OVERHEAT EFFECTS
PrecacheParticleSystem( "astw2_halo_2_overheat_beam_rifle" )
PrecacheParticleSystem( "astw2_halo_2_overheat_brute_plasma_rifle" )
PrecacheParticleSystem( "astw2_halo_2_overheat_plasma_rifle" )
PrecacheParticleSystem( "astw2_halo_2_overheat_sentinel_beam_blue" )
PrecacheParticleSystem( "astw2_halo_2_overheat_sentinel_beam_red" )
PrecacheParticleSystem( "astw2_halo_3_overheat_beam_rifle" )
PrecacheParticleSystem( "astw2_halo_3_overheat_brute_plasma_rifle" )
PrecacheParticleSystem( "astw2_halo_3_overheat_plasma_pistol_overcharge" )
PrecacheParticleSystem( "astw2_halo_3_overheat_plasma_rifle" )
PrecacheParticleSystem( "astw2_halo_3_overheat_plasma_turret" )
PrecacheParticleSystem( "astw2_halo_ce_overheat_fuel_rod" )
PrecacheParticleSystem( "astw2_halo_ce_overheat_plasma_pistol" )
PrecacheParticleSystem( "astw2_halo_ce_overheat_beam_rifle" )
PrecacheParticleSystem( "astw2_halo_ce_overheat_plasma_rifle" )

--EQUIPMENT STUFF
PrecacheParticleSystem( "astw2_halo_3_bubbleshield_fx" )
PrecacheParticleSystem( "astw2_halo_3_power_drain_fx" )
PrecacheParticleSystem( "astw2_halo_3_power_drain_explosion_fx" )
PrecacheParticleSystem( "astw2_halo_3_deployable_cover_shield_deplete_fx" )
PrecacheParticleSystem( "astw2_halo_3_deployable_cover_impact_fx" )
PrecacheParticleSystem( "astw2_halo_3_deployable_cover_explosion_fx" )
PrecacheParticleSystem( "astw2_halo_3_deployable_shield_depleted_fx" )
PrecacheParticleSystem( "astw2_halo_3_invincibility_fx" )
PrecacheParticleSystem( "astw2_halo_3_invincibility_pickup_fx" )
PrecacheParticleSystem( "astw2_halo_3_invincibility_pickup_fx_flare" )
PrecacheParticleSystem( "astw2_halo_3_invincibility_pickup_fx_vapor" )
PrecacheParticleSystem( "astw2_halo_3_invisibility_pickup_fx" )
PrecacheParticleSystem( "astw2_halo_3_invisibility_pickup_fx_flare" )
PrecacheParticleSystem( "astw2_halo_3_invisibility_pickup_fx_vapor" )
PrecacheParticleSystem( "astw2_halo_3_gravlift_fx" )
PrecacheParticleSystem( "astw2_halo_3_superflare_fx" )
PrecacheParticleSystem( "astw2_halo_3_regenerator_fx" )
PrecacheParticleSystem( "astw2_halo_3_regenerator_explosion_fx" )
PrecacheParticleSystem( "astw2_halo_3_flamethrower_pilot_fx" )
PrecacheParticleSystem( "astw2_halo_3_hammer_fx" )
PrecacheParticleSystem( "astw2_halo_3_hammer_fx_current" )
PrecacheParticleSystem( "astw2_halo_3_sword_fx" )

--Projectile Effects
PrecacheParticleSystem( "astw2_halo_ce_plasma_grenade_trail" )
PrecacheParticleSystem( "astw2_halo_ce_rocket_launcher_trail" )
PrecacheParticleSystem( "astw2_halo_ce_missile_launcher_trail" )
PrecacheParticleSystem( "astw2_halo_ce_missile_launcher_b_trail" )
PrecacheParticleSystem( "astw2_halo_ce_fuel_rod_trail" )
PrecacheParticleSystem( "astw2_halo_2_prophet_beam_projectile_trail" )
PrecacheParticleSystem( "astw2_halo_2_scarab_turret_projectile_trail" )
PrecacheParticleSystem( "astw2_halo_2_scarab_beam_charging" )
PrecacheParticleSystem( "astw2_halo_2_scarab_beam_projectile_trail" )
PrecacheParticleSystem( "astw2_halo_2_gun_tower_charging" )
PrecacheParticleSystem( "astw2_halo_2_gun_tower_projectile_trail" )
PrecacheParticleSystem( "astw2_halo_2_sentinel_beam_tracer" )
PrecacheParticleSystem( "astw2_halo_2_sentinel_beam_blue_tracer" )
PrecacheParticleSystem( "astw2_halo_2_needler_trail" )
PrecacheParticleSystem( "astw2_halo_2_enforcer_needler_trail" )
PrecacheParticleSystem( "astw2_halo_2_brute_plasma_rifle_trail" )
PrecacheParticleSystem( "astw2_halo_2_fuel_rod_projectile_trail" )
PrecacheParticleSystem( "astw2_halo_2_plasma_grenade_trail" )
PrecacheParticleSystem( "astw2_halo_2_plasma_rifle_trail" )
PrecacheParticleSystem( "astw2_halo_2_plasma_pistol_trail" )
PrecacheParticleSystem( "astw2_halo_3_brute_plasma_rifle_trail" )
PrecacheParticleSystem( "astw2_halo_3_plasma_grenade_trail" )
PrecacheParticleSystem( "astw2_halo_3_plasma_rifle_trail" )
PrecacheParticleSystem( "astw2_halo_3_plasma_pistol_trail" )
PrecacheParticleSystem( "astw2_halo_3_plasma_pistol_overcharge_trail" )
PrecacheParticleSystem( "astw2_halo_3_needler_trail" )
PrecacheParticleSystem( "astw2_halo_3_frag_grenade_trail" )
PrecacheParticleSystem( "astw2_halo_3_rocket_launcher_trail" )
PrecacheParticleSystem( "astw2_halo_3_spiker_trail" )
PrecacheParticleSystem( "astw2_halo_3_flood_ranged_form_trail" )
PrecacheParticleSystem( "astw2_halo_spv3_brute_plasma_rifle_trail" )
PrecacheParticleSystem( "astw2_halo_spv3_brute_plasma_pistol_trail" )
PrecacheParticleSystem( "astw2_halo_spv3_plasma_rifle_trail" )
PrecacheParticleSystem( "astw2_halo_spv3_plasma_pistol_trail" )
PrecacheParticleSystem( "astw2_halo_spv3_plasma_pistol_overcharge_trail" )
PrecacheParticleSystem( "astw2_halo_spv3_brute_plasma_pistol_overcharge_trail" )
PrecacheParticleSystem( "astw2_halo_spv3_shredder_trail" )
PrecacheParticleSystem( "astw2_halo_spv3_spiker_trail" )
PrecacheParticleSystem( "astw2_halo_reach_concussion_round_trail" )
PrecacheParticleSystem( "astw2_halo_reach_grenade_launcher_trail" )
PrecacheParticleSystem( "astw2_halo_3_nuke_launcher_trail" )
PrecacheParticleSystem( "astw2_halo_aerial_dark_projectile_trail" )
PrecacheParticleSystem( "astw2_halo_phantom_projectile_fx" )
PrecacheParticleSystem( "astw2_halo_2_impact_phantom_fx" )
PrecacheParticleSystem( "astw2_halo_2_impact_brute_plasma_rifle" )
PrecacheParticleSystem( "astw2_halo_2_impact_carbine" )
PrecacheParticleSystem( "astw2_halo_2_impact_carbine" )
PrecacheParticleSystem( "astw2_halo_2_impact_needler" )
PrecacheParticleSystem( "astw2_halo_2_impact_plasma_rifle" )
--Misc Effects
PrecacheParticleSystem( "flame_halo_3" )
PrecacheParticleSystem( "astw2_halo_3_gravity_hammer_fx" )
--Explosion Effects
PrecacheParticleSystem( "halo_reach_explosion_unsc" )
PrecacheParticleSystem( "halo_reach_explosion_covenant" )
PrecacheParticleSystem( "halo_reach_gravity_hammer_smash" )
PrecacheParticleSystem( "astw2_halo_2_brute_shot_explosion" )
PrecacheParticleSystem( "astw2_halo_2_frag_explosion" )
PrecacheParticleSystem( "astw2_halo_2_mortar_explosion" )
PrecacheParticleSystem( "astw2_halo_2_rocket_explosion" )
PrecacheParticleSystem( "astw2_halo_2_overcharge_impact" )
PrecacheParticleSystem( "astw2_halo_2_fuel_rod_explosion" )
PrecacheParticleSystem( "astw2_halo_2_prophet_explosion" )
PrecacheParticleSystem( "astw2_halo_2_prophet_beam_explosion" )
PrecacheParticleSystem( "astw2_halo_2_scarab_beam_explosion" )
PrecacheParticleSystem( "astw2_halo_2_needler_explosion" )
PrecacheParticleSystem( "astw2_halo_2_plasma_explosion" )
PrecacheParticleSystem( "astw2_halo_3_brute_shot_explosion" )
PrecacheParticleSystem( "astw2_halo_3_firebomb_explosion" )
PrecacheParticleSystem( "astw2_halo_3_frag_explosion" )
PrecacheParticleSystem( "astw2_halo_3_overcharge_impact" )
PrecacheParticleSystem( "astw2_halo_3_fuel_rod_explosion" )
PrecacheParticleSystem( "astw2_halo_3_needler_explosion" )
PrecacheParticleSystem( "astw2_halo_3_plasma_explosion" )
PrecacheParticleSystem( "astw2_halo_3_rocket_explosion" )
PrecacheParticleSystem( "astw2_halo_3_spike_grenade_explosion" )
PrecacheParticleSystem( "astw2_halo_3_hunter_projectile_impact" )
PrecacheParticleSystem( "astw2_halo_spv3_hunter_projectile_impact" )
PrecacheParticleSystem( "astw2_halo_ce_burst_ground" )
PrecacheParticleSystem( "astw2_halo_ce_sml_explosion" )
PrecacheParticleSystem( "astw2_halo_ce_frag_explosion" )
PrecacheParticleSystem( "astw2_halo_ce_rocket_explosion" )
PrecacheParticleSystem( "astw2_halo_ce_needler_explosion" )
PrecacheParticleSystem( "astw2_halo_ce_plasma_explosion" )
PrecacheParticleSystem( "astw2_halo_reach_concussion_rifle_explosion" )
PrecacheParticleSystem( "astw2_halo_reach_fuel_rod_explosion" )
PrecacheParticleSystem( "astw2_halo_reach_needler_explosion" )
PrecacheParticleSystem( "astw2_halo_reach_plasma_explosion" )
PrecacheParticleSystem( "astw2_halo_custom_mac_explosion" )
PrecacheParticleSystem( "astw2_halo_custom_nuke_explosion_XXL" )
PrecacheParticleSystem( "astw2_halo_custom_nuke_explosion_huge" )
PrecacheParticleSystem( "astw2_halo_phantom_projectile_impact_fx" )
PrecacheParticleSystem( "astw2_halo_2_sentinel_impact_blue" )
PrecacheParticleSystem( "astw2_halo_2_sentinel_impact_red" )
--Muzzle Effects
PrecacheParticleSystem( "astw2_halo_aerial_muzzle_dark_carbine" )
PrecacheParticleSystem( "astw2_halo_ce_muzzle_turret_covenant" )
PrecacheParticleSystem( "astw2_halo_spv3_muzzle_beam_rifle" )
PrecacheParticleSystem( "astw2_halo_spv3_muzzle_brute_plasma_pistol" )
PrecacheParticleSystem( "astw2_halo_spv3_muzzle_brute_plasma_rifle" )
PrecacheParticleSystem( "astw2_halo_spv3_muzzle_brute_shot" )
PrecacheParticleSystem( "astw2_halo_spv3_muzzle_carbine" )
PrecacheParticleSystem( "astw2_halo_spv3_muzzle_focus_rifle" )
PrecacheParticleSystem( "astw2_halo_spv3_muzzle_fuel_rod" )
PrecacheParticleSystem( "astw2_halo_spv3_muzzle_mauler" )
PrecacheParticleSystem( "astw2_halo_spv3_muzzle_needler" )
PrecacheParticleSystem( "astw2_halo_spv3_muzzle_particle_carbine" )
PrecacheParticleSystem( "astw2_halo_spv3_muzzle_plasma_pistol" )
PrecacheParticleSystem( "astw2_halo_spv3_muzzle_plasma_rifle" )
PrecacheParticleSystem( "astw2_halo_spv3_muzzle_shredder" )
PrecacheParticleSystem( "astw2_halo_spv3_muzzle_spiker" )
PrecacheParticleSystem( "astw2_halo_spv3_muzzle_assault_rifle" )
PrecacheParticleSystem( "astw2_halo_spv3_muzzle_battle_rifle" )
PrecacheParticleSystem( "astw2_halo_spv3_muzzle_DMR" )
PrecacheParticleSystem( "astw2_halo_spv3_muzzle_magnum" )
PrecacheParticleSystem( "astw2_halo_spv3_muzzle_shotgun" )
PrecacheParticleSystem( "astw2_halo_spv3_muzzle_SMG" )
PrecacheParticleSystem( "astw2_halo_spv3_muzzle_SMG_specops" )
PrecacheParticleSystem( "astw2_halo_spv3_muzzle_sniper_rifle" )
PrecacheParticleSystem( "astw2_halo_spv3_muzzle_sniper_rifle_specops" )
PrecacheParticleSystem( "astw2_halo_ce_muzzle_gravity_wrench_charge" )
PrecacheParticleSystem( "astw2_halo_ce_muzzle_assault_rifle" )
PrecacheParticleSystem( "astw2_halo_ce_muzzle_pistol" )
PrecacheParticleSystem( "astw2_halo_ce_muzzle_shotgun" )
PrecacheParticleSystem( "astw2_halo_ce_muzzle_sniper_rifle" )
PrecacheParticleSystem( "astw2_halo_ce_muzzle_plasma_rifle" )
PrecacheParticleSystem( "astw2_halo_ce_muzzle_fuel_rod" )
PrecacheParticleSystem( "astw2_halo_ce_muzzle_plasma_pistol" )
PrecacheParticleSystem( "astw2_halo_ce_muzzle_needler" )
PrecacheParticleSystem( "astw2_halo_2_muzzle_battle_rifle" )
PrecacheParticleSystem( "astw2_halo_2_muzzle_SMG" )
PrecacheParticleSystem( "astw2_halo_2_muzzle_sniper_rifle" )
PrecacheParticleSystem( "astw2_halo_2_muzzle_shotgun" )
PrecacheParticleSystem( "astw2_halo_2_muzzle_rocket_launcher" )
PrecacheParticleSystem( "astw2_halo_2_muzzle_magnum" )
PrecacheParticleSystem( "astw2_halo_2_muzzle_brute_shot" )
PrecacheParticleSystem( "astw2_halo_2_muzzle_carbine" )
PrecacheParticleSystem( "astw2_halo_2_muzzle_beam_rifle" )
PrecacheParticleSystem( "astw2_halo_2_muzzle_brute_plasma_rifle" )
PrecacheParticleSystem( "astw2_halo_2_muzzle_plasma_rifle" )
PrecacheParticleSystem( "astw2_halo_2_muzzle_fuel_rod" )
PrecacheParticleSystem( "astw2_halo_2_muzzle_plasma_pistol" )
PrecacheParticleSystem( "astw2_halo_2_muzzle_needler" )
PrecacheParticleSystem( "astw2_halo_2_muzzle_sentinel_beam_red" )
PrecacheParticleSystem( "astw2_halo_2_muzzle_sentinel_beam_blue" )
PrecacheParticleSystem( "astw2_halo_3_muzzle_assault_rifle" )
PrecacheParticleSystem( "astw2_halo_3_muzzle_battle_rifle" )
PrecacheParticleSystem( "astw2_halo_3_muzzle_hunter_cannon_charge" )
PrecacheParticleSystem( "astw2_halo_3_muzzle_magnum" )
PrecacheParticleSystem( "astw2_halo_3_muzzle_magnum_ODST" )
PrecacheParticleSystem( "astw2_halo_3_muzzle_SMG" )
PrecacheParticleSystem( "astw2_halo_3_muzzle_SMG_ODST" )
PrecacheParticleSystem( "astw2_halo_3_muzzle_rocket_launcher" )
PrecacheParticleSystem( "astw2_halo_3_muzzle_sniper_rifle" )
PrecacheParticleSystem( "astw2_halo_3_muzzle_shotgun" )
PrecacheParticleSystem( "astw2_halo_3_muzzle_machine_gun_turret" )
PrecacheParticleSystem( "astw2_halo_3_muzzle_missile_pod" )
PrecacheParticleSystem( "astw2_halo_3_muzzle_spartan_laser" )
PrecacheParticleSystem( "astw2_halo_3_muzzle_spartan_laser_charge" )
PrecacheParticleSystem( "astw2_halo_3_muzzle_carbine" )
PrecacheParticleSystem( "astw2_halo_3_muzzle_plasma_rifle" )
PrecacheParticleSystem( "astw2_halo_3_muzzle_brute_plasma_rifle" )
PrecacheParticleSystem( "astw2_halo_3_muzzle_plasma_turret" )
PrecacheParticleSystem( "astw2_halo_3_muzzle_fuel_rod" )
PrecacheParticleSystem( "astw2_halo_3_muzzle_plasma_pistol" )
PrecacheParticleSystem( "astw2_halo_3_muzzle_needler" )
PrecacheParticleSystem( "astw2_halo_3_muzzle_spiker" )
PrecacheParticleSystem( "astw2_halo_3_muzzle_brute_shot" )
PrecacheParticleSystem( "astw2_halo_3_muzzle_mauler" )
PrecacheParticleSystem( "astw2_halo_3_muzzle_mauler_flare" )
PrecacheParticleSystem( "astw2_halo_3_muzzle_nuke_flare" )
PrecacheParticleSystem( "astw2_halo_3_muzzle_laser_painter_flare" )
PrecacheParticleSystem( "astw2_halo_3_muzzle_laser_painter_blue_flare" )
PrecacheParticleSystem( "astw2_halo_3_muzzle_beam_rifle" )
PrecacheParticleSystem( "astw2_halo_3_muzzle_warthog_chaingun" )
PrecacheParticleSystem( "astw2_halo_3_muzzle_warthog_gauss_cannon" )
PrecacheParticleSystem( "astw2_halo_4_muzzle_forerunner_aiming_beam" )
PrecacheParticleSystem( "astw2_halo_reach_muzzle_assault_rifle" )
PrecacheParticleSystem( "astw2_halo_reach_muzzle_DMR" )
PrecacheParticleSystem( "astw2_halo_reach_muzzle_magnum" )
PrecacheParticleSystem( "astw2_halo_reach_muzzle_sniper_rifle" )
PrecacheParticleSystem( "astw2_halo_reach_muzzle_plasma_repeater" )
PrecacheParticleSystem( "astw2_halo_reach_muzzle_plasma_pistol" )
PrecacheParticleSystem( "astw2_halo_reach_muzzle_plasma_rifle" )
PrecacheParticleSystem( "astw2_halo_reach_muzzle_focus_rifle" )
PrecacheParticleSystem( "astw2_halo_reach_muzzle_concussion_rifle" )
PrecacheParticleSystem( "astw2_halo_reach_focus_rifle_impact" )
PrecacheParticleSystem( "astw2_halo_3_sentinel_impact_blue" )
PrecacheParticleSystem( "astw2_halo_3_sentinel_impact_red" )
PrecacheParticleSystem( "astw2_halo_3_laser_beam_blue" )
PrecacheParticleSystem( "astw2_halo_3_laser_beam_red" )
PrecacheParticleSystem( "astw2_halo_3_laser_beam_monitor" )
PrecacheParticleSystem( "simphys_halo_warthog_gauss_muzzle" )
--Decal Effects
game.AddDecal( "astw2_halo_reach_impact_nuke_explosion", "effects/halo_reach/impact_nuke_explosion" )
game.AddDecal( "astw2_halo_reach_impact_soft_terrain_explosion", "effects/halo_reach/impact_soft_terrain_explosion" )
game.AddDecal( "astw2_halo_reach_impact_hard", "effects/halo_reach/impact_hard" )
game.AddDecal( "astw2_halo_reach_impact_hard_medium", "effects/halo_reach/impact_hard_medium" )
game.AddDecal( "astw2_halo_3_sword_impact_medium", "effects/halo3/sword_impact_medium" )
game.AddDecal( "astw2_halo_3_impact_gauss", "effects/halo3/blast_scorch_ring" )
game.AddDecal( "astw2_halo_3_plasma_impact_medium_blue", "effects/halo3/plasma_impact_medium_blue" )
game.AddDecal( "astw2_halo_3_plasma_impact_medium_blue_sentinel", "effects/halo3/plasma_impact_medium_blue_sentinel" )
game.AddDecal( "astw2_halo_3_plasma_impact_medium_red", "effects/halo3/plasma_impact_medium_red" )
game.AddDecal( "astw2_halo_3_plasma_impact_medium_red_laser", "effects/halo3/plasma_impact_medium_red_laser" )
game.AddDecal( "astw2_halo_3_plasma_impact_medium_green", "effects/halo3/plasma_impact_medium_green" )
game.AddDecal( "astw2_halo_3_plasma_impact_medium_green_carbine", "effects/halo3/plasma_impact_medium_green_carbine" )
game.AddDecal( "astw2_halo_3_plasma_impact_large_purple", "effects/halo3/plasma_impact_large_purple" )
game.AddDecal( "astw2_halo_3_plasma_impact_large_green", "effects/halo3/plasma_impact_large_green" )
game.AddDecal( "astw2_halo_3_napalm_splat_large", "effects/halo3/napalm_splat_large1" )
game.AddDecal( "astw2_halo_3_blast_scorch_large", "effects/halo3/blast_scorch_large" )
game.AddDecal( "astw2_halo_2_phantom_plasma_burn", "effects/halo2/phantom_plasma_burn" )
game.AddDecal( "astw2_halo_2_plasma_burn_inner_glow", "effects/halo2/plasma_burn_inner_glow" )
game.AddDecal( "astw2_halo_2_plasma_blue_fizzle", "effects/halo2/plasma_blue_fizzle" )
game.AddDecal( "astw2_halo_2_plasma_blue_glow", "effects/halo2/plasma_blue_glow" )
game.AddDecal( "astw2_halo_2_plasma_burn_inner_glow_brute", "effects/halo2/plasma_burn_inner_glow_brute" )
game.AddDecal( "astw2_halo_2_plasma_red_glow", "effects/halo2/plasma_red_glow" )
game.AddDecal( "astw2_halo_2_plasma_red_fizzle", "effects/halo2/plasma_red_fizzle" )
game.AddDecal( "astw2_halo_2_plasma_explosion_glow_inner", "effects/halo2/plasma_explosion_glow_inner" )
game.AddDecal( "astw2_halo_2_plasma_beam_rifle_glow", "effects/halo2/beam_rifle_glow" )
game.AddDecal( "astw2_halo_2_plasma_green_inner_glow", "effects/halo2/plasma_green_inner_glow" )
game.AddDecal( "astw2_halo_2_plasma_green_glow", "effects/halo2/plasma_green_glow" )
game.AddDecal( "astw2_halo_2_plasma_green_fizzle", "effects/halo2/plasma_green_fizzle" )
game.AddDecal( "astw2_halo_2_default_scorch", "effects/halo2/default_scorch" )
game.AddDecal( "astw2_halo_2_default_blast", "effects/halo2/default_blast" ) 

--Sound STUFF

sound.Add( {
    name = "astw2.halo_nuke_trail",
    channel = CHAN_AUTO,
    volume = 1,
    level = 140,
    sound = { "halo/halo_reach/weapons/nuke/nuke_trail.wav" }
} )

sound.Add( {
    name = "astw2.halo_nuke_explosion",
    channel = CHAN_AUTO,
    volume = 1,
    level = 140,
    sound = { "halo/halo_reach/weapons/nuke/nuke_expl.wav" }
} )

sound.Add( {
    name = "astw2.halo_3_explosion_lrg",
    channel = CHAN_AUTO,
    volume = 1,
    level = 140,
    sound = { "halo/halo_reach/weapons/h3_lrg_expl1.ogg", "halo/halo_reach/weapons/h3_lrg_expl2.ogg", "halo/halo_reach/weapons/h3_lrg_expl3.ogg", "halo/halo_reach/weapons/h3_lrg_expl4.ogg"}
} )
--PATH lua/gmodadminsuite/sh_networking.lua:
return gluapack()()
--PATH lua/gmodadminsuite/lang/english.lua:
return {
	Name = "English",
	Flag = "flags16/gb.png",
	Phrases = function() return {

		open_menu                 = "Open Menu",
		menu_nopermission         = "Sorry, but you do not have permission to access the GmodAdminSuite menu.",
		menu_unknown_module       = "Sorry, but a module with that name is not installed or does not exist.",
		menu_disabled_module      = "Sorry, but that module is disabled.",
		menu_module_nopermission  = "Sorry, you don't have permission to access this module.",
		open_gas                  = "Open GmodAdminSuite",
		module_shortcut           = "Module Shortcut",
		module_reset_data		  = "Reset Module Position/Size",
		module_shortcut_info      = [[You can quickly access this GmodAdminSuite module through console and chat commands.

		To access the module through your console, type: %s
		To access the module through chat, type: %s

		Additionally, you can bind a key on your keyboard to a specific module.
		To do this, in your console, type: %s

		Make sure to replace KEY with a key on your keyboard of your choice.
		%s]],
		close                     = "Close",
		wiki                      = "Wiki",
		licensee                  = "Licensee",
		support                   = "Support",
		module_shop               = "Module Shop",
		welcome                   = "Welcome",
		operator                  = "Operator",
		script_page               = "Script Page",
		wiki                      = "Wiki",
		no_modules_available      = "No modules available!",
		no_modules_available_info = [[Sorry, but there aren't any GmodAdminSuite modules available for you to use.
		You may have insufficient permissions to use any, or none are enabled.]],
		custom_ellipsis           = "Custom...",
		usergroup_ellipsis        = "Usergroup...",
		steamid_ellipsis          = "SteamID...",
		enter_steamid_ellipsis    = "Enter SteamID...",
		by_distance               = "By Distance",
		by_usergroup              = "By Usergroup",
		by_team                   = "By Team",
		by_name                   = "By Name",
		right_click_to_focus      = "Right click to focus",
		unknown                   = "Unknown",
		utilities                 = "Utilities",
		player_management         = "Player Management",
		administration            = "Administration",
		s_second                  = "1 second",
		s_seconds                 = "%d seconds",
		s_minute                  = "1 minute",
		s_minutes                 = "%d minutes",
		s_hour                    = "1 hour",
		s_hours                   = "%d hours",
		second_ago                = "1 second ago",
		seconds_ago               = "%d seconds ago",
		minute_ago                = "1 minute ago",
		minutes_ago               = "%d minutes ago",
		hour_ago                  = "1 hour ago",
		hours_ago                 = "%d hours ago",
		just_now                  = "Just now",
		click_to_focus            = "Click to focus",
		right_click_to_focus      = "Right click to focus",
		add_steamid               = "Custom SteamID",
		copied                    = "Copied!",
		settings                  = "Settings",
		add_steamid_help          = [[Enter a SteamID or SteamID64. Examples:
		SteamID: %s
		SteamID64: %s]],

		setting_default_module = "Default Module",
		setting_default_module_tip = "What module should be opened when the GmodAdminSuite main menu is opened?",
		none = "None",
		general = "General",
		localization = "Localization",
		setting_menu_voicechat = "Allow speaking (voice chat)\nwhen GAS menus are open",
		setting_menu_voicechat_tip = "GmodAdminSuite's menus do not block your voice chat key. If this option is on, just press your voice chat key to talk whilst in a menu.",
		use_gas_language = "Use GmodAdminSuite language",
		default_format = "Default Format",
		short_date_format = "Short Date Format",
		long_date_format = "Long Date Format",
		short_date_format_tip = "Date format used for shorter date formats\n\nThe default format automatically matches the date format of your region (North America, Europe, etc.)",
		long_date_format_tip = "Date format used for longer date formats",
		permissions = "Permissions",
		module_enable_switch_tip = "Changes to this will only apply after a server restart/map change",
		enabled = "Enabled",
		modules = "Modules",
		permissions_help = [[GmodAdminSuite utilizes an open-source permissions library called OpenPermissions, which was developed by Billy for GAS. It provides optimized permissions handling for advanced systems running on any sized server.
		
		OpenPermissions is where you will control what groups can access what modules, and what they can do with those modules.
		It can be opened at any time by typing "!openpermissions" in chat or "openpermissions" in console.

		For help & info, click the "Help" tab in the OpenPermissions menu.]],
		website = "Website",
		fun = "Fun",

		bvgui_copied               = "Copied!",
		bvgui_open_context_menu    = "Open Context Menu",
		bvgui_open_steam_profile   = "Open Steam Profile",
		bvgui_right_click_to_focus = "Right click to focus",
		bvgui_click_to_focus       = "Click to focus",
		bvgui_unknown              = "Unknown",
		bvgui_no_data              = "No data",
		bvgui_no_results_found     = "No results found",
		bvgui_done                 = "Done",
		bvgui_enter_text_ellipsis  = "Enter text...",
		bvgui_loading_ellipsis     = "Loading...",
		bvgui_pin_tip              = "Press ESC to click the menu again",
		bvgui_click_to_render      = "Click to render",
		bvgui_teleport             = "Teleport",
		bvgui_inspecting           = "Inspecting",
		bvgui_inspect              = "Inspect",
		bvgui_screenshot           = "Screenshot",
		bvgui_ok                   = "OK",
		bvgui_screenshot_saved     = "Screenshot Saved",
		bvgui_screenshot_saved_to  = "The screenshot has been saved to %s on your computer",
		bvgui_reset                = "Reset",
		bvgui_right_click_to_stop_rendering = "Right click to stop rendering",

		settings_player_popup_close 		= "Close Player Popups when\nthey lose focus",
		settings_player_popup_close_tip	 	= "Should Player Popups close when you click on a different menu?"
} end }
--PATH addons/[gas] gmodadminsuite-jobwhitelist-1.3.4/lua/gmodadminsuite/modules/jobwhitelist/lang/english.lua:
return gluapack()()
--PATH addons/[gas] gmodadminsuite-jobwhitelist-1.3.4/lua/gmodadminsuite/modules/jobwhitelist/lang/french.lua:
return gluapack()()
--PATH lua/gmodadminsuite/modules/playerdatabase/lang/french.lua:
return gluapack()()
--PATH lua/gmodadminsuite/modules/fpsbooster/_gas_info.lua:
return gluapack()()
--PATH lua/gmodadminsuite/modules/playerdatabase/_gas_info.lua:
return gluapack()()
--PATH lua/gmodadminsuite/modules/playerdatabase/_gas_info.lua:
return {
	Name = "Player Database",
	Category = GAS.MODULE_CATEGORY_PLAYER_MANAGEMENT,
	Icon = "icon16/database.png"
}
--PATH lua/gmodadminsuite/modules/secondaryusergroups/_gas_info.lua:
return {
	DefaultEnabled = true,
	Name = "Secondary Usergroups",
	Category = GAS.MODULE_CATEGORY_PLAYER_MANAGEMENT,
	Wiki = "https://gmodsto.re/gmodadminsuite-secondaryusergroups-wiki",
	Icon = "icon16/group.png",
}
--PATH lua/gmodadminsuite/modules/secondaryusergroups/sh_init.lua:
if (SERVER) then
	AddCSLuaFile("sh_core.lua")
	AddCSLuaFile("cl_menu.lua")
end

GAS:hook("gmodadminsuite:LoadModule:secondaryusergroups", "LoadModule:secondaryusergroups", function()
	include("gmodadminsuite/modules/secondaryusergroups/sh_core.lua")
	if (SERVER) then
		include("gmodadminsuite/modules/secondaryusergroups/sv_secondaryusergroups.lua")
		include("gmodadminsuite/modules/secondaryusergroups/sv_permissions.lua")
	else
		include("gmodadminsuite/modules/secondaryusergroups/cl_menu.lua")
	end
end)
--PATH lua/gmodadminsuite/cl_contextmenu.lua:
return gluapack()()
--PATH lua/autorun/human_pm.lua:
return gluapack()()
--PATH lua/imagetool/sh_batch.lua:
return gluapack()()
--PATH lua/imagetool/cl_hooks.lua:
return gluapack()()
--PATH lua/autorun/install_tfa_base.lua:
local function checkForTFA()
	if TFA and TFA_BASE_VERSION and TFA_BASE_VERSION >= 4 then return end -- we're 100% good

	if CLIENT then
		Derma_Query(
			"The weapon(s) you have installed requires TFA Base. Use the button below to install it.",
			"Install TFA Base !!!",
			"Workshop",
			function() gui.OpenURL("http://steamcommunity.com/workshop/filedetails/?id=415143062") end
		)
	else
		print("#################### WARNING!!! ####################")
		print("The weapon(s) you have installed requires TFA Base.")
		print("http://steamcommunity.com/workshop/filedetails/?id=415143062")
		print("####################################################")
	end
end

hook.Add("InitPostEntity", "INSTALL TFA BASE", checkForTFA)
--PATH lua/autorun/jawawarrior.lua:
player_manager.AddValidModel( "Jawa Warrior",		"models/jajoff/sw/jawa.mdl" );
list.Set( "PlayerOptionsModel", "Jawa Warrior",		"models/jajoff/sw/jawa.mdl" );
--PATH lua/autorun/kiryu_jedi.lua:
player_manager.AddValidModel( "Kiryu Jedi", "models/player/mexicano/kiryu_jedi.mdl" )

--PATH addons/[miecze] moce i hilty/lua/autorun/lscs_best_regards_from_luna.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/autorun/lscs_best_regards_from_luna.lua:
--[[

heavily modified version of GVP's Lightsaber System for public use

please dont reupload, dont resell

best regards luna

]]--

LSCS = istable( LSCS ) and LSCS or { Hilt = {}, Blade = {}, Stance = {}, Force = {},BulletTracerDeflectable = {} }

LSCS.VERSION = 194
LSCS.VERSION_GITHUB = 0
LSCS.VERSION_TYPE = ".GIT"

function LSCS:GetVersion()
	return LSCS.VERSION
end

function LSCS:CheckUpdates()
	http.Fetch("https://raw.githubusercontent.com/SpaxscE/lscs_public/main/lua/autorun/lscs_best_regards_from_luna.lua", function(contents,size) 
		local Entry = string.match( contents, "LSCS.VERSION%s=%s%d+" )

		if Entry then
			LSCS.VERSION_GITHUB = tonumber( string.match( Entry , "%d+" ) ) or 0
		else
			LSCS.VERSION_GITHUB = 0
		end

		if LSCS.VERSION_GITHUB == 0 then
			print("[LSCS] latest version could not be detected, You have Version: "..LSCS:GetVersion())
		else
			if  LSCS:GetVersion() >= LSCS.VERSION_GITHUB then
				print("[LSCS] is up to date, Version: "..LSCS:GetVersion())
			else
				print("[LSCS] a newer version is available! Version: "..LSCS.VERSION_GITHUB..", You have Version: "..LSCS:GetVersion())

				if LSCS.VERSION_TYPE == ".GIT" then
					print("[LSCS] get the latest version at https://github.com/SpaxscE/lscs_public")
				else
					print("[LSCS] restart your game/server to get the latest version!")
				end

				if CLIENT then 
					timer.Simple(18, function() 
						chat.AddText( Color( 255, 0, 0 ), "[LSCS] a newer version is available!" )
					end)
				end
			end
		end
	end)
end

AddCSLuaFile("lscs/init.lua")
include("lscs/init.lua")

if SERVER then
	resource.AddWorkshop( "2837856621" )
end

if CLIENT then
	list.Set( "ContentCategoryIcons", "[LSCS]", "icon16/lscs.png" )
	list.Set( "ContentCategoryIcons", "[LSCS] - Hilts", "icon16/lscs.png" )
	list.Set( "ContentCategoryIcons", "[LSCS] - Force", "icon16/lscs.png" )
	list.Set( "ContentCategoryIcons", "[LSCS] - Crystals", "icon16/lscs.png" )
	list.Set( "ContentCategoryIcons", "[LSCS] - Stances", "icon16/lscs.png" )
end

hook.Add( "InitPostEntity", "!!!lscscheckupdates", function()
	timer.Simple(20, function() LSCS:CheckUpdates() end)
end )

hook.Add( "LSCS:OnPlayerForceUse", "no power", function( ply, id, item )

	-- disallow saber throw useage example
	local teamData = RPExtraTeams[ply:Team()]
    if !teamData or (teamData.category ~= MX_CatJedi and teamData.jedi ~= true) then return false end
end)
hook.Add( "LSCS:OnPlayerCraftedSaber", "no saber", function( ply, weapon_entity )

end )

	hook.Add( "PlayerSpawn", "!!!!!lscs_auto_equip", function( ply )
		if not ply:lscsIsValid() then return end
        local teamData = RPExtraTeams[ply:Team()]
            if !teamData or (teamData.category ~= MX_CatJedi and teamData.jedi ~= true) then 
                ply:lscsSetForceAllowed( false )
                return
            end
        ply:lscsSetForceAllowed( true )
        ply:Give("weapon_lscs")
		ply:lscsCraftSaber()

		local SWEP = ply:GetWeapon( "weapon_lscs" )

		if not IsValid( SWEP ) then return end

		SWEP:SetBlockPoints( 999999 )
	end )

--PATH addons/[miecze] moce i hilty/lua/lscs/combos/juyo-vaapad.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/lscs/combos/lusmadual.lua:
return gluapack()()
--PATH lua/lscs/combos/master_form3.lua:
COMBO.id = "form3c"
COMBO.PrintName = "Master:Soresu(III)"
COMBO.Author = "Storm"
COMBO.Description = "Way of the Mynock."

COMBO.DeflectBullets = true
COMBO.AutoBlock = true

COMBO.BlockDistanceNormal = 60 -- distance of crosshair to block pos until  a normal block is detected with this stance. Avoid using this. Only uncomment if you really need it.
COMBO.BlockDistancePerfect = 35 -- distance of crosshair to block pos until  a perfect block is detected with this stance. Avoid using this. Only uncomment if you really need it.
COMBO.MaxBlockPoints = 130 -- use this to make op boss saber stances. Avoid using this. Only uncomment if you really need it.
COMBO.BPDrainPerHit = 10

COMBO.DamageMultiplier = 1

COMBO.LeftSaberActive = false

COMBO.HoldType = "form3_holdtype"

COMBO.Attacks = {
	["SLAM"] = {
		AttackAnim = "slashdown",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:Freeze( true )
			ply:SetVelocity( Vector(0,0,200) )
			ply:lscsSuppressFalldamage( CurTime() + 5 )

			timer.Simple( 0.5, function()
				if IsValid( weapon ) and IsValid( ply ) then
					ply:SetVelocity( Vector(0,0,-1500) )
				end
			end)
		end,
		FinishAttack = function( weapon, ply )
			ply:Freeze( false )
		end,
		Delay = 0.0,
		Duration = 1.5,
	},
	["FRONT_DASH"] = {
		AttackAnim = "combo4",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			if ply:OnGround() then
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 1600 )
			else
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 600 + Vector(0,0,40) )
			end
		end,

		FinishAttack = function( weapon, ply ) end,
		Delay = 0.2,
		Duration = 0.6,
	 },
	["BACKFLIP"] = {
		AttackAnim = "rollback",
		BeginAttack = function( weapon, ply )  
			weapon:SetDMGActive( false )

			ply:SetVelocity( Vector(0,0,250) - Angle(0,ply:EyeAngles().y,0):Forward() * 50 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 0.5,
	},
	["ROLL_RIGHT"] = {
		AttackAnim = "rollright",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			ply:SetVelocity( Vector(0,0,50) + Angle(0,ply:EyeAngles().y,0):Right() * 600 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 1,
	},
	["ROLL_LEFT"] = {
		AttackAnim = "rollleft",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			ply:SetVelocity( Vector(0,0,50) - Angle(0,ply:EyeAngles().y,0):Right() * 600 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 1,
	},
	["____"] = {
		AttackAnim = "sore_atk_w_55s",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.55,
	},
	["-45-"] = {
		AttackAnim = "sore_atk_w_55s",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()

		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.55,
	},
	["+45+"] = {
		AttackAnim = "sore_atk_w_55s",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.55,
	},
	["W_S_"] = {
		AttackAnim = "sore_atk_w_55s",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.7, Vector(250,0,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.7, 0.2, Vector(100,0,0) )
			ply:lscsSetTimedMove( 3, CurTime() + 0.9, 0.4, Vector(0,0,0) )

			timer.Simple(0.2, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)
			timer.Simple(0.6, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 1,
	},
	["__S_"] = {
		AttackAnim = "sore_atk_s_55s",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.55,
	},
	["_A__"] = {
		AttackAnim = "soresu2_atk1_weighed_55s",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.55,
	},
	["___D"] = {
		AttackAnim = "soresu2_atk2_weighed_55s",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.55,
	},
	["W__D"] = { 
		AttackAnim = "sore_atk_d_55s",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.55,
	},
	["WA__"] = {
		AttackAnim = "sore_atk_a_55s",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.55,
	},
	["__SD"] = {
		AttackAnim = "soresu2_atk6_weighed_55s",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.55,
	},
	["_AS_"] = {
		AttackAnim = "soresu2_atk5_weighed_55s",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.55,
	},
	["W___"] = {
		AttackAnim = "sore_atk_w_55s",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			if ply:OnGround() then
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 1000 )
			end
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.55,
	},
}

--PATH addons/[miecze] moce i hilty/lua/lscs/combos/suma.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/lscs/combos/untrained.lua:
COMBO.id = "untrained"
COMBO.PrintName = "Untrained"
COMBO.Author = "Luna"
COMBO.Description = "Self-Taught Swordsman. The Person using this Stance probably knows how to wield a Saber without hurting himself. However, he still not quite a Jedi yet."

COMBO.DeflectBullets = false
COMBO.AutoBlock = true

COMBO.LeftSaberActive = false

COMBO.HoldType = "melee"

COMBO.DamageMultiplier = 100
COMBO.BPDrainPerHit = 100

COMBO.Attacks = {}
COMBO.Attacks["____"] = {
	AttackAnim = "range_melee",
	AttackAnimMenu = "seq_baton_swing",

	BeginAttack = function( weapon, ply )  
		weapon:DoAttackSound()
	end,
	FinishAttack = function( weapon, ply )  
	end,
	Delay = 0,
	Duration = 0.25,
}
COMBO.Attacks["_A__"] = {
	AttackAnim = "phalanx_b_left_t1",
	AttackAnimStart = 0.2,

	BeginAttack = function( weapon, ply )  
		weapon:DoAttackSound()
	end,
	FinishAttack = function( weapon, ply )  
	end,
	Delay = 0.1,
	Duration = 0.5,
}
COMBO.Attacks["___D"] = {
	AttackAnim = "phalanx_b_right_t1",
	AttackAnimStart = 0.2,

	BeginAttack = function( weapon, ply )  
		weapon:DoAttackSound()
	end,
	FinishAttack = function( weapon, ply )  
	end,
	Delay = 0.1,
	Duration = 0.5,
}
COMBO.Attacks["W_S_"] = {
	AttackAnim = "vanguard_r_s3_t1",

	BeginAttack = function( weapon, ply )  
		weapon:DoAttackSound()

		ply:lscsSetTimedMove( 1, CurTime(), 0.2, Vector(600,0,0) )
		ply:lscsSetTimedMove( 1, CurTime() + 0.2, 0.4, Vector(0,0,0) )
	end,
	FinishAttack = function( weapon, ply ) end,
	Delay = 0.1,
	Duration = 0.5,
}
COMBO.Attacks["__SD"] = {
	AttackAnim = "ryoku_b_s3_t1",
	AttackAnimStart = 0.4,
	BeginAttack = function( weapon, ply )  
		weapon:DoAttackSound()
		ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(-1,1,0) )
	end,
	FinishAttack = function( weapon, ply ) end,
	Delay = 0,
	Duration = 0.5,
}
COMBO.Attacks["_AS_"] = {
	AttackAnim = "ryoku_b_s3_t1",
	BeginAttack = function( weapon, ply )  
		weapon:DoAttackSound()
		ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(-1,-1,0) )
	end,
	FinishAttack = function( weapon, ply ) end,
	Delay = 0,
	Duration = 0.4,
}
--PATH addons/[miecze] moce i hilty/lua/lscs/combos/visigoth.lua:
COMBO.id = "visigoth"
COMBO.PrintName = "Visigoth"
COMBO.Author = "UCCROW"
COMBO.Description = "Visigoth"

COMBO.DeflectBullets = true
COMBO.AutoBlock = true

COMBO.LeftSaberActive = false

COMBO.HoldType = "wos_visigoth_corvinus"

COMBO.Attacks = {
	["SLAM"] = {
		AttackAnim = "slashdown",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:Freeze( true )
			ply:SetVelocity( Vector(0,0,200) )
			ply:lscsSuppressFalldamage( CurTime() + 5 )

			timer.Simple( 0.5, function()
				if IsValid( weapon ) and IsValid( ply ) then
					ply:SetVelocity( Vector(0,0,-1500) )
				end
			end)
		end,
		FinishAttack = function( weapon, ply )
			ply:Freeze( false )
		end,
		Delay = 0.0,
		Duration = 1.5,
	},
	["FRONT_DASH"] = {
		AttackAnim = "cartwheel",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			if ply:OnGround() then
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 1600 )
			else
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 600 + Vector(0,0,40) )
			end
		end,

		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 1.5,
	 },
	["BACKFLIP"] = {
		AttackAnim = "rollback",
		BeginAttack = function( weapon, ply )  
			weapon:SetDMGActive( false )

			ply:SetVelocity( Vector(0,0,250) - Angle(0,ply:EyeAngles().y,0):Forward() * 50 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 0.5,
	},
	["ROLL_RIGHT"] = {
		AttackAnim = "rollright",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			ply:SetVelocity( Vector(0,0,50) + Angle(0,ply:EyeAngles().y,0):Right() * 600 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 1,
	},
	["ROLL_LEFT"] = {
		AttackAnim = "rollleft",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			ply:SetVelocity( Vector(0,0,50) - Angle(0,ply:EyeAngles().y,0):Right() * 600 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 1,
	},
	["____"] = {
		AttackAnim = "ryoku_r_c1_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.6,
	},
	["-45-"] = {
		AttackAnim = "vanguard_r_s3_t3",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(10,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.4,
	},
	["+45+"] = {
		AttackAnim = "a_combo4",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(10,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.3,
	},
	["W_S_"] = {
		AttackAnim = "wos_bs_shared_recovery_attack",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.7, Vector(250,0,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.7, 0.2, Vector(100,0,0) )
			ply:lscsSetTimedMove( 3, CurTime() + 0.9, 0.4, Vector(0,0,0) )

			timer.Simple(0.2, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)
			timer.Simple(0.6, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.6,
	},
	["__S_"] = {
		AttackAnim = "phalanx_b_s1_t1",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(-10,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.6,
	},
	["_A__"] = {
		AttackAnim = "pure_b_left_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.2, Vector(0,-100,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.2, 0.1, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.6,
	},
	["___D"] = {
		AttackAnim = "pure_b_right_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.2, Vector(0,100,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.2, 0.1, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.6,
	},
	["W__D"] = {
		AttackAnim = "ryoku_a_right_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.4, Vector(1,1,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.2,
		Duration = 0.6,
	},
	["WA__"] = {
		AttackAnim = "ryoku_a_left_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(25,-25,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.6,
	},
	["__SD"] = {
		AttackAnim = "wos_bs_shared_flourish_heavy",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(-1,1,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.6,
	},
	["_AS_"] = {
		AttackAnim = "wos_bs_shared_flourish_heavy",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(-1,-1,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.6,
	},
	["W___"] = {
		AttackAnim = "vanguard_a_s1_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			if ply:OnGround() then
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 1000 )
			end
			ply:lscsSetTimedMove( 1, CurTime(), 0.9, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.9,
	},
}

--PATH addons/[miecze] moce i hilty/lua/lscs/combos/yongli.lua:
COMBO.id = "yongli"
COMBO.PrintName = "YongLi"
COMBO.Author = "Luna"
COMBO.Description = "Standard Sword Art. Quick to learn, hard to master, but balanced and combat proven."

COMBO.DeflectBullets = true
COMBO.AutoBlock = true

COMBO.LeftSaberActive = false

COMBO.HoldType = "slam"

COMBO.Attacks = {
	["SLAM"] = {
		AttackAnim = "slashdown",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:Freeze( true )
			ply:SetVelocity( Vector(0,0,200) )
			ply:lscsSuppressFalldamage( CurTime() + 5 )

			timer.Simple( 0.5, function()
				if IsValid( weapon ) and IsValid( ply ) then
					ply:SetVelocity( Vector(0,0,-1500) )
				end
			end)
		end,
		FinishAttack = function( weapon, ply )
			ply:Freeze( false )
		end,
		Delay = 0.0,
		Duration = 1.5,
	},
	["FRONT_DASH"] = {
		AttackAnim = "combo4",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			if ply:OnGround() then
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 1600 )
			else
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 600 + Vector(0,0,40) )
			end
		end,

		FinishAttack = function( weapon, ply ) end,
		Delay = 0.2,
		Duration = 0.6,
	 },
	["BACKFLIP"] = {
		AttackAnim = "rollback",
		BeginAttack = function( weapon, ply )  
			weapon:SetDMGActive( false )

			ply:SetVelocity( Vector(0,0,250) - Angle(0,ply:EyeAngles().y,0):Forward() * 50 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 0.5,
	},
	["ROLL_RIGHT"] = {
		AttackAnim = "rollright",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			ply:SetVelocity( Vector(0,0,50) + Angle(0,ply:EyeAngles().y,0):Right() * 600 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 1,
	},
	["ROLL_LEFT"] = {
		AttackAnim = "rollleft",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			ply:SetVelocity( Vector(0,0,50) - Angle(0,ply:EyeAngles().y,0):Right() * 600 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 1,
	},
	["____"] = {
		AttackAnim = "a_combo3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.3,
	},
	["-45-"] = {
		AttackAnim = "vanguard_r_s3_t3",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(10,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.4,
	},
	["+45+"] = {
		AttackAnim = "a_combo4",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(10,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.3,
	},
	["W_S_"] = {
		AttackAnim = "h_left_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.7, Vector(250,0,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.7, 0.2, Vector(100,0,0) )
			ply:lscsSetTimedMove( 3, CurTime() + 0.9, 0.4, Vector(0,0,0) )

			timer.Simple(0.2, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)
			timer.Simple(0.6, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 1.3,
	},
	["__S_"] = {
		AttackAnim = "a_combo4",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(-10,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.3,
	},
	["_A__"] = {
		AttackAnim = "a_combo3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.2, Vector(0,-100,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.2, 0.1, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.3,
	},
	["___D"] = {
		AttackAnim = "combo2",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.2, Vector(0,100,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.2, 0.1, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.3,
	},
	["W__D"] = {
		AttackAnim = "combo4",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.4, Vector(1,1,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.2,
		Duration = 0.6,
	},
	["WA__"] = {
		AttackAnim = "combo3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(25,-25,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.3,
	},
	["__SD"] = {
		AttackAnim = "a_combo2",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(-1,1,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.3,
	},
	["_AS_"] = {
		AttackAnim = "combo1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(-1,-1,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.3,
	},
	["W___"] = {
		AttackAnim = "combo32",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			if ply:OnGround() then
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 1000 )
			end
			ply:lscsSetTimedMove( 1, CurTime(), 0.9, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.8,
	},
}

--PATH addons/[miecze] moce i hilty/lua/lscs/content/blades_inq.lua:
local blade = {}
blade.PrintName = "EnergoModule" -- nice name in the menu
blade.Author = "Miller"
blade.id = "elst" -- internal ID. Always lower case.
blade.color_blur = Color(60,19,119)
blade.color_core = Color(163,84,212)
--blade.mdl = "models/lscs/weapons/nanosword_bladefx.mdl" -- use a model as blade?
--blade.mdl_poseparameter = "blade_retract" -- pose parameter to retract the blade. Should go from 0-1
blade.length = 21 -- blade length
blade.width = 0.9 -- width
blade.widthWiggle = 5 -- how much "noise" the blade has idling
blade.material_core_tip = Material( "lscs/effects/lightsaber_tip" ) -- material of the inner cores blade-tip
blade.material_core = Material( "lscs/effects/lightsaber_core" ) -- material of the inner cores blade
blade.material_glow = Material( "lscs/effects/lightsaber_glow" ) -- glow sprite effect
blade.material_trail = Material( "lscs/effects/lightsaber_trail" ) -- what material to use for the trail
blade.dynamic_light = true -- show dynamic light?
blade.no_trail = false -- disable trail?
blade.sounds = {
	Attack = "nanosword_hup",
	Attack1 = "nanosword_hup",
	Attack2 = "nanosword_hup",
	Attack3 = "nanosword_hup",
	Activate = "nanosword_turnon",
	Disable = "nanosword_turnoff",
	Idle =  "nanosword_idle",
}
LSCS:RegisterBlade( blade ) -- register it to the system. This will also register a new entity


local blade = {}
blade.PrintName = "EnergoModule Long" -- nice name in the menu
blade.Author = "Miller"
blade.id = "elstl" -- internal ID. Always lower case.
blade.color_blur = Color(60,19,119)
blade.color_core = Color(163,84,212)
--blade.mdl = "models/lscs/weapons/nanosword_bladefx.mdl" -- use a model as blade?
--blade.mdl_poseparameter = "blade_retract" -- pose parameter to retract the blade. Should go from 0-1
blade.length = 25 -- blade length
blade.width = 0.9 -- width
blade.widthWiggle = 6 -- how much "noise" the blade has idling
blade.material_core_tip = Material( "lscs/effects/lightsaber_tip" ) -- material of the inner cores blade-tip
blade.material_core = Material( "lscs/effects/lightsaber_core" ) -- material of the inner cores blade
blade.material_glow = Material( "lscs/effects/lightsaber_glow" ) -- glow sprite effect
blade.material_trail = Material( "lscs/effects/lightsaber_trail" ) -- what material to use for the trail
blade.dynamic_light = true -- show dynamic light?
blade.no_trail = false -- disable trail?
blade.sounds = {
	Attack = "nanosword_hup",
	Attack1 = "nanosword_hup",
	Attack2 = "nanosword_hup",
	Attack3 = "nanosword_hup",
	Activate = "nanosword_turnon",
	Disable = "nanosword_turnoff",
	Idle =  "nanosword_idle",
}
LSCS:RegisterBlade( blade ) -- register it to the system. This will also register a new entity



local blade = {}
blade.PrintName = "EnergoModule Bat" -- nice name in the menu
blade.Author = "Miller"
blade.id = "elstb" -- internal ID. Always lower case.
blade.color_blur = Color(60,19,119)
blade.color_core = Color(163,84,212)
--blade.mdl = "models/lscs/weapons/nanosword_bladefx.mdl" -- use a model as blade?
--blade.mdl_poseparameter = "blade_retract" -- pose parameter to retract the blade. Should go from 0-1
blade.length = 15 -- blade length
blade.width = 2 -- width
blade.widthWiggle = 8 -- how much "noise" the blade has idling
blade.material_core_tip = Material( "lscs/effects/lightsaber_tip" ) -- material of the inner cores blade-tip
blade.material_core = Material( "lscs/effects/lightsaber_core" ) -- material of the inner cores blade
blade.material_glow = Material( "lscs/effects/lightsaber_glow" ) -- glow sprite effect
blade.material_trail = Material( "lscs/effects/lightsaber_trail" ) -- what material to use for the trail
blade.dynamic_light = true -- show dynamic light?
blade.no_trail = false -- disable trail?
blade.sounds = {
	Attack = "nanosword_hup",
	Attack1 = "nanosword_hup",
	Attack2 = "nanosword_hup",
	Attack3 = "nanosword_hup",
	Activate = "nanosword_turnon",
	Disable = "nanosword_turnoff",
	Idle =  "nanosword_idle",
}
LSCS:RegisterBlade( blade ) -- register it to the system. This will also register a new entity


local blade = {}
blade.PrintName = "EnergoModule Katana" -- nice name in the menu
blade.Author = "Miller"
blade.id = "elstk" -- internal ID. Always lower case.
blade.color_blur = Color(60,19,119)
blade.color_core = Color(163,84,212)
--blade.mdl = "models/lscs/weapons/nanosword_bladefx.mdl" -- use a model as blade?
--blade.mdl_poseparameter = "blade_retract" -- pose parameter to retract the blade. Should go from 0-1
blade.length = 40 -- blade length
blade.width = 0.9 -- width
blade.widthWiggle = 4 -- how much "noise" the blade has idling
blade.material_core_tip = Material( "lscs/effects/lightsaber_tip" ) -- material of the inner cores blade-tip
blade.material_core = Material( "lscs/effects/lightsaber_core" ) -- material of the inner cores blade
blade.material_glow = Material( "lscs/effects/lightsaber_glow" ) -- glow sprite effect
blade.material_trail = Material( "lscs/effects/lightsaber_trail" ) -- what material to use for the trail
blade.dynamic_light = true -- show dynamic light?
blade.no_trail = false -- disable trail?
blade.sounds = {
	Attack = "nanosword_hup",
	Attack1 = "nanosword_hup",
	Attack2 = "nanosword_hup",
	Attack3 = "nanosword_hup",
	Activate = "nanosword_turnon",
	Disable = "nanosword_turnoff",
	Idle =  "nanosword_idle",
}
LSCS:RegisterBlade( blade ) -- register it to the system. This will also register a new entity

local blade = {}
blade.PrintName = "Electrohammer Crystal" -- nice name in the menu
blade.Author = "Midnight"
blade.id = "elecham" -- internal ID. Always lower case.
blade.color_blur = Color(60,19,119)
blade.color_core = Color(163,84,212)
--blade.mdl = "models/lscs/weapons/nanosword_bladefx.mdl" -- use a model as blade?
--blade.mdl_poseparameter = "blade_retract" -- pose parameter to retract the blade. Should go from 0-1
blade.length = 10 -- blade length
blade.width = 0.9 -- width
blade.widthWiggle = 5 -- how much "noise" the blade has idling
blade.material_core_tip = Material( "lscs/effects/lightsaber_tip" ) -- material of the inner cores blade-tip
blade.material_core = Material( "lscs/effects/lightsaber_core" ) -- material of the inner cores blade
blade.material_glow = Material( "lscs/effects/lightsaber_glow" ) -- glow sprite effect
blade.material_trail = Material( "lscs/effects/lightsaber_trail" ) -- what material to use for the trail
blade.dynamic_light = true -- show dynamic light?
blade.no_trail = false -- disable trail?
blade.sounds = {
	Attack = "nanosword_hup",
	Attack1 = "nanosword_hup",
	Attack2 = "nanosword_hup",
	Attack3 = "nanosword_hup",
	Activate = "nanosword_turnon",
	Disable = "nanosword_turnoff",
	Idle =  "nanosword_idle",
}
LSCS:RegisterBlade( blade ) -- register it to the system. This will also register a new entity
--PATH addons/[miecze] moce i hilty/lua/lscs/content/blades_lscs_extension.lua:

--[[
	v v v Blade v v v
]]
local blade = {}
blade.PrintName = "Purple Electrostaff Crystal" 
blade.Author = "BadJay707"
blade.id = "purpstaff"
blade.color_blur = Color(163,84,212)
blade.color_core = Color(163,84,212)
blade.length = 13
blade.width = 0.9 
blade.widthWiggle = 5
blade.material_core_tip = Material( "lscs/effects/lightsaber_tip" ) 
blade.material_core = Material( "lscs/effects/lightsaber_core" )
blade.material_glow = Material( "lscs/effects/lightsaber_glow" ) 
blade.material_trail = Material( "lscs/effects/lightsaber_trail" ) 
blade.dynamic_light = true 
blade.no_trail = false 
blade.sounds = {
	Attack = "nanosword_hup",
	Attack1 = "nanosword_hup",
	Attack2 = "nanosword_hup",
	Attack3 = "nanosword_hup",
	Activate = "nanosword_turnon",
	Disable = "nanosword_turnoff",
	Idle =  "nanosword_idle",
}
LSCS:RegisterBlade( blade )

local blade = {}
blade.PrintName = "Yellow Electrostaff Crystal" 
blade.Author = "BadJay707"
blade.id = "yellstaff"
blade.color_blur = Color(255,255,51)
blade.color_core = Color(255,255,255)
blade.length = 13
blade.width = 0.9 
blade.widthWiggle = 5
blade.material_core_tip = Material( "lscs/effects/lightsaber_tip" ) 
blade.material_core = Material( "lscs/effects/lightsaber_core" )
blade.material_glow = Material( "lscs/effects/lightsaber_glow" ) 
blade.material_trail = Material( "lscs/effects/lightsaber_trail" ) 
blade.dynamic_light = true 
blade.no_trail = false 
blade.sounds = {
	Attack = "nanosword_hup",
	Attack1 = "nanosword_hup",
	Attack2 = "nanosword_hup",
	Attack3 = "nanosword_hup",
	Activate = "nanosword_turnon",
	Disable = "nanosword_turnoff",
	Idle =  "nanosword_idle",
}
LSCS:RegisterBlade( blade ) 

local blade = {}
blade.PrintName = "Mandalorian Royal Staff Crystal" 
blade.Author = "BadJay707"
blade.id = "mandostaffcrys"
blade.color_blur = Color(0,0,0)
blade.color_core = Color(0,0,0)
blade.length = 13
blade.width = 0.9 
blade.widthWiggle = 5
blade.material_core_tip = Material( "lscs/effects/lightsaber_tip" ) 
blade.material_core = Material( "lscs/effects/lightsaber_core" )
blade.material_glow = Material( "lscs/effects/lightsaber_glow" ) 
blade.material_trail = Material( "lscs/effects/lightsaber_trail" ) 
blade.dynamic_light = true 
blade.no_trail = true 
blade.sounds = {
	Attack = "nanosword_hup",
	Attack1 = "nanosword_hup",
	Attack2 = "nanosword_hup",
	Attack3 = "nanosword_hup",
	Activate = "",
	Disable = "",
	Idle =  "",
}
LSCS:RegisterBlade( blade )


local blade = {}
blade.PrintName = "Electrostaff Crystal" 
blade.Author = "BadJay707"
blade.id = "mandostaffcrys"
blade.color_blur = Color(255,255,0)
blade.color_core = Color(255,255,255)
blade.length = 13
blade.width = 0.9 
blade.widthWiggle = 5
blade.material_core_tip = Material( "lscs/effects/lightsaber_tip" ) 
blade.material_core = Material( "lscs/effects/lightsaber_core" )
blade.material_glow = Material( "lscs/effects/lightsaber_glow" ) 
blade.material_trail = Material( "lscs/effects/lightsaber_trail" ) 
blade.dynamic_light = true 
blade.no_trail = false 
blade.sounds = {
	Attack = "nanosword_hup",
	Attack1 = "nanosword_hup",
	Attack2 = "nanosword_hup",
	Attack3 = "nanosword_hup",
	Activate = "nanosword_turnon",
	Disable = "nanosword_turnoff",
	Idle =  "nanosword_idle",
}
LSCS:RegisterBlade( blade )

local blade = {}
blade.PrintName = "Force Pike Crystal" 
blade.Author = "BadJay707"
blade.Spawnable = false
blade.id = "forcepikecrys"
blade.color_blur = Color(0,0,0)
blade.color_core = Color(0,0,0)
blade.length = 49
blade.width = 0.9 
blade.widthWiggle = 5
blade.material_core_tip = Material( "lscs/effects/lightsaber_tip" ) 
blade.material_core = Material( "lscs/effects/lightsaber_core" )
blade.material_glow = Material( "lscs/effects/lightsaber_glow" ) 
blade.material_trail = Material( "lscs/effects/lightsaber_trail" ) 
blade.dynamic_light = true 
blade.no_trail = true 
blade.sounds = {
	Attack = "nanosword_hup",
	Attack1 = "nanosword_hup",
	Attack2 = "nanosword_hup",
	Attack3 = "nanosword_hup",
	Activate = "",
	Disable = "",
	Idle =  "",
}
LSCS:RegisterBlade( blade )

local blade = {}
blade.PrintName = "Savage Spear Crystal" 
blade.Author = "BadJay707"
blade.Spawnable = false
blade.id = "savagespearcrys"
blade.color_blur = Color(0,0,0)
blade.color_core = Color(0,0,0)
blade.length = 30
blade.width = 8
blade.widthWiggle = 8
blade.material_core_tip = Material( "lscs/effects/lightsaber_tip" ) 
blade.material_core = Material( "lscs/effects/lightsaber_core" )
blade.material_glow = Material( "lscs/effects/lightsaber_glow" ) 
blade.material_trail = Material( "lscs/effects/lightsaber_trail" ) 
blade.dynamic_light = true 
blade.no_trail = true 
blade.sounds = {
	Attack = "nanosword_hup",
	Attack1 = "nanosword_hup",
	Attack2 = "nanosword_hup",
	Attack3 = "nanosword_hup",
	Activate = "",
	Disable = "",
	Idle =  "",
}
LSCS:RegisterBlade( blade )

local blade = {}
blade.PrintName = "Skreeji Pike Crystal" 
blade.Author = "BadJay707"
blade.Spawnable = false
blade.id = "skreejipikecrys"
blade.color_blur = Color(0,0,0)
blade.color_core = Color(0,0,0)
blade.length = 15
blade.width = 6
blade.widthWiggle = 6
blade.material_core_tip = Material( "lscs/effects/lightsaber_tip" ) 
blade.material_core = Material( "lscs/effects/lightsaber_core" )
blade.material_glow = Material( "lscs/effects/lightsaber_glow" ) 
blade.material_trail = Material( "lscs/effects/lightsaber_trail" ) 
blade.dynamic_light = true 
blade.no_trail = true
blade.sounds = {
	Attack = "nanosword_hup",
	Attack1 = "nanosword_hup",
	Attack2 = "nanosword_hup",
	Attack3 = "nanosword_hup",
	Activate = "",
	Disable = "",
	Idle =  "",
}
LSCS:RegisterBlade( blade )

local blade = {}
blade.PrintName = "Spear Crystal" 
blade.Author = "BadJay707"
blade.Spawnable = false
blade.id = "spearcrys"
blade.color_blur = Color(0,0,0)
blade.color_core = Color(0,0,0)
blade.length = 9
blade.width = 2
blade.widthWiggle = 2
blade.material_core_tip = Material( "lscs/effects/lightsaber_tip" ) 
blade.material_core = Material( "lscs/effects/lightsaber_core" )
blade.material_glow = Material( "lscs/effects/lightsaber_glow" ) 
blade.material_trail = Material( "lscs/effects/lightsaber_trail" ) 
blade.dynamic_light = true 
blade.no_trail = true
blade.sounds = {
	Attack = "nanosword_hup",
	Attack1 = "nanosword_hup",
	Attack2 = "nanosword_hup",
	Attack3 = "nanosword_hup",
	Activate = "",
	Disable = "",
	Idle =  "",
}
LSCS:RegisterBlade( blade )

local blade = {}
blade.PrintName = "Sycthe Crystal" 
blade.Author = "BadJay707"
blade.Spawnable = false
blade.id = "sycthecrys"
blade.color_blur = Color(0,0,0)
blade.color_core = Color(0,0,0)
blade.length = 30
blade.width = 8
blade.widthWiggle = 8
blade.material_core_tip = Material( "lscs/effects/lightsaber_tip" ) 
blade.material_core = Material( "lscs/effects/lightsaber_core" )
blade.material_glow = Material( "lscs/effects/lightsaber_glow" ) 
blade.material_trail = Material( "lscs/effects/lightsaber_trail" ) 
blade.dynamic_light = true 
blade.no_trail = true
blade.sounds = {
	Attack = "nanosword_hup",
	Attack1 = "nanosword_hup",
	Attack2 = "nanosword_hup",
	Attack3 = "nanosword_hup",
	Activate = "",
	Disable = "",
	Idle =  "",
}
LSCS:RegisterBlade( blade )

local blade = {}
blade.PrintName = "Tusken Gaffi Crystal" 
blade.Author = "BadJay707"
blade.Spawnable = false
blade.id = "tuskengafficrys"
blade.color_blur = Color(0,0,0)
blade.color_core = Color(0,0,0)
blade.length = 9
blade.width = 5
blade.widthWiggle = 5
blade.material_core_tip = Material( "lscs/effects/lightsaber_tip" ) 
blade.material_core = Material( "lscs/effects/lightsaber_core" )
blade.material_glow = Material( "lscs/effects/lightsaber_glow" ) 
blade.material_trail = Material( "lscs/effects/lightsaber_trail" ) 
blade.dynamic_light = true 
blade.no_trail = true
blade.sounds = {
	Attack = "nanosword_hup",
	Attack1 = "nanosword_hup",
	Attack2 = "nanosword_hup",
	Attack3 = "nanosword_hup",
	Activate = "",
	Disable = "",
	Idle =  "",
}
LSCS:RegisterBlade( blade )

local blade = {}
blade.PrintName = "Commanding Burning Yellow"
blade.Author = "BadJay707"
blade.id = "commandingburningyellow"
blade.color_blur = Color(255,0,0)
blade.color_core = Color(255,191,0)
blade.length = 45
blade.width = 0.9 
blade.widthWiggle = 0.6 
blade.material_core_tip = Material( "lscs/effects/lightsaber_tip" ) 
blade.material_core = Material( "lscs/effects/lightsaber_core" ) 
blade.material_glow = Material( "lscs/effects/lightsaber_glow" ) 
blade.material_trail = Material( "lscs/effects/lightsaber_trail" ) 
blade.dynamic_light = true 
blade.no_trail = false 
blade.sounds = {
	Attack = "saber_hup", 
	Attack1 = "saber_spin1", 
	Attack2 = "saber_spin2", 
	Attack3 = "saber_spin3", 
	Activate = "saber_turnon",
	Disable = "saber_turnoff",
	Idle =  "lscs/saber/saberhum4.wav",
}
LSCS:RegisterBlade( blade )

local blade = {}
blade.PrintName = "White Blue Purple"
blade.Author = "BadJay707"
blade.id = "whitebluepurple"
blade.color_blur = Color(98,3,186)
blade.color_core = Color(0,65,255)
blade.length = 45 
blade.width = 0.9 
blade.widthWiggle = 0.6 
blade.material_core_tip = Material( "lscs/effects/lightsaber_tip" ) 
blade.material_core = Material( "lscs/effects/lightsaber_core" ) 
blade.material_glow = Material( "lscs/effects/lightsaber_glow" ) 
blade.material_trail = Material( "lscs/effects/lightsaber_trail" ) 
blade.dynamic_light = true 
blade.no_trail = false 
blade.sounds = {
	Attack = "saber_hup", 
	Attack1 = "saber_spin1", 
	Attack2 = "saber_spin2",
	Attack3 = "saber_spin3", 
	Activate = "saber_turnon",
	Disable = "saber_turnoff",
	Idle =  "lscs/saber/saberhum4.wav",
}
LSCS:RegisterBlade( blade )

local blade = {}
blade.PrintName = "Fire Orange"
blade.Author = "BadJay707"
blade.id = "fireorange" 
blade.color_blur = Color(255,0,0)
blade.color_core = Color(255,165,0)
blade.length = 45 
blade.width = 0.9
blade.widthWiggle = 0.6
blade.material_core_tip = Material( "lscs/effects/lightsaber_tip" ) 
blade.material_core = Material( "lscs/effects/lightsaber_core" ) 
blade.material_glow = Material( "lscs/effects/lightsaber_glow" ) 
blade.material_trail = Material( "lscs/effects/lightsaber_trail" ) 
blade.dynamic_light = true 
blade.no_trail = false 
blade.sounds = {
	Attack = "saber_hup", 
	Attack1 = "saber_spin1", 
	Attack2 = "saber_spin2", 
	Attack3 = "saber_spin3", 
	Activate = "saber_turnon",
	Disable = "saber_turnoff",
	Idle =  "lscs/saber/saberhum4.wav",
}
LSCS:RegisterBlade( blade ) 

local blade = {}
blade.PrintName = "Fallen Red"
blade.Author = "BadJay707"
blade.id = "fallenred"
blade.color_blur = Color(100,0,0)
blade.color_core = Color(255,153,153)
blade.length = 45 
blade.width = 0.9 
blade.widthWiggle = 0.6 
blade.material_core_tip = Material( "lscs/effects/lightsaber_tip" ) 
blade.material_core = Material( "lscs/effects/lightsaber_core" ) 
blade.material_glow = Material( "lscs/effects/lightsaber_glow" ) 
blade.material_trail = Material( "lscs/effects/lightsaber_trail" ) 
blade.dynamic_light = true 
blade.no_trail = false 
blade.sounds = {
	Attack = "saber_hup", 
	Attack1 = "saber_spin1", 
	Attack2 = "saber_spin2", 
	Attack3 = "saber_spin3", 
	Activate = "saber_turnon",
	Disable = "saber_turnoff",
	Idle =  "lscs/saber/saberhum4.wav",
}
LSCS:RegisterBlade( blade ) 

local blade = {}
blade.PrintName = "Pink Yellow"
blade.Author = "BadJay707"
blade.id = "pinkyellow" 
blade.color_blur = Color(115,104,0)
blade.color_core = Color(199,21,133)
blade.length = 45 
blade.width = 0.9 
blade.widthWiggle = 0.6 
blade.material_core_tip = Material( "lscs/effects/lightsaber_tip" ) 
blade.material_core = Material( "lscs/effects/lightsaber_core" ) 
blade.material_glow = Material( "lscs/effects/lightsaber_glow" ) 
blade.material_trail = Material( "lscs/effects/lightsaber_trail" ) 
blade.dynamic_light = true 
blade.no_trail = false 
blade.sounds = {
	Attack = "saber_hup", 
	Attack1 = "saber_spin1", 
	Attack2 = "saber_spin2", 
	Attack3 = "saber_spin3", 
	Activate = "saber_turnon",
	Disable = "saber_turnoff",
	Idle =  "lscs/saber/saberhum4.wav",
}
LSCS:RegisterBlade( blade ) 

local blade = {}
blade.PrintName = "Rotworm Purple" 
blade.Author = "BadJay707"
blade.id = "rotwormpurple" 
blade.color_blur = Color(138,43,226)
blade.color_core = Color(238,130,238)
blade.length = 45 
blade.width = 0.9 
blade.widthWiggle = 0.6 
blade.material_core_tip = Material( "lscs/effects/lightsaber_tip" ) 
blade.material_core = Material( "lscs/effects/lightsaber_core" ) 
blade.material_glow = Material( "lscs/effects/lightsaber_glow" ) 
blade.material_trail = Material( "lscs/effects/lightsaber_trail" ) 
blade.dynamic_light = true 
blade.no_trail = false 
blade.sounds = {
	Attack = "saber_hup", 
	Attack1 = "saber_spin1",
	Attack2 = "saber_spin2", 
	Attack3 = "saber_spin3", 
	Activate = "saber_turnon",
	Disable = "saber_turnoff",
	Idle =  "lscs/saber/saberhum4.wav",
}
LSCS:RegisterBlade( blade )

local blade = {}
blade.PrintName = "Gold Core" 
blade.Author = "BadJay707"
blade.id = "goldcore" 
blade.color_blur = Color(205,120,1)
blade.color_core = Color(139,69,19)
blade.length = 45 
blade.width = 0.9 
blade.widthWiggle = 0.6 
blade.material_core_tip = Material( "lscs/effects/lightsaber_tip" ) 
blade.material_core = Material( "lscs/effects/lightsaber_core" ) 
blade.material_glow = Material( "lscs/effects/lightsaber_glow" ) 
blade.material_trail = Material( "lscs/effects/lightsaber_trail" ) 
blade.dynamic_light = true 
blade.no_trail = false 
blade.sounds = {
	Attack = "saber_hup", 
	Attack1 = "saber_spin1", 
	Attack2 = "saber_spin2", 
	Attack3 = "saber_spin3", 
	Activate = "saber_turnon",
	Disable = "saber_turnoff",
	Idle =  "lscs/saber/saberhum4.wav",
}
LSCS:RegisterBlade( blade )

local blade = {}
blade.PrintName = "Sovereign Gold and Blue" 
blade.Author = "BadJay707"
blade.id = "sovereigngoldblue" 
blade.color_blur = Color(0,0,128)
blade.color_core = Color(255,255,0)
blade.length = 45 
blade.width = 0.9 
blade.widthWiggle = 0.6 
blade.material_core_tip = Material( "lscs/effects/lightsaber_tip" ) 
blade.material_core = Material( "lscs/effects/lightsaber_core" ) 
blade.material_glow = Material( "lscs/effects/lightsaber_glow" ) 
blade.material_trail = Material( "lscs/effects/lightsaber_trail" ) 
blade.dynamic_light = true 
blade.no_trail = false 
blade.sounds = {
	Attack = "saber_hup", 
	Attack1 = "saber_spin1", 
	Attack2 = "saber_spin2", 
	Attack3 = "saber_spin3", 
	Activate = "saber_turnon",
	Disable = "saber_turnoff",
	Idle =  "lscs/saber/saberhum4.wav",
}
LSCS:RegisterBlade( blade )

local blade = {}
blade.PrintName = "Lime Green" 
blade.Author = "BadJay707"
blade.id = "limegreen" 
blade.color_blur = Color(0,100,0)
blade.color_core = Color(50,205,50)
blade.length = 45 
blade.width = 0.9 
blade.widthWiggle = 0.6 
blade.material_core_tip = Material( "lscs/effects/lightsaber_tip" ) 
blade.material_core = Material( "lscs/effects/lightsaber_core" ) 
blade.material_glow = Material( "lscs/effects/lightsaber_glow" ) 
blade.material_trail = Material( "lscs/effects/lightsaber_trail" ) 
blade.dynamic_light = true 
blade.no_trail = false 
blade.sounds = {
	Attack = "saber_hup", 
	Attack1 = "saber_spin1", 
	Attack2 = "saber_spin2", 
	Attack3 = "saber_spin3", 
	Activate = "saber_turnon",
	Disable = "saber_turnoff",
	Idle =  "lscs/saber/saberhum4.wav",
}
LSCS:RegisterBlade( blade )

local blade = {}
blade.PrintName = "Mint Green" 
blade.Author = "BadJay707"
blade.id = "mintgreen" 
blade.color_blur = Color(45,188,78)
blade.color_core = Color(255,255,255)
blade.length = 45 
blade.width = 0.9 
blade.widthWiggle = 0.6 
blade.material_core_tip = Material( "lscs/effects/lightsaber_tip" ) 
blade.material_core = Material( "lscs/effects/lightsaber_core" ) 
blade.material_glow = Material( "lscs/effects/lightsaber_glow" ) 
blade.material_trail = Material( "lscs/effects/lightsaber_trail" ) 
blade.dynamic_light = true 
blade.no_trail = false 
blade.sounds = {
	Attack = "saber_hup", 
	Attack1 = "saber_spin1", 
	Attack2 = "saber_spin2", 
	Attack3 = "saber_spin3", 
	Activate = "saber_turnon",
	Disable = "saber_turnoff",
	Idle =  "lscs/saber/saberhum4.wav",
}
LSCS:RegisterBlade( blade )

local blade = {}
blade.PrintName = "Ice Blue" 
blade.Author = "BadJay707"
blade.id = "iceblue" 
blade.color_blur = Color(58,195,195)
blade.color_core = Color(72,209,204)
blade.length = 45 
blade.width = 0.9 
blade.widthWiggle = 0.6 
blade.material_core_tip = Material( "lscs/effects/lightsaber_tip" ) 
blade.material_core = Material( "lscs/effects/lightsaber_core" ) 
blade.material_glow = Material( "lscs/effects/lightsaber_glow" ) 
blade.material_trail = Material( "lscs/effects/lightsaber_trail" ) 
blade.dynamic_light = true 
blade.no_trail = false 
blade.sounds = {
	Attack = "saber_hup", 
	Attack1 = "saber_spin1", 
	Attack3 = "saber_spin3", 
	Activate = "saber_turnon",
	Disable = "saber_turnoff",
	Idle =  "lscs/saber/saberhum4.wav",
}
LSCS:RegisterBlade( blade )

local blade = {}
blade.PrintName = "Sea Green" 
blade.Author = "BadJay707"
blade.id = "seagreen" 
blade.color_blur = Color(50,205,50)
blade.color_core = Color(0,250,154)
blade.length = 45 
blade.width = 0.9 
blade.widthWiggle = 0.6 
blade.material_core_tip = Material( "lscs/effects/lightsaber_tip" ) 
blade.material_core = Material( "lscs/effects/lightsaber_core" ) 
blade.material_glow = Material( "lscs/effects/lightsaber_glow" ) 
blade.material_trail = Material( "lscs/effects/lightsaber_trail" ) 
blade.dynamic_light = true 
blade.no_trail = false 
blade.sounds = {
	Attack = "saber_hup", 
	Attack1 = "saber_spin1", 
	Attack2 = "saber_spin2", 
	Attack3 = "saber_spin3", 
	Activate = "saber_turnon",
	Disable = "saber_turnoff",
	Idle =  "lscs/saber/saberhum4.wav",
}
LSCS:RegisterBlade( blade ) 

local blade = {}
blade.PrintName = "Silver Blue" 
blade.Author = "BadJay707"
blade.id = "silverblue" 
blade.color_blur = Color(144,180,211)
blade.color_core = Color(255,255,255)
blade.length = 45 
blade.width = 0.9 
blade.widthWiggle = 0.6 
blade.material_core_tip = Material( "lscs/effects/lightsaber_tip" ) 
blade.material_core = Material( "lscs/effects/lightsaber_core" ) 
blade.material_glow = Material( "lscs/effects/lightsaber_glow" ) 
blade.material_trail = Material( "lscs/effects/lightsaber_trail" ) 
blade.dynamic_light = true 
blade.no_trail = false 
blade.sounds = {
	Attack = "saber_hup", 
	Attack1 = "saber_spin1", 
	Attack2 = "saber_spin2", 
	Attack3 = "saber_spin3", 
	Activate = "saber_turnon",
	Disable = "saber_turnoff",
	Idle =  "lscs/saber/saberhum4.wav",
}
LSCS:RegisterBlade( blade )

local blade = {}
blade.PrintName = "Orange Gold" 
blade.Author = "ink"
blade.id = "orangegold" 
blade.color_blur = Color(255,246,92)
blade.color_core = Color(255,209,67)
blade.length = 45 
blade.width = 0.9 
blade.widthWiggle = 0.6 
blade.material_core_tip = Material( "lscs/effects/lightsaber_tip" ) 
blade.material_core = Material( "lscs/effects/lightsaber_coreorange" ) 
blade.material_glow = Material( "lscs/effects/lightsaber_glow" ) 
blade.material_trail = Material( "lscs/effects/lightsaber_trail" ) 
blade.dynamic_light = true 
blade.no_trail = false 
blade.sounds = {
	Attack = "saber_hup", 
	Attack1 = "saber_spin1", 
	Attack2 = "saber_spin2", 
	Attack3 = "saber_spin3", 
	Activate = "saber_turnon",
	Disable = "saber_turnoff",
	Idle =  "lscs/saber/saberhum4.wav",
}
LSCS:RegisterBlade( blade )

local blade = {}
blade.PrintName = "Tythian Flame"
blade.Author = "Ink"
blade.id = "tythianflame" 
blade.color_blur = Color(115,104,0)
blade.color_core = Color(251,177,111)
blade.length = 45 
blade.width = 0.9 
blade.widthWiggle = 0.6 
blade.material_core_tip = Material( "lscs/effects/lightsaber_tip" ) 
blade.material_core = Material( "lscs/effects/lightsaber_core" ) 
blade.material_glow = Material( "lscs/effects/lightsaber_glow" ) 
blade.material_trail = Material( "lscs/effects/lightsaber_trail" ) 
blade.dynamic_light = true 
blade.no_trail = false 
blade.sounds = {
	Attack = "saber_hup", 
	Attack1 = "saber_spin1", 
	Attack2 = "saber_spin2", 
	Attack3 = "saber_spin3", 
	Activate = "saber_turnon",
	Disable = "saber_turnoff",
	Idle =  "lscs/saber/saberhum4.wav",
}
LSCS:RegisterBlade( blade ) 

local blade = {}
blade.PrintName = "Pink Purple"
blade.Author = "Ink"
blade.id = "pinkpurple" 
blade.color_blur = Color(74,17,136)
blade.color_core = Color(255,102,196)
blade.length = 45 
blade.width = 0.9 
blade.widthWiggle = 0.6 
blade.material_core_tip = Material( "lscs/effects/lightsaber_tip" ) 
blade.material_core = Material( "lscs/effects/lightsaber_core" ) 
blade.material_glow = Material( "lscs/effects/lightsaber_glow" ) 
blade.material_trail = Material( "lscs/effects/lightsaber_trail" ) 
blade.dynamic_light = true 
blade.no_trail = false 
blade.sounds = {
	Attack = "saber_hup", 
	Attack1 = "saber_spin1", 
	Attack2 = "saber_spin2", 
	Attack3 = "saber_spin3", 
	Activate = "saber_turnon",
	Disable = "saber_turnoff",
	Idle =  "lscs/saber/saberhum4.wav",
}
LSCS:RegisterBlade( blade ) 

local blade = {}
blade.PrintName = "Furious Red Yellow" 
blade.Author = "ink"
blade.id = "furiousredyellow" 
blade.color_blur = Color(159,180,0)
blade.color_core = Color(255,255,255)
blade.length = 45 
blade.width = 0.9 
blade.widthWiggle = 0.6 
blade.material_core_tip = Material( "lscs/effects/lightsaber_tipred" ) 
blade.material_core = Material( "lscs/effects/lightsaber_corered" ) 
blade.material_glow = Material( "lscs/effects/lightsaber_glow" ) 
blade.material_trail = Material( "lscs/effects/lightsaber_trail" ) 
blade.dynamic_light = true 
blade.no_trail = false 
blade.sounds = {
	Attack = "saber_hup", 
	Attack1 = "saber_spin1", 
	Attack2 = "saber_spin2", 
	Attack3 = "saber_spin3", 
	Activate = "saber_turnon",
	Disable = "saber_turnoff",
	Idle =  "lscs/saber/saberhum4.wav",
}
LSCS:RegisterBlade( blade )

local blade = {}
blade.PrintName = "Electrostaff Crystal" 
blade.Author = "BadJay707"
blade.id = "electrostaffcrys"
blade.color_blur = Color(240,230,140)
blade.color_core = Color(240,230,140)
blade.length = 10
blade.width = 1
blade.widthWiggle = 5
blade.material_core_tip = Material( "lscs/effects/lightsaber_tip" ) 
blade.material_core = Material( "lscs/effects/lightsaber_core" )
blade.material_glow = Material( "lscs/effects/lightsaber_glow" ) 
blade.material_trail = Material( "lscs/effects/lightsaber_trail" ) 
blade.dynamic_light = true 
blade.no_trail = false 
blade.sounds = {
	Attack = "nanosword_hup",
	Attack1 = "nanosword_hup",
	Attack2 = "nanosword_hup",
	Attack3 = "nanosword_hup",
	Activate = "nanosword_turnon",
	Disable = "nanosword_turnoff",
	Idle =  "nanosword_idle",
}
LSCS:RegisterBlade( blade )
--PATH addons/[miecze] moce i hilty/lua/lscs/content/force_block.lua:
local force = {}
force.PrintName = "Immunity [Advanced]"
force.Author = "Blu-x92 / Luna"
force.Description = "Incoming Force Power attacks are absorbed and regain Force Points. Also gives a permanent immunity against incoming Force Powers as long your own Force Points are above 50% even when this Power is not activated. Only the weak minded don't learn this ability."
force.id = "immunityii"

force.Equip = function( ply ) ply._lscsForceResistant = true end
force.UnEquip = function( ply ) ply._lscsForceResistant = nil ply:GetNWBool( "_lscsForceProtect", false ) end
force.StartUse = function( ply )
	local Time = CurTime()

	local CanDo = (ply._lscsNextForce or 0) < Time

	if not CanDo then return end

	ply._lscsNextForce = Time + 1

	if ply:GetNWBool( "_lscsForceProtect", false ) then
		ply:SetNWBool( "_lscsForceProtect", false )
	else
		if ply:lscsGetForce() < 20 then return end

		ply:SetNWBool( "_lscsForceProtect", true )
		ply._lscsBlockTime = CurTime() + 30

		ply:EmitSound("lscs/force/protect.mp3")

		ply:lscsTakeForce( 20 )
	end

end
LSCS:RegisterForce( force )

local force = {}
force.PrintName = "Immunity [Mastered]"
force.Author = "Storm"
force.Description = "Gives a permanent immunity against incoming Force Powers as long your own Force Points are above 50% even when this Power is not activated. Only the weak minded don't learn this ability."
force.id = "immunityiii"

force.Equip = function( ply ) ply._lscsForceResistant = true end
force.UnEquip = function( ply ) ply._lscsForceResistant = nil ply:GetNWBool( "_lscsForceProtect", false ) end
force.StartUse = function( ply )
	local Time = CurTime()

	local CanDo = (ply._lscsNextForce or 0) < Time

	if not CanDo then return end

	ply._lscsNextForce = Time + 1

	if ply:GetNWBool( "_lscsForceProtect", false ) then
		ply:SetNWBool( "_lscsForceProtect", false )
	else
		if ply:lscsGetForce() < 20 then return end

		ply:SetNWBool( "_lscsForceProtect", true )
		ply._lscsBlockTime = CurTime() + 40

		ply:EmitSound("lscs/force/protect.mp3")

		ply:lscsTakeForce( 20 )
	end

end
LSCS:RegisterForce( force )
--PATH addons/[miecze] moce i hilty/lua/lscs/content/force_clas_cleave.lua:
local force = {}
force.PrintName = "Dismantle"
force.Author = "Solace"
force.Description = "Know your place, you fool."
force.id = "clascleave" -- lowercase only

force.OnClk =  function( ply, TIME )
	if ply._holdingcleave then	
		ply._CleaveTimer = (math.Clamp( (CurTime() - ply._CleaveStart ), 0, 10 ) )
		
		if ply._CleaveTimer < 10 then
			ply:lscsTakeForce( 1 )
		end
	end
end

force.StartUse = function( ply )
	if ply:lscsGetForce() < 50 then return end -- do we have enough force points ?
	
	local Time = CurTime()
	
	ply._holdingcleave = false
	
	local CanCleave = (ply._lscsNextForce or 0) < Time
	
	if not CanCleave then return end
	
	ply._holdingcleave = true
	ply._CleaveStart = CurTime()
end
force.StopUse = function( ply )
	if ply._holdingcleave then
		local AimVector = ply:GetAimVector()
		local MyPos = ply:GetShootPos()
		ply.EffectPos = nil
		
		local CleaveDamage = math.Clamp( (100 * ply._CleaveTimer), 100, 1000 )
		
		for _, Ent in pairs( ents.FindInSphere( MyPos, 800 ) ) do
			local Sub = (Ent.GetShootPos and Ent:GetShootPos() or Ent:GetPos()) - MyPos
			local ToTarget = Sub:GetNormalized()

			if math.deg( math.acos( math.Clamp( AimVector:Dot( ToTarget ) ,-1,1) ) ) < 30 then
				local Dist = Sub:Length()

				if IsValid( Ent ) and Dist < 400 then
					if Ent:IsNPC() or Ent:IsPlayer() then
						local BoneID = Ent:LookupBone("ValveBiped.Bip01_Spine")
						if BoneID then
							ply.EffectPos = Ent:GetBonePosition(BoneID)
						end
						
						for i = 0, 20 do
							timer.Simple( 0.025 * i, function ()
								ply:EmitSound("weapons/knife/knife_deploy1.wav")
							end)
						end
					
						timer.Simple( 0.5, function()
							if Ent:IsValid() then
								if BoneID then
									ply.EffectPos = Ent:GetBonePosition(BoneID)
								end
								local effectdata = EffectData()
								effectdata:SetOrigin( ply.EffectPos or Ent:GetPos() - (AimVector * 20) )
								effectdata:SetEntity( Ent )
								effectdata:SetScale(2)
								effectdata:SetMagnitude(18)
								util.Effect( "force_cleave", effectdata, true, true )
								
								for i = 0, 20 do
									local effectdata2 = EffectData()
									effectdata2:SetOrigin( (ply.EffectPos or Ent:GetPos()) + ( VectorRand() * math.Rand( 50, 80 )) )
									effectdata2:SetEntity( Ent )
									effectdata2:SetScale(2)
									effectdata2:SetMagnitude(18)
									util.Effect( "force_cleave_sparkle", effectdata2, true, true )
								end
								
								
								Ent:TakeDamage(CleaveDamage , ply, ply)
								Ent:EmitSound("weapons/knife/knife_hit1.wav")
							return end
						end)
					end
				end
			end
		end	
		
		ply._lscsNextForce = CurTime() + 3
		LSCS:PlayVCDSequence( ply, "gesture_item_give", 0.5 )
		ply._holdingcleave = false
	end
end
LSCS:RegisterForce( force )
--PATH addons/[miecze] moce i hilty/lua/lscs/content/force_greaterpush.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/lscs/content/force_purify.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/lscs/content/hilt_anzatis.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/lscs/content/hilts_badjay.lua:
local hilt = {}
hilt.PrintName = "Bandit Hilt1"
hilt.Author = "BadJay707"
hilt.id = "bandit1"
hilt.mdl = "models/plo/cwa/sabers/bandit_saber1.mdl"
hilt.info = {
	ParentData = {
		["RH"] = {
			bone = "ValveBiped.Bip01_R_Hand",
			pos = Vector(3, -1.3, -7),
			ang = Angle(-90, 7, 10),
		},
		["LH"] = {
			bone = "ValveBiped.Bip01_L_Hand",
			pos = Vector(3, -1.3, -7),
            ang = Angle(-90,0,0),
		},
	},
GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(1.8, -0.5, -0.1) ),
                dir = ent:LocalToWorldAngles( Angle(-90, -7, 10) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Bandit Hilt2"
hilt.Author = "BadJay707"
hilt.id = "bandit2"
hilt.mdl = "models/plo/cwa/sabers/bandit_saber2.mdl"
hilt.info = {
	ParentData = {
		["RH"] = {
			bone = "ValveBiped.Bip01_R_Hand",
			pos = Vector(3, -1.3, -7),
			ang = Angle(-90, 100, 0),
		},
		["LH"] = {
			bone = "ValveBiped.Bip01_L_Hand",
			pos = Vector(3, -1.3, -7),
            ang = Angle(-90,0,0),
		},
	},
GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(1.8, -0.4, -0.1) ),
                dir = ent:LocalToWorldAngles( Angle(-90, -7, 10) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Bandit Hilt3"
hilt.Author = "BadJay707"
hilt.id = "bandit3"
hilt.mdl = "models/plo/cwa/sabers/bandit_saber3.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
			bone = "ValveBiped.Bip01_R_Hand",
			pos = Vector(3, -1.3, -7),
			ang = Angle(-90, 7, 10),
		},
		["LH"] = {
			bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3, -1.3, -7),
            ang = Angle(-90,0,0),
		},
    },
    GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(1.8, -0.5, -0.1) ),
                dir = ent:LocalToWorldAngles( Angle(-90, -7, 10) ):Up(),
            },
            [2] = {
                pos = ent:LocalToWorld( Vector(1,-0.5,1.1) ),
                dir = ent:LocalToWorldAngles( Angle(-50,0,0) ):Up(),
		length_multiplier = 0.15,
		width_multiplier = 0.3,
            },
            [3] = {
                pos = ent:LocalToWorld( Vector(1,-0.5,-1.35) ),
                dir = ent:LocalToWorldAngles( Angle(-130,0,0) ):Up(),
		length_multiplier = 0.15,
		width_multiplier = 0.3,
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Electrostaff"
hilt.Author = "BadJay707"
hilt.Spawnable = false
hilt.id = "electrostaff"
hilt.mdl = "models/plo/cwa/melee/electro_staff.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.65, -1.05, -10),
            ang = Angle(-90,0,0),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1.5, 10),
            ang = Angle(90,0,0),
        },
    },
    GetBladePos = function( ent ) 
               local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(-20,-0.9,0) ),
                dir = ent:LocalToWorldAngles( Angle(90,180,0) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Magnaguard Electrostaff"
hilt.Author = "BadJay707"
hilt.Spawnable = false
hilt.id = "magnastaff"
hilt.mdl = "models/plo/cwa/melee/magna_staff.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.65, -1.05, 3),
            ang = Angle(90,0,0),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1.5, 0),
            ang = Angle(90,0,0),
        },
    },
    GetBladePos = function( ent ) 
               local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(-20,-0.9,0) ),
                dir = ent:LocalToWorldAngles( Angle(90,180,0) ):Up(),
            },
	        [2] = {
                pos = ent:LocalToWorld( Vector(29,-0.9,0) ),
                dir = ent:LocalToWorldAngles( Angle(-90,-180,0) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Mandalorian Royal Staff"
hilt.Author = "BadJay707"
hilt.Spawnable = false
hilt.id = "mandostaff"
hilt.mdl = "models/plo/cwa/melee/mandalorian_royal_staff.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.65, -1.05, 3),
            ang = Angle(90,0,0),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1.5, 0),
            ang = Angle(90,0,0),
        },
    },
    GetBladePos = function( ent ) 
               local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(-20,-0.9,0) ),
                dir = ent:LocalToWorldAngles( Angle(90,180,0) ):Up(),
            },
            [2] = {
                pos = ent:LocalToWorld( Vector(29,-0.9,0) ),
                dir = ent:LocalToWorldAngles( Angle(-90,-180,0) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Savage Spear"
hilt.Author = "BadJay707"
hilt.Spawnable = false
hilt.id = "savagespear"
hilt.mdl = "models/plo/cwa/melee/savage_spear.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.2, -2.5, -14.7),
            ang = Angle(-90,180,0),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -2.5, 14.7),
            ang = Angle(90,0,0),
        },
    },
    GetBladePos = function( ent ) 
               local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(-10,-0.9,1) ),
                dir = ent:LocalToWorldAngles( Angle(90,180,0) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Skreeji Pike"
hilt.Author = "BadJay707"
hilt.Spawnable = false
hilt.id = "skreejipike"
hilt.mdl = "models/plo/cwa/melee/skreeji_pike.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.2, -2.5, -14.7),
            ang = Angle(-90,180,0),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -2.5, 14.7),
            ang = Angle(90,0,0),
        },
    },
    GetBladePos = function( ent ) 
               local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(-17,-0.9,5) ),
                dir = ent:LocalToWorldAngles( Angle(90,180,0) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Spear"
hilt.Author = "BadJay707"
hilt.Spawnable = false
hilt.id = "spear"
hilt.mdl = "models/plo/cwa/melee/spear.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.2, -2.5, -0.1),
            ang = Angle(90,180,0),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.2, 0, -0.1),
            ang = Angle(-90,0,0),
        },
    },
    GetBladePos = function( ent ) 
               local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(0,-1,0.4) ),
                dir = ent:LocalToWorldAngles( Angle(-90,180,0) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Sycthe"
hilt.Author = "BadJay707"
hilt.Spawnable = false
hilt.id = "sycthe"
hilt.mdl = "models/plo/cwa/melee/sycthe.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.2, -2.5, -4),
            ang = Angle(-90,180,0),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.2, 0, 4),
            ang = Angle(90,0,0),
        },
    },
    GetBladePos = function( ent ) 
               local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(-36,-0.5,-5) ),
                dir = ent:LocalToWorldAngles( Angle(360,180,0) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Tusken Gaffi"
hilt.Author = "BadJay707"
hilt.Spawnable = false
hilt.id = "tuskengaffi"
hilt.mdl = "models/plo/cwa/melee/tusken_gaffi.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.2, -1.3, -6),
            ang = Angle(-90,180,0),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1.3, 14.7),
            ang = Angle(90,0,0),
        },
    },
    GetBladePos = function( ent ) 
               local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(-13,-0.9,2.5) ),
                dir = ent:LocalToWorldAngles( Angle(370,180,0) ):Up(),
            },
            [2] = {
                pos = ent:LocalToWorld( Vector(25.5,-0.9,0) ),
                dir = ent:LocalToWorldAngles( Angle(-90,-180,0) ):Up(),
            },           
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Force Pike"
hilt.Author = "BadJay707"
hilt.Spawnable = false
hilt.id = "forcepike"
hilt.mdl = "models/plo/cwa/melee/force_pike.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.2, -0.5, -14.7),
            ang = Angle(90,0,0),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -0.5, 14.7),
            ang = Angle(-90,0,0),
        },
    },
    GetBladePos = function( ent ) 
               local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(-7.5,-0.9,0) ),
                dir = ent:LocalToWorldAngles( Angle(-90,180,0) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )
--PATH addons/[miecze] lscs_inventory_saver/lua/lscs/content/inventory_saver_example.lua:
return gluapack()()
--PATH lua/lscs/content/lscs_blades.lua:

--[[
	v v v Blade v v v
]]
local blade = {}
blade.PrintName = "Sapphire"
blade.Author = "Blu-x92 / Luna"
blade.id = "sapphire"
blade.color_blur = Color(0,65,255)
blade.color_core = Color(255,255,255)
blade.length = 45
blade.width = 0.9
blade.widthWiggle = 0.6
blade.material_core_tip = Material( "lscs/effects/lightsaber_tip" )
blade.material_core = Material( "lscs/effects/lightsaber_core" )
blade.material_glow = Material( "lscs/effects/lightsaber_glow" )
blade.material_trail = Material( "lscs/effects/lightsaber_trail" )
blade.dynamic_light = true
blade.no_trail = false
blade.sounds = {
	Attack = "saber_hup",
	Attack1 = "saber_spin1",
	Attack2 = "saber_spin2",
	Attack3 = "saber_spin3",
	Activate = "saber_turnon",
	Disable = "saber_turnoff",
	Idle =  "saber_idle4",
}
LSCS:RegisterBlade( blade )

-- modify previous blade, only change what we need to change
blade.PrintName = "Rubin"
blade.id = "rubin"
blade.color_blur = Color(200,0,0)
blade.width = 0.8
blade.widthWiggle = 0.7
blade.sounds.Idle = "saber_idle2"
LSCS:RegisterBlade( blade ) -- then register new blade table

-- repeat ^^
blade.PrintName = "Smaragd"
blade.id = "smaragd"
blade.color_blur = Color(0,150,0)
blade.width = 0.9
blade.widthWiggle = 0.6
blade.sounds.Idle = "saber_idle5"
LSCS:RegisterBlade( blade )

-- repeat ^^
blade.PrintName = "Amethyst"
blade.id = "amethyst"
blade.color_blur = Color(200,0,200)
blade.width = 1
blade.widthWiggle = 0.2
blade.sounds.Idle = "saber_idle3"
LSCS:RegisterBlade( blade )

-- repeat ^^
blade.PrintName = "Citrine"
blade.id = "citrine"
blade.color_blur = Color(200,150,0)
blade.width = 0.9
blade.widthWiggle = 0.6
blade.sounds.Idle = "saber_idle1"
LSCS:RegisterBlade( blade )

-- repeat ^^
blade.PrintName = "Allnatt"
blade.id = "allnatt"
blade.color_blur = Color(200,200,0)
blade.width = 0.65
blade.widthWiggle = 1
blade.sounds.Idle = "saber_idle3"
LSCS:RegisterBlade( blade )

-- special case: model based blade
local blade = {}
blade.PrintName = "Nano Particles"
blade.Author = "Blu-x92 / Luna"
blade.id = "nanoparticles"
blade.color_blur = Color(0,127,255)
blade.color_core = Color(0,0,0)
blade.mdl = "models/lscs/weapons/nanosword_bladefx.mdl"
blade.mdl_poseparameter = "blade_retract"
blade.length = 27
blade.dynamic_light = true
blade.no_trail = false
blade.sounds = {
	Attack = "nanosword_hup",
	Attack1 = "nanosword_hup",
	Attack2 = "nanosword_hup",
	Attack3 = "nanosword_hup",
	Activate = "nanosword_turnon",
	Disable = "nanosword_turnoff",
	Idle =  "nanosword_idle",
}
LSCS:RegisterBlade( blade )

--PATH lua/lvs_framework/autorun/lvs_player.lua:
local meta = FindMetaTable( "Player" )

function meta:lvsGetAITeam()
	return self:GetNWInt( "lvsAITeam", LVS.PlayerDefaultTeam )
end

function meta:lvsGetVehicle()
	local Pod = self:GetVehicle()

	if not IsValid( Pod ) then return NULL end

	if Pod.LVSchecked then

		return Pod.LVSBaseEnt

	else
		local Parent = Pod:GetParent()
		
		if not IsValid( Parent ) then return NULL end

		if not Parent.LVS then
			Pod.LVSchecked = LVS.MapDoneLoading
			Pod.LVSBaseEnt = NULL

			return NULL
		end

		Pod.LVSchecked = LVS.MapDoneLoading
		Pod.LVSBaseEnt = Parent

		return Parent
	end
end

function meta:lvsGetWeaponHandler()
	local Pod = self:GetVehicle()

	if not IsValid( Pod ) then return NULL end

	local weapon = Pod:lvsGetWeapon()

	if IsValid( weapon ) then
		return weapon
	else
		local veh = self:lvsGetVehicle()

		if not IsValid( veh ) then return NULL end

		if veh:GetDriver() == self then
			return veh
		else
			return NULL
		end
	end
end

function meta:lvsGetControls()
	if not istable( self.LVS_BINDS ) then
		self:lvsBuildControls()
	end
	
	return self.LVS_BINDS
end

function meta:lvsMouseAim()
	if LVS:IsDirectInputForced() then
		return false
	end

	return self._lvsMouseAim
end

function meta:lvsMouseSensitivity()
	local X = self._lvsMouseX or 1
	local Y = self._lvsMouseY or 1
	local delta = self._lvsReturnDelta or 1

	return X, Y, delta
end

function meta:lvsBuildControls()
	if istable( self.LVS_BINDS ) then
		table.Empty( self.LVS_BINDS )
	end

	if SERVER then
		self._lvsMouseAim = self:GetInfoNum( "lvs_mouseaim", 0 ) == 1

		self.LVS_BINDS = table.Copy( LVS.KEYS_CATEGORIES )

		for _,v in pairs( LVS.KEYS_REGISTERED ) do
			if v.id == "~SKIP~" then continue end

			local ButtonID = self:GetInfoNum( v.cmd, 0 )

			if not self.LVS_BINDS[v.category][ ButtonID ] then
				self.LVS_BINDS[v.category][ ButtonID ] = {}
			end

			table.insert( self.LVS_BINDS[v.category][ ButtonID ], v.id )
		end

		net.Start( "lvs_buildcontrols" )
		net.Send( self )

		self._lvsMouseX = self:GetInfoNum( "lvs_sensitivity_x", 1 )
		self._lvsMouseY = self:GetInfoNum( "lvs_sensitivity_y", 1 )
		self._lvsReturnDelta = self:GetInfoNum( "lvs_return_delta", 1 )
	else
		self._lvsMouseAim = GetConVar( "lvs_mouseaim" ):GetInt() == 1
		self._lvsMouseX = GetConVar(  "lvs_sensitivity_x" ):GetFloat()
		self._lvsMouseY = GetConVar( "lvs_sensitivity_y" ):GetFloat()
		self._lvsReturnDelta = GetConVar( "lvs_return_delta" ):GetFloat()

		self.LVS_BINDS = {}

		local KeySpawnMenu = input.LookupBinding( "+menu" )
		if isstring( KeySpawnMenu ) then
			KeySpawnMenu = input.GetKeyCode( KeySpawnMenu )
		end

		local KeyContextMenu = input.LookupBinding( "+menu_context" )
		if isstring( KeyContextMenu ) then
			KeyContextMenu = input.GetKeyCode( KeyContextMenu )
		end

		self._lvsDisableSpawnMenu = nil
		self._lvsDisableContextMenu = nil

		for _,v in pairs( LVS.KEYS_REGISTERED ) do
			if v.id == "~SKIP~" then continue end

			local KeyCode = GetConVar( v.cmd ):GetInt()

			self.LVS_BINDS[ v.id ] = KeyCode

			if KeyCode == KeySpawnMenu then
				self._lvsDisableSpawnMenu = true
			end
			if KeyCode == KeyContextMenu then
				self._lvsDisableContextMenu = true
			end
		end
	end
end

local IS_MOUSE_ENUM = {
	[MOUSE_LEFT] = true,
	[MOUSE_RIGHT] = true,
	[MOUSE_MIDDLE] = true,
	[MOUSE_4] = true,
	[MOUSE_5] = true,
	[MOUSE_WHEEL_UP] = true,
	[MOUSE_WHEEL_DOWN] = true,
}

local function GetInput( ply, name )
	if SERVER then
		if not ply._lvsKeyDown then
			ply._lvsKeyDown = {}
		end

		return ply._lvsKeyDown[ name ] == true
	else
		local Key = ply:lvsGetControls()[ name ] or 0

		if IS_MOUSE_ENUM[ Key ] then
			return input.IsMouseDown( Key ) 
		else
			return input.IsKeyDown( Key ) 
		end
	end
end

function meta:lvsKeyDown( name )
	if not self:lvsGetInputEnabled() then return false end

	local Pressed = GetInput( self, name )
	local NewPressed = hook.Run( "LVS.PlayerKeyDown", self, name, Pressed )

	if isbool( NewPressed ) then
		return NewPressed
	else
		return Pressed
	end
end

function meta:lvsGetInputEnabled()
	return (self._lvsKeyDisabler or 0) < CurTime()
end

function meta:lvsSetInputDisabled( disable )
	if CLIENT then
		net.Start( "lvs_buildcontrols" )
			net.WriteBool( disable )
		net.SendToServer()
	end

	if disable then
		self._lvsKeyDisabler = CurTime() + 120
	else
		self._lvsKeyDisabler = CurTime() + 0.25
	end
end

if CLIENT then
	function meta:lvsSetView( view )
		self._lvsViewPos = view.origin or vector_origin
		self._lvsViewAngles = view.angles or angle_zero

		return view
	end

	function meta:lvsGetView()
		local pos = self._lvsViewPos or vector_origin
		local ang = self._lvsViewAngles or angle_zero

		return pos, ang
	end

	net.Receive( "lvs_buildcontrols", function( len )
		local ply = LocalPlayer()
		if not IsValid( ply ) then return end
		ply:lvsBuildControls()
	end )

	local OldVisible = false
	local function KeyBlocker()
		local Visible = gui.IsGameUIVisible() or vgui.CursorVisible()

		if Visible ~= OldVisible then
			OldVisible = Visible

			local ply = LocalPlayer()

			if not IsValid( ply ) then return end

			if Visible then
				ply:lvsSetInputDisabled( true )
			else
				ply:lvsSetInputDisabled( false )
			end
		end
	end

	hook.Add( "LVS.PlayerEnteredVehicle", "!!!!!lvs_keyblocker_enable", function( ply, veh )
		hook.Add("PostDrawHUD", "!!!lvs_keyblocker", KeyBlocker )
	end )

	hook.Add( "LVS.PlayerLeaveVehicle", "!!!!!lvs_keyblocker_disable", function( ply, veh )
		hook.Remove("PostDrawHUD", "!!!lvs_keyblocker" )
	end )

	local players_bonemanip = {}

	local function StartBoneManip( id )
		players_bonemanip[ id ] = true
	end

	local function StopBoneManip( id )
		if not players_bonemanip[ id ] then return end

		players_bonemanip[ id ] = nil

		local ply = Entity( id )

		if not IsValid( ply ) then return end

		local angle_zero = Angle(0,0,0)

		for i = 0, (ply:GetBoneCount() - 1) do
			ply:ManipulateBoneAngles( i, angle_zero )
		end
	end

	net.Receive( "lvs_bonemanip", function( len )
		local entindex = net.ReadInt( 9 )
		local enable = net.ReadBool()

		if enable then
			StartBoneManip( entindex )

			return
		end

		StopBoneManip( entindex )
	end )

	hook.Add( "Think", "!!!!!lvs_player_bonemanip", function()
		for EntID, _ in pairs( players_bonemanip ) do
			local ply = Entity( EntID )

			if not IsValid( ply ) or not ply:IsPlayer() then continue end

			local Pod = ply:GetVehicle()
			local vehicle = ply:lvsGetVehicle()

			if not IsValid( Pod ) or not IsValid( vehicle ) then return end

			local BoneManipulate = vehicle:GetPlayerBoneManipulation( ply, Pod:lvsGetPodIndex() )

			for name, ang in pairs( BoneManipulate ) do
				local bone = ply:LookupBone( name )

				if not bone then continue end

				ply:ManipulateBoneAngles( bone, ang )
			end
		end
	end )

	return
end

util.AddNetworkString( "lvs_buildcontrols" )
util.AddNetworkString( "lvs_bonemanip" )

function meta:lvsStartBoneManip()
	net.Start( "lvs_bonemanip" )
		net.WriteInt( self:EntIndex(), 9 )
		net.WriteBool( true )
	net.Broadcast()
end

function meta:lvsStopBoneManip()
	net.Start( "lvs_bonemanip" )
		net.WriteInt( self:EntIndex(), 9 )
		net.WriteBool( false )
	net.Broadcast()
end

net.Receive( "lvs_buildcontrols", function( len, ply )
	if not IsValid( ply ) then return end

	ply:lvsSetInputDisabled( net.ReadBool() )
end )

function meta:lvsSetInput( name, value )
	if not self._lvsKeyDown then
		self._lvsKeyDown = {}
	end

	self._lvsKeyDown[ name ] = value
end

LVS.TEAMS = {
	[0] = "FRIENDLY TO EVERYONE",
	[1] = "Team 1",
	[2] = "Team 2",
	[3] = "HOSTILE TO EVERYONE",
}

function meta:lvsSetAITeam( nTeam )
	nTeam = nTeam or LVS.PlayerDefaultTeam

	if self:lvsGetAITeam() ~= nTeam then
		self:PrintMessage( HUD_PRINTTALK, "[LVS] Your AI-Team has been updated to: "..(LVS.TEAMS[ nTeam ] or "") )
	end

	self:SetNWInt( "lvsAITeam", nTeam )
end

hook.Add( "PlayerButtonUp", "!!!lvsButtonUp", function( ply, button )
	for _, KeyBind in pairs( ply:lvsGetControls() ) do
		local KeyTBL = KeyBind[ button ]

		if not KeyTBL then continue end

		for _, KeyName in pairs( KeyTBL ) do
			ply:lvsSetInput( KeyName, false )
		end
	end
end )

hook.Add( "PlayerButtonDown", "!!!lvsButtonDown", function( ply, button )
	if not ply:lvsGetInputEnabled() then return end

	local vehicle = ply:lvsGetVehicle()
	local vehValid = IsValid( vehicle )

	for _, KeyBind in pairs( ply:lvsGetControls() ) do
		local KeyTBL = KeyBind[ button ]

		if not KeyTBL then continue end

		for _, KeyName in pairs( KeyTBL ) do
			ply:lvsSetInput( KeyName, true )

			if not vehValid then continue end

			if string.StartWith( KeyName, "~SELECT~" ) then
				local exp_string = string.Explode( "#", KeyName )
				local base = ply:lvsGetWeaponHandler()

				if exp_string[2] and IsValid( base ) then
					base:SelectWeapon( tonumber( exp_string[2] ) )
				end
			end

			if KeyName == "EXIT" then
				if vehicle:GetDriver() == ply and vehicle:GetlvsLockedStatus() then vehicle:UnLock() end

				if vehicle:GetlvsLockedStatus() then continue end

				ply:ExitVehicle()
			end
		end
	end
end )

hook.Add("CanExitVehicle","!!!lvsCanExitVehicle",function(vehicle,ply)
	if IsValid( ply:lvsGetVehicle() ) then return false end
end)

--PATH lua/lvs_framework/autorun/sh_starwars_keybinding.lua:

hook.Add( "LVS:Initialize", "[LVS] - Star Wars - Keys", function()
	local KEYS = {
		{
			name = "+THRUST_SF",
			category = "LVS-Starfighter",
			name_menu = "Thrust Increase",
			default = "+forward",
			cmd = "lvs_starfighter_throttle_up"
		},
		{
			name = "-THRUST_SF",
			category = "LVS-Starfighter",
			name_menu = "Thrust Decrease",
			default = "+back",
			cmd = "lvs_starfighter_throttle_down"
		},
		{
			name = "+PITCH_SF",
			category = "LVS-Starfighter",
			name_menu = "Pitch Up",
			default = "+speed",
			cmd = "lvs_starfighter_pitch_up"
		},
		{
			name = "-PITCH_SF",
			category = "LVS-Starfighter",
			name_menu = "Pitch Down",
			cmd = "lvs_starfighter_pitch_down"
		},
		{
			name = "-YAW_SF",
			category = "LVS-Starfighter",
			name_menu = "Yaw Left [Roll in Direct Input]",
			cmd = "lvs_starfighter_yaw_left"
		},
		{
			name = "+YAW_SF",
			category = "LVS-Starfighter",
			name_menu = "Yaw Right [Roll in Direct Input]",
			cmd = "lvs_starfighter_yaw_right"
		},
		{
			name = "-ROLL_SF",
			category = "LVS-Starfighter",
			name_menu = "Roll Left [Yaw in Direct Input]",
			default = "+moveleft",
			cmd = "lvs_starfighter_roll_left"
		},
		{
			name = "+ROLL_SF",
			category = "LVS-Starfighter",
			name_menu = "Roll Right [Yaw in Direct Input]",
			default = "+moveright",
			cmd = "lvs_starfighter_roll_right"
		},
		{
			name = "+VTOL_Z_SF",
			category = "LVS-Starfighter",
			name_menu = "VTOL Up",
			cmd = "lvs_starfighter_vtol_up"
		},
		{
			name = "-VTOL_Z_SF",
			category = "LVS-Starfighter",
			name_menu = "VTOL Down",
			cmd = "lvs_starfighter_vtol_dn"
		},
		{
			name = "-VTOL_Y_SF",
			category = "LVS-Starfighter",
			name_menu = "VTOL Right",
			cmd = "lvs_starfighter_vtol_right"
		},
		{
			name = "+VTOL_Y_SF",
			category = "LVS-Starfighter",
			name_menu = "VTOL Left",
			cmd = "lvs_starfighter_vtol_left"
		},
		{
			name = "-VTOL_X_SF",
			category = "LVS-Starfighter",
			name_menu = "VTOL Reverse",
			default = "+back",
			cmd = "lvs_starfighter_vtol_reverse"
		},
	}

	for _, v in pairs( KEYS ) do
		LVS:AddKey( v.name, v.category, v.name_menu, v.cmd, v.default )
	end
end )

LVS:AddWeaponPreset( "TURBO", {
	Icon = Material("lvs/weapons/nos.png"),
	HeatRateUp = 0.1,
	HeatRateDown = 0.1,
	UseableByAI = false,
	Attack = function( ent )
		local PhysObj = ent:GetPhysicsObject()
		if not IsValid( PhysObj ) then return end
		local THR = ent:GetThrottle()
		local FT = FrameTime()

		local Vel = ent:GetVelocity():Length()

		PhysObj:ApplyForceCenter( ent:GetForward() * math.Clamp(ent.MaxVelocity + 500 - Vel,0,1) * PhysObj:GetMass() * THR * FT * 150 ) -- increase speed
		PhysObj:AddAngleVelocity( PhysObj:GetAngleVelocity() * FT * 0.5 * THR ) -- increase turn rate
	end,
	StartAttack = function( ent )
		ent.TargetThrottle = 1.3
		ent:EmitSound("lvs/vehicles/generic/boost.wav")
	end,
	FinishAttack = function( ent )
		ent.TargetThrottle = 1
	end,
	OnSelect = function( ent )
		ent:EmitSound("buttons/lever5.wav")
	end,
	OnThink = function( ent, active )
		if not ent.TargetThrottle then return end

		local Rate = FrameTime() * 0.5

		ent:SetMaxThrottle( ent:GetMaxThrottle() + math.Clamp(ent.TargetThrottle - ent:GetMaxThrottle(),-Rate,Rate) )

		local MaxThrottle = ent:GetMaxThrottle()

		ent:SetThrottle( MaxThrottle )

		if MaxThrottle == ent.TargetThrottle then
			ent.TargetThrottle = nil
		end
	end,
	OnOverheat = function( ent ) ent:EmitSound("lvs/overheat_boost.wav") end,
} )

if CLIENT then return end

resource.AddWorkshop("2919757295")
--PATH lua/autorun/master_association.lua:
-- KyleJWest
list.Set( "PlayerOptionsModel", "CGI_3D_Unassigned_Phase_1_Clone", "models/player/KyleJWest/CGI3DPhase1Clone/CGI3DPhase1Clone.mdl" )
player_manager.AddValidModel( "CGI_3D_Unassigned_Phase_1_Clone", "models/player/KyleJWest/CGI3DPhase1Clone/CGI3DPhase1Clone.mdl" )
player_manager.AddValidHands( "CGI_3D_Unassigned_Phase_1_Clone", "models/player/KyleJWest/CGI3DPhase1Clone_c_arms/CGI3DPhase1Clone_c_arms.mdl",0,"10000000" )

-- Sample

-- Suno


--PATH lua/autorun/mcfly_jka_younglings.lua:
return gluapack()()
--PATH lua/mediaplayer/shared.lua:
return gluapack()()
--PATH lua/mediaplayer/utils.lua:
return gluapack()()
--PATH lua/mediaplayer/sh_cvars.lua:
return gluapack()()
--PATH lua/mediaplayer/players/base/shared.lua:
local MediaPlayer = MediaPlayer

local HasFocus = system.HasFocus
local MuteUnfocused = MediaPlayer.Cvars.MuteUnfocused
local CeilPower2 = MediaPlayerUtils.CeilPower2

--[[---------------------------------------------------------
	Base Media Player
-----------------------------------------------------------]]

local MEDIAPLAYER = MEDIAPLAYER
MEDIAPLAYER.__index = MEDIAPLAYER

-- Inherit EventEmitter for all mediaplayer instances
EventEmitter:new(MEDIAPLAYER)

MEDIAPLAYER.Name = "base"
MEDIAPLAYER.IsMediaPlayer = true
MEDIAPLAYER.NoMedia = "\4" -- end of transmission character

-- Media Player states
MP_STATE_ENDED = 0
MP_STATE_PLAYING = 1
MP_STATE_PAUSED  = 2
NUM_MP_STATE = 3

include "sh_snapshot.lua"

--
-- Initialize the media player object.
--
function MEDIAPLAYER:Init(params)
	self._Queue = {}		-- media queue
	self._Media = nil		-- current media
	self._Owner = nil		-- media player owner

	self._State = MP_STATE_ENDED -- waiting for new media

	if SERVER then

		self._TransmitState = TRANSMIT_ALWAYS
		self._Listeners = {}

		self._Location = -1

	else

		self._LastMediaUpdate = 0
		inputhook.Add( KEY_Q, self, self.OnQueueKeyPressed )
		inputhook.Add( KEY_C, self, self.OnQueueKeyPressed )

	end

	-- Merge in any passed in params
	-- table.Merge(self, params or {})
end

--
-- Get whether the media player is valid.
--
-- @return boolean	Whether the media player is valid
--
function MEDIAPLAYER:IsValid()
	if self._removed then
		return false
	end

	return true
end

--
-- String coercion metamethod
--
-- @return String	Media player string representation
--
function MEDIAPLAYER:__tostring()
	return self:GetId()
end

--
-- Get the media player's unique ID.
--
-- @return Number	Media player ID.
--
function MEDIAPLAYER:GetId()
	return self.id
end

--
-- Get the media player's type.
--
-- @return String	MP type.
--
function MEDIAPLAYER:GetType()
	return self.Name
end

function MEDIAPLAYER:GetPlayerState()
	return self._State
end

function MEDIAPLAYER:SetPlayerState( state )
	local current = self._State
	self._State = state

	if MediaPlayer.DEBUG then
		print( "MEDIAPLAYER.SetPlayerState", state )
	end

	if current ~= state then
		self:OnPlayerStateChanged( current, state )
	end
end

function MEDIAPLAYER:OnPlayerStateChanged( old, new )
	local media = self:GetMedia()
	local validMedia = IsValid(media)

	if MediaPlayer.DEBUG then
		print( "MEDIAPLAYER.OnPlayerStateChanged", old .. ' => ' .. new )
	end

	if new == MP_STATE_PLAYING then
		if validMedia and not media:IsPlaying() then
			media:Play()
		end
	elseif new == MP_STATE_PAUSED then
		if validMedia and media:IsPlaying() then
			media:Pause()
		end
	end

	self:emit( MP.EVENTS.PLAYER_STATE_CHANGED, new, old )
end

--
-- Get whether the media player is currently playing media.
--
-- @return boolean	Media is playing
--
function MEDIAPLAYER:IsPlaying()
	return self._State == MP_STATE_PLAYING
end

--
-- Get the media player's position.
--
-- @return Vector3	Media player's position
--
function MEDIAPLAYER:GetPos()
	if not self._pos then
		self._pos = Vector(0,0,0)
	end
	return self._pos
end

--
-- Get the media player's location ID.
--
-- @return Number	Media player's location ID
--
function MEDIAPLAYER:GetLocation()
	return self._Location
end

function MEDIAPLAYER:GetOwner()
	return self._Owner
end

function MEDIAPLAYER:SetOwner( ply )
	self._Owner = ply
end

---
-- Determines if the player has privileges to use media controls (skip, seek,
-- etc.). Override this for custom behavior.
--
function MEDIAPLAYER:IsPlayerPrivileged( ply )
	return ply == self:GetOwner() or ply:IsAdmin() or
		hook.Run( "MediaPlayerIsPlayerPrivileged", self, ply )
end

---
-- Media player update
--
function MEDIAPLAYER:Think()

	if SERVER then
		self:UpdateListeners()
	end

	local media = self:GetMedia()
	local validMedia = IsValid(media)

	-- Waiting to play new media
	if SERVER then
		if self._State <= MP_STATE_ENDED then

			-- Check queue for videos to play
			if not self:IsQueueEmpty() then
				self:OnMediaFinished()
			end

		elseif self._State == MP_STATE_PLAYING then

			-- Wait for media to finish
			if validMedia and media:IsTimed() then
				local time = media:CurrentTime()
				local duration = media:Duration()

				if time > duration then
					self:OnMediaFinished()
				end
			end

		end
	end

	if CLIENT and validMedia then
		media:Sync()

		local volume

		-- TODO: add a GAMEMODE hook to determine if sound should be muted
		if not HasFocus() and MuteUnfocused:GetBool() then
			volume = 0
		else
			volume = MediaPlayer.Volume()
		end

		media:Volume( volume )
	end

end

--
-- Get the currently playing media.
--
-- @return Media	Currently playing media
--
function MEDIAPLAYER:GetMedia()
	return self._Media
end

MEDIAPLAYER.CurrentMedia = MEDIAPLAYER.GetMedia

--
-- Set the currently playing media.
--
-- @param media		Media object.
--
function MEDIAPLAYER:SetMedia( media )
	self._Media = media
	self:OnMediaStarted( media )

	-- NOTE: media can be nil!
	self:emit(MP.EVENTS.MEDIA_CHANGED, media)
end

--
-- Get the media queue.
-- TODO: Remove this as it should only be accessed internally?
--
-- @return table	Media queue.
--
function MEDIAPLAYER:GetMediaQueue()
	return self._Queue
end

--
-- Clear the media queue.
--
function MEDIAPLAYER:ClearMediaQueue()
	self._Queue = {}
	if SERVER then
		self:BroadcastUpdate()
	end
end

--
-- Get whether the media queue is empty.
--
-- @return boolean	Whether the queue is empty
--
function MEDIAPLAYER:IsQueueEmpty()
	return #self._Queue == 0
end

function MEDIAPLAYER:GetQueueLimit( bNetLength )
	local limit = MediaPlayer.Cvars.QueueLimit:GetInt()

	if bNetLength then
		limit = math.max( CeilPower2( limit ) / 2, 2 )
	end

	return limit
end

function MEDIAPLAYER:GetQueueRepeat()
	return self._QueueRepeat
end

function MEDIAPLAYER:SetQueueRepeat( shouldRepeat )
	self._QueueRepeat = shouldRepeat
end

function MEDIAPLAYER:GetQueueShuffle()
	return self._QueueShuffle
end

function MEDIAPLAYER:SetQueueShuffle( shouldShuffle )
	self._QueueShuffle = shouldShuffle

	if SERVER then
		if shouldShuffle then
			self:ShuffleQueue()
		else
			self:SortQueue()
		end
	end
end

function MEDIAPLAYER:GetQueueLocked()
	return self._QueueLocked
end

function MEDIAPLAYER:SetQueueLocked( locked )
	self._QueueLocked = locked
end

---
-- Called when the queue is updated; emits a change event.
--
function MEDIAPLAYER:QueueUpdated()
	if SERVER then
		self:SortQueue()
	end

	self:emit( MP.EVENTS.QUEUE_CHANGED, self._Queue )
end

--
-- Add media to the queue.
--
-- @param media		Media object.
--
function MEDIAPLAYER:AddMedia( media )
	if not media then return end

	if SERVER then
		-- cache the time the media has been queued for sorting purposes
		media:SetMetadataValue("queueTime", RealTime())
	end

	table.insert( self._Queue, media )
end

--
-- Event called when media should begin playing.
--
-- @param media		Media object to be played.
--
function MEDIAPLAYER:OnMediaStarted( media )

	media = media or self:CurrentMedia()

	if MediaPlayer.DEBUG then
		print( "MEDIAPLAYER.OnMediaStarted", media )
	end

	if IsValid(media) then

		if SERVER then
			local startTime
			local currentTime = media:CurrentTime()

			if currentTime > 0 then
				startTime = RealTime() - currentTime
			else
				startTime = RealTime()
			end

			media:StartTime( startTime + 1 )
		else
			self._LastMediaUpdate = RealTime()
		end

		if SERVER then
			self:SetPlayerState( MP_STATE_PLAYING )
		end

		self:emit('mediaStarted', media)

	elseif SERVER then
		self:SetPlayerState( MP_STATE_ENDED )
	end

end

--
-- Event called when media should stop playing and the next in the queue
-- should begin.
--
-- @param media		Media object to stop.
--
function MEDIAPLAYER:OnMediaFinished( media )

	media = media or self:CurrentMedia()

	if MediaPlayer.DEBUG then
		print( "MEDIAPLAYER.OnMediaFinished", media )
	end

	if SERVER then
		self:SetPlayerState( MP_STATE_ENDED )
	end

	self._Media = nil

	if CLIENT and IsValid(media) then
		media:Stop()
	end

	self:emit('mediaFinished', media)

	if SERVER then
		if media and self:GetQueueRepeat() then
			media:ResetTime()
			self:AddMedia( media )
		end

		self:NextMedia()
	end

end

--
-- Event called when the media player is to be removed/destroyed.
--
function MEDIAPLAYER:Remove()
	MediaPlayer.Destroy( self )
	self._removed = true

	if SERVER then

		-- Remove all listeners
		for _, ply in pairs( self._Listeners ) do
			-- TODO: it's probably better not to send individual net messages
			-- for each player removed.
			self:RemoveListener( ply )
		end

	else

		local media = self:CurrentMedia()

		if IsValid(media) then
			media:Stop()
		end

	end
end

function MEDIAPLAYER:GetSupportedServiceIDs()

	local serviceIDs = table.Copy( MediaPlayer.GetSupportedServiceIDs() )

	if self.ServiceWhitelist then
		local tbl = {}

		for _, id in ipairs(serviceIDs) do
			if table.HasValue( self.ServiceWhitelist, id ) then
				table.insert( tbl, id )
			end
		end

		serviceIDs = tbl
	end

	return serviceIDs

end

--PATH lua/mediaplayer/players/entity/shared.lua:
return gluapack()()
--PATH lua/mediaplayer/players/entity/sh_meta.lua:
--[[---------------------------------------------------------
	Media Player Entity Meta
-----------------------------------------------------------]]

local EntityMeta = FindMetaTable("Entity")
if not EntityMeta then return end

function EntityMeta:GetMediaPlayer()
	return self._mp
end

--
-- Installs a media player reference to the entity.
--
-- @param Table|String?  mp    Media player table or string type.
-- @param String?        mpId  Media player unique ID.
--
function EntityMeta:InstallMediaPlayer( mp, mpId )
	if not istable(mp) then
		local mpType = isstring(mp) and mp or "entity"

		if not MediaPlayer.IsValidType(mpType) then
			ErrorNoHalt("ERROR: Attempted to install invalid mediaplayer type onto an entity!\n")
			ErrorNoHalt("ENTITY: " .. tostring(self) .. "\n")
			ErrorNoHalt("TYPE: " .. tostring(mpType) .. "\n")
			mpType = "entity" -- default
		end

		local mpId = mpId or "Entity" .. self:EntIndex()
		mp = MediaPlayer.Create( mpId, mpType )
	end

	self._mp = mp
	self._mp:SetEntity(self)

	local creator = self.GetCreator and self:GetCreator()
	if IsValid( creator ) then
		self._mp:SetOwner( creator )
	end

	if isfunction(self.SetupMediaPlayer) then
		self:SetupMediaPlayer(mp)
	end

	return mp
end

local DefaultConfig = {
	offset	= Vector(0,0,0),	-- translation from entity origin
	angle	= Angle(0,90,90),	-- rotation
	-- attachment = "corner"	-- attachment name
	width = 64,					-- screen width
	height = 64 * 9/16			-- screen height
}

function EntityMeta:GetMediaPlayerPosition()
	local cfg = self.PlayerConfig or DefaultConfig

	local w = (cfg.width or DefaultConfig.width)
	local h = (cfg.height or DefaultConfig.height)
	local angles = (cfg.angle or DefaultConfig.angle)

	local pos, ang

	if cfg.attachment then
		local idx = self:LookupAttachment(cfg.attachment)
		if not idx then
			local err = string.format("MediaPlayer:Entity.Draw: Invalid attachment '%s'\n", cfg.attachment)
			Error(err)
		end

		-- Get attachment orientation
		local attach = self:GetAttachment(idx)
		pos = attach.pos
		ang = attach.ang
	else
		pos = self:GetPos() -- TODO: use GetRenderOrigin?
	end

	-- Apply offset
	if cfg.offset then
		pos = pos +
			self:GetForward() * cfg.offset.x +
			self:GetRight() * cfg.offset.y +
			self:GetUp() * cfg.offset.z
	end

	-- Set angles
	ang = ang or self:GetAngles() -- TODO: use GetRenderAngles?

	ang:RotateAroundAxis( ang:Right(), angles.p )
	ang:RotateAroundAxis( ang:Up(), angles.y )
	ang:RotateAroundAxis( ang:Forward(), angles.r )

	return w, h, pos, ang
end

--PATH lua/mediaplayer/sh_services.lua:
return gluapack()()
--PATH lua/mediaplayer/services/base/shared.lua:
return gluapack()()
--PATH lua/mediaplayer/services/browser.lua:
return gluapack()()
--PATH lua/mediaplayer/services/youtube/shared.lua:
return gluapack()()
--PATH lua/mediaplayer/services/twitch/cl_init.lua:
include "shared.lua"

DEFINE_BASECLASS( "mp_service_browser" )

local TwitchUrl = "http://www.twitch.tv/%s/%s/%s/popout"

---
-- Approximate amount of time it takes for the Twitch video player to load upon
-- loading the webpage.
--
local playerLoadDelay = 5

local secMinute = 60
local secHour = secMinute * 60

local function formatTwitchTime( seconds )
	local hours = math.floor((seconds / secHour) % 24)
	local minutes = math.floor((seconds / secMinute) % 60)
	seconds = math.floor(seconds % 60)

	local tbl = {}

	if hours > 0 then
		table.insert(tbl, hours)
		table.insert(tbl, 'h')
	end

	if hours > 0 or minutes > 0 then
		table.insert(tbl, minutes)
		table.insert(tbl, 'm')
	end

	table.insert(tbl, seconds)
	table.insert(tbl, 's')

	return table.concat(tbl, '')
end

function SERVICE:OnBrowserReady( browser )

	BaseClass.OnBrowserReady( self, browser )

	local info = self:GetTwitchVideoInfo()
	local url = TwitchUrl:format(info.channel, info.type, info.chapterId)

	-- Move current time forward due to twitch player load time
	local curTime = math.min( self:CurrentTime() + playerLoadDelay, self:Duration() )

	local time = math.ceil( curTime )
	if time > 5 then
		url = url .. '?t=' .. formatTwitchTime(time)
	end

	browser:OpenURL( url )

end

--PATH lua/mediaplayer/services/vimeo/shared.lua:
return gluapack()()
--PATH lua/mediaplayer/services/vimeo/shared.lua:
DEFINE_BASECLASS( "mp_service_browser" )

SERVICE.Name 	= "Vimeo"
SERVICE.Id 		= "vm"
SERVICE.Base 	= "browser"

function SERVICE:New( url )
	local obj = BaseClass.New(self, url)
	obj._data = obj:GetVimeoVideoId()
	return obj
end

function SERVICE:Match( url )
	return string.find( url, "vimeo.com/%d+" )
end

function SERVICE:GetVimeoVideoId()

	local videoId

	if self.videoId then

		videoId = self.videoId

	elseif self.urlinfo then

		local url = self.urlinfo

		-- http://www.vimeo.com/(videoId)
		videoId = string.match(url.path, "^/(%d+)")

		self.videoId = videoId

	end

	return videoId

end

--PATH lua/mediaplayer/services/image.lua:
return gluapack()()
--PATH lua/mediaplayer/services/html5_video.lua:
return gluapack()()
--PATH lua/mediaplayer/services/webpage.lua:
DEFINE_BASECLASS( "mp_service_browser" )

SERVICE.Name 	= "Webpage"
SERVICE.Id 		= "www"
SERVICE.Base 	= "res"
SERVICE.Abstract = true -- This service must be handled as a special case.

if CLIENT then

	function SERVICE:OnBrowserReady( browser )
		BaseClass.OnBrowserReady( self, browser )
		browser:OpenURL( self.url )
	end

	function SERVICE:IsMouseInputEnabled()
		return IsValid( self.Browser )
	end

else

	function SERVICE:Match( url )
		return false
	end

end

--PATH lua/mediaplayer/sh_history.lua:
return gluapack()()
--PATH lua/mediaplayer/sh_history.lua:
--[[---------------------------------------------------------
	Media Player History
-----------------------------------------------------------]]

MediaPlayer.History = {}

---
-- Default metadata table name
-- @type String
--
local TableName = "mediaplayer_history"

---
-- SQLite table struct
-- @type String
--
local TableStruct = string.format([[
CREATE TABLE %s (
	id				INTEGER PRIMARY KEY AUTOINCREMENT,
	mediaid			VARCHAR(48),
	url				VARCHAR(512),
	player_name		VARCHAR(32),
	steamid			VARCHAR(32),
	time			DATETIME DEFAULT CURRENT_TIMESTAMP
)]], TableName)

---
-- Default number of results to return
-- @type Integer
--
local DefaultResultLimit = 100

---
-- Log the given media as a request.
--
-- @param media		Media service object.
-- @return table	SQL query results.
--
function MediaPlayer.History:LogRequest( media )
	local id = media:UniqueID()
	if not id then return end

	local ply = media:GetOwner()
	if not IsValid(ply) then return end

	local query = string.format( "INSERT INTO `%s` " ..
			"(mediaid,url,player_name,steamid) " ..
			"VALUES ('%s',%s,%s,'%s')",
			TableName,
			media:UniqueID(),
			sql.SQLStr( media:Url() ),
			sql.SQLStr( ply:Nick() ),
			ply:SteamID64() or -1 )

	local result = sql.Query(query)

	if MediaPlayer.DEBUG then
		print("MediaPlayer.History.LogRequest")
		print(query)
		if istable(result) then
			PrintTable(result)
		else
			print(result)
		end
	end

	return result
end

function MediaPlayer.History:GetRequestsByPlayer( ply, limit )
	if not isnumber(limit) then
		limit = DefaultResultLimit
	end

	local query = string.format( [[
SELECT H.*, M.title, M.thumbnail, M.duration
FROM %s AS H
JOIN mediaplayer_metadata AS M
	ON (M.id = H.mediaid)
WHERE steamid='%s'
LIMIT %d]],
			TableName,
			ply:SteamID64() or -1,
			limit )

	local result = sql.Query(query)

	if MediaPlayer.DEBUG then
		print("MediaPlayer.History.GetRequestsByPlayer", ply, limit)
		print(query)
		if istable(result) then
			PrintTable(result)
		else
			print(result)
		end
	end

	return result
end

-- Create the SQLite table if it doesn't exist
if not sql.TableExists(TableName) then
	Msg("MediaPlayer.History: Creating `" .. TableName .. "` table...\n")
	print(sql.Query(TableStruct))
end

--PATH lua/mediaplayer/cl_screen.lua:
return gluapack()()
--PATH lua/autorun/properties/mediaplayer.lua:
return gluapack()()
--PATH lua/mp_menu/cl_init.lua:
MP = MP or {}
MP.EVENTS = MP.EVENTS or {}

MP.EVENTS.UI = {

	--[[--------------------------------------------------------
		Sidebar events
	----------------------------------------------------------]]

	SETUP_SIDEBAR = "mp.events.ui.sidebarChanged",
	SETUP_PLAYBACK_PANEL = "mp.events.ui.setupPlaybackPanel",
	SETUP_MEDIA_PANEL = "mp.events.ui.setupMediaPanel",

	MEDIA_PLAYER_CHANGED = "mp.events.ui.mediaPlayerChanged",

	OPEN_REQUEST_MENU = "mp.events.ui.openRequestMenu",
	FAVORITE_MEDIA = "mp.events.ui.favoriteMedia",
	REMOVE_MEDIA = "mp.events.ui.removeMedia",
	SKIP_MEDIA = "mp.events.ui.skipMedia",
	VOTE_MEDIA = "mp.events.ui.voteMedia",
	TOGGLE_LOCK = "mp.events.ui.toggleLock",
	TOGGLE_PAUSE = "mp.events.ui.togglePause",
	TOGGLE_REPEAT = "mp.events.ui.toggleRepeat",
	TOGGLE_SHUFFLE = "mp.events.ui.toggleShuffle",
	SEEK = "mp.events.ui.seek",

	START_SEEKING = "mp.events.ui.startSeeking",
	STOP_SEEKING = "mp.events.ui.stopSeeking",

	PRIVILEGED_PLAYER = "mp.events.ui.privilegedPlayer"

}

include "sidebar.lua"

--PATH lua/mp_menu/sidebar.lua:
return gluapack()()
--PATH lua/mp_menu/sidebar_tabs.lua:
local math = math
local ceil = math.ceil
local clamp = math.Clamp

local surface = surface
local color_white = color_white

local PANEL = {}

PANEL.TabHeight = 43

function PANEL:Init()

	self:SetShowIcons( false )

	self:SetFadeTime( 0 )
	self:SetPadding( 0 )

	self.animFade = Derma_Anim( "Fade", self, self.CrossFade )

	self.Items = {}

end

function PANEL:Paint( w, h )

end

function PANEL:AddSheet( label, panel, material, NoStretchX, NoStretchY, Tooltip )

	if not IsValid( panel ) then return end

	local Sheet = {}

	Sheet.Name = label

	Sheet.Tab = vgui.Create( "MP.SidebarTab", self )
	Sheet.Tab:SetTooltip( Tooltip )
	Sheet.Tab:Setup( label, self, panel, material )

	Sheet.Panel = panel
	Sheet.Panel.NoStretchX = NoStretchX
	Sheet.Panel.NoStretchY = NoStretchY
	Sheet.Panel:SetPos( self:GetPadding(), self.TabHeight + self:GetPadding() )
	Sheet.Panel:SetVisible( false )

	panel:SetParent( self )

	table.insert( self.Items, Sheet )

	if not self:GetActiveTab() then
		self:SetActiveTab( Sheet.Tab )
		Sheet.Panel:SetVisible( true )
	end

	-- self.tabScroller:AddPanel( Sheet.Tab )

	return Sheet

end

function PANEL:PerformLayout()

	local ActiveTab = self:GetActiveTab()
	local Padding = self:GetPadding()

	if not ActiveTab then return end

	-- Update size now, so the height is definitiely right.
	ActiveTab:InvalidateLayout( true )

	local ActivePanel = ActiveTab:GetPanel()

	local numItems = #self.Items
	local tabWidth = ceil(self:GetWide() / numItems)

	local tab

	for k, v in pairs( self.Items ) do

		tab = v.Tab

		tab:SetSize( tabWidth, self.TabHeight )
		tab:SetPos( (k-1) * tabWidth )

		-- Handle tab panel visibility
		if tab:GetPanel() == ActivePanel then
			tab:GetPanel():SetVisible( true )
			tab:SetZPos( 100 )
		else
			tab:GetPanel():SetVisible( false )
			tab:SetZPos( 1 )
		end

		tab:ApplySchemeSettings()

	end

	ActivePanel:SetWide( self:GetWide() - Padding * 2 )
	ActivePanel:SetTall( (self:GetTall() - ActiveTab:GetTall() ) - Padding )

	ActivePanel:InvalidateLayout()

	-- Give the animation a chance
	self.animFade:Run()

end

derma.DefineControl( "MP.SidebarTabs", "", PANEL, "DPropertySheet" )


local SIDEBAR_TAB = {}

surface.CreateFont( "MP.TabTitle", {
	font = "Roboto Regular",
	size = 16,
	weight = 400
} )

SIDEBAR_TAB.BgColor = Color( 28, 100, 157 )
SIDEBAR_TAB.SelectedBorderColor = color_white
SIDEBAR_TAB.SelectedBorderHeight = 2

function SIDEBAR_TAB:Init()

	self.BaseClass.Init( self )

	self:SetFont( "MP.TabTitle" )
	self:SetContentAlignment( 5 )
	self:SetTextInset( 0, 0 )

end

function SIDEBAR_TAB:Paint( w, h )

	surface.SetDrawColor( self.BgColor )
	surface.DrawRect( 0, 0, w, h )

	if self:IsActive() then
		surface.SetDrawColor( self.SelectedBorderColor )
		surface.DrawRect( 0, h - self.SelectedBorderHeight, w, self.SelectedBorderHeight )
	end

end

function SIDEBAR_TAB:ApplySchemeSettings()

	self:SetTextInset( 0, 0 )

	-- TODO: this errors as of version 2015.03.09
	-- DLabel.ApplySchemeSettings( self )

end

derma.DefineControl( "MP.SidebarTab", "", SIDEBAR_TAB, "DTab" )



local CURRENTLY_PLAYING_TAB = {}

AccessorFunc( CURRENTLY_PLAYING_TAB, "MediaPlayerId", "MediaPlayerId" )

CURRENTLY_PLAYING_TAB.BgColor = Color( 7, 21, 33 )

function CURRENTLY_PLAYING_TAB:Init()

	self.QueuePanel = vgui.Create( "MP.Queue", self )
	self.QueuePanel:Dock( FILL )
	self.QueuePanel:DockMargin( 0, -4, 0, 0 ) -- fix offset due to seekbar

	self.PlaybackPanel = vgui.Create( "MP.Playback", self )
	self.PlaybackPanel:Dock( TOP )

	hook.Add( MP.EVENTS.UI.MEDIA_PLAYER_CHANGED, self, self.OnMediaPlayerChanged )

end

function CURRENTLY_PLAYING_TAB:OnMediaPlayerChanged( mp )

	self:SetMediaPlayerId( mp:GetId() )

	self.QueuePanel.Header.AddVidBtn:SetLocked( mp:GetQueueLocked() )

	if not self.MediaChangedHandle then
		-- set current media
		self.PlaybackPanel:OnMediaChanged( mp:GetMedia() )

		-- listen for any future media changes
		self.MediaChangedHandle = function(...)
			if ValidPanel(self.PlaybackPanel) then
				self.PlaybackPanel:OnMediaChanged(...)
			end
		end
		mp:on( MP.EVENTS.MEDIA_CHANGED, self.MediaChangedHandle )
	end

	if not self.QueueChangedHandle then
		-- set current queue
		self.QueuePanel:OnQueueChanged( mp:GetMediaQueue() )

		-- listen for any future media changes
		self.QueueChangedHandle = function(...)
			if ValidPanel(self.QueuePanel) then
				self.QueuePanel:OnQueueChanged(...)
			end
		end
		mp:on( MP.EVENTS.QUEUE_CHANGED, self.QueueChangedHandle )
	end

	if not self.PlayerStateChangeHandle then
		-- set current player state
		self.PlaybackPanel:OnPlayerStateChanged( mp:GetPlayerState() )

		-- listen for any future player state changes
		self.PlayerStateChangeHandle = function(...)
			if ValidPanel(self.PlaybackPanel) then
				self.PlaybackPanel:OnPlayerStateChanged(...)
			end
		end
		mp:on( MP.EVENTS.PLAYER_STATE_CHANGED, self.PlayerStateChangeHandle )
	end

end

function CURRENTLY_PLAYING_TAB:OnRemove()

	hook.Remove( MP.EVENTS.UI.MEDIA_PLAYER_CHANGED, self )

	local mpId = self:GetMediaPlayerId()
	local mp = MediaPlayer.GetById( mpId )

	if mp then
		mp:removeListener( MP.EVENTS.MEDIA_CHANGED, self.MediaChangedHandle )
		mp:removeListener( MP.EVENTS.QUEUE_CHANGED, self.QueueChangedHandle )
		mp:removeListener( MP.EVENTS.PLAYER_STATE_CHANGED, self.PlayerStateChangeHandle )
	end

end

function CURRENTLY_PLAYING_TAB:Paint( w, h )
	surface.SetDrawColor( self.BgColor )
	surface.DrawRect( 0, 0, w, h )
end

derma.DefineControl( "MP.CurrentlyPlayingTab", "", CURRENTLY_PLAYING_TAB, "Panel" )

--PATH lua/mp_menu/queue.lua:
return gluapack()()
--PATH addons/[ui] msd_ui/lua/msd/ui/msdcontext.lua:
return gluapack()()
--PATH addons/[ui] msd_ui/lua/msd/ui/msdmdlmenu.lua:
return gluapack()()
--PATH lua/mvp/core/sh_loader.lua:
return gluapack()()
--PATH lua/mvp/loggers/console.lua:
return gluapack()()
--PATH lua/mvp/core/sh_permissions.lua:
mvp = mvp or {}
mvp.permissions = mvp.permissions or {}

mvp.permissions.list = mvp.permissions.list or {}

function mvp.permissions.AddPermission(name, defaulAccess, description, sortOrder)
    mvp.utils.AssertType(name, mvp.type.string, "mvp.permissions.AddPermission", 1)
    mvp.utils.AssertType(defaulAccess, mvp.type.string, "mvp.permissions.AddPermission", 2)

    local permissionCAMI = {
        Name = name,
        Description = description or "This permission has no description",
        MinAccess = defaulAccess
    }

    local permissionInternal = {
        name = name,
        description = description or "This permission has no description",
        defaultAccess = defaulAccess,
        sortOrder = sortOrder or 99
    }

    CAMI.RegisterPrivilege(permissionCAMI)
    mvp.permissions.list[name] = permissionInternal
end

function mvp.permissions.Check(ply, permission)
    mvp.utils.AssertType(ply, mvp.type.player, "mvp.permissions.Check", 1)
    mvp.utils.AssertType(permission, mvp.type.string, "mvp.permissions.Check", 2)

    return CAMI.PlayerHasAccess(ply, permission)
end

function mvp.permissions.CheckAll(ply, permissions)
    mvp.utils.AssertType(ply, mvp.type.player, "mvp.permissions.CheckAll", 1)
    mvp.utils.AssertType(permissions, mvp.type.array, "mvp.permissions.CheckAll", 2)

    for _, permission in pairs(permissions) do
        if (not mvp.permissions.Check(ply, permission)) then
            return false
        end
    end

    return true
end

function mvp.permissions.CheckSome(ply, permissions)
    mvp.utils.AssertType(ply, mvp.type.player, "mvp.permissions.CheckSome", 1)
    mvp.utils.AssertType(permissions, mvp.type.array, "mvp.permissions.CheckSome", 2)

    for _, permission in pairs(permissions) do
        if (mvp.permissions.Check(ply, permission)) then
            return true
        end
    end

    return false
end

function mvp.permissions.GetPermission(name)
    mvp.utils.AssertType(name, mvp.type.string, "mvp.permissions.GetPermission", 1)

    return mvp.permissions.list[name]
end

function mvp.permissions.GetPermissionList()
    return mvp.permissions.list
end
--PATH lua/mvp/thirdparty/sh_cami.lua:
return gluapack()()
--PATH lua/mvp/core/ui/cl_outlined_rect.lua:
return gluapack()()
--PATH lua/mvp/languages/en.lua:
local l = {}

l["general.terminal"] = "Terminal"
l["general.disabled"] = "This feature is disabled."

l["general.by_x"] = "by %s"
l["general.no_permission"] = "You don't have permission to do that."
l["general.use"] = "Press {{btn:%s}} to interact"
l["general.command_x"] = "Command: %s"

l["general.screen_position.tl"] = "Top Left"
l["general.screen_position.tc"] = "Top Center"
l["general.screen_position.tr"] = "Top Right"
l["general.screen_position.cl"] = "Center Left"
l["general.screen_position.cc"] = "Center Center"
l["general.screen_position.cr"] = "Center Right"
l["general.screen_position.bl"] = "Bottom Left"
l["general.screen_position.bc"] = "Bottom Center"
l["general.screen_position.br"] = "Bottom Right"

--[[
    UI
]]--

l["ui.general.save"] = "Save"
l["ui.general.save.thing"] = "Save %s"
l["ui.general.close"] = "Close"
l["ui.general.none"] = "None"
l["ui.general.edit"] = "Edit"

l["ui.home"] = "Home"
l["ui.home.description"] = "This is the home page for the Terminal admin menu."

l["ui.config"] = "Settings"
l["ui.config.save"] = "Save settings"
l["ui.config.description"] = "This is your settings for the Terminal and it's packages. You can change your server name, logo, gamemode and more."

l["ui.config.saved"] = "Settings saved successfully."
l["ui.config.saved.description"] = "Your settings have been saved successfully."

l["ui.permissions"] = "Permissions"
l["ui.permissions.description"] = "All the permissions that Terminal or it's packages registered are listed here."

l["ui.packages"] = "Packages"
l["ui.packages.description"] = "This is the packages that are currently loaded into Terminal."
l["ui.packages.installed"] = "Installed packages"
l["ui.packages.available"] = "Available packages"

l["ui.credits"] = "Credits"
l["ui.credits.description"] = "This is the credits for the Terminal and materials used in the Terminal"
l["ui.credits.steam_profile"] = "Steam Profile"

l["ui.credits.terminal"] = l["general.terminal"]
l["ui.credits.icons"] = "Icons"
l["ui.credits.packages"] = "Packages"

l["ui.notifications.servername.title"] = "Server name not set"
l["ui.notifications.servername.description"] = "You haven't set a server name yet. Currently Terminal will use default value \"%s\" as your server name. You can set a server name in the settings."
l["ui.notifications.servername.action.1"] = "Set server name"

l["ui.notifications.logo.title"] = "Server logo not set"
l["ui.notifications.logo.description"] = "You haven't set a server logo yet. Currently Terminal will use default value \"%s\" as your server logo. You can set a server logo in the settings."
l["ui.notifications.logo.action.1"] = "Set server logo"

l["ui.notifications.gamemode.title"] = "Gamemode not set"
l["ui.notifications.gamemode.description"] = "You haven't set a gamemode yet. Currently Terminal will use default value \"%s\" as your gamemode. You can set a gamemode in the settings."
l["ui.notifications.gamemode.action.1"] = "Set gamemode"
l["ui.notifications.gamemode.action.2"] = "Dissmiss"


--[[
    Config Section
]]--

l["section.terminal"] = l["general.terminal"]
l["section.terminal.general"] = "General"
l["section.terminal.appearance"] = "Appearance"
l["section.terminal.developer"] = "Developer"

l["value.prefix.description"] = "Prefix for the all commands."
l["value.command.description"] = "Command for opening Terminal menu."
l["value.allowConsoleCommand.description"] = "Allow console command for opening Terminal menu."

l["value.tag.description"] = "Tag for all chat messages."
l["value.language.description"] = "Language for Terminal to use."
l["value.useNotifications.description"] = "Use notifications system. If set to false, Terminal will use chat for notifications."
l["value.notificationsPosition.description"] = "Position for notifications on screen."
l["value.notificationsPosition.ps.title"] = "Terminal notifications position"
l["value.notificationsPosition.ps.description"] = "This is where the notifications will appear on the screen."

l["value.debug.description"] = "Enable debug mode."

l["section.server"] = "Server"
l["section.server.gamemode"] = "Gamemode"
l["section.server.branding"] = "Branding"

l["value.gamemode.description"] = "Gamemode for the server."
l["value.logo.description"] = "Branding for the server."
l["value.servername.description"] = "Branding for the server."

--[[
    Permissions Section
]]--

l["permission.mvp.terminal.description"] = "Allows access to the Terminal menu."
l["permission.mvp.terminal.configs.description"] = "Allows access to the Terminal configuration menu."
l["permission.mvp.terminal.packages.description"] = "Allows to control what packages are being loaded."


mvp.language.Register("en", l)
--PATH lua/mvp/core/command/sh_command.lua:
mvp = mvp or {}
mvp.command = mvp.command or {}

mvp.command.list = mvp.command.list or {}

function mvp.command.Register(command)
    local id = command:GetID()

    if (id == "unnamed_command") then
        mvp.q.LogError("Commands", "Unnamed command registered")

        return
    end

    if (mvp.command.list[id]) then
        mvp.q.LogWarn("Commands", "Command with id '" .. id .. "' already exists")
        mvp.q.LogWarn("Commands", "This is probably a bug! Since this should not happen outside of development!")

        mvp.q.LogDebug("Commands", "ID: " .. id)

        mvp.command.list[id] = nil
    end

    mvp.command.list[id] = command

    mvp.q.LogInfo("Commands", "Registered command with id '" .. id .. "'")
    hook.Run("mvp.command.Registered", command)
end

function mvp.command.GetList()
    return mvp.command.list
end

function mvp.command.Get(id)
    return mvp.command.list[id]
end

function mvp.command.Init()
    mvp.q.LogInfo("Commands", "Initializing commands...")

    mvp.loader.LoadFolder("commands")

    mvp.q.LogInfo("Commands", "Initialized commands")
end

hook.Add("PlayerSay", "mvp.command.PlayerSay", function(ply, text)
    local prefix = string.sub(text, 1, 1)
    local configPrefix = mvp.config.Get("prefix")

    if (prefix ~= configPrefix) then return end

    local args = string.Explode(" ", text)
    local command = string.lower(string.sub(args[1], 2))

    table.remove(args, 1)

    local commandObject = mvp.command.Get(command)
    if (not commandObject) then return end

    return commandObject:Run(ply, args) or ""
end)
--PATH lua/mvp/commands/terminal.lua:
return gluapack()()
--PATH lua/mvp/packages/radialmenu/cl_credits.lua:
return gluapack()()
--PATH addons/[bronie] perfect-hands/lua/mvp/packages/perfecthands/languages/de.lua:
--
-- This translation was done by TheCookieYT
-- https://steamcommunity.com/id/76561198293343119/
--

local l = {}

l["section.perfecthands"] = "Perfekt Hands"
l["section.perfecthands.appearance"] = "Erscheinungsbild"
l["section.perfecthands.animations"] = "Animations-System"
l["section.perfecthands.interactions"] = "Interaktions-System"

l["value.phands.useIcons.description"] = "Wenn aktiviert, werden Animationen Symbole verwenden, ansonsten Text."
l["value.phands.iconsTheme.description"] = "Das Thema der Symbole."

l["value.phands.useAnimations.description"] = "Aktivieren oder deaktivieren Sie das Animationssystem."
l["value.phands.animationAllowFreelook.description"] = "Ermöglichen Sie dem Spieler, während der Animationen freizusehen."
l["value.phands.animationSpeed.description"] = "Die Geschwindigkeit der Animationen."
l["value.phands.animationVelocityCutoff.description"] = "Steuerung der maximalen Geschwindigkeit, bei der die Animation abgespielt wird. Wenn die Geschwindigkeit des Spielers höher ist als dieser Wert, wird die Animation nicht abgespielt."

l["value.phands.useInteractions.description"] = "Aktivieren oder deaktivieren Sie das Interaktionssystem."
l["value.phands.interactionDistance.description"] = "Die Entfernung, in der der Spieler mit Objekten interagieren kann."
l["value.phands.interactionWeightMultiplier.description"] = "Steuerung des Gewichtsmultiplikators für das Interaktionssystem. Dies beeinflusst, wie schwer die Objekte sich anfühlen, wenn der Spieler sie hält."

l["phands.name"] = "Hände" -- this is the name for the hands SWEP

l["phands.mouse_buttons.MOUSE1"] = "LMB"
l["phands.mouse_buttons.MOUSE2"] = "RMB"
l["phands.mouse_buttons.MOUSE3"] = "MMB"

l["phands.hint.drag"] = "Halte {{btn:%s}} gedrückt, um dieses Objekt zu greifen."
l["phands.hint.rmb"] = "Drücke {{btn:%s}}, um das Animationsmenü zu öffnen."
l["phands.hint.rmb.stop"] = "Drücke {{btn:%s}} oder {{btn:%s}}, um die Animation zu stoppen."
l["phands.hint.freelook"] = "Drücke {{btn:%s}}, um den freien Blick zu aktivieren."

l["phands.cant_use_animation"] = "Du kannst die Animation \"%s\" gerade nicht verwenden."

l["phands.animation.surrender"] = "Ergeben"
l["phands.animation.surrender.description"] = "Du hebst die Hände und akzeptierst dein Schicksal."
l["phands.animation.armsinfront"] = "Arme nach vorne"
l["phands.animation.armsinfront.description"] = "Du legst deine Arme vor dich."
l["phands.animation.armsbehind"] = "Arme nach hinten"
l["phands.animation.armsbehind.description"] = "Du legst deine Arme hinter dich."
l["phands.animation.armsbehindhead"] = "Arme hinter dem Kopf"
l["phands.animation.armsbehindhead.description"] = "Du legst deine Arme hinter deinen Kopf."
l["phands.animation.armsonbelt"] = "Arme auf dem Gürtel"
l["phands.animation.armsonbelt.description"] = "Du legst deine Arme auf deinen Gürtel."
l["phands.animation.comlink"] = "Comlink"
l["phands.animation.comlink.description"] = "Du benutzt dein Comlink."
l["phands.animation.hololink"] = "Hololink"
l["phands.animation.hololink.description"] = "Du benutzt dein Hololink."
l["phands.animation.highfive"] = "High Five"
l["phands.animation.highfive.description"] = "Du streckst deine Hand für ein High Five aus."
l["phands.animation.point"] = "Zeigen"
l["phands.animation.point.description"] = "Du zeigst auf etwas."
l["phands.animation.salute"] = "Salutieren"
l["phands.animation.salute.description"] = "Du salutierst."
l["phands.animation.pensive"] = "Nachdenklich"
l["phands.animation.pensive.description"] = "Du siehst nachdenklich aus."
l["phands.animation.typing"] = "Tippen"
l["phands.animation.typing.description"] = "Du tippst auf einer Tastatur."
l["phands.animation.middlefinger"] = "Mittelfinger"
l["phands.animation.middlefinger.description"] = "Zeige jemandem den Mittel Finger."
l["phands.animation.attention"] = "Achtung"
l["phands.animation.attention.description"] = "Sie stehen stramm."
l["phands.animation.attention.kneel"] = "Knien"
l["phands.animation.attention.kneel.description"] = "Sie knien auf einem Knie."




mvp.language.Register("de", l)
--PATH addons/[bronie] perfect-hands/lua/mvp/packages/perfecthands/animations/sh_animations.lua:
local P = mvp.package.Get()

P.animations = P.animations or {}
P.animations.list = {}
P.animations.listSeq = {}

function P.animations.GetAll()
    return P.animations.list
end

function P.animations.Get(id)
    return P.animations.list[id]
end

function P.animations.Add(id, data)
    P.animations.list[id] = data
    P.animations.listSeq[#P.animations.listSeq + 1] = id
end

mvp.loader.LoadFile("packages/" .. P:GetCWD() .. "/sh_animations_list.lua")
--PATH lua/mvp/packages/simpledefcons/sh_package.lua:
local P = mvp.meta.package:New()

P:SetIcon(Material("mvp/simpledefcons/package_icon.png", "smooth"))
P:SetName("Simple DEFCONs")
P:SetVersion("1.0.2")
P:SetDescription("Simple DEFCONs for StarwarsRP servers.")
P:SetAuthor("Kot")

P:AddFolder("languages")
P:AddFolder("manage")
P:AddFolder("commands")
P:AddFile("cl_hud.lua")
P:AddFile("cl_credits.lua")
-- P:AddFile("cl_test.lua")

P:AddConfigsFolder()

mvp.permissions.AddPermission("mvp.simpledefcons.bypass", "admin", "Allows to bypass job check for DEFCONs menu.", 99)

mvp.package.Register(P)
--PATH lua/mvp/packages/simpledefcons/languages/en.lua:
local l = {}

l["section.simpledefcons"] = "Simple DEFCONs"
l["section.simpledefcons.general"] = "General"
l["section.simpledefcons.appearance"] = "Appearance"

l["value.simpledefcons.timeOnScreen.description"] = "Time in seconds of how long base status should be displayed, if there no sound attached to it."
l["value.simpledefcons.defcons.description"] = "List of DEFCONs. Each DEFCON has a name and a color."
l["value.simpledefcons.allowedJobs.description"] = "List of jobs that are allowed to change the base status."

l["value.simpledefcons.showHUD.description"] = "Show the base status on the HUD."
l["value.simpledefcons.hudPosition.description"] = "Position of the base status on the HUD."
l["value.simpledefcons.entityManagerModel.description"] = "Model for the base status manager entity."
l["value.simpledefcons.entityDisplayModel.description"] = "Model for the base status display entity."

l["simpledefcons.configure_allowed_jobs"] = "Configure allowed jobs"
l["simpledefcons.search_jobs"] = "Search..."
l["simpledefcons.configure_defcons"] = "Configure DEFCONs"
l["simpledefcons.add_defcon"] = "Add new DEFCON"
l["simpledefcons.defcon_name"] = "DEFCON Title"
l["simpledefcons.defcon_color"] = "DEFCON Color"
l["simpledefcons.defcon_description"] = "DEFCON Description"
l["simpledefcons.defcon_sound"] = "DEFCON Sound (optional)"

l["simpledefcons.set"] = "Set"
l["simpledefcons.apply"] = "Apply"
l["simpledefcons.active"] = "Active"
l["simpledefcons.attention"] = "ATTENTION"
l["simpledefcons.base_status"] = "Base status"
l["simpledefcons.initiated_by"] = "{{color:Accent}}{{lang:simpledefcons.attention}}{{color:Text}} - {{color:%s}}%s{{color:Text}} initiated by {{color:%s}}%s{{color:Text}}!"

l["simpledefcons.managerEntity"] = "Base Status Manager"
l["simpledefcons.managerEntity.description"] = "Manages the base status."

l["simpledefcons.displayEntity"] = l["simpledefcons.base_status"] .. ":"

mvp.language.Register("en", l)
--PATH lua/mvp/packages/simpledefcons/manage/sh_manage.lua:
return gluapack()()
--PATH lua/mvp/packages/simpledefcons/commands/defcons.lua:
return gluapack()()
--PATH lua/mvp/gamemodes/blank.lua:
local gm = mvp.meta.gamemode:New()

gm:SetName("Blank")
gm:SetDescription("A blank gamemode for testing purposes.")
gm:SetAuthor("Kot")
gm:SetVersion("1.0.0")
gm:SetLicense("MIT")

function gm:GetMoney(ply)
    return 99999
end

function gm:CanAfford(ply, sum)
    return true
end

function gm:AddMoney(ply, sum)
    return true
end

function gm:TakeMoney(ply, sum)
    return true
end

function gm:FormatMoney(ply, sum)
    return tostring(sum) .. " mvp$"
end

mvp.gamemode.Register(gm)
--PATH lua/mvp/vgui/dropdown/cl_dropdown_option.lua:
local PANEL = {}

DEFINE_BASECLASS( "mvp.Button" )

AccessorFunc( PANEL, "menu", "Menu" )
AccessorFunc( PANEL, "checked", "Checked" )
AccessorFunc( PANEL, "isCheckable", "IsCheckable" )

function PANEL:Init()
    
end

function PANEL:SetSubMenu(menu)
    self.SubMenu = menu
end

function PANEL:AddSubMenu()
    local SubMenu = vgui.Create("mvp.DropdownMenu")
    SubMenu:SetVisible(false)
    SubMenu:SetParent(self)

    self:SetSubMenu(SubMenu)

    return SubMenu
end

function PANEL:DoClickInternal()
	self:GetMenu():Remove()
end

function PANEL:OnCursorEntered()
	BaseClass.OnCursorEntered( self )

	if ( IsValid( self.ParentMenu ) ) then
		self.ParentMenu:OpenSubMenu( self, self.SubMenu )
		return
	end

	self:GetParent():OpenSubMenu( self, self.SubMenu )
end

function PANEL:Paint(w, h)
    BaseClass.Paint(self, w, h)

    if (self.SubMenu) then
        -- @todo: draw arrow
    end

    return true
end

vgui.Register("mvp.DropdownMenuOption", PANEL, "mvp.Button")
--PATH lua/mvp/vgui/menu/cl_menu.lua:
return gluapack()()
--PATH lua/mvp/menus/cl_admin.lua:
return gluapack()()
--PATH lua/ncs_shared/sh_hooks.lua:
if CLIENT then
    hook.Add( "InitPostEntity", "NCS_SHARED_PlayerReadyForNetworking", function()
        if !IsValid(LocalPlayer()) then return end

        net.Start( "NCS_SHARED_PlayerReadyForNetworking" )
        net.SendToServer()
    end )
else 
    local NETWORKED = {}

    util.AddNetworkString( "NCS_SHARED_PlayerReadyForNetworking" )

    net.Receive( "NCS_SHARED_PlayerReadyForNetworking", function( len, ply )
        if NETWORKED[ply] then
            ply:Kick()
            return
        end

        NETWORKED[ply] = true

        hook.Run("NCS_SHARED_PlayerReadyForNetworking", ply)
    end )
end
--PATH lua/ncs_shared/currencies/currencies/sh_basewars.lua:
return gluapack()()
--PATH lua/ncs_shared/modules/configuration/sh_main.lua:
return gluapack()()
--PATH lua/ncs_shared/modules/configuration/sh_main.lua:
NCS_SHARED.SavedDataOptions = NCS_SHARED.SavedDataOptions or {}

local didOptionChange = false
local optionCategories = {}
local dataLoaded = false
local lastOptionCreated

function NCS_SHARED.CreateDataOption(name, datatable)
    local UID = string.Replace(string.lower(name.."_"..datatable.dataCategory), " ", "")
    UID = tostring(UID)

    NCS_SHARED.SavedDataOptions[UID] = datatable
    NCS_SHARED.SavedDataOptions[UID].dataName = name
    NCS_SHARED.SavedDataOptions[UID].uniqueid = UID
    NCS_SHARED.SavedDataOptions[UID].setInternalData = function(s, value)
        if NCS_SHARED.SavedDataOptions[UID].verifyData then
            local verifyData = NCS_SHARED.SavedDataOptions[UID]:verifyData(value)

            if ( verifyData == false ) then return end
        end

        net.Start("NCS_SHARED_SetConfigOption")
            net.WriteString(UID, value)
            net.WriteType(value)
        net.SendToServer()
    end

    lastOptionCreated = CurTime() + 2

    table.insert(optionCategories, datatable.dataCategory)
end

function NCS_SHARED.GetDataOption(uniqueid)
    if !NCS_SHARED.SavedDataOptions[tostring(uniqueid)] then ErrorNoHalt("Invalid Data Option Index!") return end
    
    return ( NCS_SHARED.SavedDataOptions[tostring(uniqueid)].currentValue and NCS_SHARED.SavedDataOptions[tostring(uniqueid)].currentValue or false )
end

if SERVER then

    function NCS_SHARED.SetDataOption(uniqueid, value)
        if !NCS_SHARED.SavedDataOptions[tostring(uniqueid)] then ErrorNoHalt("[NCS] Attempted to set an invalid data option!") return end

        if NCS_SHARED.SavedDataOptions[tostring(uniqueid)].verifyData then
            local verifyData = NCS_SHARED.SavedDataOptions[tostring(uniqueid)]:verifyData(value)

            if ( verifyData == false ) then return end
        end

        NCS_SHARED.SavedDataOptions[tostring(uniqueid)].currentValue = value

        didOptionChange = true

        net.Start("NCS_SHARED_SetConfigOption")
            net.WriteString(uniqueid, value)
            net.WriteType(value)
        net.Broadcast()
    end

    local function ReadDataOptions()
        if lastOptionCreated and lastOptionCreated < CurTime() then
            for k, v in pairs(optionCategories) do
                local DATA = file.Read("ncs_configuration_lib_"..v..".json", "DATA")

                if DATA ~= nil then
                    DATA = util.JSONToTable(DATA)
                end

                for k, v in pairs(NCS_SHARED.SavedDataOptions) do
                    if ( DATA == nil ) or ( DATA[k] == nil ) then
                        NCS_SHARED.SavedDataOptions[tostring(k)].currentValue = NCS_SHARED.SavedDataOptions[tostring(k)].defaultValue
                    else
                        NCS_SHARED.SavedDataOptions[k].currentValue = DATA[k]
                    end
                end
                
            end

            lastOptionCreated = false
            dataLoaded = true

            hook.Run("NCS_SHARED_ConfigurationModuleLoaded")
        end
    end

    local nextRun = CurTime() + 10

    hook.Add("Think", "NCS_SharedResources_SaveData", function()
        ReadDataOptions()

        if nextRun > CurTime() then return end
        if !dataLoaded then return end
        if !didOptionChange then return end

        local DATA = {}

        for k, v in pairs(NCS_SHARED.SavedDataOptions) do
            if !v.saveData then continue end

            DATA[v.dataCategory] = DATA[v.dataCategory] or {}
            DATA[v.dataCategory][tostring(v.uniqueid)] = v.currentValue
        end

        for k, v in pairs(DATA) do
            file.Write("ncs_configuration_lib_"..k..".json", util.TableToJSON(v))
        end

        didOptionChange = false
    end )

    util.AddNetworkString("NCS_SHARED_SendConfigOptions")
    util.AddNetworkString("NCS_SHARED_SetConfigOption")

    net.Receive("NCS_SHARED_SetConfigOption", function(_, P)
        local aGroups = NCS_SHARED.GetDataOption("admingroups_library")

        if !aGroups then
            if !P:IsSuperAdmin() then NCS_SHARED.AddText(Color(255,0,0), "[NCS] ", color_white, "No permission, please contact system administrator.") return end
        elseif !aGroups[P:GetUserGroup()] then
            NCS_SHARED.AddText(Color(255,0,0), "[NCS] ", color_white, "No permission, please contact system administrator.")
            return
        end
    
        local UID = net.ReadString()
        local VAL = net.ReadType()
    
        NCS_SHARED.SetDataOption(UID, VAL)
    end )
end

hook.Add("NCS_SHARED_PlayerReadyForNetworking", "NCS_SHARED_ConfigurationOptionNetworking", function(P)
    local DATA = {}

    for k, v in pairs(NCS_SHARED.SavedDataOptions) do
        DATA[v.dataCategory] = DATA[v.dataCategory] or {}
        DATA[v.dataCategory][tostring(v.uniqueid)] = v.currentValue
    end

    for k, v in pairs(DATA) do
        net.Start("NCS_SHARED_SendConfigOptions")
            net.WriteTable(v)
        net.Send(P)
    end
end )
--PATH lua/ncs_shared/modules/configuration/default/sh_defaultoptions.lua:
return gluapack()()
--PATH lua/ncs_shared/vgui/cl_collapsiblecategory.lua:
return gluapack()()
--PATH lua/ncs_shared/vgui/cl_textentry.lua:
local PANEL = {}

surface.CreateFont( "NCS_SHARED_textEntry", {
	font = "Montserrat Medium",
	extended = false,
	size = ScreenScale(5),
} )

function PANEL:Init()
    self:SetFont("NCS_SHARED_textEntry")
end

function PANEL:Paint(w, h)
    surface.SetDrawColor( Color(122,132,137, 180) )
    surface.DrawOutlinedRect( 0, 0, w, h )

    self:DrawTextEntryText(color_white, color_white, color_white)
end

vgui.Register( "NCS_SHARED_TextEntry", PANEL, "DTextEntry" )
--PATH addons/[lib] onyx_framework_2/lua/onyx/framework/libs/thirdparty/data/utf8_chunk_2.lua:
return {[940] = 902,[941] = 904,[942] = 905,[943] = 906,[945] = 913,[946] = 914,[947] = 915,[948] = 916,[949] = 917,[950] = 918,[951] = 919,[952] = 920,[953] = 921,[954] = 922,[955] = 923,[956] = 924,[957] = 925,[958] = 926,[959] = 927,[960] = 928,[961] = 929,[962] = 931,[963] = 931,[964] = 932,[965] = 933,[966] = 934,[967] = 935,[968] = 936,[969] = 937,[970] = 938,[971] = 939,[972] = 908,[973] = 910,[974] = 911,[976] = 914,[977] = 920,[981] = 934,[982] = 928,[985] = 984,[987] = 986,[989] = 988,[991] = 990,[993] = 992,[995] = 994,[997] = 996,[999] = 998,[1001] = 1000,[1003] = 1002,[1005] = 1004,[1007] = 1006,[1008] = 922,[1009] = 929,[1010] = 1017,[1013] = 917,[1016] = 1015,[1019] = 1018,[1072] = 1040,[1073] = 1041,[1074] = 1042,[1075] = 1043,[1076] = 1044,[1077] = 1045,[1078] = 1046,[1079] = 1047,[1080] = 1048,[1081] = 1049,[1082] = 1050,[1083] = 1051,[1084] = 1052,[1085] = 1053,[1086] = 1054,[1087] = 1055,[1088] = 1056,[1089] = 1057,[1090] = 1058,[1091] = 1059,[1092] = 1060,[1093] = 1061,[1094] = 1062,[1095] = 1063,[1096] = 1064,[1097] = 1065,[1098] = 1066,[1099] = 1067,[1100] = 1068,[1101] = 1069,[1102] = 1070,[1103] = 1071,[1104] = 1024,[1105] = 1025,[1106] = 1026,[1107] = 1027,[1108] = 1028,[1109] = 1029,[1110] = 1030,[1111] = 1031,[1112] = 1032,[1113] = 1033,[1114] = 1034,[1115] = 1035,[1116] = 1036,[1117] = 1037,[1118] = 1038,[1119] = 1039,[1121] = 1120,[1123] = 1122,[1125] = 1124,[1127] = 1126,[1129] = 1128,[1131] = 1130,[1133] = 1132,[1135] = 1134,[1137] = 1136,[1139] = 1138,[1141] = 1140,[1143] = 1142,[1145] = 1144,[1147] = 1146,[1149] = 1148,[1151] = 1150,[1153] = 1152,[1163] = 1162,[1165] = 1164,[1167] = 1166,[1169] = 1168,[1171] = 1170,[1173] = 1172,[1175] = 1174,[1177] = 1176,[1179] = 1178,[1181] = 1180,[1183] = 1182,[1185] = 1184,[1187] = 1186,[1189] = 1188,[1191] = 1190,[1193] = 1192,[1195] = 1194,[1197] = 1196,[1199] = 1198,[1201] = 1200,[1203] = 1202,[1205] = 1204,[1207] = 1206,[1209] = 1208,[1211] = 1210,[1213] = 1212,[1215] = 1214,[1218] = 1217,[1220] = 1219,[1222] = 1221,[1224] = 1223,[1226] = 1225,[1228] = 1227,[1230] = 1229,[1231] = 1216,[1233] = 1232,[1235] = 1234,[1237] = 1236,[1239] = 1238,[1241] = 1240,[1243] = 1242,[1245] = 1244,[1247] = 1246,[1249] = 1248,[1251] = 1250,[1253] = 1252,[1255] = 1254,[1257] = 1256,[1259] = 1258,[1261] = 1260,[1263] = 1262,[1265] = 1264,[1267] = 1266,[1269] = 1268,[1271] = 1270,[1273] = 1272,[1275] = 1274,[1277] = 1276,[1279] = 1278,[1281] = 1280,[1283] = 1282,[1285] = 1284,[1287] = 1286,[1289] = 1288,[1291] = 1290,[1293] = 1292,[1295] = 1294,[1297] = 1296,[1299] = 1298,[1377] = 1329,[1378] = 1330,[1379] = 1331,[1380] = 1332,[1381] = 1333,[1382] = 1334,[1383] = 1335,[1384] = 1336,[1385] = 1337,[1386] = 1338,[1387] = 1339,[1388] = 1340,[1389] = 1341,[1390] = 1342,[1391] = 1343,[1392] = 1344,[1393] = 1345,[1394] = 1346,[1395] = 1347,[1396] = 1348,[1397] = 1349,[1398] = 1350,[1399] = 1351,[1400] = 1352,[1401] = 1353,[1402] = 1354,[1403] = 1355,[1404] = 1356,[1405] = 1357,[1406] = 1358,[1407] = 1359,[1408] = 1360,[1409] = 1361,[1410] = 1362,[1411] = 1363,[1412] = 1364,[1413] = 1365,[1414] = 1366,[7549] = 11363,[7681] = 7680,[7683] = 7682,[7685] = 7684,[7687] = 7686,[7689] = 7688,}
--PATH addons/[lib] onyx_framework_2/lua/onyx/ui/sh_init_ui.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

05/06/2022

--]]

onyx.IncludeFolder('onyx/ui/libs/thirdparty/')
onyx.IncludeFolder('onyx/ui/libs/')
onyx.IncludeFolder('onyx/ui/cfg/', true)
onyx.IncludeFolder('onyx/ui/core/', true)
onyx.IncludeFolder('onyx/ui/traits/', true)
onyx.IncludeFolder('onyx/ui/elements/', true)
--PATH addons/[lib] onyx_framework_2/lua/onyx/ui/traits/cl_click.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

16/04/2022

--]]

local TRAIT = {}

AccessorFunc(TRAIT, 'm_bDepressed', 'Depressed', FORCE_BOOL)
AccessorFunc(TRAIT, 'm_bDisabled', 'Disabled', FORCE_BOOL)

--[[------------------------------
Makes possible to make any panel clickable
--------------------------------]]

function TRAIT:Init()
    self:SetDepressed(false)
    self:SetCursor('hand')
    self:SetMouseInputEnabled(true)

    --[[------------------------------
    Override default, not add
    Useful when is called for DLabel
    --------------------------------]]
    self.OnMousePressed = function(self, code)
        if not self:GetDisabled() then
            self:SetDepressed(true)
            self:Call('OnPress', nil, code)
        end
    end

    self.OnMouseReleased = function(self, code)
        if self:GetDisabled() then return end

        if (CurTime() - (onyx.menuButtonPressTime or 0) > .2) then
            self:Call('OnRelease', nil, code)
        
            if code == MOUSE_LEFT then
                self:Call('DoClick')
            elseif code == MOUSE_RIGHT then
                self:Call('DoRightClick')
            else
                self:Call('DoMiddleClick')
            end
        end

        self:SetDepressed(false)
    end
end

function TRAIT:SetDisabled(bool)
    self.m_bDisabled = bool

    if bool then
        self:SetCursor('no')
        self:Call('OnDisabled', nil)
    else
        self:SetCursor('hand')
        self:Call('OnEnabled', nil)
    end
end

local colorCircle = Color(0, 0, 0, 100)
function TRAIT:AddHoverSound()
    self:On('OnCursorEntered', function(panel)
        -- surface.PlaySound('onyx/ui/on_mouseover/mouse_over1.wav')
        -- surface.PlaySound('onyx/ui/on_mouseover/mouse_over2.wav')
        -- surface.PlaySound('onyx/ui/on_mouseover/mouse_over5.wav')
        surface.PlaySound('onyx/ui/on_mouseover/pop_mouse_over.wav')
        -- surface.PlaySound('onyx/ui/on_mouseover/sub_bass_mouseover.wav')
    end)

    self:On('OnRelease', function(panel)
        -- surface.PlaySound('onyx/ui/on_click/round_pop_click.wav')
        -- surface.PlaySound('onyx/ui/on_click/round_pop_click1.wav')
        -- surface.PlaySound('onyx/ui/on_click/pop_click.wav')
        -- surface.PlaySound('onyx/ui/on_click/melodic1_click.wav')
        surface.PlaySound('onyx/ui/on_click/footfall_click.wav')
    end)
end

function TRAIT:AddClickEffect()
    self:On('OnRelease', function(panel)
        local x, y = panel:ScreenToLocal(input.GetCursorPos())
        
        panel.circleAnimFraction = 0
        panel.circleX = x
        panel.circleY = y
        onyx.anim.Create(panel, .25, {
            index = 400,
            target = {
                circleAnimFraction = 1
            }
        })
    end)

    self.circleAnimFraction = 0
    self:InjectEventHandler('PaintOver')
    self:On('PaintOver', function(panel, w, h)
        if (panel.circleAnimFraction > 0 and panel.circleAnimFraction < 1) then
            local circle = onyx.CalculateCircle(panel.circleX, panel.circleY, math.max(w, h) * panel.circleAnimFraction, 32)
            onyx.DrawPoly(circle, ColorAlpha(colorCircle, colorCircle.a * (1 - panel.circleAnimFraction)))
        end
    end)
end

onyx.trait.Register('click', TRAIT, 'Makes it easy to make any panel clickable')
--PATH addons/[lib] onyx_framework_2/lua/onyx/ui/elements/cl_checkbox.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

07/05/2023

--]]

local PANEL = {}

local colorPrimary = onyx:Config('colors.primary')
local colorSecondary = onyx:Config('colors.secondary')
local colorAccent = onyx:Config('colors.accent')
local wimgTick = onyx.wimg.Simple('https://i.imgur.com/TZ8Zfax.png', 'smooth mips')

AccessorFunc(PANEL, 'm_bChecked', 'Checked', FORCE_BOOL)

function PANEL:Init()
    local size = onyx.ScaleTall(18)

    self.m_bChecked = false

    self:Import('click')
    self:SetSize(size, size)

    self:Import('hovercolor')
    self:SetColorKey('outlineColor')
    self:SetColorIdle(colorSecondary)
    self:SetColorHover(colorAccent)

    self.backgroundColor = onyx.CopyColor(colorPrimary)
    self.backgroundIdleColor = colorPrimary
    self.backgroundActiveColor = colorAccent
end

function PANEL:Paint(w, h)
    local backgroundColor = self.backgroundColor
    local outlineColor = self.outlineColor
    local size = math.ceil(h * .66)

    draw.RoundedBox(8, 0, 0, w, h, outlineColor)
    draw.RoundedBox(8, 1, 1, w - 2, h - 2, backgroundColor)

    if (self.m_bChecked) then
        wimgTick:Draw(w * .5 - size * .5, h * .5 - size * .5, size, size)
    end
end

function PANEL:DoClick()
    self:SetValue(not self.m_bChecked)
end

function PANEL:SetChecked(bBool)
    assert(isbool(bBool), string.format('bad argument #1 to `SetChecked` (expected bool, got %s)', type(bBool)))
    self.m_bChecked = bBool

    if (bBool) then
        onyx.anim.Create(self, .33, {
            index = 40,
            target = {
                backgroundColor = self.backgroundActiveColor
            }
        })
    else
        onyx.anim.Create(self, .33, {
            index = 40,
            target = {
                backgroundColor = self.backgroundIdleColor
            }
        })
    end
end

function PANEL:SetValue(bBool)
    self:SetChecked(bBool)
    self:Call('OnChange', nil, bBool)
end

function PANEL:GetValue()
    return self.m_bChecked
end

onyx.gui.Register('onyx.CheckBox', PANEL)

-- ANCHOR Test

-- onyx.gui.Test('onyx.Frame', .4, .65, function(self)
--     self:MakePopup()

--     for i = 1, 10 do
--         local panel = self:Add('Panel')
--         panel:Dock(TOP)
--         panel:SetTall(ScreenScale(24))

--         local btn = panel:Add('onyx.CheckBox')
--         -- btn:Dock(LEFT)
--         btn:AlignRight(0)
--         btn:CenterVertical()
--     end
-- end)
--PATH addons/[lib] onyx_framework_2/lua/onyx/ui/elements/cl_pie_chart.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

04/01/2024

--]]

local CIRCLE_FULL_ANGLE = 360

local PANEL = {}

AccessorFunc(PANEL, 'm_Data', 'Data')
AccessorFunc(PANEL, 'm_LegendFont', 'LegendFont')
AccessorFunc(PANEL, 'm_iSum', 'Sum')
AccessorFunc(PANEL, 'm_bDonut', 'Donut')
AccessorFunc(PANEL, 'm_flRadius', 'Radius')
AccessorFunc(PANEL, 'm_colCircleBackgroundColor', 'CircleBackgroundColor')

function PANEL:Init()
    self:SetData({})
    self:SetCircleBackgroundColor(Color(100, 100, 100))
    self:SetDonut(false)
    self:SetRadius(.33)
    self:SetLegendFont(onyx.Font('Comfortaa@16'))

    self.divBody = self:Add('Panel')
    self.divBody.Paint = function(panel, w, h)
        self:DrawChart(w, h)
    end
    self.divBody.PerformLayout = function(panel, w, h)
        self:PerformChart(w, h)
    end

    self.divLegend = self:Add('Panel')
    self.divLegend.Paint = function(panel, w, h)
        self:DrawLegend(w, h)
    end
end

function PANEL:PerformLayout(w, h)
    self.divBody:Dock(FILL)

    self.divLegend:Dock(RIGHT)
    self.divLegend:SetWide(w * .5)
end

function PANEL:SetLegendVisible(bVisible)
    self.divLegend:SetVisible(bVisible)
end

function PANEL:AddRecord(text, amount, color)
    onyx.AssertType(text, 'string', 'AddRecord', 1)
    onyx.AssertType(amount, 'number', 'AddRecord', 2)

    local color = color or onyx.ColorEditHSV(color_white, math.random(360), .8, .8)

    local data = self:GetData()
    table.insert(data, {
        text = text,
        amount = amount,
        color = color
    })

    table.sort(data, function(a, b)
        return a.amount > b.amount
    end)

    self:UpdateSum()
end

function PANEL:UpdateSum()
    local data = self:GetData()
    local sum = 0

    for _, record in ipairs(data) do
        sum = sum + record.amount
    end

    for _, record in ipairs(data) do
        record.fraction = (record.amount / sum)
    end

    self:SetSum(sum)
    self.divBody:InvalidateLayout(true)

    return sum
end

function PANEL:DrawLegend(w, h)
    local data = self:GetData()
    local amount = #data
    local font = self:GetLegendFont()
    local y = 0

    surface.SetFont(font)
    local _, textH = surface.GetTextSize('A')
    local space = onyx.ScaleTall(5)
    local iconMargin = onyx.ScaleWide(5)

    for index = 1, amount do
        local record = data[index]

        onyx.DrawCircle(textH * .5, y + textH * .5, textH * .5, record.color)

        draw.SimpleText(record.text, font, textH + iconMargin, y, color_white, 0, 0)
        draw.SimpleText(math.Round(record.fraction * 100, 1) .. '%', font, w, y, color_white, 2, 0)

        y = y + textH + space
    end
end

function PANEL:DrawChart(w, h)
    local data = self:GetData()
    local radius = math.min(w, h) * self:GetRadius()
    local isDonut = self:GetDonut()
    local outlineThickness = 4

    if (isDonut) then
        onyx.DrawOutlinedCircle(w * .5, h * .5, radius, outlineThickness, self.m_colCircleBackgroundColor)
    else
        onyx.DrawCircle(w * .5, h * .5, radius, self.m_colCircleBackgroundColor)
    end

    for _, record in ipairs(data) do
        onyx.DrawWithPolyMask(record.poly, function()
            if (isDonut) then
                onyx.DrawOutlinedCircle(w * .5, h * .5, radius, outlineThickness, record.color)
            else
                onyx.DrawCircle(w * .5, h * .5, radius, record.color)
            end
        end)
    end

    self:PostDrawChart(w, h)
end

function PANEL:PostDrawChart(w, h)

end

function PANEL:PerformChart(w, h)
    local data = self:GetData()
    local startAngle = 0
    local radius = math.min(w, h) * self:GetRadius()

    for _, record in ipairs(data) do
        if (not record.fraction) then break end

        local segmentAngle = math.Round(record.fraction * CIRCLE_FULL_ANGLE)

        record.poly = onyx.CalculateArc(w * .5, h * .5, startAngle, segmentAngle, radius + 2, 24, true)

        startAngle = startAngle + segmentAngle
    end
end

onyx.gui.Register('onyx.PieChart', PANEL)

--[[------------------------------
DEBUG
--------------------------------]]
-- onyx.gui.Test('onyx.Frame', .65, .65, function(self, w, h)
--     self:MakePopup()
--     local content = self:Add('onyx.PieChart')
--     content:DockPadding(10, 10, 10, 10)
--     content:Dock(FILL)
--     -- content:SetLegendVisible(false)
--     content:AddRecord('Apple', 10, Color(220, 31, 31))
--     content:AddRecord('Pear', 10, Color(113, 193, 78))
--     content:AddRecord('Banana', 5, Color(255, 224, 48))
--     content:AddRecord('Orange', 2, Color(255, 143, 15))
--     content:SetDonut(true)
-- end)
--PATH addons/[lib] onyx_framework_2/lua/onyx/ui/elements/cl_text_entry.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

02/03/2023

--]]

local PANEL = {}

local colorPrimary = onyx:Config('colors.primary')
local colorSecondary = onyx:Config('colors.secondary')
local colorAccent = onyx:Config('colors.accent')
local colorBG = colorPrimary

AccessorFunc(PANEL, 'm_PlaceholderText', 'PlaceholderText')
AccessorFunc(PANEL, 'm_colPlaceholderColor', 'PlaceholderColor')
AccessorFunc(PANEL, 'm_PlaceholderFont', 'PlaceholderFont')
AccessorFunc(PANEL, 'm_iTextSpace', 'TextSpace')

local MUTATORS = {
    'Font',
    'HistoryEnabled',
    'Multiline',
    'Numeric',
    -- 'PlaceholderColor',
    -- 'PlaceholderText',
    'TabbingDisabled',
    'TextColor',
    'UpdateOnType',
    'Value'
}

local DISPATCH = {
    'OnLoseFocus',
    'OnGetFocus',
    'AllowInput',
    'OnChange',
    'OnEnter',
    'OnKeyCode',
    'OnValueChange',
    'OnCursorEntered',
    'OnCursorExited',
}

function PANEL:Init()
    self:SetTextSpace(onyx.ScaleWide(10))
    self:SetTall(onyx.ScaleTall(30))
    self.colors = {
        outline = colorSecondary,
        accent = colorAccent
    }

    self.textEntry = self:Add('DTextEntry')
    self.textEntry:Dock(FILL)
    self.textEntry:DockPadding(0, 0, 0, 0)
    self.textEntry:DockMargin(0, 0, 0, 0)
    self.textEntry.Paint = function(panel, w, h)
        panel:DrawTextEntryText(panel:GetTextColor(), colorAccent, panel:GetTextColor())
    end

    for _, name in ipairs(MUTATORS) do
        self:CombineMutator(self.textEntry, name)
    end

    for _, name in ipairs(DISPATCH) do
        self:MakeDispatchFn(self.textEntry, name)
    end

    self:SetFont(onyx.Font('Comfortaa@16'))
    self:SetTextColor(color_white)
    self:SetPlaceholderFont(self:GetFont())
    self:SetPlaceholderColor(Color(125, 125, 125))

    self:Import('hovercolor')
    self:SetColorKey('colorBackground')
    self:SetColorIdle(colorBG)
    self:SetColorHover(onyx.OffsetColor(colorBG, -5))

    self.focusAnimFraction = 0
    self.currentOutlineColor = onyx.CopyColor( self.colors.outline )
end

function PANEL:SetDisabled(bool)
    self.textEntry:SetDisabled(bool)
    self.textEntry:SetCursor(bool and 'no' or 'beam')
    self.m_bDisabled = bool

    if (bool) then
        self:Call('OnDisabled')
    else
        self:Call('OnEnabled')
    end
end

function PANEL:GetDisabled()
    return self.m_bDisabled
end

function PANEL:OnDisabled()
    local offset = -5
    self.onyxAnims = {}
    self:SetColorIdle(onyx.OffsetColor(colorBG, offset))
    self:SetColorHover(onyx.OffsetColor(self:GetColorIdle(), -5 + offset))
end

function PANEL:OnEnabled()
    local offset = 0
    self.onyxAnims = {}
    self:SetColorIdle(onyx.OffsetColor(colorBG, offset))
    self:SetColorHover(onyx.OffsetColor(self:GetColorIdle(), -5 + offset))
end

function PANEL:PerformLayout(w, h)
    local gmodOffset = 2 -- lol, there's is slight text offset in dtextentryy (for 1920x1080)

    self:DockPadding(self.m_iTextSpace - gmodOffset, 0, self.m_iTextSpace - gmodOffset, 0)
    self:DockMargin(0, 0, 0, 0)
end

function PANEL:SetPlaceholderIcon(icon, params)
    self.placeholderWebImage = onyx.wimg.Simple(icon, params)
end

function PANEL:OnGetFocus()
    self:SetHoverBlocked(true)
    self:ResetHighlight()

    onyx.anim.Simple(self, .25, {
        focusAnimFraction = 1,
        currentOutlineColor = self.colors.accent
    }, 1, nil, nil, 'inQuad')
end

function PANEL:OnLoseFocus()
    self:SetHoverBlocked(false)
    self:OnCursorExited()

    onyx.anim.Simple(self, .25, {
        focusAnimFraction = 0,
        currentOutlineColor = self.colors.outline
    }, 1, nil, nil, 'outQuad')
end

function PANEL:Paint(w, h)
    local text = self:GetPlaceholderText()
    local color = self:GetPlaceholderColor()
    local thickness = 1
    local currentOutlineColor = self.currentOutlineColor

    if (self.highlight) then
        currentOutlineColor = ColorAlpha(self.highlightColor, math.abs(math.sin(CurTime() * 6)) * 200 + 55)
        if (self.highlightEndTime and self.highlightEndTime <= CurTime()) then
            self:ResetHighlight()
        end
    end

    draw.RoundedBox(8, 0, 0, w, h, currentOutlineColor)
    draw.RoundedBox(8, thickness, thickness, w - thickness * 2, h - thickness * 2, self.colorBackground)

    if (self:GetValue() == '' and text and text ~= '') then
        local placeholderWebImage = self.placeholderWebImage
        local x = self.m_iTextSpace

        if (placeholderWebImage) then
            local size = onyx.ScaleTall(12)

            placeholderWebImage:Draw(x, h * .5 - size * .5, size, size, colorAccent)

            x = x + size + onyx.ScaleWide(5)
        end

        draw.SimpleText(text, self:GetPlaceholderFont(), x, h * .5, color, 0, 1)
    end
end

function PANEL:Highlight(color, time)
    self.highlightColor = color
    self.highlightStartTime = CurTime()
    if (time) then
        self.highlightEndTime = CurTime() + time
    end
    self.highlight = true
end

function PANEL:ResetHighlight()
    self.highlightColor = nil
    self.highlightStartTime = nil
    self.highlightEndTime = nil
    self.highlight = nil
end

onyx.gui.Register('onyx.TextEntry', PANEL)

-- ANCHOR Test

-- onyx.gui.Test('onyx.Frame', .4, .65, function(self)
--     self:MakePopup()

--     local content = self:Add('Panel')
--     content:Dock(FILL)
--     content:DockMargin(5, 5, 5, 5)

--         local btn = content:Add('onyx.ComboBox')
--         btn:Dock(TOP)
--         btn:DockMargin(0, 0 ,0 ,5)
--     btn:Highlight(Color(212, 72, 72))

--         local btn = content:Add('onyx.TextEntry')
--         btn:Dock(TOP)
--         btn:DockMargin(0, 0 ,0 ,5)
--         btn:SetPlaceholderText('Tset')
--     btn:Highlight(Color(212, 72, 72))

-- end)
--PATH addons/[ui] onyx_f4/lua/onyx/modules/f4/languages/cl_french.lua:
return gluapack()()
--PATH addons/[ui] onyx_f4/lua/onyx/modules/f4/languages/cl_german.lua:
--[[
 
Ersteller: tochnonement
E-Mail: tochnonement@gmail.com
 
Übersetzer: thestarhd
Profil: https://www.gmodstore.com/users/76561198801156110
 
05/01/2024
 
--]]
 
local LANG = {}
 
-- REITER
LANG.f4_jobs_u = 'JOBS'
LANG.f4_jobs_desc = 'Wähle deinen Weg'
 
LANG.f4_dashboard_u = 'DASHBOARD'
LANG.f4_dashboard_desc = 'Allgemeine Informationen'
 
LANG.f4_shop_u = 'SHOP'
LANG.f4_shop_desc = 'Kaufe beliebige Waren'
 
LANG.f4_admin_u = 'ADMIN'
LANG.f4_admin_desc = 'Addon konfigurieren'
 
LANG.f4_donate_u = 'SPENDEN'
LANG.f4_donate_desc = 'Unterstütze den Server'
 
LANG.addon_settings_u = 'EINSTELLUNGEN'
LANG.addon_settings_desc = 'Addon konfigurieren'
 
LANG.addon_stats_u = 'STATISTIKEN'
LANG.addon_stats_desc = 'Addon-Statistiken überprüfen'
 
LANG.addon_return_u = 'ZURÜCK'
LANG.addon_return_desc = 'Zurück zum Rahmen'
 
-- Sonstiges
LANG.f4_salary = 'Gehalt'
LANG.f4_price = 'Preis'
LANG.f4_loading = 'Laden'
LANG.f4_purchases = 'Einkäufe'
LANG.f4_switches = 'Schalter'
LANG.f4_unavailable = 'Nicht verfügbar'
LANG.f4_description_u = 'BESCHREIBUNG'
LANG.f4_weapons_u = 'WAFFEN'
LANG.f4_entities_u = 'ENTITÄTEN'
LANG.f4_ammo_u = 'MUNITION'
LANG.f4_food_u = 'NAHRUNG'
LANG.f4_shipments_u = 'SENDUNGEN'
LANG.f4_become_u = 'WERDE'
LANG.f4_create_vote_u = 'UMFRAGE ERSTELLEN'
LANG.f4_general_u = 'ALLGEMEIN'
LANG.f4_police_u = 'POLIZEI'
LANG.f4_mayor_u = 'BÜRGERMEISTER'
LANG.f4_confirm_u = 'BESTÄTIGEN'
LANG.f4_cancel_u = 'ABBRECHEN'
LANG.f4_mostpopular_u = 'AM BELIEBTESTEN'
LANG.f4_chart_u = 'DIAGRAMM'
LANG.f4_loading_u = 'LADEN'
LANG.f4_empty_u = 'LEER'
 
LANG.f4_playersonline_u = 'SPIELER ONLINE'
LANG.f4_totalmoney_u = 'GESAMTGELD'
LANG.f4_staffonline_u = 'TEAMMITGLIEDER ONLINE'
LANG.f4_actions_u = 'AKTIONEN'
 
-- Aktionen
LANG['f4_action_input_amount'] = 'Menge eingeben'
LANG['f4_action_input_text'] = 'Text eingeben'
LANG['f4_action_input_reason'] = 'Grund eingeben'
LANG['f4_action_choose_player'] = 'Spieler auswählen'
 
LANG['f4_action_confirm_action'] = 'Aktion bestätigen'
LANG['f4_action_drop_money'] = 'Geld fallen lassen'
LANG['f4_action_give_money'] = 'Geld geben'
LANG['f4_action_change_name'] = 'Namen ändern'
LANG['f4_action_drop_weapon'] = 'Waffe fallen lassen'
LANG['f4_action_sell_doors'] = 'Alle Türen verkaufen'
 
LANG['f4_action_warrant'] = 'Durchsuchungsbefehl erstellen'
LANG['f4_action_wanted'] = 'Gesucht'
 
LANG['f4_toggle_lockdown'] = 'Lockdown umschalten'
LANG['f4_give_license'] = 'Lizenz geben'
 
-- Phrasen
LANG['f4_search_text'] = 'Nach Name suchen...'
 
-- Einstellungen
LANG['f4.option_url_desc'] = 'URL eingeben (leer lassen, um zu deaktivieren)'
 
LANG['f4.discord_url.name'] = 'Discord'
LANG['f4.discord_url.desc'] = 'Trete unserem Discord-Server bei'
 
LANG['f4.forum_url.name'] = 'Forum'
LANG['f4.forum_url.desc'] = 'Triff die Community'
 
LANG['f4.steam_url.name'] = 'Steam'
LANG['f4.steam_url.desc'] = 'Trete unserer Steam-Gruppe bei'
 
LANG['f4.rules_url.name'] = 'Regeln'
LANG['f4.rules_url.desc'] = 'Kenne die Regeln'
 
LANG['f4.donate_url.name'] = 'Spenden'
 
LANG['f4.website_ingame.name'] = 'Browser'
LANG['f4.website_ingame.desc'] = 'Verwende den Ingame-Browser, um die Website-URL zu öffnen'
 
LANG['f4.title.name'] = 'Titel'
LANG['f4.title.desc'] = 'Der Titel für den Rahmen'
 
LANG['f4.hide_donate_tab.name'] = 'Spenden-Tab ausblenden'
LANG['f4.hide_donate_tab.desc'] = 'Blendet den Tab Spenden aus'
 
LANG['f4.edit_job_colors.name'] = 'Jobfarben bearbeiten'
LANG['f4.edit_job_colors.desc'] = 'Sollen Jobfarben heller angezeigt werden'
 
LANG['f4.hide_admins.name'] = 'Admins-Abschnitt ausblenden'
LANG['f4.hide_admins.desc'] = 'Blendet den Dashboard-Admin-List-Abschnitt aus'
 
LANG['f4.admin_on_duty.name'] = 'Admin-Job aktiviert'
LANG['f4.admin_on_duty.desc'] = 'Zeigt als Admin nur eine Person mit einem bestimmten Job an'
 
LANG['f4.admin_on_duty_job.name'] = 'Admin-Jobname'
LANG['f4.admin_on_duty_job.desc'] = 'Der Jobname des Admins*'
 
LANG['f4.colored_items.name'] = 'Farbiger Verlauf'
LANG['f4.colored_items.desc'] = 'Aktiviere leichten Farbverlauf auf Gegenständen/Jobs'
 
LANG['f4.item_columns.name'] = 'Spalten'
LANG['f4.item_columns.desc'] = 'Die Anzahl der Spalten für Gegenstände'
 
LANG['f4.job_columns.name'] = 'Spalten'
LANG['f4.job_columns.desc'] = 'Die Anzahl der Spalten für Jobs'
 
LANG['f4.model_3d.name'] = '3D-Modelle'
LANG['f4.model_3d.desc'] = 'Aktiviere Echtzeit-Rendering für Item-/Job-Symbole'
 
LANG['f4.item_show_unavailable.name'] = 'Nicht verfügbare Gegenstände'
LANG['f4.item_show_unavailable.desc'] = 'Zeige Gegenstände an, die customCheck nicht bestanden haben'
 
LANG['f4.job_show_unavailable.name'] = 'Nicht verfügbare Jobs'
LANG['f4.job_show_unavailable.desc'] = 'Zeige Jobs an, die customCheck nicht bestanden haben'
 
LANG['f4.job_show_requirejob.name'] = 'Abhängige Jobs'
LANG['f4.job_show_requirejob.desc'] = 'Zeige Jobs an, die aufgrund des falschen Jobs des Spielers nicht gewählt werden können'
 
onyx.lang:AddPhrases('german', LANG)
--PATH addons/[ui] onyx_f4/lua/onyx/modules/f4/languages/cl_turkish.lua:
-- Discord: sethlimited

local LANG = {}

-- TABS
LANG.f4_jobs_u = 'MESLEKLER'
LANG.f4_jobs_desc = 'Yolunu seç'

LANG.f4_dashboard_u = 'GÖSTERGE PANELİ'
LANG.f4_dashboard_desc = 'Genel Bilgi'

LANG.f4_shop_u = 'MARKET'
LANG.f4_shop_desc = 'Ürün satın al'

LANG.f4_admin_u = 'YETKİLİ'
LANG.f4_admin_desc = 'Eklentiyi yapılandır'

LANG.f4_donate_u = 'BAĞIŞ'
LANG.f4_donate_desc = 'Sunucuyu destekle'

LANG.addon_settings_u = 'AYARLAR'
LANG.addon_settings_desc = 'Eklentiyi yapılandır'

LANG.addon_stats_u = 'İSTATİSTİKLER'
LANG.addon_stats_desc = 'Eklenti istatistiklerini kontrol et'

LANG.addon_return_u = 'GERİ DÖN'
LANG.addon_return_desc = 'Panele geri dön'

-- Other
LANG.f4_salary = 'Maaş'
LANG.f4_price = 'Ücret'
LANG.f4_loading = 'Yükleniyor'
LANG.f4_purchases = 'Satın alımlar'
LANG.f4_switches = 'Geçişler'
LANG.f4_unavailable = 'Kullanım dışı'
LANG.f4_description_u = 'AÇIKLAMA'
LANG.f4_weapons_u = 'SİLAHLAR'
LANG.f4_entities_u = 'VARLIKLAR'
LANG.f4_ammo_u = 'MERMİ'
LANG.f4_food_u = 'YEMEK'
LANG.f4_shipments_u = 'SEVKİYATLAR'
LANG.f4_become_u = 'MESLEĞE GEÇ'
LANG.f4_create_vote_u = 'OYLAMA BAŞLAT'
LANG.f4_general_u = 'GENEL'
LANG.f4_police_u = 'POLİS'
LANG.f4_mayor_u = 'BAŞKAN'
LANG.f4_confirm_u = 'ONAYLA'
LANG.f4_cancel_u = 'İPTAL ET'
LANG.f4_mostpopular_u = 'EN POPÜLER'
LANG.f4_chart_u = 'GRAFİK'
LANG.f4_loading_u = 'YÜKLENİYOR'
LANG.f4_empty_u = 'BOŞ'

LANG.f4_playersonline_u = 'AKTİF OYUNCULAR'
LANG.f4_totalmoney_u = 'TOPLAM PARA'
LANG.f4_staffonline_u = 'AKTİF YETKİLİLER'
LANG.f4_actions_u = 'EYLEMLER'

-- Actions
LANG['f4_action_input_amount'] = 'Tutar girin'
LANG['f4_action_input_text'] = 'Metin girin'
LANG['f4_action_input_reason'] = 'Sebep girin'
LANG['f4_action_choose_player'] = 'Oyuncu seçin'

LANG['f4_action_confirm_action'] = 'Eylemi onayla'
LANG['f4_action_drop_money'] = 'Para bırak'
LANG['f4_action_give_money'] = 'Para ver'
LANG['f4_action_change_name'] = 'İsim değiştir'
LANG['f4_action_drop_weapon'] = 'Silah bırak'
LANG['f4_action_sell_doors'] = 'Tüm kapıları sat'

LANG['f4_action_warrant'] = 'Baskın emri çıkart'
LANG['f4_action_wanted'] = 'Aranma oluştur'

LANG['f4_toggle_lockdown'] = 'Lockdown oluştur'
LANG['f4_give_license'] = 'Lisans ver'

-- Phrases
LANG['f4_search_text'] = 'İsme göre ara...'

-- Settings
LANG['f4.option_url_desc'] = 'URL girin (iptal için boş bırakın)'

LANG['f4.discord_url.name'] = 'Discord'
LANG['f4.discord_url.desc'] = 'Discord sunucumuza katıl'

LANG['f4.forum_url.name'] = 'Forum'
LANG['f4.forum_url.desc'] = 'Toplulukla tanışın'

LANG['f4.steam_url.name'] = 'Steam'
LANG['f4.steam_url.desc'] = 'Steam grubumuza katıl'

LANG['f4.rules_url.name'] = 'Kurallar'
LANG['f4.rules_url.desc'] = 'Kuralları bil'

LANG['f4.donate_url.name'] = 'Bağış'

LANG['f4.website_ingame.name'] = 'Tarayıcı'
LANG['f4.website_ingame.desc'] = 'URL açmak için oyun içi tarayıcısını kullan'

LANG['f4.title.name'] = 'Başlık'
LANG['f4.title.desc'] = 'Çerçeve için başlık'

LANG['f4.hide_donate_tab.name'] = 'Bağış sekmesini gizle'
LANG['f4.hide_donate_tab.desc'] = 'Kredi market entegrasyon sekmesini gizle'

LANG['f4.edit_job_colors.name'] = 'Meslek renklerini değiştir'
LANG['f4.edit_job_colors.desc'] = 'Meslek renkleri daha açık mı gösterilmeli'

LANG['f4.hide_admins.name'] = 'Yetkili bölümünü gizle'
LANG['f4.hide_admins.desc'] = 'Paneldeki yetkili bölümünü gizle'

LANG['f4.admin_on_duty.name'] = 'Yetkili mesleği etkin'
LANG['f4.admin_on_duty.desc'] = 'Yalnızca belirli meslekteki kişileri yetkili olarak göster'

LANG['f4.admin_on_duty_job.name'] = 'Yetkili meslek ismi'
LANG['f4.admin_on_duty_job.desc'] = 'Yetkilinin meslek ismi*'

LANG['f4.colored_items.name'] = 'Renklendirilmiş Gradyan'
LANG['f4.colored_items.desc'] = 'Mesleklerde/öğelerde hafif gradyanı etkinleştir'

LANG['f4.item_columns.name'] = 'Sütunlar'
LANG['f4.item_columns.desc'] = 'Öğeler için sütun miktarı'

LANG['f4.job_columns.name'] = 'Sütunlar'
LANG['f4.job_columns.desc'] = 'Meslekler için sütun miktarı'

LANG['f4.model_3d.name'] = '3D Modeller'
LANG['f4.model_3d.desc'] = 'Meslek/öğe simgeleri için gerçek zamanlı oluşturmayı etkinleştir'

LANG['f4.item_show_unavailable.name'] = 'Kullanılamayan öğeler'
LANG['f4.item_show_unavailable.desc'] = 'Kontrolde(customCheck) başarısız olan öğeleri göster'

LANG['f4.job_show_unavailable.name'] = 'Kullanılamayan meslekler'
LANG['f4.job_show_unavailable.desc'] = 'Kontrolde(customCheck) başarısız olan meslekleri göster'

LANG['f4.job_show_requirejob.name'] = 'Şartlı meslekler'
LANG['f4.job_show_requirejob.desc'] = 'Oyuncunun yanlış mesleği sebebi ile seçilemeyen meslekleri göster'

onyx.lang:AddPhrases('turkish', LANG)

--PATH addons/[ui] onyx_f4/lua/onyx/modules/f4/ui/cl_frame.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

25/12/2023

--]]

local colorPrimary = onyx:Config('colors.primary')
local colorTertiary = onyx:Config('colors.tertiary')
local wimgLoading = onyx.wimg.Simple('https://i.imgur.com/VVswRpx.png', 'smooth mips')
local lastChosenTab = 1

local L = function(...) return onyx.lang:Get(...) end

DEFINE_BASECLASS('onyx.Frame')

local PANEL = {}

function PANEL:Init()
    onyx.f4.frame = self

    local padding = onyx.ScaleTall(10)
    self.containerPadding = padding

    self.container = self:Add('Panel')
    self.container:DockPadding(padding, padding, padding, padding)

    self.sidebar = self:Add('onyx.Sidebar')
    self.sidebar:SetDescriptionEnabled(true)
    self.sidebar:SetContainer(self.container)
    self.sidebar:SetKeepTabContent(true)
    self:Combine(self.sidebar, 'ChooseTab')
    self.sidebar:On('OnTabSwitched', function(panel, tab)
        if (tab.data.class ~= 'HTML') then
            lastChosenTab = tab.tabIndex
        end
    end)

    self.profile = self:InitProfile()

    self:SetTitle(onyx.f4:GetOptionValue('title'))
    self:LoadTabs()
    self:ChooseTab(lastChosenTab)
    self.currentJob = LocalPlayer():Team()
end

function PANEL:PerformLayout(w, h)
    BaseClass.PerformLayout(self, w, h)

    self.sidebar:Dock(LEFT)
    self.sidebar:SetWide(w * .2)

    self.container:Dock(FILL)
end

function PANEL:InitProfile()
    local sidebar = self.sidebar
    local padding = onyx.ScaleTall(7.5)
    local client = LocalPlayer()

    local labelText = team.GetName(client:Team())
    local labelColor = onyx.f4.ConvertJobColor(team.GetColor(client:Team()))
    local labelFont = onyx.Font('Comfortaa@14')

    local profile = sidebar:Add('Panel')
    profile:SetTall(onyx.ScaleTall(50))
    profile:Dock(TOP)
    profile:DockMargin(0, 0, 0, onyx.ScaleTall(5))
    profile:DockPadding(padding, padding, padding, padding)
    profile.Paint = function(panel, w, h)
        draw.RoundedBox(8, 0, 0, w, h, colorTertiary)
        draw.RoundedBox(8, 1, 1, w - 2, h - 2, colorPrimary)
    end
    profile.Think = function(panel)
        if ((panel.nextThink or 0) > CurTime()) then return end
        panel.nextThink = CurTime() + .25

        local lblJob = panel.lblJob

        labelColor = onyx.f4.ConvertJobColor(team.GetColor(client:Team()))                                                                                                                                                                            -- 5409e8b9-5bf9-4f0d-8990-ecb0a7db9134
        labelText = team.GetName(client:Team())

        if (IsValid(lblJob)) then
            lblJob:SetText(labelText)
        end
    end

    local avatar = profile:Add('onyx.RoundedAvatar')
    avatar:Dock(LEFT)
    avatar:SetWide(profile:GetTall() - padding * 2)
    avatar:SetPlayer(LocalPlayer(), 64)
    avatar:DockMargin(0, 0, onyx.ScaleWide(10), 0)
    avatar.PaintOver = function(panel, w, h)
        onyx.DrawOutlinedCircle(w * .5, h * .5, w * .5, 4, labelColor)
    end

    local lblTitle = profile:Add('onyx.Label')
    lblTitle:Dock(TOP)
    lblTitle:SetText(client:Name())
    lblTitle:Font('Comfortaa Bold@16')
    lblTitle:SetContentAlignment(4)

    local lblJob = profile:Add('onyx.Label')
    lblJob:Dock(FILL)
    lblJob:SetText(labelText)
    lblJob:SetTextColor(labelColor)
    lblJob:SetFont(labelFont)
    lblJob:SetContentAlignment(7)
    profile.lblJob = lblJob

    profile.PerformLayout = function(panel, w, h)
        lblTitle:SetTall((h - padding * 2) / 2)
    end

    return profile
end

do
    local LINKS = {
        {
            name = 'discord_url',
            desc = 'f4.discord_url.desc',
            icon = 'https://i.imgur.com/tYNtgoR.png'
        },
        {
            name = 'forum_url',
            desc = 'f4.forum_url.desc',
            icon = 'https://i.imgur.com/RH3sx4q.png'
        },
        {
            name = 'steam_url',
            desc = 'f4.steam_url.desc',
            icon = 'https://i.imgur.com/jB5T1Wo.png'
        },
        {
            name = 'rules_url',
            desc = 'f4.rules_url.desc',
            icon = 'https://i.imgur.com/JFhx1xW.png'
        },
        {
            name = 'donate_url',
            icon = 'https://i.imgur.com/MrgKOkL.png',
            desc = 'f4_donate_desc',
            donate = true
        },
    }

    function PANEL:LoadTabs()
        local tabs = onyx.f4:GetSortedTabs()
        local hideDonateTab = onyx.f4:GetOptionValue('hide_donate_tab')
        local donateTabAdded = false

        for _, tab in ipairs(tabs) do
            self.sidebar:AddTab({
                name = L(tab.name),
                desc = L(tab.desc),
                icon = tab.icon,
                class = tab.class,
                onClick = tab.onClick
            })
        end

        if (onyx.creditstore and not hideDonateTab) then
            local colorGold = Color(255, 225, 106)
            local colorGoldDesc = Color(157, 143, 84)

            self.sidebar:AddTab({
                name = onyx.lang:Get('f4_donate_u'),
                desc = onyx.lang:Get('f4_donate_desc'),
                wimg = 'creditstore_currency',
                nameColor = colorGold,
                descColor = colorGoldDesc,
                iconColor = colorGold,
                onClick = function()
                    RunConsoleCommand('onyx_store_open')
                    self:Close()
                    return false
                end
            })

            donateTabAdded = true
        end

        local allowedLinks = {}
        for _, link in ipairs(LINKS) do
            local url = onyx.f4:GetOptionValue(link.name):Trim()
            if (link.donate and donateTabAdded) then continue end

            if (url ~= '') then
                table.insert(allowedLinks, link)
            end
        end

        if (#allowedLinks > 0) then
            local spacer = self.sidebar:Add('Panel')
            spacer:Dock(TOP)
            spacer:SetTall(1)
            spacer:DockMargin(0, 0, 0, onyx.ScaleTall(5))
            spacer.Paint = function(panel, w, h)
                surface.SetDrawColor(0, 0, 0, 50)
                surface.DrawRect(0, 0, w, h)
            end
        end

        for _, link in ipairs(allowedLinks) do
            local option = onyx.inconfig.options['f4_' .. link.name]
            local name = L(option.title)
            local url = onyx.f4:GetOptionValue(link.name):Trim()

            self.sidebar:AddTab({
                name = name:upper(),
                desc = (link.desc and L(link.desc) or ''),
                icon = link.icon,
                wimg = link.wimg,
                class = 'HTML',
                onSelected = function(content)
                    content:OpenURL(url)
                    content.OnBeginLoadingDocument = function(panel)
                        if (not panel.bLoaded) then
                            panel.bLoading = true
                        end
                    end
                    content.OnFinishLoadingDocument = function(panel)
                        panel.bLoading = nil
                        panel.bLoaded = true
                    end
                    content.PaintOver = function(panel, w, h)
                        if (panel.bLoading) then
                            local maxSize = onyx.ScaleTall(64)
                            local size = maxSize * .5 + maxSize * .5 * math.abs(math.sin(CurTime()))

                            wimgLoading:DrawRotated(w * .5, h * .5, size, size, (CurTime() * 100) % 360)
                        end
                    end
                end,
                onClick = function()
                    if ( not onyx.f4:GetOptionValue('website_ingame') or url:find( 'discord.gg/' ) ) then
                        gui.OpenURL(url)
                        self:Close()
                        return false
                    end
                
                    return true
                end
            })
        end

        CAMI.PlayerHasAccess(LocalPlayer(), 'onyx_f4_edit', function(bAllowed)
            if (not bAllowed) then return end
            self.sidebar:AddTab({
                name = L('f4_admin_u'),
                desc = L('f4_admin_desc'),
                icon = 'https://i.imgur.com/l4M12dO.png',
                onClick = function()
                    onyx.f4.OpenAdminSettings()
                    self:Remove()
                    return false
                end
            })
        end)
    end
end

function PANEL:Think()
    if (self.currentJob ~= LocalPlayer():Team() and not self.jobRemoveCalled) then
        self:Remove()
        self.jobRemoveCalled = true
    end

    local keyName = input.LookupBinding('gm_showspare2', true)
    if (keyName) then
        local keyIndex = input.GetKeyCode(keyName)
        if (keyIndex and keyIndex > 0) then
            local keyDown = input.IsKeyDown(keyIndex)

            if (self.keyDown == nil) then
                self.keyDown = keyDown
            elseif (self.keyDown ~= keyDown) then
                self.keyDown = keyDown
                if (keyDown) then
                    self:Remove()
                end
            end
        end
    end
end

onyx.gui.Register('onyx.f4.Frame', PANEL, 'onyx.Frame')

--[[------------------------------
DEBUG
--------------------------------]]
-- onyx.gui.Test('onyx.f4.Frame', .65, .65, function(panel)
--     panel:MakePopup()
-- end)
--PATH addons/[ui] onyx_f4/lua/onyx/modules/f4/ui/cl_tab_jobs.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

25/12/2023

--]]

local colorPrimary = onyx:Config('colors.primary')
local colorSecondary = onyx:Config('colors.secondary')
local colorTertiary = onyx:Config('colors.tertiary')
local colorGray = Color(159, 159, 159)
local font0 = onyx.Font('Overpass SemiBold@14')
local COLOR_NEGATIVE = Color(221, 107, 107)
local oldScrollValue = 0

local L = function(...) return onyx.lang:Get(...) end

local PANEL = {}

local cvShowFavorite = CreateClientConVar('cl_onyx_f4_show_favorite_jobs', '1', true, false)

function PANEL:Init()
    local toolbarPadding = onyx.ScaleTall(5)

    self.list = self:Add('onyx.ScrollPanel')
    self.list:Dock(FILL)
    self.list.OnRemove = function(panel)
        if (panel.scrollInitialized) then
            oldScrollValue = panel.scroll:GetScroll()
        end
    end

    if (oldScrollValue) then
        self:SetScroll(4, oldScrollValue)
    end

    self.toolbar = self:Add('DPanel')
    self.toolbar:Dock(TOP)
    self.toolbar:SetTall(onyx.ScaleTall(40))
    self.toolbar:DockPadding(toolbarPadding, toolbarPadding, toolbarPadding * 2, toolbarPadding)
    self.toolbar:DockMargin(0, 0, 0, onyx.ScaleTall(10))
    self.toolbar.Paint = function(panel, w, h)
        draw.RoundedBox(8, 0, 0, w, h, colorSecondary)
    end
    self.toolbar.PerformLayout = function(panel, w, h)
        self.favToggler:SetWide(self.favToggler:GetContentWidth())
    end

    self.favToggler = self.toolbar:Add('onyx.TogglerLabel')
    self.favToggler:Dock(RIGHT)
    self.favToggler:SetText(L('f4_show_favorite'))
    self.favToggler:SetBackgroundColor(onyx.OffsetColor(colorTertiary, 10))
    self.favToggler:Font('Comfortaa Bold@18')
    self.favToggler:SetTextMargin(onyx.ScaleTall(10))
    self.favToggler:SetChecked(cvShowFavorite:GetBool(), true)
    self.favToggler.OnChange = function(panle, bool)
        cvShowFavorite:SetBool(bool)
        self:Reload()
    end

    self.search = self.toolbar:Add('onyx.TextEntry')
    self.search:SetPlaceholderText(onyx.lang:Get('f4_search_text'))
    self.search:SetPlaceholderIcon('https://i.imgur.com/Nk3IUJT.png', 'smooth mips')
    self.search:Dock(LEFT)
    self.search:SetWide(onyx.ScaleWide(150))
    self.search:SetUpdateOnType(true)
    self.search.OnValueChange = function(panel, value)
        value = onyx.utf8.lower(value)

        for _, cat in ipairs(self.list:GetItems()) do
            local layout = cat.canvas:GetChild(0)
            local items = layout:GetChildren()
            local visibleItemAmount = 0

            for _, item in ipairs(items) do
                if (onyx.utf8.lower(item:GetName()):find(value, nil, true)) then
                    item:SetVisible(true)
                    visibleItemAmount = visibleItemAmount + 1
                else
                    item:SetVisible(false)
                end
            end

            layout:InvalidateLayout()

            cat:SetVisible(value == '' or visibleItemAmount > 0)
            cat:UpdateInTick()
        end

        self.list:InvalidateLayout()
    end

    self.preview = self:Add('onyx.Panel')
    self.preview:Hide()
    self.preview.blur = 0
    self.preview.pos = 0
    self.preview.Paint = function(panel, w, h)
        local frame = onyx.f4.frame
        if (not IsValid(frame)) then return end -- just in case

        local realW, realH = frame.container:GetSize()
        local padding = frame.containerPadding

        if (panel.blur > 0) then
            onyx.DrawBlurExpensive(panel, panel.blur)
        end

        DisableClipping(true)
            surface.SetDrawColor(ColorAlpha(color_black, panel.pos * 100))
            surface.DrawRect(-padding, -padding, realW, realH)
        DisableClipping(false)
    end
    self.preview.PerformLayout = function(panel, w, h)
        panel.content:SetTall(h)
        panel.content:SetWide(w * .6)
    end
    self.preview.OnMouseReleased = function(panel)
        self:DisablePreview()
    end

    self.preview.content = self.preview:Add('onyx.f4.JobPreview')
    self.preview.content.OnFavoriteStateSwitched = function()
        self:Reload()
    end

    self.categories = {}
    self:LoadJobs()
end

function PANEL:Reload()
    local scrollValue = self.list.scroll:GetScroll()
    local container = self.list:GetContainer()

    container:Clear()
    self.search:SetValue('')
    self.categories = {}
    self:LoadJobs()
    self:SetScroll(4, scrollValue)
    container:SetAlpha(0)
    container:AlphaTo(255, .3)
end

function PANEL:SetScroll(tickAmount, scrollValue)
    timer.Simple(engine.TickInterval() * tickAmount, function()
        if (IsValid(self.list)) then
            self.list.scrollInitialized = true
            self.list.scroll:SetScroll(scrollValue)
            self.list.scroll.Current = scrollValue
            self.list.canvas.container:SetPos(0, -scrollValue)
        end
    end)
end

function PANEL:EnablePreview(member, reason)
    local preview = self.preview
    local available = reason == nil

    preview:Show()
    preview.pos = 0
    preview.content:SetPos(preview:GetWide())

    preview.content:SetupJob(member)

    if ( preview.content.hideButton ) then
        preview.content.btnChoose:SetVisible(false)
        preview.content.spacer:SetVisible(false)
    elseif ( member.team == LocalPlayer():Team() ) then
        preview.content.btnChoose:SetVisible(false)
        preview.content.spacer:SetVisible(false)
    else
        preview.content.btnChoose:SetVisible(available)
        preview.content.spacer:SetVisible(available)
    end

    onyx.anim.Create(preview, .2, {
        index = 1,
        target = {
            blur = 2,
            pos = 1
        },
        think = function(anim, panel)
            local w = panel:GetSize()
            local contentW = panel.content:GetWide()

            panel.content:SetPos(w - contentW * panel.pos, 0)
        end,
        onFinished = function(anim, panel)
            panel.content.enabled = true
        end,
        easing = 'inQuad'
    })
end

function PANEL:DisablePreview()
    local preview = self.preview

    if (not preview.content.enabled) then
        return
    end

    preview.content.enabled = false
    onyx.anim.Create(preview, .2, {
        index = 1,
        target = {
            blur = 0,
            pos = 0
        },
        think = function(anim, panel)
            local w = panel:GetSize()
            local contentW = panel.content:GetWide()

            panel.content:SetPos(w - contentW * panel.pos, 0)
        end,
        onFinished = function(anim, panel)
            panel:Hide()
        end,
        easing = 'inQuad'
    })
end

function PANEL:PerformLayout(w, h)
    self.preview:SetSize(w, h)
end

function PANEL:LoadJobs()
    local client = LocalPlayer()
    local categories = DarkRP.getCategories()['jobs']
    local showUnavailable = onyx.f4:GetOptionValue('job_show_unavailable')
    local showWrong = onyx.f4:GetOptionValue('job_show_requirejob')
    local teamIndex = client:Team()

    if (cvShowFavorite:GetBool()) then
        self:CreateCategory(L('f4_favorite_u'), onyx.f4:FetchFavoriteObjects('jobs'), true, true)
    end

    for _, category in ipairs(categories) do
        local canSee = category.canSee
        local members = {}

        if (canSee and not canSee(client)) then continue end

        for _, member in ipairs(category.members) do
            local customCheck = member.customCheck
            local needToChangeFrom = member.NeedToChangeFrom
            local reason

            if (customCheck and not customCheck(client)) then
                if (showUnavailable) then
                    reason = L('f4_unavailable')
                else
                    continue
                end
            end

            if (needToChangeFrom and needToChangeFrom ~= teamIndex) then
                if (showWrong) then
                    reason = L('f4_unavailable')
                else
                    continue
                end
            end

            table.insert(members, {
                job = member,
                reason = reason
            })
        end

        table.sort(members, function(a, b)
            return a.job.team < b.job.team
        end)

        self:CreateCategory(category.name, members, category.startExpanded)
    end
end

function PANEL:CreateCategory(name, members, startExpanded, color)
    if (#members < 1) then return end

    local pnlCategory = self.list:Add('onyx.Category')
    pnlCategory:Dock(TOP)
    pnlCategory:SetTitle(onyx.utf8.upper(name))
    pnlCategory:SetSpace(0)
    pnlCategory:SetInset(onyx.ScaleTall(10))
    pnlCategory:DockMargin(0, 0, 0, onyx.ScaleTall(10))
    pnlCategory.m_iTextMargin = onyx.ScaleTall(10)
    pnlCategory.m_bSquareCorners = true
    pnlCategory:SetExpanded(startExpanded)
    pnlCategory.canvas.Paint = function(p, w, h)
        draw.RoundedBoxEx(8, 0, 0, w, h, colorPrimary, false, false, true, true)
    end

    if (color) then
        pnlCategory.wimage = onyx.wimg.Create('favorite_fill', 'smooth mips')
    end

    local content = pnlCategory:Add('onyx.Grid')
    content:Dock(TOP)
    content:SetTall(0)
    content:SetSpaceX(onyx.ScaleTall(5))
    content:SetSpaceY(content:GetSpaceX())
    content:SetColumnCount(onyx.f4:GetOptionValue('job_columns'))
    content.category = pnlCategory

    for _, member in ipairs(members) do
        self:CreateMember(member.job, content, member.reason)
    end

    if ( startExpanded ) then
        pnlCategory:UpdateInTick()
        pnlCategory:UpdateInTick(10)
        pnlCategory:UpdateInTick(100)
    end
end

function PANEL:CreateMember(member, content, reason)
    local model = istable(member.model) and member.model[1] or member.model
    local max = member.max
    local inf = max == 0
    local index = member.team
    local color = onyx.f4.ConvertJobColor(member.color)
    local salary = DarkRP.formatMoney(member.salary)
    local level = member.level

    local item = content:Add('onyx.f4.Item')
    item:SetTall(onyx.ScaleTall(55))
    item:SetModel(model)
    item:SetName(member.name)
    item:SetColor(color, .25)
    --item:SetDesc(salary)
    --item:SetDescLabel(L('f4_salary'))

    if member.wl and !member.vip then
        item:SetDescColor(Color(184, 3, 255))
    	item:SetDesc('Wymagana Whitelista')
    	item:SetDescLabel("")
		--item:SetColor(Color(184, 3, 255), .25)
    elseif member.wl and member.vip then
        item:SetDescColor(Color(184, 3, 255))
    	item:SetDesc('Wymagana Whitelista i VIP')
    	item:SetDescLabel("")
		item:SetColor(Color(255,215,0), .25)
	elseif member.vip then
        item:SetDescColor(Color(255, 215, 0))
    	item:SetDesc('Praca VIP')
    	item:SetDescLabel("")
		item:SetColor(Color(255,215,0), .25)
    elseif (reason) then
        item:SetDescColor(COLOR_NEGATIVE)
        item:SetDesc(reason)
        item:SetDescLabel('')
    elseif (level and onyx.f4.GetPlayerLevel(LocalPlayer(), math.huge) < level) then
        item:SetDescColor(COLOR_NEGATIVE)
        item:SetDesc(L('requires_level', {
            level = string.Comma(level)
        }))
        item:SetDescLabel('')
    elseif (member.salary == 0) then
        item:SetDescColor(colorGray)
    else
        item:SetDescColor(Color(91, 195, 70))
    end

    item:PositionCamera('face')

    item:Import('click')
    item:Import('hovercolor')
    item:SetColorKey('colorBG')
    item:SetColorIdle(colorSecondary)
    item:SetColorHover(colorTertiary)
    item:AddHoverSound()
    item:AddClickEffect()
    item.DoClick = function()
        self:EnablePreview(member, reason)
    end

    local limit = item:Add('Panel')
    limit:Dock(RIGHT)
    limit:SetZPos(-1)
    limit:SetWide((item:GetTall() - item.padding * 2))
    limit:SetMouseInputEnabled(false)
    limit.text = inf and '∞' or ''
    limit.Paint = function(panel, w, h)
        onyx.DrawOutlinedCircle(w * .5, h * .5, math.floor(h * .5), 6, colorPrimary)

        if (panel.fraction and panel.fraction > 0) then
            onyx.DrawWithPolyMask(panel.mask, function()
                onyx.DrawOutlinedCircle(w * .5, h * .5, math.floor(h * .5), 6, color)
            end)
        end

        draw.SimpleText(panel.text, font0, w * .5, h * .5, color_white, 1, 1)
    end
    limit.PerformLayout = function(panel, w, h)
        if (panel.fraction) then
            local endAngle = math.Round(panel.fraction * 360)
            panel.mask = onyx.CalculateArc(w * .5, h * .5, 0, endAngle, h * .5 + 2, 24, true)
        end
    end

    if (not inf) then
        limit.Think = function(panel)
            if ((panel.nextThink or 0) > CurTime()) then return end                                                                                                                                                                                                        -- 5409e8b9-5bf9-4f0d-8990-ecb0a7db9134
            panel.nextThink = CurTime() + .1

            local amount = #team.GetPlayers(index)
            local fraction = math.Clamp(amount / max, 0, 1)

            panel.text = amount .. ' / ' .. max

            if (not panel.fraction or panel.fraction ~= fraction) then
                panel.fraction = fraction
                panel:InvalidateLayout()
            end
        end
    end
end

onyx.gui.Register('onyx.f4.Jobs', PANEL)

--[[------------------------------
DEBUG
--------------------------------]]
-- onyx.gui.Test('onyx.f4.Frame', .6, .65, function(panel)
--     panel:MakePopup()
--     panel:ChooseTab(2)
-- end)
--PATH addons/[ui] onyx_f4/lua/onyx/modules/f4/ui/cl_tab_shop.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

25/12/2023

--]]

local colorPrimary = onyx:Config('colors.primary')
local colorSecondary = onyx:Config('colors.secondary')
local colorTertiary = onyx:Config('colors.tertiary')
local colorLine = Color(75, 75, 75)
local colorCanAfford = Color(121, 255, 141)
local colorCannotAfford = Color(253, 120, 120)
local COLOR_NEGATIVE = Color(221, 107, 107)
local oldScrollValues = {}
local convars = {}
local itemTypes = {'entities', 'weapons', 'shipments', 'ammo'}
for _, itemType in ipairs(itemTypes) do
    convars[itemType] = CreateClientConVar('cl_onyx_f4_show_favorite_' .. itemType, '1', true, false)
end

local L = function(...) return onyx.lang:Get(...) end

local PANEL = {}

function PANEL:Init()
    local toolbarPadding = onyx.ScaleTall(5)

    self.container = self:Add('Panel')
    self.container:Dock(FILL)

    self.toolbar = self:Add('DPanel')
    self.toolbar:Dock(TOP)
    self.toolbar:SetTall(onyx.ScaleTall(80))
    self.toolbar:DockMargin(0, 0, 0, onyx.ScaleTall(10))
    self.toolbar.Paint = function(panel, w, h)
        draw.RoundedBox(8, 0, 0, w, h, colorSecondary)
    end
    self.toolbar.PerformLayout = function(panel, w, h)
        self.topRow:SetTall(h / 2)
        self.favToggler:SetWide(self.favToggler:GetContentWidth())
    end

    self.topRow = self.toolbar:Add('Panel')
    self.topRow:Dock(BOTTOM)
    self.topRow:DockPadding(toolbarPadding, toolbarPadding, toolbarPadding * 2, toolbarPadding)

    self.navbar = self.toolbar:Add('onyx.Navbar')
    self.navbar:Dock(FILL)
    self.navbar:SetContainer(self.container)
    self.navbar:SetKeepTabContent(true)
    -- self.navbar:SetRoundness(8)
    self.navbar.Paint = function(panel, w, h)
        draw.RoundedBoxEx(8, 0, 0, w, h, colorTertiary, true, true)
        surface.SetDrawColor(colorLine)
        surface.DrawRect(0, h - 1, w, 1)
    end
    self.navbar.OnTabSelected = function(panel, tab, content)
        local convar = convars[tab.ItemType]

        self.search:SetValue('')
        self.favToggler:SetVisible(convar ~= nil)

        if (convar) then
            self.favToggler:SetChecked(convar:GetBool())
            self.favToggler.OnChange = function(panel, bool)
                convar:SetBool(bool)

                tab.content:Remove()
                self.navbar:SelectTab(tab, true)
                tab.content:SetAlpha(0)
                tab.content:AlphaTo(255, .3)
            end
        end
    end

    self.favToggler = self.topRow:Add('onyx.TogglerLabel')
    self.favToggler:Dock(RIGHT)
    self.favToggler:SetText(L('f4_show_favorite'))
    self.favToggler:SetBackgroundColor(onyx.OffsetColor(colorTertiary, 10))
    self.favToggler:Font('Comfortaa Bold@18')
    self.favToggler:SetTextMargin(onyx.ScaleTall(10))

    self.search = self.topRow:Add('onyx.TextEntry')
    self.search:SetPlaceholderText(onyx.lang:Get('f4_search_text'))
    self.search:SetPlaceholderIcon('https://i.imgur.com/Nk3IUJT.png', 'smooth mips')
    self.search:Dock(LEFT)
    self.search:SetWide(onyx.ScaleWide(150))
    self.search:SetUpdateOnType(true)
    self.search.OnValueChange = function(panel, value)
        value = onyx.utf8.lower(value)

        local activeTab = self.navbar:GetActiveTab()
        if (not IsValid(activeTab)) then return end

        local plist = activeTab.content

        for _, cat in ipairs(plist:GetItems()) do
            local layout = cat.canvas:GetChild(0)
            local items = layout:GetChildren()
            local visibleItemAmount = 0

            for _, item in ipairs(items) do
                if (onyx.utf8.lower(item:GetName()):find(value, nil, true)) then
                    item:SetVisible(true)
                    visibleItemAmount = visibleItemAmount + 1
                else
                    item:SetVisible(false)
                end
            end

            layout:InvalidateLayout()

            cat:SetVisible(value == '' or visibleItemAmount > 0)
            cat:UpdateInTick()
        end

        plist:InvalidateLayout()
    end

    self.enabledFirst = false
    self.categories = {}
    self:AddItemCategory('entities', L('f4_entities_u'), 'https://i.imgur.com/JnNGizM.png', Color(141, 208, 255), 'canBuyCustomEntity', function(item)
        RunConsoleCommand('darkrp', item.cmd)
    end)

    self:AddItemCategory('weapons', L('f4_weapons_u'), 'https://i.imgur.com/IJQlezA.png', Color(255, 73, 73), 'canBuyPistol', function(item)
        RunConsoleCommand('darkrp', 'buy', item.name)
    end)

    self:AddItemCategory('shipments', L('f4_shipments_u'), 'https://i.imgur.com/9uyTLgB.png', Color(255, 173, 67), 'canBuyShipment', function(item)
        RunConsoleCommand('darkrp', 'buyshipment', item.name)
    end)

    self:AddItemCategory('ammo', L('f4_ammo_u'), 'https://i.imgur.com/oRqB4Cl.png', Color(255, 246, 141), 'canBuyAmmo', function(item)
        RunConsoleCommand('darkrp', 'buyammo', item.id)
    end)

    if (DarkRP.getFoodItems) then
        local food = DarkRP.getFoodItems()
        if (food) then
            self:AddItemCategory({{
                name = L('f4_food_u'),
                members = food,
            }}, L('f4_food_u'), 'https://i.imgur.com/sJWsDi6.png', Color(171, 255, 141), nil, function(item)
                RunConsoleCommand('darkrp', 'buyfood', item.name)
            end)
        end
    end
end

function PANEL:AddItemCategory(id, name, icon, color, hookName, purchaseFunc)
    local showUnavailable = onyx.f4:GetOptionValue('job_show_unavailable')
    local client = LocalPlayer()
    local teamIndex = client:Team()
    local categories = {}
    local membersAmount = 0

    local darkRPCategories = istable(id) and id or DarkRP.getCategories()[id]
    if (not darkRPCategories) then
        return
    end

    -- No favorites for food, sorry :(
    if (isstring(id)) then
        local members = onyx.f4:FetchFavoriteObjects(id)
        if (members) then
            table.insert(categories, {
                members = members,
                name = L('f4_favorite_u'),
                favorite = true
            })
        end
    end

    for _, cat in ipairs(darkRPCategories) do
        local canSee = cat.canSee
        local catName = cat.name
        local catMembers = {}

        if (not canSee or canSee(client)) then

            local members = cat.members or {}
            for _, member in ipairs(members) do
                local customCheck = member.customCheck
                local allowed = member.allowed or {}
                local reason

                if (customCheck and not customCheck(client)) then
                    if (showUnavailable) then
                        reason = L('f4_unavailable')
                    else
                        continue
                    end
                end

                if (hookName) then
                    local canBuy, suppress, message = hook.Call(hookName, nil, client, member)
                    if (canBuy == false) then
                        if (not suppress) then
                            reason = message
                        else
                            continue
                        end
                    end
                end

                if (not table.IsEmpty(allowed) and not table.HasValue(allowed, teamIndex)) then
                    continue
                end

                if (member.energy and member.requiresCook ~= false and not client:isCook()) then
                    return
                end

                membersAmount = membersAmount + 1
                table.insert(catMembers, {
                    item = member,
                    reason = reason
                })
            end

            table.insert(categories, {
                members = catMembers,
                name = catName
            })

        end
    end

    for _, category in ipairs(categories) do
        if (category.members) then
            table.sort(category.members, function(a, b)
                local aSort = a.item.sortOrder or 100
                local bSort = b.item.sortOrder or 100
                local aName = a.item.name or ''
                local bName = b.item.name or ''

                return (aSort < bSort or (aSort == bSort and aName < bName))
            end)
        end
    end

    self.categories[id] = categories

    if (membersAmount > 0) then
        local tab = self.navbar:AddTab({
            name = name,
            icon = icon,
            class = 'onyx.ScrollPanel',
            onBuild = function(content)
                self:SetupItemList(content, self.categories[id], color, purchaseFunc, id)

                content.OnRemove = function(panel)
                    if (panel.scrollInitialized) then
                        oldScrollValues[id] = panel.scroll:GetScroll()
                    end
                end

                timer.Simple(engine.TickInterval() * 4, function()
                    if (IsValid(content)) then
                        content.scrollInitialized = true

                        local oldScrollValue = oldScrollValues[id]
                        if (oldScrollValue) then
                            content.scroll:SetScroll(oldScrollValue)
                            content.scroll.Current = oldScrollValue
                            content.canvas.container:SetPos(0, -oldScrollValue)
                        end
                    end
                end)
            end
        })

        tab.ItemType = id

        if (not self.enabledFirst) then
            self.enabledFirst = true
            self.navbar:SelectTab(tab, true)
        end
    end
end

function PANEL:SetupItemList(content, categories, color, purchaseFunc, itemType)
    local convar = convars[itemType]
    for _, category in ipairs(categories) do
        if (convar and category.favorite and not convar:GetBool()) then continue end
        if (#category.members > 0) then
            self:CreateCategory(content, category.name, category.members, color, purchaseFunc, itemType)
        end
    end
end

function PANEL:CreateCategory(container, name, members, color, purchaseFunc, itemType)
    local pnlCategory = container:Add('onyx.Category')
    pnlCategory:Dock(TOP)
    pnlCategory:SetTitle(onyx.utf8.upper(name))
    pnlCategory:SetSpace(0)
    pnlCategory:SetInset(onyx.ScaleTall(10))
    pnlCategory:DockMargin(0, 0, 0, onyx.ScaleTall(10))
    pnlCategory:SetExpanded(true)
    pnlCategory.m_iTextMargin = onyx.ScaleTall(10)
    pnlCategory.m_bSquareCorners = true
    pnlCategory.canvas.Paint = function(p, w, h)
        draw.RoundedBoxEx(8, 0, 0, w, h, colorPrimary, false, false, true, true)
    end

    local content = pnlCategory:Add('onyx.Grid')
    content:Dock(TOP)
    content:SetTall(0)
    content:SetSpaceX(onyx.ScaleTall(5))
    content:SetSpaceY(content:GetSpaceX())
    content:SetColumnCount(onyx.f4:GetOptionValue('item_columns'))
    content.category = pnlCategory
    content.parentContainer = container

    for _, member in ipairs(members) do
        self:CreateMember(member.item, content, color, purchaseFunc, member.reason, itemType)
    end

    pnlCategory:UpdateInTick()
    pnlCategory:UpdateInTick(10)
    pnlCategory:UpdateInTick(100)
end

function PANEL:CreateMember(member, content, color, purchaseFunc, reason, itemType)
    local model = member.model
    local price = itemType == 'weapons' and member.pricesep or member.price
    local level = member.level

    local item = content:Add('onyx.f4.Item')
    item:SetTall(onyx.ScaleTall(55))
    item:SetModel(model)
    item:SetName(member.name)
    item:SetColor(color or Color(200, 200, 200), .1)
    item:SetDesc(DarkRP.formatMoney(price))
    item:SetDescLabel(L('f4_price'))
    item:SetDescColor(Color(69, 192, 87))
    item.objectIdentifier = (member.ent or member.entity or member.name)
    if (not member.energy) then
        item:AddFavoriteButton()
    end
    item.Think = function(panel)
        if ((panel.nextThink or 0) > CurTime()) then return end
        if (panel.unavailable) then return end
    
        local balance = LocalPlayer():getDarkRPVar('money') or 0
        panel.nextThink = CurTime() + .33
        panel:SetDescColor(balance >= price and colorCanAfford or colorCannotAfford)
    end
    item.OnFavoriteStateSwitched = function()
        local navbar = self.navbar
        local activeTab = navbar:GetActiveTab()
        local itemType = activeTab.ItemType
        local allCategories = self.categories[itemType]
        local favCategory = allCategories[1]

        if (favCategory and favCategory.favorite) then
            favCategory.members = onyx.f4:FetchFavoriteObjects(itemType)
        end

        activeTab.content:Remove()
        navbar:SelectTab(activeTab, true)
        activeTab.content:SetAlpha(0)
        activeTab.content:AlphaTo(255, .3)
    end

    if (reason) then
        item:SetDescColor(COLOR_NEGATIVE)
        item:SetDesc(reason)
        item:SetDescLabel('')
        item.unavailable = true
    elseif (level and onyx.f4.GetPlayerLevel(LocalPlayer(), math.huge) < level) then
        item:SetDescColor(COLOR_NEGATIVE)
        item:SetDesc(L('requires_level', {
            level = string.Comma(level)
        }))
        item:SetDescLabel('')
        item.unavailable = true
    end

    item:Import('click')
    item:Import('hovercolor')
    item:SetColorKey('colorBG')
    item:SetColorIdle(colorSecondary)
    item:SetColorHover(colorTertiary)
    item:AddHoverSound()
    item:AddClickEffect()
    item.DoClick = function()
        if (purchaseFunc) then
            purchaseFunc(member)
        end
    end

    item:PositionCamera('center')
end

onyx.gui.Register('onyx.f4.Shop', PANEL)

-- onyx.gui.Test('onyx.f4.Frame', .65, .65, function(panel)
--     panel:MakePopup()
--     panel:ChooseTab(3)
-- end)
--PATH addons/[ui] onyx_hud/lua/onyx/modules/hud/languages/cl_english.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

14/08/2024

--]]

local LANG = {}

--[[
    .............
    General Words
]]--

LANG[ 'hud_status_wanted' ] = 'Wanted'
LANG[ 'hud_status_speaking' ] = 'Speaking'
LANG[ 'hud_status_typing' ] = 'Typing'
LANG[ 'props' ] = 'Props'
LANG[ 'close' ] = 'Close'
LANG[ 'alert' ] = 'Alert'
LANG[ 'message' ] = 'Message'
LANG[ 'unknown' ] = 'Unknown'
LANG[ 'accept' ] = 'Accept'
LANG[ 'deny' ] = 'Deny'
LANG[ 'none' ] = 'None'
LANG[ 'add' ] = 'Add'
LANG[ 'remove' ] = 'Remove'
LANG[ 'jobs' ] = 'Jobs'
LANG[ 'door' ] = 'Door'
LANG[ 'vehicle' ] = 'Vehicle'
LANG[ 'door_groups' ] = 'Door groups'
LANG[ 'display' ] = 'Display'
LANG[ 'general' ] = 'General'
LANG[ 'speedometer' ] = 'Speedometer'
LANG[ 'fuel' ] = 'Fuel'
LANG[ 'vote' ] = 'Vote'
LANG[ 'question' ] = 'Question'

--[[
    .......
    Timeout
]]--

LANG[ 'timeout_title' ] = 'CONNECTION LOST'
LANG[ 'timeout_info' ] = 'Server is unavailable now, we are sorry'
LANG[ 'timeout_status' ] = 'You will be reconnected in %d seconds'

--[[
    ......
    Themes
]]--

LANG[ 'hud.theme.default.name' ] = 'Default'
LANG[ 'hud.theme.forest.name' ] = 'Forest'
LANG[ 'hud.theme.violet_night.name' ] = 'Violet Night'
LANG[ 'hud.theme.rustic_ember.name' ] = 'Rustic Ember'
LANG[ 'hud.theme.green_apple.name' ] = 'Green Apple'
LANG[ 'hud.theme.lavender.name' ] = 'Lavender'
LANG[ 'hud.theme.elegance.name' ] = 'Elegance'
LANG[ 'hud.theme.mint_light.name' ] = 'Mint'
LANG[ 'hud.theme.gray.name' ] = 'Gray'
LANG[ 'hud.theme.rose_garden.name' ] = 'Rose Garden'
LANG[ 'hud.theme.ocean_wave.name' ] = 'Ocean Wave'
LANG[ 'hud.theme.sky_blue.name' ] = 'Sky Blue'
LANG[ 'hud.theme.golden_dawn.name' ] = 'Golden Dawn'

--[[
    ....
    Help
    - Full phrase: "Type <command> to open settings"
]]

LANG[ 'hud_help_type' ] = 'Type'
LANG[ 'hud_help_to' ] = 'to open settings'

--[[
    .............
    3D2D Doors
]]--

LANG[ 'door_purchase' ] = 'Purchase {object}'
LANG[ 'door_sell' ] = 'Sell {object}'
LANG[ 'door_addowner' ] = 'Add owner'
LANG[ 'door_rmowner' ] = 'Remove owner'
LANG[ 'door_rmowner_help' ] = 'Choose the player you want to revoke ownership from'
LANG[ 'door_addowner_help' ] = 'Choose the player you want to grant ownership to'
LANG[ 'door_title' ] = 'Set title'
LANG[ 'door_title_help' ] = 'What title you want to set?'
LANG[ 'door_admin_disallow' ] = 'Disallow ownership'
LANG[ 'door_admin_allow' ] = 'Allow ownership'
LANG[ 'door_admin_edit' ] = 'Edit access'
LANG[ 'door_owned' ] = 'Private Property'
LANG[ 'door_unowned' ] = 'For Sale'

LANG[ 'hud_door_help' ] = 'Press {bind} to purchase for {price}'
LANG[ 'hud_door_owner' ] = 'Owner: {name}'
LANG[ 'hud_door_allowed' ] = 'Allowed to own'
LANG[ 'hud_door_coowners' ] = 'Coowners'
LANG[ 'hud_and_more' ] = 'and more...'

--[[
    .........
    Uppercase
]]--

LANG[ 'reconnect_u' ] = 'RECONNECT'
LANG[ 'disconnect_u' ] = 'DISCONNECT'
LANG[ 'settings_u' ] = 'SETTINGS'
LANG[ 'configuration_u' ] = 'CONFIGURATION'
LANG[ 'introduction_u' ] = 'INTRODUCTION'

--[[
    .........
    Lowercase
]]--

LANG[ 'seconds_l' ] = 'seconds'
LANG[ 'minutes_l' ] = 'minutes'

--[[
    .............
    Configuration
]]--

LANG[ 'hud.timeout.name' ] = 'Timeout Duration'
LANG[ 'hud.timeout.desc' ] = 'How many seconds before auto-reconnection'

LANG[ 'hud.alert_queue.name' ] = 'Alert Queue'
LANG[ 'hud.alert_queue.desc' ] = 'Should alerts be placed in queue'

LANG[ 'hud.props_counter.name' ] = 'Props Counter'
LANG[ 'hud.props_counter.desc' ] = 'Show props counter'

LANG[ 'hud.main_avatar_mode.name' ] = 'Main Avatar Type'
LANG[ 'hud.main_avatar_mode.desc' ] = 'Choose the type'

LANG[ 'hud.voice_avatar_mode.name' ] = 'Voice Avatar Type'
LANG[ 'hud.voice_avatar_mode.desc' ] = 'Choose the type'

LANG[ 'hud.restrict_themes.name' ] = 'Restrict Themes'
LANG[ 'hud.restrict_themes.desc' ] = 'Restrict players to choose themes'

LANG[ 'hud.speedometer_mph.name' ] = 'Use Miles'
LANG[ 'hud.speedometer_mph.desc' ] = 'Switch units to miles per hour'

LANG[ 'hud.speedometer_max_speed.name' ] = 'Max Default Speed'
LANG[ 'hud.speedometer_max_speed.desc' ] = 'The max speed for the speedometer'

LANG[ 'hud.wpnsel_sounds.name' ] = 'Weapon Selection Sounds'
LANG[ 'hud.wpnsel_sounds.desc' ] = 'Enable weapon selection UI sounds'

LANG[ 'hud_should_draw' ] = 'Should draw the element'
LANG[ 'hud.main.name' ] = 'Main HUD'
LANG[ 'hud.ammo.name' ] = 'Ammo'
LANG[ 'hud.agenda.name' ] = 'Agenda'
LANG[ 'hud.alerts.name' ] = 'Alerts'
LANG[ 'hud.pickup_history.name' ] = 'Pickup History'
LANG[ 'hud.level.name' ] = 'Level'
LANG[ 'hud.voice.name' ] = 'Voice Panels'
LANG[ 'hud.overhead_health.name' ] = '3D2D Overhead Health'
LANG[ 'hud.overhead_armor.name' ] = '3D2D Overhead Armor'
LANG[ 'hud.vehicle.name' ] = 'Vehicle HUD'
LANG[ 'hud.notifications.name' ] = 'Notifications'

--[[
    ........
    Settings
]]--

LANG[ 'hud.theme.name' ] = 'Theme'
LANG[ 'hud.theme.desc' ] = 'Choose the HUD theme'

LANG[ 'hud.scale.name' ] = 'Scale'
LANG[ 'hud.scale.desc' ] = 'Adjust the scale of the HUD'

LANG[ 'hud.roundness.name' ] = 'Roundness'
LANG[ 'hud.roundness.desc' ] = 'Adjust the roundness of the HUD'

LANG[ 'hud.margin.name' ] = 'Margin'
LANG[ 'hud.margin.desc' ] = 'The distance between the HUD and the edges'

LANG[ 'hud.icons_3d.name' ] = '3D Models'
LANG[ 'hud.icons_3d.desc' ] = 'Render model icons in 3D'

LANG[ 'hud.compact.name' ] = 'Compact Mode'
LANG[ 'hud.compact.desc' ] = 'Enable the compact mode'

LANG[ 'hud.speedometer_blur.name' ] = 'Speedometer Blur'
LANG[ 'hud.speedometer_blur.desc' ] = 'Enable the blur for the speedometer'

LANG[ 'hud.3d2d_max_details.name' ] = 'Max 3D2D Details'
LANG[ 'hud.3d2d_max_details.desc' ] = 'The maximum amount of detailed info renders'

--[[
    ......
    Status
]]--

LANG[ 'hud_lockdown' ] = 'LOCKDOWN'
LANG[ 'hud_lockdown_help' ] = 'Please return to your homes!'

LANG[ 'hud_wanted' ] = 'WANTED'
LANG[ 'hud_wanted_help' ] = 'Reason: {reason}'

LANG[ 'hud_arrested' ] = 'ARRESTED'
LANG[ 'hud_arrested_help' ] = 'You will be released in {time}'

onyx.lang:AddPhrases( 'english', LANG )
--PATH addons/[ui] onyx_hud/lua/onyx/modules/hud/core/sh_config.lua:
return gluapack()()
--PATH addons/[ui] onyx_hud/lua/onyx/modules/hud/core/sh_config.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

19/08/2024

--]]

local function createDisplayOption( id, default )
    if ( default == nil ) then default = true end

    onyx.hud:RegisterOption( 'display_' .. id, {
        title = 'hud.' .. id .. '.name',
        desc = 'hud_should_draw',
        category = 'display',
        cami = 'onyx_hud_edit',
        type = 'bool',
        default = default
    } )
end

CAMI.RegisterPrivilege({
    Name = 'onyx_hud_edit',
    MinAccess = 'superadmin',
    Description = 'Allows to configure Onyx HUD'
})

onyx.hud:RegisterOption( 'timeout', {
    title = 'hud.timeout.name',
    desc = 'hud.timeout.desc',
    category = 'general',
    cami = 'onyx_hud_edit',
    type = 'int',
    default = 45,
    min = 15,
    max = 180
} )

onyx.hud:RegisterOption( 'alert_queue', {
    title = 'hud.alert_queue.name',
    desc = 'hud.alert_queue.desc',
    category = 'general',
    cami = 'onyx_hud_edit',
    type = 'bool',
    default = false
} )

onyx.hud:RegisterOption( 'props_counter', {
    title = 'hud.props_counter.name',
    desc = 'hud.props_counter.desc',
    category = 'general',
    cami = 'onyx_hud_edit',
    type = 'bool',
    default = false
} )

onyx.hud:RegisterOption( 'restrict_themes', {
    title = 'hud.restrict_themes.name',
    desc = 'hud.restrict_themes.desc',
    category = 'general',
    cami = 'onyx_hud_edit',
    type = 'bool',
    default = false
} )

onyx.hud:RegisterOption( 'main_avatar_mode', {
    title = 'hud.main_avatar_mode.name',
    desc = 'hud.main_avatar_mode.desc',
    category = 'general',
    cami = 'onyx_hud_edit',
    type = 'int',
    default = 0,
    min = 0,
    max = 1,
    combo = {
        { 'Avatar', 0 },
        { 'Model', 1 }
    }
} )

onyx.hud:RegisterOption( 'voice_avatar_mode', {
    title = 'hud.voice_avatar_mode.name',
    desc = 'hud.voice_avatar_mode.desc',
    category = 'general',
    cami = 'onyx_hud_edit',
    type = 'int',
    default = 0,
    min = 0,
    max = 1,
    combo = {
        { 'Avatar', 0 },
        { 'Model', 1 }
    }
} )

-- Speedometer

onyx.hud:RegisterOption( 'speedometer_mph', {
    title = 'hud.speedometer_mph.name',
    desc = 'hud.speedometer_mph.desc',
    category = 'speedometer',
    cami = 'onyx_hud_edit',
    type = 'bool',
    default = false
} )

onyx.hud:RegisterOption( 'speedometer_max_speed', {
    title = 'hud.speedometer_max_speed.name',
    desc = 'hud.speedometer_max_speed.desc',
    category = 'speedometer',
    cami = 'onyx_hud_edit',
    type = 'int',
    default = 260,
    min = 180,
    max = 300
} )

-- Display

createDisplayOption( 'main' )
createDisplayOption( 'ammo' )
createDisplayOption( 'agenda' )
createDisplayOption( 'pickup_history' )
createDisplayOption( 'voice' )
createDisplayOption( 'alerts' )
createDisplayOption( 'vehicle' )
createDisplayOption( 'level' )
createDisplayOption( 'notifications' )
createDisplayOption( 'overhead_health', false )
createDisplayOption( 'overhead_armor', false )
--PATH addons/[ui] onyx_hud/lua/onyx/modules/hud/elements/cl_gesture_menu.lua:
return gluapack()()
--PATH addons/[ui] onyx_hud/lua/onyx/modules/hud/elements/cl_notifications.lua:
return gluapack()()
--PATH addons/[ui] onyx_hud/lua/onyx/modules/hud/elements/cl_own_info.lua:
return gluapack()()
--PATH addons/[ui] onyx_hud/lua/onyx/modules/hud/elements/cl_timeout.lua:
return gluapack()()
--PATH addons/[ui] onyx_hud/lua/onyx/modules/hud/elements/cl_voice_chat.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

14/08/2024

--]]


onyx.hud.VoicePanels = onyx.hud.VoicePanels or {}

local hud = onyx.hud
local cache = hud.VoicePanels

local ANIM_DURATION = .2

local function findBestFont( text, maxWidth, ... )
    local bestFont = select( 1, ... )
    assert( bestFont, 'no fonts given' )

    local lastWidth = math.huge
    for _, font in ipairs( { ... } ) do
        local width = onyx.GetTextSize( text, font )
        local isGood = width <= maxWidth

        if ( isGood or width < lastWidth ) then
            bestFont = font
            lastWidth = width

            if ( isGood ) then
                break
            end
        end
    end

    return bestFont
end

local function createPanel( ply )
    local padding = hud.ScaleTall( 5 )
    local bUseModelIcon = onyx.hud:GetOptionValue( 'voice_avatar_mode' ) == 1

    local panel = vgui.Create( 'Panel' )
    panel:SetVisible( false )
    panel:SetPaintedManually( true )
    panel:SetWide( hud.ScaleWide( 200 ) )
    panel:SetTall( hud.ScaleTall( 40 ) )
    panel:DockPadding( padding, padding, padding, padding )

    panel.player = ply
    panel.name = ply:Name()
    panel.job = team.GetName( ply:Team())
    panel.color = team.GetColor( ply:Team() )
    panel.fraction = 0
    panel.font = onyx.hud.fonts.SmallBold

    panel.OnRemove = function( this )
        for index, data in ipairs( cache ) do
            if ( data.panel == this ) then
                table.remove( cache, index )
                break
            end
        end
    end

    panel.Paint = function( this, w, h )
        local size = h - padding * 2
        local textX = h + padding
        local shouldShowJob = true
        local textColor = hud:GetColor( 'textPrimary' )
        local primaryColor = hud:GetColor( 'primary' )
        local isDark = hud:IsDark()
        local y0 = h * .5

        onyx.hud.DrawRoundedBox( 0, 0, w, h, primaryColor )

        draw.SimpleText( this.name, this.font, textX, y0, textColor, 0, 1 )

        if ( this.mask and IsValid( this.avatar ) ) then
            onyx.DrawWithPolyMask( this.mask, function()
                if ( this.avatar:GetClassName() ~= 'AvatarImage' ) then
                    surface.SetDrawColor( 0, 0, 0, 100 )
                    surface.DrawRect( 0, 0, w, h )
    
                    onyx.DrawMatGradient( 0, 0, w, h, BOTTOM, ColorAlpha( this.color, isDark and 25 or 150 )  )
                end
                
                this.avatar:PaintManual()
            end )

            onyx.DrawOutlinedCircle( padding + size * .5, y0, size * .5, 4, this.color )
        end
    end

    panel.PerformLayout = function( this, w, h )
        local size = h - padding * 2
        local maxWidth = w - size
        
        this.mask = onyx.CalculateCircle( padding + size * .5, h * .5, math.floor( size * .5 ) - 1, 24 )
        this.font = findBestFont( this.name, maxWidth, onyx.hud.fonts.SmallBold, onyx.hud.fonts.TinyBold )
    end

    panel.avatar = panel:Add( bUseModelIcon and 'SpawnIcon' or 'AvatarImage' )
    panel.avatar:SetWide( panel:GetTall() - padding * 2 )
    panel.avatar:SetPaintedManually( true )
    panel.avatar:Dock( LEFT )

    if ( bUseModelIcon ) then
        -- I have to disable it, since gmod starts rebuilding the icon
        -- and if there would be many icons it would be a mess
        -- this function does synchronize bodygroups & skin as well :(
        -- onyx.hud.UpdateModelIcon( panel.avatar, onyx.hud.GetModelData( ply ) )

        panel.avatar:SetModel( ply:GetModel() )
    else
        panel.avatar:SetPlayer( ply, 64 )
    end

    return panel
end

local function findPanel( ply )
    for index, data in ipairs( cache ) do
        if ( data.ply == ply ) then
            return data.panel
        end
    end
end

local function startAnimation( panel, targetFraction, duration, onFinished )
    onyx.anim.Create( panel, duration, {
        index = 1,
        target = { fraction = targetFraction },
        onFinished = onFinished,
        easing = 'inOutQuad',
        think = function( _, this )
            this:SetAlpha( this.fraction * 255 )
        end
    } )
end

local function toggleSpeaking( ply, state )
    local panel = findPanel( ply )
    if ( state ) then
        if ( IsValid( panel ) ) then
            startAnimation( panel, 1, ANIM_DURATION )
        else
            local data ={
                ply = ply,
                panel = createPanel( ply )
            }

            table.insert( cache, data )
            startAnimation( data.panel, 1, ANIM_DURATION )
        end
    else
        if ( IsValid( panel ) ) then
            startAnimation( panel, 0, .5, function( _, this )
                this:Remove()
            end )
        end
    end
end

local function sanitizeCache()
    for _ = 1, #cache do
        for index, data in ipairs( cache ) do
            if ( not IsValid( data.ply ) ) then
                data.panel:Remove()
                break
            end
        end
    end
end

local function drawVoiceChat( self, client, scrW, scrH )
    local screenPadding = hud.GetScreenPadding()
    local baseY = scrH * .75
    local posY = baseY
    local space = hud.ScaleTall( 5 )
    local speed = FrameTime() * 8

    for index, data in ipairs( cache ) do
        local ply = data.ply -- always valid here
        local panel = data.panel
        if ( IsValid( panel ) ) then
            local width, height = panel:GetSize()
            local posX = scrW - screenPadding - width
    
            posY = posY - height

            panel.animatedX = Lerp( speed, panel.animatedX or ScrW(), posX )
            panel.animatedY = Lerp( speed, panel.animatedY or posY, posY )
        
            panel:SetPos( panel.animatedX, panel.animatedY )
            panel:SetVisible( true ) -- this fixes micro glitch with popup being visible when created
            panel:PaintManual()

            posY = posY - space
        end
    end
end

hook.Add( 'PlayerStartVoice', 'onyx.hud.PlayerStartVoice', function( ply )
    if ( IsValid( ply ) and ply ~= LocalPlayer() ) then
        toggleSpeaking( ply, true )
    end

    return true
end )

hook.Add( 'PlayerEndVoice', 'onyx.hud.PlayerEndVoice', function( ply )
    if ( IsValid( ply ) ) then
        toggleSpeaking( ply, false )
    end

    return true
end )

onyx.hud:RegisterElement( 'voice', {
    drawFn = function( self, client, scrW, scrH )
        sanitizeCache()
        drawVoiceChat( self, client, scrW, scrH )
    end
} )
--PATH addons/[ui] onyx_scoreboard/lua/onyx/modules/scoreboard/sh_init.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

28/02/2024

--]]

onyx:Addon('scoreboard', {
    color = Color(65, 162, 211),
    author = 'tochnonement',
    version = '1.1.2',
    licensee = '76561198196280105'
})

----------------------------------------------------------------

onyx.Include('sv_sql.lua')
onyx.IncludeFolder('onyx/modules/scoreboard/languages/')
onyx.IncludeFolder('onyx/modules/scoreboard/core/', true)
onyx.IncludeFolder('onyx/modules/scoreboard/cfg/', true)
onyx.IncludeFolder('onyx/modules/scoreboard/ui/')

onyx.scoreboard:Print('Finished loading.')
--PATH addons/[ui] onyx_scoreboard/lua/onyx/modules/scoreboard/ui/cl_columns_row.lua:
return gluapack()()
--PATH addons/[gas] gmodadminsuite-config-master/lua/openpermissions_config.lua:
--[[

	   ____                   ____                      _           _                 
	  / __ \____  ___  ____  / __ \___  _________ ___  (_)_________(_)___  ____  _____
	 / / / / __ \/ _ \/ __ \/ /_/ / _ \/ ___/ __ `__ \/ / ___/ ___/ / __ \/ __ \/ ___/
	/ /_/ / /_/ /  __/ / / / ____/  __/ /  / / / / / / (__  |__  ) / /_/ / / / (__  ) 
	\____/ .___/\___/_/ /_/_/    \___/_/  /_/ /_/ /_/_/____/____/_/\____/_/ /_/____/  
	    /_/                                                                           

	Welcome to the OpenPermissions configuration file.
	This is where you'll define who is an OpenPermissions Operator.

	Operators have maximum permissions - you could call them "superadmins" of OpenPermissions.
	They have access to changing the permissions of the server, so only add people you trust here!

]]

-- Enter usergroups that should be Operators
OpenPermissions.Operators.Usergroups = {"superadmin", "operator", "developer", "owner", "founder"}

-- Enter SteamIDs or SteamID64s of people who should be Operators
OpenPermissions.Operators.SteamIDs = {"STEAM_0:1:40314158", "76561198040894045"}

-- Don't delete the line below; your config will break.
return true
--PATH addons/[ekonomia] pcasino/lua/autorun/pcasino_init.lua:
return gluapack()()
--PATH addons/[ekonomia] pcasino/lua/perfectcasino/derma/cl_elements.lua:
-- Function Cache
local color = Color
local draw_roundedbox = draw.RoundedBox
local draw_simpletext = draw.SimpleText
local draw_notexture = draw.NoTexture
local surface_setdrawcolor = surface.SetDrawColor
-- Color cache
local inputBlack = color(100, 100, 100)
local mainRed = color(155, 50, 50)
local mainBlack = color(38, 38, 38)
local textWhite = color(220, 220, 220)

-- Text Entry
local PANEL = {}
function PANEL:Init()
	self:DockMargin(5, 5, 5, 5)
	self:SetFont("pCasino.Textbox.Static")
	self:SetText("")
	self:SetDisplayText("Input")
end

function PANEL:SetDisplayText(text)
	self.placeholder = text
end

function PANEL:Paint(w, h)
	draw_roundedbox(3, 0, 0, w, h, mainRed)
	draw_roundedbox(3, 1, 1, w - 2, h - 2, mainBlack)

	self:DrawTextEntryText(textWhite, mainRed, mainRed)

	if(self:GetText() == "") and not self:HasFocus() then
		draw_simpletext(self.placeholder, "pCasino.Textbox.Static", 5, h/2, textWhite, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
	end
end
vgui.Register('pCasinoEntry', PANEL, 'DTextEntry')

-- Switch
-- Created by Livaco, edited by Owain.
local PANEL = {}
function PANEL:Init()
	self:SetText("")
	self.toggle = true

	self.lerp = 0.2
end
function PANEL:DoClick()
	self:Toggle()
end
function PANEL:Toggle()
	self:SetToggle(not self:GetToggle())
end
function PANEL:GetToggle()
	return self.toggle
end
function PANEL:SetToggle(value)
	self.toggle = value
end
function PANEL:Paint(w, h)
	draw_roundedbox(3, w*0.05, h*0.3, w*0.9, h*0.4, inputBlack)

	if self:GetToggle() then
		self.lerp = Lerp(0.1, self.lerp, 0.8)
	else
		self.lerp = Lerp(0.1, self.lerp, 0.2)
	end

	draw_notexture()
	surface_setdrawcolor(200-(200*self.lerp), 0+(200*self.lerp), 0, 255)
	PerfectCasino.UI.DrawCircle(w*self.lerp, h*0.5, h*0.35, 1)
end
vgui.Register('pCasinoSwitch', PANEL, 'DButton')


-- Circle Function
-- Created by Ben.
local sinCache = {}
local cosCache = {}
for i = 0, 360 do
	sinCache[i] = math.sin(math.rad(i))
	cosCache[i] = math.cos(math.rad(i))
end
function PerfectCasino.UI.DrawCircle(x, y, r, step)
    local positions = {}

    for i = 0, 360, step do
        table.insert(positions, {
            x = x + cosCache[i] * r,
            y = y + sinCache[i] * r
        })
    end

    return surface.DrawPoly(positions)
end

-- Rotate around point
-- Taken from wiki: https://wiki.facepunch.com/gmod/surface.DrawTexturedRectRotated
function PerfectCasino.UI.DrawTexturedRectRotatedPoint(x, y, w, h, rot, x0, y0)
	local c = math.cos(math.rad(rot))
	local s = math.sin(math.rad(rot))
	
	local newx = y0 * s - x0 * c
	local newy = y0 * c + x0 * s
	
	surface.DrawTexturedRectRotated(x + newx, y + newy, w, h, rot)
end

-- Rotate text
-- Taken from wiki: https://wiki.facepunch.com/gmod/cam.PushModelMatrix
function PerfectCasino.UI.TextRotated(text, x, y, color, font, ang, shift)
	local mat = Matrix()
	mat:Rotate(Angle(0, ang, 0))
	mat:SetTranslation(Vector(x, y, shift or 0))
	
	cam.PushModelMatrix(mat, true)
	    draw_simpletext(text, font, 0, 0, color, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
	cam.PopModelMatrix()    
end

-- Apply st, nd, rd, th to a number. This only works to 20, but there will never be an internal usecase past 20
-- Taken from xSits: A custom addon written by Owain
function PerfectCasino.UI.NumberSuffix(i)
	if i == 1 then
		return i.."st"
	elseif i == 2 then
		return i.."nd"
	elseif i == 3 then
		return i.."rd"
	end

	return i.."th"
end

-- Wrap text
-- Taken from XYZUI: A custom UI library written by Owain
function PerfectCasino.UI.WrapText(text, wrap, font, posx, posy, color, align1, align2)
	text = string.Explode("", text)

	local newText = {}
	for i=1, math.ceil(#text/wrap) do
		newText[i] = ""
		for p=1 + ((i-1)*wrap), i*wrap do
			if not text[p] then break end

			newText[i] = newText[i]..text[p]
		end
	end

	text = newText

	local space = 30*#text
	local startingPos = posy-(space/2)+(30/2)

	for k, v in pairs(text) do
		draw_simpletext(v, font, posx, startingPos+((k-1)*30), color or color_white, align1, align2)
	end
end

--PATH addons/[ekonomia] pcasino/lua/perfectcasino/core/sh_chip.lua:
return gluapack()()
--PATH addons/[ekonomia] pcasino/lua/perfectcasino/config/sh_language.lua:
-- Config Menu
PerfectCasino.Translation.ConfigMenu = {}
PerfectCasino.Translation.ConfigMenu.Title = "pCasino Entity Creator"
PerfectCasino.Translation.ConfigMenu.EntityToConfig = "Entity To Config"
PerfectCasino.Translation.ConfigMenu.EntityToConfigComboBox = "Choose an entity!"
PerfectCasino.Translation.ConfigMenu.RewardComboBox = "Choose a reward!"
PerfectCasino.Translation.ConfigMenu.SpawnEntity = "Create Entity"
PerfectCasino.Translation.ConfigMenu.ResetButton = "Go Back"
PerfectCasino.Translation.ConfigMenu.AddComboButton = "New Combo"
PerfectCasino.Translation.ConfigMenu.TableHeaderChance = "Combo"
PerfectCasino.Translation.ConfigMenu.TableHeaderActions = "Actions"
PerfectCasino.Translation.ConfigMenu.TakeoutBonusMultiplier = "Takeout Bonus Multiplier:"
PerfectCasino.Translation.ConfigMenu.IsJackpot = "Is Jackpot:"
PerfectCasino.Translation.ConfigMenu.Delete = "DELETE"

-- Entities
PerfectCasino.Translation.Entities = {}
PerfectCasino.Translation.Entities["pcasino_slot_machine"] = "Basic Slot Machine"
PerfectCasino.Translation.Entities["pcasino_wheel_slot_machine"] = "Wheel Slot Machine"
PerfectCasino.Translation.Entities["pcasino_roulette_table"] = "Roulette Table"
PerfectCasino.Translation.Entities["pcasino_blackjack_table"] = "Blackjack Table"
PerfectCasino.Translation.Entities["pcasino_mystery_wheel"] = "Mystery Wheel"
PerfectCasino.Translation.Entities["pcasino_sign_plaque"] = "Sign Plaque"
PerfectCasino.Translation.Entities["pcasino_sign_stand"] = "Sign Stand"
PerfectCasino.Translation.Entities["pcasino_sign_wall_logo"] = "Sign Wall Logo"
PerfectCasino.Translation.Entities["pcasino_sign_interior_standing"] = "Sign Interior Standing"
PerfectCasino.Translation.Entities["pcasino_sign_interior_wall"] = "Sign Interior Wall"
PerfectCasino.Translation.Entities["pcasino_chair"] = "Chair"
PerfectCasino.Translation.Entities["pcasino_prize_plinth"] = "Prize Plinth"
PerfectCasino.Translation.Entities["pcasino_npc"] = "NPC"

-- Rewards
PerfectCasino.Translation.Rewards = {}
PerfectCasino.Translation.Rewards["nothing"] = "Nothing"
PerfectCasino.Translation.Rewards["money"] = "Money"
PerfectCasino.Translation.Rewards["jackpot"] = "Jackpot"
PerfectCasino.Translation.Rewards["prize_wheel"] = "Free Mystery Wheel Spin"
PerfectCasino.Translation.Rewards["weapon"] = "Weapon"
PerfectCasino.Translation.Rewards["health"] = "Health"
PerfectCasino.Translation.Rewards["armor"] = "Armor"
PerfectCasino.Translation.Rewards["kill"] = "Kill"
PerfectCasino.Translation.Rewards["setmodel"] = "Set Playermodel"
PerfectCasino.Translation.Rewards["ps1_points"] = "[Pointshop 1] Points"
PerfectCasino.Translation.Rewards["ps1_item"] = "[Pointshop 1] Item"
PerfectCasino.Translation.Rewards["ps2_points"] = "[Pointshop 2] Points"
PerfectCasino.Translation.Rewards["ps2_item"] = "[Pointshop 2] Item"
PerfectCasino.Translation.Rewards["ps2_prempoints"] = "[Pointshop 2] Premium Points"
PerfectCasino.Translation.Rewards["pssh_points"] = "[SH Pointshop] Points"
PerfectCasino.Translation.Rewards["pssh_item"] = "[SH Pointshop] Item"
PerfectCasino.Translation.Rewards["pssh_prempoints"] = "[SH Pointshop] Premium Points"
PerfectCasino.Translation.Rewards["wcd_givecar"] = "[William's Car Dealer] Give Car"
PerfectCasino.Translation.Rewards["fcd_givecar"] = "[Fresh Car Dealer] Give Car"
PerfectCasino.Translation.Rewards["bwe_givexp"] = "[BrickWall's Essentials] Give XP"
PerfectCasino.Translation.Rewards["mtkn_tokens"] = "[mTokens] Give Tokens"
PerfectCasino.Translation.Rewards["srp_givecar"] = "[SantosRP] Give Car"
PerfectCasino.Translation.Rewards["bc_credits"] = "[Brick's Credits] Credits"
PerfectCasino.Translation.Rewards["3dcd_givecar"] = "[3D Car Dealer 2] Give Car"
PerfectCasino.Translation.Rewards["vcmod_givecar"] = "[VCMod] Give Car"
PerfectCasino.Translation.Rewards["mcd_givecar"] = "[Modern Car Dealer] Give Car"

-- Config Options
PerfectCasino.Translation.Config = {}
PerfectCasino.Translation.Config.general = {}
PerfectCasino.Translation.Config.general.Title = "General Settings"
PerfectCasino.Translation.Config.general.Desc = "The general game settings"
PerfectCasino.Translation.Config.general.betPeriod = "The period after the first bet before the game starts"
PerfectCasino.Translation.Config.general.useFreeSpins = "The ability to use won free spins on this wheel"
PerfectCasino.Translation.Config.general.rope = "Add a rope around the edge"
PerfectCasino.Translation.Config.general.model = "The model to show off"
PerfectCasino.Translation.Config.general.spin = "Make the platform spin"
PerfectCasino.Translation.Config.general.bow = "A cute bow on top (This will not work with models that have oversized collision boxes)"
PerfectCasino.Translation.Config.general.bowOffset = "If having a bow is enabled, you can set a vertical offset here. (Negative or positive)"
PerfectCasino.Translation.Config.general.limitUse = "Only allow use of 1 machine at a time"

PerfectCasino.Translation.Config.buySpin = {}
PerfectCasino.Translation.Config.buySpin.Title = "Buy Spins Settings"
PerfectCasino.Translation.Config.buySpin.Desc = "Buying spins for a wheel"
PerfectCasino.Translation.Config.buySpin.buy = "The ability to purchase a spin for money"
PerfectCasino.Translation.Config.buySpin.cost = "If so, the price a spin costs"
PerfectCasino.Translation.Config.jackpot = {}
PerfectCasino.Translation.Config.jackpot.Title = "Jackpot Settings"
PerfectCasino.Translation.Config.jackpot.Desc = "The jackpot settings"
PerfectCasino.Translation.Config.jackpot.toggle = "Should the jackpot be winnable?"
PerfectCasino.Translation.Config.jackpot.startValue = "Starting Jackpot value"
PerfectCasino.Translation.Config.jackpot.betAdd = "The % of the bet to add to the jackpot. 0.1 = 10%, 0.5 = 50%, 1 = 100%, ect"
PerfectCasino.Translation.Config.reward = {}
PerfectCasino.Translation.Config.reward.Title = "Reward Settings"
PerfectCasino.Translation.Config.reward.Desc = "Choose what reward combos are given"
PerfectCasino.Translation.Config.combo = {}
PerfectCasino.Translation.Config.combo.Title = "Combo Settings"
PerfectCasino.Translation.Config.combo.Desc = "Create combos for payouts"
PerfectCasino.Translation.Config.wheel = {}
PerfectCasino.Translation.Config.wheel.Title = "Wheel Settings"
PerfectCasino.Translation.Config.wheel.Desc = "Set what rewards are given on the wheel"
PerfectCasino.Translation.Config.bet = {}
PerfectCasino.Translation.Config.bet.Title = "Bet Settings"
PerfectCasino.Translation.Config.bet.Desc = "Set bet limits"
PerfectCasino.Translation.Config.bet.default = "The default betting value"
PerfectCasino.Translation.Config.bet.max = "The max betting value"
PerfectCasino.Translation.Config.bet.min = "The minimum betting value"
PerfectCasino.Translation.Config.bet.iteration = "The betting increase when the arrow is pressed"
PerfectCasino.Translation.Config.bet.betLimit = "Max bet per round per user (0 for no limit)"
PerfectCasino.Translation.Config.chance = {}
PerfectCasino.Translation.Config.chance.Title = "Chance Settings"
PerfectCasino.Translation.Config.chance.Desc = "Set the chances of it landing on this item. Higher value = more chance"
PerfectCasino.Translation.Config.chance.Bar = "Chance rates visualized"
PerfectCasino.Translation.Config.other = {}
PerfectCasino.Translation.Config.other.Title = "Other Settings"
PerfectCasino.Translation.Config.other.Desc = "Misc settings"
PerfectCasino.Translation.Config.turn = {}
PerfectCasino.Translation.Config.turn.Title = "Turn Settings"
PerfectCasino.Translation.Config.turn.Desc = "The settings for each turn"
PerfectCasino.Translation.Config.turn.timeout = "The amount of seconds until the turn times out"
PerfectCasino.Translation.Config.payout = {}
PerfectCasino.Translation.Config.payout.Title = "Payout Settings"
PerfectCasino.Translation.Config.payout.Desc = "The payout settings"
PerfectCasino.Translation.Config.payout.win = "The payout multiplier for a win"
PerfectCasino.Translation.Config.payout.blackjack = "The payout multiplier for a blackjack win"
PerfectCasino.Translation.Config.text = {}
PerfectCasino.Translation.Config.text.Title = "Text Settings"
PerfectCasino.Translation.Config.text.Desc = "The text settings"
PerfectCasino.Translation.Config.text.overhead = "The text to display above the NPC"
PerfectCasino.Translation.Config.text.chat = "The chat message to say when interacted with"

-- Toolgun
PerfectCasino.Translation.ToolGun = {}
PerfectCasino.Translation.ToolGun.NoEntity = "Please configure an entity with Right Click first"
PerfectCasino.Translation.ToolGun.DeletePermissions = "FPP BLOCKS YOUR PCASINO TOOLGUN PERMISSIONS"
PerfectCasino.Translation.ToolGun.FPPCheck = "Check you can toolgun this entity with FPP!"

-- Entity Interfaces
PerfectCasino.Translation.UI = {}
PerfectCasino.Translation.UI.JackPot = "JackPot: %s"
PerfectCasino.Translation.UI.Number = "Number: %i"
PerfectCasino.Translation.UI.Start = "Start: %is"
PerfectCasino.Translation.UI.PlaceBet = "Place Bet"
PerfectCasino.Translation.UI.Waiting = "Waiting"
PerfectCasino.Translation.UI.DoubleDown = "Double Down"
PerfectCasino.Translation.UI.Split = "Split"
PerfectCasino.Translation.UI.Hit = "Hit"
PerfectCasino.Translation.UI.Stand = "Stand"
PerfectCasino.Translation.UI.Blackjack = "%i (Blackjack)"
PerfectCasino.Translation.UI.Bust = "%i (Bust)"
PerfectCasino.Translation.UI.CurrentHandTotalValue = "Hand Value: %s"
PerfectCasino.Translation.UI.CurrentHand = "Current Hand: %s"
PerfectCasino.Translation.UI.SpinThatWheel = "Spin That Wheel!"
PerfectCasino.Translation.UI.ReadyToPlay = "Ready To Play!"
PerfectCasino.Translation.UI.PurchaseASpin = "Purchase a Spin!"
PerfectCasino.Translation.UI.FreeSpin = "Free Spin!"
PerfectCasino.Translation.UI.FreeSpinCount = "Free Spins: %s"
PerfectCasino.Translation.UI.Play = "Play: %s"
PerfectCasino.Translation.UI.LeaveSeat = "Hold E to leave the seat"
PerfectCasino.Translation.UI.BetLimit = "Bet Limit: %s"

-- Chat messages
PerfectCasino.Translation.Chat = {}
PerfectCasino.Translation.Chat.NoMoney = "You do not have enough money to place this bet..."
PerfectCasino.Translation.Chat.Payout = "You have won %s!"
PerfectCasino.Translation.Chat.RouletteFail = "None of your bets paid out..."
PerfectCasino.Translation.Chat.PayoutJackpot = "You hit the jackpot worth %s!"
PerfectCasino.Translation.Chat.AlreadyPlaced = "You have already placed a bet..."
PerfectCasino.Translation.Chat.BetPlaced = "Your bet has been placed!"
PerfectCasino.Translation.Chat.HandBust = "Your hand has bust, you will receive no payout..."
PerfectCasino.Translation.Chat.DealerHandBust = "The dealer has bust, your payout is %s!"
PerfectCasino.Translation.Chat.HandDraw = "You drew with the house, your bet has been returned to you."
PerfectCasino.Translation.Chat.HandLose = "The house's hand beats your hand, you will receive no payout..."
PerfectCasino.Translation.Chat.HandWin = "You beat the house, your payout is %s!"
PerfectCasino.Translation.Chat.SlotWheelSpin = "You spun the wheel and got %s!"
PerfectCasino.Translation.Chat.UsedFreeSpin = "You have used a free spin!"
PerfectCasino.Translation.Chat.UsedPaidSpin = "You have paid %s for a spin!"
PerfectCasino.Translation.Chat.BetLimit = "You have reached the betting limit for this round!"
PerfectCasino.Translation.Chat.WillReachBetLimit = "This bet will exceed the bet limit. You cannot bet more than %s..."
PerfectCasino.Translation.Chat.LimitMachineUse = "You are trying to use a different machine too quickly..."
PerfectCasino.Translation.Chat.LimitMachineUsedByOther = "This machine is currently being used by someone else!"

--PATH lua/autorun/portals_autorun.lua:


CreateConVar("portals_allow_custom_colors", 1, {FCVAR_ARCHIVE, FCVAR_REPLICATED}, "Whether players should be able to change portal colors.", 0, 1)
CreateConVar("portals_allow_custom_sounds", 1, {FCVAR_ARCHIVE, FCVAR_REPLICATED}, "Whether players should be able to change portal sounds.", 0, 1)

CreateConVar("porte_default_sound", "turbolift.wav", {FCVAR_ARCHIVE, FCVAR_REPLICATED}, "The default sound that is used for portal effects.")

CreateConVar("portals_extended_whitelist", 1, {FCVAR_ARCHIVE, FCVAR_REPLICATED}, "Whether portals should teleport non-player, non-npc entities.")

if CLIENT then
	CreateClientConVar("portals_lights_enabled", 1, true, false, "Whether portals should emit light.", 0, 1)
	CreateClientConVar("portals_lights_range", 1024, true, false, "The range at which portals emit light.", 0)
end

--PATH lua/autorun/rb655_extended_spawnmenu.lua:

AddCSLuaFile()

if ( SERVER ) then

	util.AddNetworkString( "rb655_playsound" )

	concommand.Add( "rb655_playsound_all", function( ply, cmd, args )
		if ( !ply:IsSuperAdmin() or !args[ 1 ] or string.Trim( args[ 1 ] ) == "" ) then return end

		net.Start( "rb655_playsound" )
		net.WriteString( args[ 1 ] or "" )
		net.Broadcast()
	end )

	return

end

local cl_addTabs = CreateClientConVar( "rb655_create_sm_tabs", "0", true, true )

--[[local function removeOldTabls()
	for k, v in pairs( g_SpawnMenu.CreateMenu.Items ) do
		if (v.Tab:GetText() == language.GetPhrase( "spawnmenu.category.npcs" ) or
			v.Tab:GetText() == language.GetPhrase( "spawnmenu.category.entities" ) or
			v.Tab:GetText() == language.GetPhrase( "spawnmenu.category.weapons" ) or
			v.Tab:GetText() == language.GetPhrase( "spawnmenu.category.vehicles" ) or
			v.Tab:GetText() == language.GetPhrase( "spawnmenu.category.postprocess" ) ) then
			g_SpawnMenu.CreateMenu:CloseTab( v.Tab, true )
		end
	end
end

hook.Add( "PopulateContent", "rb655_extended_spawnmenu", function( pnlContent, tree, node )
	removeOldTabls() removeOldTabls() removeOldTabls() -- For some reason it doesn't work with only one call
end )]]

local function getGameList()
	local games = engine.GetGames()
	table.insert( games, {
		title = "All",
		folder = "GAME",
		icon = "all",
		mounted = true
	} )
	table.insert( games, {
		title = "Garry's Mod",
		folder = "garrysmod",
		mounted = true
	} )
	return games
end

--[[ ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ ]]

local theSound = nil

function rb655_playsound( snd )

	if ( theSound ) then theSound:Stop() end

	theSound = CreateSound( LocalPlayer(), snd )
	theSound:Play()

end

net.Receive( "rb655_playsound", function( len )
	rb655_playsound( net.ReadString() )
end )

spawnmenu.AddContentType( "sound", function( container, obj )
	if ( !obj.nicename ) then return end
	if ( !obj.spawnname ) then return end

	local icon = vgui.Create( "ContentIcon", container )
	icon:SetContentType( "sound" )
	icon:SetSpawnName( obj.spawnname )
	icon:SetName( obj.nicename )
	icon:SetMaterial( "icon16/sound.png" )

	icon.DoClick = function()
		rb655_playsound( obj.spawnname )
	end

	icon.OpenMenu = function( icn )
		local menu = DermaMenu()
			menu:AddOption( "#spawnmenu.menu.copy", function() SetClipboardText( obj.spawnname ) end ):SetIcon( "icon16/page_copy.png" )
			menu:AddOption( "Play on all clients", function() RunConsoleCommand( "rb655_playsound_all", obj.spawnname ) end ):SetIcon( "icon16/sound.png" )
			menu:AddOption( "Stop all sounds", function() RunConsoleCommand( "stopsound" ) end ):SetIcon( "icon16/sound_mute.png" )
			menu:AddSpacer()
			menu:AddOption( "#spawnmenu.menu.delete", function() icn:Remove() hook.Run( "SpawnlistContentChanged", icn ) end ):SetIcon( "icon16/bin_closed.png" )
		menu:Open()
	end

	if ( IsValid( container ) ) then
		container:Add( icon )
	end

	return icon

end )

local function OnSndNodeSelected( self, node, name, path, pathid, icon, ViewPanel, pnlContent )

	ViewPanel:Clear( true )

	local Path = node:GetFolder()

	local files = file.Find( Path .. "/*.wav", node:GetPathID() )
	files = table.Add( files, file.Find( Path .. "/*.mp3", node:GetPathID() ) )
	files = table.Add( files, file.Find( Path .. "/*.ogg", node:GetPathID() ) )

	local offset = 0
	local limit = 512
	if ( node.offset ) then offset = node.offset or 0 end

	for k, v in pairs( files ) do
		if ( k > limit + offset ) then
			if ( !node.Done ) then
				offset = offset + limit
				local mats = ( self.Parent or node ):AddNode( ( self.Text or node:GetText() ) .. " (" .. offset .. " - " .. offset + limit .. ")" )
				mats:SetFolder( node:GetFolder() )
				mats.Text = self.Text or node:GetText()
				mats.Parent = self.Parent or node
				mats:SetPathID( node:GetPathID() )
				mats:SetIcon( node:GetIcon() )
				mats.offset = offset
				mats.OnNodeSelected = function( mats_self, mats_node )
					OnSndNodeSelected( mats_self, mats_node, mats_self.Text, mats_node:GetFolder(), mats_node:GetPathID(), mats_node:GetIcon(), ViewPanel, pnlContent )
				end
			end
			node.Done = true
		break end
		if ( k <= offset ) then continue end

		local p = Path .. "/"
		if ( string.StartWith( path, "addons/" ) or string.StartWith( path, "download/" ) ) then
			p = string.sub( p, string.find( p, "/sound/" ) + 1 )
		end

		p = string.sub( p .. v, 7 )

		spawnmenu.CreateContentIcon( "sound", ViewPanel, { spawnname = p, nicename = string.Trim( v ) } )

	end

	pnlContent:SwitchPanel( ViewPanel )

end

local function AddBrowseContentSnd( node, name, icon, path, pathid )

	local ViewPanel = node.ViewPanel
	local pnlContent = node.pnlContent

	if ( !string.EndsWith( path, "/" ) && string.len( path ) > 1 ) then path = path .. "/" end

	local fi, fo = file.Find( path .. "sound", pathid )
	if ( !fo && !fi ) then return end

	local sounds = node:AddFolder( name, path .. "sound", pathid, false, false, "*.*" )
	sounds:SetIcon( icon )

	sounds.OnNodeSelected = function( self, node_sel )
		OnSndNodeSelected( self, node_sel, name, path, pathid, icon, ViewPanel, pnlContent )
	end

end

language.Add( "spawnmenu.category.browsesounds", "Browse Sounds" )

local function RefreshAddonSounds( browseAddonSounds )
		for _, addon in SortedPairsByMemberValue( engine.GetAddons(), "title" ) do

		if ( !addon.downloaded ) then continue end
		if ( !addon.mounted ) then continue end
		if ( !table.HasValue( select( 2, file.Find( "*", addon.title ) ), "sound" ) ) then continue end

		AddBrowseContentSnd( browseAddonSounds, addon.title, "icon16/bricks.png", "", addon.title )
	end
end
local function RefreshGameSounds( browseGameSounds )
	local games = getGameList()

	for _, game in SortedPairsByMemberValue( games, "title" ) do
		if ( !game.mounted ) then continue end
		AddBrowseContentSnd( browseGameSounds, game.title, "games/16/" .. ( game.icon or game.folder ) .. ".png", "", game.folder )
	end
end

local browseGameSounds
local browseAddonSounds
hook.Add( "PopulateContent", "SpawnmenuLoadSomeSounds", function( pnlContent, tree, browseNode ) timer.Simple( 0.5, function()

	if ( !IsValid( tree ) or !IsValid( pnlContent ) ) then
		print( "!!! Extended Spawnmenu: FAILED TO INITALIZE PopulateContent HOOK FOR SOUNDS !!!" )
		print( "!!! Extended Spawnmenu: FAILED TO INITALIZE PopulateContent HOOK FOR SOUNDS !!!" )
		print( "!!! Extended Spawnmenu: FAILED TO INITALIZE PopulateContent HOOK FOR SOUNDS !!!" )
		return
	end

	local ViewPanel = vgui.Create( "ContentContainer", pnlContent )
	ViewPanel:SetVisible( false )

	local browseSounds = tree:AddNode( "#spawnmenu.category.browsesounds", "icon16/sound.png" )
	browseSounds.ViewPanel = ViewPanel
	browseSounds.pnlContent = pnlContent

	--[[ --------------------------------------------------------------------------------------- ]]

	browseAddonSounds = browseSounds:AddNode( "#spawnmenu.category.addons", "icon16/folder_database.png" )
	browseAddonSounds.ViewPanel = ViewPanel
	browseAddonSounds.pnlContent = pnlContent

	RefreshAddonSounds( browseAddonSounds )

	--[[ --------------------------------------------------------------------------------------- ]]

	local addon_sounds = {}
	local _, snd_folders = file.Find( "addons/*", "MOD" )
	for _, addon in SortedPairs( snd_folders ) do

		if ( !file.IsDir( "addons/" .. addon .. "/sound/", "MOD" ) ) then continue end

		table.insert( addon_sounds, addon )

	end

	local browseLegacySounds = browseSounds:AddNode( "#spawnmenu.category.addonslegacy", "icon16/folder_database.png" )
	browseLegacySounds.ViewPanel = ViewPanel
	browseLegacySounds.pnlContent = pnlContent

	for _, addon in SortedPairsByValue( addon_sounds ) do

		AddBrowseContentSnd( browseLegacySounds, addon, "icon16/bricks.png", "addons/" .. addon .. "/", "MOD" )

	end

	--[[ --------------------------------------------------------------------------------------- ]]

	AddBrowseContentSnd( browseSounds, "#spawnmenu.category.downloads", "icon16/folder_database.png", "download/", "MOD" )

	--[[ --------------------------------------------------------------------------------------- ]]

	browseGameSounds = browseSounds:AddNode( "#spawnmenu.category.games", "icon16/folder_database.png" )
	browseGameSounds.ViewPanel = ViewPanel
	browseGameSounds.pnlContent = pnlContent

	RefreshGameSounds( browseGameSounds )

end ) end )

hook.Add( "GameContentChanged", "ES_RefreshSpawnmenuSounds", function()

	if ( IsValid( browseAddonSounds ) ) then

		-- TODO: Maybe be more advaced and do not delete => recreate all the nodes, only delete nodes for addons that were removed, add only the new ones?
		browseAddonSounds:Clear()
		browseAddonSounds.ViewPanel:Clear( true )

		RefreshAddonSounds( browseAddonSounds )

	end

	if ( IsValid( browseGameSounds ) ) then

		-- TODO: Maybe be more advaced and do not delete => recreate all the nodes, only delete nodes for addons that were removed, add only the new ones?
		browseGameSounds:Clear()
		browseGameSounds.ViewPanel:Clear( true )

		RefreshGameSounds( browseGameSounds )

	end

end )

--[[ ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ ]]

local function IsMaterialUsableOnEntities( matPath )
	-- A png file? No thanks
	if ( string.GetExtensionFromFilename( matPath ) ) then return false end

	local mat = Material( matPath )
	if ( !string.find( mat:GetShader(), "LightmappedGeneric" )
	&& !string.find( mat:GetShader(), "WorldVertexTransition" )
	&& !string.find( mat:GetShader(), "Spritecard" )
	&& !string.find( mat:GetShader(), "Water" )
	&& !string.find( mat:GetShader(), "Cable" )
	--&& !string.find( mat:GetShader(), "UnlitGeneric" )
	&& !string.find( mat:GetShader(), "Refract" ) ) then
		return true
	end

	return false
end

local DisplayedWarning = false
local function DisplayOneTimeWarning()
	if ( DisplayedWarning ) then return end
	DisplayedWarning = true

	Derma_Message( "Please note that not all materials are usable on entities, such as map textures, etc.\nYou can still try though!", "Warning", "OK" )
end

spawnmenu.AddContentType( "material", function( container, obj )
	if ( !obj.nicename ) then return end
	if ( !obj.spawnname ) then return end

	local icon = vgui.Create( "ContentIcon", container )
	icon:SetContentType( "material" )
	icon:SetSpawnName( obj.spawnname )
	icon:SetName( obj.nicename )
	if ( string.GetExtensionFromFilename( obj.spawnname ) == "png" ) then
		icon:SetMaterial( obj.spawnname )
	else
		icon.Image:SetImage( obj.spawnname )
	end

	icon.DoClick = function()
		if ( !IsMaterialUsableOnEntities( obj.spawnname ) ) then DisplayOneTimeWarning() end

		RunConsoleCommand( "material_override", obj.spawnname )
		spawnmenu.ActivateTool( "material" )
		surface.PlaySound( "garrysmod/ui_click.wav" )
	end

	icon.OpenMenu = function( icn )
		local menu = DermaMenu()
			menu:AddOption( "#spawnmenu.menu.copy", function() SetClipboardText( obj.spawnname ) end ):SetIcon( "icon16/page_copy.png" )

			local str = "Use with Material Tool"
			if ( !IsMaterialUsableOnEntities( obj.spawnname ) ) then
				str = "Try to use with Material Tool (Probably won't work)"
			end
			menu:AddOption( str, function()
				RunConsoleCommand( "material_override", obj.spawnname )
				spawnmenu.ActivateTool( "material" )
			end ):SetIcon( "icon16/pencil.png" )

			menu:AddSpacer()
			menu:AddOption( "#spawnmenu.menu.delete", function() icn:Remove() hook.Run( "SpawnlistContentChanged", icn ) end ):SetIcon( "icon16/bin_closed.png" )
		menu:Open()
	end

	if ( IsValid( container ) ) then
		container:Add( icon )
	end

	return icon

end )

local function OnMatNodeSelected( self, node, name, path, pathid, icon, ViewPanel, pnlContent )

	ViewPanel:Clear( true )

	local Path = node:GetFolder()

	local mat_files = file.Find( Path .. "/*.vmt", node:GetPathID() )
	mat_files = table.Add( mat_files, file.Find( Path .. "/*.png", node:GetPathID() ) )

	local offset = 0
	local limit = 512
	if ( node.offset ) then offset = node.offset or 0 end

	for k, v in pairs( mat_files ) do
		if ( k > limit + offset ) then
			if ( !node.Done ) then
				offset = offset + limit
				local mats = ( self.Parent or node ):AddNode( ( self.Text or node:GetText() ) .. " (" .. offset .. " - " .. offset + limit .. ")" )
				mats:SetFolder( node:GetFolder() )
				mats.Text = self.Text or node:GetText()
				mats.Parent = self.Parent or node
				mats:SetPathID( node:GetPathID() )
				mats:SetIcon( node:GetIcon() )
				mats.offset = offset
				mats.OnNodeSelected = function( self_mats, node_sel )
					OnMatNodeSelected( self_mats, node_sel, self_mats.Text, node_sel:GetFolder(), node_sel:GetPathID(), node_sel:GetIcon(), ViewPanel, pnlContent )
				end
			end
			node.Done = true
		break end
		if ( k <= offset ) then continue end

		local p = Path .. "/"
		if ( string.StartWith( path, "addons/" ) or string.StartWith( path, "download/" ) ) then
			p = string.sub( p, string.find( p, "/materials/" ) + 1 )
		end

		p = string.sub( p .. v, 11 )

		if ( string.GetExtensionFromFilename( p ) == "vmt" ) then
			p = string.StripExtension( p )
			v = string.StripExtension( v )
		end

		if ( Material( p ):GetShader() == "Spritecard" ) then continue end

		spawnmenu.CreateContentIcon( "material", ViewPanel, { spawnname = p, nicename = v } )
	end

	pnlContent:SwitchPanel( ViewPanel )

end

local function AddBrowseContentMaterial( node, name, icon, path, pathid )

	local ViewPanel = node.ViewPanel
	local pnlContent = node.pnlContent

	if ( !string.EndsWith( path, "/" ) && string.len( path ) > 1 ) then path = path .. "/" end

	local fi, fo = file.Find( path .. "materials", pathid )
	if ( !fi && !fo ) then return end

	local materials = node:AddFolder( name, path .. "materials", pathid, false, false, "*.*" )
	materials:SetIcon( icon )

	materials.OnNodeSelected = function( self, node_sel )
		OnMatNodeSelected( self, node_sel, name, path, pathid, icon, ViewPanel, pnlContent )
	end

end

language.Add( "spawnmenu.category.browsematerials", "Browse Materials" )

local function RefreshAddonMaterials( node )
	for _, addon in SortedPairsByMemberValue( engine.GetAddons(), "title" ) do

		if ( !addon.downloaded ) then continue end
		if ( !addon.mounted ) then continue end
		if ( !table.HasValue( select( 2, file.Find( "*", addon.title ) ), "materials" ) ) then continue end

		AddBrowseContentMaterial( node, addon.title, "icon16/bricks.png", "", addon.title )

	end
end
local function RefreshGameMaterials( node )
	local games = getGameList()

	for _, game in SortedPairsByMemberValue( games, "title" ) do
		if ( !game.mounted ) then continue end
		AddBrowseContentMaterial( node, game.title, "games/16/" .. ( game.icon or game.folder ) .. ".png", "", game.folder )
	end
end

local browseAddonMaterials
local browseGameMaterials
hook.Add( "PopulateContent", "SpawnmenuLoadSomeMaterials", function( pnlContent, tree, browseNode ) timer.Simple( 0.5, function()

	if ( !IsValid( tree ) or !IsValid( pnlContent ) ) then
		print( "!!! Extended Spawnmenu: FAILED TO INITALIZE PopulateContent HOOK FOR MATERIALS!!!" )
		print( "!!! Extended Spawnmenu: FAILED TO INITALIZE PopulateContent HOOK FOR MATERIALS!!!" )
		print( "!!! Extended Spawnmenu: FAILED TO INITALIZE PopulateContent HOOK FOR MATERIALS!!!" )
		return
	end

	local ViewPanel = vgui.Create( "ContentContainer", pnlContent )
	ViewPanel:SetVisible( false )

	local browseMaterials = tree:AddNode( "#spawnmenu.category.browsematerials", "icon16/picture_empty.png" )
	browseMaterials.ViewPanel = ViewPanel
	browseMaterials.pnlContent = pnlContent

	--[[ --------------------------------------------------------------------------------------- ]]

	browseAddonMaterials = browseMaterials:AddNode( "#spawnmenu.category.addons", "icon16/folder_database.png" )
	browseAddonMaterials.ViewPanel = ViewPanel
	browseAddonMaterials.pnlContent = pnlContent

	RefreshAddonMaterials( browseAddonMaterials )

	--[[ --------------------------------------------------------------------------------------- ]]

	local addon_mats = {}
	local _, mat_folders = file.Find( "addons/*", "MOD" )
	for _, addon in SortedPairs( mat_folders ) do

		if ( !file.IsDir( "addons/" .. addon .. "/materials/", "MOD" ) ) then continue end

		table.insert( addon_mats, addon )

	end

	local browseLegacyMaterials = browseMaterials:AddNode( "#spawnmenu.category.addonslegacy", "icon16/folder_database.png" )
	browseLegacyMaterials.ViewPanel = ViewPanel
	browseLegacyMaterials.pnlContent = pnlContent

	for _, addon in SortedPairsByValue( addon_mats ) do

		AddBrowseContentMaterial( browseLegacyMaterials, addon, "icon16/bricks.png", "addons/" .. addon .. "/", "MOD" )

	end

	--[[ --------------------------------------------------------------------------------------- ]]

	AddBrowseContentMaterial( browseMaterials, "#spawnmenu.category.downloads", "icon16/folder_database.png", "download/", "MOD" )

	--[[ --------------------------------------------------------------------------------------- ]]

	browseGameMaterials = browseMaterials:AddNode( "#spawnmenu.category.games", "icon16/folder_database.png" )
	browseGameMaterials.ViewPanel = ViewPanel
	browseGameMaterials.pnlContent = pnlContent

	RefreshGameMaterials( browseGameMaterials )

end ) end )

hook.Add( "GameContentChanged", "ES_RefreshSpawnmenuMaterials", function()

	if ( IsValid( browseAddonMaterials ) ) then

		-- TODO: Maybe be more advaced and do not delete => recreate all the nodes, only delete nodes for addons that were removed, add only the new ones?
		browseAddonMaterials:Clear()
		browseAddonMaterials.ViewPanel:Clear( true )

		RefreshAddonMaterials( browseAddonMaterials )

	end

	if ( IsValid( browseGameMaterials ) ) then

		-- TODO: Maybe be more advaced and do not delete => recreate all the nodes, only delete nodes for addons that were removed, add only the new ones?
		browseGameMaterials:Clear()
		browseGameMaterials.ViewPanel:Clear( true )

		RefreshGameMaterials( browseGameMaterials )

	end

end )

--[[ ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ ]]
--[[ ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ ]]
--[[ ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ ]]
--[[ ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ ]]
--[[ ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ ]]

hook.Add( "PopulateContent", "rb655_extended_spawnmenu_entities", function( pnlContent, tree, node )
	if ( !cl_addTabs:GetBool() ) then return end

	local node_w = tree:AddNode( "#spawnmenu.category.entities", "icon16/bricks.png" )

	node_w.PropPanel = vgui.Create( "ContentContainer", pnlContent )
	node_w.PropPanel:SetVisible( false )

	function node_w:DoClick()
		pnlContent:SwitchPanel( self.PropPanel )
	end

	local Categorised = {}

	local SpawnableEntities = list.Get( "SpawnableEntities" )
	if ( SpawnableEntities ) then
		for k, v in pairs( SpawnableEntities ) do
			v.Category = v.Category or "Other"
			Categorised[ v.Category ] = Categorised[ v.Category ] or {}
			table.insert( Categorised[ v.Category ], v )
		end
	end

	for CategoryName, v in SortedPairs( Categorised ) do

		local node_new = node_w:AddNode( CategoryName, "icon16/bricks.png" )

		local CatPropPanel = vgui.Create( "ContentContainer", pnlContent )
		CatPropPanel:SetVisible( false )

		local Header = vgui.Create("ContentHeader", node_w.PropPanel )
		Header:SetText( CategoryName )
		node_w.PropPanel:Add( Header )

		for k, ent in SortedPairsByMemberValue( v, "PrintName" ) do
			local t = {
				nicename	= ent.PrintName or ent.ClassName,
				spawnname	= ent.ClassName,
				material	= "entities/" .. ent.ClassName .. ".png",
				admin		= ent.AdminOnly
			}
			spawnmenu.CreateContentIcon( ent.ScriptedEntityType or "entity", CatPropPanel, t )
			spawnmenu.CreateContentIcon( ent.ScriptedEntityType or "entity", node_w.PropPanel, t )
		end

		function node_new:DoClick()
			pnlContent:SwitchPanel( CatPropPanel )
		end

	end
end )

hook.Add( "PopulateContent", "rb655_extended_spawnmenu_post_processing", function( pnlContent, tree, node )
	if ( !cl_addTabs:GetBool() ) then return end

	local node_w = tree:AddNode( "#spawnmenu.category.postprocess", "icon16/picture.png" )

	node_w.PropPanel = vgui.Create( "ContentContainer", pnlContent )
	node_w.PropPanel:SetVisible( false )

	function node_w:DoClick()
		pnlContent:SwitchPanel( self.PropPanel )
	end

	-- Get the table

	local Categorised = {}
	local PostProcess = list.Get( "PostProcess" )

	if ( PostProcess ) then
		for k, v in pairs( PostProcess ) do
			v.category = v.category or "Other"
			v.name = k
			Categorised[ v.category ] = Categorised[ v.category ] or {}
			table.insert( Categorised[ v.category ], v )
		end
	end

	-- Put table into panels
	for CategoryName, v in SortedPairs( Categorised ) do

		local node_new = node_w:AddNode( CategoryName, "icon16/picture.png" )

		local CatPropPanel = vgui.Create( "ContentContainer", pnlContent )
		CatPropPanel:SetVisible( false )

		local Header = vgui.Create( "ContentHeader", node_w.PropPanel )
		Header:SetText( CategoryName )
		node_w.PropPanel:Add( Header )

		for k, pp in SortedPairsByMemberValue( v, "PrintName" ) do
			if ( pp.func ) then pp.func( CatPropPanel ) pp.func( node_w.PropPanel ) continue end

			local t = {
				name = pp.name,
				icon = pp.icon
			}

			spawnmenu.CreateContentIcon( "postprocess", CatPropPanel, t )
			spawnmenu.CreateContentIcon( "postprocess", node_w.PropPanel, t )
		end

		function node_new:DoClick()
			pnlContent:SwitchPanel( CatPropPanel )
		end
	end

end )

hook.Add( "PopulateContent", "rb655_extended_spawnmenu_npcs", function( pnlContent, tree, node )
	if ( !cl_addTabs:GetBool() ) then return end

	local node_w = tree:AddNode( "#spawnmenu.category.npcs", "icon16/monkey.png" )

	node_w.PropPanel = vgui.Create( "ContentContainer", pnlContent )
	node_w.PropPanel:SetVisible( false )

	function node_w:DoClick()
		pnlContent:SwitchPanel( self.PropPanel )
	end

	local NPCList = list.Get( "NPC" )
	local Categories = {}

	for k, v in pairs( NPCList ) do
		local Category = v.Category or "Other"
		local Tab = Categories[ Category ] or {}

		Tab[ k ] = v

		Categories[ Category ] = Tab
	end

	for CategoryName, v in SortedPairs( Categories ) do

		local node_new = node_w:AddNode( CategoryName, "icon16/monkey.png" )

		local CatPropPanel = vgui.Create( "ContentContainer", pnlContent )
		CatPropPanel:SetVisible( false )

		local Header = vgui.Create("ContentHeader", node_w.PropPanel )
		Header:SetText( CategoryName )
		node_w.PropPanel:Add( Header )

		for name, ent in SortedPairsByMemberValue( v, "Name" ) do
			local t = {
				nicename	= ent.Name or name,
				spawnname	= name,
				material	= "entities/" .. name .. ".png",
				weapon		= ent.Weapons,
				admin		= ent.AdminOnly
			}
			spawnmenu.CreateContentIcon( "npc", CatPropPanel, t )
			spawnmenu.CreateContentIcon( "npc", node_w.PropPanel, t )
		end

		function node_new:DoClick()
			pnlContent:SwitchPanel( CatPropPanel )
		end

	end
end )

hook.Add( "PopulateContent", "rb655_extended_spawnmenu_vehicles", function( pnlContent, tree, node )
	if ( !cl_addTabs:GetBool() ) then return end

	local node_w = tree:AddNode( "#spawnmenu.category.vehicles", "icon16/car.png" )

	node_w.PropPanel = vgui.Create( "ContentContainer", pnlContent )
	node_w.PropPanel:SetVisible( false )

	function node_w:DoClick()
		pnlContent:SwitchPanel( self.PropPanel )
	end

	local Categorised = {}
	local Vehicles = list.Get( "Vehicles" )
	if ( Vehicles ) then
		for k, v in pairs( Vehicles ) do
			v.Category = v.Category or "Other"
			Categorised[ v.Category ] = Categorised[ v.Category ] or {}
			v.ClassName = k
			v.PrintName = v.Name
			v.ScriptedEntityType = "vehicle"
			table.insert( Categorised[ v.Category ], v )
		end
	end

	for CategoryName, v in SortedPairs( Categorised ) do

		local node_new = node_w:AddNode( CategoryName, "icon16/car.png" )

		local CatPropPanel = vgui.Create( "ContentContainer", pnlContent )
		CatPropPanel:SetVisible( false )

		local Header = vgui.Create("ContentHeader", node_w.PropPanel )
		Header:SetText( CategoryName )
		node_w.PropPanel:Add( Header )

		for k, ent in SortedPairsByMemberValue( v, "PrintName" ) do
			local t = {
				nicename	= ent.PrintName or ent.ClassName,
				spawnname	= ent.ClassName,
				material	= "entities/" .. ent.ClassName .. ".png",
				admin		= ent.AdminOnly
			}
			spawnmenu.CreateContentIcon( ent.ScriptedEntityType or "entity", node_w.PropPanel, t )
			spawnmenu.CreateContentIcon( ent.ScriptedEntityType or "entity", CatPropPanel, t )
		end

		function node_new:DoClick()
			pnlContent:SwitchPanel( CatPropPanel )
		end

	end

end )

hook.Add( "PopulateContent", "rb655_extended_spawnmenu_weapons", function( pnlContent, tree, node )
	if ( !cl_addTabs:GetBool() ) then return end

	local node_w = tree:AddNode( "#spawnmenu.category.weapons", "icon16/gun.png" )

	node_w.PropPanel = vgui.Create( "ContentContainer", pnlContent )
	node_w.PropPanel:SetVisible( false )

	function node_w:DoClick()
		pnlContent:SwitchPanel( self.PropPanel )
	end

	local Weapons = list.Get( "Weapon" )
	local Categorised = {}

	for k, weapon in pairs( Weapons ) do
		if ( !weapon.Spawnable && !weapon.AdminSpawnable ) then continue end

		Categorised[ weapon.Category ] = Categorised[ weapon.Category ] or {}
		table.insert( Categorised[ weapon.Category ], weapon )
	end

	for CategoryName, v in SortedPairs( Categorised ) do
		local node_new = node_w:AddNode( CategoryName, "icon16/gun.png" )

		local CatPropPanel = vgui.Create( "ContentContainer", pnlContent )
		CatPropPanel:SetVisible( false )

		local Header = vgui.Create("ContentHeader", node_w.PropPanel )
		Header:SetText( CategoryName )
		node_w.PropPanel:Add( Header )

		for k, ent in SortedPairsByMemberValue( v, "PrintName" ) do
			local t = {
				nicename	= ent.PrintName or ent.ClassName,
				spawnname	= ent.ClassName,
				material	= "entities/" .. ent.ClassName .. ".png",
				admin		= ent.AdminOnly
			}
			spawnmenu.CreateContentIcon( ent.ScriptedEntityType or "weapon", CatPropPanel, t )
			spawnmenu.CreateContentIcon( ent.ScriptedEntityType or "weapon", node_w.PropPanel, t )
		end

		function node_new:DoClick()
			pnlContent:SwitchPanel( CatPropPanel )
		end

	end

end )

--PATH lua/autorun/rd_claim_boards_init.lua:
return gluapack()()
--PATH lua/autorun/rd_claim_boards_init.lua:
hook.Add("Initialize", "RDV.CLAIMBOARDS.ProductInitialize", function()
    local VALID = RDV.LIBRARY.RegisterProduct("Claim Boards", {})

    if !VALID then return end

    RDV.CLAIMBOARDS = RDV.CLAIMBOARDS or {
        CFG = {
            CustomHeaders = true,
        },
    }
    local rootDir = "rd_claim_boards"

    local function AddFile(File, dir)
        local fileSide = string.lower(string.Left(File , 3))

        if SERVER and fileSide == "sv_" then
            include(dir..File)
        elseif fileSide == "sh_" then
            if SERVER then 
                AddCSLuaFile(dir..File)
            end
            include(dir..File)
        elseif fileSide == "cl_" then
            if SERVER then 
                AddCSLuaFile(dir..File)
            elseif CLIENT then
                include(dir..File)
            end
        end
    end

    local function IncludeDir(dir)
        dir = dir .. "/"
        local File, Directory = file.Find(dir.."*", "LUA")

        for k, v in ipairs(File) do
            if string.EndsWith(v, ".lua") then
                AddFile(v, dir)
            end
        end
        
        for k, v in ipairs(Directory) do
            IncludeDir(dir..v)
        end

    end
    IncludeDir(rootDir)

    if RDV.CLAIMBOARDS.GetBattalionCount() <= 0 and RPExtraTeams then
        if !RDV.CLAIMBOARDS.CORE.AddBattalion then return end

        local CFG = RDV.CLAIMBOARDS.CORE

        local CATS = {}

        for k, v in ipairs(RPExtraTeams) do
            CATS[v.category] = CATS[v.category] or {}

            table.insert(CATS[v.category], v.name)
        end

        for k, v in pairs(CATS) do
            CFG:AddBattalion(k, v)
        end
    end
end)
--PATH lua/reality_development/client/vgui/cl_dbutton_category.lua:
local COL_2 = Color(39,39,39,235)
local COL_3 = Color(36,36,36, 225)
local COL_4 = Color(68,131,171,255)

local PANEL = {
	Init = function(self)
        self.ACTIVE = false
        self.HOVERED = {}
        self.SELECTED = false

        local PARENT = self:GetParent()

        local w, h = PARENT:GetSize()

        self.SCROLL = vgui.Create("DScrollPanel", PARENT)
        self.SCROLL:Dock(LEFT)
        self.SCROLL:SetSize(w * 0.3, h)
        self.SCROLL:DockMargin(w * 0.02, h * 0.02, w * 0.02, h * 0.02)
        self.SCROLL.Paint = function(self, w, h)
            surface.SetDrawColor( RDV.LIBRARY.GetConfigOption("LIBRARY_outlineTheme") )
            surface.DrawOutlinedRect( 0, 0, w, h )
        end
    end,
    AddPage = function(self, title, icon, cb)
        self.PAGES = self.PAGES or {}

        local COL = RDV.LIBRARY.GetConfigOption("LIBRARY_outlineTheme")

        local BUTTON = self.SCROLL:Add("DButton")
        BUTTON:SetText("")
        
        local w, h = BUTTON:GetSize()
        BUTTON:Dock(TOP)
        BUTTON:SetHeight(h * 2)
        BUTTON:SetFont("RDV_LIB_FRAME_TITLE")
        BUTTON:SetText(title)
        BUTTON:SetTextColor(color_white)

        BUTTON.Paint = function(s, w, h)
            local S_W, S_H = s:GetSize()

            if ( self.ACTIVE == title ) or self.HOVERED[s] then
                COL = RDV.LIBRARY.GetConfigOption("LIBRARY_hoverTheme")
            else
                COL = RDV.LIBRARY.GetConfigOption("LIBRARY_outlineTheme")
            end

            surface.SetDrawColor(COL)

            surface.DrawOutlinedRect( 0, 0, w, h )


            if icon then
                RDV.LIBRARY.DrawImgur(w * 0.05, S_H * 0.173, (h / 1.5), (h / 1.5), icon, COL)
            end
        end

        BUTTON.DoClick = function(s)
            if self.SELECTED and self.SELECTED ~= s then
                if self.HOVERED[self.SELECTED] then
                    self.HOVERED[self.SELECTED] = false
                end

                self.SELECTED:SetTextColor(color_white)
            end

            self.SELECTED = s

            surface.PlaySound(RDV.LIBRARY.GetConfigOption("LIBRARY_clickSound"))

            self:SelectPage(title)
        end
        BUTTON.OnCursorEntered = function(s)
            surface.PlaySound(RDV.LIBRARY.GetConfigOption("LIBRARY_hoverSound"))

            s:SetTextColor(RDV.LIBRARY.GetConfigOption("LIBRARY_hoverTheme"))

            self.HOVERED[s] = true
        end
        BUTTON.OnCursorExited = function(s)
            if self.SELECTED == s then return end

            s:SetTextColor(color_white)

            self.HOVERED[s] = nil
        end

        self.PAGES[title] = {
            BUTTON = BUTTON,
            CALLBACK = cb,
        }
    end,
    GetPage = function(self)
        self.ACTIVE = self.ACTIVE or false

        return self.ACTIVE
    end,
    SelectPage = function(self, title)
        local TAB = self.PAGES[title]

        if TAB then
            if TAB.CALLBACK then
                TAB:CALLBACK()
            end

            self.ACTIVE = title
        end
    end,
}

vgui.Register( "RDV_LIBRARY_SIDEBAR", PANEL )
--PATH lua/reality_development/client/vgui/cl_imgur.lua:
return gluapack()()
--PATH lua/reality_development/client/vgui/cl_imgur.lua:
local PANEL = {}

AccessorFunc(PANEL, "ImgurID", "ImgurID", FORCE_STRING)
AccessorFunc(PANEL, "ImageSize", "ImageSize", FORCE_NUMBER)
AccessorFunc(PANEL, "NormalColor", "NormalColor")
AccessorFunc(PANEL, "HoverColor", "HoverColor")
AccessorFunc(PANEL, "ClickColor", "ClickColor")
AccessorFunc(PANEL, "DisabledColor", "DisabledColor")

function PANEL:Init()
    self:SetText("")
    self.ImageCol = color_white
    self:SetImgurID("635PPvg")

    self:SetNormalColor(color_white)
    self:SetHoverColor(color_white)
    self:SetClickColor(color_white)
    self:SetDisabledColor(color_white)

    self:SetImageSize(1)
end

function PANEL:PaintBackground(w, h) end

function PANEL:Paint(w, h)
    self:PaintBackground(w, h)

    local imageSize = w * 0.125 + (h * 0.1) * self:GetImageSize()
    local imageOffsetW = (w - imageSize) / 2
    local imageOffset = (h - imageSize) / 2

    if not self:IsEnabled() then
        RDV.LIBRARY.DrawImgur(imageOffsetW, imageOffset, imageSize, imageSize, self:GetImgurID(), self:GetDisabledColor())
        return
    end

    local col = self:GetNormalColor()

    if self:IsHovered() then
        col = self:GetHoverColor()
    end

    if self:IsDown() or self:GetToggle() then
        col = self:GetClickColor()
    end

    RDV.LIBRARY.DrawImgur(imageOffsetW, imageOffset, imageSize, imageSize, self:GetImgurID(), col)
end

vgui.Register("RDV_LIBRARY_IMGUR", PANEL, "DButton")



--PATH lua/reality_development/client/vgui/cl_nframe.lua:
return gluapack()()
--PATH lua/reality_development/functions/cl_overhead.lua:
local SOVERHEADS = {}
local OVERHEADS = {}

function RDV.LIBRARY.EditOverhead(ent, line, newval)
    if !OVERHEADS[ent] then return end

    local KEY = OVERHEADS[ent]
    local TAB = SOVERHEADS[KEY]

    if !TAB or !TAB.Lines or !TAB.Lines[line] then return end

    -- Improve Later
    local w, h = 0, 0

    for k, v in ipairs(TAB.Lines) do
        if !v.Font then table.remove(TAB.Lines, k) continue end
        if !v.Text then table.remove(TAB.Lines, k) continue end

        surface.SetFont( v.Font )

        local nw, nh = surface.GetTextSize( v.Text )

        h = (h + nh)

        if nw > w then
            w = nw
        end
    end

    TAB.w, TAB.h = (w + 20), (h + 5)
    --

    TAB.Lines[line] = newval
end

function RDV.LIBRARY.AddOverhead(ent, data)
    if !istable(data) or !data.Lines then return end
    if !data.Accent then data.Accent = Color(255,255,255) end
    if !data.Position then data.Position = true end

    if OVERHEADS[ent] then
        table.remove(SOVERHEADS, OVERHEADS[ent])
    end

    data.ENTITY = ent

    local w, h = 0, 0

    for k, v in ipairs(data.Lines) do
        if !v.Font then table.remove(data.Lines, k) continue end
        if !v.Text then table.remove(data.Lines, k) continue end

        surface.SetFont( v.Font )

        local nw, nh = surface.GetTextSize( v.Text )

        h = (h + nh)

        if nw > w then
            w = nw
        end
    end

    data.w, data.h = (w + 20), (h + 5)

    local KEY = table.insert(SOVERHEADS, data)

    OVERHEADS[ent] = KEY
end

local COL_1 = Color(0,0,0,180)
local COL_2 = Color(255,255,255)

hook.Add("PostDrawTranslucentRenderables", "RDV.LIBRARY.AddOverhead", function()
    for k, v in ipairs(SOVERHEADS) do
        local ENTITY = v.ENTITY

        if !IsValid(ENTITY) then table.remove(SOVERHEADS, k) continue end 

        if !v.Distance or !isnumber(v.Distance) then
            v.Distance = 20000
        end

        if ( ENTITY:GetPos():DistToSqr(LocalPlayer():GetPos()) > v.Distance ) then
            continue
        end
        
        local CENTER = ENTITY:OBBCenter()

        local w, h = (v.w or 0), (v.h or 0)

        local POS = v.Position

        if ( v.Position == true ) then
            local physBone = ENTITY:LookupBone("ValveBiped.Bip01_Head1") 
            local bone_pos
        
            if (physBone) then
                bone_pos = ENTITY:GetBonePosition(physBone) 
            end
        
            if (bone_pos) then
                POS = bone_pos + Vector(0, 0, 15) 
            else
                POS = ENTITY:LocalToWorld(Vector(CENTER.x, CENTER.y, ENTITY:OBBMaxs().z)) + Vector(0, 0, 10)
            end
        elseif isnumber(v.Position) then
            POS = ENTITY:GetPos() + Vector(0, 0, v.Position)
        end

        if !isvector(POS) then return end
        
        local ANG = Angle(0, Angle(0, (LocalPlayer():GetPos() - ENTITY:GetPos()):Angle().y + 90, 90).y, 90)

        cam.Start3D2D(POS, ANG, 0.1)
            draw.RoundedBox(0, -( w / 2 ), 0, w, h, COL_1)
            draw.RoundedBox(0, -( w / 2), h - (h / 12), w, (h / 12), v.Accent)

            for a, b in ipairs(v.Lines) do
                draw.SimpleText(b.Text, b.Font, 0, (a * 30) - 30, ( b.Color or COL_2 ), TEXT_ALIGN_CENTER)
            end
        cam.End3D2D()
    end
end )
--PATH lua/reality_development/functions/sid64_finder/sh_main.lua:
return gluapack()()
--PATH lua/reality_development/libs/characters/list/sh_voidchar.lua:
return gluapack()()
--PATH lua/reality_development/libs/language/sh_lang.lua:
return gluapack()()
--PATH lua/reality_development/libs/language/sh_lang.lua:
local LANG = {}

local function RegisterLang(NEW)
    if LANG[NEW] then return end

    local LIST = {}

    for k, v in pairs(LANG) do
        table.insert(LIST, k)
    end

    table.insert(LIST, NEW)

    RDV.LIBRARY.AddConfigOption("LIB_langSet", {
        TYPE = RDV.LIBRARY.TYPE.SE,
        LIST = LIST,
        NAME = "Language",
        CATEGORY = "Library",
        DESCRIPTION = "Primary Language",
        DEFAULT = "en",
        SECTION = "Language",
    })
end

function RDV.LIBRARY.AddLang(lang, note)
    RegisterLang(lang)

    LANG[lang] = LANG[lang] or {}

    for k, v in pairs(note) do 
        LANG[lang][k] = v
    end
end

function RDV.LIBRARY.GetLang(lang, note, replacements)
    if !lang then
        lang = RDV.LIBRARY.GetConfigOption("LIB_langSet")
    end
    
    if !LANG[lang] then
        if LANG["en"] then
            lang = "en"
        else
            return note
        end
    end

    if !LANG[lang][note] then
        return note
    else
        note = LANG[lang][note]
    end

    if replacements and istable(replacements) then
        note = note:format(unpack(replacements))
    end

    return (note or "NOT FOUND")
end
--PATH addons/[admin] sam-160/lua/sam/libs/sh_promises.lua:
if SAM_LOADED then return end
-- not real promises, just really simple one

local isfunction = sam and sam.isfunction or isfunction

local null = {}

local Promise = {}

local PromiseMethods = {}
local Promise_meta = {__index = PromiseMethods}

function Promise.new()
	return setmetatable({
		value = null,
		null = null
	}, Promise_meta)
end

function Promise.IsPromise(v)
	return getmetatable(v) == Promise_meta
end

function PromiseMethods:resolve(v)
	if self.value ~= null then return end
	if self.done_callback then
		self.done_callback(v)
	else
		self.value = v
		self.callback = 0
	end
end

function PromiseMethods:reject(v)
	if self.value ~= null then return end
	if self.catch_callback then
		self.catch_callback(v)
	else
		self.value = v
		self.callback = 1
	end
end

function PromiseMethods:done(func)
	if isfunction(func) then
		if self.value ~= null and self.callback == 0 then
			func(self.value)
		else
			self.done_callback = func
		end
	end
	return self
end

function PromiseMethods:catch(func)
	if isfunction(func) then
		if self.value ~= null and self.callback == 1 then
			func(self.value)
		else
			self.catch_callback = func
		end
	end
	return self
end

return Promise
--PATH addons/[admin] sam-160/lua/sam/sh_colors.lua:
return gluapack()()
--PATH addons/[admin] sam-160/lua/sam/sh_colors.lua:
if SAM_LOADED then return end

local colors = {
	Red   = Color(244, 67, 54),
	Blue  = Color(13, 130, 223),
	Green = Color(0, 230, 64),
	White = Color(236, 240, 241),
	Black = Color(10, 10, 10)
}

function sam.get_color(name)
	return colors[name]
end

function sam.add_color(name, color)
	if isstring(name) and IsColor(color) then
		colors[name] = color
	end
end
--PATH addons/[admin] sam-160/lua/sam/sh_lang.lua:
return gluapack()()
--PATH addons/[admin] sam-160/lua/sam/ranks/sh_ranks.lua:
return gluapack()()
--PATH addons/[admin] sam-160/lua/sam/player/sh_nw_vars.lua:
return gluapack()()
--PATH addons/[admin] sam-160/lua/sam/command/arguments/player.lua:
if SAM_LOADED then return end

local sam, command = sam, sam.command

local can_target_player = function(arg, admin, target, cmd, input)
	if not IsValid(target) or not target:IsPlayer() or not target:sam_get_nwvar("is_authed") then
		if input then
			admin:sam_send_message("cant_find_target", {
				S = input
			})
		end
		return false
	end

	if not arg.allow_higher_target and not admin:CanTarget(target) then
		if cmd then
			admin:sam_send_message("cant_target_player", {
				S = target:Name()
			})
		end
		return false
	end

	if arg.cant_target_self and admin == target then
		if cmd then
			admin:sam_send_message("cant_target_self", {
				S = cmd.name
			})
		end
		return false
	end

	return true
end

local check_text_match = function(text, ply)
	if ply:Name():lower():find(text, 1, true) then return true end
	if ply:GetUserGroup():lower():find(text, 1, true) then return true end
	if team.GetName(ply:Team()):lower():find(text, 1, true) then return true end

	if not ply:IsBot() then
		return ply:SteamID():lower():find(text, 1, true) or ply:SteamID64():lower():find(text, 1, true)
	end

	return false
end

command.new_argument("player")
	:OnExecute(function(arg, input, ply, cmd, result, n)
		if input == nil and arg.optional then
			if sam.isconsole(ply) then
				ply:sam_send_message("cant_target_self", {
					S = cmd.name
				})
				return false
			end
			result[n] = {ply, admin = ply, input = input}
			return
		end

		local single_target = arg.single_target
		local targets = {admin = ply, input = input}

		if input == "*" then
			if single_target then
				ply:sam_send_message("cant_target_multi_players")
				return false
			end
			local players = player.GetAll()
			for i = 1, #players do
				local v = players[i]
				if can_target_player(arg, ply, v) then
					table.insert(targets, v)
				end
			end
		elseif input:sub(1, 1) == "#" and not single_target then
			local tmp = {}
			for _, v in ipairs(input:sub(2):Trim():Split(",")) do
				v = tonumber(v)
				if not sam.isnumber(v) then continue end
				local target = Entity(v)
				if not tmp[target] and IsValid(target) and target:IsPlayer() then
					tmp[target] = true
					if can_target_player(arg, ply, target) then
						table.insert(targets, target)
					end
				end
			end
		else
			local target
			if input == "^" then
				target = ply
			elseif input == "@" and not sam.isconsole(ply) then
				target = ply:GetEyeTrace().Entity
			elseif sam.is_steamid(input) then
				target = player.GetBySteamID(input)
			elseif sam.is_steamid64(input) then
				target = player.GetBySteamID64(input)
			elseif input:sub(1, 1) == "#" then
				local index = input:sub(2):Trim()
				index = tonumber(index)

				if not isnumber(index) then
					ply:sam_send_message("invalid_id", {
						S = input
					})
					return false
				end

				target = Entity(index)

				if not IsValid(target) or not target:IsPlayer() then
					ply:sam_send_message("player_id_not_found", {
						S = index
					})
					return false
				end
			else
				if input:sub(1, 1) == "%" and #input > 1 then
					input = input:sub(2)
				end

				target = sam.player.find_by_name(input)
				if sam.istable(target) then
					if single_target then
						ply:sam_send_message("found_multi_players", {T = target})
						return false
					else
						for k, v in ipairs(target) do
							if can_target_player(arg, ply, v) then
								table.insert(targets, v)
							end
						end
						goto _end
					end
				end
			end

			if not can_target_player(arg, ply, target, cmd, input) then
				return false
			end

			table.insert(targets, target)
		end

		::_end::

		if #targets == 0 then
			ply:sam_send_message("cant_find_target", {
				S = input
			})
			return false
		end
		result[n] = targets
	end)

	-- Do NOT ask me about this code at all please because I feel shit about it but I'm not gonna make
	-- a file specially for this one
	:Menu(function(set_result, body, buttons, argument, childs)
		if body.ply_list then
			local ply_list = body.ply_list
			ply_list.argument = argument
			ply_list.set_result = set_result
			ply_list.multi_select = argument.single_target ~= true

			if argument.single_target == true and #ply_list:GetSelected() > 1 then
				ply_list:ClearSelection()
			end

			ply_list:OnRowSelected()
			ply_list:GetParent():Show()

			return
		end

		local SUI = sam.SUI

		local SetVisible = FindMetaTable("Panel").SetVisible

		local left_body = body:Add("SAM.Panel")
		left_body:Dock(LEFT)
		left_body:DockMargin(0, 0, 5, 0)
		left_body:SetWide(0)
		left_body.no_remove = true
		left_body.no_change = "player"

		SetVisible(left_body, false)
		left_body.SetVisible = function(s, visible)
			if visible == s:IsVisible() or visible == s.visible_state then return end

			if visible then
				SetVisible(s, true)
				s:InvalidateLayout(true)
			end

			s.visible_state = visible
			s:Stop()

			s:SizeTo(visible and SUI.Scale(320) or 0, -1, 0.2, 0, 0, function()
				SetVisible(s, visible)
				s:InvalidateParent(true)
			end)
		end
		left_body:Show()

		table.insert(childs, left_body)

		local ply_list = left_body:Add("SAM.ScrollPanel")
		ply_list:Dock(FILL)
		ply_list:Background(Color(34, 34, 34), 3)
		ply_list.argument = argument
		ply_list.set_result = set_result
		ply_list.multi_select = argument.single_target ~= true
		ply_list.Paint = function(s, w, h)
			s:RoundedBox("Background", 3, 0, 0, w, h, SUI.GetColor("text_entry_bg"))
		end

		local lines = {}
		function ply_list:OnClickLine(line, clear)
			local multi_select = ply_list.multi_select
			if not multi_select and not clear then return end

			if multi_select and input.IsKeyDown(KEY_LCONTROL) then
				if line.Selected then
					line.Selected = false
					self.main_selected_line = nil
					self:OnRowSelected()
					return
				end
				clear = false
			end

			if multi_select and input.IsKeyDown(KEY_LSHIFT) then
				local selected = self:GetSelectedLine()
				if selected then
					self.main_selected_line = self.main_selected_line or selected

					if clear then
						self:ClearSelection()
					end

					local first = math.min(self.main_selected_line.id, line.id)
					local last = math.max(self.main_selected_line.id, line.id)

					for id = first, last do
						local line_2 = lines[id]
						local was_selected = line_2.Selected

						line_2.Selected = true

						if not was_selected then
							self:OnRowSelected(line_2.id, line_2)
						end
					end

					return
				end
			end

			if not multi_select or clear then
				self:ClearSelection()
			end

			line.Selected = true

			self.main_selected_line = line
			self:OnRowSelected(line.id, line)
		end

		function ply_list:GetSelected()
			local ret = {}
			for _, v in ipairs(lines) do
				if v.Selected then
					table.insert(ret, v)
				end
			end
			return ret
		end

		function ply_list:GetSelectedLine()
			for _, line in ipairs(lines) do
				if line.Selected then return line end
			end
		end

		function ply_list:ClearSelection()
			for _, line in ipairs(lines) do
				line.Selected = false
			end
			self:OnRowSelected()
		end

		function ply_list:OnRowSelected()
			local plys = {}
			for k, v in ipairs(ply_list:GetSelected()) do
				plys[k] = v.ply:EntIndex()
			end
			if #plys == 0 then
				self.set_result(nil)
			else
				self.set_result("#" .. table.concat(plys, ","))
			end
		end

		function ply_list:OnRowRightClick(_, line)
			local dmenu = vgui.Create("SAM.Menu")
			dmenu:SetInternal(line)

			local name = line.ply:Name()
			dmenu:AddOption("Copy Name", function()
				SetClipboardText(name)
			end)

			dmenu:AddSpacer()

			local steamid = line.ply:SteamID()
			dmenu:AddOption("Copy SteamID", function()
				SetClipboardText(steamid)
			end)

			dmenu:AddOption("Copy SteamID64", function()
				SetClipboardText(util.SteamIDTo64(steamid))
			end)

			dmenu:Open()
			dmenu:SetPos(input.GetCursorPos())
		end

		local item_click = function(s)
			ply_list:OnClickLine(s, true)
		end

		local item_rightclick = function(s)
			if not s.Selected then
				ply_list:OnClickLine(s, true)
			end
			ply_list:OnRowRightClick(s.id, s)
		end

		local item_cursor = function(s)
			if input.IsMouseDown(MOUSE_LEFT) then
				ply_list:OnClickLine(s)
			end
		end

		local added_players = {}

		local add_player = function(ply, i)
			if can_target_player(ply_list.argument, LocalPlayer(), ply) then
				local player_button = ply_list:Add("SAM.Button")
				player_button:Dock(TOP)
				player_button:DockMargin(0, 0, 0, 2)
				player_button:DockPadding(4, 4, 4, 4)
				player_button:SetContained(false)
				player_button:SetText("")
				player_button:SetZPos(i)
				player_button.DoClick = item_click
				player_button.DoRightClick = item_rightclick
				player_button.OnCursorMoved = item_cursor

				local line = player_button:Add("SAM.PlayerLine")
				line:SetMouseInputEnabled(false)
				line:SetInfo({
					steamid = ply:IsBot() and "BOT" or ply:SteamID(),
					name = ply:Name(),
					rank = ply:GetUserGroup()
				})

				player_button:InvalidateLayout(true)
				player_button:SizeToChildren(false, true)

				player_button.ply = ply
				player_button.line = line
				player_button.id = table.insert(lines, player_button)
				body.search_entry:OnValueChange()

				added_players[ply] = true
			end
		end

		ply_list:On("Think", function()
			local players = player.GetAll()
			for i = 1, #players do
				local ply = players[i]
				if not added_players[ply] then
					add_player(ply, i)
				end
			end

			local argument = ply_list.argument
			for i = 1, #lines do
				local line = lines[i]
				local ply = line.ply

				if not can_target_player(argument, LocalPlayer(), ply) then
					line:Remove()
					table.remove(lines, i)
					added_players[ply] = nil
					ply_list:OnRowSelected()
					break
				end

				line = line.line
				line:SetName(ply:Name())
				line:SetRank(ply:GetUserGroup())
			end
		end)

		local search_entry = left_body:Add("SAM.TextEntry")
		search_entry:Dock(TOP)
		search_entry:DockMargin(0, 0, 0, 5)
		search_entry:SetPlaceholder("Search... (name/steamid/rank/job)")
		search_entry:SetBackground(Color(34, 34, 34))
		search_entry:SetTall(25)
		search_entry:SetNoBar(true)

		function search_entry:OnValueChange(text)
			if text == nil then
				text = self:GetValue()
			end
			if text ~= "" then
				ply_list:ClearSelection()
			end
			text = text:lower()
			for i, line in ipairs(lines) do
				local ply = line.ply
				if IsValid(ply) then
					line:SetVisible(check_text_match(text, ply))
				end
			end
			ply_list:GetCanvas():InvalidateLayout(true)
		end

		body.ply_list = ply_list
		body.search_entry = search_entry
	end)

	:AutoComplete(function(arg, result, name)
		local ply = LocalPlayer()
		for k, v in ipairs(player.GetAll()) do
			if can_target_player(arg, ply, v) and v:Name():lower():find(name, 1, true) then
				table.insert(result, "%" .. v:Name())
			end
		end
	end)
:End()

--PATH addons/[admin] sam-160/lua/sam/menu/sh_init.lua:
if SAM_LOADED then return end

require("sui")

sam.command.new("menu")
	:Help("Open admin mod menu")
	:MenuHide()
	:DisableNotify()
	:OnExecute(function(ply)
		sam.netstream.Start(ply, "OpenMenu")
	end)
:End()

if CLIENT then
	sam.netstream.Hook("OpenMenu", function()
		sam.menu.open_menu()
	end)
end

if SERVER then
	for _, f in ipairs(file.Find("sam/menu/tabs/*.lua", "LUA")) do
		sam.load_file("sam/menu/tabs/" .. f)
	end
end
--PATH addons/[lib] sui/lua/sui/libs/tdlib/cl_tdlib.lua:
return gluapack()()
--PATH addons/[lib] sui/lua/sui/vgui/sui_combobox.lua:
local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name

local TEXT_FONT = SUI.CreateFont("ComboBox", "Roboto Regular", 16)

local GetColor = SUI.GetColor
local draw_material = sui.draw_material

local PANEL = {}

PANEL.NoOverrideClear = true

sui.scaling_functions(PANEL)

function PANEL:Init()
	self:ScaleInit()
	self.DropButton:Remove()
	self:SetFont(TEXT_FONT)
	self:SetSize(34, 22)
	self:SetIsMenu(true)

	local image = self:Add(NAME .. ".Image")
	image:Dock(FILL)
	image:SetImage("https://raw.githubusercontent.com/Srlion/Addons-Data/main/icons/sui/arrow.png")
	image.Draw = self.Paint
end

function PANEL:OpenMenu(pControlOpener)
	if pControlOpener and pControlOpener == self.TextEntry then return end
	if #self.Choices == 0 then return end

	if IsValid(self.Menu) then
		self.Menu:Remove()
		self.Menu = nil
	end

	self.Menu = vgui.Create(NAME .. ".Menu", self)
	self.Menu:SetInternal(self)

	for k, v in ipairs(self.Choices) do
		self.Menu:AddOption(v, function()
			self:ChooseOption(v, k)
		end)
	end

	local x, y = self:LocalToScreen(0, self:GetTall())
	self.Menu:SetMinimumWidth(self:GetWide())
	self.Menu:Open(x, y, false, self)
end

function PANEL:Paint(w, h, from_image)
	local text_color = GetColor("menu_option_hover_text")

	if from_image then
		local size = SUI.ScaleEven(10)
		draw_material(nil, w - (size / 2) - 6, h / 2, size, text_color)
	else
		local col = GetColor("menu")
		self:RoundedBox("Background", 4, 0, 0, w, h, col)
		self:SetTextColor(text_color)
	end
end

function PANEL:PerformLayout()
end

sui.register("ComboBox", PANEL, "DComboBox")
--PATH addons/[lib] sui/lua/sui/vgui/sui_label_panel.lua:
return gluapack()()
--PATH addons/[lib] sui/lua/sui/vgui/sui_panel.lua:
local PANEL = {}

sui.scaling_functions(PANEL)

function PANEL:Init()
	self:ScaleInit()
end

sui.register("Panel", PANEL, "Panel")
--PATH addons/[lib] sui/lua/sui/vgui/sui_query_box.lua:
return gluapack()()
--PATH addons/[lib] sui/lua/sui/vgui/sui_query_box.lua:
local ScrW, ScrH = ScrW, ScrH
local DisableClipping = DisableClipping
local SetDrawColor = surface.SetDrawColor
local DrawRect = surface.DrawRect
local BlurPanel = sui.TDLib.BlurPanel
local lerp_color = sui.lerp_color

local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name

local GetColor = SUI.GetColor

local PANEL = {}

function PANEL:SetCallback(callback)
	self.callback = callback
end

function PANEL:Init()
	self:SetSize(0, 0)

	local bottom = self:Add("Panel")
	bottom:Dock(BOTTOM)
	bottom:DockMargin(4, 10, 4, 4)
	bottom:SetZPos(100)

	local save = bottom:Add(NAME .. ".Button")
	save:SetText("SAVE")
	save:Dock(RIGHT)
	save:SetEnabled(false)
	self.save = save

	function save.DoClick()
		self.callback()
		self:Remove()
	end

	local cancel = bottom:Add(NAME .. ".Button")
	cancel:Dock(RIGHT)
	cancel:DockMargin(0, 0, 4, 0)
	cancel:SetContained(false)
	cancel:SetColors(GetColor("query_box_cancel"), GetColor("query_box_cancel_text"))
	cancel:SetText("CANCEL")
	self.cancel = cancel

	function cancel.DoClick()
		self:Remove()
	end

	bottom:SetSize(save:GetWide() * 2 + 4, SUI.Scale(30))

	local body = self:Add("Panel")
	body:Dock(FILL)
	body:DockMargin(4, 4, 4, 4)
	body:DockPadding(3, 3, 3, 3)
	body:InvalidateLayout(true)
	body:InvalidateParent(true)

	local added = 1
	function body.OnChildAdded(s, child)
		added = added + 1
		child:Dock(TOP)
		child:SetZPos(added)
		child:InvalidateLayout(true)
		s:InvalidateLayout(true)
	end
	self.body = body

	function self:Add(name)
		return body:Add(name)
	end

	local old_Paint = self.Paint
	local trans = Color(0, 0, 0, 0)
	local new_col = Color(70, 70, 70, 100)
	function self:Paint(w, h)
		lerp_color(trans, new_col)

		local x, y = self:LocalToScreen(0, 0)
		DisableClipping(true)
			BlurPanel(self)
			SetDrawColor(trans)
			DrawRect(x * -1, y * -1, ScrW(), ScrH())
		DisableClipping(false)

		old_Paint(self, w, h)
	end
end

function PANEL:ChildrenHeight()
	local body = self.body

	self.header:InvalidateLayout(true)
	local height = self.header:GetTall()

	body:InvalidateLayout(true)
	self:InvalidateLayout(true)
	height = height + select(2, body:ChildrenSize())

	height = height + SUI.Scale(30) + 14 + 6

	return height
end

function PANEL:Paint(w, h)
	if GetColor("frame_blur") then
		BlurPanel(self)
	end

	self:RoundedBox("Background", 8, 0, 0, w, h, GetColor("query_box_bg"))
end

function PANEL:Done()
	self:InvalidateChildren(true)

	self.size_to_children = function()
		local h = self:ChildrenHeight()
		self:RealSetSize(self:GetWide(), h)
		self.real_h = h
	end

	self:Center()
	self:MakePopup()
	self:DoModal(true)

	timer.Simple(0.08, function()
		self:AddAnimations(self:GetWide(), self:ChildrenHeight(), true)
	end)
end

sui.register("QueryBox", PANEL, NAME .. ".Frame")
--PATH addons/[admin] sam-160/lua/sam/menu/tabs/commands.lua:
return gluapack()()
--PATH addons/[admin] sam-160/lua/sam/modules/murder.lua:
if SAM_LOADED then return end

local add = not GAMEMODE and hook.Add or function(_, _, fn)
	fn()
end

-- Thanks to https://github.com/boxama/addons/blob/master/addons/ULX_Murder/lua/ulx/modules/sh/murder.lua
add("PostGamemodeLoaded", "SAM.Murder", function()
	if GAMEMODE.Author ~= "MechanicalMind" then return end
	if not isstring(GAMEMODE.Version) or GAMEMODE.Version < "28" then return end

	local sam, command = sam, sam.command

	command.set_category("Murder")

	local autoslain_players = {}

	command.new("slaynr")
		:SetPermission("slaynr", "admin")

		:AddArg("player")
		:AddArg("number", {hint = "rounds", optional = true, default = 1, min = 1, max = 100, round = true})

		:Help("Slays the target(s) at the beggining of the next round.")

		:OnExecute(function(ply, targets, rounds)
			for i = 1, #targets do
				local v = targets[i]
				v.MurdererChance = 0

				if not v:IsBot() then
					autoslain_players[v:AccountID()] = rounds
				end
			end

			sam.player.send_message(nil, "{A} set {T} to be autoslain for {V} round(s)", {
				A = ply, T = targets, V = rounds
			})
		end)
	:End()

	command.new("unslaynr")
		:SetPermission("unslaynr", "admin")

		:AddArg("player")

		:Help("Remove target(s) autoslays.")

		:OnExecute(function(ply, targets)
			for i = 1, #targets do
				local v = targets[i]
				v.MurdererChance = 1

				if not v:IsBot() then
					autoslain_players[v:AccountID()] = nil
				end
			end

			sam.player.send_message(nil, "Removed all autoslays for {T} ", {
				A = ply, T = targets
			})
		end)
	:End()

	hook.Add("OnStartRound", "SAM.Murder", function()
		timer.Simple(3, function()
			local players = team.GetPlayers(2)
			local targets = {admin = sam.console}
			for i = 1, #players do
				local v = players[i]
				if not v:IsBot() then continue end

				local slays = autoslain_players[v:AccountID()]
				if not slays then continue end

				v:Kill()

				slays = slays - 1

				targets[1] = v
				sam.player.send_message(nil, "{A} autoslayed {T}, autoslays left: {V}.", {
					A = sam.console, T = targets, V = slays
				})

				autoslain_players[v:AccountID()] = slays > 0 and slays or nil
			end
		end)
	end)

	hook.Add("PlayerInitialSpawn", "SAM.Murder", function(ply)
		if autoslain_players[ply:AccountID()] then
			ply.MurdererChance = 0
		end
	end)

	command.new("respawn")
		:SetPermission("respawn", "admin")

		:AddArg("player", {single_target = true})

		:Help("Respawn a target.")

		:OnExecute(function(ply, targets)
			local target = targets[1]

			if target:Team() ~= 2 then
				return ply:sam_add_text("You cannot respawn a spectator!")
			end

			target:Spectate(OBS_MODE_NONE)
			target:Spawn()

			sam.player.send_message(nil, "respawn", {
				A = ply, T = targets
			})
		end)
	:End()

	local get_admins = function()
		local admins = {}

		local players = player.GetHumans()
		for i = 1, #players do
			local v = players[i]
			if v:IsAdmin() then
				table.insert(admins, v)
			end
		end

		return admins
	end

	command.new("givemagnum")
		:SetPermission("givemagnum", "superadmin")

		:AddArg("player", {single_target = true, optional = true})

		:Help("Give the target a magnum.")

		:OnExecute(function(ply, targets)
			local target = targets[1]

			if target:Team() ~= 2 then
				return ply:sam_add_text("You cannot give spectator a magnum!")
			end

			target:Give("weapon_mu_magnum")

			sam.player.send_message(get_admins(), "{A} gave {T} a {V}", {
				A = ply, T = targets, V = "magnum"
			})
		end)
	:End()

	command.new("giveknife")
		:SetPermission("giveknife", "superadmin")

		:AddArg("player", {single_target = true, optional = true})

		:Help("Give the target a knife.")

		:OnExecute(function(ply, targets)
			local target = targets[1]

			if target:Team() ~= 2 then
				return ply:sam_add_text("You cannot give spectator a knife!")
			end

			target:Give("weapon_mu_knife")

			sam.player.send_message(get_admins(), "{A} gave {T} a {V}", {
				A = ply, T = targets, V = "knife"
			})
		end)
	:End()

	command.new("forcemurderer")
		:SetPermission("forcemurderer", "admin")

		:AddArg("player", {single_target = true, optional = true})

		:Help("Force the target to me a murderer next round.")

		:OnExecute(function(ply, targets)
			GAMEMODE.ForceNextMurderer = targets[1]

			sam.player.send_message(get_admins(), "{A} set {T} to be the Murderer next round!", {
				A = ply, T = targets
			})
		end)
	:End()

	command.new("getmurderers")
		:SetPermission("getmurderers", "admin")

		:Help("Print all murderers in chat.")

		:OnExecute(function(ply)
			local murderers = {admin = ply}

			local players = team.GetPlayers(2)
			for i = 1, #players do
				local v = players[i]
				if v:GetMurderer() then
					table.insert(murderers, v)
				end
			end

			sam.player.send_message(ply, "Murderers are: {T}", {
				T = murderers
			})
		end)
	:End()
end)
--PATH addons/[admin] sam-160/lua/sam/modules/sh_reserved_slots.lua:
return gluapack()()
--PATH addons/[admin] sam-160/lua/sam/modules/utime.lua:
if SAM_LOADED then return end

local PLAYER = FindMetaTable("Player")

function PLAYER:GetUTime()
	return self:sam_get_nwvar("TotalUTime")
end

function PLAYER:SetUTime(time)
	self:sam_set_nwvar("TotalUTime", time)
end

function PLAYER:GetUTimeStart()
	return self:sam_get_nwvar("UTimeStart")
end

function PLAYER:SetUTimeStart(time)
	self:sam_set_nwvar("UTimeStart", time)
end

function PLAYER:GetUTimeSessionTime()
	return CurTime() - self:GetUTimeStart()
end

function PLAYER:GetUTimeTotalTime()
	return self:GetUTime() + CurTime() - self:GetUTimeStart()
end

if SERVER then
	hook.Add("SAM.AuthedPlayer", "SAM.UTime", function(ply)
		ply:SetUTime(ply:sam_get_play_time())
		ply:SetUTimeStart(CurTime())
	end)
end
--PATH addons/[lib] sui/lua/sui/libs/gif_loader.lua:
local byte = string.byte
local sub = string.sub
local lshift = bit.lshift
local rshift = bit.rshift
local bor = bit.bor
local band = bit.band

local GIFDecoder = {}
local GIFDecoderMethods = {}
local GIFDecoder_meta = {__index = GIFDecoderMethods}

function GIFDecoder.new(buf)
	local buf_n = #buf
	local this = setmetatable({
		p = 1,
		buf = buf
	}, GIFDecoder_meta)

	local version = this:read(6)
	assert(version == "GIF89a" or version == "GIF87a", "wrong file format")

	this.width = this:word()
	this.height = this:word()

	local pf0 = this:byte()
	local global_palette_flag = rshift(pf0, 7)
	local num_global_colors_pow2 = band(pf0, 0x7)
	local num_global_colors = lshift(1, num_global_colors_pow2 + 1)
	this:skip(2)

	local global_palette_offset = nil
	local global_palette_size = nil

	if global_palette_flag > 0 then
		global_palette_offset = this.p
		this.global_palette_offset = global_palette_offset
		global_palette_size = num_global_colors
		this:skip(num_global_colors * 3)
	end

	local no_eof = true

	local frames = {}

	local delay = 0
	local transparent_index = nil
	local disposal = 1

	while no_eof and this.p <= buf_n do
		local b = this:byte()
		if b == 0x3b then
			no_eof = false
		elseif b == 0x2c then
			local x, y, w, h = this:word(), this:word(), this:word(), this:word()
			local pf2 = this:byte()
			local local_palette_flag = rshift(pf2, 7)
			local interlace_flag = band(rshift(pf2, 6), 1)
			local num_local_colors_pow2 = band(pf2, 0x7)
			local num_local_colors = lshift(1, num_local_colors_pow2 + 1)
			local palette_offset = global_palette_offset
			local palette_size = global_palette_size
			local has_local_palette = false
			if local_palette_flag ~= 0 then
				has_local_palette = true
				palette_offset = this.p
				palette_size = num_local_colors
				this:skip(num_local_colors * 3)
			end

			local data_offset = this.p

			this:skip(1)
			this:skip_eob()

			table.insert(frames, {
				x = x,
				y = y,
				width = w,
				height = h,
				has_local_palette = has_local_palette,
				palette_offset = palette_offset,
				palette_size = palette_size,
				data_offset = data_offset,
				data_length = this.p - data_offset,
				transparent_index = transparent_index,
				interlaced = interlace_flag > 0,
				delay = delay,
				disposal = disposal
			})
		elseif b == 0x21 then
			local b2 = this:byte()
			if b2 == 0xf9 then
				local len, flags = this:bytes(2)
				delay = this:word()
				local transparent, terminator = this:bytes(2)

				assert(len == 4 and terminator == 0, "Invalid graphics extension block.")

				if flags % 2 == 1 then
					transparent_index = transparent
				else
					transparent_index = nil
				end

				disposal = math.floor(flags / 4) % 8
			elseif b2 == 0xff then
				this:read(this:byte())
				this:skip_eob()
			else
				this:skip_eob()
			end
		end
	end

	this.frames = frames

	return this
end

function GIFDecoderMethods:skip(offset)
	self.p = self.p + offset
end

-- skip to end of block
function GIFDecoderMethods:skip_eob()
	repeat
		local size = self:byte()
		self:skip(size)
	until size == 0
end

function GIFDecoderMethods:byte()
	local b = byte(self.buf, self.p)
	self:skip(1)
	return b
end

function GIFDecoderMethods:bytes(len)
	local _p = self.p
	self:skip(len)
	return byte(self.buf, _p, len + _p - 1)
end

function GIFDecoderMethods:read(len)
	local _p = self.p
	self:skip(len)
	return sub(self.buf, _p, len + _p - 1)
end

function GIFDecoderMethods:word()
	return bor(self:byte(), lshift(self:byte(), 8))
end

local GifReaderLZWOutputIndexStream = function(this, output, output_length)
	local min_code_size = this:byte()
	local clear_code = lshift(1, min_code_size)
	local eoi_code = clear_code + 1
	local next_code = eoi_code + 1
	local cur_code_size = min_code_size + 1

	local code_mask = lshift(1, cur_code_size) - 1
	local cur_shift = 0
	local cur = 0
	local op = 0

	local subblock_size = this:byte()

	local code_table = {}

	local prev_code = nil

	while true do
		while cur_shift < 16 do
			if subblock_size == 0 then break end

			cur = bor(cur, lshift(this:byte(), cur_shift))
			cur_shift = cur_shift + 8

			if subblock_size == 1 then
				subblock_size = this:byte()
			else
				subblock_size = subblock_size - 1
			end
		end

		if cur_shift < cur_code_size then break end

		local code = band(cur, code_mask)
		cur = rshift(cur, cur_code_size)
		cur_shift = cur_shift - cur_code_size

		if code == clear_code then
			next_code = eoi_code + 1
			cur_code_size = min_code_size + 1
			code_mask = lshift(1, cur_code_size) - 1

			prev_code = null
			continue
		elseif code == eoi_code then
			break
		end

		local chase_code = code < next_code and code or prev_code
		local chase_length = 0
		local chase = chase_code
		while chase > clear_code do
			chase = rshift(code_table[chase], 8)
			chase_length = chase_length + 1
		end

		local k = chase
		local op_end = op + chase_length + (chase_code ~= code and 1 or 0)
		if op_end > output_length then
			Error("Warning, gif stream longer than expected.")
			return
		end

		output[op] = k; op = op + 1
		op = op + chase_length

		local b = op

		if chase_code ~= code then
			output[op] = k; op = op + 1
		end
		chase = chase_code

		while chase_length > 0 do
			chase_length = chase_length - 1
			chase = code_table[chase]
			b = b - 1
			output[b] = band(chase, 0xff)

			chase = rshift(chase, 8)
		end

		if prev_code ~= nil and next_code < 4096 then
			code_table[next_code] = bor(lshift(prev_code, 8), k)
			next_code = next_code + 1

			if next_code >= code_mask + 1 and cur_code_size < 12 then
				cur_code_size = cur_code_size + 1
				code_mask = bor(lshift(code_mask, 1), 1)
			end
		end

		prev_code = code
	end

	if op ~= output_length then
		Error("Warning, gif stream shorter than expected.")
	end

	return output
end

function GIFDecoderMethods:decode_and_blit_frame_RGBA(frame_num, pixels)
	local frame = self.frames[frame_num]
	local num_pixels = frame.width * frame.height
	local index_stream = {}

	self.p = frame.data_offset
	GifReaderLZWOutputIndexStream(self, index_stream, num_pixels)
	local palette_offset = frame.palette_offset

	local trans = frame.transparent_index
	if trans == nil then
		trans = 256
	end

	local width = self.width
	local framewidth = frame.width
	local framestride = width - framewidth
	local xleft = framewidth

	local opbeg = (frame.y * width + frame.x) * 4

	local opend = ((frame.y + frame.height) * width + frame.x) * 4
	local op = opbeg
	local scanstride = framestride * 4

	if frame.interlaced == true then
		scanstride = scanstride + (width * 4 * 7)
	end

	local interlaceskip = 8

	local i = 0
	local buf = self.buf
	while i < num_pixels do
		local index = index_stream[i]

		if xleft == 0 then
			op = op + scanstride
			xleft = framewidth

			if op >= opend then
				scanstride =
					framestride * 4 + width * 4 * (interlaceskip - 1)

				op =
					opbeg +
					(framewidth + framestride) * lshift(interlaceskip, 1)
				interlaceskip = rshift(interlaceskip, 1)
			end
		end

		if index ~= trans then
			index = palette_offset + index * 3
			pixels[op + 0] = byte(buf, index)
			pixels[op + 1] = byte(buf, index + 1)
			pixels[op + 2] = byte(buf, index + 2)
			pixels[op + 3] = 255
		end

		op = op + 4

		xleft = xleft - 1
		i = i + 1
	end
end

function GIFDecoderMethods:clear_frame(frame_num, pixels)
	local frame = self.frames[frame_num]

	self.p = frame.data_offset

	local width = self.width
	local framewidth = frame.width
	local framestride = width - framewidth
	local xleft = framewidth

	local opbeg = (frame.y * width + frame.x) * 4

	local opend = ((frame.y + frame.height) * width + frame.x) * 4
	local op = opbeg
	local scanstride = framestride * 4

	if frame.interlaced == true then
		scanstride = scanstride + (width * 4 * 7)
	end

	local interlaceskip = 8

	local i = 0
	local num_pixels = frame.width * frame.height
	while i < num_pixels do
		if xleft == 0 then
			op = op + scanstride
			xleft = framewidth

			if op >= opend then
				scanstride =
					framestride * 4 + width * 4 * (interlaceskip - 1)

				op =
					opbeg +
					(framewidth + framestride) * lshift(interlaceskip, 1)
				interlaceskip = rshift(interlaceskip, 1)
			end
		end

		pixels[op + 0] = 0
		pixels[op + 1] = 0
		pixels[op + 2] = 0
		pixels[op + 3] = 0
		op = op + 4

		xleft = xleft - 1
		i = i + 1
	end
end

function GIFDecoderMethods:get_frames()
	local num_pixels = self.width * self.height * 4 + 4
	local frames = {}
	local numFrames = #self.frames
	local last_frame
	local restore_from
	for i = 1, numFrames do
		local frame = self.frames[i]

		local data = {}

		if last_frame then
			local _data = last_frame.data
			for k = 0, num_pixels do
				data[k] = _data[k]
			end
		end

		if i > 1 then
			local last_disposal = last_frame.disposal
			if last_disposal == 3 then
				if restore_from then
					for k = 0, num_pixels do
						data[k] = restore_from[k]
					end
				else
					self:clear_frame(i - 1, data)
				end
			end

			if last_disposal == 2 then
				self:clear_frame(i - 1, data)
			end
		end

		self:decode_and_blit_frame_RGBA(i, data)

		local delay = frame.delay
		if delay < 2 then
			delay = 10
		end

		local disposal = frame.disposal
		last_frame = {
			data = data,
			delay = delay,
			disposal = disposal
		}
		frames[i] = last_frame

		if disposal ~= 3 then
			restore_from = data
		end
	end

	return frames
end

return GIFDecoder.new
--PATH addons/[lib] sui/lua/sui/vgui/sui_label.lua:
return gluapack()()
--PATH addons/[lib] sui/lua/sui/vgui/sui_label_panel.lua:
local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name

local LABEL_FONT = SUI.CreateFont("LabelPanel", "Roboto", 18)

local PANEL = {}

local add = function(s, c)
	if IsValid(s.pnl) then
		s.pnl:Remove()
	end

	local pnl = vgui.Create(c, s)
	s.pnl = pnl

	return pnl
end

function PANEL:Init()
	self.title = ""

	local label = self:Add(NAME .. ".Label")
	label:Dock(LEFT)
	self.label = label

	self:SetFont(LABEL_FONT)

	self:Dock(TOP)
	self:InvalidateLayout(true)
	self.Add = add
end

function PANEL:SetPanel(pnl)
	if IsValid(self.pnl) then
		self.pnl:Remove()
	end

	pnl:SetParent(self)
	self.pnl = pnl
end

function PANEL:SetLabel(lbl)
	self.title = lbl
	self:InvalidateLayout(true)
end

function PANEL:SetFont(font)
	self.font = font
	self.label:SetFont(font)
end

function PANEL:PerformLayout(w, h)
	local label = self.label
	local pnl = self.pnl

	local pnl_w, pnl_h = 0, 0
	if pnl then
		pnl_w, pnl_h = pnl:GetSize()
	end

	label:SetWide(w - pnl_w - 4)
	label:SetText(sui.wrap_text(self.title, self.font, w - pnl_w - 4))

	local _, _h = label:GetTextSize()
	self:SetTall(math.max(_h, pnl_h))

	if pnl then
		pnl:SetPos(w - pnl_w, h / 2 - pnl_h / 2)
	end
end

sui.register("LabelPanel", PANEL, "PANEL")
--PATH addons/[lib] sui/lua/sui/vgui/sui_query_box.lua:
return gluapack()()
--PATH addons/[lib] sui/lua/sui/vgui/sui_text_entry.lua:
local sui = sui

local surface = surface
local utf8 = sui.utf8
local draw = draw
local math = math

local IsValid = IsValid
local tostring = tostring
local tonumber = tonumber

local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name

local GetColor = SUI.GetColor
local TEXT_ENTRY_FONT = SUI.CreateFont("TextEntry", "Roboto Regular", 16)

local Panel = {}

sui.scaling_functions(Panel)

AccessorFunc(Panel, "m_FontName", "Font", FORCE_STRING)
AccessorFunc(Panel, "m_Editable", "Editable", FORCE_BOOL)
AccessorFunc(Panel, "m_Placeholder", "Placeholder", FORCE_STRING)
AccessorFunc(Panel, "m_MaxChars", "MaxChars", FORCE_NUMBER)
AccessorFunc(Panel, "m_Numeric", "Numeric", FORCE_BOOL)
AccessorFunc(Panel, "m_NoBar", "NoBar", FORCE_BOOL)
AccessorFunc(Panel, "m_BarColor", "BarColor")
AccessorFunc(Panel, "m_Background", "Background")
AccessorFunc(Panel, "m_Radius", "Radius")
AccessorFunc(Panel, "m_NoEnter", "NoEnter")

Panel:SetRadius(3)

function Panel:Init()
	self:ScaleInit()

	self:SetupTransition("TextEntryReady", 0.9, function()
		return self:IsEditing() or self:GetBarColor() ~= nil
	end)

	self:SetUpdateOnType(true)
	self:SetCursor("beam")
	self:SetFont(TEXT_ENTRY_FONT)
	self:SetPlaceholder("Placeholder text")

	self:SetSize(200, 22)

	self.allowed_numeric_characters = "1234567890.-"

	self.history = {}
	self.history_pos = 1
	self.can_use_history = true

	self:OnScaleChange()
end

function Panel:SetCaretPos(pos)
	DTextEntry.SetCaretPos(self, math.Clamp(pos, 0, utf8.len(self:GetText())))
end

function Panel:SetValue(value)
	self:SetText(value)
	self:OnValueChange(value)
end

function Panel:AllowInput(ch)
	if self:CheckNumeric(ch) then return true end

	if sui.wspace_chs[ch] or sui.cntrl_chs[ch] then
		return true
	end

	local max_chars = self:GetMaxChars()
	if max_chars and #self:GetText() >= max_chars then
		surface.PlaySound("resource/warning.wav")
		return true
	end
end

function Panel:AddValue(v, i, j)
	local original_text = self:GetText()

	local start
	if i then
		start = original_text:sub(1, i)
	else
		start = utf8.sub(original_text, 1, self:GetCaretPos())
	end

	local text = start .. v
	local caret_pos = utf8.len(text)

	local _end
	if j then
		_end = original_text:sub(j)
	else
		_end = utf8.sub(original_text, utf8.len(start) + 1)
	end
	text = text .. _end

	local max_chars = self:GetMaxChars()
	if max_chars then
		text = text:sub(1, max_chars)
	end

	self:SetValue(text)
	self:SetCaretPos(caret_pos)
end

function Panel:OnKeyCodeTyped(code)
	if self.no_down then
		self.no_down = nil
		return
	end

	if code == KEY_UP or code == KEY_DOWN then
		if not self:UpdateFromHistory(code) then
			return true
		end

		local lines, caret_line = self:GetNumLines()

		if lines == 1 then
			return true
		end

		--
		-- this fixes a weird issue
		-- make the text entry has at least 2 lines, go up then go down, you won't be able to go up again
		--
		if code == KEY_DOWN and lines == caret_line + 1 then
			self.no_down = true
			gui.InternalKeyCodeTyped(KEY_DOWN)
		end
	end

	self:OnKeyCode(code)

	if code == KEY_ENTER then
		if IsValid(self.Menu) then
			self.Menu:Remove()
		end

		if not self:GetNoEnter() then
			self:FocusNext()
			self:OnEnter()
		end
	end
end

function Panel:DisallowFloats(disallow)
	if not isbool(disallow) then
		disallow = true
	end

	if disallow then
		self.allowed_numeric_characters = self.allowed_numeric_characters:gsub("%.", "", 1)
	elseif not self.allowed_numeric_characters:find(".", 1, true) then
		self.allowed_numeric_characters = self.allowed_numeric_characters .. "."
	end
end

function Panel:DisallowNegative(disallow)
	if not isbool(disallow) then
		disallow = true
	end

	if disallow then
		self.allowed_numeric_characters = self.allowed_numeric_characters:gsub("%-", "", 1)
	elseif not self.allowed_numeric_characters:find("-", 1, true) then
		self.allowed_numeric_characters = self.allowed_numeric_characters .. "-"
	end
end

function Panel:CheckNumeric(value)
	if not self:GetNumeric() then return false end

	if not self.allowed_numeric_characters:find(value, 1, true) then
		return true
	end

	local new_value = ""
	local current_value = tostring(self:GetText())

	local caret_pos = self:GetCaretPos()
	for i = 0, #current_value do
		new_value = new_value .. current_value:sub(i, i)
		if i == caret_pos then
			new_value = new_value .. value
		end
	end

	if #current_value ~= 0 and not tonumber(new_value) then
		return true
	end

	return false
end

function Panel:AddHistory(txt)
	if not txt or txt == "" then return end
	local history = self.history
	if history[#history] ~= txt then
		table.insert(history, txt)
	end
end

function Panel:UpdateFromHistory(code)
	if not self.can_use_history then return end

	local lines, caret_line = self:GetNumLines()

	if code == KEY_UP then
		if caret_line > 1 then return true end -- enable the caret to move up and down

		if self.history_pos <= 1 then return end

		self.history_pos = self.history_pos - 1
	elseif code == KEY_DOWN then
		if caret_line ~= lines then return true end

		if self.history_pos >= #self.history then
			self:SetValue("")
			self:SetCaretPos(0)
			self.history_pos = #self.history + 1
			return
		end

		self.history_pos = self.history_pos + 1
	end

	local text = self.history[self.history_pos]
	if not text then return end

	self:SetValue(text)
	self:SetCaretPos(utf8.len(text))
end

function Panel:OnTextChanged()
	self.history_pos = #self.history + 1

	local text = self:GetText()

	self.can_use_history = text == "" and true or false

	if self:GetUpdateOnType() then
		self:UpdateConvarValue()
		self:OnValueChange(text)
	end

	self:OnChange()
end

function Panel:OnScaleChange()
	self:InvalidateLayout()
	self:InvalidateLayout(true)
end

function Panel:Paint(w, h)
	self:RoundedBox("Background", self:GetRadius(), 0, 0, w, h, GetColor("text_entry_bg") or self:GetBackground())

	local text_entry_3 = GetColor("text_entry_3")

	if self:GetText() == "" then
		local old_text = self:GetText()
		self:SetText(self:GetPlaceholder())
		self:DrawTextEntryText(GetColor("text_entry_2"), text_entry_3, text_entry_3)
		self:SetText(old_text)
	else
		self:DrawTextEntryText(GetColor("text_entry"), text_entry_3, text_entry_3)
	end

	if not self:GetNoBar() then
		local bar_color = self:GetBarColor()

		self:RoundedBox("Bar1", 0, 0, h - 1, w, 1, GetColor("text_entry_bar_color"))

		local bar = math.Round(w * self.TextEntryReady)
		if bar > 0 then
			self:RoundedBox("Bar2", 0, (w / 2) - (bar / 2), h - 1, bar, 1, bar_color or text_entry_3)
		end
	end
end

-- https://github.com/ValveSoftware/source-sdk-2013/blob/0d8dceea4310fde5706b3ce1c70609d72a38efdf/mp/src/vgui2/vgui_controls/TextEntry.cpp#L969
function Panel:GetNumLines(wide)
	local num_lines = 1

	wide = wide or self:GetWide() - 2

	local char_width
	local x = 3

	local word_start_index = 1
	local word_start_len
	local word_length = 0
	local has_word = false
	local just_started_new_line = true
	local word_started_on_new_line = true

	local start_char = 1

	surface.SetFont(self:GetFont())

	local i = start_char
	local text, n = utf8.force(self:GetText())
	local caret_line = 0
	local caret_pos = self:GetCaretPos()
	local caret_i = 1
	while i <= n do
		local ch_len = utf8.char_bytes(text:byte(i))
		local ch = text:sub(i, i + ch_len - 1)

		if ch ~= " " then
			if not has_word then
				word_start_index = i
				word_start_len = ch_len
				has_word = true
				word_started_on_new_line = just_started_new_line
				word_length = 0
			end
		else
			has_word = false
		end

		char_width = surface.GetTextSize(ch)
		just_started_new_line = false

		if (x + char_width) >= wide then
			x = 3

			just_started_new_line = true
			has_word = false

			if word_started_on_new_line then
				num_lines = num_lines + 1
			else
				num_lines = num_lines + 1
				i = (word_start_index + word_start_len) - ch_len
			end

			word_length = 0
		end

		x = x + char_width
		word_length = word_length + char_width

		if caret_i == caret_pos then
			caret_line = num_lines
		end

		i = i + ch_len
		caret_i = caret_i + 1
	end

	return num_lines, caret_line
end

function Panel:SetCheck(func, col)
	function self:OnValueChange(text)
		if func(text) == false then
			self.valid = false
			self:SetBarColor(GetColor("close_hover"))
			self:SetNoEnter(true)
		else
			self.valid = true
			self:SetBarColor(col)
			self:SetNoEnter(false)
		end
	end
	self:SetValue(self:GetText())
end

sui.register("TextEntry", Panel, "DTextEntry")

--PATH addons/[chat] scb-29/lua/scb/settings/cl_settings.lua:
return gluapack()()
--PATH addons/[chat] scb-29/lua/scb/settings/tabs/tags.lua:
if SCB_LOADED then return end

local scb = scb
local SUI = scb.SUI
local language = scb.language

scb.tags = scb.tags or {}

net.Receive("SCB.SendTags", function()
	local tags = net.ReadData(net.ReadUInt(17))
	tags = util.Decompress(tags)
	scb.tags = scb.mp.unpack(tags)
end)

net.Receive("SCB.AddTag", function()
	local key = net.ReadString()
	local tag = net.ReadString()
	scb.tags[key] = tag

	local old = net.ReadString()

	if old ~= "" then
		scb.tags[old] = nil
	end

	hook.Call("SCB.TagsModified")
end)

net.Receive("SCB.RemoveTag", function()
	scb.tags[net.ReadString()] = nil
	hook.Call("SCB.TagsModified")
end)

local tags_menu = function(title, key, key_tag)
	key = key or ""

	local options = sui.valid_options()

	local querybox = vgui.Create("SCB.QueryBox")
	querybox:SetTitle(title)
	querybox:SetWide(300)

	local name = querybox:Add("SCB.TextEntry")
	name:Dock(TOP)
	name:SetPlaceholder(language.tag_owner)
	name:SetValue(key)

	name:SetCheck(function(_name)
		if _name == "" or (scb.tags[_name] and key ~= _name) then
			return false
		end
	end)

	options.Add(name)

	local tag = querybox:Add("SCB.TextEntry")
	tag:Dock(TOP)
	tag:DockMargin(0, 4, 0, 0)
	tag:SetPlaceholder(language.tag)
	tag:SetValue(key_tag or "")

	tag:SetCheck(function(_tag)
		return _tag ~= ""
	end)

	options.Add(tag)

	local preview = querybox:Add("SCB.ChatLine")
	preview:DockMargin(0, 6, 0, 0)
	preview.x = 3
	preview.emoji_size = 18

	preview:ScaleChanged()
	preview:Parse(tag:GetValue())
	preview:SetMouseInputEnabled(false)

	tag:On("OnValueChange", function(s, v)
		preview.added = {}
		preview:ScaleChanged()
		preview:Parse(v)
		querybox:size_to_children()
	end)

	querybox:SetCallback(function()
		net.Start("SCB.AddTag")
			net.WriteString(name:GetText())
			net.WriteString(tag:GetText())
			net.WriteString(name:GetText() ~= key and key or "")
		net.SendToServer()
	end)

	querybox:Done()
	querybox.save:SetEnabled(true)

	function querybox.save:Think()
		self:SetEnabled(options.IsValid())
	end
end

return {
	title = language.tags_title,
	pos = 2,
	func = function(parent)
		local body = parent:Add("Panel")
		body:Dock(FILL)
		body:DockMargin(0, 1, 0, 0)
		body:InvalidateParent(true)

		SUI.OnScaleChanged(body, function()
			body:Remove()
		end)

		local tags_list = body:Add("SCB.ThreeGrid")
		tags_list:Dock(FILL)
		tags_list:InvalidateLayout(true)
		tags_list:InvalidateParent(true)

		tags_list:SetColumns(2)
		tags_list:SetHorizontalMargin(2)
		tags_list:SetVerticalMargin(2)

		local load_tags = function()
			tags_list:Clear()

			for key, tag in SortedPairs(scb.tags) do
				local pnl = vgui.Create("DButton")
				pnl:SetText("")
				pnl:SetTall(SUI.Scale(560))
				pnl:SUI_TDLib()
					:ClearPaint()
					:FadeHover()

				function pnl:DoClick()
					tags_menu(language.edit .. " '" .. key .. "'", key, tag)
				end

				function pnl:DoRightClick()
					local d_menu = DermaMenu()

					d_menu:AddOption(language.remove, function()
						net.Start("SCB.RemoveTag")
							net.WriteString(key)
						net.SendToServer()
					end)

					d_menu:Open()
					d_menu:MakePopup()

					function pnl:OnRemove()
						d_menu:Remove()
					end
				end
				tags_list:AddCell(pnl)

				local name = pnl:Add("SCB.Label")
				name:Dock(TOP)
				name:SetFont(SCB_16)
				name:SetText(key)
				name:SetTextInset(3, 0)
				name:SetExpensiveShadow(1, color_black)
				name:SizeToContentsY(3)

				local _tag = pnl:Add("SCB.ChatLine")
				_tag:DockMargin(3, 0, 0, 0)
				_tag:SetFont(SCB_16)

				_tag.emoji_size = 16
				_tag:Parse(tag)
				_tag:SetMouseInputEnabled(false)

				pnl:SizeToChildren(false, true)
			end

			for k, v in ipairs(tags_list.Rows) do
				tags_list:CalculateRowHeight(v)
			end
		end
		load_tags()

		hook.Add("SCB.TagsModified", tags_list, load_tags)

		local add = body:Add("SCB.Button")
		add:Dock(BOTTOM)
		add:DockMargin(0, 4, 0, 0)
		add:SetText(language.add_tag:upper())

		add:On("DoClick", function()
			tags_menu(language.add_tag)
		end)

		return body
	end
}
--PATH lua/arc9/common/localization/base_en.lua:
L = {}

/////////////////////////////////////// Font
////////////////////// See "font_en" file

/////////////////////////////////////// General
////////////////////// Units of measurement
L["unit.second"] = "s"
L["unit.meter"] = "m"
L["unit.millimeter"] = "mm"
L["unit.meterpersecond"] = "m/s"
L["unit.hammerunit"] = "HU"
L["unit.decibel"] = "dB"
L["unit.rpm"] = "RPM"
L["unit.moa"] = "MOA"
L["unit.dmg"] = "DMG"
L["unit.projectiles"] = "PROJ"

L["unit.inch"] = "in"
L["unit.foot"] = "ft"
L["unit.footpersecond"] = "ft/s"
L["unit.yard"] = "yd"

////////////////////// Ammo types
L["ammo.pistol"] = "Pistol Ammo"
L["ammo.357"] = "Magnum Ammo"
L["ammo.smg1"] = "Carbine Ammo"
L["ammo.ar2"] = "Rifle Ammo"
L["ammo.buckshot"] = "Shotgun Ammo"
L["ammo.sniperpenetratedround"] = "Sniper Ammo"
L["ammo.smg1_grenade"] = "Rifle Grenades"
L["ammo.xbowbolt"] = "Crossbow Bolts"
L["ammo.rpg_round"] = "Rockets"
L["ammo.grenade"] = "Grenades"
L["ammo.slam"] = "SLAM"
L["ammo.alyxgun"] = "Alyx's Gun Ammo"

/////////////////////////////////////// HUD
L["hud.version"] = "ARCTIC SYSTEMS HUD v"
L["hud.jammed"] = "JAMMED!"
L["hud.therm_deco"] = "BARREL TEMP"

L["hud.firemode.single"] = "SINGLE"
L["hud.firemode.burst"] = "BURST"
L["hud.firemode.auto"] = "AUTO"
L["hud.firemode.safe"] = "SAFE"

L["hud.hint.bash"] = "Bash"
L["hud.hint.bipod"] = "Toggle Bipod"
L["hud.hint.breath"] = "Hold Breath"
L["hud.hint.customize"] = "Customize"
L["hud.hint.cycle"] = "Cycle"
L["hud.hint.firemode"] = "Switch Firemode"
L["hud.hint.inspect"] = "Inspect"
L["hud.hint.lean"] = "Lean"
L["hud.hint.peek"] = "Peek"
L["hud.hint.reload"] = "Reload"
L["hud.hint.safe"] = "Toggle Safe"
L["hud.hint.switchsights"] = "Switch Sights"
L["hud.hint.toggleatts"] = "Toggle Attachments"
L["hud.hint.ubgl"] = "Toggle"
L["hud.hint.unjam"] = "Unjam"
L["hud.hint.zoom"] = "Change Zoom"
L["hud.hint.quicknade"] = "Quickthrow "

L["hud.hint.lowammo"] = "Low Ammo"
L["hud.hint.noammo"] = "No Ammo"

L["hud.error.missingbind"] = "No button bound to %s"
L["hud.error.missingbind_zoom"] = "Bind \"Suit Zoom\" in settings!"
L["hud.error.missingbind_context"] = "Bind \"Open Context Menu\" in settings!"

/////////////////////////////////////// Customization menu
L["customize.panel.customize"] = "CUSTOMIZE"
L["customize.panel.personalize"] = "PERSONALIZE"
L["customize.panel.stats"] = "STATS & BALLISTICS"
L["customize.panel.trivia"] = "TRIVIA"
L["customize.panel.inspect"] = "INSPECT"
L["customize.panel.presets"] = "Presets"

L["customize.stats.aimtime"] = "Aim Time"
L["customize.stats.ammo"] = "Ammo Type"
L["customize.stats.armorpiercing"] = "Armor Piercing"
L["customize.stats.burstdelay"] = "Burst Delay"
L["customize.stats.capacity"] = "Capacity"
L["customize.stats.cyclic"] = "Cyclic ROF"
L["customize.stats.explosive"] = "Explosive Damage"
L["customize.stats.firemodes"] = "Fire Modes"
L["customize.stats.firepower"] = "Firepower"
L["customize.stats.freeaim"] = "Free Aim Radius"
L["customize.stats.muzzlevelocity"] = "Muzzle Velocity"
L["customize.stats.noise"] = "Noise"
L["customize.stats.penetration"] = "Penetration"
L["customize.stats.precision"] = "Precision"
L["customize.stats.range"] = "Range"
L["customize.stats.ricochet"] = "Ricochet Chance"
L["customize.stats.rof"] = "ROF"
L["customize.stats.speed"] = "Movement Speed"
L["customize.stats.sprinttofire"] = "Sprint to Fire Time"
L["customize.stats.supplylimit"] = "Supply Limit"
L["customize.stats.sway"] = "Sway"
L["customize.stats.triggerdelay"] = "Trigger Delay"

L["customize.hint.attach"] = "Attach"
L["customize.hint.controller"] = "Controller Mode is on."
L["customize.hint.cursor"] = "Cursor"
L["customize.hint.cycle"] = "Cycle Slot"
L["customize.hint.delete"] = "Delete"
L["customize.hint.deselect"] = "Deselect"
L["customize.hint.expand"] = "Expand"
L["customize.hint.export"] = "Export"
L["customize.hint.favorite"] = "Favorite"
L["customize.hint.import"] = "Import"
L["customize.hint.install"] = "Install"
L["customize.hint.last"] = "Last Slot"
L["customize.hint.lastmode"] = "Last Mode"
L["customize.hint.nextmode"] = "Next Mode"
L["customize.hint.open"] = "Open"
L["customize.hint.pan"] = "Pan"
L["customize.hint.quicksave"] = "Quicksave"
L["customize.hint.randomize"] = "Attach Random"
L["customize.hint.recalculate"] = "Recalculate"
L["customize.hint.recenter"] = "Recenter"
L["customize.hint.rotate"] = "Rotate"
L["customize.hint.save"] = "Save"
L["customize.hint.select"] = "Select"
L["customize.hint.unattach"] = "Unattach"
L["customize.hint.unfavorite"] = "Remove Favorite"
L["customize.hint.zoom"] = "Zoom"

L["customize.trivia.description"] = "Description"

L["customize.stats.explain.firepower"] = "The damage potential at point-blank range."
L["customize.stats.explain.rof"] = "The weapon's rate of fire."
L["customize.stats.explain.cyclic"] = "The weapon's cyclic rate of fire. Ignores factors like burst delay or reload requirements."
L["customize.stats.explain.capacity"] = "How much ammo the gun can hold in the magazine + chamber."
L["customize.stats.explain.range"] = "The range at which the gun deals minimum damage."
L["customize.stats.explain.precision"] = "The weapon's accuracy. Measured in Minutes of Accuracy (MOA)."
L["customize.stats.explain.muzzlevelocity"] = "The muzzle velocity of bullets fired from this gun."
L["customize.stats.explain.ammo"] = "The type of ammo this gun uses."
L["customize.stats.explain.penetration"] = "Amount of material this gun can penetrate."
L["customize.stats.explain.ricochet"] = "Maximum chance for bullets from this gun to ricochet."
L["customize.stats.explain.armorpiercing"] = "Amount of damage from this gun that completely ignores most damage resistances."
L["customize.stats.explain.explosive"] = "Amount of explosive damage this gun will do."
L["customize.stats.explain.speed"] = "Speed at which you can move while using this gun."
L["customize.stats.explain.aimtime"] = "How long it takes to aim down sights from hip fire."
L["customize.stats.explain.sprinttofire"] = "How long it takes to exit sprint and begin shooting."
L["customize.stats.explain.firemodes"] = "Which fire modes this gun has access to."
L["customize.stats.explain.burstdelay"] = "Amount of time after firing a burst before the gun can fire again."
L["customize.stats.explain.triggerdelay"] = "Delay between pulling the trigger and firing a shot."
L["customize.stats.explain.noise"] = "How loud the gun's gunshots are."
L["customize.stats.explain.sway"] = "Amount of sway applied to the gun."
L["customize.stats.explain.freeaim"] = "Maximum free aim angle. Lower is better."
L["customize.stats.explain.supplylimit"] = "Amount of ammo that the gun can receive from ARC9 ammo sources."

L["customize.bench.dummy"] = "BALLISTICS DUMMY TEST"
L["customize.bench.effect"] = "EFFECT AT RANGE"
L["customize.bench.ballistics"] = "TERMINAL BALLISTICS PERFORMANCE EVALUATION"
L["customize.bench.precision"] = "MECHANICAL PRECISION TEST"

L["folder.back"] = "Back"
L["folder.deselect"] = "Deselect"
L["folder.favorites"] = "Favorites"
L["folder.select"] = "Select"

////////////////////// Automatic stats
L["autostat.enable.pre"] = "Enables"
L["autostat.disable.pre"] = "Disables"
L["autostat.enable.post"] = ""
L["autostat.disable.post"] = ""

L["autostat.aimdownsightstime"] = "Aim Down Sights Time"
L["autostat.alwaysphysbullet"] = "Always Physical Bullets"
L["autostat.ammopershot"] = "Ammo Per Shot"
L["autostat.armdamage"] = "Arm Damage"
L["autostat.armorpiercing"] = "Armor Piercing"
L["autostat.autoburst"] = "Automatic Burst Fire"
L["autostat.autoreload"] = "Idle Reloading"
L["autostat.bash"] = "Melee Attacks"
L["autostat.bashdamage"] = "Melee Damage"
L["autostat.bashlungerange"] = "Melee Lunge Range"
L["autostat.bashrange"] = "Melee Range"
L["autostat.bashspeed"] = "Melee Speed"
L["autostat.bipod"] = "Bipod"
L["autostat.bottomlessclip"] = "Bottomless Magazine"
L["autostat.breathholdtime"] = "Focus Time"
L["autostat.bulletguidance"] = "Guided Rounds"
L["autostat.bulletguidanceamount"] = "Guidance Factor"
L["autostat.canfireunderwater"] = "Underwater Shooting"
L["autostat.cantpeek"] = "Disables Peeking"
L["autostat.chambersize"] = "Chamber Load Count"
L["autostat.chestdamage"] = "Chest Damage"
L["autostat.clipsize"] = "Magazine Capacity"
L["autostat.cycletime"] = "Cycle Time"
L["autostat.damagemax"] = "Close Range Damage"
L["autostat.damagemin"] = "Long Range Damage"
L["autostat.damagerand"] = "Damage Variance"
L["autostat.deploytime"] = "Draw Time"
L["autostat.distance"] = "Bullet Distance"
L["autostat.entitymuzzlevelocity"] = "Projectile Muzzle Velocity"
L["autostat.explosiondamage"] = "Explosion Damage"
L["autostat.explosionradius"] = "Explosion Splash Radius"
L["autostat.fixtime"] = "Unjam Time"
L["autostat.freeaimradius"] = "Free Aim Radius"
L["autostat.headshotdamage"] = "Headshot Damage"
L["autostat.heatcapacity"] = "Heat Capacity"
L["autostat.heatdissipation"] = "Heat Dissipation"
L["autostat.heatpershot"] = "Heat Per Shot"
L["autostat.hybridreload"] = "Hybrid Individual Reloading"
L["autostat.infiniteammo"] = "Infinite Ammunition"
L["autostat.legdamage"] = "Leg Damage"
L["autostat.malfunction"] = "Jamming"
L["autostat.malfunctionmeanshotstofail"] = "Mean Shots Between Failures"
L["autostat.malfunctionwait"] = "Malfunction Wait Time"
L["autostat.manualaction"] = "Manual Action"
L["autostat.manualactionchamber"] = "Shots Per Cycle"
L["autostat.neverphysbullet"] = "Non-Physical Bullets"
L["autostat.noflash"] = "No Muzzle Flash"
L["autostat.num"] = "Projectile Count"
L["autostat.overheat"] = "Overheating"
L["autostat.overheattime"] = "Overheat Fix Time"
L["autostat.pelletspread"] = "Clump Spread"
L["autostat.penetration"] = "Material Penetration"
L["autostat.penetrationdelta"] = "Damage After Penetration"
L["autostat.physbulletdrag"] = "Bullet Drag"
L["autostat.physbulletgravity"] = "Bullet Drop"
L["autostat.physbulletmuzzlevelocity"] = "Muzzle Velocity"
L["autostat.postburstdelay"] = "Burst Delay"
L["autostat.pushbackforce"] = "Pushback Force"
L["autostat.rangemax"] = "Maximum Range"
L["autostat.rangemin"] = "Minimum Range"
L["autostat.recoil"] = "Recoil"
L["autostat.recoilautocontrol"] = "Recoil Control"
L["autostat.recoildissipationrate"] = "Recoil Dissipation Rate"
L["autostat.recoilkick"] = "Felt Recoil"
L["autostat.recoilmodifiercap"] = "Maximum Cumulative Recoil"
L["autostat.recoilpatterndrift"] = "Recoil Drift"
L["autostat.recoilpershot"] = "Recoil per Shot"
L["autostat.recoilrandomside"] = "Horizontal Recoil Spread"
L["autostat.recoilrandomup"] = "Vertical Recoil Spread"
L["autostat.recoilresettime"] = "Recoil Reset Time"
L["autostat.recoilside"] = "Horizontal Recoil"
L["autostat.recoilup"] = "Vertical Recoil"
L["autostat.reloadtime"] = "Reload Time"
L["autostat.ricochetanglemax"] = "Ricochet Angle"
L["autostat.ricochetchance"] = "Ricochet Chance"
L["autostat.rpm"] = "Fire Rate"
L["autostat.runawayburst"] = "Runaway Burst"
L["autostat.secondarysupplylimit"] = "Reserve Secondary Ammo"
L["autostat.shootvolume"] = "Report Volume"
L["autostat.shootwhilesprint"] = "Shoot While Sprinting"
L["autostat.shotgunreload"] = "Individual Reloading"
L["autostat.speed"] = "Movement Speed"
L["autostat.spread"] = "Spread"
L["autostat.sprinttofiretime"] = "Sprint To Fire Time"
L["autostat.stomachdamage"] = "Stomach Damage"
L["autostat.supplylimit"] = "Reserve Magazines"
L["autostat.sway"] = "Sway"
L["autostat.triggerdelay"] = "Trigger Delay"
L["autostat.triggerdelaytime"] = "Trigger Delay Time"
L["autostat.visualrecoil"] = "Visual Recoil"
L["autostat.visualrecoilpunch"] = "Visual Recoil Punch"
L["autostat.visualrecoilroll"] = "Visual Recoil Roll"
L["autostat.visualrecoilside"] = "Horizontal Visual Recoil"
L["autostat.visualrecoilup"] = "Vertical Visual Recoil"

L["autostat.secondary._beforephrase"] = false
-- if true, secondary stat phrasing comes before the stat
L["autostat.secondary._divider"] = " "
-- space between the secondary phrase from the stat phrase. set true to use empty string

-- L["autostat.secondary.blindfire"] = "while Blind-Firing"
L["autostat.secondary.bipod"] = "on Bipod"
L["autostat.secondary.crouch"] = "while Crouching"
L["autostat.secondary.empty"] = "on Last round in mag"
L["autostat.secondary.evenreload"] = "every Even Reload"
L["autostat.secondary.evenshot"] = "every Even Shot"
L["autostat.secondary.first"] = "on First Shot"
L["autostat.secondary.firstshot"] = "on First Shot"
L["autostat.secondary.heated"] = "while Heated"
L["autostat.secondary.hipfire"] = "in Hipfire"
L["autostat.secondary.hot"] = "from Heat"
L["autostat.secondary.last"] = "on Last round in mag"
L["autostat.secondary.lastshot"] = "on Last round in mag"
L["autostat.secondary.midair"] = "in Mid-Air"
L["autostat.secondary.move"] = "while Moving"
L["autostat.secondary.oddreload"] = "every Odd Reload"
L["autostat.secondary.oddshot"] = "every Odd Shot"
L["autostat.secondary.recoil"] = "from Recoil" --"With Each Shot"
L["autostat.secondary.shooting"] = "while Shooting"
L["autostat.secondary.sighted"] = "while Sighted"
L["autostat.secondary.sights"] = "in Sights"
L["autostat.secondary.silenced"] = "when Silenced"
L["autostat.secondary.sprint"] = "when Sprinting"
L["autostat.secondary.true"] = "when TrueNames is on"
L["autostat.secondary.ubgl"] = "in UBGL"

////////////////////// Universal Trivia
/////////// Country of Origin
L["trivia.country"] = "Country of Origin"

L["country.ar"] = "Argentina"
L["country.au"] = "Australia"
L["country.at"] = "Austria"
L["country.by"] = "Belarus"
L["country.be"] = "Belgium"
L["country.br"] = "Brazil"
L["country.ca"] = "Canada"
L["country.cn"] = "China"
L["country.hr"] = "Croatia"
L["country.dk"] = "Denmark"
L["country.eg"] = "Egypt"
L["country.fi"] = "Finland"
L["country.fr"] = "France"
L["country.de"] = "Germany"
L["country.gr"] = "Greece"
L["country.hk"] = "Hong Kong"
L["country.hu"] = "Hungary"
L["country.is"] = "Iceland"
L["country.id"] = "Indonesia"
L["country.ir"] = "Iran"
L["country.iq"] = "Iraq"
L["country.ie"] = "Ireland"
L["country.il"] = "Israel"
L["country.it"] = "Italy"
L["country.jp"] = "Japan"
L["country.kz"] = "Kazakstan"
L["country.kp"] = "North Korea"
L["country.kr"] = "South Korea"
L["country.lt"] = "Lithuania"
L["country.mx"] = "Mexico"
L["country.nl"] = "Netherlands"
L["country.nz"] = "New Zealand"
L["country.no"] = "Norway"
L["country.pk"] = "Pakistan"
L["country.ph"] = "Philippines"
L["country.pl"] = "Poland"
L["country.pt"] = "Portugal"
L["country.ro"] = "Romania"
L["country.ru"] = "Russia"
L["country.sa"] = "Saudi Arabia"
L["country.sg"] = "Singapore"
L["country.sk"] = "Slovakia"
L["country.si"] = "Slovenia"
L["country.za"] = "South Africa"
L["country.es"] = "Spain"
L["country.se"] = "Sweden"
L["country.ch"] = "Switzerland"
L["country.tw"] = "Taiwan"
L["country.th"] = "Thailand"
L["country.tr"] = "Turkey"
L["country.ua"] = "Ukraine"
L["country.ae"] = "United Arab Emirates"
L["country.gb"] = "United Kingdom"
L["country.us"] = "United States"

////////////////////// Blacklist menu
L["blacklist.title"] = "ARC9 Attachment Blacklist"
L["blacklist.desc"] = "Attachments checked here will be blocked from use"
L["blacklist.blisted"] = "BLACKLISTED"
L["blacklist.all"] = "ALL"
L["blacklist.id"] = "ID"
L["blacklist.name"] = "NAME"
L["blacklist.filter"] = "FILTER"

////////////////////// Incompatible addons
L["incompatible.title"] = "ARC9: INCOMPATIBLE ADDONS"
L["incompatible.line1"] = "You have some addons that are known to not work with ARC9."
L["incompatible.line2"] = "Disable them or expect broken behavior!"
L["incompatible.confirm"] = "Acknowledge"
L["incompatible.wait"] = "Wait {time}s"
L["incompatible.never"] = "Never warn me again"
L["incompatible.never.hover"] = "Are you absolutely sure you understand the consequences?"
L["incompatible.never.confirm"] = "You have chosen to never show incompatiblity warnings again. If you encounter errors or broken behaviour, it is your own responsibility."

////////////////////// Warning panel
L["badconf.title"] = "ARC9: BAD GMOD SETTINGS WARNING"
L["badconf.line1"] = "It appears some Garry's Mod settings are causing problems."
L["badconf.line2"] = "Listed below are problems which have been detected, and solutions to fix them."
L["badconf.confirm"] = "Acknowledge"
L["badconf.wait"] = "Wait {time}s"

L["badconf.directx.title"] = "Outdated DirectX version"
L["badconf.directx.desc"] = "You are currently running DirectX 8 or 8.1. Modern GMod isn't meant for this, you might not be able to see models on most weapon packs. (dx9 was introduced 21 years ago!)"
L["badconf.directx.solution"] = "Solution: Go to Garry's Mod's launch options and insert \"-dxlevel 95\" into the launch parameters. If \"-dxlevel 70/80/85\" is listed there, remove it."

L["badconf.tickrate.title"] = "Too low server tickrate"
L["badconf.tickrate.desc"] = "The server you are on is running on very low tickrate. ARC9 runs best if you run a minimum of 20 tickrate (66+ is recommended)."
L["badconf.tickrate.solution"] = "Solution: If you are a server owner, then insert \"-tickrate 33\", or whichever value you want, in the server launch configurations."

L["badconf.matbumpmap.title"] = "mat_bumpmap is disabled"
L["badconf.matbumpmap.desc"] = "You have bumpmaps disabled, which makes weapons look worse. It also breaks certain ARC9 optics."
L["badconf.matbumpmap.solution"] = "Solution: In the console, type \"mat_bumpmap 1\". If you are using an FPS config of any kind, then find and delete mat_bumpmap 0 line from \"autoexec.cfg\"."

L["badconf.addons.title"] = "Too many addons! Lua file limit exceeded!"
L["badconf.addons.desc"] = "You have installed way too many addons and have reached the Lua file limit. ARC9 has therefore not been able to initialize properly, meaning attachments might not work."
L["badconf.addons.solution"] = "Solution: Uninstall heavy addons through the in-game Addons menu, or through the Steam workshop (for example other weapon bases, JMod, Entity Packs, and so on)."

L["badconf.warning"] = "Warning! Your performance is not optimal! - Hover over to view details."
L["badconf.warning.desc"] = "More FPS is always good. Especially on weapon bases like this one.\n\nHover cursor over items below to see solution."

L["badconf.x64.title"] = "► Slow 32-Bit branch Detected"
L["badconf.x64.desc"] = [[You are currently running Garry's Mod in 32-bit. This restricts the amount of performance you can obtain drastically.

Solution: In Garry's Mod's launch options, go to "Betas" and change to "x86-64 - Chromium + 64-bit binaries".

Google "gmod x64" to find a tutorial online.]]

L["badconf.multicore.title"] = "► No Multicore Rendering commands"
L["badconf.multicore.desc"] = [[Certain multicore rendering settings are currently disabled. This results in worsened in-game performance.

Solution: You need to put certain commands into autoexec.cfg

Google "gmod multicore" to find a tutorial online.

All commands that can increase performance:
gmod_mcore_test 1
mat_queue_mode 2
cl_threaded_bone_setup 1
cl_threaded_client_leaf_system 1
r_threaded_client_shadow_manager 1
r_threaded_renderables 1]]

////////////////////// Presets
L["customize.presets.atts"] = " Attachments"
L["customize.presets.back"] = "Back"
L["customize.presets.cancel"] = "Cancel"
L["customize.presets.code"] = "Preset Code (Copied to Clipboard)"
L["customize.presets.default"] = "Default"
L["customize.presets.default.long"] = "Default preset"
L["customize.presets.dumb"] = "Are you dumb"
L["customize.presets.import"] = "Import"
L["customize.presets.invalid"] = "Invalid string!"
L["customize.presets.new"] = "New Preset Name"
L["customize.presets.paste"] = "Paste Preset Code Here"
L["customize.presets.random"] = "Random"
L["customize.presets.save"] = "Save"
L["customize.presets.unnamed"] = "Unnamed"

L["customize.presets.deldef"] = "Are you sure you want to delete \"{name}\" default preset?"
L["customize.presets.deldef2"] = "You would have to reset weapon in developer settings to return it."
L["customize.presets.yes"] = "Yes"

////////////////////// Tips
L["tips.arc-9"] = "It's ARC9, not ARC-9, not Arc9."
L["tips.blacklist"] = "You can blacklist attachments! See the ARC9 Workshop description for more information."
L["tips.bugs"] = "Report bugs on the official Discord server, or better yet, open a Github issue."
L["tips.custombinds"] = "ARC9 key combos can be replaced with custom binds. Start typing +arc9_ to find the available binds!"
L["tips.cyberdemon"] = "To kill the terrorist, shoot him until he is dead."
L["tips.description"] = "We advise you to read the descriptions of addons before commenting."
L["tips.development"] = "Keen to develop ARC9 content? The official Discord server has plenty of resources to help!"
L["tips.discord"] = "Join Diamond Doves on Discord! The link is in the ARC9 description and in top of settings."
L["tips.external"] = "If using the Github version of ARC9, make sure to update frequently!"
L["tips.hints"] = "Keep ARC9's HUD on to see control hints."
L["tips.lean"] = "To manually lean, bind keys to +alt1 and +alt2."
L["tips.love"] = "Feel free to tell the devs you appreciate their work! It really helps us keep going."
L["tips.m9k"] = "Check out M9K guns!."
L["tips.official"] = "Only download ARC9 from official sources. Third party uploads may be malicious or outdated!"
L["tips.presets"] = "Share your favorite presets with your friends by exporting them!"
L["tips.settings"] = "You can turn these tips off, and much more, in the ARC9 settings. Click the button in the top left corner!"
L["tips.tips"] = "Tips have a fixed order. Keep reading and you'll eventually see them all."
L["tips.tolerance"] = "All weapon bases work fine together. There's no need for favoritism."

////////////////////// Other
L["atts.favourites"] = "Favourites"
L["atts.filter"] = "Filter"

/////////////////////////////////////// Settings menu
-- Use this method to localize convars in settings menu:
-- settings.convar.title = "Convar Title"
-- settings.convar.desc = "Convar Description"

L["settings.title"] = "ARC9 Settings"
L["settings.desc"] = "Description"

L["settings.default_convar"] = "Default value"
L["settings.convar_server"] = "Server variable"
L["settings.convar_client"] = "Client variable"

////////////////////// General
L["settings.tabname.general"] = "General"

L["settings.general.client"] = "Client"
L["settings.language_id.title"] = "Language"
L["settings.language_id.desc"] = "Language pack to use for ARC9."
L["settings.truenames.title"] = "True Names"
L["settings.truenames.desc"] = "Set whether to use weapons' real names or fictional names made by the developers. Not all weapons utilize this."
L["settings.resetsettings.cl.title"] = "Reset all CLIENT settings"

L["settings.general.server"] = "Server"
L["settings.truenames_default.title"] = "Default True Names"
L["settings.truenames_default.desc"] = "Set the default true names mode on the server. All players using \"Default\" in preference will use this."
L["settings.truenames_enforced.title"] = "Default True Names Enforced"
L["settings.truenames_enforced.desc"] = "Set to force all players to use the server setting for true names."

L["settings.resetsettings.sv.title"] = "Reset all SERVER settings"

L["settings.reset"] = "Reset!"

////////////////////// Performance
L["settings.tabname.performance"] = "Performance"

L["settings.performance.important"] = "High Performance Impact"
L["settings.cheapscopes.title"] = "Cheap Scopes"
L["settings.cheapscopes.desc"] = "A cheap RT scope implementation by zooming your whole view to aim, instead of rendering world again in a scope. Significantly increases performance on large maps."
L["settings.tpik.title"] = "TPIK"
L["settings.tpik.desc"] = "TPIK (Third Person Inverse Kinematics) is a system that allows most weapons display detailed and same as in first person hands positions, reload and firing animations in third person.\n\nConfigure it in Visuals tab."
L["settings.allflash.title"] = "All Flashlights"
L["settings.allflash.desc"] = "Fully render all flashlights from other players.\n\nVery expensive on servers."

L["settings.performance.blur.title"] = "Blur"
L["settings.cust_blur.title"] = "Customization Background"
L["settings.cust_blur.desc"] = "Blurs customization background."
L["settings.fx_reloadblur.title"] = "While Reloading"
L["settings.fx_reloadblur.desc"] = "Blurs the world while reloading."
L["settings.fx_animblur.title"] = "While readying"
L["settings.fx_animblur.desc"] = "Blurs the world while deploying a weapon for the first time."
L["settings.fx_rtblur.title"] = "In Scopes"
L["settings.fx_rtblur.desc"] = "Blurs the world while using a magnified scope."
L["settings.fx_adsblur.title"] = "In Sights"
L["settings.fx_adsblur.desc"] = "Blurs the weapon while aiming down sights."
L["settings.fx_rtvm.title"] = "Render Weapon through RT Scopes"
L["settings.fx_rtvm.desc"] = "! EXPERIMENTAL !\nRenders the weapon and its attachments through RT scopes. Requires \"Cheap Scopes\" to be disabled.\nSignificantly reduces performance."
L["settings.fx_rtblur.title2"] = "Blur behind Scopes"

L["settings.performance.shelleject.title"] = "Shell Eject"
L["settings.eject_fx.title"] = "Smoke Effects"
L["settings.eject_fx.desc"] = "Produce smoke effects from ejected shell casings, where the weapon supports this feature"
L["settings.eject_time.title"] = "Add Life Time"
L["settings.eject_time.desc"] = "Allow shell casings to stay in the world for longer. Can be expensive."

L["settings.performance.fx.title"] = "Effects"
L["settings.muzzle_light.title"] = "Muzzle Light"
L["settings.muzzle_light.desc"] = "Enable light emitted from muzzle flashes when firing a weapon."
L["settings.muzzle_others.title"] = "Other Muzzle Effects"
L["settings.muzzle_others.desc"] = "Enable muzzle effects from other players' guns."

////////////////////// Optics
L["settings.tabname.optics"] = "Optics"

L["settings.optics.control"] = "Control"
L["settings.optics.sensmult.title"] = "Multiply ADS Sensitivity"
L["settings.optics.sensmult.desc"] = "Multiply the look sensitivity by this amount when aiming.\nThe lower the value, the lower the sensitivity.\nUseful when using controllers, or if the user just wants lower aiming sensitivity."
L["settings.optics.compensate_sens.title"] = "Compensate Sensitivity"
L["settings.optics.compensate_sens.desc"] = "Compensate sensitivity for magnification."
L["settings.optics.toggleads.title"] = "Toggle ADS"
L["settings.optics.toggleads.desc"] = "Aiming will toggle sights."

L["settings.optics.dtap_sights.title"] = "Double-Tap to Switch Sights"
L["settings.optics.dtap_sights.desc"] = "Allows double-tapping the USE key to switch sights."

L["settings.optics.color"] = "Color"
L["settings.optics.reflex.title"] = "Reflex Sights"
L["settings.optics.reflex.desc"] = "Color to use for reflex/holographic sights.\n\nNot all optics support this feature."
L["settings.optics.scope.title"] = "Scopes"
L["settings.optics.scope.desc"] = "Color to use for magnified scopes.\n\nNot all optics support this feature."

////////////////////// Crosshair
L["settings.tabname.crosshair"] = "Crosshair"

L["settings.crosshair.crosshair"] = "Crosshair"
L["settings.crosshair.cross_enable.title"] = "Enable Crosshair"
L["settings.crosshair.cross_enable.desc"] = "Enable crosshair. Some guns do not allow you to use the crosshair."
L["settings.crosshair.cross.title"] = "Crosshair Color"
L["settings.crosshair.cross.desc"] = "The color of your crosshair."
L["settings.crosshair.cross_size_mult.title"] = "Crosshair Size"
L["settings.crosshair.cross_size_mult.desc"] = "Multiply the size of your crosshair."
L["settings.crosshair.cross_size_dot.title"] = "Dot Size"
L["settings.crosshair.cross_size_dot.desc"] = "Multiply the size of the middle dot."
L["settings.crosshair.cross_size_prong.title"] = "Prong Size"
L["settings.crosshair.cross_size_prong.desc"] = "Multiply the size of the outer prongs."
L["settings.crosshair.crosshair_static.title"] = "Static Crosshair"
L["settings.crosshair.crosshair_static.desc"] = "Enable static crosshair, which does not move when shooting."
L["settings.crosshair.crosshair_force.title"] = "Force Crosshair"
L["settings.crosshair.crosshair_force.desc"] = "Force the crosshair even on guns that don't want you to see it.\n\nServer setting."
L["settings.crosshair.crosshair_target.title"] = "Red Crosshair on Target"
L["settings.crosshair.crosshair_target.desc"] = "Make the crosshair red when aiming on a target.\nAlso activates aim assist if it is turned on."
L["settings.crosshair.crosshair_peeking.title"] = "Display Crosshair when Peeking"
L["settings.crosshair.crosshair_peeking.desc"] = "Displays the crosshair when aiming and using the peek function."

////////////////////// Customization
L["settings.tabname.hud_cust"] = "Customization"

L["settings.hud_cust.hud"] = "HUD"
L["settings.hud_cust.hud_scale.title"] = "HUD Scale"
L["settings.hud_cust.hud_scale.desc"] = "Scale multiplier for ARC9's HUD."
L["settings.hud_cust.hud_deadzonex.title"] = "HUD Width Deadzone"
L["settings.hud_cust.hud_deadzonex.desc"] = "Horizontal \"deadzone\" for customization menu and HUD panel.\nUseful for ultrawide monitors."
L["settings.hud_cust.hud_color.title"] = "HUD Color"
L["settings.hud_cust.hud_color.desc"] = "Highlight color for the HUD.\nThe accent color."
L["settings.hud_cust.hud_holiday.title"] = "Holiday Themes"
L["settings.hud_cust.hud_holiday.desc"] = "Themes that activate during certain holidays.\nWill override highlight color"
L["settings.hud_cust.hud_darkmode.title"] = "Dark Theme"
L["settings.hud_cust.hud_darkmode.desc"] = "Enables dark colors in HUD instead of light gray and disables vignette effect in background."
L["settings.hud_cust.cust_light.title"] = "Enable Light"
L["settings.hud_cust.cust_light.desc"] = "Enables gun lighting in the customization menu.\n\nSame thing as button near settings button."
L["settings.hud_cust.cust_light_brightness.title"] = "Light Brightness"
L["settings.hud_cust.cust_light_brightness.desc"] = "How bright that light in the customization panel will be.\n\nDon't forget to turn it on first though!"

L["settings.hud_cust.customization"] = "Customization"
L["settings.hud_cust.cust_hints.title"] = "Hints"
L["settings.hud_cust.cust_hints.desc"] = "Enable hints in the customization menu."
L["settings.hud_cust.cust_tips.title"] = "Tips"
L["settings.hud_cust.cust_tips.desc"] = "Tips about ARC9 base near hints."
L["settings.hud_cust.cust_exit_reset_sel.title"] = "Exit Resets Selection"
L["settings.hud_cust.cust_exit_reset_sel.desc"] = "Exiting customization menu resets the active slot selection."
L["settings.hud_cust.imperial.title"] = "Imperial Measurement"
L["settings.hud_cust.imperial.desc"] = "Replaces various measurement systems to their Imperial variants.\nOnly affects the \"Stats & Ballistics\" customization screen."

////////////////////// Game HUD
L["settings.tabname.hud_game"] = "Game HUD"

L["settings.hud_game.lcd"] = "LCD Panel"
L["settings.hud_game.hud_arc9.title"] = "Enable HUD"
L["settings.hud_game.hud_arc9.desc"] = "Enable HUD for ARC9 weapons."
L["settings.hud_game.hud_always.title"] = "On all weapons"
L["settings.hud_game.hud_always.desc"] = "Enable that HUD on all weapons."
L["settings.hud_game.hud_compact.title"] = "Compact Mode"
L["settings.hud_game.hud_compact.desc"] = "Compact appearance for the HUD panel."
L["settings.hud_game.hud_nohints.title"] = "Disable Hints"
L["settings.hud_game.hud_nohints.desc"] = "Disable hints completely. They will not show up in the 3D HUD, nor in the 2D HUD."
L["settings.hud_game.hud_keephints.title"] = "Keep Hints"
L["settings.hud_game.hud_keephints.desc"] = "Show the ARC9 control hints on top on HUD panel."
L["settings.hud_game.hud_force_disable.title"] = "Force Disable HUD"
L["settings.hud_game.hud_force_disable.desc"] = "Disable ARC9 HUD for all players. Does not affect hints."

L["settings.hud_game.killfeed"] = "Killfeed"
L["settings.hud_game.killfeed_enable.title"] = "Killfeed Icons"
L["settings.hud_game.killfeed_enable.desc"] = "Enable auto-generation of killfeed icons for ARC9 guns."
L["settings.hud_game.killfeed_dynamic.title"] = "Dynamic updating"
L["settings.hud_game.killfeed_dynamic.desc"] = "Killfeed icons will be regenerated after each kill.\n\nTurn off if you want get that 0.1 fps."
L["settings.hud_game.killfeed_colour.title"] = "Full Color Icons"
L["settings.hud_game.killfeed_colour.desc"] = "Dynamically generated icons are fully colored."

L["settings.hud_game.breath"] = "Breath"
L["settings.hud_game.breath_hud.title"] = "Breath HUD"
L["settings.hud_game.breath_hud.desc"] = "Show a bar that displays your remaining breath while stabilizing your gun in sights."
L["settings.hud_game.breath_pp.title"] = "Breath Post-Process"
L["settings.hud_game.breath_pp.desc"] = "Holding breath will also add post-processing effects to your screen."
L["settings.hud_game.breath_sfx.title"] = "Breath SFX"
L["settings.hud_game.breath_sfx.desc"] = "Holding breath will play associated sound effects."

L["settings.hud_game.centerhint"] = "Tooltips"
L["settings.hud_game.centerhint_reload.title"] = "Display Reload Tip"
L["settings.hud_game.centerhint_reload.desc"] = "Display a reload tip when low on ammunition."
L["settings.hud_game.centerhint_reload_percent.title"] = "Magazine Percentage"
L["settings.hud_game.centerhint_reload_percent.desc"] = "Display the reload tip when the current magazine is at this percentage value."
L["settings.hud_game.centerhint_bipod.title"] = "Display Toggle Bipod"
L["settings.hud_game.centerhint_bipod.desc"] = "Display a tip when the bipod can be toggled."
L["settings.hud_game.centerhint_jammed.title"] = "Display Jammed Tip"
L["settings.hud_game.centerhint_jammed.desc"] = "Display a tip when your weapon is jammed."

L["settings.hud_game.centerhint_firemode.title"] = "Display Firemode Tip"
L["settings.hud_game.centerhint_firemode.desc"] = "Display a tip when you swap firing mode or toggle your safety."
L["settings.hud_game.centerhint_firemode_time.title"] = "Display Firemode Time"
L["settings.hud_game.centerhint_firemode_time.desc"] = "How long the firing mode should be displayed."

L["settings.hud_game.centerhint_overheat.title"] = "Display Overheat Tip"
L["settings.hud_game.centerhint_overheat.desc"] = "Displays an overlayed tip showing how close the weapon is to overheating.\n\nNot displayed if ARC9 HUD is enabled or the weapon does not support overheat."

L["settings.hud_game.hud_glyph"] = "Glyph Type"

L["settings.hud_game.hud_glyph_type_hud.title"] = "HUD"
L["settings.hud_game.hud_glyph_type_hud.desc"] = "Change which family of glyphs to use.\nThis affects the HUD tips."

L["settings.hud_game.hud_glyph_type_cust.title"] = "Customization Menu"
L["settings.hud_game.hud_glyph_type_cust.desc"] = "Change which family of glyphs to use.\nThis affects the customization menu tips.\nChanges apply next time the customization menu is opened."

L["settings.hud_game.hud_glyph_light"] = "Light"
L["settings.hud_game.hud_glyph_dark"] = "Dark"
L["settings.hud_game.hud_glyph_knockout"] = "Knockout"

////////////////////// NPCs
L["settings.tabname.npc"] = "NPCs"

L["settings.npc.weapons"] = "NPC Weapons"
L["settings.npc.npc_equality.title"] = "Damage Equality"
L["settings.npc.npc_equality.desc"] = "NPCs do just as much damage as players do.\n\nThis is a server variable."
L["settings.npc.npc_spread.title"] = "NPC Spread"
L["settings.npc.npc_spread.desc"] = "Multiplier for how inaccurate NPCs will be when firing."
L["settings.npc.npc_atts.title"] = "Give Attachments"
L["settings.npc.npc_atts.desc"] = "Spawned or given ARC9 weapons receive a random set of attachments.\n\nThis is a server variable."
L["settings.npc.npc_autoreplace.title"] = "Replace NPC Weapons"
L["settings.npc.npc_autoreplace.desc"] = "Replace NPC weapons with randomly chosen ARC9 weapons.\n\nThis is a server variable."
L["settings.npc.replace_spawned.title"] = "Replace Ground Weapons"
L["settings.npc.replace_spawned.desc"] = "Replace map/spawned HL2 weapons with randomly chosen ARC9 weapons.\n\nThis is a server variable."
L["settings.npc.npc_give_weapons.title"] = "Players Can Give Weapons"
L["settings.npc.npc_give_weapons.desc"] = "Players are able to press E on NPCs to give them their weapon.\n\nThis is a server variable."

////////////////////// Gameplay
L["settings.tabname.gameplay"] = "Gameplay"

L["settings.gameplay.controls"] = "Controls"
L["settings.gameplay.toggleads.title"] = "Toggle ADS"
L["settings.gameplay.toggleads.desc"] = "Aiming will toggle sights."
L["settings.gameplay.autolean.title"] = "Automatic Lean"
L["settings.gameplay.autolean.desc"] = "Aiming will try to automatically lean if this is possible."
L["settings.gameplay.autoreload.title"] = "Automatic Reload"
L["settings.gameplay.autoreload.desc"] = "Empty ARC9 weapons will reload automatically."
L["settings.gameplay.togglelean.title"] = "Toggle Lean"
L["settings.gameplay.togglelean.desc"] = "Pressing the lean keys will toggle leaning instead of needing to be held down.\n\nWorks poorly in conjunction with autolean. If using toggle lean, you should disable autolean."
L["settings.gameplay.togglepeek.title"] = "Toggle Peek"
L["settings.gameplay.togglepeek.desc"] = "Pressing the peek key will toggle peeking instead of needing to be held down."
L["settings.gameplay.togglepeek_reset.title"] = "Reset Peek State After Aiming"
L["settings.gameplay.togglepeek_reset.desc"] = "(Only if Toggle Peek is on)\nPeek state will not be retained when exiting aim down sights."
L["settings.gameplay.togglebreath.title"] = "Toggle Holding Breath"
L["settings.gameplay.togglebreath.desc"] = "Pressing the Holding Breath key will toggle Holding Breath instead of needing to be held down."

L["settings.gameplay.mechanics"] = "Game Mechanics"
L["settings.gameplay.infinite_ammo.title"] = "Infinite Ammo"
L["settings.gameplay.infinite_ammo.desc"] = "Weapons have infinite ammunition.\n\nThis is a server variable."
L["settings.gameplay.realrecoil.title"] = "Physical Visual Recoil"
L["settings.gameplay.realrecoil.desc"] = "Select weapons set up for this feature experience physical muzzle rise, meaning they will fire where their viewmodel shows it rather than at the center of the screen. Very important for some weapon packs' balancing schemes.\n\nThis is a server variable."
L["settings.gameplay.lean.title"] = "Leaning"
L["settings.gameplay.lean.desc"] = "Whether players can lean with +alt1 and +alt2, including automatic lean.\n\nThis is a server variable."
L["settings.gameplay.mod_sway.title"] = "Sway"
L["settings.gameplay.mod_sway.desc"] = "Weapons will have sway, if they are set up to use it.\n\nThis is a server variable."
L["settings.gameplay.mod_freeaim.title"] = "Free Aim"
L["settings.gameplay.mod_freeaim.desc"] = "Weapons will have free aim, and will not always shoot in the middle of the screen.\n\nThis is a server variable."
L["settings.gameplay.mod_bodydamagecancel.title"] = "Body Damage Cancel"
L["settings.gameplay.mod_bodydamagecancel.desc"] = "Cancel out default body damage multiplier. Only disable if using another mod that provides this type of functionality.\ne.g. Mods which change the default limb multipliers.\n\nThis is a server variable."
L["settings.gameplay.breath_slowmo.title"] = "Slow-Mo Breath"
L["settings.gameplay.breath_slowmo.desc"] = "Holding breath slows time.\n\nSingleplayer only."
L["settings.gameplay.manualbolt.title"] = "Manual Cycling"
L["settings.gameplay.manualbolt.desc"] = "Bolt-action weapons configured for this feature will only bolt when R is pressed, and not when the attack key is released."
L["settings.gameplay.never_ready.title"] = "No Ready Anims"
L["settings.gameplay.never_ready.desc"] = "Disable ready animations when deploying a weapon.\n\nThis is a server variable."
L["settings.gameplay.recoilshake.title"] = "Recoil FOV Shake"
L["settings.gameplay.recoilshake.desc"] = "Snaps field of view when shooting"
L["settings.gameplay.equipment_generate_ammo.title"] = "Unique Ammo Types for Equipment"
L["settings.gameplay.equipment_generate_ammo.desc"] = "There is a limit of 255 ammo types, and disabling this option may help fix some problems if you have lots of addons.\n\nThis is a server variable.\n\nRequires restart."

-- ??
L["settings.gameplay.mult_defaultammo.title"] = "Default Reserve Ammo"
L["settings.gameplay.mult_defaultammo.desc"] = "How many magazines/grenades/equipment give to player when he takes weapon for first time?\n\nThis is a server variable."
L["settings.gameplay.nearwall.title"] = "Near-walling"
L["settings.gameplay.nearwall.desc"] = "Not allow gun shoot when you standing too close to wall or any obstacle."

////////////////////// Visuals
L["settings.tabname.visuals"] = "Visuals"

L["settings.visuals.viewmodel"] = "Viewmodel"
L["settings.visuals.vm_bobstyle.title"] = "Bob Style"
L["settings.visuals.vm_bobstyle.desc"] = "Select different viewmodel bobbing styles, to the flavor of different contributors of ARC9 (and Valve Software)."
L["settings.visuals.fov.title"] = "FOV"
L["settings.visuals.fov.desc"] = "Add viewmodel FOV. Makes the viewmodel bigger or smaller. Use responsibly."
L["settings.visuals.vm_addx.title"] = "Add X"
L["settings.visuals.vm_addx.desc"] = "Shift the viewmodel to the right or left."
L["settings.visuals.vm_addy.title"] = "Add Y"
L["settings.visuals.vm_addy.desc"] = "Shift the viewmodel forwards and backwards."
L["settings.visuals.vm_addz.title"] = "Add Z"
L["settings.visuals.vm_addz.desc"] = "Shift the viewmodel up and down."

L["settings.visuals.cambob"] = "View Bobbing"
L["settings.visuals.vm_cambob.title"] = "Sprint View Bobbing"
L["settings.visuals.vm_cambob.desc"] = "Makes your camera move when you sprinting"
L["settings.visuals.vm_cambobwalk.title"] = "Walk View Bobbing"
L["settings.visuals.vm_cambobwalk.desc"] = "Makes your camera slightly move when you walking around (requires sprint bobbing)"
L["settings.visuals.vm_cambobintensity.title"] = "Intensity"
L["settings.visuals.vm_cambobintensity.desc"] = "How intense bobbing will be"

L["settings.visuals.tpik"] = "TPIK"
L["settings.visuals.tpik.title"] = "Enable TPIK"
L["settings.visuals.tpik.desc"] = "TPIK (Third Person Inverse Kinematics) is a system that allows most weapons display detailed and same as in first person hands positions, reload and firing animations in third person."
L["settings.visuals.tpik_others.title"] = "Other Players TPIK"
L["settings.visuals.tpik_others.desc"] = "Show TPIK for players other than yourself. Negatively impacts performance."
L["settings.visuals.tpik_framerate.title"] = "TPIK Framerate"
L["settings.visuals.tpik_framerate.desc"] = "Maximum framerate at which TPIK can run. Set to 0 for unlimited."

////////////////////// Bullet Physics
L["settings.tabname.bullets"] = "Bullet Physics"

L["settings.bullets.bullets"] = "Bullet Physics"
L["settings.bullets.bullet_physics.title"] = "Physical Bullets"
L["settings.bullets.bullet_physics.desc"] = "Weapons that support this feature will fire physical bullets, which have drop, travel time, and drag.\n\nThis is a server variable."
L["settings.bullets.bullet_gravity.title"] = "Gravity"
L["settings.bullets.bullet_gravity.desc"] = "Multiplier for bullet gravity.\n\nThis is a server variable."
L["settings.bullets.bullet_drag.title"] = "Drag"
L["settings.bullets.bullet_drag.desc"] = "Multiplier for bullet drag.\n\nThis is a server variable."
L["settings.bullets.ricochet.title"] = "Ricochet"
L["settings.bullets.ricochet.desc"] = "Bullets fired from select weapons can sometimes bounce off of surfaces and continue to travel and do damage.\n\nThis is a server variable."
L["settings.bullets.mod_penetration.title"] = "Penetration"
L["settings.bullets.mod_penetration.desc"] = "Bullets fired from select weapons can penetrate surfaces and deal damage to whatever is on the other side.\n\nThis is a server variable."
L["settings.bullets.bullet_lifetime.title"] = "Life Time"
L["settings.bullets.bullet_lifetime.desc"] = "Time in seconds after which a bullet will be deleted.\n\nThis is a server variable."
L["settings.bullets.bullet_imaginary.title"] = "Imaginary Bullets"
L["settings.bullets.bullet_imaginary.desc"] = "Bullets will appear to travel into the skybox, beyond the map's bounds."

////////////////////// Attachments
L["settings.tabname.attachments"] = "Attachments"

L["settings.attachments.customization"] = "Customization"
L["settings.attachments.atts_nocustomize.title"] = "Disable Customization"
L["settings.attachments.atts_nocustomize.desc"] = "Disallow all customization via the customization menu.\n\nThis is a server variable."
L["settings.attachments.atts_max.title"] = "Max Attachments"
L["settings.attachments.atts_max.desc"] = "The maximum number of attachments that can be put on a weapon, including cosmetic attachments.\n\nThis is a server variable."
L["settings.attachments.autosave.title"] = "Autosave"
L["settings.attachments.autosave.desc"] = "Your last weapon customization options will be saved and automatically applied the next time you spawn that weapon."
L["settings.attachments.blacklist.title"] = "Blacklist Menu"
L["settings.attachments.blacklist.open"] = "Open"

L["settings.attachments.inventory"] = "Inventory"
L["settings.attachments.free_atts.title"] = "Free Attachments"
L["settings.attachments.free_atts.desc"] = "Attachments can be used without being picked up first.\n\nThis is a server variable."
L["settings.attachments.atts_lock.title"] = "One For All"
L["settings.attachments.atts_lock.desc"] = "Picking up one instance of an attachments allows you to use it infinite times on all your guns.\n\nThis is a server variable."
L["settings.attachments.atts_loseondie.title"] = "Lose On Death"
L["settings.attachments.atts_loseondie.desc"] = "Your attachment inventory will be lost when you die.\n\nThis is a server variable."
L["settings.attachments.atts_generateentities.title"] = "Generate Entities"
L["settings.attachments.atts_generateentities.desc"] = "Generate entities that can be spawned, allowing you to pick up attachments when free attachments is off.\n\nMight increase load time.\n\nThis is a server variable."

////////////////////// Modifiers
L["settings.tabname.modifiers"] = "Modifiers"

L["settings.modifiers.quick.title"] = "Quick Stats Modifiers"
L["settings.modifiers.quick.desc"] = " "

L["settings.mod_damage.title"] = "Damage"
L["settings.mod_spread.title"] = "Spread"
L["settings.mod_recoil.title"] = "Recoil"
L["settings.mod_visualrecoil.title"] = "Visual Recoil"
L["settings.mod_adstime.title"] = "Aim Down Sights Time"
L["settings.mod_sprinttime.title"] = "Sprint To Fire Time"
L["settings.mod_damagerand.title"] = "Damage Variance"
L["settings.mod_muzzlevelocity.title"] = "Muzzle Velocity"
L["settings.mod_rpm.title"] = "RPM"
L["settings.mod_headshotdamage.title"] = "Headshot Damage"
L["settings.mod_malfunction.title"] = "Malfunction Chance"

////////////////////// Controller
L["settings.tabname.controller"] = "Controller"

L["settings.controller.misc"] = "Misc"
L["settings.controller.misc.desc"] = "There should be button that will open panel with advanced controller config, but for now it is in  spawnmenu > Options > ARC9 > Controller."
L["settings.controller.controller.title"] = "Enable Controller Mode"
L["settings.controller.controller.desc"] = "Enable custom controller-compatible glyphs, showing controller buttons instead of the default keys."
-- L["settings.controller.controller_rumble.title"] = "Rumble"
-- L["settings.controller.controller_rumble.desc"] = "Enable controller rumble as long as Fesiug's DLL mod is loaded.\n\ngithub.com/Fesiug/\ngmod-sinput"
L["settings.controller.controller_config.title"] = "Advanced config"
L["settings.controller.controller_config.content"] = "Open panel"
L["settings.controller.controller_config.desc"] = "Open advanced controller configuration panel."

L["settings.controller.glyphs.title"] = "Glyph Type"
L["settings.controller.glyphs.desc"] = "Choose which family of glyphs you want to use.\nSet up glyphs in \"Spawnmenu\" > Options > ARC9 > Controller."

////////////////////// Aim Assist
L["settings.tabname.aimassist"] = "Aim Assist"
L["settings.tabname.aimassist.desc"] = "You can enable aim assistance if you might have trouble keeping your aim on your target, or if you just prefer to not put effort into shooting your targets."

L["settings.aimassist.enable.title"] = "Enable Aim Assist"
L["settings.aimassist.enable.desc"] = "Enables an aim assistance feature that moves your aim towards a target when aiming near them.\n\nThis is a server variable.\n\nRequires Aim Assist to be enabled on CLIENT."

L["settings.aimassist.enable_general.desc"] = "Enables an aim assistance feature that moves your aim towards a target when aiming near them.\n\nConfigure it in the \"Aim Assist\" tab."

L["settings.aimassist.enable_client.desc"] = "Enables an aim assistance feature that moves your aim towards a target when aiming near them.\n\nRequires Aim Assist to be enabled on SERVER."

L["settings.aimassist.intensity.title"] = "Intensity"
L["settings.aimassist.intensity.desc"] = "How intense the aim assist is.\n\nThis is a server variable."

L["settings.aimassist.cone.title"] = "Cone"
L["settings.aimassist.cone.desc"] = "How close or far away you need to look towards a target before the aim assist engages.\n\nThis is a server variable."

L["settings.aimassist.head.title"] = "Lock onto head"
L["settings.aimassist.head.desc"] = "If the aim assist should lock onto the target's head instead of its chest.\n\nThis is a server variable."

L["settings.aimassist.sensmult.desc"] = "Multiply the look sensitivity by this amount when hovering over a valid target.\nThe lower the value, the lower the sensitivity."

////////////////////// Asset Caching
L["settings.tabname.caching"] = "Asset Caching"
L["settings.caching.title"] = "Asset Caching"
L["settings.caching.desc"] = "You can cache some ARC9 assets (save in memory without loading while playing) to prevent stutters for comfort gameplay!\n\nYou surely should enable some stuff if your gmod running on HDD."

L["settings.caching.precache_sounds_onfirsttake.title"] = "On first equip: Cache gun sounds"
L["settings.caching.precache_sounds_onfirsttake.desc"] = "Caches all sounds only from gun you just took in hands (except reload sounds).\n\nNot any impactful, rather helpful to prevent stutters while firing."

L["settings.caching.precache_attsmodels_onfirsttake.title"] = "On first equip: Cache all attachments"
L["settings.caching.precache_attsmodels_onfirsttake.desc"] = "Caches all ARC9 attachments models when any ARC9 weapon was first equipped.\n\nCauses pretty big freeze, especially when you have lots of weapons."
L["settings.caching.precache_wepmodels_onfirsttake.title"] = "On first equip: Cache all weapon models"
L["settings.caching.precache_wepmodels_onfirsttake.desc"] = "Caches all ARC9 weapons viewmodels when any ARC9 weapon was first equipped.\n\nCauses REALLY BIG freeze, especially when you have lots of weapons."

L["settings.caching.precache_allsounds_onstartup.title"] = "On game start: Cache all guns sounds"
L["settings.caching.precache_allsounds_onstartup.desc"] = "Caches all sounds from all guns on server start-up. (except reload sounds).\n\nNot so impactful, but anyway you better use first option here."
L["settings.caching.precache_attsmodels_onstartup.title"] = "On game start: Cache all attachments"
L["settings.caching.precache_attsmodels_onstartup.desc"] = "Caches all ARC9 attachments models on server start-up.\n\nCauses pretty big load time increase, especially when you have lots of weapons."
L["settings.caching.precache_wepmodels_onstartup.title"] = "On game start: Cache all weapon models"
L["settings.caching.precache_wepmodels_onstartup.desc"] = "Caches all ARC9 weapons viewmodels on server start-up.\n\nCauses REALLY BIG load time increase, especially when you have lots of weapons."

L["settings.caching.precache_allsounds.title"] = "All weapon sounds"
L["settings.caching.precache_wepmodels.title"] = "All weapon models"
L["settings.caching.precache_attsmodels.title"] = "All attachments models"

L["settings.developer.cache"] = "Cache"

////////////////////// Developer
L["settings.tabname.developer"] = "Developer"

L["settings.developer.developer"] = "Developer Options"
L["settings.developer.dev_always_ready.title"] = "Always Ready"
L["settings.developer.dev_always_ready.desc"] = "Always play \"ready\" animation when deploying a weapon.\n\nThis is a server variable."
L["settings.developer.dev_benchgun.title"] = "Benchgun"
L["settings.developer.dev_benchgun.desc"] = "Keep the weapon where it currently is."
L["settings.developer.dev_crosshair.title"] = "Dev Crosshair"
L["settings.developer.dev_crosshair.desc"] = "Funky looking crosshair showing the exact point of aim and some useful numbers.\n\nThis is a server variable, and only works for admins - don't get cheaty with this!"
L["settings.developer.dev_show_affectors.title"] = "Display Affectors"
L["settings.developer.dev_show_affectors.desc"] = "Displays which current affectors are currently applied.\n\nRequires \"Dev Crosshair\"."
L["settings.developer.dev_show_shield.title"] = "Show Shield"
L["settings.developer.dev_show_shield.desc"] = "Show the model for the player's shield."
L["settings.developer.dev_greenscreen.title"] = "Green Screen"
L["settings.developer.dev_greenscreen.desc"] = "Show a green screen background in the customisation menu for screenshots.\n\nIf you are using HDR, don't forget to set mat_bloom_scalefactor_scalar to 0!"
L["settings.developer.reloadatts.title"] = "Reload Attachments"
L["settings.developer.reloadlangs.title"] = "Reload Languages"
L["settings.developer.dev_listmyatts.title"] = "List My Attachments"
L["settings.developer.dev_listanims.title"] = "List Anims"
L["settings.developer.dev_listbones.title"] = "List Bones"
L["settings.developer.dev_listbgs.title"] = "List Bodygroups"
L["settings.developer.dev_listatts.title"] = "List QCAttachments"
L["settings.developer.dev_listmats.title"] = "List Materials"
L["settings.developer.dev_export.title"] = "Get Export Code"
L["settings.developer.dev_getjson.title"] = "Get Weapon JSON"

L["settings.developer.presets_clear.title"] = "Clear weapon data"
L["settings.developer.presets_clear.desc"] = "Clear presets, all icons and default preset for weapon you currently holding.\n\nWarning: if menu opened without ARC9 weapon in hands it will delete all existing ARC9 presets and icons!"

L["settings.developer.clear"] = "Clear"
L["settings.developer.print"] = "Print to Console"
L["settings.developer.reload"] = "Reload"

////////////////////// ARC9 Premium
L["premium.title"] = "ARC9 Premium"
L["premium.desc"] = "ARC9 Premium allows additional customization as a major thanks for supporting the addon financially."

L["premium.requires"] = "Requires <color=255,106,0>ARC9 Premium</color>."
L["premium.acquire"] = "Subscribe to <color=255,106,0>ARC9 Premium</color>"

L["premium.ownedno"] = "<color=255,106,0>ARC9 Premium</color>: <color=255,100,100>Not owned</color>"
L["premium.owned"] = "<color=255,106,0>ARC9 Premium</color>: <color=255,100,100>Owned</color>"

L["premium.help"] = "What is ARC9 Premium?"
L["premium.help.header"] = "Guide to ARC9 Premium"
L["premium.help.desc"] = "Creating addons takes time and resources. ARC9 has always been available for free, and it will remain that way. However, if you wish to support the base financially, you may do so, and get rewarded for it!"

L["premium.help.ownedbutnoaccess"] = "Have you recently purchased ARC9 Premium, but do not have automatic access to it? Contact us on the Diamond Doves Discord Server for assistance.\nEnsure you can provide proof of purchase before contacting. Simply saying \"I buy, now give\" is not good enough."

L["premium.content"] = "Included in <color=255,106,0>ARC9 Premium</color>:"
L["premium.content.list"] = [[
- Unlimited Customization Slots (Increased from 32)
- Unlimited Preset Slots (Increased from 10 per weapon)
- Access to Supermodifier settings*
- Access to an exclusive Dark UI mode
- Ability to colour optic reticles, UI and more
- Exclusive camos made available through the base
- Exclusive support channel on Discord

*Requires administrator if on a server
]]

L["premium.payment.month"] = [[
$%s
Acquire ARC9 Premium for 1 Month.
]]

L["premium.payment.months"] = [[
$%s
Acquire ARC9 Premium for %s Months and get a <color=100,255,100>%s%% discount</color>!
]]

L["premium.payment.info"] = [[
Purchasing ARC9 Premium grants immediate access to all the contents listed previously for the time purchased.
Time can be extended by purchasing any of the options once more, and the time will refresh automatically once the original time has expired.
Once the time has passed, and no additional payment has been made, access to ARC9 Premium will be removed.

All customization options, including attachment slots, presets and coloured reticles made with ARC9 Premium will remain available, but you will not alter them or add any additional ones.
]]

L["premium.purchased"] = "Purchased <color=255,106,0>ARC9 Premium</color>!"
L["premium.purchased.desc"] = [[
Thank you for purchasing ARC9 Premium! You made the bird a very happy one!

A receipt will be sent to your connected Email.

If you have not immediately acquired access to the ARC9 Premium bonuses, please rejoin the server, or restart your game.

If you are still having problems with it, or if you still have not been granted Premium, then do visit the Diamond Doves Discord server and provide valid proof of purchase, and we will have it fixed for you.
]]

--PATH lua/arc9/common/localization/base_en.lua:
return gluapack()()
--PATH lua/arc9/common/localization/base_zh-cn.lua:
L = {}

/////////////////////////////////////// Font
////////////////////// See "font_zh-cn" file

/////////////////////////////////////// General
////////////////////// Units of measurement
L["unit.second"] = "s"
L["unit.meter"] = "m"
L["unit.millimeter"] = "mm"
L["unit.meterpersecond"] = "m/s"
L["unit.hammerunit"] = "HU"
L["unit.decibel"] = "dB"
L["unit.rpm"] = "RPM"
L["unit.moa"] = "MOA"
L["unit.dmg"] = "DMG"
L["unit.projectiles"] = "PROJ"

L["unit.inch"] = "in"
L["unit.foot"] = "ft"
L["unit.footpersecond"] = "ft/s"
L["unit.yard"] = "yd"

////////////////////// Ammo types
-- L["ammo.pistol"] = "Pistol Ammo"
-- L["ammo.357"] = "Magnum Ammo"
-- L["ammo.smg1"] = "Carbine Ammo"
-- L["ammo.ar2"] = "Rifle Ammo"
-- L["ammo.buckshot"] = "Shotgun Ammo"
-- L["ammo.sniperpenetratedround"] = "Sniper Ammo"
-- L["ammo.smg1_grenade"] = "Rifle Grenades"
-- L["ammo.xbowbolt"] = "Crossbow Bolts"
-- L["ammo.rpg_round"] = "Rockets"
-- L["ammo.grenade"] = "Grenades"
-- L["ammo.slam"] = "SLAM"
-- L["ammo.alyxgun"] = "Alyx's Gun Ammo"

/////////////////////////////////////// HUD
L["hud.version"] = "ARCTIC SYSTEMS HUD v"
L["hud.jammed"] = "卡弹！"
L["hud.therm_deco"] = "枪管温度"

L["hud.firemode.single"] = "单发"
L["hud.firemode.burst"] = "点射"
L["hud.firemode.auto"] = "自动"
L["hud.firemode.safe"] = "保险"

L["hud.hint.bash"] = "近战"
L["hud.hint.bipod"] = "切换两脚架"
L["hud.hint.breath"] = "屏气"
L["hud.hint.customize"] = "自定义"
L["hud.hint.cycle"] = "上膛"
L["hud.hint.firemode"] = "切换开火模式"
L["hud.hint.inspect"] = "检查"
L["hud.hint.lean"] = "侧身"
L["hud.hint.peek"] = "窥视"
L["hud.hint.reload"] = "重载"
L["hud.hint.safe"] = "切换保险"
L["hud.hint.switchsights"] = "切换瞄具"
L["hud.hint.toggleatts"] = "切换配件"
L["hud.hint.ubgl"] = "切换"
-- L["hud.hint.unjam"] = "Unjam"
L["hud.hint.zoom"] = "瞄具缩放"
-- L["hud.hint.quicknade"] = "Quickthrow "

-- L["hud.hint.lowammo"] = "Low Ammo"
-- L["hud.hint.noammo"] = "No Ammo"

-- L["hud.error.missingbind"] = "No button bound to %s"
-- L["hud.error.missingbind_zoom"] = "Bind \"Suit Zoom\" in settings!"
-- L["hud.error.missingbind_context"] = "Bind \"Open Context Menu\" in settings!"

/////////////////////////////////////// Customization menu
L["customize.panel.customize"] = "自定义"
L["customize.panel.personalize"] = "客制化"
L["customize.panel.stats"] = "数据和弹道"
L["customize.panel.trivia"] = "介绍"
L["customize.panel.inspect"] = "检视"
L["customize.panel.presets"] = "预设"

L["customize.stats.aimtime"] = "瞄准速度"
L["customize.stats.ammo"] = "弹药类型"
L["customize.stats.armorpiercing"] = "穿甲"
L["customize.stats.burstdelay"] = "点射延迟"
L["customize.stats.capacity"] = "装填量"
L["customize.stats.cyclic"] = "有效射速"
L["customize.stats.explosive"] = "爆炸伤害"
L["customize.stats.firemodes"] = "开火模式"
L["customize.stats.firepower"] = "火力"
L["customize.stats.freeaim"] = "自由腰射角度"
L["customize.stats.muzzlevelocity"] = "出膛速度"
L["customize.stats.noise"] = "开火响度"
L["customize.stats.penetration"] = "穿透力"
L["customize.stats.precision"] = "准度"
L["customize.stats.range"] = "射程"
L["customize.stats.ricochet"] = "反弹概率"
L["customize.stats.rof"] = "射速"
L["customize.stats.speed"] = "移动速度"
L["customize.stats.sprinttofire"] = "冲刺恢复速度"
L["customize.stats.supplylimit"] = "补给上限"
L["customize.stats.sway"] = "偏移"
L["customize.stats.triggerdelay"] = "扳机延迟"

L["customize.hint.attach"] = "安装"
L["customize.hint.controller"] = "开启手柄模式。"
L["customize.hint.cursor"] = "光标"
L["customize.hint.cycle"] = "切换槽位"
L["customize.hint.delete"] = "删除"
L["customize.hint.deselect"] = "取消选择"
L["customize.hint.expand"] = "配置"
L["customize.hint.export"] = "导出"
L["customize.hint.favorite"] = "加入收藏"
L["customize.hint.import"] = "导入"
L["customize.hint.install"] = "安装"
L["customize.hint.last"] = "上个槽位"
L["customize.hint.lastmode"] = "上个模式"
L["customize.hint.nextmode"] = "下个模式"
L["customize.hint.open"] = "打开"
L["customize.hint.pan"] = "平移"
L["customize.hint.quicksave"] = "快速保存"
-- L["customize.hint.randomize"] = "Attach Random"
L["customize.hint.recalculate"] = "重新计算"
L["customize.hint.recenter"] = "重置视角"
L["customize.hint.rotate"] = "旋转"
L["customize.hint.save"] = "保存"
L["customize.hint.select"] = "选择"
L["customize.hint.unattach"] = "卸下"
L["customize.hint.unfavorite"] = "取消收藏"
L["customize.hint.zoom"] = "缩放"

L["customize.trivia.description"] = "介绍"

-- L["customize.stats.explain.firepower"] = "The damage potential at point-blank range."
-- L["customize.stats.explain.rof"] = "The weapon's rate of fire."
-- L["customize.stats.explain.cyclic"] = "The weapon's cyclic rate of fire. Ignores factors like burst delay or reload requirements."
-- L["customize.stats.explain.capacity"] = "How much ammo the gun can hold in the magazine + chamber."
-- L["customize.stats.explain.range"] = "The range at which the gun deals minimum damage."
-- L["customize.stats.explain.precision"] = "The weapon's accuracy. Measured in Minutes of Accuracy (MOA)."
-- L["customize.stats.explain.muzzlevelocity"] = "The muzzle velocity of bullets fired from this gun."
-- L["customize.stats.explain.ammo"] = "The type of ammo this gun uses."
-- L["customize.stats.explain.penetration"] = "Amount of material this gun can penetrate."
-- L["customize.stats.explain.ricochet"] = "Maximum chance for bullets from this gun to ricochet."
-- L["customize.stats.explain.armorpiercing"] = "Amount of damage from this gun that completely ignores most damage resistances."
-- L["customize.stats.explain.explosive"] = "Amount of explosive damage this gun will do."
-- L["customize.stats.explain.speed"] = "Speed at which you can move while using this gun."
-- L["customize.stats.explain.aimtime"] = "How long it takes to aim down sights from hip fire."
-- L["customize.stats.explain.sprinttofire"] = "How long it takes to exit sprint and begin shooting."
-- L["customize.stats.explain.firemodes"] = "Which fire modes this gun has access to."
-- L["customize.stats.explain.burstdelay"] = "Amount of time after firing a burst before the gun can fire again."
-- L["customize.stats.explain.triggerdelay"] = "Delay between pulling the trigger and firing a shot."
-- L["customize.stats.explain.noise"] = "How loud the gun's gunshots are."
-- L["customize.stats.explain.sway"] = "Amount of sway applied to the gun."
-- L["customize.stats.explain.freeaim"] = "Maximum free aim angle. Lower is better."
-- L["customize.stats.explain.supplylimit"] = "Amount of ammo that the gun can receive from ARC9 ammo sources."

L["customize.bench.dummy"] = "假人伤害测试"
L["customize.bench.effect"] = "测试距离"
L["customize.bench.ballistics"] = "弹道射程测试记录"
L["customize.bench.precision"] = "机械准度测试"

L["folder.back"] = "返回"
L["folder.deselect"] = "取消选择"
L["folder.favorites"] = "收藏夹"
L["folder.select"] = "选择"

////////////////////// Automatic stats
L["autostat.enable.pre"] = "启用"
L["autostat.disable.pre"] = "禁用"
L["autostat.enable.post"] = ""
L["autostat.disable.post"] = ""

L["autostat.aimdownsightstime"] = "瞄准耗时"
L["autostat.alwaysphysbullet"] = "使用物理弹道"
L["autostat.ammopershot"] = "弹药消耗"
L["autostat.armdamage"] = "手部伤害倍率"
L["autostat.armorpiercing"] = "穿甲强度"
L["autostat.autoburst"] = "自动点射"
L["autostat.autoreload"] = "自动装填"
L["autostat.bash"] = "近战攻击"
L["autostat.bashdamage"] = "近战伤害"
L["autostat.bashlungerange"] = "近战近身距离"
L["autostat.bashrange"] = "近战距离"
-- L["autostat.bashspeed"] = "Melee Speed"
L["autostat.bipod"] = "两脚架"
L["autostat.bottomlessclip"] = "无限弹夹"
L["autostat.breathholdtime"] = "屏吸时间"
L["autostat.bulletguidance"] = "制导子弹"
L["autostat.bulletguidanceamount"] = "制导强度"
L["autostat.canfireunderwater"] = "水下开火"
-- L["autostat.cantpeek"] = "Disables Peeking"
L["autostat.chambersize"] = "弹膛装填量"
L["autostat.chestdamage"] = "胸口伤害倍率"
L["autostat.clipsize"] = "弹夹容量"
L["autostat.cycletime"] = "上膛耗时"
L["autostat.damagemax"] = "近距离伤害"
L["autostat.damagemin"] = "远距离伤害"
L["autostat.damagerand"] = "伤害随机性"
L["autostat.deploytime"] = "部署耗时"
L["autostat.distance"] = "子弹距离"
L["autostat.entitymuzzlevelocity"] = "出膛速度"
L["autostat.explosiondamage"] = "爆炸伤害"
L["autostat.explosionradius"] = "爆炸范围"
L["autostat.fixtime"] = "卡弹修理耗时"
L["autostat.freeaimradius"] = "自由腰射角度"
L["autostat.headshotdamage"] = "爆头伤害倍率"
L["autostat.heatcapacity"] = "过热上限"
L["autostat.heatdissipation"] = "散热速度"
L["autostat.heatpershot"] = "开火过热量"
L["autostat.hybridreload"] = "非空单发装填"
L["autostat.infiniteammo"] = "无限弹药"
L["autostat.legdamage"] = "腿部伤害倍率"
L["autostat.malfunction"] = "卡弹"
L["autostat.malfunctionmeanshotstofail"] = "平均卡弹率"
L["autostat.malfunctionwait"] = "卡弹等待时间"
L["autostat.manualaction"] = "手动上膛"
L["autostat.manualactionchamber"] = "上膛弹药消耗"
L["autostat.neverphysbullet"] = "不使用物理弹道"
L["autostat.noflash"] = "无枪口火焰"
L["autostat.num"] = "出膛弹量"
L["autostat.overheat"] = "过热"
L["autostat.overheattime"] = "过热修理耗时"
L["autostat.pelletspread"] = "弹丸散射"
L["autostat.penetration"] = "穿透强度"
-- L["autostat.penetrationdelta"] = "Damage After Penetration"
L["autostat.physbulletdrag"] = "弹道阻力"
L["autostat.physbulletgravity"] = "弹道重力"
L["autostat.physbulletmuzzlevelocity"] = "出膛速度"
L["autostat.postburstdelay"] = "点射延迟"
L["autostat.pushbackforce"] = "后推力"
L["autostat.rangemax"] = "最大射程"
L["autostat.rangemin"] = "最小射程"
L["autostat.recoil"] = "后坐力"
L["autostat.recoilautocontrol"] = "后坐自动控制"
L["autostat.recoildissipationrate"] = "后坐恢复速率"
L["autostat.recoilkick"] = "后坐力强度"
-- L["autostat.recoilmodifiercap"] = "Maximum Cumulative Recoil"
L["autostat.recoilpatterndrift"] = "后坐力漂移"
-- L["autostat.recoilpershot"] = "Recoil per Shot"
L["autostat.recoilrandomside"] = "随机水平后坐力"
L["autostat.recoilrandomup"] = "随机垂直后坐力"
L["autostat.recoilresettime"] = "后坐重置时间"
L["autostat.recoilside"] = "水平后坐力"
L["autostat.recoilup"] = "垂直后坐力"
L["autostat.reloadtime"] = "装填耗时"
L["autostat.ricochetanglemax"] = "反弹角度"
L["autostat.ricochetchance"] = "反弹概率"
L["autostat.rpm"] = "射速"
L["autostat.runawayburst"] = "不间断点射"
L["autostat.secondarysupplylimit"] = "次要后备弹药上限"
L["autostat.shootvolume"] = "枪火响度"
L["autostat.shootwhilesprint"] = "冲刺时开火"
L["autostat.shotgunreload"] = "单发装填"
L["autostat.speed"] = "移动速度"
L["autostat.spread"] = "散射"
L["autostat.sprinttofiretime"] = "冲刺恢复耗时"
L["autostat.stomachdamage"] = "腹部伤害倍率"
L["autostat.supplylimit"] = "后备弹药上限"
L["autostat.sway"] = "偏移"
L["autostat.triggerdelay"] = "扳机延迟"
-- L["autostat.triggerdelaytime"] = "Trigger Delay Time"
L["autostat.visualrecoil"] = "可视后坐力"
L["autostat.visualrecoilpunch"] = "可视后坐力击退"
L["autostat.visualrecoilroll"] = "可视后坐力横滚"
L["autostat.visualrecoilside"] = "水平可视后坐力"
L["autostat.visualrecoilup"] = "垂直可视后坐力"

L["autostat.secondary._beforephrase"] = true
-- if true, secondary stat phrasing comes before the stat
L["autostat.secondary._divider"] = true
-- space between the secondary phrase from the stat phrase. set true to use empty string

-- L["autostat.secondary.blindfire"] = "while Blind-Firing"
-- L["autostat.secondary.bipod"] = "on Bipod"
L["autostat.secondary.crouch"] = "蹲下"
L["autostat.secondary.empty"] = "最后一发"
L["autostat.secondary.evenreload"] = "偶数次装填"
L["autostat.secondary.evenshot"] = "偶数发"
L["autostat.secondary.first"] = "首发"
L["autostat.secondary.firstshot"] = "首发"
-- L["autostat.secondary.heated"] = "while Heated"
L["autostat.secondary.hipfire"] = "腰射"
-- L["autostat.secondary.hot"] = "from Heat"
L["autostat.secondary.last"] = "最后一发"
L["autostat.secondary.lastshot"] = "最后一发"
L["autostat.secondary.midair"] = "空中"
L["autostat.secondary.move"] = "移动"
L["autostat.secondary.oddreload"] = "奇数次装填"
L["autostat.secondary.oddshot"] = "奇数发"
L["autostat.secondary.recoil"] = "后坐力" --"With Each Shot"
L["autostat.secondary.shooting"] = "开火"
-- L["autostat.secondary.sighted"] = "while Sighted"
L["autostat.secondary.sights"] = "瞄准"
L["autostat.secondary.silenced"] = "消音"
-- L["autostat.secondary.sprint"] = "when Sprinting"
L["autostat.secondary.true"] = "真实名称开启时"
L["autostat.secondary.ubgl"] = "下挂武器"

////////////////////// Blacklist menu
-- L["blacklist.title"] = "ARC9 Attachment Blacklist"
-- L["blacklist.desc"] = "Attachments checked here will be blocked from use"
-- L["blacklist.blisted"] = "BLACKLISTED"
-- L["blacklist.all"] = "ALL"
-- L["blacklist.id"] = "ID"
-- L["blacklist.name"] = "NAME"
-- L["blacklist.filter"] = "FILTER"

////////////////////// Incompatible addons
L["incompatible.title"] = "ARC9: INCOMPATIBLE ADDONS"
L["incompatible.line1"] = "You have some addons that are known to not work with ARC9."
L["incompatible.line2"] = "Disable them or expect broken behavior!"
L["incompatible.confirm"] = "Acknowledge"
L["incompatible.wait"] = "Wait {time}s"
L["incompatible.never"] = "Never warn me again"
L["incompatible.never.hover"] = "Are you absolutely sure you understand the consequences?"
L["incompatible.never.confirm"] = "You have chosen to never show incompatiblity warnings again. If you encounter errors or broken behaviour, it is your own responsibility."

////////////////////// Warning panel
-- L["badconf.title"] = "ARC9: BAD GMOD SETTINGS WARNING"
-- L["badconf.line1"] = "It appears some Garry's Mod settings are causing problems."
-- L["badconf.line2"] = "Listed below are problems which have been detected, and solutions to fix them."
-- L["badconf.confirm"] = "Acknowledge"
-- L["badconf.wait"] = "Wait {time}s"

-- L["badconf.directx.title"] = "Outdated DirectX version"
-- L["badconf.directx.desc"] = "You are currently running DirectX 8 or 8.1. Modern GMod isn't meant for this, you might not be able to see models on most weapon packs. (dx9 was introduced 21 years ago!)"
-- L["badconf.directx.solution"] = "Solution: Go to Garry's Mod's launch options and insert \"-dxlevel 95\" into the launch parameters. If \"-dxlevel 70/80/85\" is listed there, remove it."

-- L["badconf.tickrate.title"] = "Too low server tickrate"
-- L["badconf.tickrate.desc"] = "The server you are on is running on very low tickrate. ARC9 runs best if you run a minimum of 20 tickrate (66+ is recommended)."
-- L["badconf.tickrate.solution"] = "Solution: If you are a server owner, then insert \"-tickrate 33\", or whichever value you want, in the server launch configurations."

-- L["badconf.matbumpmap.title"] = "mat_bumpmap is disabled"
-- L["badconf.matbumpmap.desc"] = "You have bumpmaps disabled, which makes weapons look worse. It also breaks certain ARC9 optics."
-- L["badconf.matbumpmap.solution"] = "Solution: In the console, type \"mat_bumpmap 1\". If you are using an FPS config of any kind, then find and delete mat_bumpmap 0 line from \"autoexec.cfg\"."

-- L["badconf.addons.title"] = "Too many addons! Lua file limit exceeded!"
-- L["badconf.addons.desc"] = "You have installed way too many addons and have reached the Lua file limit. ARC9 has therefore not been able to initialize properly, meaning attachments might not work."
-- L["badconf.addons.solution"] = "Solution: Uninstall heavy addons through the in-game Addons menu, or through the Steam workshop (for example other weapon bases, JMod, Entity Packs, and so on)."

-- L["badconf.warning"] = "Warning! Your performance is not optimal! - Hover over to view details."
-- L["badconf.warning.desc"] = "More FPS is always good. Especially on weapon bases like this one.\n\nHover cursor over items below to see solution."

-- L["badconf.x64.title"] = "► Slow 32-Bit branch Detected"
-- L["badconf.x64.desc"] = [[You are currently running Garry's Mod in 32-bit. This restricts the amount of performance you can obtain drastically.

-- Solution: In Garry's Mod's launch options, go to "Betas" and change to "x86-64 - Chromium + 64-bit binaries".

-- Google "gmod x64" to find a tutorial online.]]

-- L["badconf.multicore.title"] = "► No Multicore Rendering commands"
-- L["badconf.multicore.desc"] = [[Certain multicore rendering settings are currently disabled. This results in worsened in-game performance.

-- Solution: You need to put certain commands into autoexec.cfg

-- Google "gmod multicore" to find a tutorial online.

-- All commands that can increase performance:
-- gmod_mcore_test 1
-- mat_queue_mode 2
-- cl_threaded_bone_setup 1
-- cl_threaded_client_leaf_system 1
-- r_threaded_client_shadow_manager 1
-- r_threaded_renderables 1]]

////////////////////// Presets
L["customize.presets.atts"] = " 个配件"
L["customize.presets.back"] = "退回"
L["customize.presets.cancel"] = "取消"
L["customize.presets.code"] = "预设代码 (已复制到剪切板)"
L["customize.presets.default"] = "默认"
L["customize.presets.default.long"] = "出厂设置"
L["customize.presets.dumb"] = "你倒是输点东西啊？"
L["customize.presets.import"] = "导入"
L["customize.presets.invalid"] = "非法字符串！"
L["customize.presets.new"] = "预设名"
L["customize.presets.paste"] = "输入预设代码"
L["customize.presets.random"] = "随机"
L["customize.presets.save"] = "保存"
L["customize.presets.unnamed"] = "未命名"

-- L["customize.presets.deldef"] = "Are you sure you want to delete \"{name}\" default preset?"
-- L["customize.presets.deldef2"] = "You would have to reset weapon in developer settings to return it."
L["customize.presets.yes"] = "是"

////////////////////// Tips
-- L["tips.arc-9"] = "It's ARC9, not ARC-9, not Arc9."
-- L["tips.blacklist"] = "You can blacklist attachments! See the ARC9 Workshop description for more information."
-- L["tips.bugs"] = "Report bugs on the official Discord server, or better yet, open a Github issue."
-- L["tips.custombinds"] = "ARC9 key combos can be replaced with custom binds. Start typing +arc9_ to find the available binds!"
-- L["tips.cyberdemon"] = "To kill the terrorist, shoot him until he is dead."
-- L["tips.description"] = "We advise you to read the descriptions of addons before commenting."
-- L["tips.development"] = "Keen to develop ARC9 content? The official Discord server has plenty of resources to help!"
-- L["tips.discord"] = "Join Diamond Doves on Discord! The link is in the ARC9 description and in top of settings."
-- L["tips.external"] = "If using the Github version of ARC9, make sure to update frequently!"
-- L["tips.hints"] = "Keep ARC9's HUD on to see control hints."
-- L["tips.lean"] = "To manually lean, bind keys to +alt1 and +alt2."
-- L["tips.love"] = "Feel free to tell the devs you appreciate their work! It really helps us keep going."
-- L["tips.m9k"] = "Check out M9K guns!."
-- L["tips.official"] = "Only download ARC9 from official sources. Third party uploads may be malicious or outdated!"
-- L["tips.presets"] = "Share your favorite presets with your friends by exporting them!"
-- L["tips.settings"] = "You can turn these tips off, and much more, in the ARC9 settings. Click the button in the top left corner!"
-- L["tips.tips"] = "Tips have a fixed order. Keep reading and you'll eventually see them all."
-- L["tips.tolerance"] = "All weapon bases work fine together. There's no need for favoritism."

////////////////////// Other
L["atts.favourites"] = "收藏"
L["atts.filter"] = "筛选"

/////////////////////////////////////// Settings menu
-- Use this method to localize convars in settings menu:
-- settings.convar.title = "Convar Title"
-- settings.convar.desc = "Convar Description"

L["settings.title"] = "ARC9 设定"
L["settings.desc"] = "简介"

-- L["settings.default_convar"] = "Default value"
-- L["settings.convar_server"] = "Server variable"
-- L["settings.convar_client"] = "Client variable"

////////////////////// General
-- L["settings.tabname.general"] = "General"

-- L["settings.general.client"] = "Client"
L["settings.language_id.title"] = "语言"
-- L["settings.language_id.desc"] = "Language pack to use for ARC9."
-- L["settings.truenames.title"] = "True Names"
-- L["settings.truenames.desc"] = "Set whether to use weapons' real names or fictional names made by the developers. Not all weapons utilize this."
-- L["settings.resetsettings.cl.title"] = "Reset all CLIENT settings"

-- L["settings.general.server"] = "Server"
-- L["settings.truenames_default.title"] = "Default True Names"
-- L["settings.truenames_default.desc"] = "Set the default true names mode on the server. All players using \"Default\" in preference will use this."
-- L["settings.truenames_enforced.title"] = "Default True Names Enforced"
-- L["settings.truenames_enforced.desc"] = "Set to force all players to use the server setting for true names."

-- L["settings.resetsettings.sv.title"] = "Reset all SERVER settings"

-- L["settings.reset"] = "Reset!"

////////////////////// Performance
L["settings.tabname.performance"] = "性能"

L["settings.performance.important"] = "主要设置"
L["settings.cheapscopes.title"] = "高性能准镜"
L["settings.cheapscopes.desc"] = "通过放大玩家视角来进行瞄具渲染，而不是渲染两次。在较大的地图上会显著提升性能。"
L["settings.tpik.title"] = "TPIK"
L["settings.tpik.desc"] = "TPIK (第三人称逆运动动画) 可将第一人称的手部动作表现在你的第三人称角色上。\n\n在 “视觉” 设置里可调整详细信息。"
L["settings.allflash.title"] = "第三人称手电筒"
L["settings.allflash.desc"] = "将其他玩家的手电以完整光源表现。\n\n对服务器压力很大。"

L["settings.performance.blur.title"] = "模糊化"
L["settings.cust_blur.title"] = "自定义菜单背景"
L["settings.cust_blur.desc"] = "自定义菜单背景进行模糊处理。"
L["settings.fx_reloadblur.title"] = "装填时"
L["settings.fx_reloadblur.desc"] = "装填时模糊屏幕。"
L["settings.fx_animblur.title"] = "准备武器时"
L["settings.fx_animblur.desc"] = "第一次掏出武器时模糊屏幕。"
L["settings.fx_rtblur.title"] = "使用准镜时"
L["settings.fx_rtblur.desc"] = "有倍率的准镜会模糊准镜外的视野。"
L["settings.fx_adsblur.title"] = "瞄准时"
L["settings.fx_adsblur.desc"] = "武器会在瞄准时模糊。"
-- L["settings.fx_rtvm.title"] = "Render Weapon through RT Scopes"
-- L["settings.fx_rtvm.desc"] = "! EXPERIMENTAL !\nRenders the weapon and its attachments through RT scopes. Requires \"Cheap Scopes\" to be disabled.\nSignificantly reduces performance."

L["settings.performance.shelleject.title"] = "弹壳"
L["settings.eject_fx.title"] = "烟雾效果"
L["settings.eject_fx.desc"] = "启用时弹壳会冒烟。只有特定武器支持此功能。"
L["settings.eject_time.title"] = "额外时间"
L["settings.eject_time.desc"] = "让弹壳再飞一会。弹壳太多会影响性能。"

L["settings.performance.fx.title"] = "特效"
L["settings.muzzle_light.title"] = "枪火光效"
L["settings.muzzle_light.desc"] = "开火时会短暂显示光源。"
L["settings.muzzle_others.title"] = "他人枪口特效"
L["settings.muzzle_others.desc"] = "显示其他玩家的枪口特效。"

////////////////////// Optics
L["settings.tabname.optics"] = "瞄具"

L["settings.optics.control"] = "操作"
-- L["settings.optics.sensmult.title"] = "Multiply ADS Sensitivity"
-- L["settings.optics.sensmult.desc"] = "Multiply the look sensitivity by this amount when aiming.\nThe lower the value, the lower the sensitivity.\nUseful when using controllers, or if the user just wants lower aiming sensitivity."
L["settings.optics.compensate_sens.title"] = "鼠标灵敏度自动调整"
L["settings.optics.compensate_sens.desc"] = "根据准镜放大倍率调整灵敏度。"
L["settings.optics.toggleads.title"] = "切换瞄准"
L["settings.optics.toggleads.desc"] = "按一次瞄准键进入或退出瞄准，而不是按住。"

-- L["settings.optics.dtap_sights.title"] = "Double-Tap to Switch Sights"
-- L["settings.optics.dtap_sights.desc"] = "Allows double-tapping the USE key to switch sights."

L["settings.optics.color"] = "颜色"
L["settings.optics.reflex.title"] = "全息"
L["settings.optics.reflex.desc"] = "全息/反射瞄具的准心颜色。\n\n只有部分瞄具支持这个功能。"
L["settings.optics.scope.title"] = "准镜"
L["settings.optics.scope.desc"] = "放大瞄具的准心颜色。\n\n只有部分瞄具支持这个功能。"

////////////////////// Crosshair
L["settings.tabname.crosshair"] = "准心"

L["settings.crosshair.crosshair"] = "十字准星"
L["settings.crosshair.cross_enable.title"] = "启用准星"
L["settings.crosshair.cross_enable.desc"] = "腰射和部分武器瞄准时显示十字准心。\n\n部分武器不允许显示准心，此设定会无效。"
L["settings.crosshair.cross.title"] = "准星颜色"
L["settings.crosshair.cross.desc"] = "给你的准心上色。"
L["settings.crosshair.cross_size_mult.title"] = "准心大小"
L["settings.crosshair.cross_size_mult.desc"] = "准心的大小倍率。"
L["settings.crosshair.cross_size_dot.title"] = "中点大小"
L["settings.crosshair.cross_size_dot.desc"] = "准心中间的点的大小倍率。"
L["settings.crosshair.cross_size_prong.title"] = "十字长度"
L["settings.crosshair.cross_size_prong.desc"] = "准心周围长条的大小倍率。"
L["settings.crosshair.crosshair_static.title"] = "静态准心"
L["settings.crosshair.crosshair_static.desc"] = "准心不会在开火时震动。"
L["settings.crosshair.crosshair_force.title"] = "强制启用准心"
L["settings.crosshair.crosshair_force.desc"] = "在所有武器上开启准心。\n\n服务器端设置。"
-- L["settings.crosshair.crosshair_target.title"] = "Red Crosshair on Target"
-- L["settings.crosshair.crosshair_target.desc"] = "Make the crosshair red when aiming on a target.\nAlso activates aim assist if it is turned on."
-- L["settings.crosshair.crosshair_peeking.title"] = "Display Crosshair when Peeking"
-- L["settings.crosshair.crosshair_peeking.desc"] = "Displays the crosshair when aiming and using the peek function."

////////////////////// Customization
L["settings.tabname.hud_cust"] = "自定义"

L["settings.hud_cust.hud"] = "HUD"
L["settings.hud_cust.hud_scale.title"] = "HUD 大小"
L["settings.hud_cust.hud_scale.desc"] = "全局界面大小倍率。"
-- L["settings.hud_cust.hud_deadzonex.title"] = "HUD Width Deadzone"
-- L["settings.hud_cust.hud_deadzonex.desc"] = "Horizontal \"deadzone\" for customization menu and HUD panel.\nUseful for ultrawide monitors."
L["settings.hud_cust.hud_color.title"] = "HUD 颜色"
L["settings.hud_cust.hud_color.desc"] = "主题高亮颜色。"
-- L["settings.hud_cust.hud_holiday.title"] = "Holiday Themes"
-- L["settings.hud_cust.hud_holiday.desc"] = "Themes that activate during certain holidays.\nWill override highlight color"
-- L["settings.hud_cust.hud_darkmode.title"] = "Dark Theme"
-- L["settings.hud_cust.hud_darkmode.desc"] = "Enables dark colors in HUD instead of light gray and disables vignette effect in background."
L["settings.hud_cust.cust_light.title"] = "自定义界面灯光"
L["settings.hud_cust.cust_light.desc"] = "切换灯光效果。"
L["settings.hud_cust.cust_light_brightness.title"] = "自定义灯光强度"
L["settings.hud_cust.cust_light_brightness.desc"] = "调整自定义界面的照明。\n\n不要忘记先打开灯光再看效果。"

L["settings.hud_cust.customization"] = "自定义"
L["settings.hud_cust.cust_hints.title"] = "提示"
L["settings.hud_cust.cust_hints.desc"] = "自定义菜单的键位提示。"
-- L["settings.hud_cust.cust_tips.title"] = "Tips"
-- L["settings.hud_cust.cust_tips.desc"] = "Tips about ARC9 base near hints."
L["settings.hud_cust.cust_exit_reset_sel.title"] = "退出时重置选择"
L["settings.hud_cust.cust_exit_reset_sel.desc"] = "退出自定义菜单会同时取消选择当前槽位。"
-- L["settings.hud_cust.imperial.title"] = "Imperial Measurement"
-- L["settings.hud_cust.imperial.desc"] = "Replaces various measurement systems to their Imperial variants.\nOnly affects the \"Stats & Ballistics\" customization screen."

////////////////////// Game HUD
L["settings.tabname.hud_game"] = "HUD"

L["settings.hud_game.lcd"] = "LCD 屏幕"
L["settings.hud_game.hud_arc9.title"] = "启用 HUD"
L["settings.hud_game.hud_arc9.desc"] = "ARC9 武器会显示自己的 HUD。"
L["settings.hud_game.hud_always.title"] = "HUD 全局启用"
L["settings.hud_game.hud_always.desc"] = "非 ARC9 武器也启用此 HUD。"
L["settings.hud_game.hud_compact.title"] = "精简模式"
L["settings.hud_game.hud_compact.desc"] = "精简 HUD 上的信息。"
-- L["settings.hud_game.hud_nohints.title"] = "Disable Hints"
-- L["settings.hud_game.hud_nohints.desc"] = "Disable hints completely. They will not show up in the 3D HUD, nor in the 2D HUD."
L["settings.hud_game.hud_keephints.title"] = "一直显示提示"
L["settings.hud_game.hud_keephints.desc"] = "HUD 上分的操作提示不会消失。"
-- L["settings.hud_game.hud_force_disable.title"] = "Force Disable HUD"
-- L["settings.hud_game.hud_force_disable.desc"] = "Disable ARC9 HUD for all players. Does not affect hints."

L["settings.hud_game.killfeed"] = "击杀显示"
L["settings.hud_game.killfeed_enable.title"] = "自动生成击杀菜单图标"
L["settings.hud_game.killfeed_enable.desc"] = "用模型生成 ARC9 武器的击杀图标而不是现有材质。"
L["settings.hud_game.killfeed_dynamic.title"] = "动态生成菜单图标"
L["settings.hud_game.killfeed_dynamic.desc"] = "击杀图标会自动刷新，显示当前武器配件。\n\n关掉可能影响性能。"
-- L["settings.hud_game.killfeed_colour.title"] = "Full Color Icons"
-- L["settings.hud_game.killfeed_colour.desc"] = "Dynamically generated icons are fully colored."

L["settings.hud_game.breath"] = "屏气"
L["settings.hud_game.breath_hud.title"] = "屏气条"
L["settings.hud_game.breath_hud.desc"] = "瞄准屏气时显示剩余时间。"
L["settings.hud_game.breath_pp.title"] = "屏气后处理效果"
L["settings.hud_game.breath_pp.desc"] = "启用屏气时的特殊视觉效果。"
L["settings.hud_game.breath_sfx.title"] = "屏气音效"
L["settings.hud_game.breath_sfx.desc"] = "启用屏气时的音效。"

-- L["settings.hud_game.centerhint"] = "Tooltips"
-- L["settings.hud_game.centerhint_reload.title"] = "Display Reload Tip"
-- L["settings.hud_game.centerhint_reload.desc"] = "Display a reload tip when low on ammunition."
-- L["settings.hud_game.centerhint_reload_percent.title"] = "Magazine Percentage"
-- L["settings.hud_game.centerhint_reload_percent.desc"] = "Display the reload tip when the current magazine is at this percentage value."
-- L["settings.hud_game.centerhint_bipod.title"] = "Display Toggle Bipod"
-- L["settings.hud_game.centerhint_bipod.desc"] = "Display a tip when the bipod can be toggled."
-- L["settings.hud_game.centerhint_jammed.title"] = "Display Jammed Tip"
-- L["settings.hud_game.centerhint_jammed.desc"] = "Display a tip when your weapon is jammed."

-- L["settings.hud_game.centerhint_firemode.title"] = "Display Firemode Tip"
-- L["settings.hud_game.centerhint_firemode.desc"] = "Display a tip when you swap firing mode or toggle your safety."
-- L["settings.hud_game.centerhint_firemode_time.title"] = "Display Firemode Time"
-- L["settings.hud_game.centerhint_firemode_time.desc"] = "How long the firing mode should be displayed."

-- L["settings.hud_game.centerhint_overheat.title"] = "Display Overheat Tip"
-- L["settings.hud_game.centerhint_overheat.desc"] = "Displays an overlayed tip showing how close the weapon is to overheating.\n\nNot displayed if ARC9 HUD is enabled or the weapon does not support overheat."

-- L["settings.hud_game.hud_glyph"] = "Glyph Type"

-- L["settings.hud_game.hud_glyph_type_hud.title"] = "HUD"
-- L["settings.hud_game.hud_glyph_type_hud.desc"] = "Change which family of glyphs to use.\nThis affects the HUD tips."

-- L["settings.hud_game.hud_glyph_type_cust.title"] = "Customization Menu"
-- L["settings.hud_game.hud_glyph_type_cust.desc"] = "Change which family of glyphs to use.\nThis affects the customization menu tips.\nChanges apply next time the customization menu is opened."

-- L["settings.hud_game.hud_glyph_light"] = "Light"
-- L["settings.hud_game.hud_glyph_dark"] = "Dark"
-- L["settings.hud_game.hud_glyph_knockout"] = "Knockout"

////////////////////// NPCs
L["settings.tabname.npc"] = "NPC"

L["settings.npc.weapons"] = "NPC 武器"
L["settings.npc.npc_equality.title"] = "伤害平等"
L["settings.npc.npc_equality.desc"] = "NPC 使用 ARC9 武器时造成的伤害和玩家一样。\n\n服务器参数。"
L["settings.npc.npc_spread.title"] = "NPC 散射"
L["settings.npc.npc_spread.desc"] = "NPC 的开火准度。"
L["settings.npc.npc_atts.title"] = "配置随机配件"
L["settings.npc.npc_atts.desc"] = "生成或刷出的 ARC9 武器会获得一些配件。\n\n服务器参数。"
L["settings.npc.npc_autoreplace.title"] = "替换 NPC 武器"
L["settings.npc.npc_autoreplace.desc"] = "NPC 的 HL2 武器会替换成随机 ARC9 武器。.\n\n服务器参数。"
L["settings.npc.replace_spawned.title"] = "替换地面武器"
L["settings.npc.replace_spawned.desc"] = "地图上自带和生成的 HL2 武器会替换成随机 ARC9 武器。\n\n服务器参数。"
L["settings.npc.npc_give_weapons.title"] = "玩家给予 NPC 武器"
L["settings.npc.npc_give_weapons.desc"] = "对 NPC 按使用键会把玩家的武器交给 NPC。\n\n服务器参数。"

////////////////////// Gameplay
L["settings.tabname.gameplay"] = "游戏性"

L["settings.gameplay.controls"] = "操作"
L["settings.gameplay.toggleads.title"] = "切换瞄准"
L["settings.gameplay.toggleads.desc"] = "按一次瞄准键进入或退出瞄准，而不是按住。"
L["settings.gameplay.autolean.title"] = "自动侧身"
L["settings.gameplay.autolean.desc"] = "在角落和墙壁附近瞄准会自动侧身探头。"
L["settings.gameplay.autoreload.title"] = "自动装填"
L["settings.gameplay.autoreload.desc"] = "武器如果没子弹了会立刻开始装填。"
L["settings.gameplay.togglelean.title"] = "切换侧身"
L["settings.gameplay.togglelean.desc"] = "按一下侧身键会进入或退出窥视状态，不需要按住。\n\n此设定和自动侧身兼容性很差，请不要同时开启两个。"
L["settings.gameplay.togglepeek.title"] = "切换窥视"
L["settings.gameplay.togglepeek.desc"] = "按一下窥视键会进入或退出窥视状态，不需要按住。"
-- L["settings.gameplay.togglepeek_reset.title"] = "Reset Peek State After Aiming"
-- L["settings.gameplay.togglepeek_reset.desc"] = "(Only if Toggle Peek is on)\nPeek state will not be retained when exiting aim down sights."
-- L["settings.gameplay.togglebreath.title"] = "Toggle Holding Breath"
-- L["settings.gameplay.togglebreath.desc"] = "Pressing the Holding Breath key will toggle Holding Breath instead of needing to be held down."

L["settings.gameplay.mechanics"] = "游戏机制"
L["settings.gameplay.infinite_ammo.title"] = "无限子弹"
L["settings.gameplay.infinite_ammo.desc"] = "ARC9 武器不需要消耗子弹进行装填。\n\n服务器参数。"
L["settings.gameplay.realrecoil.title"] = "视觉后坐力影响散射"
L["settings.gameplay.realrecoil.desc"] = "部分武器的开火位置会受到视觉后坐力的影响。这个设置对它们的平衡很重要。\n\n服务器参数。"
L["settings.gameplay.lean.title"] = "侧身"
L["settings.gameplay.lean.desc"] = "玩家可以使用 +alt1 和 +alt2，以及自动侧身功能，进行探头开火。\n\n服务器参数。"
L["settings.gameplay.mod_sway.title"] = "偏移"
L["settings.gameplay.mod_sway.desc"] = "部分武器会有随机偏移。\n\n服务器参数。"
L["settings.gameplay.mod_freeaim.title"] = "自由腰射"
L["settings.gameplay.mod_freeaim.desc"] = "部分武器腰射时子弹不会从屏幕中间出现，而是随着鼠标移动。\n\n服务器参数。"
L["settings.gameplay.mod_bodydamagecancel.title"] = "调整身体伤害倍率"
L["settings.gameplay.mod_bodydamagecancel.desc"] = "调整伤害抵消默认的伤害倍率。如果你的游戏模式没有这个倍率，可禁用此功能。\n\n服务器参数。"
L["settings.gameplay.breath_slowmo.title"] = "屏气慢动作"
L["settings.gameplay.breath_slowmo.desc"] = "屏气时会进入子弹时间。\n\n单人模式专用。"
L["settings.gameplay.manualbolt.title"] = "手动上膛"
L["settings.gameplay.manualbolt.desc"] = "需要单发上膛的武器需要按 R 上膛而不是自动上膛。"
L["settings.gameplay.never_ready.title"] = "禁用准备动画"
L["settings.gameplay.never_ready.desc"] = "不显示武器首次掏出的特殊动画。\n\n服务器参数。"
-- L["settings.gameplay.recoilshake.title"] = "Recoil FOV Shake"
-- L["settings.gameplay.recoilshake.desc"] = "Snaps field of view when shooting"
-- L["settings.gameplay.equipment_generate_ammo.title"] = "Unique Ammo Types for Equipment"
-- L["settings.gameplay.equipment_generate_ammo.desc"] = "There is a limit of 255 ammo types, and disabling this option may help fix some problems if you have lots of addons.\n\nThis is a server variable.\n\nRequires restart."

-- ??
-- L["settings.gameplay.mult_defaultammo.title"] = "Default Reserve Ammo"
-- L["settings.gameplay.mult_defaultammo.desc"] = "How many magazines/grenades/equipment give to player when he takes weapon for first time?\n\nThis is a server variable."
L["settings.gameplay.nearwall.title"] = "枪管近身"
L["settings.gameplay.nearwall.desc"] = "如果离墙壁或者其他东西太近时，武器会没空间开火。"

////////////////////// Visuals
L["settings.tabname.visuals"] = "视觉"

L["settings.visuals.viewmodel"] = "第一人称模型"
L["settings.visuals.vm_bobstyle.title"] = "视觉晃动效果"
L["settings.visuals.vm_bobstyle.desc"] = "可选不同 ARC9 成员（以及 Valve）配置的第一人称模型晃动，从新到旧排序。" -- developer of arc9 team -> contributors of arc9; remove mention of new to old 
L["settings.visuals.fov.title"] = "FOV"
L["settings.visuals.fov.desc"] = "缩放第一人称模型。极端数值会导致模型很怪，请妥善利用。"
L["settings.visuals.vm_addx.title"] = "X 轴偏移"
L["settings.visuals.vm_addx.desc"] = "调整第一人称模型的左右位置。"
L["settings.visuals.vm_addy.title"] = "Y 轴偏移"
L["settings.visuals.vm_addy.desc"] = "调整第一人称模型的前后位置。"
L["settings.visuals.vm_addz.title"] = "Z 轴偏移"
L["settings.visuals.vm_addz.desc"] = "调整第一人称模型的上下位置。"

-- L["settings.visuals.cambob"] = "View Bobbing"
-- L["settings.visuals.vm_cambob.title"] = "Sprint View Bobbing"
-- L["settings.visuals.vm_cambob.desc"] = "Makes your camera move when you sprinting"
-- L["settings.visuals.vm_cambobwalk.title"] = "Walk View Bobbing"
-- L["settings.visuals.vm_cambobwalk.desc"] = "Makes your camera slightly move when you walking around (requires sprint bobbing)"
-- L["settings.visuals.vm_cambobintensity.title"] = "Intensity"
-- L["settings.visuals.vm_cambobintensity.desc"] = "How intense bobbing will be"

L["settings.visuals.tpik"] = "TPIK"
L["settings.visuals.tpik.title"] = "TPIK"
L["settings.visuals.tpik.desc"] = "TPIK (第三人称逆运动动画) 可将第一人称的手部动作表现在你的第三人称角色上。"
L["settings.visuals.tpik_others.title"] = "其他玩家的 TPIK"
L["settings.visuals.tpik_others.desc"] = "可以在其他玩家身上看到第一人称动画。对性能有较大影响。"
L["settings.visuals.tpik_framerate.title"] = "TPIK 帧率"
L["settings.visuals.tpik_framerate.desc"] = "限制 TPIK 动画的帧率。设为 0 时没有上限。"

////////////////////// Bullet Physics
L["settings.tabname.bullets"] = "物理子弹"

L["settings.bullets.bullets"] = "物理子弹"
L["settings.bullets.bullet_physics.title"] = "物理子弹"
L["settings.bullets.bullet_physics.desc"] = "支持此功能的武器子弹会在世界里飞到目标点而不是在开火时立刻中弹。子弹会受到重力和阻力影响。\n\n服务器参数。"
L["settings.bullets.bullet_gravity.title"] = "重力"
L["settings.bullets.bullet_gravity.desc"] = "子弹重力倍率。\n\n服务器参数。"
L["settings.bullets.bullet_drag.title"] = "阻力"
L["settings.bullets.bullet_drag.desc"] = "子弹阻力倍率。\n\n服务器参数。"
L["settings.bullets.ricochet.title"] = "子弹反弹"
L["settings.bullets.ricochet.desc"] = "子弹打中后会根据材质，子弹属性和角度有概率改变角度继续飞行。\n\n服务器参数。"
L["settings.bullets.mod_penetration.title"] = "子弹穿透"
L["settings.bullets.mod_penetration.desc"] = "子弹打中后可以穿透一定量的材质，然后继续飞行。\n\n服务器参数。"
L["settings.bullets.bullet_lifetime.title"] = "存在时间"
L["settings.bullets.bullet_lifetime.desc"] = "子弹如果存在超过这个时间就会消失。\n\n服务器参数。"
L["settings.bullets.bullet_imaginary.title"] = "视觉子弹"
L["settings.bullets.bullet_imaginary.desc"] = "打进天空墙的子弹会生成一个假子弹继续飞行。"

////////////////////// Attachments
L["settings.tabname.attachments"] = "配件"

L["settings.attachments.customization"] = "自定义"
L["settings.attachments.atts_nocustomize.title"] = "禁用自定义"
L["settings.attachments.atts_nocustomize.desc"] = "玩家不可进行任何配件改动。\n\n服务器参数。"
L["settings.attachments.atts_max.title"] = "最大配件量"
L["settings.attachments.atts_max.desc"] = "武器最多能装的配件数量。\n\n服务器参数。"
L["settings.attachments.autosave.title"] = "自动保存"
L["settings.attachments.autosave.desc"] = "你的上一个武器配置会在获得下一把同样武器时应用。"
-- L["settings.attachments.blacklist.title"] = "Blacklist Menu"
L["settings.attachments.blacklist.open"] = "打开"

L["settings.attachments.inventory"] = "配件背包"
L["settings.attachments.free_atts.title"] = "免费配件"
L["settings.attachments.free_atts.desc"] = "不需要捡起配件实体也可以使用所有配件。\n\n服务器参数。"
L["settings.attachments.atts_lock.title"] = "捡起即解锁"
L["settings.attachments.atts_lock.desc"] = "捡起一个配件可以给多个武器配置而不消耗。\n\n服务器参数。"
L["settings.attachments.atts_loseondie.title"] = "死亡时掉落"
L["settings.attachments.atts_loseondie.desc"] = "死亡的时候配件会消失。\n\n服务器参数。"
L["settings.attachments.atts_generateentities.title"] = "生成实体"
L["settings.attachments.atts_generateentities.desc"] = "在菜单里为每个配件生成一个实体。\n\n会增加加载时间。\n\n服务器参数。"

////////////////////// Modifiers
L["settings.tabname.modifiers"] = "属性修改"

L["settings.modifiers.quick.title"] = "快捷属性修改"
L["settings.modifiers.quick.desc"] = " "

-- L["settings.mod_damage.title"] = "Damage"
-- L["settings.mod_spread.title"] = "Spread"
-- L["settings.mod_recoil.title"] = "Recoil"
-- L["settings.mod_visualrecoil.title"] = "Visual Recoil"
-- L["settings.mod_adstime.title"] = "Aim Down Sights Time"
-- L["settings.mod_sprinttime.title"] = "Sprint To Fire Time"
-- L["settings.mod_damagerand.title"] = "Damage Variance"
-- L["settings.mod_muzzlevelocity.title"] = "Muzzle Velocity"
-- L["settings.mod_rpm.title"] = "RPM"
-- L["settings.mod_headshotdamage.title"] = "Headshot Damage"
-- L["settings.mod_malfunction.title"] = "Malfunction Chance"

////////////////////// Controller
L["settings.tabname.controller"] = "手柄"

L["settings.controller.misc"] = "Misc"
L["settings.controller.misc.desc"] = "There should be button that will open panel with advanced controller config, but for now it is in  spawnmenu > Options > ARC9 > Controller."
L["settings.controller.controller.title"] = "Controller Glyphs"
L["settings.controller.controller.desc"] = "Enable custom controller-compatible glyphs, showing controller buttons instead of the default keys."
-- L["settings.controller.controller_rumble.title"] = "Rumble"
-- L["settings.controller.controller_rumble.desc"] = "Enable controller rumble as long as Fesiug's DLL mod is loaded.\n\ngithub.com/Fesiug/\ngmod-sinput"
L["settings.controller.controller_config.title"] = "Advanced config"
L["settings.controller.controller_config.content"] = "Open panel"
L["settings.controller.controller_config.desc"] = "Open advanced controller configuration panel."

-- L["settings.controller.glyphs.title"] = "Glyph Type"
-- L["settings.controller.glyphs.desc"] = "Choose which family of glyphs you want to use.\nSet up glyphs in \"Spawnmenu\" > Options > ARC9 > Controller."

////////////////////// Aim Assist
-- L["settings.tabname.aimassist"] = "Aim Assist"
-- L["settings.tabname.aimassist.desc"] = "You can enable aim assistance if you might have trouble keeping your aim on your target, or if you just prefer to not put effort into shooting your targets."

-- L["settings.aimassist.enable.title"] = "Enable Aim Assist"
-- L["settings.aimassist.enable.desc"] = "Enables an aim assistance feature that moves your aim towards a target when aiming near them.\n\nThis is a server variable.\n\nRequires Aim Assist to be enabled on CLIENT."

-- L["settings.aimassist.enable_general.desc"] = "Enables an aim assistance feature that moves your aim towards a target when aiming near them.\n\nConfigure it in the \"Aim Assist\" tab."

-- L["settings.aimassist.enable_client.desc"] = "Enables an aim assistance feature that moves your aim towards a target when aiming near them.\n\nRequires Aim Assist to be enabled on SERVER."

-- L["settings.aimassist.intensity.title"] = "Intensity"
-- L["settings.aimassist.intensity.desc"] = "How intense the aim assist is.\n\nThis is a server variable."

-- L["settings.aimassist.cone.title"] = "Cone"
-- L["settings.aimassist.cone.desc"] = "How close or far away you need to look towards a target before the aim assist engages.\n\nThis is a server variable."

-- L["settings.aimassist.head.title"] = "Lock onto head"
-- L["settings.aimassist.head.desc"] = "If the aim assist should lock onto the target's head instead of its chest.\n\nThis is a server variable."

-- L["settings.aimassist.sensmult.desc"] = "Multiply the look sensitivity by this amount when hovering over a valid target.\nThe lower the value, the lower the sensitivity."

////////////////////// Asset Caching
-- L["settings.tabname.caching"] = "Asset Caching"
-- L["settings.caching.title"] = "Asset Caching"
-- L["settings.caching.desc"] = "You can cache some ARC9 assets (save in memory without loading while playing) to prevent stutters for comfort gameplay!\n\nYou surely should enable some stuff if your gmod running on HDD."

-- L["settings.caching.precache_sounds_onfirsttake.title"] = "On first equip: Cache gun sounds"
-- L["settings.caching.precache_sounds_onfirsttake.desc"] = "Caches all sounds only from gun you just took in hands (except reload sounds).\n\nNot any impactful, rather helpful to prevent stutters while firing."

-- L["settings.caching.precache_attsmodels_onfirsttake.title"] = "On first equip: Cache all attachments"
-- L["settings.caching.precache_attsmodels_onfirsttake.desc"] = "Caches all ARC9 attachments models when any ARC9 weapon was first equipped.\n\nCauses pretty big freeze, especially when you have lots of weapons."
-- L["settings.caching.precache_wepmodels_onfirsttake.title"] = "On first equip: Cache all weapon models"
-- L["settings.caching.precache_wepmodels_onfirsttake.desc"] = "Caches all ARC9 weapons viewmodels when any ARC9 weapon was first equipped.\n\nCauses REALLY BIG freeze, especially when you have lots of weapons."

-- L["settings.caching.precache_allsounds_onstartup.title"] = "On game start: Cache all guns sounds"
-- L["settings.caching.precache_allsounds_onstartup.desc"] = "Caches all sounds from all guns on server start-up. (except reload sounds).\n\nNot so impactful, but anyway you better use first option here."
-- L["settings.caching.precache_attsmodels_onstartup.title"] = "On game start: Cache all attachments"
-- L["settings.caching.precache_attsmodels_onstartup.desc"] = "Caches all ARC9 attachments models on server start-up.\n\nCauses pretty big load time increase, especially when you have lots of weapons."
-- L["settings.caching.precache_wepmodels_onstartup.title"] = "On game start: Cache all weapon models"
-- L["settings.caching.precache_wepmodels_onstartup.desc"] = "Caches all ARC9 weapons viewmodels on server start-up.\n\nCauses REALLY BIG load time increase, especially when you have lots of weapons."

-- L["settings.caching.precache_allsounds.title"] = "All weapon sounds"
-- L["settings.caching.precache_wepmodels.title"] = "All weapon models"
-- L["settings.caching.precache_attsmodels.title"] = "All attachments models"

-- L["settings.developer.cache"] = "Cache"


////////////////////// Developer
L["settings.tabname.developer"] = "开发者"

L["settings.developer.developer"] = "开发者设置"
-- L["settings.developer.dev_always_ready.title"] = "Always Ready"
-- L["settings.developer.dev_always_ready.desc"] = "Always play \"ready\" animation when deploying a weapon.\n\n服务器参数。"
-- L["settings.developer.dev_benchgun.title"] = "Benchgun"
-- L["settings.developer.dev_benchgun.desc"] = "Keep the weapon where it currently is."
-- L["settings.developer.dev_crosshair.title"] = "Dev Crosshair"
-- L["settings.developer.dev_crosshair.desc"] = "Funky looking crosshair showing the exact point of aim and some useful numbers.\n\nThis is a server variable, and only works for admins - don't get cheaty with this!"
-- L["settings.developer.dev_show_affectors.title"] = "Display Affectors"
-- L["settings.developer.dev_show_affectors.desc"] = "Displays which current affectors are currently applied.\n\nRequires \"Dev Crosshair\"."
-- L["settings.developer.dev_show_shield.title"] = "Show Shield"
-- L["settings.developer.dev_show_shield.desc"] = "Show the model for the player's shield."
-- L["settings.developer.dev_greenscreen.title"] = "Green Screen"
-- L["settings.developer.dev_greenscreen.desc"] = "Show a green screen background in the customisation menu for screenshots.\n\nIf you are using HDR, don't forget to set mat_bloom_scalefactor_scalar to 0!"
-- L["settings.developer.reloadatts.title"] = "Reload Attachments"
-- L["settings.developer.reloadlangs.title"] = "Reload Languages"
-- L["settings.developer.dev_listmyatts.title"] = "List My Attachments"
-- L["settings.developer.dev_listanims.title"] = "List Anims"
-- L["settings.developer.dev_listbones.title"] = "List Bones"
-- L["settings.developer.dev_listbgs.title"] = "List Bodygroups"
-- L["settings.developer.dev_listatts.title"] = "List QCAttachments"
-- L["settings.developer.dev_export.title"] = "Get Export Code"
-- L["settings.developer.dev_getjson.title"] = "Get Weapon JSON"
-- L["settings.developer.presets_clear.title"] = "Clear weapon data"
-- L["settings.developer.presets_clear.desc"] = "Clear presets, all icons and default preset for weapon you currently holding.\n\nWarning: if menu opened without ARC9 weapon in hands it will delete all existing ARC9 presets and icons!"

-- L["settings.developer.clear"] = "Clear"
L["settings.developer.print"] = "Print to Console"
L["settings.developer.reload"] = "Reload"

////////////////////// ARC9 Premium
L["premium.title"] = "ARC9 Premium"
L["premium.desc"] = "ARC9 Premium 允许额外的自定义功能，以感谢用户在经济上对该插件的支持。"

L["premium.requires"] = "需要 <color=255,106,0>ARC9 Premium</color>。"
L["premium.acquire"] = "订阅 <color=255,106,0>ARC9 Premium</color>"

L["premium.ownedno"] = "<color=255,106,0>ARC9 Premium</color>: <color=255,100,100>未拥有</color>"
L["premium.owned"] = "<color=255,106,0>ARC9 Premium</color>: <color=255,100,100>已拥有</color>"

L["premium.help"] = "什么是 ARC9 Premium？"
L["premium.help.header"] = "ARC9 Premium 指南"
L["premium.help.desc"] = "创建附加组件需要时间和资源。ARC9 一直以来都是免费提供的，今后也将如此。但是，如果您希望在经济上支持基础版，您可以这样做，并因此获得奖励！"

L["premium.help.ownedbutnoaccess"] = "您是否最近购买了 ARC9 高级版，但无法自动访问？请在钻石鸽 Discord 服务器上联系我们寻求帮助。\n在联系之前，请确保您能提供购买证明。仅仅说 「我买了，现在给」是不够的。"

L["premium.content"] = "包括在 <color=255,106,0>ARC9 Premium</color> 中："
L["premium.content.list"] = [[
- 无限定制插槽（从 32 个增加到 32 个）
- 无限预设插槽（每种武器从 10 个增加到 10 个）
- 访问超级修改器设置*
- 访问独有的黑暗用户界面模式
- 可为光学视网膜、用户界面等着色
- 通过基地提供专属迷彩
- Discord 上的专属支持频道

*如果在服务器上，需要管理员帮助
]]

L["premium.payment.month"] = [[
$%s
购买 ARC9 Premium 1 个月。
]]

L["premium.payment.months"] = [[
$%s
购买 %s 个月的 ARC9 Premium，可享受 <color=100,255,100>%s%% 的折扣</color>！
]]

L["premium.payment.info"] = [[
购买 ARC9 Premium 可在购买时间内立即访问前面列出的所有内容。
您可以通过再次购买任何选项来延长时间，一旦原定时间到期，时间将自动刷新。
一旦时间过期，且未支付额外费用，ARC9 高级版的访问权限将被取消。

所有自定义选项，包括使用 ARC9 Premium 制作的附件插槽、预设和彩色视网膜仍将可用，但您将无法更改或添加任何其他选项。
]]

L["premium.purchased"] = "已购买 <color=255,106,0>ARC9 Premium</color>！"
L["premium.purchased.desc"] = [[
感谢您购买 ARC9 Premium！您让小鸟非常开心！

收据将发送到您的连接邮箱。

如果您没有立即获得 ARC9 Premium 奖励，请重新加入服务器或重启游戏。

如果您仍有问题，或仍未获得高级奖励，请访问钻石鸽 Discord 服务器并提供有效的购买证明，我们会为您修复。
]]

--PATH lua/arc9/common/sh_truenames.lua:
local truenames_enforced = GetConVar("arc9_truenames_enforced")
local truenames_default = GetConVar("arc9_truenames_default")
local truenames_preference = CLIENT and GetConVar("arc9_truenames")

--[[
    If called from the server or sv is true, returns the server truenames mode.
    If called from the client, returns the client preference if exists and is not enforced.
]]
function ARC9:UseTrueNames(sv)
    return truenames_default:GetBool()
    -- if SERVER or sv or truenames_enforced:GetBool() or truenames_preference:GetInt() == 2 then
    --     return truenames_default:GetBool()
    -- end
    -- return truenames_preference:GetBool()
end
--PATH lua/arc9/shared/sh_physbullet.lua:
return gluapack()()
--PATH lua/arc9/client/cl_autostats.lua:
return gluapack()()
--PATH lua/arc9/client/cl_bind.lua:
ARC9.KeyPressed_Menu = false

local randsound = "arc9/newui/ui_part_randomize.ogg"

hook.Add("PlayerBindPress", "ARC9_Binds", function(ply, bind, pressed, code)
    local wpn = ply:GetActiveWeapon()

    if !wpn or !IsValid(wpn) or !wpn.ARC9 then return end

    if bind == "+menu_context" then
        if !wpn:GetInSights() and !LocalPlayer():KeyDown(IN_USE) then
            -- if wpn:GetCustomize() then
            --     surface.PlaySound("arc9/newui/ui_close.ogg")
            --     net.Start("ARC9_togglecustomize")
            --     net.WriteBool(false)
            --     net.SendToServer()
            --     -- wpn:DoIconCapture()
            -- else
            --     surface.PlaySound("arc9/newui/ui_open.ogg")
            --     net.Start("ARC9_togglecustomize")
            --     net.WriteBool(true)
            --     net.SendToServer()
            -- end

            ARC9.KeyPressed_Menu = pressed

            return true
        elseif wpn:GetInSights() and !LocalPlayer():KeyDown(IN_USE) then
            return true
        end
    end

    if !pressed then return end

    if bind == "+use" and !LocalPlayer():KeyDown(IN_USE) then
        return ARC9.AttemptGiveNPCWeapon()
    end

    if bind == "+showscores" and wpn:GetCustomize() then
        if ply:KeyDown(IN_USE) then
            wpn:CycleSelectedAtt(-1)
        else
            wpn:CycleSelectedAtt(1)
        end
        return true
    end

    if bind == "impulse 100" and wpn:GetCustomize() then
        if wpn.CustomizeLastHovered and wpn.CustomizeLastHovered:IsHovered() then
            local att = wpn.CustomizeLastHovered.att
            ARC9:ToggleFavorite(att)
            if ARC9.Favorites[att] and wpn.BottomBarFolders["!favorites"] then
                wpn.BottomBarFolders["!favorites"][att] = true
            elseif wpn.BottomBarFolders["!favorites"] then
                wpn.BottomBarFolders["!favorites"][att] = nil
            end
        end
        return true
    end

    if bind == "+reload" and wpn:GetCustomize() then
        local attpnl = wpn.CustomizeLastHovered
        local foldpnl = wpn.CustomizeLastHoveredFolder
        local slotpnl = wpn.CustomizeLastHoveredSlot
        local slotpnl2 = wpn.CustomizeLastHoveredSlot2

        -- if attpnl and attpnl:IsHovered() then
            -- print("att", attpnl.att)
        -- end

        if foldpnl and foldpnl:IsHovered() then
            -- print("folder", foldpnl)

            local randompool = {}

            for _, v in ipairs(wpn.BottomBarAtts) do
                local atbl = ARC9.GetAttTable(v.att)

                local checkfolder = foldpnl.folder

                local pathprefix = string.Implode("/", wpn.BottomBarPath)
                if pathprefix != "" then checkfolder = pathprefix .. "/" .. foldpnl.folder end
                
                if atbl.Folder == checkfolder or (foldpnl.folder == "!favorites" and ARC9.Favorites[v.att]) then
                    table.insert(randompool, atbl)
                    randompool[#randompool].fuckthis = v.slot
                end               
            end

            local thatatt = randompool[math.random(0, #randompool)]
            if thatatt then
                wpn:Attach(thatatt.fuckthis, thatatt.ShortName, true)
            end

            surface.PlaySound(randsound)
        end
        
        
        if slotpnl and slotpnl.slot then
            if !wpn:GetSlotBlocked(slotpnl.slot) then
                wpn:RollRandomAtts({[1] = wpn:LocateSlotFromAddress(slotpnl.slot.Address)}, true)
                
                wpn:PruneAttachments()
                wpn:PostModify()
                wpn:SendWeapon()

                timer.Simple(0, function() wpn:CreateHUD_Bottom() end)

                surface.PlaySound(randsound)
            end
        end

        if slotpnl2 and slotpnl2.fuckinghovered then
            if !wpn:GetSlotBlocked(slotpnl2) then
                wpn:RollRandomAtts({[1] = wpn:LocateSlotFromAddress(slotpnl2.Address)}, true)
                
                wpn:PruneAttachments()
                wpn:PostModify()
                wpn:SendWeapon()

                timer.Simple(0, function() wpn:CreateHUD_Bottom() end)

                surface.PlaySound(randsound)
            end
        end

        return true
    end

    if wpn:GetInSights() then
        if bind == "invnext" then
            wpn:Scroll(1)
            wpn.Peeking = false 

            return true
        elseif bind == "invprev" then
            wpn:Scroll(-1)
            wpn.Peeking = false 

            return true
        end
    end
end)

function ARC9.GetBindKey(bind)
    local key = input.LookupBinding(bind)

    local CTRL = ARC9.ControllerMode()

    if CTRL then
        return bind
    elseif !key then
        if bind == "+zoom" then return ARC9:GetPhrase("hud.error.missingbind_zoom") end -- fucking blind stupid retards please open settings
        if bind == "+menu_context" then return ARC9:GetPhrase("hud.error.missingbind_context") end
        -- return "bind KEY " ..  bind
		
		return string.format(ARC9:GetPhrase("hud.error.missingbind"), bind)
    else
        return string.upper(key)
    end
end

function ARC9.GetKeyIsBound(bind)
    local key = input.LookupBinding(bind)

    if !key then
        return false
    else
        return true
    end
end

function ARC9.GetKey(bind)
    local key = input.LookupBinding(bind)

    return input.GetKeyCode(key)
end

ARC9.KeyPressed_Melee = false
ARC9.KeyPressed_UBGL = false
ARC9.KeyPressed_Inspect = false
ARC9.KeyPressed_SwitchSights = false

concommand.Add("+arc9_melee", function()
    ARC9.KeyPressed_Melee = true
end)

concommand.Add("-arc9_melee", function()
    ARC9.KeyPressed_Melee = false
end)

concommand.Add("+arc9_ubgl", function()
    ARC9.KeyPressed_UBGL = true
end)

concommand.Add("-arc9_ubgl", function()
    ARC9.KeyPressed_UBGL = false
end)

concommand.Add("+arc9_inspect", function()
    ARC9.KeyPressed_Inspect = true
end)

concommand.Add("-arc9_inspect", function()
    ARC9.KeyPressed_Inspect = false
end)

concommand.Add("+arc9_switchsights", function()
    ARC9.KeyPressed_SwitchSights = true
end)

concommand.Add("-arc9_switchsights", function()
    ARC9.KeyPressed_SwitchSights = false
end)
--PATH lua/arc9/client/cl_font.lua:
return gluapack()()
--PATH lua/arc9/client/cl_hudbob.lua:
local hud_notonground = 0
local hud_velocity = 0
local bobct = 0
local lastctmath = 0

function ARC9.HUDBob(pos, ang)
    local step = 10
    local mag = 0.25
    local ts = 0 -- self:GetTraversalSprintAmount()
    -- ts = 1

    local lp = LocalPlayer()
    local ft = FrameTime()

    local v = lp:GetVelocity():Length()
    v = math.Clamp(v, 0, 350)
    hud_velocity = v
    local d = math.Clamp(hud_velocity / 350, 0, 1)

    if lp:OnGround() and lp:GetMoveType() != MOVETYPE_NOCLIP then
        hud_notonground = math.Approach(hud_notonground, 0, ft / 0.1)
    else
        hud_notonground = math.Approach(hud_notonground, 1, ft / 0.1)
    end

    mag = mag * d
    step = 10

    -- ang:RotateAroundAxis(ang:Forward(), math.sin(bobct * step * 0.5) * ((math.sin(CurTime() * 6.151) * 0.2) + 1) * 4.5 * d)
    -- ang:RotateAroundAxis(ang:Right(), math.sin(bobct * step * 0.12) * ((math.sin(CurTime() * 1.521) * 0.2) + 1) * 2.11 * d)
    pos = pos - (ang:Forward() * math.sin(bobct * step * 0.35) * 0.25 * mag)
    -- pos = pos + (ang:Forward() * math.sin(bobct * step * 0.3) * 0.11 * ((math.sin(CurTime() * 2) * ts * 1.25) + 1) * ((math.sin(CurTime() * 1.615) * 0.2) + 1) * mag)
    pos = pos + (ang:Right() * (math.sin(bobct * step * 0.9) * 0.25 * mag))

    local steprate = Lerp(d, 1, 2.5)

    steprate = Lerp(hud_notonground, steprate, 0.25)

    if IsFirstTimePredicted() or game.SinglePlayer() then
        local ctt = CurTime()
        if lastctmath != ctt then
            lastctmath = ctt
            bobct = bobct + (ft * steprate)
        end
    end

    return pos, ang
end

local lasteyeangles = Angle(0, 0, 0)
local hudsway = Angle(0, 0, 0)

function ARC9.HUDSway(pos, ang)
    hudsway = hudsway + (0.75 * Angle(math.AngleDifference(lasteyeangles[1], EyeAngles()[1]) * FrameTime(), math.AngleDifference(lasteyeangles[2], EyeAngles()[2]) * FrameTime(), 0))

    hudsway[1] = math.Clamp(math.NormalizeAngle(hudsway[1]), -2, 2)
    hudsway[2] = math.Clamp(math.NormalizeAngle(hudsway[2]), -2, 2)

    pos = pos + ang:Right() * hudsway[1]
    pos = pos + ang:Forward() * -hudsway[2] * 1.25

    hudsway = LerpAngle(0.2, hudsway, angle_zero)

    lasteyeangles = EyeAngles()

    return pos, ang
end
--PATH lua/arc9/client/cl_killicons.lua:
return gluapack()()
--PATH lua/arc9/client/cl_move.lua:
return gluapack()()
--PATH lua/autorun/sh_cami.lua:
return gluapack()()
--PATH lua/pixelui/core/cl_color.lua:
--[[
	PIXEL UI - Copyright Notice
	© 2023 Thomas O'Sullivan - All rights reserved

	This program is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program.  If not, see <https://www.gnu.org/licenses/>.
--]]

do
    local format = string.format
    function PIXEL.DecToHex(dec, zeros)
        return format("%0" .. (zeros or 2) .. "x", dec)
    end

    local max = math.max
    local min = math.min
    function PIXEL.ColorToHex(color)
        return format("#%02X%02X%02X",
            max(min(color.r, 255), 0),
            max(min(color.g, 255), 0),
            max(min(color.b, 255), 0)
        )
    end
end

function PIXEL.ColorToHSL(col)
    local r = col.r / 255
    local g = col.g / 255
    local b = col.b / 255
    local max, min = math.max(r, g, b), math.min(r, g, b)
    b = max + min

    local h = b / 2
    if max == min then return 0, 0, h end

    local s, l = h, h
    local d = max - min
    s = l > .5 and d / (2 - b) or d / b

    if max == r then
        h = (g - b) / d + (g < b and 6 or 0)
    elseif max == g then
        h = (b - r) / d + 2
    elseif max == b then
        h = (r - g) / d + 4
    end

    return h * .16667, s, l
end

local createColor = Color
do
    local function hueToRgb(p, q, t)
        if t < 0 then t = t + 1 end
        if t > 1 then t = t - 1 end
        if t < 1 / 6 then return p + (q - p) * 6 * t end
        if t < 1 / 2 then return q end
        if t < 2 / 3 then return p + (q - p) * (2 / 3 - t) * 6 end
        return p
    end

    function PIXEL.HSLToColor(h, s, l, a)
        local r, g, b
        local t = h / (2 * math.pi)

        if s == 0 then
            r, g, b = l, l, l
        else
            local q
            if l < 0.5 then
                q = l * (1 + s)
            else
                q = l + s - l * s
            end

            local p = 2 * l - q
            r = hueToRgb(p, q, t + 1 / 3)
            g = hueToRgb(p, q, t)
            b = hueToRgb(p, q, t - 1 / 3)
        end

        return createColor(r * 255, g * 255, b * 255, (a or 1) * 255)
    end
end

function PIXEL.CopyColor(col)
    return createColor(col.r, col.g, col.b, col.a)
end

function PIXEL.OffsetColor(col, offset)
    return createColor(col.r + offset, col.g + offset, col.b + offset)
end

do
    local match = string.match
    local tonumber = tonumber

    function PIXEL.HexToColor(hex)
        local r, g, b = match(hex, "#(..)(..)(..)")
        return createColor(
            tonumber(r, 16),
            tonumber(g, 16),
            tonumber(b, 16)
        )
    end
end

do
    local curTime = CurTime
    local hsvToColor = HSVToColor

    local lastUpdate = 0
    local lastCol = createColor(0, 0, 0)

    function PIXEL.GetRainbowColor()
        local time = curTime()
        if lastUpdate == time then return lastCol end

        lastUpdate = time
        lastCol = hsvToColor((time * 50) % 360, 1, 1)

        return lastCol
    end
end

do
    local colorToHSL = ColorToHSL

    function PIXEL.IsColorLight(col)
        local _, _, lightness = colorToHSL(col)
        return lightness >= .5
    end
end

function PIXEL.LerpColor(t, from, to)
    return createColor(from.r, from.g, from.b, from.a):Lerp(to, t)
end

function PIXEL.IsColorEqualTo(from, to)
    return from.r == to.r and from.g == to.g and from.b == to.b and from.a == to.a
end

local colorMeta = FindMetaTable("Color")
colorMeta.Copy = PIXEL.CopyColor
colorMeta.IsLight = PIXEL.IsColorLight
colorMeta.EqualTo = PIXEL.IsColorEqualTo

function colorMeta:Offset(offset)
    self.r = self.r + offset
    self.g = self.g + offset
    self.b = self.b + offset
    return self
end

-- Combatibility for versions before 2024.06.28
if not colorMeta.Lerp then
    local lerp = Lerp
    local isColor = IsColor
    local deprecation_warning_shown = false
    function colorMeta:Lerp(target, fraction)
        if isColor(fraction) then
            -- Don't break addons using this based on Pixel UI for now.
            local rememberFraction = fraction
            fraction = target
            target = rememberFraction

            if not deprecation_warning_shown then
                deprecation_warning_shown = true
                -- Scream at them at least once though, should be fine to keep this backwards compatibility until the update. 
                ErrorNoHaltWithStack("Deprecated PIXEL-UI Color:Lerp(fraction, target) is used.")
            end
        end

        self.r = lerp(fraction, self.r, target.r)
        self.g = lerp(fraction, self.g, target.g)
        self.b = lerp(fraction, self.b, target.b)
        self.a = lerp(fraction, self.a, target.a)
        return self
    end
end

--PATH lua/pixelui/core/cl_images.lua:
--[[
	PIXEL UI - Copyright Notice
	© 2023 Thomas O'Sullivan - All rights reserved

	This program is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program.  If not, see <https://www.gnu.org/licenses/>.
--]]

local materials = {}
local queue = {}

local useProxy = false

file.CreateDir(PIXEL.DownloadPath)

local function endsWithExtension(str)
    local fileName = str:match(".+/(.-)$")
    if not fileName then
        return false
    end
    local extractedExtension = fileName and fileName:match("^.+(%..+)$")

    return extractedExtension and string.sub(str, -#extractedExtension) == extractedExtension or false
end

local function processQueue()
    if queue[1] then
        local url, filePath, matSettings, callback = unpack(queue[1])

        http.Fetch((useProxy and ("https://proxy.duckduckgo.com/iu/?u=" .. url)) or url,
            function(body, len, headers, code)
                if len > 2097152 or code ~= 200 then
                    materials[filePath] = Material("nil")
                else
                    local writeFilePath = filePath
                    if not endsWithExtension(filePath) then
                        writeFilePath = filePath .. ".png"
                    end

                    file.Write(writeFilePath, body)
                    materials[filePath] = Material("../data/" .. writeFilePath, matSettings or "noclamp smooth mips")
                end

                callback(materials[filePath])
            end,
            function(error)
                if useProxy then
                    materials[filePath] = Material("nil")
                    callback(materials[filePath])
                else
                    useProxy = true
                    processQueue()
                end
            end
        )
    end
end

function PIXEL.GetImage(url, callback, matSettings)
    local protocol = url:match("^([%a]+://)")

    local hasTrailingSlash = url:sub(-1) == "/"
    local urlWithoutTrailingSlash = url
    if hasTrailingSlash then
        urlWithoutTrailingSlash = url:sub(1, -2)
    end

    local fileNameStart = urlWithoutTrailingSlash:find("[^/]+$")
    if not fileNameStart then
        return
    end

    local urlWithoutProtocol = url
    if not protocol then
        protocol = "http://"
    else
        urlWithoutProtocol = string.gsub(urlWithoutTrailingSlash, protocol, "")
    end

    local urlWithoutFileName = urlWithoutTrailingSlash:sub(protocol:len() + 1, fileNameStart - 1)

    local dirPath = PIXEL.DownloadPath .. urlWithoutFileName
    local filePath = PIXEL.DownloadPath .. urlWithoutProtocol

    file.CreateDir(dirPath)

    local readFilePath = filePath
    if not endsWithExtension(filePath) and file.Exists(filePath .. ".png", "DATA") then
        readFilePath = filePath .. ".png"
    end

    if materials[filePath] then
        callback(materials[filePath])
    elseif file.Exists(readFilePath, "DATA") then
        materials[filePath] = Material("../data/" .. readFilePath, matSettings or "noclamp smooth mips")
        callback(materials[filePath])
    else
        table.insert(queue, {
            url,
            filePath,
            matSettings,
            function(mat)
                callback(mat)
                table.remove(queue, 1)
                processQueue()
            end
        })

        if #queue == 1 then
            processQueue()
        end
    end
end


function PIXEL.GetImgur(id, callback, _, matSettings)
    local url = "https://i.imgur.com/" .. id .. ".png"
    PIXEL.GetImage(url, callback, matSettings)
end

--PATH lua/pixelui/drawing/cl_overheads.lua:
--[[
	PIXEL UI - Copyright Notice
	© 2023 Thomas O'Sullivan - All rights reserved

	This program is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program.  If not, see <https://www.gnu.org/licenses/>.
--]]

PIXEL.RegisterFontUnscaled("UI.Overhead", "Open Sans Bold", 100)

local localPly
local function checkDistance(ent)
    if not IsValid(localPly) then localPly = LocalPlayer() end
    if localPly:GetPos():DistToSqr(ent:GetPos()) > 200000 then return true end
end

local disableClipping = DisableClipping
local start3d2d, end3d2d = cam.Start3D2D, cam.End3D2D
local Icon = icon

local function drawOverhead(ent, pos, text, ang, scale)
    if ang then
        ang = ent:LocalToWorldAngles(ang)
    else
        ang = (pos - localPly:GetPos()):Angle()
        ang:SetUnpacked(0, ang[2] - 90, 90)
    end

    PIXEL.SetFont("UI.Overhead")
    local w, h = PIXEL.GetTextSize(text)
    w = w + 40
    h = h + 6

    local x, y = -(w * .5), -h

    local oldClipping = disableClipping(true)

    start3d2d(pos, ang, scale or 0.05)
    if not Icon then
        PIXEL.DrawRoundedBox(12, x, y, w, h, PIXEL.Colors.Primary)
        PIXEL.DrawText(text, "UI.Overhead", 0, y + 1, PIXEL.Colors.PrimaryText, TEXT_ALIGN_CENTER)
    else
        x = x - 40
        PIXEL.DrawRoundedBox(12, x, y, h, h, PIXEL.Colors.Primary)
        PIXEL.DrawRoundedBoxEx(12, x + (h - 12), y + h - 20, w + 15, 20, PIXEL.Colors.Primary, false, false, false, true)
        PIXEL.DrawText(text, "UI.Overhead", x + h + 15, y + 8, PIXEL.Colors.PrimaryText)
        PIXEL.DrawImage(x + 10, y + 10, h - 20, h - 20, Icon, color_white)
    end
    end3d2d()

    disableClipping(oldClipping)
end

local entOffset = 2
function PIXEL.DrawEntOverhead(ent, text, angleOverride, posOverride, scaleOverride)
    if checkDistance(ent) then return end

    if posOverride then
        drawOverhead(ent, ent:LocalToWorld(posOverride), text, angleOverride, scaleOverride)
        return
    end

    local pos = ent:OBBMaxs()
    pos:SetUnpacked(0, 0, pos[3] + entOffset)

    drawOverhead(ent, ent:LocalToWorld(pos), text, angleOverride, scaleOverride)
end

local eyeOffset = Vector(0, 0, 7)
local fallbackOffset = Vector(0, 0, 73)
function PIXEL.DrawNPCOverhead(ent, text, angleOverride, offsetOverride, scaleOverride)
    if checkDistance(ent) then return end

    local eyeId = ent:LookupAttachment("eyes")
    if eyeId then
        local eyes = ent:GetAttachment(eyeId)
        if eyes then
            eyes.Pos:Add(offsetOverride or eyeOffset)
            drawOverhead(ent, eyes.Pos, text, angleOverride, scaleOverride)
            return
        end
    end

    drawOverhead(ent, ent:GetPos() + fallbackOffset, text, angleOverride, scaleOverride)
end

function PIXEL.EnableIconOverheads(new)
    local oldIcon = Icon
    local imgurMatch = (new or ""):match("^[a-zA-Z0-9]+$")
    if imgurMatch then
        new = "https://i.imgur.com/" .. new .. ".png"
    end
    Icon = new
    return oldIcon
end
--PATH lua/pixelui/drawing/cl_rounded_box.lua:
--[[
	PIXEL UI - Copyright Notice
	© 2023 Thomas O'Sullivan - All rights reserved

	This program is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program.  If not, see <https://www.gnu.org/licenses/>.
--]]

local cornerTex8 = surface.GetTextureID("gui/corner8")
local cornerTex16 = surface.GetTextureID("gui/corner16")
local cornerTex32 = surface.GetTextureID("gui/corner32")
local cornerTex64 = surface.GetTextureID("gui/corner64")
local cornerTex512 = surface.GetTextureID("gui/corner512")

local round = math.Round
local min = math.min
local floor = math.floor

local setDrawColor = surface.SetDrawColor
local drawRect = surface.DrawRect
local drawTexturedRectUV = surface.DrawTexturedRectUV
local setTexture = surface.SetTexture

function PIXEL.DrawRoundedBoxEx(borderSize, x, y, w, h, col, topLeft, topRight, bottomLeft, bottomRight)
	setDrawColor(col.r, col.g, col.b, col.a)

	if borderSize <= 0 then
		drawRect(x, y, w, h)
		return
	end

	x = round(x)
	y = round(y)
	w = round(w)
	h = round(h)
	borderSize = min(round(borderSize), floor(w / 2))

	drawRect(x + borderSize, y, w - borderSize * 2, h)
	drawRect(x, y + borderSize, borderSize, h - borderSize * 2)
	drawRect(x + w - borderSize, y + borderSize, borderSize, h - borderSize * 2)

	local tex = cornerTex8
	if borderSize > 8 then tex = cornerTex16 end
	if borderSize > 16 then tex = cornerTex32 end
	if borderSize > 32 then tex = cornerTex64 end
	if borderSize > 64 then tex = cornerTex512 end

	setTexture(tex)

	if topLeft then
		drawTexturedRectUV(x, y, borderSize, borderSize, 0, 0, 1, 1)
	else
		drawRect(x, y, borderSize, borderSize)
	end

	if topRight then
		drawTexturedRectUV(x + w - borderSize, y, borderSize, borderSize, 1, 0, 0, 1)
	else
		drawRect(x + w - borderSize, y, borderSize, borderSize)
	end

	if bottomLeft then
		drawTexturedRectUV(x, y + h -borderSize, borderSize, borderSize, 0, 1, 1, 0)
	else
		drawRect(x, y + h - borderSize, borderSize, borderSize)
	end

	if bottomRight then
		drawTexturedRectUV(x + w - borderSize, y + h - borderSize, borderSize, borderSize, 1, 1, 0, 0)
	else
		drawRect(x + w - borderSize, y + h - borderSize, borderSize, borderSize)
	end
end

local drawRoundedBoxEx = PIXEL.DrawRoundedBoxEx
function PIXEL.DrawRoundedBox(borderSize, x, y, w, h, col)
	return drawRoundedBoxEx(borderSize, x, y, w, h, col, true, true, true, true)
end

local roundedBoxCache = {}
local whiteTexture = surface.GetTextureID("vgui/white")

local drawPoly = surface.DrawPoly

function PIXEL.DrawFullRoundedBoxEx(borderSize, x, y, w, h, col, tl, tr, bl, br)
	setDrawColor(col.r, col.g, col.b, col.a)

	if borderSize <= 0 then
		drawRect(x, y, w, h)
		return
	end

	local fullRight = x + w
	local fullBottom = y + h

	local left, right = x + borderSize, fullRight - borderSize
	local top, bottom = y + borderSize, fullBottom - borderSize

	local halfBorder = borderSize * .7

	local cacheName = borderSize .. x .. y .. w .. h
	local cache = roundedBoxCache[cacheName]
	if not cache then
		cache = {
			{x = right, y = y}, --Top Right
			{x = right + halfBorder, y = top - halfBorder},
			{x = fullRight, y = top},

			{x = fullRight, y = bottom}, --Bottom Right
			{x = right + halfBorder, y = bottom + halfBorder},
			{x = right, y = fullBottom},

			{x = left, y = fullBottom}, --Bottom Left
			{x = left - halfBorder, y = bottom + halfBorder},
			{x = x, y = bottom},

			{x = x, y = top}, --Top Left
			{x = left - halfBorder, y = top - halfBorder},
			{x = left, y = y}
		}

		roundedBoxCache[cacheName] = cache
	end

	setTexture(whiteTexture)
	drawPoly(cache)

	if not tl then drawRect(x, y, borderSize, borderSize) end
	if not tr then drawRect(x + w - borderSize, y, borderSize, borderSize) end
	if not bl then drawRect(x, y + h - borderSize, borderSize, borderSize) end
	if not br then drawRect(x + w - borderSize, y + h - borderSize, borderSize, borderSize) end
end

function PIXEL.DrawFullRoundedBox(borderSize, x, y, w, h, col)
	return PIXEL.DrawFullRoundedBoxEx(borderSize, x, y, w, h, col, true, true, true, true)
end
--PATH lua/pixelui/elements/cl_image_button.lua:
return gluapack()()
--PATH lua/pixelui/elements/cl_navbar.lua:
return gluapack()()
--PATH lua/pixelui/elements/cl_scrollbar.lua:
--[[
	PIXEL UI - Copyright Notice
	© 2023 Thomas O'Sullivan - All rights reserved

	This program is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program.  If not, see <https://www.gnu.org/licenses/>.
--]]

local PANEL = {}

function PANEL:Init()
    self.NormalCol = PIXEL.Colors.Scroller
    self.HoverCol = PIXEL.OffsetColor(self.NormalCol, 15)

    self.Colour = PIXEL.CopyColor(self.NormalCol)
end

function PANEL:OnMousePressed()
    self:GetParent():Grip(1)
end

function PANEL:Paint(w, h)
    self.Colour = PIXEL.LerpColor(FrameTime() * 12, self.Colour,
        (self:IsHovered() or self:GetParent().Dragging) and self.HoverCol or self.NormalCol
    )

    PIXEL.DrawRoundedBox(w / 2, 0, 0, w, h, self.Colour)
end

vgui.Register("PIXEL.ScrollbarGrip", PANEL, "Panel")

PANEL = {}

AccessorFunc(PANEL, "m_bVisibleFullHeight", "VisibleFullHeight", FORCE_BOOL)

function PANEL:Init()
    self.Offset = 0
    self.Scroll = 0
    self.CanvasSize = 1
    self.BarSize = 1

    self.BackgroundCol = PIXEL.OffsetColor(PIXEL.Colors.Background, 5)

    self.Scrollbar = vgui.Create("PIXEL.ScrollbarGrip", self)
    self:SetVisibleFullHeight(false)
end

function PANEL:SetEnabled(b)
    if not b then
        self.Offset = 0
        self:SetScroll(0)
        self.HasChanged = true
    end

    self:SetMouseInputEnabled(b)

    if not self:GetVisibleFullHeight() then
        self:SetVisible(b)
    end

    if self.Enabled != b then
        self:GetParent():InvalidateLayout()

        if self:GetParent().OnScrollbarAppear then
            self:GetParent():OnScrollbarAppear()
        end
    end

    self.Enabled = b
end

function PANEL:GetEnabled()
    return self.Enabled
end

function PANEL:Value()
    return self.Pos
end

function PANEL:BarScale()
    if self.BarSize == 0 then return 1 end
    return self.BarSize / (self.CanvasSize + self.BarSize)
end

function PANEL:SetUp(barSize, canvasSize)
    self.BarSize = barSize
    self.CanvasSize = math.max(canvasSize - barSize, 1)

    self:SetEnabled(canvasSize > barSize)

    self:InvalidateLayout()
end

function PANEL:OnMouseWheeled(dlta)
    if not self:IsVisible() then return false end
    return self:AddScroll(dlta * -2)
end

function PANEL:AddScroll(dlta)
    local oldScroll = self:GetScroll()

    dlta = dlta * 25
    self:SetScroll(oldScroll + dlta)

    return oldScroll != self:GetScroll()
end

function PANEL:SetScroll(scrll)
    if not self.Enabled then self.Scroll = 0 return end

    self.Scroll = math.Clamp(scrll, 0, self.CanvasSize + 75)

    self:InvalidateLayout()

    local func = self:GetParent().OnVScroll
    if func then
        func(self:GetParent(), self:GetOffset())
    else
        self:GetParent():InvalidateLayout()
    end
end

function PANEL:LimitScroll()
    if self.Scroll < 0 or self.Scroll > self.CanvasSize then
        self.Scroll = math.Clamp(self.Scroll, -75, self.CanvasSize + 75)
    end
end

function PANEL:AnimateTo(scrll, length, delay, ease)
    local anim = self:NewAnimation(length, delay, ease)
    anim.StartPos = self.Scroll
    anim.TargetPos = scrll
    anim.Think = function(an, pnl, fraction)
        pnl:SetScroll(Lerp(fraction, an.StartPos, an.TargetPos))
    end
end

function PANEL:GetScroll()
    if not self.Enabled then self.Scroll = 0 end
    return self.Scroll
end

function PANEL:GetOffset()
    if not self.Enabled then return 0 end
    return self.Scroll * -1
end

function PANEL:Think() end

function PANEL:OnMousePressed()
    if select(2, self:CursorPos()) > self.Scrollbar.y then
        self:SetScroll(self:GetScroll() + self.BarSize)
    else
        self:SetScroll(self:GetScroll() - self.BarSize)
    end
end

function PANEL:OnMouseReleased()
    self.Dragging = false
    self.DraggingCanvas = nil
    self:MouseCapture(false)

    self.Scrollbar.Depressed = false
end

function PANEL:OnCursorMoved(x, y)
    if not self.Enabled or not self.Dragging then return end

    y = select(2, self:ScreenToLocal(0, gui.MouseY())) - self.HoldPos

    local trackSize = self:GetTall() - self.Scrollbar:GetTall()
    y = y / trackSize

    self:SetScroll(math.Clamp(y * self.CanvasSize, 0, self.CanvasSize))
end

function PANEL:Grip()
    if not self.Enabled or self.BarSize == 0 then return end

    self:MouseCapture(true)
    self.Dragging = true

    self.HoldPos = select(2, self.Scrollbar:ScreenToLocal(x, gui.MouseY()))

    self.Scrollbar.Depressed = true
end

function PANEL:PerformLayout(w, h)
    self:LimitScroll()

    local scroll = self:GetScroll() / self.CanvasSize
    local barSize = math.max(self:BarScale() * self:GetTall(), 10)
    local track = self:GetTall() - barSize
    track = track + 1

    scroll = scroll * track

    local barStart = math.max(scroll, 0)
    local barEnd = math.min(scroll + barSize, self:GetTall())

    self.Scrollbar:SetPos(0, barStart)
    self.Scrollbar:SetSize(w, barEnd - barStart)
end

function PANEL:Paint(w, h)
    PIXEL.DrawRoundedBox(w / 2, 0, 0, w, h, self.BackgroundCol)
end

vgui.Register("PIXEL.Scrollbar", PANEL, "Panel")
--PATH lua/pixelui/elements/cl_text_button.lua:
return gluapack()()
--PATH lua/pixelui/elements/cl_text_entry.lua:
--[[
	PIXEL UI - Copyright Notice
	© 2023 Thomas O'Sullivan - All rights reserved

	This program is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program.  If not, see <https://www.gnu.org/licenses/>.
--]]

local PANEL = {}

function PANEL:Init()
    self.TextEntry = vgui.Create("PIXEL.TextEntryInternal", self)

    self.PlaceholderTextCol = PIXEL.OffsetColor(PIXEL.Colors.SecondaryText, -110)

    self.DisabledCol = PIXEL.OffsetColor(PIXEL.Colors.Background, 6)
    self.FocusedOutlineCol = PIXEL.Colors.PrimaryText

    self.OutlineCol = PIXEL.OffsetColor(PIXEL.Colors.Scroller, 10)
    self.InnerOutlineCol = PIXEL.CopyColor(PIXEL.Colors.Transparent)
end

function PANEL:PerformLayout(w, h)
    self.TextEntry:Dock(FILL)

    local xPad, yPad = PIXEL.Scale(4), PIXEL.Scale(8)
    self:DockPadding(xPad, yPad, xPad, yPad)
end

function PANEL:Paint(w, h)
    if not self:IsEnabled() then
        PIXEL.DrawRoundedBox(PIXEL.Scale(4), 0, 0, w, h, self.DisabledCol)
        PIXEL.DrawSimpleText("Disabled", self:GetFont(), PIXEL.Scale(4), h / 2, PIXEL.Colors.SecondaryText, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
        return
    end

    if self:GetValue() == "" then
        local placeholderY = self:IsMultiline() and draw.GetFontHeight(self:GetFont()) or h / 2
        PIXEL.DrawSimpleText(self:GetPlaceholderText() or "", self:GetFont(), PIXEL.Scale(10), placeholderY, self.PlaceholderTextCol, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
    end

    local outlineThickness = PIXEL.Scale(1)
    PIXEL.DrawOutlinedRoundedBox(PIXEL.Scale(2), 0, 0, w, h, self.OutlineCol, outlineThickness)

    local col = PIXEL.Colors.Transparent

    if self:IsEditing() then
        col = self.FocusedOutlineCol
    end

    if self.OverrideCol then
        col = self.OverrideCol
    end

    self.InnerOutlineCol = PIXEL.LerpColor(FrameTime() * 8, self.InnerOutlineCol, col)

    PIXEL.DrawOutlinedRoundedBox(PIXEL.Scale(2), outlineThickness, outlineThickness, w - outlineThickness * 2, h - outlineThickness * 2, self.InnerOutlineCol, PIXEL.Scale(1))
end

function PANEL:OnChange() end
function PANEL:OnValueChange(value) end

function PANEL:IsEnabled() return self.TextEntry:IsEnabled() end
function PANEL:SetEnabled(enabled) self.TextEntry:SetEnabled(enabled) end

function PANEL:GetValue() return self.TextEntry:GetValue() end
function PANEL:SetValue(value) self.TextEntry:SetValue(value) end

function PANEL:IsMultiline() return self.TextEntry:IsMultiline() end
function PANEL:SetMultiline(isMultiline) self.TextEntry:SetMultiline(isMultiline) end

function PANEL:IsEditing() return self.TextEntry:IsEditing() end

function PANEL:GetEnterAllowed() return self.TextEntry:GetEnterAllowed() end
function PANEL:SetEnterAllowed(allow) self.TextEntry:SetEnterAllowed(allow) end

function PANEL:GetUpdateOnType() return self.TextEntry:GetUpdateOnType() end
function PANEL:SetUpdateOnType(enabled) self.TextEntry:SetUpdateOnType(enabled) end

function PANEL:GetNumeric() return self.TextEntry:GetNumeric() end
function PANEL:SetNumeric(enabled) self.TextEntry:SetNumeric(enabled) end

function PANEL:GetHistoryEnabled() return self.TextEntry:GetHistoryEnabled() end
function PANEL:SetHistoryEnabled(enabled) self.TextEntry:SetHistoryEnabled(enabled) end

function PANEL:GetTabbingDisabled() return self.TextEntry:GetTabbingDisabled() end
function PANEL:SetTabbingDisabled(disabled) self.TextEntry:SetTabbingDisabled(disabled) end

function PANEL:GetPlaceholderText() return self.TextEntry:GetPlaceholderText() end
function PANEL:SetPlaceholderText(text) self.TextEntry:SetPlaceholderText(text) end

function PANEL:GetFont() return self.TextEntry:GetFont() end
function PANEL:SetFont(font) self.TextEntry:SetFontInternal(font) end

function PANEL:GetInt() return self.TextEntry:GetInt() end
function PANEL:GetFloat() return self.TextEntry:GetFloat() end

function PANEL:IsEditing() return self.TextEntry:IsEditing() end
function PANEL:SetEditable(enabled) self.TextEntry:SetEditable(enabled) end

function PANEL:AllowInput(value) end
function PANEL:GetAutoComplete(txt) end

function PANEL:OnKeyCode(code) end
function PANEL:OnEnter() end

function PANEL:OnGetFocus() end
function PANEL:OnLoseFocus() end

vgui.Register("PIXEL.TextEntry", PANEL, "Panel")
--PATH lua/pixelui/libraries/cl_arc.lua:
--https://gist.github.com/theawesomecoder61/d2c3a3d42bbce809ca446a85b4dda754

-- Draws an arc on your screen.
-- startang and endang are in degrees, 
-- radius is the total radius of the outside edge to the center.
-- cx, cy are the x,y coordinates of the center of the arc.
-- roughness determines how many triangles are drawn. Number between 1-360; 2 or 3 is a good number.
function PIXEL.DrawUncachedArc(cx, cy, radius, thickness, startang, endang, roughness, color)
    surface.SetDrawColor(color)
    PIXEL.DrawArc(PIXEL.PrecacheArc(cx, cy, radius, thickness, startang, endang, roughness))
end

function PIXEL.PrecacheArc(cx, cy, radius, thickness, startang, endang, roughness)
    local triarc = {}
    -- local deg2rad = math.pi / 180
    -- Define step
    roughness = math.max(roughness or 1, 1)
    local step = roughness
    -- Correct start/end ang
    startang, endang = startang or 0, endang or 0
    endang = startang + endang

    if startang > endang then
        step = math.abs(step) * -1
    end

    -- Create the inner circle's points.
    local inner = {}
    local r = radius - thickness

    for deg = startang, endang, step do
        local rad = math.rad(deg)
        -- local rad = deg2rad * deg
        local ox, oy = cx + (math.cos(rad) * r), cy + (-math.sin(rad) * r)

        table.insert(inner, {
            x = ox,
            y = oy,
            u = (ox - cx) / radius + .5,
            v = (oy - cy) / radius + .5
        })
    end

    -- Create the outer circle's points.
    local outer = {}

    for deg = startang, endang, step do
        local rad = math.rad(deg)
        -- local rad = deg2rad * deg
        local ox, oy = cx + (math.cos(rad) * radius), cy + (-math.sin(rad) * radius)

        table.insert(outer, {
            x = ox,
            y = oy,
            u = (ox - cx) / radius + .5,
            v = (oy - cy) / radius + .5
        })
    end

    -- Triangulize the points.
    -- twice as many triangles as there are degrees.
    for tri = 1, #inner * 2 do
        local p1, p2, p3
        p1 = outer[math.floor(tri / 2) + 1]
        p3 = inner[math.floor((tri + 1) / 2) + 1]

        --if the number is even use outer.
        if tri % 2 == 0 then
            p2 = outer[math.floor((tri + 1) / 2)]
        else
            p2 = inner[math.floor((tri + 1) / 2)]
        end

        table.insert(triarc, {p1, p2, p3})
    end
    -- Return a table of triangles to draw.

    return triarc
end

--Draw a premade arc.
function PIXEL.DrawArc(arc)
    for k, v in ipairs(arc) do
        surface.DrawPoly(v)
    end
end

--PATH lua/pixelui/menus/cl_query_popup.lua:
--[[
	PIXEL UI - Copyright Notice
	© 2023 Thomas O'Sullivan - All rights reserved

	This program is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program.  If not, see <https://www.gnu.org/licenses/>.
--]]

local PANEL = {}

AccessorFunc(PANEL, "Text", "Text", FORCE_STRING)
AccessorFunc(PANEL, "ButtonText", "ButtonText", FORCE_STRING)

PIXEL.RegisterFont("UI.Message", "Open Sans SemiBold", 18)

function PANEL:Init()
    self:SetDraggable(true)
    self:SetSizable(true)

    self:SetMinWidth(PIXEL.Scale(240))
    self:SetMinHeight(PIXEL.Scale(80))

    self.Message = vgui.Create("PIXEL.Label", self)
    self.Message:SetTextAlign(TEXT_ALIGN_CENTER)
    self.Message:SetFont("UI.Message")

    self.BottomPanel = vgui.Create("Panel", self)
    self.ButtonHolder = vgui.Create("Panel", self.BottomPanel)

    self.Buttons = {}
end

function PANEL:AddOption(name, callback)
    callback = callback or function() end

    local btn = vgui.Create("PIXEL.TextButton", self.ButtonHolder)
    btn:SetText(name)
    btn.DoClick = function()
        self:Close(true)
        callback()
    end
    table.insert(self.Buttons, btn)
end

function PANEL:LayoutContent(w, h)
    self.Message:SetSize(self.Message:CalculateSize())
    self.Message:Dock(TOP)
    self.Message:DockMargin(0, 0, 0, PIXEL.Scale(8))

    for k,v in ipairs(self.Buttons) do
        v:SizeToText()
        v:Dock(LEFT)
        v:DockMargin(PIXEL.Scale(4), 0, PIXEL.Scale(4), 0)
    end

    self.ButtonHolder:SizeToChildren(true)

    local firstBtn = self.Buttons[1]

    self.BottomPanel:Dock(TOP)
    self.BottomPanel:SetTall(firstBtn:GetTall())
    self.ButtonHolder:SetTall(firstBtn:GetTall())

    self.ButtonHolder:CenterHorizontal()

    if self.ButtonHolder:GetWide() < firstBtn:GetWide() then
        self.ButtonHolder:SetWide(firstBtn:GetWide())
    end

    if self.BottomPanel:GetWide() < self.ButtonHolder:GetWide() then
        self.BottomPanel:SetWide(self.ButtonHolder:GetWide())
    end

    if self:GetWide() < PIXEL.Scale(240) then
        self:SetWide(240)
        self:Center()
    end

    if self.HasSized and self.HasSized > 1 then return end
    self.HasSized = (self.HasSized or 0) + 1

    self:SizeToChildren(true, true)
    self:Center()
end

function PANEL:SetText(text) self.Message:SetText(text) end
function PANEL:GetText(text) return self.Message:GetText() end

vgui.Register("PIXEL.Query", PANEL, "PIXEL.Frame")

PIXEL.UI.Overrides.Derma_Query = PIXEL.UI.Overrides.Derma_Query or Derma_Query

Derma_Query = PIXEL.UI.CreateToggleableOverride(PIXEL.UI.Overrides.Derma_Query, function(text, title, ...)
    local msg = vgui.Create("PIXEL.Query")
    msg:SetTitle(title)
    msg:SetText(text)

    local args = {...}
    for i = 1, #args, 2 do
        msg:AddOption(args[i], args[i + 1])
    end

    msg:MakePopup()
    msg:DoModal()

    return msg
end, PIXEL.UI.ShouldOverrideDermaPopups)
--PATH lua/pixelui/menus/cl_string_request_popup.lua:
--[[
	PIXEL UI - Copyright Notice
	© 2023 Thomas O'Sullivan - All rights reserved

	This program is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program.  If not, see <https://www.gnu.org/licenses/>.
--]]

local PANEL = {}

AccessorFunc(PANEL, "Text", "Text", FORCE_STRING)
AccessorFunc(PANEL, "ButtonText", "ButtonText", FORCE_STRING)

PIXEL.RegisterFont("UI.Message", "Open Sans SemiBold", 18)

function PANEL:Init()
    self:SetDraggable(true)
    self:SetSizable(true)

    self:SetMinWidth(PIXEL.Scale(240))
    self:SetMinHeight(PIXEL.Scale(80))

    self.Message = vgui.Create("PIXEL.Label", self)
    self.Message:SetTextAlign(TEXT_ALIGN_CENTER)
    self.Message:SetFont("UI.Message")

    self.TextEntry = vgui.Create("PIXEL.TextEntry", self)

    self.BottomPanel = vgui.Create("Panel", self)
    self.ButtonHolder = vgui.Create("Panel", self.BottomPanel)

    self.Buttons = {}
end

function PANEL:AddOption(name, callback)
    local btn = vgui.Create("PIXEL.TextButton", self.ButtonHolder)
    btn:SetText(name)
    btn.DoClick = function()
        self:Close(true)
        callback(self.TextEntry:GetValue())
    end
    table.insert(self.Buttons, btn)
end

function PANEL:LayoutContent(w, h)
    self.Message:SetSize(self.Message:CalculateSize())
    self.Message:Dock(TOP)
    self.Message:DockMargin(0, 0, 0, PIXEL.Scale(8))

    self.TextEntry:SetTall(PIXEL.Scale(32))
    self.TextEntry:Dock(TOP)
    self.TextEntry:DockMargin(0, 0, 0, PIXEL.Scale(10))

    for k,v in ipairs(self.Buttons) do
        v:SizeToText()
        v:Dock(LEFT)
        v:DockMargin(PIXEL.Scale(4), 0, PIXEL.Scale(4), 0)
    end

    self.ButtonHolder:SizeToChildren(true)

    local firstBtn = self.Buttons[1]

    self.BottomPanel:Dock(TOP)
    self.BottomPanel:SetTall(firstBtn:GetTall())
    self.ButtonHolder:SetTall(firstBtn:GetTall())

    self.ButtonHolder:CenterHorizontal()

    if self.ButtonHolder:GetWide() < firstBtn:GetWide() then
        self.ButtonHolder:SetWide(firstBtn:GetWide())
    end

    if self:GetWide() < PIXEL.Scale(240) then
        self:SetWide(240)
        self:Center()
    end

    if self.HasSized and self.HasSized > 1 then return end
    self.HasSized = (self.HasSized or 0) + 1

    self:SizeToChildren(true, true)
    self:Center()
end

function PANEL:SetText(text) self.Message:SetText(text) end
function PANEL:GetText(text) return self.Message:GetText() end

function PANEL:SetPlaceholderText(text) self.TextEntry:SetPlaceholderText(text) end
function PANEL:GetPlaceholderText(text) return self.TextEntry:GetPlaceholderText() end

vgui.Register("PIXEL.StringRequest", PANEL, "PIXEL.Frame")

PIXEL.UI.Overrides.Derma_StringRequest = PIXEL.UI.Overrides.Derma_StringRequest or Derma_StringRequest

Derma_StringRequest = PIXEL.UI.CreateToggleableOverride(PIXEL.UI.Overrides.Derma_StringRequest, function(title, text, placeholderText, enterCallback, cancelCallback, buttonText, cancelText)
    cancelCallback = cancelCallback or function() end
    buttonText = buttonText or "OK"
    cancelText = cancelText or "Cancel"

    local msg = vgui.Create("PIXEL.StringRequest")
    msg:SetTitle(title)
    msg:SetText(text)

    msg:SetPlaceholderText(placeholderText)

    msg:AddOption(buttonText, enterCallback)
    msg:AddOption(cancelText, cancelCallback)

    msg.CloseButton.DoClick = function(s)
        cancelCallback(msg.TextEntry:GetValue())
        msg:Close()
    end

    msg:MakePopup()
    msg:DoModal()

    return msg
end, PIXEL.UI.ShouldOverrideDermaPopups)
--PATH lua/slib/vgui/cl_sframe.lua:
return gluapack()()
--PATH lua/slib/vgui/cl_sbutton.lua:
return gluapack()()
--PATH lua/slib/vgui/cl_sdropdown.lua:
return gluapack()()
--PATH lua/slib/vgui/cl_sstatement.lua:
local PANEL = {}

local colorpickerMat, checkmarkMat = Material("slib/icons/color-picker16.png", "noclamp smooth" ), Material("slib/icons/checkmark.png", "noclamp smooth" )

local textcolor, textcolor_50, maincolor, maincolor_7, maincolor_10, accentcolor, cleanaccentcolor = slib.getTheme("textcolor"), slib.getTheme("textcolor", -50), slib.getTheme("maincolor"), slib.getTheme("maincolor", 7), slib.getTheme("maincolor", 10), slib.getTheme("accentcolor"), slib.getTheme("accentcolor")
local margin = slib.getTheme("margin")

function PANEL:Init()
    self:Dock(TOP)
    self:SetTall(slib.getScaledSize(25, "y"))
    self:DockMargin(margin, 0, margin, margin)
    self.font = slib.createFont("Roboto", 14)
	self.bg = maincolor_7
	self.elemBg = maincolor
	
	slib.wrapFunction(self, "SetZPos", nil, function() return self end, true)
	slib.wrapFunction(self, "DockMargin", nil, function() return self end, true)
end

function PANEL:Paint(w,h)
    surface.SetDrawColor(self.bg)
    surface.DrawRect(0, 0, w, h)
	
    draw.SimpleText(self.name, self.font, self.center and w * .5 - self.xoffset - margin or margin, h * .5, textcolor, self.center and TEXT_ALIGN_CENTER or TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
end

function PANEL:OnSizeChanged(w, h)
	if self.center then
		self:setCenter()
	end
end

function PANEL:setCenter()
	self.center = true

	self.xoffset = self.element:GetWide() * .5

	surface.SetFont(self.font)
	local w, h = surface.GetTextSize(self.name)

	local l,t,r,b = self.element:GetDockMargin()
	self.element:DockMargin(l,t,self:GetWide() * .5 - self.xoffset - (w * .5) - margin,b)
end

function PANEL:addStatement(name, value)
    self.name = name
	local statement = slib.getStatement(value)
	local element

	if statement == "color" then
		element = vgui.Create("SButton", self)
		element:SetWide(slib.getScaledSize(25, "y") - slib.getScaledSize(2, "x") - slib.getScaledSize(2, "x"))
		element.color = value
		element.old_color = value

		element.Paint = function(s,w,h)
			draw.RoundedBox(h * .3, 0, 0, w, h, element.color)

			surface.SetDrawColor(textcolor_50)
			surface.SetMaterial(colorpickerMat)
			local sizew, sizeh = 16, 16

			surface.DrawTexturedRect( (w * .5) - (sizew * .5), (h * .5) - (sizeh * .5), sizew, sizeh )
		end

		element.OnRemove = function()
			if IsValid(element.ColorPicker) then element.ColorPicker:Remove() end
		end

		element.DoClick = function()
			if element.ColorPicker and IsValid(element.ColorPicker) then return end

			local posx, posy = self:LocalToScreen( element:GetPos() )

			element.ClosePicker = vgui.Create("SButton")
			element.ClosePicker:Dock(FILL)
			element.ClosePicker:MakePopup()
			element.ClosePicker.DoClick = function()
				if IsValid(element.ColorPicker) then element.ColorPicker:Remove() end
				if IsValid(element.ClosePicker) then element.ClosePicker:Remove() end
			end

			element.ClosePicker.Paint = function() end

			element.ColorPicker = vgui.Create("DColorMixer")
			element.ColorPicker:SetSize( slib.getScaledSize(200, "x"), slib.getScaledSize(160, "y") )
			element.ColorPicker:SetPos( posx - element.ColorPicker:GetWide(), posy )
			element.ColorPicker:SetPalette(false)
			element.ColorPicker:SetAlphaBar(false)
			element.ColorPicker:SetAlphaBar( true )
			element.ColorPicker:SetWangs(false)
			element.ColorPicker:SetColor(element.color and element.color or Color(255,0,0))
			element.ColorPicker:MakePopup()

			element.ColorPicker.Think = function()
				element.color = element.ColorPicker:GetColor()
			end

			element.ColorPicker.OnRemove = function()
				element.old_color = element.color

				if isfunction(element.onValueChange) then
					local result = element.onValueChange(element.color)
					if result == false then element.color = element.old_color end
				end
			end
		end
	elseif statement == "bool" then
		element = vgui.Create("SButton", self)
		element:SetWide(slib.getScaledSize(25, "y") - slib.getScaledSize(2, "x") - slib.getScaledSize(2, "x"))
		element.basealpha = cleanaccentcolor.a

		element.Paint = function(s,w,h)
			draw.RoundedBox(h * .3, 0, 0, w, h, self.elemBg)
            
            local wantedcolor = accentcolor

			wantedcolor.a = s.enabled and element.basealpha or 0
		
			local ico_size = h * .55

			surface.SetDrawColor(slib.lerpColor(s, wantedcolor, 3))
			surface.SetMaterial(checkmarkMat)
			surface.DrawTexturedRect(w * .5 - ico_size * .5,h * .5 - ico_size * .5, ico_size, ico_size)
		end

		element.enabled = value

		element.DoClick = function()
			element.enabled = !element.enabled
            
            if isfunction(element.onValueChange) then
				local result = element.onValueChange(element.enabled)
				if result == false then element.enabled = !element.enabled end
            end
		end
	elseif statement == "int" then
		element = vgui.Create("DNumberWang", self)
		element:SetWide(slib.getScaledSize(50, "x"))
		element:SetDrawLanguageID(false)
		element:SetFont(self.font)
		element:SetMin(0)
		element:SetMax(2000000)
		element.oldValue = value

		element.Paint = function(s,w,h)
			draw.RoundedBox(h * .3, 0, 0, w, h, self.elemBg)

			s:DrawTextEntryText(textcolor, cleanaccentcolor, cleanaccentcolor)
		end

		element.OnValueChanged = function(ignore)
			local oldValue = element.oldValue
			local newValue = element:GetValue()

			timer.Create(tostring(element), .3, 1, function()
				if isfunction(element.onValueChange) then
					local result = element.onValueChange(newValue)
					if result == false then
						element.oldValue = oldValue
						element:SetText(oldValue)
					return end

					element.oldValue = newValue
				end
			end)
		end

		element:SetText(value)
	elseif statement == "function" or statement == "table" then
		element = vgui.Create("SButton", self)
		element:Dock(RIGHT)
		element:DockMargin(0,slib.getTheme("margin"),slib.getTheme("margin"),slib.getTheme("margin"))
		element:setTitle(statement == "function" and "Execute" or "View Table")

		element.DoClick = function()
			if statement == "function" then
				value()
			return end
			
			local display_data = vgui.Create("STableViewer")
			display_data:setTable(value)
			display_data:SetBG(false, true, nil, true)

			if isfunction(element.onElementOpen) then
				element.onElementOpen(display_data)
			end
		end
	elseif statement == "string" then
		element = vgui.Create("DTextEntry", self)
		element:SetWide(slib.getScaledSize(80, "x"))
		element:SetDrawLanguageID(false)
		element:SetFont(self.font)
		element.Paint = function(s,w,h)
			draw.RoundedBox(h * .3, 0, 0, w, h, self.elemBg)

			s:DrawTextEntryText(textcolor, cleanaccentcolor, cleanaccentcolor)
		end
    end
    
    element:Dock(RIGHT)
    element:DockMargin(0,slib.getScaledSize(2, "x"),slib.getScaledSize(2, "x"),slib.getScaledSize(2, "x"))

	self.element = element

	return self, element
end

vgui.Register("SStatement", PANEL, "EditablePanel")
--PATH addons/[admin] gprotect_1.15.101/lua/g_protect/sh_gprotect_baseconfig.lua:
return gluapack()()
--PATH addons/[admin] gprotect_1.15.101/lua/g_protect/sh_util.lua:
return gluapack()()
--PATH addons/[misc] smartspawnmanager/lua/autorun/smartspawn/plugins/cl_derma.lua:
return gluapack()()
--PATH addons/[misc] smartspawnmanager/lua/autorun/smartspawn/plugins/cl_derma.lua:
//
/*
	Smart's Derma Script
	Date: 1/24/2018
	Time: 2:24pm
	Author: Smart Like My Shoe 
	Defines a bunch of functions that make my Derma life easier 
*/

///////////
// Vars 
///////////

local smart = {
	blur = Material( "pp/blurscreen" ),
	
	defaultFont = "Default",
	
	cornerRadius = 6,
	backGroundColor = Color(20, 20, 20, 200),
	panelColor = Color(30, 30, 30, 200),
	buttonTextColor = Color(255, 255, 255, 255),
	buttonColor = Color(100, 100, 100, 255),
	buttonColorHovered = Color(120, 120, 120, 255),
	buttonSuccessSound = "buttons/button3.wav",
	buttonErrorSound = "buttons/button2.wav",
	transitionDuration = 0.5,
};

/////////////
// Accessor methods 
/////////////

function smart:SetCornerRadius(radius)
	self.cornerRadius = radius;
end

function smart:SetBackgroundColor(color)
	self.backGroundColor = color;
end 

function smart:SetButtonTextColor(color)
	self.buttonTextColor = color;
end 

function smart:SetButtonColor(color)
	self.buttonColor = color;
end 

function smart:SetColorHovered(color)
	self.buttonColorHovered = color;
end 

function smart:SetSuccessSound(path)
	self.buttonSuccessSound = path;
end 

function smart:SetTransitionDuration(duration)
	self.transitionDuration = duration;
end

function smart:SetDefaultFont(font)
	self.defaultFont = font;
end

function smart:SetPanelColor(color)
	self.panelColor = color;
end

////////////
// Methods 
////////////

/*
	GenerateFont 
	Parameters: string
	Returns: void 
	Description: Calls surface.createfont method
*/
function smart:GenerateFont(name, font, size, weight)

	weight = weight || 500;

	surface.CreateFont(name, {
		font = font,
		extended = false,
		size = size,
		weight = weight,
		blursize = 0,
		scanlines = 0,
		antialias = true,
		underline = false,
		italic = false,
		strikeout = false,
		symbol = false,
		rotary = false,
		shadow = false,
		additive = false,
		outline = false,
	});
	
	if (self.defaultFont == "Default") then 
		self.defaultFont = name;
	end 
	print("Generating font", name, size)
end

/*
	Blur 
	Parameters: panel, integer, integer, integer 
	Returns: void 
	Description: Draws a nice blur effect 
*/

function smart:Blur(panel, layers, density, alpha)
	local x, y = panel:LocalToScreen(0, 0);

	surface.SetDrawColor(255, 255, 255, alpha);
	surface.SetMaterial(self.blur);

	for i = 1, 3 do
		self.blur:SetFloat("$blur", ( i / layers ) * density);
		self.blur:Recompute();
		render.UpdateScreenEffectTexture();
		surface.DrawTexturedRect(-x, -y, ScrW(), ScrH());
	end
end

/*
	Slide 
	Parameters: panel, integer, integer
	Returns: void 
	Description: Slides a panel to an absolute position over time (seconds)
*/
function smart:Slide(p, x, y)

	// Calculate differences 
	local pX, pY = p:GetPos();
	local diffX = x - pX;
	local diffY = y - pY;
	
	local startTime = CurTime();
	
	// Hook the think method to run our animation
	local oldThink = p.Think || function(_p) end;
	
	p.Think = function(_p)
		oldThink(p);
		
		local timeElapsed = CurTime() - startTime;
		local progress = (timeElapsed/self.transitionDuration);
		
		p:SetPos(pX + (diffX*progress), pY + (diffY*progress));
		
		if (progress >= 1) then // Unhook the think method
			p.Think = oldThink;
			p:SetPos(x, y);
		end
	end 
end 

/*
	Frame 
	Parameters: integer, integer, integer (optional), integer (optional), string (optional)
	Returns: panel
	Description: Generates a custom derma frame 
*/
function smart:Frame(x, y, width, height, title, closeButton)

	x = x || ScrW()/2-width/2;
	y = y || ScrH()/2-height/2;
	title = title || "";
	if (closeButton == nil) then 
		closeButton = true;
	end

	local frame = vgui.Create("DFrame");
	frame:SetSize(width, height);
	frame:SetPos(x, y);
	frame:ShowCloseButton(false);
	frame:SetDraggable(false);
	frame:SetTitle(title);
	frame._x = x;
	frame._y = y;
	frame.Paint = function(p)
		self:Blur(frame, 1, 2, 255);
		draw.RoundedBox(self.cornerRadius, 0, 0, p:GetWide(), p:GetTall(), self.backGroundColor);
	end
	
	if (closeButton) then 
		frame.close = vgui.Create("DImageButton");
		frame.close:SetParent(frame);
		frame.close:SetIcon("icon16/cancel.png");
		frame.close:SetPos(frame:GetWide() - 21, 5);
		frame.close:SetSize(16, 16);
		frame.close.DoClick = function(p)
			
			surface.PlaySound(self.buttonSuccessSound);
			frame.Dismiss();
		end
	end
	
	frame.Request = function(x2, y2, x3, y3)
		
		local centerX = ScrW() / 2 - frame:GetWide() / 2;
		local centerY = ScrH() / 2 - frame:GetTall() / 2;
		
		x2 = x2 || centerX;
		y2 = y2 || -frame:GetTall();
		x3 = x3 || centerX;
		y3 = y3 || centerY;
		
		frame:SetPos(x2, y2);
		self:Slide(frame, x3, y3);
	end
	
	frame.Dismiss = function(x2, y2)
		x2 = x2 || x;
		y2 = y2 || ScrH();
		
		self:Slide(frame, x2, y2);
		timer.Simple(self.transitionDuration, function()
			if (IsValid(frame)) then 
				frame:Close();
			end
		end);
	end
	
	return frame;
end

/*
	Panel 
	Parameters: int, int 
	Returns: panel 
*/
function smart:Panel(w, h)

	local panel = vgui.Create("DPanel");
	panel:SetSize(w, h);
	panel.Paint = function(s)
	
		draw.RoundedBox(self.cornerRadius, 0, 0, s:GetWide(), s:GetTall(), self.panelColor);
	end
	
	return panel;
end

/*
	List 
	Parameters: panel (optional), boolean (optional)
	Returns: panel 
*/
function smart:List(parent, bHorizontal)

	bHorizontal = bHorizontal || false;
	
	local dList = vgui.Create("DPanelList");
	dList:SetSpacing(2);
	dList:EnableVerticalScrollbar(true);
	dList:EnableHorizontal(bHorizontal);
	
	if (parent) then 
		dList:SetParent(parent);
		dList:SetPos(5, 25);
		dList:SetSize(parent:GetWide() - 10, parent:GetTall() - 30);
	end 
	
	return dList;
end

/*
	CollapsibleCategoryList
	Parameters: int, int
	Returns: panel 
*/
function smart:CollapsibleCategoryList(w, h, color)

	color = color || Color(20, 20, 20, 255);

	local cat = vgui.Create("DCollapsibleCategory");
	cat:SetWide(w);
	cat.Paint = function() end
	cat.Header:SetFont(self.defaultFont);
	cat.Header.Paint = function(s)
		draw.RoundedBox(4, 0, 0, s:GetWide(), s:GetTall(), color);
	end
	
	local internalList = self:List(nil, false);
	
	cat.internalList = internalList;
	cat:SetContents(internalList);
	
	cat.AddItem = function(s, p)
		internalList:AddItem(p);
	end
	
	return cat;
end

/*
	Button
	Parameters: string, function 
	Returns: panel
*/
function smart:Button(text, func)

	func = func || function() end

	local button = vgui.Create("DButton");
	button:SetText(text);
	button:SetTextColor(self.buttonTextColor);
	button.DoClick = function() 
		surface.PlaySound(self.buttonSuccessSound);
		func();
	end
	button.Paint = function(p)
		
		local color;
		if (button:IsHovered()) then 
			color = self.buttonColorHovered;
		else
			color = self.buttonColor;
		end 
		
		local highLightColor = Color(color.r + 5, 
									color.g + 5,
									color.b + 5,
									color.a);
									
		local highLightCornerRadius = self.cornerRadius - 2;
		if (highLightCornerRadius < 0) then 
			highLightCornerRadius = 0;
		end
									
		draw.RoundedBox(self.cornerRadius, 0, 0, p:GetWide(), p:GetTall(), color);
		draw.RoundedBox(highLightCornerRadius, 0, 0, p:GetWide(), p:GetTall()/2, highLightColor);
	end 

	return button;
end

/*
	Label 
	Parameters: string, string 
	Return: panel 
*/
function smart:Label(text, font, color)

	color = color || Color(255,255,255,255);

	local lab = vgui.Create("DLabel");
	lab:SetFont(font);
	lab:SetText(text);
	lab:SetTextColor(color);
	lab:SizeToContents();
	
	return lab;
end

/*
	SpawnIcon
	Parameters: string 
	Return: panel
*/
function smart:SpawnIcon(model, size)

	local spawnIcon = vgui.Create("SpawnIcon");
	spawnIcon:SetModel(model);
	spawnIcon:SetSize(size, size);
	
	/* Unneccesary?
	if (self.BuiltSpawnIcons[model] == nil) then
		spawnIcon:RebuildSpawnIcon();
		self.BuiltSpawnIcons[model] = true;
	end
	*/
	
	return spawnIcon;
end


/*
	DPropertySheet 
	Parameters: void 
	Return: panel
*/
function smart:PropertySheet()

	local propertySheet = vgui.Create("DPropertySheet");
	propertySheet.Paint = function(s)
		draw.RoundedBox(0, 0, 0, s:GetWide(), s:GetTall(), Color(0, 0, 0, 200));
	end
	
	propertySheet.DoPaintSetup = function(s)
	
		for k, v in pairs(s.Items) do
			if (!v.Tab) then 
				continue;
			end
		
			v.Tab.Paint = function(self,w,h)
		
				if (s:GetActiveTab() == v.Tab) then 
					draw.RoundedBox(4, 0, 0, w, h-5, Color(80, 80, 80, 200));
				else 
			
					draw.RoundedBox(4, 0, 0, w, h, Color(50, 50, 50, 200));
				end
			end
		end
	end 
	
	return propertySheet;
end

/*
	Dropdown sheet
	Parameters: void 
	Return: panel
*/
function smart:DropDownSheet(txt, options, defaultOption, width, height, onSelectOption)

	local parent = vgui.Create("DPanel");
	parent:SetSize(width, height);
	parent.Paint = function() end

	local lab = self:Label(txt, "Trebuchet18");
	lab:SetPos(0, 0);
	lab:SetParent(parent);
	lab:SizeToContents();

	local combo = vgui.Create("DComboBox", parent);
	combo:SetSize(100, 20);
	combo:SetPos(width - 140, 0);
	combo.OnSelect = onSelectOption;

	for k,v in next, options do 
		combo:AddChoice(v);
	end

	combo:SetText(options[defaultOption]);

	return parent;
end

/*
	Notification
	Parameters: string, int 
	Return: Panel
*/
local iconMaterial = Material("icon16/exclamation.png");
function smart:Notification(text, duration, index)
	
	local label = self:Label(text, "Trebuchet24");
	local width = label:GetWide() + 31;
	local height = label:GetTall() + 5;
	
	local x = ScrW() - width;
	local y = ScrH() / 2 - height / 2 + index * height;
	
	local frame = self:Frame(x, y, width, height, "", false);
	label:SetParent(frame);
	label:SetPos(21, 2.5);
	
	local iconMat
	local icon = vgui.Create("DPanel", frame);
	icon:SetPos(3, height/2 - 8);
	icon:SetSize(16, 16);
	icon.Paint = function()
		
		surface.SetDrawColor(color_white);
		surface.SetMaterial(iconMaterial);
		surface.DrawTexturedRect(0, 0, icon:GetWide(), icon:GetTall());
	end
	
	frame.Request(ScrW(), y, x, y); 
	
	timer.Simple(duration, function()
		frame.Dismiss(ScrW(), y);
	end);
end

/*
	NumSlider
	Parameters: Int, Int, Int, String
*/
function smart:NumSlider(min, max, decimals, conVar)

	local dSlider = vgui.Create("DNumSlider");
	dSlider:SetMin(min);
	dSlider:SetMax(max);
	dSlider:SetDecimals(decimals);
	if (conVar != nil) then 
		dSlider:SetConVar(conVar);
	end
	
	dSlider.Label:SetFont("Trebuchet18");
	dSlider.Label:SetTextColor(Color(255, 255, 255, 255));
	
	dSlider.Slider.Knob.Paint = function(self, w, h)
		draw.RoundedBox(6, 0, 0, w, h, Color(80, 80, 80, 255));
	end
	dSlider.Slider.Paint = function(self, w, h)
		draw.RoundedBox(6, 0, 0, w, h, Color(255, 255, 255, 100));
	end
	dSlider.TextArea.Paint = function(self)
		draw.SimpleText(self:GetText(), "Trebuchet18", 6, 3, Color(255, 255, 255, 255), TEXT_ALIGN_LEFT, TEXT_ALIGN_LEFT);
	end
	
	return dSlider;
end

/*
	Graph Plot Point 
	Parameters: String
*/
function smart:PlotPoint(txt)
	
	local tLab = self:Label(txt, "Trebuchet18", color_black);

	local point = self:Panel();
	point:SetSize(8, 8);
	point.Paint = function(s)
		draw.RoundedBox(2, 0, 0, s:GetWide(), s:GetTall(), Color(255, 255, 255, 200));
	end
	
	point:SetTooltipPanel(tLab);
	
	return point;
end

/*
	Line Graph
	Parameters: String, String, Int, Int, Int, Table, Int, Int
*/
function smart:LineGraph(title, xAxisLabel, w, h, axisPadding, dataPoints, xInterval, yInterval)
	
	local plottedPoints = {};
	local thresholds = {};
	
	local graph = self:Panel()
	graph:SetSize(w, h);
	graph.Paint = function(s) 
	
		local yOrigin = s:GetTall();
		local yPadded = yOrigin - axisPadding;

		surface.SetDrawColor(color_white);
		surface.DrawLine(axisPadding, yPadded, s:GetWide(), yPadded); // X Axis
		surface.DrawLine(axisPadding, yPadded, axisPadding, 0); // Y Axis
		
		// X Axis Label 
		draw.SimpleText(xAxisLabel, "Trebuchet18", s:GetWide()/2, s:GetTall() - axisPadding - 5, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
	
		
		local maxX = #dataPoints;
		//local minX = 0;
		local maxY = math.Round(math.max(unpack(dataPoints)));
		local minY = math.Round(math.min(unpack(dataPoints)));
		
		local diffY = math.max((maxY - minY) + yInterval, yInterval);	
		local scaleX = w / 10;
		local scaleY = (h-axisPadding*2) / diffY;
		
		local xCounter = 0;
		for x = maxX - 10, maxX do // Draw the numbers on the x axis
			
			if (x < 0) then continue end
		
			local text = tostring(x * xInterval);
			draw.SimpleText(text, "Trebuchet18", axisPadding + scaleX * xCounter, yPadded + 10, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER);
			
			xCounter = xCounter + 1;
		end
	
		for y = minY, diffY, yInterval do // Draw the text along the y axis
			local text = tostring(y);
			draw.SimpleText(text, "Trebuchet18", axisPadding - 12, yPadded - y * scaleY, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER);
		end
		
		// Plots the line graph 
		surface.SetDrawColor(color_white);
		xCounter = 0;
		for x = maxX - 10, maxX do 
			local y1 = dataPoints[x];
			local y2 = dataPoints[x + 1];
			if (!y1 || !y2) then continue end 
		
			local y1Unscaled = y1;
			y1 = y1 * scaleY;
			y2 = y2 * scaleY;
			local x1 = axisPadding + scaleX * xCounter;
			local x2 = axisPadding + scaleX * (xCounter + 1);
			
			surface.DrawLine(x1, yPadded - y1, x2, yPadded - y2);
			
			if (plottedPoints[x] == nil) then 
					
				local point = self:PlotPoint(tostring(math.Round(y1Unscaled)));
				point:SetParent(graph);
				point:SetPos(x1 - point:GetWide()/2, (yPadded - y1) - point:GetTall()/2);
				plottedPoints[x] = true;
			end
			
			
			xCounter = xCounter + 1;
		end
		
		// Plot thresholds 
		for k,v in next, thresholds do 
		
			if (diffY > v.y) then 
				
				local y = yPadded - v.y * scaleY;
				surface.SetDrawColor(v.color);
				surface.DrawLine(axisPadding, y, w, y);
				draw.SimpleText(tostring(v.y) .. " - " .. v.text, "Trebuchet18", w/2, y - 7, v.color, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER);
			end
		end
		
		// Draw title 
		draw.SimpleText(title, "Trebuchet18", w/2, 10, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER);
	end
	
	function graph:AddThreshold(y, text, color)
	
		thresholds[#thresholds+1] = {
			y = y,
			text = text,
			color = color,
		};
	end
	
	return graph;
end

return smart;
--PATH addons/[misc] sreward_1.6.31/lua/s_reward/core/cl_admin_menu.lua:
return gluapack()()
--PATH addons/[misc] sreward_1.6.31/lua/s_reward/languages/sh_turkish.lua:
return gluapack()()
--PATH addons/[misc] sreward_1.6.31/lua/s_reward/rewards/sh_perp.lua:
return gluapack()()
--PATH lua/streamradio_core/url.lua:
local StreamRadioLib = StreamRadioLib

StreamRadioLib.Url = StreamRadioLib.Url or {}

local LIB = StreamRadioLib.Url
table.Empty(LIB)

local LIBUtil = StreamRadioLib.Util
local LIBNetURL = StreamRadioLib.NetURL
local LIBString = StreamRadioLib.String

local g_sanitizeOnlineUrlCache = LIBUtil.CreateCacheArray(2048)
local g_sanitizeOfflineUrlCache = LIBUtil.CreateCacheArray(2048)
local g_isOfflineURLCache = LIBUtil.CreateCacheArray(2048)

local function GetProtocol(url)
	url = tostring(url or "")

	local protocol = string.match(url, "^([%w_][%w_]+):[//\\][//\\]") or ""
	protocol = string.Trim(protocol)
	protocol = string.lower(protocol)

	return protocol
end

local function SplittProtocolAndPath(url)
	local protocol = GetProtocol(url)

	if protocol == "" then
		return "", url
	end

	local path = string.match(url, ":[//\\][//\\]([ -~]+)$")
	return protocol, path
end

local function SplittDriveLetterAndPath(url)
	url = tostring(url or "")

	local letter, path = string.match(url, "^(%a):[//\\]+([ -~]+)$")

	letter = letter or ""
	path = path or ""

	if letter == "" then
		return "", url
	end

	if path == "" then
		return "", url
	end

	letter = string.Trim(letter)
	letter = string.lower(letter)

	return letter, path
end

local function ConcatProtocolAndPath(protocol, path)
	protocol = tostring(protocol or "")
	path = tostring(path or "")

	if protocol == "" then
		return path
	end

	local url = string.format("%s://%s", protocol, path)
	return url
end

local function ConcatDriveLetterAndPath(letter, path)
	letter = tostring(letter or "")
	path = tostring(path or "")

	if letter == "" then
		return path
	end

	local url = string.format("%s:/%s", letter, path)
	return url
end


function LIB.SplittProtocolAndPath(url)
	return SplittProtocolAndPath(url)
end

function LIB.IsOfflineURL(url)
	url = tostring(url or "")

	if url == "" then
		return false
	end

	if g_isOfflineURLCache:Has(url) then
		return g_isOfflineURLCache:Get(url)
	end

	g_isOfflineURLCache:Set(url, true)

	local letter = SplittDriveLetterAndPath(url)

	if letter ~= "" then
		-- drive letter paths (C:/, C://) are offline too, even though we explicitly ban them later
		return true
	end

	local protocol = GetProtocol(url)

	if protocol == "" then
		return true
	end

	if protocol == "file" then
		return true
	end

	g_isOfflineURLCache:Set(url, false)
	return false
end

function LIB.IsOnlineURL(url)
	return not LIB.IsOfflineURL(url)
end

local function IsBlockedURLCode(url)
	url = url or ""

	local blockedURLCode = StreamRadioLib.BlockedURLCode or ""
	local blockedURLCodeSequence = StreamRadioLib.BlockedURLCodeSequence or ""

	if blockedURLCode == "" then
		return false
	end

	if blockedURLCodeSequence == "" then
		return false
	end

	if url == blockedURLCode then
		return true
	end

	if string.find(url, blockedURLCodeSequence, 1, true) then
		return true
	end

	return false
end

function LIB.IsValidURL(url)
	url = tostring(url or "")

	if url == "" then
		return false
	end

	if IsBlockedURLCode(url) then
		return false
	end

	return true
end

local function SanitizeUrlInternal(url)
	url = tostring(url or "")

	url = string.Trim(url)

	if not LIB.IsValidURL(url) then
		return ""
	end

	url = string.Replace(url, "\n", "")
	url = string.Replace(url, "\r", "")
	url = string.Replace(url, "\t", "")
	url = string.Replace(url, "\b", "")
	url = string.Replace(url, "\v", "")

	url = string.Trim(url)

	return url
end

function LIB.SanitizeUrl(url)
	url = tostring(url or "")

	if url == "" then
		return ""
	end

	if LIB.IsOfflineURL(url) then
		return LIB.SanitizeOfflineUrl(url)
	end

	return LIB.SanitizeOnlineUrl(url)
end

function LIB.SanitizeOnlineUrl(url)
	url = tostring(url or "")

	if url == "" then
		return ""
	end

	local cacheId = url

	if g_sanitizeOnlineUrlCache:Has(cacheId) then
		return g_sanitizeOnlineUrlCache:Get(cacheId)
	end

	url = SanitizeUrlInternal(url)

	url = LIBNetURL.normalize(url)
	url = tostring(url)

	url = string.sub(url, 0, StreamRadioLib.STREAM_URL_MAX_LEN_ONLINE)
	url = string.Trim(url)

	g_sanitizeOnlineUrlCache:Set(cacheId, url)
	g_sanitizeOnlineUrlCache:Set(url, url)

	return url
end

function LIB.SanitizeOfflineUrl(url)
	url = tostring(url or "")

	if url == "" then
		return ""
	end

	local cacheId = url

	if g_sanitizeOfflineUrlCache:Has(cacheId) then
		return g_sanitizeOfflineUrlCache:Get(cacheId)
	end

	if not LIB.IsValidURL(url) then
		return ""
	end

	url = SanitizeUrlInternal(url)

	local letter, letterPath = SplittDriveLetterAndPath(thisPath)
	if letter ~= "" then
		letterPath = LIBString.NormalizeSlashes(letterPath)
		letterPath = string.TrimLeft(letterPath, "/")

		url = ConcatDriveLetterAndPath(letter, letterPath)
	else
		local protocol, protocolPath = SplittProtocolAndPath(url)

		protocolPath = LIBString.NormalizeSlashes(protocolPath)
		protocolPath = string.TrimLeft(protocolPath, "/")

		url = ConcatProtocolAndPath(protocol, protocolPath)
	end

	url = string.sub(url, 0, StreamRadioLib.STREAM_URL_MAX_LEN_OFFLINE)
	url = string.Trim(url)

	g_sanitizeOfflineUrlCache:Set(cacheId, url)
	g_sanitizeOfflineUrlCache:Set(url, url)

	return url
end

function LIB.URIAddParameter(url, parameter)
	if not istable(parameter) then
		parameter = {parameter}
	end

	url = tostring(url or "")
	url = LIBNetURL.normalize(url)

	for k, v in pairs(parameter) do
		url.query[k] = v
	end

	url = tostring(url)
	return url
end

function LIB.IsDriveLetterOfflineURL(url)
	if not LIB.IsOfflineURL(url) then
		return false
	end

	url = string.Trim(url or "")

	local _, path = SplittProtocolAndPath(url)
	local letter = SplittDriveLetterAndPath(path)

	if letter == "" then
		return false
	end

	return true
end

function LIB.Load()
	StreamRadioLib.Hook.Add("PostCleanupMap", "reset_cache_url", function()
		g_sanitizeOnlineUrlCache:Empty()
		g_sanitizeOfflineUrlCache:Empty()
		g_isOfflineURLCache:Empty()
	end)
end

return true


--PATH lua/streamradio_core/json.lua:
local StreamRadioLib = StreamRadioLib

StreamRadioLib.JSON = StreamRadioLib.JSON or {}

local LIB = StreamRadioLib.JSON
table.Empty(LIB)

local catchAndErrorNoHaltWithStack = StreamRadioLib.Util.CatchAndErrorNoHaltWithStack

function LIB.Encode(data, prettyPrint)
	if not istable(data) then
		data = {data}
	end

	local status, json = catchAndErrorNoHaltWithStack(util.TableToJSON, data)
	if not status then
		return nil
	end

	if not json then
		return nil
	end

	json = StreamRadioLib.String.NormalizeNewlines(json, "\n")
	return json
end

function LIB.Decode(json)
	json = tostring(json or "")
	json = StreamRadioLib.String.NormalizeNewlines(json, "\n")

	json = string.gsub(json, "//.-\n" , "\n")    -- singleline comment
	json = string.gsub(json, "/%*.-%*/" , "\n")  -- multiline comment

	json = string.gsub(json, ",([%s]*)([%]%}])", "%1%2")  -- trailing comma of arrays/objects

	json = string.gsub(json, "\n[%s]*", "\n")     -- remove all spaces at the start of lines
	json = string.gsub(json, "[%s\n]*\n", "\n")   -- remove all empty lines and all spaces at the end of lines
	json = string.gsub(json, "^\n", "")           -- remove first empty new line
	json = string.gsub(json, "\n$", "")           -- remove last empty new line

	json = string.Trim(json)

	if json == "" then
		return {}
	end

	local status, data = catchAndErrorNoHaltWithStack(util.JSONToTable, json)

	if not status then
		return nil
	end

	if not data then
		return nil
	end

	if not istable(data) then
		data = {data}
	end

	return data
end

return true


--PATH lua/streamradio_core/models/111as_h500_radio.lua:
return gluapack()()
--PATH lua/streamradio_core/models/portal_ball.lua:
local RADIOMDL = RADIOMDL
if not istable( RADIOMDL ) then
	StreamRadioLib.Model.LoadModelSettings()
	return
end

-- Portal 1 Ball
RADIOMDL.model = "models/props/sphere.mdl"

RADIOMDL.NoDisplay = true
RADIOMDL.SpawnAng = Angle( 0, 0, 0 )
RADIOMDL.SpawnFlatOnWall = false

function RADIOMDL:SoundLevel(ent, soundlevel)
	if SERVER then return end

	soundlevel = soundlevel or 0
	if soundlevel <= 0 then
		ent:SetSkin(0)
		return
	end

	local vol = ent:GetVolume()

	soundlevel = soundlevel * 100000
	soundlevel = math.log10(soundlevel) / 5
	soundlevel = soundlevel ^ 20 * 1.1
	soundlevel = soundlevel * vol

	soundlevel = math.Clamp(soundlevel, 0, 1)

	local skinid = math.Round(soundlevel * 9)
	ent:SetSkin( skinid )
end

return true


--PATH lua/streamradio_core/models/portal_gladosball.lua:
local RADIOMDL = RADIOMDL
if not istable( RADIOMDL ) then
	StreamRadioLib.Model.LoadModelSettings()
	return
end

-- Portal 1 GlaDOS Ball
RADIOMDL.model = "models/props_bts/glados_ball_reference.mdl"

local skins = {0,  1,  3,  2}

RADIOMDL.NoDisplay = true
RADIOMDL.SpawnAng = Angle( 0, 0, 0 )
RADIOMDL.SpawnFlatOnWall = false

function RADIOMDL:SoundLevel(ent, soundlevel)
	if SERVER then return end

	soundlevel = soundlevel or 0
	if soundlevel <= 0 then
		ent:SetSkin(0)
		return
	end

	local vol = ent:GetVolume()

	soundlevel = soundlevel * 100000
	soundlevel = math.log10(soundlevel) / 5
	soundlevel = soundlevel ^ 20 * 1.1
	soundlevel = soundlevel * vol

	soundlevel = math.Clamp(soundlevel, 0, 1)

	local skinid = skins[math.Round(soundlevel * 3) + 1] or 0
	ent:SetSkin( skinid )
end

return true


--PATH lua/streamradio_core/models/portal_speaker_small.lua:
return gluapack()()
--PATH lua/streamradio_core/models/wire_monitor_big.lua:
local RADIOMDL = RADIOMDL
if not istable( RADIOMDL ) then
	StreamRadioLib.Model.LoadModelSettings()
	return
end

-- Wire Monitor, Big
-- Addon: https://steamcommunity.com/sharedfiles/filedetails/?id=160250458
RADIOMDL.model = "models/kobilica/wiremonitorbig.mdl"

RADIOMDL.SpawnAng = Angle(0, 0, 0)
RADIOMDL.SpawnFlatOnWall = true
RADIOMDL.SoundPosOffset = Vector(0.25, 0, 11.75)
RADIOMDL.SoundAngOffset = Angle(0, 0, 0)

RADIOMDL.DisplayAngles = Angle(0, 90, 90)

                              --      F,      R,      U
RADIOMDL.DisplayOffset    = Vector(0.25, -11.25,  24.25) -- Top Left
RADIOMDL.DisplayOffsetEnd = Vector(0.25,  11.25,   1.75) -- Bottom Right

RADIOMDL.DisplayWidth = 1400
RADIOMDL.DisplayHeight, RADIOMDL.DisplayScale = RADIOMDL:GetDisplayHeight(RADIOMDL.DisplayOffset, RADIOMDL.DisplayOffsetEnd, RADIOMDL.DisplayWidth)

RADIOMDL.FontSizes = {
--  Name 	= Size,	Weight, Parentname
	Header	= {45,	1000},
	Small	= {36,	700},
	Default	= {42,	700},
	Tooltip	= {42,	800},
	Big		= {50,	700},
}

function RADIOMDL:SetupGUI(ent, gui_controller, mainpanel)
	gui_controller:SetPos(0, 0)
	gui_controller:SetSize(self.DisplayWidth, self.DisplayHeight)

	mainpanel:SetSize(gui_controller:GetClientSize())

	local modelsetup = {}
	if CLIENT then
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/header/text", "font", self.Fonts.Header)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/header/pretext", "font", self.Fonts.Header)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/button", "font", self.Fonts.Default)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/button", "font", self.Fonts.Default)

		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/header", "font", self.Fonts.Header)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/controls/progressbar/label", "font", self.Fonts.Small)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/button", "font", self.Fonts.Big)

		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/volume/progressbar/label", "font", self.Fonts.Default)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/error/textbox", "font", self.Fonts.Big)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/error/button", "font", self.Fonts.Big)

		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/error/textbox", "font", self.Fonts.Big)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/error/button", "font", self.Fonts.Big)

		StreamRadioLib.SetSkinTableProperty(modelsetup, "tooltip", "font", self.Fonts.Tooltip)
	end

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/header", "sizeh", 80)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/header", "sizeh", 80)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists", "gridsize", {x = 2, y = 10})
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview", "gridsize", {x = 1, y = 10})
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/scrollbar", "sizew", 60)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/scrollbar", "sizew", 60)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/sidebutton", "sizew", 100)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/error/textbox/scrollbar", "sizew", 60)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/error/textbox/scrollbar", "sizew", 60)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/button", "sizeh", 90)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/error/button", "sizew", 80)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/error/button", "sizew", 80)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "", "cornersize", 0)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "", "borderwidth", 16)

	local shadow = 10
	local padding = 10
	local margin = 10

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/button", "shadowwidth", shadow)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/button", "shadowwidth", shadow)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/button", "padding", padding)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/button", "padding", padding)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/button", "margin", margin)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/button", "margin", margin)

	gui_controller:SetModelSetup(modelsetup)

	mainpanel:ForEachChildRecursive(function(panel, child)
		if child.SetShadowWidth and child:GetShadowWidth() == 5 then
			child:SetShadowWidth(shadow)
		end

		if child.SetPadding and child:GetPadding() == 5 then
			child:SetPadding(padding)
		end

		if child.SetMargin and child:GetMargin() == 5 then
			child:SetMargin(margin)
		end
	end)
end

return true


--PATH lua/streamradio_core/models/wire_speaker1.lua:
return gluapack()()
--PATH lua/streamradio_core/cache.lua:
return gluapack()()
--PATH lua/streamradio_core/classes/ui/panel.lua:
return gluapack()()
--PATH lua/streamradio_core/classes/ui/label.lua:
local StreamRadioLib = StreamRadioLib

if not istable(CLASS) then
	StreamRadioLib.ReloadClasses()
	return
end

local BASE = CLASS:GetBaseClass()
local changehooks = {
	Text = "OnTextChange",
	Font = "OnFontChange",
	AlignX = "OnAlignChange",
	AlignY = "OnAlignChange",
}

local function normalize_text(text)
	text = tostring(text or "")
	text = string.gsub(text, "[\r\n]", "" )
	text = string.gsub(text, "\t", "    " )

	return text
end

function CLASS:Create()
	BASE.Create(self)

	self.Clickable = false

	self.TextData = self:CreateListener({
		Text = "",
		Font = "DermaDefault",

		AlignX = TEXT_ALIGN_LEFT,
		AlignY = TEXT_ALIGN_TOP,

		Shorter = "...",
		ShorterEnd = true,
	}, function(this, k, v)
		self:InvalidateLayout()

		if CLIENT then
			self:QueueCall("UpdateText")
		end

		local hookname = changehooks[k]
		if not hookname then return end

		self:CallHook(hookname)
	end)

	if CLIENT then
		self.InternalText = ""
		self.Size = self.Size + function(this, k, v)
			if k ~= "w" then return end
			self:QueueCall("UpdateText")
		end

		self.Colors.Main = Color(0,0,0)
	end

	self:SetSkinAble(false)
end

function CLASS:UpdateText()
	if SERVER then return end

	self.InternalText = self:TextFit(self.TextData.Text, self:GetWidth())
	self:PerformRerender(true)
end

function CLASS:ShortText(text, len)
	if len <= 0 then
		return ""
	end

	local shorter = self.TextData.Shorter

	if self.TextData.ShorterEnd then
		return string.sub(text, 0, len) .. shorter
	end

	return shorter .. string.sub(text, -len)
end

function CLASS:GuessLen(text, width, func)
	local len2power = 2 ^ math.ceil(math.log(#text) / math.log(2))
	local len = len2power

	local repeattimes = 4

	while true do
		local bigger = func(self, text, len, width)
		local repeated = false

		if len2power <= 1 then
			if repeattimes <= 0 then
				break
			end

			repeattimes = repeattimes - 1
			repeated = true
		end

		if bigger > 0 then
			if repeated and repeattimes <= 1 then
				break
			end

			len2power = math.ceil(len2power / 2)
			len = len + len2power
			continue
		end

		if bigger < 0 then
			len2power = math.ceil(len2power / 2)
			len = len - len2power
			continue
		end

		break
	end

	return len
end

function CLASS:TryTextFit(text, len, width)
	local newstring = self:ShortText(text, len)

	if newstring == "" then
		return 1
	end

	surface.SetFont( self.TextData.Font )
	local w = surface.GetTextSize( newstring ) or 0
	local bigger = width - w

	return bigger
end

function CLASS:TextFit(text, width)
	if SERVER then return "" end

	if text == "" then
		return ""
	end

	if width <= 0 then
		return ""
	end

	surface.SetFont( self.TextData.Font )
	local w = surface.GetTextSize( text ) or 0
	if w <= 0 then
		return ""
	end

	if (w <= width) then
		return text
	end

	local len = self:GuessLen(text, width, self.TryTextFit)
	local newstring = self:ShortText(text, len)

	return newstring
end

function CLASS:DrawText( text, x, y, w, h )
	text = text or ""
	if text == "" then
		return
	end

	local tx, ty = x, y
	local xalign, yalign = self.TextData.AlignX, self.TextData.AlignY
	local tsw, tsh = surface.GetTextSize( text )

	if ( xalign == TEXT_ALIGN_CENTER ) then
		tx = x + w / 2 - tsw / 2
	elseif ( xalign == TEXT_ALIGN_RIGHT ) then
		tx = x + w - tsw
	end

	if ( yalign == TEXT_ALIGN_CENTER ) then
		ty = y + h / 2 - tsh / 2
	elseif ( yalign == TEXT_ALIGN_BOTTOM ) then
		ty = y + h - tsh
	end

	surface.SetTextPos( math.ceil( tx ), math.ceil( ty ) )
	surface.DrawText( text )
end

function CLASS:Render()
	BASE.Render(self)

	local x, y = self:GetRenderPos()
	local w, h = self:GetSize()

	local col = self.Colors.Main or color_black
	local font = self.TextData.Font

	surface.SetFont( font )
	surface.SetTextColor( col:Unpack() )

	self:DrawText(self.InternalText, x, y, w, h)
end

function CLASS:SetTextColor(...)
	return self:SetColor(...)
end

function CLASS:GetTextColor(...)
	return self:GetColor(...)
end

function CLASS:SetText(text)
	self.TextData.Text = normalize_text(text)
end

function CLASS:GetText()
	return self.TextData.Text or ""
end

function CLASS:GetTextSize()
	if SERVER then return 0, 0 end

	surface.SetFont(self.TextData.Font)
	local w, h = surface.GetTextSize(self.TextData.Text)
	return w or 0, h or 0
end

function CLASS:SetFont(font)
	if SERVER then return end
	self.TextData.Font = font or ""
end

function CLASS:GetFont()
	if SERVER then return end
	return self.TextData.Font or ""
end

function CLASS:SetAlign(alignX, alignY)
	if SERVER then return end
	self.TextData.AlignX = alignX or TEXT_ALIGN_LEFT
	self.TextData.AlignY = alignY or TEXT_ALIGN_TOP
end

function CLASS:GetAlign()
	if SERVER then return end
	return self.TextData.AlignX or TEXT_ALIGN_LEFT, self.TextData.AlignY or TEXT_ALIGN_TOP
end

function CLASS:SetShorter(text)
	if SERVER then return end
	self.TextData.Shorter = normalize_text(text)
end

function CLASS:GetShorter()
	if SERVER then return end
	return self.TextData.Shorter or ""
end

function CLASS:SetShorterAtEnd(bool)
	if SERVER then return end
	self.TextData.ShorterEnd = bool or false
end

function CLASS:GetShorterAtEnd()
	if SERVER then return end
	return self.TextData.ShorterEnd or false
end

function CLASS:AutoWidth(maxwidth)
	if SERVER then return end
	maxwidth = maxwidth or 0

	local textw = self:GetTextSize()
	textw = math.Clamp(textw, 0, maxwidth)

	self:SetWidth(textw)
end

function CLASS:AutoHeight(maxheight)
	if SERVER then return end
	maxheight = maxheight or 0

	local _, texth = self:GetTextSize()
	texth = math.Clamp(texth, 0, maxheight)

	self:SetHeight(texth)
end

function CLASS:AutoSize(maxwidth, maxheight)
	if SERVER then return end
	maxwidth = maxwidth or 0
	maxheight = maxheight or 0

	local textw, texth = self:GetTextSize()
	textw = math.Clamp(textw, 0, maxwidth)
	texth = math.Clamp(texth, 0, maxheight)

	self:SetSize(textw, texth)
end

function CLASS:OnModelSetup(setup)
	BASE.OnModelSetup(self, setup)

	if setup.font then
		self:SetFont(setup.font)
	end
end

return true


--PATH lua/streamradio_core/classes/ui/radio/gui_player_controls.lua:
local StreamRadioLib = StreamRadioLib

if not istable(CLASS) then
	StreamRadioLib.ReloadClasses()
	return
end

local BASE = CLASS:GetBaseClass()

local g_mat_play = StreamRadioLib.GetPNGIcon("control_play")
local g_mat_pause = StreamRadioLib.GetPNGIcon("control_pause")
local g_mat_stop = StreamRadioLib.GetPNGIcon("control_stop")
local g_mat_back = StreamRadioLib.GetPNGIcon("control_start")
local g_mat_forward = StreamRadioLib.GetPNGIcon("control_end")
local g_mat_volumedown = StreamRadioLib.GetPNGIcon("sound_delete")
local g_mat_volumeup = StreamRadioLib.GetPNGIcon("sound_add")

-- the time bar is updated less often when the song is longer than an hour
local g_slowDisplayLength = 60 * 60

local g_mat_playback_modes = {
	[StreamRadioLib.PLAYBACK_LOOP_MODE_NONE] = StreamRadioLib.GetPNGIcon("arrow_not_refresh", true),
	[StreamRadioLib.PLAYBACK_LOOP_MODE_SONG] = StreamRadioLib.GetPNGIcon("arrow_refresh"),
	[StreamRadioLib.PLAYBACK_LOOP_MODE_PLAYLIST] = StreamRadioLib.GetPNGIcon("table_refresh"),
}

local g_tooltip_playback_modes = {
	[StreamRadioLib.PLAYBACK_LOOP_MODE_NONE] = "Change loop mode\n(currently: No loop)",
	[StreamRadioLib.PLAYBACK_LOOP_MODE_SONG] = "Change loop mode\n(currently: Song loop)",
	[StreamRadioLib.PLAYBACK_LOOP_MODE_PLAYLIST] = "Change loop mode\n(currently: Playlist loop)",
}

local g_next_playback_modes = {
	[StreamRadioLib.PLAYBACK_LOOP_MODE_NONE] = StreamRadioLib.PLAYBACK_LOOP_MODE_SONG,
	[StreamRadioLib.PLAYBACK_LOOP_MODE_SONG] = StreamRadioLib.PLAYBACK_LOOP_MODE_PLAYLIST,
	[StreamRadioLib.PLAYBACK_LOOP_MODE_PLAYLIST] = StreamRadioLib.PLAYBACK_LOOP_MODE_NONE,
}

local function FormatTime(seconds)
	seconds = tonumber(seconds or 0) or 0

	local rs, ms = math.modf(seconds)
	ms = math.floor(ms * 100)

	local s = rs % 60
	local m = math.floor((rs / 60) % 60)

	local rh = math.floor(rs / 3600)
	local h = rh % 24
	local d = math.floor(rh / 24)

	return d, h, m, s, ms
end

local function GetTimeFormated(seconds, timeScale)
	seconds = tonumber(seconds or 0) or 0
	timeScale = tonumber(timeScale or 0) or 0

	if timeScale <= 0 then
		timeScale = seconds
	end

	local d, h, m, s, ms = FormatTime(seconds)

	local scale_1m = 60
	local scale_1h = scale_1m * 60
	local scale_1d = scale_1h * 24

	if timeScale < scale_1h then
		return string.format("%01i:%02i.%02i", m, s, ms)
	end

	if timeScale < scale_1d then
		return string.format("%01i:%02i:%02i", h, m, s)
	end

	return string.format("%01i:%02i:%02i:%02i", d, h, m, s)
end

local function FormatTimeleft(time, len)
	time = time or 0
	len = len or 0

	local timef = GetTimeFormated(time, len)
	local lenf = nil

	if len > 0 then
		lenf = GetTimeFormated(len)
	end

	if lenf then
		return string.format("%s / %s" , timef, lenf)
	end

	return timef
end

function CLASS:Create()
	BASE.Create(self)

	self.StreamOBJ = nil

	self.PlayPauseButton = self:AddPanelByClassname("button", true)
	self.PlayPauseButton:SetIcon(g_mat_play)
	self.PlayPauseButton:SetName("play")
	self.PlayPauseButton:SetNWName("pl")
	self.PlayPauseButton:SetSkinIdentifyer("button")
	self.PlayPauseButton.DoClick = function()
		local stream = self.StreamOBJ
		if not IsValid(stream) then return end

		if stream:IsKilled() then
			stream:ReviveStream()
		end

		local isPlayMode = stream:IsPlayMode()

		if isPlayMode then
			self:CallHook("OnPause")
			stream:Pause()
			return
		end

		self:TriggerPlay()
	end

	self.BackButton = self:AddPanelByClassname("button", true)
	self.BackButton:SetIcon(g_mat_back)
	self.BackButton:SetName("back")
	self.BackButton:SetNWName("bk")
	self.BackButton:SetSkinIdentifyer("button")
	self.BackButton:SetTooltip("Previous track")
	self.BackButton.DoClick = function()
		self:CallHook("OnPlaylistBack")
	end

	self.ForwardButton = self:AddPanelByClassname("button", true)
	self.ForwardButton:SetIcon(g_mat_forward)
	self.ForwardButton:SetName("forward")
	self.ForwardButton:SetNWName("fw")
	self.ForwardButton:SetSkinIdentifyer("button")
	self.ForwardButton:SetTooltip("Next track")
	self.ForwardButton.DoClick = function()
		self:CallHook("OnPlaylistForward")
	end

	self.StopButton = self:AddPanelByClassname("button", true)
	self.StopButton:SetIcon(g_mat_stop)
	self.StopButton:SetName("stop")
	self.StopButton:SetNWName("sp")
	self.StopButton:SetSkinIdentifyer("button")
	self.StopButton:SetTooltip("Stop playback")
	self.StopButton.DoClick = function()
		if not IsValid(self.StreamOBJ) then return end
		self:CallHook("OnStop")
		self.StreamOBJ:Stop()
	end

	self.VolumeDownButton = self:AddPanelByClassname("button", true)
	self.VolumeDownButton:SetIcon(g_mat_volumedown)
	self.VolumeDownButton:SetName("volumedown")
	self.VolumeDownButton:SetNWName("vdn")
	self.VolumeDownButton:SetSkinIdentifyer("button")
	self.VolumeDownButton:SetTooltip("Decrease volume")
	self.VolumeDownButton.OnMousePressed = function()
		if CLIENT then return end
		if not IsValid(self.StreamOBJ) then return end

		local newvol = self.StreamOBJ:GetVolume()
		newvol = newvol - 0.1
		newvol = math.Clamp(newvol, 0, 1)

		self.StreamOBJ:SetVolume(newvol)
		self:CallHook("OnVolumeDown", newvol)
	end

	self.VolumeUpButton = self:AddPanelByClassname("button", true)
	self.VolumeUpButton:SetIcon(g_mat_volumeup)
	self.VolumeUpButton:SetName("volumeup")
	self.VolumeUpButton:SetNWName("vup")
	self.VolumeUpButton:SetSkinIdentifyer("button")
	self.VolumeUpButton:SetTooltip("Increase volume")
	self.VolumeUpButton.OnMousePressed = function()
		if CLIENT then return end
		if not IsValid(self.StreamOBJ) then return end

		local newvol = self.StreamOBJ:GetVolume()
		newvol = newvol + 0.1
		newvol = math.Clamp(newvol, 0, 1)

		self.StreamOBJ:SetVolume(newvol)
		self:CallHook("OnVolumeUp", newvol)
	end

	self.VolumeUpButton.DoClick = function(this)
		this.IsPressed = true
		this.LastClickTime = RealTime()
		this:OnMousePressed()
	end

	self.VolumeUpButton.OnMouseReleased = function(this)
		this.IsPressed = nil
		this.LastClickTime = nil
	end

	self.VolumeUpButton.Think = function(this)
		if not this.IsPressed then
			return
		end

		local lastclicktime = this.LastClickTime or 0
		local clickdistance = RealTime() - lastclicktime

		if clickdistance <= 0.5 then
			return
		end

		this.LastClickTime = RealTime() - 0.45
		this:CallHook("OnMousePressed")
	end

	self.VolumeDownButton.DoClick = self.VolumeUpButton.DoClick
	self.VolumeDownButton.OnMouseReleased = self.VolumeUpButton.OnMouseReleased
	self.VolumeDownButton.Think = self.VolumeUpButton.Think

	self.PlaybackLoopModeButton = self:AddPanelByClassname("button", true)
	self.PlaybackLoopModeButton:SetName("playback-mode")
	self.PlaybackLoopModeButton:SetNWName("pm")
	self.PlaybackLoopModeButton:SetSkinIdentifyer("button")

	self.PlaybackLoopModeButton.DoClick = function()
		local loopMode = self._currentLoopMode or StreamRadioLib.PLAYBACK_LOOP_MODE_NONE
		local newLoopMode = g_next_playback_modes[loopMode] or StreamRadioLib.PLAYBACK_LOOP_MODE_NONE

		self:CallHook("OnPlaybackLoopModeChange", newLoopMode)
	end

	self.Buttons = {}
	table.insert(self.Buttons, self.PlayPauseButton)
	table.insert(self.Buttons, self.StopButton)
	table.insert(self.Buttons, self.BackButton)
	table.insert(self.Buttons, self.ForwardButton)
	table.insert(self.Buttons, self.VolumeDownButton)
	table.insert(self.Buttons, self.VolumeUpButton)
	table.insert(self.Buttons, self.PlaybackLoopModeButton)

	self.PlayBar = self:AddPanelByClassname("progressbar", true)
	self.PlayBar:SetName("progressbar")
	self.PlayBar:SetNWName("pbar")
	self.PlayBar:SetSkinIdentifyer("progressbar")
	self.PlayBar.FractionChangeText = function(this, v)
		local stream = self.StreamOBJ
		if not IsValid(stream) then return end

		if stream:GetMuted() then
			return "Muted"
		end

		if stream:IsKilled() then
			return "Sound stopped!"
		end

		if stream:IsCheckingUrl() then
			return "Checking URL..."
		end

		if stream:IsDownloading() then
			return "Downloading..."
		end

		if stream:IsLoading() then
			return "Loading..."
		end

		if stream:IsBuffering() then
			return "Buffering..."
		end

		if stream:HasError() then
			return "Error!"
		end

		if stream:IsStopMode() then
			return "Stopped"
		end

		local len = stream:GetLength()
		local time = stream:GetTime()

		return FormatTimeleft(time, len)
	end

	-- @TODO: Fix that seaking is CLIENT -> SERVER instead if SERVER -> CLIENT
	self.PlayBar.OnFractionChangeEdit = function(this, v)
		local stream = self.StreamOBJ
		if not IsValid(stream) then return end

		local noise = math.random() * 0.00001
		local len = stream:GetMasterLength()

		-- add a minimal noise to the value, so we force the change in any case
		stream:SetTime(len * v - noise, true)
	end

	self.State = self:CreateListener({
		PlaylistEnabled = true,
	}, function(this, k, v)
		if IsValid(self.BackButton) then
			self.BackButton:SetVisible(v)
		end

		if IsValid(self.ForwardButton) then
			self.ForwardButton:SetVisible(v)
		end

		self:UpdatePlaybackLoopMode(self._currentLoopMode)
		self:InvalidateLayout()
	end)

	self:UpdatePlaybackLoopMode()
	self:UpdatePlayBar()

	self.PlayBar:SetSize(1, 1)

	if CLIENT then
		self:StartFastThink()
	end

	self:InvalidateLayout()
end

function CLASS:PerformLayout(...)
	BASE.PerformLayout(self, ...)

	local w, h = self:GetClientSize()

	local margin = self:GetMargin()
	local minbarw = (h + margin) * 1.618 * 2
	local buttoncount = 0
	local buttonw = h
	local buttonh = h
	local wpos = 0
	local hpos = 0
	local hasplaybar = IsValid(self.PlayBar) and self.PlayBar.Layout.Visible
	local buttons = self.Buttons or {}

	for k, v in ipairs(buttons) do
		if not IsValid(v) then continue end
		if not v.Layout.Visible then continue end

		wpos = wpos + buttonw + margin
		buttoncount = buttoncount + 1
	end

	local barw = w - wpos
	local oneline = hasplaybar and (barw > minbarw or w > ((h + margin) * buttoncount))
	local hasbuttons = buttoncount > 0

	wpos = 0
	if oneline then
		if barw < minbarw and hasbuttons then
			barw = 0
			hasplaybar = false
			buttonw = (w - margin * (buttoncount - 1)) / buttoncount
		end

		for k, v in ipairs(buttons) do
			if not IsValid(v) then continue end
			if not v.Layout.Visible then continue end

			v:SetSize(buttonw, buttonh)
			v:SetPos(wpos, hpos)

			wpos = wpos + buttonw + margin
		end
	else
		buttonw = 0
		barw = w

		if hasbuttons then
			buttonw = (w - margin * (buttoncount - 1)) / buttoncount
			if hasplaybar then
				buttonh = (h - margin) / 2
			end
		end

		hpos = hasplaybar and buttonh + margin or 0

		for k, v in ipairs(buttons) do
			if not IsValid(v) then continue end
			if not v.Layout.Visible then continue end

			v:SetSize(buttonw, buttonh)
			v:SetPos(wpos, hpos)

			wpos = wpos + buttonw + margin
		end

		wpos = 0
	end

	local barh = h
	if hasbuttons and not oneline then
		barh = buttonh
	end

	if IsValid(self.PlayBar) then
		self.PlayBar:SetSize(barw, barh)
		self.PlayBar:SetPos(wpos, 0)
	end
end

function CLASS:Remove()
	if IsValid(self.StreamOBJ) then
		self.StreamOBJ:RemoveEvent("OnTrackEnd", self:GetID())
		self.StreamOBJ:RemoveEvent("OnVolumeChange", self:GetID())
		self.StreamOBJ:RemoveEvent("OnPlayModeChange", self:GetID())

		if CLIENT then
			self.StreamOBJ:RemoveEvent("OnSeekingStart", self:GetID())
			self.StreamOBJ:RemoveEvent("OnSeekingEnd", self:GetID())
			self.StreamOBJ:RemoveEvent("OnMute", self:GetID())
			self.StreamOBJ:RemoveEvent("OnClose", self:GetID())

			self.StreamOBJ:RemoveEvent("OnSearch", self:GetID())
			self.StreamOBJ:RemoveEvent("OnConnect", self:GetID())
			self.StreamOBJ:RemoveEvent("OnError", self:GetID())
		end
	end

	BASE.Remove(self)
end

function CLASS:UpdateButtons()
	local stream = self.StreamOBJ
	if not IsValid(stream) then return end

	local isPlayMode = stream:IsPlayMode()
	local isStopMode = stream:IsStopMode()

	local syncMode = self:GetSyncMode()

	if IsValid(self.PlayPauseButton) then
		self.PlayPauseButton:SetIcon(isPlayMode and g_mat_pause or g_mat_play)
		self.PlayPauseButton:SetTooltip(isPlayMode and "Pause playback" or "Start playback")
		self.PlayPauseButton:SetDisabled(syncMode)
	end

	if IsValid(self.StopButton) then
		self.StopButton:SetDisabled(isStopMode or syncMode)
	end
end

function CLASS:UpdatePlayBar()
	if SERVER then return end

	if not IsValid(self.PlayBar) then
		return
	end

	if not self.PlayBar:IsVisibleSimple() then
		return
	end

	self.PlayBar:UpdateText()
end

function CLASS:SetStream(stream)
	if self.StreamOBJ == stream then
		return
	end

	self.StreamOBJ = stream

	self:SetFastThinkRate(0)

	self:UpdateFromStream()
	self:UpdateButtons()
	self:UpdatePlayBar()

	if not IsValid(stream) then return end

	stream:SetEvent("OnTrackEnd", self:GetID(), function()
		if not IsValid(self) then return end
		if not IsValid(stream) then return end

		self:QueueCall("UpdatePlayBar")
		self:QueueCall("UpdateButtons")
	end)

	local function OnVolumeChange(this, vol)
		if not IsValid(self) then return end

		if IsValid(self.VolumeUpButton) then
			self.VolumeUpButton:SetDisabled(vol >= 1)
		end

		if IsValid(self.VolumeDownButton) then
			self.VolumeDownButton:SetDisabled(vol <= 0)
		end
	end

	local function OnPlayModeChange(this, mode)
		if not IsValid(self) then return end
		if not IsValid(stream) then return end

		local isPlayMode = stream:IsPlayMode()
		local isStopMode = stream:IsStopMode()

		if IsValid(self.PlayPauseButton) then
			self.PlayPauseButton:SetIcon(isPlayMode and g_mat_pause or g_mat_play)
			self.PlayPauseButton:SetTooltip(isPlayMode and "Pause playback" or "Start playback")
		end

		if IsValid(self.StopButton) then
			self.StopButton:SetDisabled(isStopMode or self:GetSyncMode())
		end

		self:QueueCall("UpdatePlayBar")
		self:QueueCall("UpdateButtons")
	end

	stream:SetEvent("OnVolumeChange", self:GetID(), OnVolumeChange)
	stream:SetEvent("OnPlayModeChange", self:GetID(), OnPlayModeChange)

	if CLIENT then
		local function UpdatePlayBar()
			if not IsValid(self) then
				return false
			end

			-- Force the think hook to call once when the stream state changes.
			self:SetFastThinkRate(0)

			self:QueueCall("UpdateButtons")
			self:QueueCall("UpdatePlayBar")

			return true
		end

		stream:SetEvent("OnSeekingStart", self:GetID(), UpdatePlayBar)
		stream:SetEvent("OnSeekingEnd", self:GetID(), UpdatePlayBar)
		stream:SetEvent("OnMute", self:GetID(), UpdatePlayBar)
		stream:SetEvent("OnClose", self:GetID(), UpdatePlayBar)

		stream:SetEvent("OnDownload", self:GetID(), UpdatePlayBar)
		stream:SetEvent("OnRetry", self:GetID(), UpdatePlayBar)
		stream:SetEvent("OnSearch", self:GetID(), UpdatePlayBar)
		stream:SetEvent("OnConnect", self:GetID(), UpdatePlayBar)
		stream:SetEvent("OnError", self:GetID(), UpdatePlayBar)
	end

	OnVolumeChange(stream, stream:GetVolume())
	OnPlayModeChange(stream)
end

function CLASS:GetStream()
	return self.StreamOBJ
end

function CLASS:UpdateFromStream()
	local StreamOBJ = self.StreamOBJ
	if not IsValid(StreamOBJ) then return end

	local len = StreamOBJ:GetLength()
	local time = StreamOBJ:GetTime()

	local isEndlessOrNoStream = StreamOBJ:IsEndless() or StreamOBJ:IsLoading() or StreamOBJ:HasError() or StreamOBJ:GetMuted() or StreamOBJ:IsKilled()

	-- @TODO: Fix that seaking is CLIENT -> SERVER instead if SERVER -> CLIENT.
	--        That's because self.PlayBar is disabled on the server as BASS streams don't exist on servers.
	--        Thus these checks below are buggy and will be fixed some day. It is difficult to fix right now.

	if IsValid(self.PlayBar) and self.PlayBar:IsVisibleSimple() then
		if isEndlessOrNoStream then
			self.PlayBar:SetFraction(0)
			self.PlayBar:SetAllowFractionEdit(false)
			self.PlayBar:SetDisabled(self:GetSyncMode())
		else
			self.PlayBar:SetFraction(time / len)
			self.PlayBar:SetAllowFractionEdit(StreamOBJ:CanSeek())
			self.PlayBar:SetDisabled(self:GetSyncMode() or not StreamOBJ:CanSeek())
		end
	end
end

function CLASS:ShouldPerformRerender()
	if SERVER then return false end

	local stream = self.StreamOBJ
	if not IsValid(stream) then return false end

	if not IsValid(self.PlayBar) then
		return false
	end

	if not self.PlayBar:IsVisibleSimple() then
		return false
	end

	if stream:GetMuted() then
		return false
	end

	if stream:IsKilled() then
		return false
	end

	if stream:HasError() then
		return false
	end

	if not stream:IsPlaying() then
		return false
	end

	return true
end

if CLIENT then
	function CLASS:FastThink()
		self.fastThinkRate = 10

		local stream = self.StreamOBJ
		if not IsValid(stream) then return end

		self.fastThinkRate = 0.25

		if not self:IsSeen() then return end
		if not self:IsVisible() then return end

		if stream:IsPlayMode() and not stream:IsKilled() then
			local len = stream:GetLength()

			if len < g_slowDisplayLength or stream:IsSeeking() then
				self.fastThinkRate = 0.05
			end
		end

		self:UpdateFromStream()

		if not self:ShouldPerformRerender() then return end

		self:UpdatePlayBar()
		self:PerformRerender(true)
	end
end

function CLASS:EnablePlaylist(bool)
	self.State.PlaylistEnabled = bool
end

function CLASS:IsPlaylistEnabled()
	return self.State.PlaylistEnabled or false
end

function CLASS:TriggerPlay()
	local stream = self.StreamOBJ

	if not IsValid(stream) then return end

	if stream:IsKilled() then
		stream:ReviveStream()
	end

	local isPlayMode = stream:IsPlayMode()

	if isPlayMode then
		return
	end

	local hasEnded = stream:HasEnded()

	self:CallHook("OnPlay")
	stream:Play(hasEnded)

	if hasEnded then
		stream:SetTime(0, true)
	end
end

function CLASS:UpdatePlaybackLoopMode(loopMode)
	loopMode = loopMode or StreamRadioLib.PLAYBACK_LOOP_MODE_NONE
	self._currentLoopMode = loopMode

	if IsValid(self.PlaybackLoopModeButton) then
		self.PlaybackLoopModeButton:SetIcon(g_mat_playback_modes[loopMode])
		self.PlaybackLoopModeButton:SetTooltip(g_tooltip_playback_modes[loopMode])

		local antiSpamTime = 1

		self.PlaybackLoopModeButton:SetDisabled(true)

		self:TimerOnce("PlaybackLoopModeButtonAntiSpam", antiSpamTime, function()
			if not IsValid(self.PlaybackLoopModeButton) then
				return
			end

			self.PlaybackLoopModeButton:SetDisabled(false)
		end)
	end

	local StreamOBJ = self.StreamOBJ

	if not IsValid(StreamOBJ) then
		return
	end

	if not StreamOBJ:HasEnded() then
		local time = StreamOBJ:GetMasterTime()

		-- make sure we reapply the time between mode changes, so it prevents jumping
		StreamOBJ:SetTime(time, true)
	else
		if loopMode ~= StreamRadioLib.PLAYBACK_LOOP_MODE_NONE then
			self:TriggerPlay()
		end
	end
end

function CLASS:SetSyncMode(bool)
	self._syncmode = bool or false

	if not IsValid(self.StreamOBJ) then return end

	if IsValid(self.BackButton) then
		self.BackButton:SetDisabled(bool)
	end

	if IsValid(self.ForwardButton) then
		self.ForwardButton:SetDisabled(bool)
	end

	if IsValid(self.PlaybackLoopModeButton) then
		self.PlaybackLoopModeButton:SetDisabled(bool)
	end

	if IsValid(self.PlayBar) then
		self.PlayBar:SetDisabled(bool)
	end

	self:UpdateButtons()
	self:UpdatePlayBar()
end

function CLASS:GetSyncMode()
	return self._syncmode or false
end

return true


--PATH lua/streamradio_core/classes/stream.lua:
local StreamRadioLib = StreamRadioLib

if not istable(CLASS) then
	StreamRadioLib.ReloadClasses()
	return
end

local tostring = tostring
local tonumber = tonumber
local isfunction = isfunction
local IsValid = IsValid
local Vector = Vector

local string = string
local math = math
local SERVER = SERVER
local CLIENT = CLIENT

local EmptyVector = Vector()

local BASS3 = nil

local LIBNetwork = StreamRadioLib.Network
local LIBBass = StreamRadioLib.Bass
local LIBError = StreamRadioLib.Error
local LIBUtil = StreamRadioLib.Util
local LIBUrl = StreamRadioLib.Url
local LIBStream = StreamRadioLib.Stream
local LIBString = StreamRadioLib.String

local BASE = CLASS:GetBaseClass()
local g_maxSongLenForCache = 60 * 60 * 1.5 -- 1.5 Hours

local function LoadBass()
	local hasBass = LIBBass.LoadDLL()

	if hasBass and not BASS3 then
		BASS3 = _G.BASS3
	end

	return hasBass
end

local function ChannelIsCacheAble( channel )
	if not IsValid( channel ) then return false end

	local len = channel:GetLength( )
	if len <= 0 then
		return false
	end

	if len > g_maxSongLenForCache then
		return false
	end

	return true
end

local function ChannelStop( channel )
	if not channel then
		return
	end

	channel:Stop()

	if channel.Remove then
		channel:Remove( )
	end

	LIBBass.ClearCache()
	return
end

local retry_timeout_max = 3

local retry_errors_non3d = {
	[41] = true,
	[21] = true,
	[22] = true,
	[2] = true,
	[-1] = true
}

local retry_errors_block = {
	[41] = true,
	[21] = true,
	[22] = true,
	[2] = true,
	[-1] = true
}

local retry_errors_urlblocked = {
	[LIBError.STREAM_ERROR_URL_NOT_WHITELISTED] = true,
	[LIBError.STREAM_ERROR_URL_BLOCKED] = true,
}

local function loadLibs()
	if LIBError.STREAM_ERROR_CFCHTTP_BLOCKED_URI then
		retry_errors_urlblocked[LIBError.STREAM_ERROR_CFCHTTP_BLOCKED_URI] = true
	end
end

function CLASS:Create()
	BASE.Create(self)

	if loadLibs then
		loadLibs()
		loadLibs = nil
	end

	self.Channel = nil
	self.TimeOffset = 0
	self.ChannelChanged = false
	self.nextUrlBackgroundCheck = 0
	self.urlBackgroundCheckRuns = nil

	self._converter_downloads = {}
	self._cache_downloads = {}

	if CLIENT then
		self.ConVarGlobalVolume = StreamRadioLib.Settings.GetConVar("volume")
		if IsValid(self.ConVarGlobalVolume) then
			self.ConVarGlobalVolume:SetEvent("OnChange", self:GetID(), function()
				self:UpdateChannelVolume()
			end)
		end
	end

	self.URL = self:CreateListener({
		external = "",
		internal = "",
	}, function(this, k, v)
		if k == "external" then
			self.URL.internal = ""

			local rawv = v

			v = string.Trim(tostring(v or ""))
			v = LIBUrl.SanitizeUrl(v)

			if rawv ~= v then
				-- avoid calling it twice on unclean input
				self.URL.external = v
				return
			end

			self:SetNWString("URL", v)

			self.TimeOffset = 0
			self._wouldpredownload = nil
			self._LastMasterState = nil
			self._server_override_timedata = nil
			self.Old_ClientStateListBuffer = nil
			self:SetClientStateOnServer("Time", 0)

			self._isCached = nil
			self._isOnline = nil
			self._interfaceName = nil
			self._isOnlineUrl = LIBUrl.IsOnlineURL(v)
			self._isCheckingUrl = nil

			self.ChannelChanged = true
			self:Update()
		end
	end)

	if CLIENT then
		self.WSData = self:CreateListener({
			WorldSound = false,

			Position = EmptyVector,
			Forward = EmptyVector,
			Velocity = EmptyVector,

			DistanceStart = 0,
			DistanceEnd = 0,

			InnerAngle = 360,
			OuterAngle = 360,
			OutVolume = 1,
		}, function(this, k, v)
			if k == "WorldSound" then
				self:QueueCall("Reconnect")
			end

			self:UpdateChannelWS()
		end)
	end

	self.Volume = self:CreateListener({
		SVMul = 1,
		CLMul = 1,
		MuteSlide = false,
	}, function(this, k, v)
		if k ~= "MuteSlide" then
			v = tonumber(v) or 0
			v = math.Clamp(v, 0, 1)

			self.Volume[k] = v
		end

		if k == "SVMul" then
			self:CallHook("OnVolumeChange", v)
			self:SetNWFloat("Volume", v)
		end

		self:UpdateChannelVolume()
	end)

	self._isseeking = false

	self.StateTable = {
		"Error",
		"Time",
		"ForceTime",
		"Length",
		"Ended",
		"ValidChannel",
	}

	self.StateTable_r = {}

	for i, v in ipairs(self.StateTable) do
		self.StateTable_r[v] = i
	end

	LIBBass.ClearCache()

	self.State = self:CreateListener({
		Error = 0,
		PlayMode = StreamRadioLib.STREAM_PLAYMODE_STOP,
		Length = 0,
		Stopped = true,
		Ended = false,
		Loop = false,
		Muted = false,
		Name = "",
		Seeking = false,
		ValidChannel = false,
		HasBass = CLIENT and LoadBass(),
	}, function(this, k, v)
		if k == "PlayMode" then
			self:UpdateChannelPlayMode()
			self:SetNWInt("PlayMode", v)
			self:CallHook("OnPlayModeChange", v)
		end

		if k == "Loop" then
			self:UpdateChannelLoop()
			self:SetNWBool("Loop", v)
		end

		if k == "Stopped" and v then
			self:CallHook("OnClose")

			if CLIENT then
				self.State.HasBass = LoadBass()
			end
		end

		if k == "Muted" then
			self:UpdateChannelMuted()
			self:CallHook("OnMute", v)

			if CLIENT then
				self.State.HasBass = LoadBass()
			end
		end

		if k == "Name" then
			self:RemoveChannel(true)
			self:Reconnect()
			self:SetNWString("Name", v)
		end

		if k == "Ended" and v then
			self:Pause()
			self:CallHook("OnTrackEnd")
		end

		if k == "HasBass" then
			self:Reconnect()
		end

		if k == "Seeking" then
			if v then
				self._isseeking = true
				self:CallHook("OnSeekingStart")
				self:TimerRemove("seeking")

				if IsValid(self.Channel) then
					self.Channel:Pause()
				end

				-- force seeking to end after 10 secounds
				self:TimerOnce("seeking", 10, function()
					self._targettime = nil
					self._isseeking = false

					if not self.State.Ended then
						self:UpdateChannelPlayMode()
					end

					self:CallHook("OnSeekingEnd")
				end)
			else
				self._targettime = nil
				self:TimerOnce("seeking", 0.2, function()
					self._isseeking = false

					if not self.State.Ended then
						self:UpdateChannelPlayMode()
					end

					self:CallHook("OnSeekingEnd")
				end)
			end

			self.Volume.MuteSlide = v
		end

		self:SetClientStateOnServer(k, v)
	end)

	for i, key in ipairs(self.StateTable) do
		local value = self.State[key]
		if key == "Time" then
			value = value or 0
		end

		if key == "ForceTime" then
			value = -1
		end

		if value == nil then
			continue
		end

		self:SetClientStateOnServer(key, value)
	end

	if SERVER then
		LIBNetwork.AddNetworkString("clientstate")

		self:NetReceive("clientstate", function(this, id, len, ply)
			local bufferlen = net.ReadUInt(16)

			for i = 1, bufferlen do
				local key = net.ReadUInt(4)

				key = self.StateTable[key]
				if not key then return end

				local value = nil

				if key == "Error" then
					value = net.ReadInt(24)
				elseif key == "Time" then
					value = net.ReadDouble()
				elseif key == "ForceTime" then
					value = net.ReadDouble()
				elseif key == "Length" then
					value = net.ReadDouble()
				else
					value = net.ReadBool()
				end

				self:SetClientState(ply, key, value)
			end
		end)
	end

	self:StartFastThink()
end

function CLASS:ActivateNetworkedMode()
	BASE.ActivateNetworkedMode(self)

	if SERVER then
		self:SetNWFloat("Volume", self.Volume.SVMul)
		self:SetNWString("URL", self.URL.external)
		self:SetNWInt("PlayMode", self.State.PlayMode)
		self:SetNWBool("Loop", self.State.Loop)
		self:SetNWString("Name", self.State.Name)
		return
	end

	self:SetNWVarCallback("Volume", "Float", function(this, nwkey, oldvar, newvar)
		self.Volume.SVMul = newvar
	end)

	self:SetNWVarCallback("URL", "String", function(this, nwkey, oldvar, newvar)
		self.URL.external = newvar
	end)

	self:SetNWVarCallback("PlayMode", "Int", function(this, nwkey, oldvar, newvar)
		self.State.PlayMode = newvar
	end)

	self:SetNWVarCallback("Loop", "Bool", function(this, nwkey, oldvar, newvar)
		self.State.Loop = newvar
	end)

	self:SetNWVarCallback("Name", "String", function(this, nwkey, oldvar, newvar)
		self.State.Name = newvar
	end)

	self.Volume.SVMul = self:GetNWFloat("Volume", 1)
	self.URL.external = self:GetNWString("URL", "")
	self.State.PlayMode = self:GetNWInt("PlayMode", StreamRadioLib.STREAM_PLAYMODE_STOP)
	self.State.Loop = self:GetNWBool("Loop", false)
	self.State.Name = self:GetNWString("Name", "")
end

function CLASS:SetClientStateOnServer(key, value)
	if not self.Network.Active then return end
	if not key then return end
	if not self.StateTable_r[key] then return end

	if SERVER then
		if key ~= "ForceTime" then
			if self._wouldpredownload then return end
		end

		self:SetClientState("SERVER", key, value)
		return
	end

	self.ClientStateListBuffer = self.ClientStateListBuffer or {}
	self.ClientStateListBuffer[key] = value

	self:QueueCall("NetworkClientState")
end

function CLASS:NetworkClientState()
	if SERVER then return end

	self.Old_ClientStateListBuffer = self.Old_ClientStateListBuffer or {}

	local sendbuffer = {}

	for key, value in pairs(self.ClientStateListBuffer or {}) do
		local key_index = self.StateTable_r[key]
		if not key_index then continue end

		if value == self.Old_ClientStateListBuffer[key] then
			continue
		end

		local item = {
			key = key,
			key_index = key_index,
			value = value,
		}

		table.insert(sendbuffer, item)

		self.Old_ClientStateListBuffer[key] = value
	end

	self:NetSend("clientstate", function()
		net.WriteUInt(#sendbuffer, 16)

		for i, v in pairs(sendbuffer) do
			local key = v.key
			local value = v.value

			net.WriteUInt(v.key_index, 4)

			if key == "Error" then
				net.WriteInt(value or 0, 24)
			elseif key == "Time" then
				net.WriteDouble(value or 0)
			elseif key == "ForceTime" then
				net.WriteDouble(value or 0)
			elseif key == "Length" then
				net.WriteDouble(value or 0)
			else
				net.WriteBool(value or false)
			end
		end
	end)
end

function CLASS:CleanUpClientStateList()
	if not self.ClientStateList then
		return
	end

	for pId, state in pairs(self.ClientStateList) do
		if pId == "SERVER" then
			continue
		end

		if StreamRadioLib.IsPlayerNetworkable(pId) then
			continue
		end

		self.ClientStateList[pId] = nil
	end
end

function CLASS:SetClientState(ply, key, value)
	if CLIENT then return end
	if not self.Network.Active then return end

	if not ply then return end
	if not key then return end

	local key_index = self.StateTable_r[key]
	if not key_index then return end

	local pId = nil

	if ply == "SERVER" then
		pId = ply
	else
		pId = StreamRadioLib.GetPlayerId(ply)
	end

	if not pId then return end

	self.ClientStateList = self.ClientStateList or {}
	self.ClientStateList[pId] = self.ClientStateList[pId] or {
		Error = 0,
		Ended = false,
		ValidChannel = false,
		Time = 0,
		Length = -1,
		TimeStamp = self.PlayTime or 0,
	}

	if key == "Time" then
		value = math.max(value, 0)
		self.ClientStateList[pId].TimeStamp = self.PlayTime or 0
	end

	if key == "ForceTime" then
		if value >= 0 then
			if pId ~= "SERVER" then
				self.TimeMaster = nil
				self._LastMasterState = nil
				self._server_override_timedata = nil
			end

			for k, v in pairs(self.ClientStateList) do
				self.ClientStateList[k].Time = value
				self.ClientStateList[k].TimeStamp = self.PlayTime or 0
			end
		end

		value = nil
	end

	self.ClientStateList[pId][key] = value

	if not self:IsValidTimeMaster(self.TimeMaster) then
		self.TimeMaster = nil

		if self:IsValidTimeMaster(pId) then
			self.TimeMaster = pId
			self._LastMasterState = nil
			self._server_override_timedata = nil
		end
	end

	if pId == "SERVER" then
		self:CallHook("OnServerStateChange", ply, key, value)
	else
		self:CallHook("OnClientStateChange", ply, key, value)
	end
end

function CLASS:GetClientStates(plyOrPId)
	if CLIENT then return nil end

	if not plyOrPId then return nil end
	if not self.ClientStateList then return nil end

	if plyOrPId == "SERVER" then
		return self.ClientStateList["SERVER"]
	end

	if not StreamRadioLib.IsPlayerNetworkable(plyOrPId) then
		self:CleanUpClientStateList()
		return nil
	end

	if isentity(plyOrPId) then
		plyOrPId = StreamRadioLib.GetPlayerId(plyOrPId)
	end

	if not plyOrPId then
		return nil
	end

	return self.ClientStateList[plyOrPId]
end

function CLASS:IsValidTimeMaster(plyOrPId)
	if CLIENT then return false end

	local state = self:GetClientStates(plyOrPId)
	if not state then return false end

	local haschannel = state.ValidChannel
	if not haschannel then return false end

	local err = state.Error or 0
	if err ~= 0 then return false end

	local timestamp = state.TimeStamp or 0
	if timestamp < 0 then return false end

	local time = state.Time
	if not time then return false end

	return true
end

function CLASS:GetTimeMasterClientState()
	if self:IsValidTimeMaster(self.TimeMaster) then
		local state = self:GetClientStates(self.TimeMaster)

		if state and not state._comp then
			state._comp = self.TimeMaster
		end

		return state
	end

	self.TimeMaster = nil

	if not self.ClientStateList then
		return nil
	end

	for pId, state in pairs(self.ClientStateList) do
		if not self:IsValidTimeMaster(pId) then continue end

		self.TimeMaster = pId

		if state and not state._comp then
			state._comp = self.TimeMaster
		end

		return state
	end

	return nil
end

function CLASS:CalcTime()
	local thistime = RealTime()
	local oldlt = self._lt or thistime
	self._lt = thistime

	self.TickTime = thistime - oldlt

	self.PlayTime = self.PlayTime or 0

	if self:IsPlayMode() then
		self.PlayTime = self.PlayTime + self.TickTime
	end
end

function CLASS:FastThink()
	self:CalcTime()

	local masterLength = self:GetMasterLength()

	self.State.Ended = self:HasEndedInternal()
	self.State.Seeking = self:_IsSeekingInternal()
	self.State.Length = self:GetLength()
	self.State.ValidChannel = IsValid(self.Channel)

	if SERVER then
		local timeA = self:GetMasterTime()

		if game.SinglePlayer() then
			self:SetNWFloat("MasterTime", timeA)
		else
			local timeB = self:GetNWFloat("MasterTime", 0)
			local dt = math.abs(timeA - timeB)
			local tickTime = engine.TickInterval()

			-- add random noise to avoid uneven network load
			local random = math.random() * 0.2
			local maxDt = 0.4 + random

			if masterLength > 0 then
				maxDt = math.min(math.max(masterLength / 4, tickTime * 4), maxDt)
			end

			if dt >= maxDt then
				self:SetNWFloat("MasterTime", timeA)
			end
		end
	end

	self:SyncTime()
	self:DoUrlBackgroundCheck()

	if CLIENT then
		self:DoUnexpectedStopCheck()
	end
end

function CLASS:DoUnexpectedStopCheck()
	if not self:HasChannel() then
		return
	end

	if self:HasError() then
		return
	end

	if not self:IsStopped() then
		return
	end

	if not self:IsPlayMode() then
		return
	end

	if self:HasEnded() then
		return
	end

	self:KillStream()
end

function CLASS:IsAllowedUrlPair(externalUrl, internalUrl, callback, logFailure)
	self:IsAllowedInternalUrl(internalUrl, function(this, allowed, err)
		-- Ask CFC first (internal URL), so we can show errors right away.
		-- It should appear in a higher priority to the user then the in-addon whitelisting.

		if not allowed then
			callback(this, false, err)
			return
		end

		self:IsAllowedExternalUrl(externalUrl, callback)
	end, logFailure)
end

function CLASS:IsAllowedInternalUrl(url, callback, logFailure)
	StreamRadioLib.Cfchttp.IsAllowedAsync(url, function(allowed)
		if not IsValid(self) then return end

		if not allowed then
			callback(self, allowed, LIBError.STREAM_ERROR_CFCHTTP_BLOCKED_URI)
			return
		end

		callback(self, true, nil)
	end, logFailure)
end

function CLASS:IsAllowedExternalUrl(url, callback)
	if self:CallHook("CanSkipUrlChecks", url) then
		-- Sometimes we want to ignore the addon's whitelist
		callback(self, true, nil)
		return
	end

	local ent = self:GetEntity()
	local context = StreamRadioLib.Whitelist.BuildContext(ent)

	StreamRadioLib.Whitelist.IsAllowedAsync(url, context, function(allowed, blockedByHook)
		if not IsValid(self) then return end

		if not allowed then
			if self:CallHook("CanBypassUrlBlock", url, blockedByHook) then
				-- Sometimes we want to ignore the block, but still to perform the checks.
				callback(self, true, nil)
				return
			end

			if blockedByHook then
				callback(self, allowed, LIBError.STREAM_ERROR_URL_BLOCKED)
				return
			end

			callback(self, false, LIBError.STREAM_ERROR_URL_NOT_WHITELISTED)
			return
		end

		callback(self, true, nil)
	end)
end

function CLASS:DoUrlBackgroundCheck()
	-- This will automatically stop the running stream if its URL is not allowed.
	-- And it also will automatically reconnect the stream if it was blocked/stopped by the whitelist protection.

	if self.urlBackgroundCheckRuns then
		return
	end

	local now = RealTime()

	if self.nextUrlBackgroundCheck > now then
		return
	end

	self.nextUrlBackgroundCheck = now + 1 + math.random() * 9

	if self:GetMuted() then
		return
	end

	if self:IsKilled() then
		return
	end

	if not self:IsActive() then
		return
	end

	if not self:IsOnlineUrl() then
		return
	end

	local externalUrl = self.URL.external
	local internalUrl = self.URL.internal

	if externalUrl == "" then
		return
	end

	if internalUrl == "" then
		return
	end

	self.urlBackgroundCheckRuns = true

	self:IsAllowedUrlPair(externalUrl, internalUrl, function(this, isAllowed)
		self.nextUrlBackgroundCheck = RealTime() + 1 + math.random() * 9
		self.urlBackgroundCheckRuns = nil

		if self:GetMuted() then
			return
		end

		if self:IsKilled() then
			return
		end

		if not self:IsActive() then
			return
		end

		if not self:IsOnlineUrl() then
			return
		end

		local isWhitelistError = retry_errors_urlblocked[self:GetError()]

		if not isAllowed then
			if not isWhitelistError then
				-- Attempt to reconnect respecting the changed rules. It will likely fail and run its complex error handling.
				self:Reconnect()
			end
		else
			if isWhitelistError then
				-- We are allowed to play again, so let's go.
				self:Reconnect()
			end
		end
	end, false)
end

function CLASS:CallEx(func, callnow, ...)
	if callnow then
		self:CallHook(func, ...)
		return
	end

	self:QueueCall(func, ...)
end

function CLASS:Update(callnow)
	self:CallEx("UpdateInternal", callnow)
end

function CLASS:UpdateInternal()
	if not self.Valid then return end
	self.State.Stopped = false

	if self:GetMuted() then
		return
	end

	if self.ChannelChanged then
		self:Connect()
		self.ChannelChanged = false
		return
	end

	if not self:IsActiveOrLoading() then
		self:Connect()
		self.ChannelChanged = false
		return
	end

	self:UpdateChannel()
	return
end

function CLASS:UpdateChannelMuted()
	if self:GetMuted() then
		self:RemoveChannel()
		return
	end

	self:Reconnect()
end

function CLASS:UpdateChannelWS()
	if not self:Is3DChannel() then return end

	local WSData = self.WSData
	local Channel = self.Channel

	Channel:SetPos( WSData.Position, WSData.Forward, WSData.Velocity )
	Channel:Set3DFadeDistance( WSData.DistanceStart, WSData.DistanceEnd )
	Channel:Set3DCone( WSData.InnerAngle, WSData.OuterAngle, WSData.OutVolume )
end

function CLASS:UpdateChannelVolume()
	if SERVER then return end
	if not self.Valid then return end
	if not IsValid( self.ConVarGlobalVolume ) then return end
	if not IsValid( self.Channel ) then return end

	local boost3d = self:Is3DChannel() and 2.00 or 1.00

	local SVvol = self.Volume.SVMul
	local CLvol = self.Volume.CLMul
	local MuteSlide = self.Volume.MuteSlide

	local volume = 0

	if not MuteSlide then
		volume = SVvol * CLvol * self.ConVarGlobalVolume:GetValue() * boost3d
	end

	-- Max 5000% normal volume on all cases.
	volume = math.Clamp(volume, 0, 50)

	self.Channel:SetVolume(volume)
end

function CLASS:UpdateChannel()
	if not self.Valid then return end
	if not IsValid( self.Channel ) then return end

	self:UpdateChannelPlayMode()
	self:UpdateChannelVolume()
	self:UpdateChannelLoop()
	self:UpdateChannelWS()
end

function CLASS:UpdateChannelPlayMode()
	if not self.Valid then return end
	local playmode = self.State.PlayMode

	if self.URL.external == "" then
		self:RemoveChannel(true)
		self.State.Stopped = true
		return
	end

	if playmode == StreamRadioLib.STREAM_PLAYMODE_STOP then
		self:RemoveChannel(true)
		self.State.Stopped = true
		return
	end

	if not IsValid(self.Channel) then
		self.ChannelChanged = true
		self:Update()
		return
	end

	if playmode == StreamRadioLib.STREAM_PLAYMODE_PAUSE then
		self.Channel:Pause()
		return
	end

	if playmode == StreamRadioLib.STREAM_PLAYMODE_PLAY_RESTART then
		self:SetTime(0)
		self.Channel:Play()
		self.State.PlayMode = StreamRadioLib.STREAM_PLAYMODE_PLAY
		return
	end

	if playmode == StreamRadioLib.STREAM_PLAYMODE_PLAY then
		self.Channel:Play()
		return
	end
end

function CLASS:UpdateChannelLoop()
	if not self.Valid then return end
	if not IsValid(self.Channel) then return end
	if self.Channel:IsBlockStreamed() then return end

	self.Channel:EnableLooping(self.State.Loop)
end

function CLASS:RemoveChannel(clearlast)
	ChannelStop(self.Channel)

	self._streamTaskUid = nil
	self.urlBackgroundCheckRuns = nil

	self.Channel = nil
	self.State.Error = LIBError.STREAM_OK
	self._tags = nil
	self._isCached = nil
	self._isOnline = nil
	self._interfaceName = nil
	self._isCheckingUrl = nil

	LIBUtil.EmptyTableSafe(self._converter_downloads)
	LIBUtil.EmptyTableSafe(self._cache_downloads)

	if clearlast then
		self.TimeOffset = 0
		self._wouldpredownload = nil
		self._LastMasterState = nil
		self._server_override_timedata = nil

		self.Old_ClientStateListBuffer = nil
		self:SetClientStateOnServer("Time", 0)
	end
end

function CLASS:Remove()
	self:RemoveChannel(true)

	if IsValid(self.ConVarGlobalVolume) then
		self.ConVarGlobalVolume:RemoveEvent("OnChange", self:GetID())
	end

	BASE.Remove(self)
end

local g_string_format = string.format

function CLASS:ToString()
	local baseToString = BASE.ToString

	if not baseToString then
		return nil
	end

	local r = baseToString(self)
	if not self.Valid then
		return r
	end

	local channel = self:GetChannel()
	local channelStr = tostring(channel or "no channel")

	local err = self:GetError()
	local errName = LIBError.GetStreamErrorName(err) or ""

	local str = g_string_format("%s <%s> [err: %i, %s]", r, channelStr, err, errName)
	return str
end

function CLASS:__eq( other )
	if not BASE.__eq(self, other) then return false end
	if self.Channel == other.Channel then return true end

	return false
end

function CLASS:IsDownloading()
	if not self.Valid then return false end
	if not self._converter_downloads then return false end

	return not table.IsEmpty(self._converter_downloads)
end

function CLASS:IsDownloadingToCache()
	if not self.Valid then return false end
	if not self._cache_downloads then return false end

	return not table.IsEmpty(self._cache_downloads)
end

function CLASS:SetBASSEngineEnabled(bool)
	bool = bool or false

	if bool then
		bool = LoadBass()
	end

	self.State.HasBass = bool
end

function CLASS:IsBASSEngineEnabled()
	if not LIBBass.HasLoadedDLL() then return false end
	return self.State.HasBass or false
end

function CLASS:_IsActiveStreamTaskUid(streamTaskUid)
	if not self.Valid then return false end

	if not streamTaskUid then
		ErrorNoHaltWithStack("Bad streamTaskUid!")
		return false
	end

	if self.URL.external == "" then return false end
	if not self._streamTaskUid then return false end
	if self._streamTaskUid ~= streamTaskUid then return false end

	if self:GetMuted() then return false end
	if self.State.Stopped then return false end

	if IsValid(self.Channel) then return false end
	if self:HasError() then return false end

	return true
end

function CLASS:AcceptError(err)
	self:AcceptStream(nil, err)
end

function CLASS:AcceptStream(channel, err)
	local errOk = LIBError.STREAM_OK

	err = tonumber(err or errOk) or errOk

	if not IsValid(channel) or err ~= errOk then
		ChannelStop(channel)
		channel = nil

		if err == errOk then
			err = LIBError.STREAM_ERROR_UNKNOWN
		end
	end

	ChannelStop(self.Channel)

	self:CleanUpClientStateList()

	self._streamTaskUid = nil
	self._isCheckingUrl = nil

	if err == errOk then
		self.Channel = channel
		self._tags = nil
		self.State.Error = errOk

		self:UpdateChannel()
		self:CallHook("OnConnect", self.Channel)
	else
		self.Channel = nil
		self._tags = nil
		self.State.Error = err

		self:SetClientStateOnServer("Time", 0)
		self:CallHook("OnError", self.State.Error)

		-- make sure we also trigger mute on "stopsound" concommand
		if err == LIBError.STREAM_SOUND_STOPPED then
			self:CallHook("OnMute", true)
		end
	end
end

function CLASS:Reconnect()
	self:RemoveChannel()
	self:Connect()
end

function CLASS:Connect()
	self._streamTaskUid = LIBUtil.Uid()
	local streamTaskUid = self._streamTaskUid

	self:TimerOnce("stream", 0.01, function()
		if not self:_IsActiveStreamTaskUid(streamTaskUid) then
			return
		end

		local externalUrl = self.URL.external

		if self.State.PlayMode == StreamRadioLib.STREAM_PLAYMODE_STOP or externalUrl == "" then
			self:UpdateChannelPlayMode()
			return
		end

		if not self:CallHook("OnSearch", externalUrl) then
			self:AcceptError(LIBError.STREAM_ERROR_FILEOPEN)
			return
		end

		self:StartConnectingProcess(streamTaskUid, false)
	end)
end

function CLASS:StartConnectingProcess(streamTaskUid, nodownload)
	if not self:_IsActiveStreamTaskUid(streamTaskUid) then
		return
	end

	if not self.State.HasBass and SERVER then
		self:AcceptError(LIBError.STREAM_ERROR_MISSING_GM_BASS3)
		return
	end

	local externalUrl = self.URL.external

	StreamRadioLib.Interface.Convert(externalUrl, function(interface, success, internalUrl, errorcode)
		if not self:_IsActiveStreamTaskUid(streamTaskUid) then
			return
		end

		if not interface then
			self:AcceptError(LIBError.STREAM_ERROR_UNKNOWN)
			return
		end

		self.URL.internal = internalUrl

		local isOnline = interface.online
		local isCached = interface.cache
		local interfaceName = interface.name

		self._isCached = isCached
		self._isOnline = isOnline
		self._interfaceName = interfaceName

		if not success then
			self:AcceptError(errorcode)
			return
		end

		self:IsAllowedUrlPair(externalUrl, internalUrl, function(this, allowed, blockErrorCode)
			if not self:_IsActiveStreamTaskUid(streamTaskUid) then
				return
			end

			if not allowed then
				self:AcceptError(blockErrorCode)
				return
			end

			if not isOnline then
				self:RunConnectingProcessWithoutDownload(streamTaskUid, interface, internalUrl)
				return
			end

			local downloadFirst = interface.downloadFirst

			if isCached then
				downloadFirst = false
			end

			if nodownload then
				downloadFirst = false
			end

			-- Avoid many connection requests starting at once by adding a random delay
			local loadBalanceTimeout = 0.25 + math.random() * 0.75

			self:TimerOnce("stream", loadBalanceTimeout, function()
				if not downloadFirst then
					self:RunConnectingProcessWithoutDownload(streamTaskUid, interface, internalUrl)
					return
				end

				self:RunConnectingProcessWithDownload(streamTaskUid, interface, internalUrl)
			end)
		end, true)
	end)
end

function CLASS:RunConnectingProcessWithDownload(streamTaskUid, interface, internalUrl)
	if not self:_IsActiveStreamTaskUid(streamTaskUid) then
		return
	end

	local canDownload = self:CallHook("OnDownload", internalUrl, interface)

	if not canDownload then
		self:RunConnectingProcessWithoutDownload(streamTaskUid, interface, internalUrl)
		return
	end

	local downloadTimeout = interface.downloadTimeout or 0
	local externalUrl = self.URL.external

	local function afterConvertedDownload()
		if not IsValid(self) then return end

		self:TimerRemove("download_timeout")

		if not self._converter_downloads[streamTaskUid] then return end
		self._converter_downloads[streamTaskUid] = nil

		if not self:_IsActiveStreamTaskUid(streamTaskUid) then return end

		-- restart the process, so we can switch to a newly created cache

		self:SetTime(0)
		self:StartConnectingProcess(streamTaskUid, true)
	end

	self._converter_downloads[streamTaskUid] = true
	self._wouldpredownload = true

	self:TimerRemove("download_timeout")

	if downloadTimeout > 0 then
		self:TimerOnce("download_timeout", downloadTimeout, afterConvertedDownload)
	end

	StreamRadioLib.Cache.Download(internalUrl, afterConvertedDownload, externalUrl)
end

function CLASS:RunConnectingProcessWithoutDownload(streamTaskUid, interface, internalUrl)
	if not self:_IsActiveStreamTaskUid(streamTaskUid) then
		return
	end

	self:_RunConnectingProcessInternal(streamTaskUid, interface, internalUrl)
end

function CLASS:_RunConnectingProcessInternal(streamTaskUid, interface, internalUrl, state)
	if not self:_IsActiveStreamTaskUid(streamTaskUid) then
		return
	end

	local WSData = self.WSData

	local isOnline = interface.online

	state = state or {}
	state = table.Copy(state)

	state.no3d = state.no3d or false
	state.retrycount = state.retrycount or 0

	if state.noBlock == nil then
		state.noBlock = true
	end

	if SERVER then
		state.no3d = true
	end

	if not WSData or not WSData.WorldSound then
		state.no3d = true
	end

	local worldSound = not state.no3d
	local noBlock = state.noBlock

	local errOk = LIBError.STREAM_OK

	local callback = function(channel, err)
		err = tonumber(err or errOk) or errOk

		if not IsValid(self) then
			ChannelStop(channel)
			return
		end

		if not self:_IsActiveStreamTaskUid(streamTaskUid) then
			ChannelStop(channel)
			return
		end

		if not IsValid(channel) or err ~= errOk then
			ChannelStop(channel)
			channel = nil

			if err == errOk then
				err = LIBError.STREAM_ERROR_UNKNOWN
			end
		end

		self:_ConnectChannelCallback(streamTaskUid, channel, err, interface, internalUrl, state)
	end

	local hasBass = self.State.HasBass

	if isOnline then
		LIBStream.PlayOnline(internalUrl, hasBass, worldSound, noBlock, callback)
		return
	end

	LIBStream.PlayOffline(internalUrl, hasBass, worldSound, noBlock, callback)
end

local function debugRetry(format, err, externalUrl, internalUrl, ...)
	if not LIBUtil.IsDebug() then return end

	local text = string.format(format, ...)

	local errorInfo = LIBError.GetStreamErrorInfo(err)

	local errorCode = errorInfo.id
	local errorName = errorInfo.name

	StreamRadioLib.Print.Debug(
		"%s\n- Error: %d, %s\n- External URL: %s\n- Internal URL: %s",
		text,
		errorCode,
		errorName,
		externalUrl,
		internalUrl
	)
end

function CLASS:_ConnectChannelCallback(streamTaskUid, channel, err, interface, internalUrl, state)
	local externalUrl = self.URL.external

	state = state or {}

	local no3d = state.no3d
	local noBlock = state.noBlock
	local isOnline = interface.online

	local retryDelay = isOnline and 2 or 0

	-- retry max 3 times on timeout
	if err == LIBError.STREAM_ERROR_TIMEOUT then
		local retrycount = state.retrycount

		if retrycount >= retry_timeout_max then
			debugRetry(
				"[Timeout] Timeout after %d attempts.",
				err,
				externalUrl,
				internalUrl,
				retrycount
			)

			self:AcceptError(err)
			return
		end

		if not self:CallHook("OnRetry", err, internalUrl, state, interface) then
			self:AcceptError(err)
			return
		end

		self:TimerOnce("stream", retryDelay, function()
			if not self:_IsActiveStreamTaskUid(streamTaskUid) then return end

			retrycount = retrycount + 1
			state.retrycount = retrycount

			debugRetry(
				"[Timeout] Retrying stream after timeout, attempt #%d / %d.",
				err,
				externalUrl,
				internalUrl,
				retrycount,
				retry_timeout_max
			)

			self:_RunConnectingProcessInternal(streamTaskUid, interface, internalUrl, state)
		end)

		return
	end

	state.retrycount = 0

	-- retry in Non-3D if 3D is not working
	if not no3d and retry_errors_non3d[err] then
		if not self:CallHook("OnRetry", err, internalUrl, state, interface) then
			self:AcceptError(err)
			return
		end

		self:TimerOnce("stream", retryDelay, function()
			if not self:_IsActiveStreamTaskUid(streamTaskUid) then return end

			state.no3d = true

			debugRetry(
				"[3D sound] Retrying stream without 3D sound after error.",
				err,
				externalUrl,
				internalUrl
			)

			self:_RunConnectingProcessInternal(streamTaskUid, interface, internalUrl, state)
		end)

		return
	end

	-- retry in block mode if no-block mode is not working
	if noBlock and retry_errors_block[err] then
		if not self:CallHook("OnRetry", err, internalUrl, state, interface) then
			self:AcceptError(err)
			return
		end

		self:TimerOnce("stream", retryDelay, function()
			if not self:_IsActiveStreamTaskUid(streamTaskUid) then return end

			state.noBlock = false

			debugRetry(
				"[Block mode] Retrying stream in block mode after error.",
				err,
				externalUrl,
				internalUrl
			)

			self:_RunConnectingProcessInternal(streamTaskUid, interface, internalUrl, state)
		end)

		return
	end

	self:_SaveChannelToCache(streamTaskUid, channel, interface, internalUrl)

	self:AcceptStream(channel, err)
end

function CLASS:_SaveChannelToCache(streamTaskUid, channel, interface, internalUrl)
	local externalUrl = self.URL.external

	local isOnline = interface.online
	local isCache = interface.cache
	local allowCaching = interface.allowCaching

	if not ChannelIsCacheAble(channel) then
		-- remove broken cache file

		if isOnline then
			StreamRadioLib.Cache.DeleteFileForUrl(externalUrl)
		end

		if isCache then
			StreamRadioLib.Cache.DeleteFileRaw(internalUrl)
		end

		return
	end

	if not isOnline then
		return
	end

	if not allowCaching then
		StreamRadioLib.Cache.DeleteFileForUrl(externalUrl)
		return
	end

	local canDownload = self:CallHook("OnDownload", internalUrl, interface)
	if not canDownload then
		return
	end

	local afterCacheDownload = function()
		if not IsValid( self ) then
			return
		end

		self._cache_downloads[streamTaskUid] = nil
	end

	self._cache_downloads[streamTaskUid] = true

	StreamRadioLib.Cache.Download(internalUrl, afterCacheDownload, externalUrl)
end

function CLASS:GetStreamName( )
	if not self.Valid then return "" end
	return self.State.Name or ""
end

function CLASS:SetStreamName(name)
	if not self.Valid then return end
	self.State.Name = name or ""
end

function CLASS:Play( restart )
	if not self.Valid then return end
	if CLIENT and self.Network.Active then return end

	self.State.PlayMode = restart and StreamRadioLib.STREAM_PLAYMODE_PLAY_RESTART or StreamRadioLib.STREAM_PLAYMODE_PLAY
end

function CLASS:IsPlayMode()
	if not self.Valid then return false end

	if self.State.PlayMode == StreamRadioLib.STREAM_PLAYMODE_PLAY then return true end
	if self.State.PlayMode == StreamRadioLib.STREAM_PLAYMODE_PLAY_RESTART then return true end

	return false
end

function CLASS:Pause()
	if not self.Valid then return end
	if CLIENT and self.Network.Active then return end
	if self:IsPauseMode() then return end

	self._oldbeforepause = self.State.PlayMode
	self.State.PlayMode = StreamRadioLib.STREAM_PLAYMODE_PAUSE
end

function CLASS:UnPause()
	if not self.Valid then return end
	if CLIENT and self.Network.Active then return end

	if not self._oldbeforepause then return end
	if not self:IsPauseMode() then return end

	local oldbeforepause = self._oldbeforepause
	self._oldbeforepause = nil

	if oldbeforepause == StreamRadioLib.STREAM_PLAYMODE_PLAY then
		self:Play(self:HasEnded())
		return
	end

	if oldbeforepause == StreamRadioLib.STREAM_PLAYMODE_PLAY_RESTART then
		self:Play(true)
		return
	end

	self.State.PlayMode = StreamRadioLib.STREAM_PLAYMODE_STOP
end

function CLASS:IsPauseMode()
	if not self.Valid then return false end
	return self.State.PlayMode == StreamRadioLib.STREAM_PLAYMODE_PAUSE
end

function CLASS:Stop()
	if not self.Valid then return end
	if CLIENT and self.Network.Active then return end

	self.State.PlayMode = StreamRadioLib.STREAM_PLAYMODE_STOP
end

function CLASS:IsStopMode()
	if not self.Valid then return true end
	return self.State.PlayMode == StreamRadioLib.STREAM_PLAYMODE_STOP
end

function CLASS:SetPlayingState(mode)
	if not self.Valid then return end
	if CLIENT and self.Network.Active then return end

	self.State.PlayMode = mode or StreamRadioLib.STREAM_PLAYMODE_STOP
end

function CLASS:GetPlayingState()
	if not self.Valid then return StreamRadioLib.STREAM_PLAYMODE_STOP end

	return self.State.PlayMode or StreamRadioLib.STREAM_PLAYMODE_STOP
end

function CLASS:GetChannel()
	if not self.Valid then return nil end
	if not IsValid( self.Channel ) then return nil end

	return self.Channel
end

function CLASS:GetError()
	if not self.Valid then
		return LIBError.STREAM_OK
	end

	local state = self.State
	if not state then
		return LIBError.STREAM_OK
	end

	return state.Error or LIBError.STREAM_OK
end

function CLASS:HasError()
	if not self.Valid then return false end
	return self:GetError() ~= LIBError.STREAM_OK
end

function CLASS:HasChannel()
	if not self.Valid then return false end
	return self:GetChannel() ~= nil
end

function CLASS:SetURL(url)
	if not self.Valid then return end
	if CLIENT and self.Network.Active then return end

	self.URL.external = LIBUrl.SanitizeUrl(url)
end

function CLASS:GetURL()
	if not self.Valid then return "" end

	local url = LIBUrl.SanitizeUrl(self.URL.external)
	return url
end

function CLASS:GetInternalURL()
	if not self.Valid then return "" end

	local url = self.URL.internal
	return url
end

function CLASS:SetLoop(var)
	if not self.Valid then return end
	if CLIENT and self.Network.Active then return end

	self.State.Loop = var or false
end

function CLASS:GetLoop()
	if not self.Valid then return false end
	return self.State.Loop or false
end

function CLASS:Set3D(var)
	if SERVER then return end
	if not self.Valid then return end

	self.WSData.WorldSound = var or false
end

function CLASS:Get3D()
	if SERVER then return false end
	if not self.Valid then return false end

	return self.WSData.WorldSound
end

function CLASS:Is3DChannel()
	if SERVER then return false end
	if not self.Valid then return false end
	if not IsValid( self.Channel ) then return false end

	return self.Channel:Is3D()
end

function CLASS:GetFilename()
	if not self.Valid then return "" end
	if not IsValid( self.Channel ) then return "" end

	return self.Channel:GetFileName( )
end

function CLASS:GetLevel()
	if not self.Valid then return 0, 0 end
	if not IsValid( self.Channel ) then return 0, 0 end

	local L, R = self.Channel:GetLevel()
	return L or 0, R or 0
end

function CLASS:GetAverageLevel()
	local L, R = self:GetLevel()

	return (L + R) / 2
end

function CLASS:GetLength()
	if not self.Valid then return -1 end
	if not IsValid(self.Channel) then return -1 end

	local length = self.Channel:GetLength( )

	if length <= 0 then
		length = -1
	end

	return length
end

function CLASS:GetRealTime()
	if not self.Valid then return 0 end
	if not IsValid( self.Channel ) then return 0 end

	local time = self.Channel:GetTime() or 0
	local length = self.Channel:GetLength()

	if length > 0 then
		time = math.min(time, length)
	end

	time = math.max(time, 0)
	return time
end

function CLASS:GetMasterTime()
	if not self.Valid then return 0 end

	if SERVER then
		local state = self:GetTimeMasterClientState() or self._LastMasterState
		if not state then return 0 end

		if not self._LastMasterState or self._LastMasterState._comp ~= state._comp then
			self._LastMasterState = table.Copy(state)
		end

		if self._server_override_timedata then
			-- Server should be able to override the time even so if not players can hear the stream
			state = self._server_override_timedata
		end

		local thistime = self.PlayTime or 0

		local timestamp = state.TimeStamp
		if not timestamp then return 0 end

		local time = state.Time
		if not time then return 0 end

		local len = self:GetMasterLength()
		local loop = self:GetLoop()

		local offset = thistime - timestamp
		local calctime = math.max(time + offset, 0)

		if len > 0 then
			if loop then
				calctime = calctime % len
			end

			calctime = math.min(calctime, len)
		end

		return calctime
	end

	return self:GetNWFloat("MasterTime", 0)
end

function CLASS:GetMasterLength()
	if not self.Valid then return -1 end

	if SERVER then
		local state = self:GetTimeMasterClientState() or self._LastMasterState
		if not state then return self:GetLength() end

		if not self._LastMasterState or self._LastMasterState._comp ~= state._comp then
			self._LastMasterState = table.Copy(state)
		end

		local len = state.Length or self:GetLength()
		return len
	end

	return self:GetLength()
end

function CLASS:GetTime()
	if not self.Valid then return 0 end
	if not IsValid( self.Channel ) then return 0 end

	local time = self:GetRealTime()
	local length = self:GetLength()

	if self:IsEndless() then
		time = time + self.TimeOffset
	end

	if length > 0 then
		time = math.min(time, length)
	end

	time = math.max(time, 0)
	return time
end

function CLASS:SetTime(time, force)
	if not self.Valid then return end

	time = tonumber(time) or 0

	if time <= 0 then
		time = 0
	end

	self.State.Time = time

	if force then
		self:SetClientStateOnServer("ForceTime", time)

		if SERVER then
			self._server_override_timedata = {
				TimeStamp = self.PlayTime or 0,
				Time = time,
			}
		end
	else
		self:SetClientStateOnServer("ForceTime", -1)
	end

	if not IsValid(self.Channel) then return end

	if not self:CanSeek() then
		return
	end

	self:_SetTimeInternal(time)
end

function CLASS:_SetTimeInternal(time)

	time = tonumber(time) or 0
	time = math.max(time, 0)

	local length = self:GetLength()

	if self:IsEndless() then
		self.TimeOffset = time - self:GetRealTime()
		return
	end

	self.TimeOffset = 0

	if not self:CanSeek() then
		return
	end

	self.State.Seeking = true
	self._isseeking = true

	if self:GetLoop() then
		time = time % length
	end

	time = math.min(time, length)

	self._targettime = time
	self:_SetTimeToTargetInternal()
end

function CLASS:_SetTimeToTargetInternal()
	if not IsValid(self.Channel) then return end
	if not self._targettime then return end

	self:TimerRemove("SetTimeToTargetInternal")

	if not self:CanSeek() then
		return
	end

	if self.State.HasBass then
		self.Channel:SetTime(self._targettime)
		return
	end

	local seakToFunc = function()
		if not IsValid(self.Channel) then return true end
		if not self._targettime then return true end

		if not self:CanSeek() then
			return true
		end

		local length = self:GetLength()

		local thistime = self.Channel:GetTime()
		thistime = math.Clamp(thistime, 0, length)

		local targettime = self._targettime
		targettime = math.Clamp(targettime, 0, length)

		if thistime == targettime then
			return true
		end

		-- an attempt to ease it a bit on the performance impact
		local random = math.random() * 2
		local step = math.Clamp(LIBUtil.RealTimeFps() * 0.03 + random, 2, 15)
		local time = math.Approach(thistime, targettime, step)

		time = math.Clamp(time, 0, length)

		-- set the time in non-decode mode, so we keep sane frame rates
		self.Channel:SetTime(time, true)

		if time == targettime then
			return true
		end

		return false
	end

	-- avoid game hiccup during track seeking
	self:TimerUntil("SetTimeToTargetInternal", 0.001, seakToFunc)
	seakToFunc()
end

function CLASS:SyncTime()
	if not self.Valid then return end
	if LIBUtil.GameIsPaused() then return end
	if self:IsStopMode() then return end

	local maxdelta = 1.5

	local time = self:GetMasterTime()

	local length = self:GetLength()
	local curtime = self:GetTime()
	local loop = self:GetLoop()

	if length > 0 then
		local tickLen = engine.TickInterval()
		local minDelta = tickLen * 2
		local maxStartDelta = tickLen * 4

		if length <= maxStartDelta then
			-- never time synchronize extremely short sounds
			return
		end

		if length <= maxdelta and time > maxStartDelta then
			-- prevent permanent seeking loop for very short sounds (length less then 1.5s)
			-- <maxStartDelta> makes sure all clients start at the same time
			-- but ignore further synchronisations past <maxStartDelta>

			return
		end

		-- limit <maxdelta> to the length minus a small margin
		maxdelta = math.min(maxdelta, math.max(length - minDelta, maxStartDelta))
	end

	local maxdelta_half = maxdelta / 2
	local mintime = time - maxdelta_half
	local maxtime = time + maxdelta_half

	if loop and length > 0 then
		-- make sure we wrap the time around start and end currently
		mintime = (length + mintime) % length
		maxtime = (length + maxtime) % length
	end

	mintime = math.max(mintime, 0)
	maxtime = math.max(maxtime, 0)

	if maxtime > mintime then
		-- classic in between check
		if curtime < mintime then
			return self:_SetTimeInternal(time)
		end

		if curtime > maxtime then
			return self:_SetTimeInternal(time)
		end

		return
	end

	if curtime < mintime and curtime > maxtime then
		-- in between check that wraps around looped time positions
		return self:_SetTimeInternal(time)
	end
end

function CLASS:HasEnded()
	if not self.Valid then
		return false
	end

	return self.State.Ended
end

function CLASS:HasEndedInternal()
	if not self.Valid then
		return false
	end

	local curtime = 0
	local length = 0

	if self:GetMuted() then
		return false
	end

	if self:IsKilled() then
		return false
	end

	if not IsValid( self.Channel ) then
		if SERVER then
			local state = self:GetTimeMasterClientState()
			if not state then return false end

			return state.Ended
		end

		return false
	end

	if self:IsEndless() then
		return false
	end

	if self:GetLoop() then
		return false
	end

	local curtime = self:GetTime()
	local length = self:GetLength()
	local timeleft = length - curtime

	-- Sometimes the time can actually lag a bit behind the actual playback position.
	-- So we add a small tolerance to make sure it doesn't get stuck at like 99.999% of the track.
	local minTimeLeft = engine.TickInterval() * 2

	if timeleft > minTimeLeft then
		return false
	end

	return true
end

function CLASS:_IsSeekingInternal()
	if not self.Valid then return false end
	if not IsValid(self.Channel) then return false end

	if self.State.HasBass then
		return self.Channel:IsSeeking()
	end

	if not self:CanSeek() then return false end

	local targettime = self._targettime
	if not targettime then return false end

	local curtime = self:GetRealTime()
	local maxDelta = engine.TickInterval() * 8

	return math.abs(targettime - curtime) > maxDelta
end

function CLASS:IsSeeking()
	if not self.Valid then return false end
	return self._isseeking or false
end

function CLASS:SetMuted( muted )
	if not self.Valid then return end
	self.State.Muted = muted or false
end

function CLASS:GetMuted()
	if not self.Valid then return false end
	return self.State.Muted or false
end

function CLASS:IsKilled()
	if SERVER then return false end
	if not self.Valid then return false end

	return self:GetError() == LIBError.STREAM_SOUND_STOPPED
end

function CLASS:KillStream()
	if SERVER then return end
	if not self.Valid then return end
	if self:IsKilled() then return end

	self:RemoveChannel()
	self:AcceptError(LIBError.STREAM_SOUND_STOPPED)
end

function CLASS:ReviveStream()
	if SERVER then return end
	if not self.Valid then return end
	if not self:IsKilled() then return end

	self:Reconnect()
end

local function getTagsMetaAsTable(channel)
	local meta = channel:GetTagsMeta()
	if not meta then
		return nil
	end

	local result = LIBString.StreamMetaStringToTable(meta)
	return result
end

local g_tagFunctionMap = {
	[StreamRadioLib.TAG_META] = getTagsMetaAsTable,
	[StreamRadioLib.TAG_HTTP] = "GetTagsHTTP",
	[StreamRadioLib.TAG_ID3] = "GetTagsID3",
	[StreamRadioLib.TAG_OGG] = "GetTagsOGG",
	[StreamRadioLib.TAG_VENDOR] = "GetTagsVendor",
}

function CLASS:GetTag(tag)
	if not self.Valid then
		return nil
	end

	local channel = self.Channel
	if not IsValid(channel) then
		return nil
	end

	self._tags = self._tags or {}

	local tab = self._tags[tag] or {}
	self._tags[tag] = tab

	local data = tab.data or {}
	tab.data = data

	local nextCall = tab.nextCall or 0

	local now = RealTime()
	if nextCall > now then
		return data
	end

	tab.nextCall = now + 1

	if self.State.HasBass then
		channel:GetTag(tag, data)
		return data
	end

	local func = g_tagFunctionMap[tag]

	if isstring(func) then
		func = channel[func]
	end

	if not func then
		return nil
	end

	local result = func(channel)
	if not result then
		return nil
	end

	table.CopyFromTo(result, data)
	return data
end

function CLASS:GetMetaTags()
	if not self.Valid then
		return nil
	end

	local data = self:GetTag(StreamRadioLib.TAG_META)
	if not data then
		return nil
	end

	return data
end


function CLASS:GetSamplingRate()
	if not self.Valid then return -1 end
	if not IsValid( self.Channel ) then return -1 end

	return self.Channel:GetSamplingRate( )
end

function CLASS:GetBitsPerSample()
	if not self.Valid then return -1 end
	if not IsValid( self.Channel ) then return -1 end

	return self.Channel:GetBitsPerSample( )
end

function CLASS:GetAverageBitRate()
	if not self.Valid then return -1 end
	if self.State.HasBass then return -1 end -- not in gm_bass yet
	if not IsValid( self.Channel ) then return -1 end

	return self.Channel:GetAverageBitRate( )
end

function CLASS:GetType()
	if not self.Valid then return -1 end
	if not self.State.HasBass then return "UNKNOWN" end
	if not IsValid( self.Channel ) then return "UNKNOWN" end

	return self.Channel:GetFileFormat( )
end

function CLASS:SetVolume( volume )
	if CLIENT then return end
	if not self.Valid then return end
	self.Volume.SVMul = volume or 1
end

function CLASS:GetVolume()
	if not self.Valid then return 0 end
	return self.Volume.SVMul or 0
end

function CLASS:SetClientVolume( volume )
	if SERVER then return end
	if not self.Valid then return end

	self.Volume.CLMul = volume or 1
end

function CLASS:GetClientVolume()
	if SERVER then return 0 end
	if not self.Valid then return 0 end

	return self.Volume.CLMul or 0
end

function CLASS:Set3DPosition( Pos, For, Vel )
	if SERVER then return end
	if not self.Valid then return end

	local WSData = self.WSData

	WSData.Position = Pos or EmptyVector
	WSData.Forward = For or EmptyVector
	WSData.Velocity = Vel or EmptyVector
end

function CLASS:Get3DPosition()
	if SERVER then return EmptyVector, EmptyVector, EmptyVector end
	if not self.Valid then return EmptyVector, EmptyVector, EmptyVector end

	local WSData = self.WSData

	return WSData.Position or EmptyVector, WSData.Forward or EmptyVector, WSData.Velocity or EmptyVector
end

function CLASS:Set3DFadeDistance( diststart, distend )
	if SERVER then return end
	if not self.Valid then return end

	local WSData = self.WSData

	WSData.DistanceStart = diststart or 0
	WSData.DistanceEnd = distend or 0
end

function CLASS:Get3DFadeDistance()
	if SERVER then return 0, 0 end
	if not self.Valid then return 0, 0 end

	local WSData = self.WSData

	return WSData.DistanceStart or 0, WSData.DistanceEnd or 0
end

function CLASS:Set3DCone( iAngle, oAngle, outvolume )
	if SERVER then return end
	if not self.Valid then return end

	local WSData = self.WSData

	WSData.InnerAngle = iAngle or 0
	WSData.OuterAngle = oAngle or 0
	WSData.OutVolume = outvolume or 0
end

function CLASS:Get3DCone()
	if SERVER then return 0, 0, 0 end
	if not self.Valid then return 0, 0, 0 end

	local WSData = self.WSData

	return WSData.InnerAngle or 0, WSData.OuterAngle or 0, WSData.OutVolume or 0
end

CLASS.Set3dcone = CLASS.Set3DCone
CLASS.Get3dcone = CLASS.Get3DCone

function CLASS:IsOnline()
	if not self.Valid then return false end
	return self._isOnline or false
end

function CLASS:IsOnlineUrl()
	if not self.Valid then return false end
	return self._isOnlineUrl or false
end

function CLASS:GetActiveInterfaceName()
	if not self.Valid then return nil end

	local interfaceName = self._interfaceName
	if not interfaceName then return nil end

	return interfaceName
end

function CLASS:IsCached()
	if not self.Valid then return false end
	return self._isCached or false
end

function CLASS:IsCheckingUrl()
	if not self.Valid then return false end
	return self._isCheckingUrl or false
end

function CLASS:IsStopped()
	if not self.Valid then return false end
	if not IsValid( self.Channel ) then return true end

	if self.State.HasBass then
		return self.Channel:GetState( ) == BASS3.ENUM.CHANNEL_STOPPED
	else
		return self.Channel:GetState( ) == GMOD_CHANNEL_STOPPED
	end
end

function CLASS:IsPlaying()
	if not self.Valid then return false end
	if not IsValid( self.Channel ) then return false end

	if self.State.HasBass then
		return self.Channel:GetState( ) == BASS3.ENUM.CHANNEL_PLAYING
	else
		return self.Channel:GetState( ) == GMOD_CHANNEL_PLAYING
	end
end

function CLASS:IsBuffering()
	if not self.Valid then return false end
	if not IsValid( self.Channel ) then return false end

	if self.State.HasBass then
		return self.Channel:GetState( ) == BASS3.ENUM.CHANNEL_STALLED
	else
		return self.Channel:GetState( ) == GMOD_CHANNEL_STALLED
	end
end

function CLASS:IsLoading()
	if not self.Valid then return false end

	if self:HasChannel() then return false end
	if self:HasError() then return false end
	if self._streamTaskUid then return true end

	return false
end

function CLASS:IsActive()
	if not self.Valid then return false end

	if self._streamTaskUid then return false end
	if self:HasChannel() then return true end
	if self:HasError() then return true end

	return false
end

function CLASS:IsActiveOrLoading()
	if not self.Valid then return false end

	if self._streamTaskUid then return true end
	if self:HasChannel() then return true end
	if self:HasError() then return true end

	return false
end

function CLASS:IsRunning()
	if not self.Valid then return false end
	if not IsValid( self.Channel ) then return false end

	if self:IsPlaying() then return true end
	if self:IsLoading() then return true end
	if self:IsCheckingUrl() then return true end
	if self:IsBuffering() then return true end
	if self:IsSeeking() then return true end
	if IsValid( self.Channel ) then return true end

	return false
end

function CLASS:IsCacheAble()
	if not self.Valid then return false end

	return ChannelIsCacheAble( self.Channel )
end

function CLASS:IsEndless()
	if not self.Valid then return false end

	if self.State.HasBass then
		if not IsValid( self.Channel ) then return false end
		return self.Channel:IsEndless()
	end

	return self:GetLength() <= 0
end

function CLASS:IsBlockStreamed()
	if not self.Valid then return false end
	if not IsValid( self.Channel ) then return false end

	return self.Channel:IsBlockStreamed( )
end

function CLASS:CanSeek()
	if not self.Valid then return false end
	if not IsValid( self.Channel ) then return false end

	if self:IsEndless() then return false end
	if self:IsBlockStreamed() then return false end
	if self:IsStopped() then return false end

	local minLen = engine.TickInterval() * 4
	if self:GetMasterLength() <= minLen then return false end

	return true
end

function CLASS:IsLooping()
	if not self.Valid then return false end
	if self:IsEndless() then return false end

	if not IsValid( self.Channel ) then return false end
	return self.Channel:IsLooping()
end

function CLASS:GetSpectrumTable( bars, SPout, func, ... )
	if not self.Valid then return 0 end
	if not IsValid( self.Channel ) then return 0 end
	if self:IsSeeking() then return 0 end

	if ( not bars ) then return 0 end
	if ( bars <= 0 ) then return 0 end

	local count = 0
	local puffersize = bars

	if ( CLIENT ) then
		puffersize = math.Round( bars * ( 22050 / 17000 ) )
	end

	if self.State.HasBass then
		if ( puffersize <= 8 ) then
			count = self.Channel:FFT( SPout, BASS3.ENUM.FFT_16 )
		elseif ( puffersize > 8 ) and ( puffersize <= 16 ) then
			count = self.Channel:FFT( SPout, BASS3.ENUM.FFT_32 )
		elseif ( puffersize > 16 ) and ( puffersize <= 32 ) then
			count = self.Channel:FFT( SPout, BASS3.ENUM.FFT_64 )
		elseif ( puffersize > 32 ) and ( puffersize <= 64 ) then
			count = self.Channel:FFT( SPout, BASS3.ENUM.FFT_128 )
		elseif ( puffersize > 64 ) and ( puffersize <= 128 ) then
			count = self.Channel:FFT( SPout, BASS3.ENUM.FFT_256 )
		elseif ( puffersize > 128 ) and ( puffersize <= 256 ) then
			count = self.Channel:FFT( SPout, BASS3.ENUM.FFT_512 )
		elseif ( puffersize > 256 ) and ( puffersize <= 512 ) then
			count = self.Channel:FFT( SPout, BASS3.ENUM.FFT_1024 )
		elseif ( puffersize > 512 ) and ( puffersize <= 1024 ) then
			count = self.Channel:FFT( SPout, BASS3.ENUM.FFT_2048 )
		elseif ( puffersize > 1024 ) and ( puffersize <= 2048 ) then
			count = self.Channel:FFT( SPout, BASS3.ENUM.FFT_4096 )
		elseif ( puffersize > 2048 ) and ( puffersize <= 4096 ) then
			count = self.Channel:FFT( SPout, BASS3.ENUM.FFT_8192 )
		elseif ( puffersize > 4096 ) then
			count = self.Channel:FFT( SPout, BASS3.ENUM.FFT_16384 )
		end
	else
		if ( puffersize <= 128 ) then
			count = self.Channel:FFT( SPout, FFT_256 )
		elseif ( puffersize > 128 ) and ( puffersize <= 256 ) then
			count = self.Channel:FFT( SPout, FFT_512 )
		elseif ( puffersize > 256 ) and ( puffersize <= 512 ) then
			count = self.Channel:FFT( SPout, FFT_1024 )
		elseif ( puffersize > 512 ) and ( puffersize <= 1024 ) then
			count = self.Channel:FFT( SPout, FFT_2048 )
		elseif ( puffersize > 1024 ) and ( puffersize <= 2048 ) then
			count = self.Channel:FFT( SPout, FFT_4096 )
		elseif ( puffersize > 2048 ) and ( puffersize <= 4096 ) then
			count = self.Channel:FFT( SPout, FFT_8192 )
		elseif ( puffersize > 4096 ) then
			count = self.Channel:FFT( SPout, FFT_16384 )
		end
	end

	if ( SERVER ) then return count end
	if ( not func ) then return count end
	local crash = 100000

	for i = 1, bars do
		crash = crash - 1

		if ( crash == 0 ) then
			error( "Crash!" )
		end

		local bin = math.Round( count / puffersize * i )
		local level = ( SPout[bin] or 0 ) ^ 2
		level = ( math.log10( level ) / 10 )
		level = ( 1 - math.abs( level ) ) ^ 3 * 1.4
		if level <= 0 then continue end
		local Continue = func( i, level, bars, ... )
		if not Continue then break end
	end

	return count
end

local g_tempArray_fft = {}
local g_tempArray_fftc = {}

local g_powres_nobass = nil
local g_powres_bass = nil

local function buildpowres()
	if not g_powres_nobass then
		g_powres_nobass = {}

		g_powres_nobass[0] = FFT_256
		g_powres_nobass[1] = FFT_256
		g_powres_nobass[2] = FFT_256
		g_powres_nobass[3] = FFT_256
		g_powres_nobass[4] = FFT_256
		g_powres_nobass[5] = FFT_256
		g_powres_nobass[6] = FFT_256
		g_powres_nobass[7] = FFT_256
		g_powres_nobass[8] = FFT_512
		g_powres_nobass[9] = FFT_1024
		g_powres_nobass[10] = FFT_2048
		g_powres_nobass[11] = FFT_2048
		g_powres_nobass[12] = FFT_8192
		g_powres_nobass[13] = FFT_16384
		g_powres_nobass[14] = FFT_32768
	end

	if not g_powres_bass then
		if BASS3 and BASS3.ENUM and BASS3.ENUM.FFT_16 then
			g_powres_bass = {}

			g_powres_bass[0] = BASS3.ENUM.FFT_16
			g_powres_bass[1] = BASS3.ENUM.FFT_16
			g_powres_bass[2] = BASS3.ENUM.FFT_16
			g_powres_bass[3] = BASS3.ENUM.FFT_16
			g_powres_bass[4] = BASS3.ENUM.FFT_32
			g_powres_bass[5] = BASS3.ENUM.FFT_64
			g_powres_bass[6] = BASS3.ENUM.FFT_128
			g_powres_bass[7] = BASS3.ENUM.FFT_256
			g_powres_bass[8] = BASS3.ENUM.FFT_512
			g_powres_bass[9] = BASS3.ENUM.FFT_1024
			g_powres_bass[10] = BASS3.ENUM.FFT_2048
			g_powres_bass[11] = BASS3.ENUM.FFT_4096
			g_powres_bass[12] = BASS3.ENUM.FFT_8192
			g_powres_bass[13] = BASS3.ENUM.FFT_16384
			g_powres_bass[14] = BASS3.ENUM.FFT_32768
		end
	end
end

local function getBarFrequency( index, size, samplerate )
	index = math.floor( index or 0 )
	size = math.floor( size or 0 )

	if ( samplerate <= 0 ) then
		return -1
	end

	if ( size <= 0 ) then
		return -1
	end

	if ( index <= 0 ) then
		return -1
	end

	if ( index > size ) then
		size = index
	end

	return (index - 1) / (size * 2) * samplerate
end

function CLASS:GetSpectrum( resolution, func, minfrq, maxfrq )
	if not self.Valid then return false end
	if not IsValid(self.Channel) then return false end
	if self:IsSeeking() then return false end

	buildpowres()

	local powres = self.State.HasBass and g_powres_bass or g_powres_nobass

	resolution = resolution or 0
	resolution = powres[resolution]

	if not resolution then return false end
	if not isfunction(func) then return false end

	local samplerate = self:GetSamplingRate()
	minfrq = minfrq or 0
	maxfrq = maxfrq or samplerate

	local count = self.Channel:FFT( g_tempArray_fft, resolution )

	local index = 0
	for i = 1, count do
		local level = g_tempArray_fft[i] or 0

		local frq = getBarFrequency(i, count, samplerate)

		if frq < 0 then
			continue
		end

		if frq < minfrq then
			continue
		end

		if frq > maxfrq then
			break
		end

		if not func( index, frq, level ) then
			break
		end

		index = index + 1
	end

	return true
end

local function calcAngleFromComplex(R, I)
	R = R or 0
	I = I or 0

	return math.atan2( I, R )
end

local function calcLengthFromComplex(R, I)
	R = R or 0
	I = I or 0

	if ( ( R == 0 ) and ( I == 0 ) ) then
		return 0
	end

	return math.sqrt( ( R ^ 2 ) + ( I ^ 2 ) )
end

function CLASS:GetSpectrumComplex( resolution, func, minfrq, maxfrq )
	if not self.Valid then return false end
	if not IsValid(self.Channel) then return false end
	if self:IsSeeking() then return false end

	buildpowres()

	local powres = self.State.HasBass and g_powres_bass or g_powres_nobass

	resolution = resolution or 0
	resolution = powres[resolution]

	if not resolution then return false end
	if not isfunction(func) then return false end

	local samplerate = self:GetSamplingRate()
	minfrq = minfrq or 0
	maxfrq = maxfrq or samplerate

	local count = 0
	local index = 0

	if self.State.HasBass then
		count = self.Channel:FFTComplex( g_tempArray_fftc, resolution )

		for i = 1, count, 2 do
			local level_R = g_tempArray_fftc[i] or 0
			local level_I = g_tempArray_fftc[i + 1] or 0

			local frq = getBarFrequency(i, count / 2, samplerate)

			if frq < 0 then
				continue
			end

			if frq < minfrq then
				continue
			end

			if frq > maxfrq then
				break
			end

			local level_length = calcLengthFromComplex(level_R, level_I);
			local level_ang = calcAngleFromComplex(level_R, level_I);

			if not func( index, frq, level_length, level_ang, level_R, level_I ) then
				break
			end

			index = index + 1
		end
	else
		count = self.Channel:FFT( g_tempArray_fft, resolution )

		for i = 1, count do
			local level = g_tempArray_fft[i] or 0

			local frq = getBarFrequency(i, count, samplerate)

			if frq < 0 then
				continue
			end

			if frq < minfrq then
				continue
			end

			if frq > maxfrq then
				break
			end

			if not func( index, frq, level, nil, level, nil ) then
				break
			end

			index = index + 1
		end
	end

	return true
end

function CLASS:PreDupe()
	local data = {}

	data.url = self:GetURL()
	data.streamname = self:GetStreamName()
	data.loop = self:GetLoop()
	data.volume = self:GetVolume()

	data.playstate = self.State.PlayMode

	return data
end

function CLASS:PostDupe(data)
	local ent = self:GetEntity()

	if not IsValid(ent) then
		return
	end

	self:SetLoop(data.loop)
	self:SetVolume(data.volume)

	ent:SetDupeURL(data.url, data.streamname, data.playstate ~= StreamRadioLib.STREAM_PLAYMODE_STOP)

	self.State.PlayMode = data.playstate
end

function CLASS:OnSearch(url)
	-- override
	return true -- Allow url to be played
end

function CLASS:CanSkipUrlChecks(url)
	-- override
	return false -- Ignore the build-in whitelist?
end

function CLASS:CanBypassUrlBlock(url, blockedByHook)
	-- override
	return false -- Bypass the URL block?
end

function CLASS:OnClose()
	-- override
end

function CLASS:OnDownload(internalUrl, interface)
	-- override
	return true -- Allow download to cache
end

function CLASS:OnConnect(channel)
	-- override
end

function CLASS:OnRetry(err, internalUrl, state, interface)
	-- override
	return true -- Retry again?
end

function CLASS:OnError(err)
	-- override
end

function CLASS:OnMute(muted)
	-- override
end

return true


--PATH lua/streamradio_core/print.lua:
return gluapack()()
--PATH lua/streamradio_core/client/cl_menu.lua:
return gluapack()()
--PATH lua/streamradio_core/client/cl_settings.lua:
return gluapack()()
--PATH lua/streamradio_core/client/cl_whitelist.lua:
local StreamRadioLib = StreamRadioLib

StreamRadioLib.Whitelist = StreamRadioLib.Whitelist or {}

local LIB = StreamRadioLib.Whitelist
table.Empty(LIB)

local LIBUtil = StreamRadioLib.Util
local LIBUrl = StreamRadioLib.Url
local LIBNet = StreamRadioLib.Net
local LIBHook = StreamRadioLib.Hook

local g_whitelistCache = LIBUtil.CreateCacheArray(2048)
local g_whitelistCallbacks = {}
local g_whitelistFunction = {}

StreamRadioLib.Hook.Add("PostCleanupMap", "reset_cache_url_whitelist", function()
	LIB.InvalidateCache()
end)

local g_emptyFunction = function() end

local function callCallbacks(url, ...)
	local callbacksList = g_whitelistCallbacks[url]
	g_whitelistCallbacks[url] = nil

	if not callbacksList then
		return
	end

	for _, callbacks in pairs(callbacksList) do
		for _, callback in ipairs(callbacks) do
			callback(...)
		end
	end
end

LIBNet.Receive("whitelist_check_url_result", function()
	local url = net.ReadString()
	local result = net.ReadBool()
	local blockedByHook = net.ReadBool()

	url = LIBUrl.SanitizeUrl(url)
	if url == "" then
		return
	end

	local now = CurTime()
	local lifetime = blockedByHook and 600 or 3600
	local expires = now + lifetime

	g_whitelistCache:Set(url, {
		result = result,
		blockedByHook = blockedByHook,
	}, expires)

	callCallbacks(url, result, blockedByHook)
end)

LIBNet.Receive("whitelist_clear_cache", function()
	LIB.InvalidateCache()
end)

function LIB.InvalidateCache()
	g_whitelistCache:Empty()
end

local function callCheckFunctions(url)
	for name, func in pairs(g_whitelistFunction) do
		local result = func(url)

		if result == nil then
			continue
		end

		return result
	end

	return false
end

function LIB.AddCheckFunction(name, func)
	g_whitelistFunction[name] = func
end

function LIB.BuildContext(ent, ply)
	context = context or {}

	if not IsValid(ent) or not isentity(ent) then
		ent = nil
	end

	if ent and ent.__IsRadio and not IsValid(ply) then
		ply = ent:GetRealRadioOwner()
	end

	if not IsValid(ply) or not ply:IsPlayer() then
		ply = nil
	end

	context.entity = ent
	context.player = ply

	return context
end

function LIB.SanitizeContext(context)
	context = context or {}

	local ent = context.entity
	local ply = context.player

	if not IsValid(ply) or not ply:IsPlayer() then
		context.player = LocalPlayer()
	end

	if not IsValid(ent) or not isentity(ent) then
		context.entity = nil
	end

	return context
end

function LIB.IsAllowedSync(url, context)
	url = tostring(url or "")

	if url == "" then
		return false, false
	end

	if LIBUrl.IsOfflineURL(url) then
		return true, false
	end

	url = LIBUrl.SanitizeOnlineUrl(url)
	if url == "" then
		return false, false
	end

	context = LIB.SanitizeContext(context)

	local now = CurTime()

	local cacheItem = g_whitelistCache:Get(url, now)
	if cacheItem then
		-- Use cached result instead of asking the server again

		local result = cacheItem.result or false
		local blockedByHook = cacheItem.blockedByHook or false

		return result, blockedByHook
	end

	local ply = context.player
	local ent = context.entity

	local isAllowed = LIBHook.RunCustom("UrlIsAllowed", url, ply, ent)

	if isAllowed == false then
		return false, true
	end

	if not StreamRadioLib.IsUrlWhitelistEnabled() then
		-- allow all URLs if the whitelist is disabled
		return nil, false
	end

	if callCheckFunctions(url) then
		return true, false
	end

	return nil, nil
end

function LIB.IsAllowedAsync(url, context, callback)
	url = tostring(url or "")
	callback = callback or g_emptyFunction

	context = LIB.SanitizeContext(context)
	local ent = context.entity or NULL

	local result, blockedByHook = LIB.IsAllowedSync(url, context)

	if result ~= nil then
		callback(result, blockedByHook or false)
		return
	end

	local callbacksList = g_whitelistCallbacks[url] or {}
	g_whitelistCallbacks[url] = callbacksList

	local callbacks = callbacksList[ent] or {}
	callbacksList[ent] = callbacks

	local hasSend = #callbacks > 0
	table.insert(callbacks, callback)

	if not hasSend then
		LIBNet.Start("whitelist_check_url")
			net.WriteString(url)
			net.WriteEntity(ent)
		net.SendToServer()
	end
end

function LIB.QuickWhitelistAdd(url)
	if not LIBUtil.IsAdmin() then
		return
	end

	url = tostring(url or "")

	if url == "" then
		return
	end

	if LIBUrl.IsOfflineURL(url) then
		return
	end

	url = LIBUrl.SanitizeOnlineUrl(url)
	if url == "" then
		return
	end

	LIBNet.Start("whitelist_quick_whitelist")
		net.WriteString(url)
		net.WriteBool(true)
	net.SendToServer()

	g_whitelistCache:Remove(url)
end

function LIB.QuickWhitelistRemove(url)
	if not LIBUtil.IsAdmin() then
		return
	end

	url = tostring(url or "")

	if url == "" then
		return
	end

	if LIBUrl.IsOfflineURL(url) then
		return
	end

	url = LIBUrl.SanitizeOnlineUrl(url)
	if url == "" then
		return
	end

	LIBNet.Start("whitelist_quick_whitelist")
		net.WriteString(url)
		net.WriteBool(false)
	net.SendToServer()

	g_whitelistCache:Remove(url)
end

function LIB.Load()
	LIB.InvalidateCache()
end

return true


--PATH lua/streamradio_core/interfaces/dropbox.lua:
return gluapack()()
--PATH lua/streamradio_core/interfaces/dropbox.lua:
local RADIOIFACE = RADIOIFACE
if not istable( RADIOIFACE ) then
	StreamRadioLib.Interface.Load()
	return
end

RADIOIFACE.name = "Dropbox"
RADIOIFACE.priority = 200
RADIOIFACE.online = true
RADIOIFACE.cache = false

RADIOIFACE.downloadTimeout = 5
RADIOIFACE.downloadFirst = true
RADIOIFACE.allowCaching = true

local ERROR_NO_PATH = 130000

StreamRadioLib.Error.AddStreamErrorCode({
	id = ERROR_NO_PATH,
	name = "STREAM_ERROR_DROPBOX_NO_PATH",
	description = "[Dropbox] Url has no path",
	helptext = [[
Make sure your Dropbox has a valid path in it.
]],
})

local DropboxPatterns = {
	"dropbox%://(.+)",
	"com/(.+)",
}

local DropboxURLs = {
	"dropbox://",
	"//www.dropbox.com/",
	"//dropbox.com/",
	"//www.dl.dropboxusercontent.com/",
	"//dl.dropboxusercontent.com/",
}

function RADIOIFACE:CheckURL(url)
	for i, v in ipairs(DropboxURLs) do
		local result = string.find(string.lower(url), v, 1, true)

		if not result then
			continue
		end

		return true
	end

	return false
end

function RADIOIFACE:ParseURL(url)
	for i, v in ipairs(DropboxPatterns) do
		local result = string.Trim(string.match(url, v) or "")

		if result == "" then
			continue
		end

		result = string.match( result, "^/(.+)$" ) or result
		result = string.TrimLeft( result, "/" )

		if result == "" then
			continue
		end

		return result
	end

	return nil
end

local g_dropbox_content_url = "https://dl.dropboxusercontent.com/";

function RADIOIFACE:Convert(url, callback)
	local path = self:ParseURL(url)

	if not path then
		callback(self, false, nil, ERROR_NO_PATH)
		return
	end

	local streamUrl = g_dropbox_content_url .. path

	streamUrl = StreamRadioLib.Url.URIAddParameter(streamUrl, {
		dl = 1,
	})

	callback(self, true, streamUrl)
end

return true


--PATH lua/streamradio_core/interfaces/online.lua:
return gluapack()()
--PATH lua/streamradio_core/interfaces/youtube.lua:
local RADIOIFACE = RADIOIFACE
if not istable( RADIOIFACE ) then
	StreamRadioLib.Interface.Load()
	return
end

RADIOIFACE.name = "YouTube"
RADIOIFACE.priority = -10000
RADIOIFACE.online = true
RADIOIFACE.cache = false

RADIOIFACE.downloadTimeout = 0
RADIOIFACE.downloadFirst = false
RADIOIFACE.allowCaching = false

local ERROR_UNSUPPORTED = 110000

local youtube_help_url = "https://steamcommunity.com/workshop/filedetails/discussion/246756300/4523281307928803506/"

StreamRadioLib.Error.AddStreamErrorCode({
	id = ERROR_UNSUPPORTED,
	name = "STREAM_ERROR_YOUTUBE_UNSUPPORTED",
	description = "[YouTube] YouTube is not supported",
	helptext = [[
YouTube is not supported. Please use other media sources.
You can use a Youtube to MP3 converter, but it is not recommended.

Notes:
	- Reliable YouTube support can't be added. It is impossible.
	- Please, don't ask me about it.
	- View the online help link for more information.
]],
	helpurl = youtube_help_url,
})

local YoutubeURLs = {
	"youtube://",
	"yt://",
	"://youtube.",
	".youtube.",
	"://youtu.be",
}

function RADIOIFACE:CheckURL(url)
	for i, v in ipairs(YoutubeURLs) do
		local result = string.find(string.lower(url), v, 1, true)

		if not result then
			continue
		end

		return true
	end

	return false
end

function RADIOIFACE:Convert(url, callback)
	callback(self, false, nil, ERROR_UNSUPPORTED)
	return
end

return true


--PATH lua/streamradio_core/filesystem/_folder.lua:
return gluapack()()
--PATH lua/streamradio_core/filesystem/m3u.lua:
return gluapack()()
--PATH lua/autorun/swm_mortar_runner.lua:
if (SERVER) then
    resource.AddFile("resource/fonts/UbuntuMono-Regular.ttf")

    timer.Simple(10, function ()
        if (istable(repairDatabase)) then
            repairDatabase["mortar"] = function (fc, mortar)
                if (mortar:Health() < mortar:GetMaxHealth()) then
                    local newHealth = mortar:Health() + 50
                    if (newHealth <= mortar:GetMaxHealth()) then
                        mortar:SetHealth(newHealth)
                    else
                        mortar:SetHealth(mortar:GetMaxHealth())
                    end
                    return true
                end
                return false
            end
        end
    end)
end

hook.Add("CalcMainActivity", "SWMortarSeatAnimOverride", function (ply, vel)
    local seat = ply:GetVehicle()

    if (not IsValid(seat) or not IsValid(seat:GetParent()) or seat:GetParent():GetClass() ~= "mortar") then return end

    ply.CalcIdeal = ACT_CROUCH
    ply.CalcSeqOverride = ply:LookupSequence("pose_ducking_01")

    return ply.CalcIdeal, ply.CalcSeqOverride
end)

hook.Add("CalcView", "SWMortarCalcViewMortarSeat", function (ply, pos, angles, fov)
    local seat = LocalPlayer():GetVehicle()
    if (IsValid(seat) and IsValid(seat:GetParent()) and seat:GetParent():GetClass() == "mortar") then
        local view = {
            origin = pos + angles:Up() * 50 - angles:Forward() * 100,
            angles = angles,
            fov = fov,
            drawviewer = true
        }

        return view
    end
end)

local visorMaterial = Material("models/dolunity/starwars/visor-final.png")
hook.Add("HUDPaint", "SWMortarHUD", function ()
    local seat = LocalPlayer():GetVehicle()
    if (IsValid(seat) and IsValid(seat:GetParent()) and seat:GetParent():GetClass() == "mortar") then
        local mortar = seat:GetParent()
        local barrelId = mortar:LookupBone("Barrel")
        local barrelAngle = mortar:GetManipulateBoneAngles(barrelId) + Angle(rot,0,ang)
        barrelAngle.z = math.Clamp(barrelAngle.z, mortar.AnglingMin, mortar.AnglingMax)

        surface.SetDrawColor(255,255,255)
        surface.SetMaterial(visorMaterial)
        local height = ScrH() * 0.25
        local width = height * 1.27
        surface.DrawTexturedRect((ScrW() - width) / 2, ScrH() - height * 0.9, width, height)

        surface.SetFont("swmFont")
        surface.SetTextColor(255, 255, 255)
        local rText
        local bax = math.abs((barrelAngle.x + mortar:GetLocalAngles().y) % 360 - 360)
        if (math.Round(bax, 2) >= 0) then
            rText = "R   >  " .. math.Round(bax, 2) .. "°"
        else
            rText = "R   >  " .. math.Round(bax, 2) .. "°"
        end
        local rWidth, rHeight = surface.GetTextSize(rText)
        surface.SetTextPos((ScrW() - width) / 2 + width * 0.1, ScrH() - height + rHeight + height * 0.11)
        surface.DrawText(rText)
        local aText = "Mil >  " .. (math.abs(math.Round(barrelAngle.z, 2) - mortar.AnglingMax) * 25 + 800)
        local aWidth, aHeight = surface.GetTextSize(aText)
        surface.SetTextPos((ScrW() - width) / 2 + width * 0.1, ScrH() - height + rHeight + aHeight + height * 0.16)
        surface.DrawText(aText)
        local sText = "Amm >  " .. table.GetKeys(mortar.ShellClasses)[mortar:GetShellClassId()]
        local sWidth, sHeight = surface.GetTextSize(aText)
        surface.SetTextPos((ScrW() - width) / 2 + width * 0.1, ScrH() - height + rHeight + aHeight + sHeight + height * 0.21)
        surface.DrawText(sText)

        local fPosX = (ScrW() - width) / 2 + width * 0.72
        local fPosY = ScrH() - height + height * 0.23
        if (mortar:GetNextFire() > CurTime()) then
            surface.SetDrawColor(100,0,0,255)
        else
            surface.SetDrawColor(255,0,0,255)
        end
        draw.NoTexture()
        surface.DrawPoly({
            {x = fPosX + 0,y = fPosY + 100},
            {x = fPosX + 30,y = fPosY + 0},
            {x = fPosX + 60,y = fPosY + 100}
        })

        draw.RoundedBox(0,(ScrW() - width) / 2 + width * 0.1, ScrH() - height * 0.375, width * 0.8, height * 0.02, Color(50,100,255, 50))
        draw.RoundedBox(0,(ScrW() - width) / 2 + width * 0.1, ScrH() - height * 0.375, width * 0.8 * (math.max(mortar:Health(), 0) / mortar:GetMaxHealth()), height * 0.02, Color(0,75,255))
    end
end)

if (CLIENT) then
    surface.CreateFont("swmFont", {
        font = "Ubuntu Mono", --  Use the font-name which is shown to you by your operating system Font Viewer, not the file name
        extended = false,
        size = 28,
        weight = 500,
        blursize = 0,
        scanlines = 0,
        antialias = true,
    })
end

--PATH addons/[chat] talk-modes/lua/talk_modes/vgui/libs/cl_spheres.lua:
return gluapack()()
--PATH addons/[chat] talk-modes/lua/talk_modes/vgui/libs/cl_circles.lua:
return gluapack()()
--PATH addons/[chat] talk-modes/lua/talk_modes/vgui/elements/cl_general.lua:
local PANEL = {}
function PANEL:Init()
    self:SetPageName("General")
    self.tblDefaultSettings = {
        ["Language"] = {
            strDesc = "Language_Desc",
            strType = "tDropdown",
            tblData = TalkModes.Languages.Available
        },
        ["Selection Key"] = {
            strDesc = "Selection Key_Desc",
            strType = "tBinder"
        },
        ["3D Voice"] = {
            strDesc = "3D Voice_Desc",
            strType = "tSwitch"
        },
        ["Talking Dead"] = {
            strDesc = "Talking Dead_Desc",
            strType = "tSwitch"
        },
        ["Selection Menu Position"] = {
            strDesc = "Selection Menu Position_Desc",
            strType = "tDropdown",
            tblData = {
                ["Top Left"] = 1,
                ["Top Center"] = 2,
                ["Top Right"] = 3,
                ["Center Left"] = 4,
                ["Center Right"] = 5,
                ["Bottom Left"] = 6,
                ["Bottom Center"] = 7,
                ["Bottom Right"] = 8
            }
        },
        ["Auto-Hide"] = {
            strDesc = "Auto-Hide_Desc",
            strType = "tSwitch"
        },
        ["Mode Change Message"] = {
            strDesc = "Mode Change Message_Desc",
            strType = "tSwitch"
        }
    }
    self:RefreshSettings()
end
vgui.Register("TalkModes.GeneralSettings", PANEL, "TalkModes.SettingsBase")

--PATH addons/[chat] talk-modes/lua/talk_modes/vgui/elements/cl_modes.lua:
return gluapack()()
--PATH lua/tfa/enums/animation.lua:
return gluapack()()
--PATH lua/tfa/enums/locomotion.lua:
--LOCOMOTION ENUM
TFA.Enum.LOCOMOTION_LUA = 0
TFA.Enum.LOCOMOTION_HYBRID = 1
TFA.Enum.LOCOMOTION_ANI = 2
--PATH lua/tfa/enums/statusnew.lua:
return gluapack()()
--PATH lua/tfa/enums/statusnew.lua:
TFA.ENUM_COUNTER = TFA.ENUM_COUNTER or 0

TFA.Enum.InverseStatus = TFA.Enum.InverseStatus or {}
local upper = string.upper

local function gen(input)
	return "STATUS_" .. upper(input)
end

function TFA.AddStatus(input)
	local key = gen(input)
	local getkey = TFA.Enum[key]

	if not getkey then
		getkey = TFA.ENUM_COUNTER
		TFA.ENUM_COUNTER = TFA.ENUM_COUNTER + 1
		TFA.Enum[key] = getkey
	end

	TFA.Enum.InverseStatus[getkey] = key

	return getkey
end

function TFA.GetStatus(input)
	local key = gen(input)
	local getkey = TFA.Enum[key]

	if not getkey then
		return TFA.AddStatus(input) -- DANGEROUS:
		-- Race condition:
		-- If something go terribly wrong and order of addition of new statuses fuck up
		-- everything will fail horribly!
	end

	return getkey
end

TFA.AddStatus("idle")
TFA.AddStatus("draw")
TFA.AddStatus("holster")
TFA.AddStatus("holster_final")
TFA.AddStatus("holster_ready")
TFA.AddStatus("reloading")
TFA.AddStatus("reloading_wait")

TFA.AddStatus("reloading_loop_start")
TFA.AddStatus("reloading_loop_start_empty")
TFA.AddStatus("reloading_loop")
TFA.AddStatus("reloading_loop_end")

TFA.Enum.STATUS_RELOADING_SHOTGUN_START = TFA.Enum.STATUS_RELOADING_LOOP_START
TFA.Enum.STATUS_RELOADING_SHOTGUN_START_SHELL = TFA.Enum.STATUS_RELOADING_LOOP_START_EMPTY
TFA.Enum.STATUS_RELOADING_SHOTGUN_LOOP = TFA.Enum.STATUS_RELOADING_LOOP
TFA.Enum.STATUS_RELOADING_SHOTGUN_END = TFA.Enum.STATUS_RELOADING_LOOP_END

TFA.AddStatus("shooting")
TFA.AddStatus("silencer_toggle")
TFA.AddStatus("bashing")
TFA.AddStatus("bashing_wait")
TFA.AddStatus("inspecting")
TFA.AddStatus("fidget")
TFA.AddStatus("firemode")

TFA.AddStatus("pump")

TFA.AddStatus("knife_slash")
TFA.AddStatus("knife_stab")

TFA.AddStatus("grenade_pull")
TFA.AddStatus("grenade_ready")
TFA.AddStatus("grenade_throw")

TFA.AddStatus("blocking")
TFA.AddStatus("blocking_end")

TFA.AddStatus("bow_shoot")
TFA.AddStatus("bow_cancel")

TFA.AddStatus("grenade_pull")
TFA.AddStatus("grenade_throw")
TFA.AddStatus("grenade_ready")
TFA.AddStatus("grenade_throw_wait")

TFA.Enum.HolsterStatus = {
	[TFA.Enum.STATUS_HOLSTER] = true,
	[TFA.Enum.STATUS_HOLSTER_FINAL] = true,
	[TFA.Enum.STATUS_HOLSTER_READY] = true
}

TFA.Enum.HolsterStatusFinal = {
	[TFA.Enum.STATUS_HOLSTER_FINAL] = true,
	[TFA.Enum.STATUS_HOLSTER_READY] = true
}

TFA.Enum.ReloadStatus = {
	[TFA.Enum.STATUS_RELOADING] = true,
	[TFA.Enum.STATUS_RELOADING_WAIT] = true,
	[TFA.Enum.STATUS_RELOADING_LOOP_START] = true,
	[TFA.Enum.STATUS_RELOADING_LOOP_START_EMPTY] = true,
	[TFA.Enum.STATUS_RELOADING_LOOP] = true,
	[TFA.Enum.STATUS_RELOADING_LOOP_END] = true
}

TFA.Enum.ReadyStatus = {
	[TFA.Enum.STATUS_IDLE] = true,
	[TFA.Enum.STATUS_INSPECTING] = true,
	[TFA.Enum.STATUS_FIDGET] = true
}

TFA.Enum.IronStatus = {
	[TFA.Enum.STATUS_IDLE] = true,
	[TFA.Enum.STATUS_SHOOTING] = true,
	[TFA.Enum.STATUS_PUMP] = true,
	[TFA.Enum.STATUS_FIREMODE] = true--,
	--[TFA.Enum.STATUS_FIDGET] = true
}

TFA.Enum.HUDDisabledStatus = {
	[TFA.Enum.STATUS_IDLE] = true,
	[TFA.Enum.STATUS_SHOOTING] = true,
	[TFA.Enum.STATUS_FIREMODE] = true,
	[TFA.Enum.STATUS_BASHING] = true,
	[TFA.Enum.STATUS_BASHING_WAIT] = true,
	[TFA.Enum.STATUS_HOLSTER] = true,
	[TFA.Enum.STATUS_HOLSTER_FINAL] = true,
	[TFA.Enum.STATUS_HOLSTER_READY] = true,
	[TFA.Enum.STATUS_KNIFE_SLASH] = true,
	[TFA.Enum.STATUS_KNIFE_STAB] = true,
	[TFA.Enum.STATUS_GRENADE_PULL] = true,
	[TFA.Enum.STATUS_GRENADE_READY] = true,
	[TFA.Enum.STATUS_GRENADE_THROW] = true,
	[TFA.Enum.STATUS_BLOCKING] = true,
	[TFA.Enum.STATUS_BLOCKING_END] = true,
	[TFA.Enum.STATUS_PUMP] = true
}

TFA.Enum.BashStatus = {
	[TFA.Enum.STATUS_BASHING] = true,
	[TFA.Enum.STATUS_BASHING_WAIT] = true,
}

TFA.Enum.SHOOT_IDLE = 0
TFA.Enum.SHOOT_START = 1
TFA.Enum.SHOOT_LOOP = 2
TFA.Enum.SHOOT_CHECK = 3
TFA.Enum.SHOOT_END = 4

TFA.Enum.ShootReadyStatus = {
	[TFA.Enum.SHOOT_IDLE] = true,
	[TFA.Enum.SHOOT_END] = true
}

TFA.Enum.ShootLoopingStatus = {
	[TFA.Enum.SHOOT_START] = true,
	[TFA.Enum.SHOOT_LOOP] = true,
	[TFA.Enum.SHOOT_CHECK] = true
}

--PATH lua/tfa/modules/tfa_envcheck.lua:
return gluapack()()
--PATH lua/tfa/modules/tfa_functions.lua:
return gluapack()()
--PATH lua/tfa/modules/tfa_matproxies.lua:
return gluapack()()
--PATH lua/tfa/modules/tfa_meta.lua:
local WEAPON = FindMetaTable("Weapon")

if WEAPON then
	function WEAPON:IsTFA() -- please do not use, just check for IsTFAWeapon directly
		return self.IsTFAWeapon
	end
else
	print("[TFA Base] Can't find weapon metatable!")
end

local PLAYER = FindMetaTable("Player")

if PLAYER then
	function PLAYER:TFA_ZoomKeyDown()
		if not IsValid(self) then return false end

		return self:GetNW2Bool("TFA_ZoomKeyDown", false)
	end

	function PLAYER:TFA_SetZoomKeyDown(isdown)
		if not IsValid(self) then return end

		self:SetNW2Bool("TFA_ZoomKeyDown", isdown)
	end
else
	print("[TFA Base] Can't find player metatable!")
end

--PATH lua/tfa/3dscoped_base.lua:
local SWEP = {}

local BaseClass = baseclass.Get("tfa_gun_base")

local scopeshadowcvar = GetConVar("cl_tfa_3dscope_overlay")

local sp = game.SinglePlayer()

function SWEP:Do3DScope()
	return true
end

function SWEP:Do3DScopeOverlay()
	if scopeshadowcvar then
		return scopeshadowcvar:GetBool()
	else
		return false
	end
end

function SWEP:UpdateScopeType()
	-- empty, function retains for error preventing
end

function SWEP:Initialize(...)
	local unsetA = self.Primary_TFA == nil
	local unsetB = self.Secondary_TFA == nil

	self.Primary_TFA = self.Primary_TFA or self.Primary
	self.Secondary_TFA = self.Secondary_TFA or self.Secondary

	if unsetA then
		self.Primary_TFA = nil
	end

	if unsetB then
		self.Secondary_TFA = nil
	end

	BaseClass.Initialize(self, ...)
end

local flipcv = GetConVar("cl_tfa_viewmodel_flip")
local cd = {}
local crosscol = Color(255, 255, 255, 255)
SWEP.RTOpaque = true

local cv_cc_r = GetConVar("cl_tfa_hud_crosshair_color_r")
local cv_cc_g = GetConVar("cl_tfa_hud_crosshair_color_g")
local cv_cc_b = GetConVar("cl_tfa_hud_crosshair_color_b")
local cv_cc_a = GetConVar("cl_tfa_hud_crosshair_color_a")

SWEP.defaultscrvec = Vector()

SWEP.ScopeAngleTransformISAngleFallback = true -- fallback to reverse ironsights angle for scope transforms
SWEP.ScopeAngleTransforms = { -- this is bad this is bad this is bad this is bad this is bad this is bad this is bad this is bad this is bad
	-- {"P", 0}, -- Pitch
	-- {"Y", 0}, -- Yaw
	-- {"R", 0}, -- Roll
}

function SWEP:RTCode(rt, scrw, scrh)
	local legacy = self.ScopeLegacyOrientation
	local rttw = ScrW()
	local rtth = ScrH()

	if not self:VMIV() then return end

	if not self.myshadowmask then
		self.myshadowmask = surface.GetTextureID(self.ScopeShadow or "vgui/scope_shadowmask_test")
	end

	if not self.myreticule then
		self.myreticule = Material(self.ScopeReticule or "scope/gdcw_scopesightonly")
	end

	if not self.mydirt then
		self.mydirt = Material(self.ScopeDirt or "vgui/scope_dirt")
	end

	local vm = self.OwnerViewModel

	if not self.LastOwnerPos then
		self.LastOwnerPos = self:GetOwner():GetShootPos()
	end

	local owoff = self:GetOwner():GetShootPos() - self.LastOwnerPos

	self.LastOwnerPos = self:GetOwner():GetShootPos()

	local scrpos

	local attShadowID = self:GetStatL("RTScopeShadowAttachment")
	if attShadowID and attShadowID > 0 then
		vm:SetupBones()

		local att = vm:GetAttachment(attShadowID)
		if att and att.Pos then
			local pos = att.Pos - owoff
			cam.Start3D()
			cam.End3D()
			scrpos = pos:ToScreen()
		end
	end

	if not scrpos then
		local spos = self:GetOwner():GetShootPos() + self:GetOwner():EyeAngles():Forward() * 16

		local pos = spos - owoff
		cam.Start3D()
		cam.End3D()
		scrpos = pos:ToScreen()

		-- self.defaultscrvec.x = scrw / 2
		-- self.defaultscrvec.y = scrh / 2
		-- scrpos = self.defaultscrvec
	end

	scrpos.x = scrpos.x - scrw / 2 + self.ScopeOverlayTransforms[1]
	scrpos.y = scrpos.y - scrh / 2 + self.ScopeOverlayTransforms[2]
	scrpos.x = scrpos.x / scrw * 1920
	scrpos.y = scrpos.y / scrw * 1920
	scrpos.x = math.Clamp(scrpos.x, -1024, 1024)
	scrpos.y = math.Clamp(scrpos.y, -1024, 1024)
	--scrpos.x = scrpos.x * ( 2 - self:GetIronSightsProgress()*1 )
	--scrpos.y = scrpos.y * ( 2 - self:GetIronSightsProgress()*1 )
	scrpos.x = scrpos.x * self.ScopeOverlayTransformMultiplier
	scrpos.y = scrpos.y * self.ScopeOverlayTransformMultiplier

	if not self.scrpos then
		self.scrpos = scrpos
	end

	self.scrpos.x = math.Approach(self.scrpos.x, scrpos.x, (scrpos.x - self.scrpos.x) * FrameTime() * 10)
	self.scrpos.y = math.Approach(self.scrpos.y, scrpos.y, (scrpos.y - self.scrpos.y) * FrameTime() * 10)
	scrpos = self.scrpos
	render.OverrideAlphaWriteEnable(true, true)
	surface.SetDrawColor(color_white)
	surface.DrawRect(-512, -512, 1024, 1024)
	render.OverrideAlphaWriteEnable(true, true)

	local ang = legacy and self:GetOwner():EyeAngles() or vm:GetAngles()

	local attID = self:GetStatL("RTScopeAttachment")
	if attID and attID > 0 then
		vm:SetupBones()
		local AngPos = vm:GetAttachment( attID )

		if AngPos then
			ang = AngPos.Ang

			if flipcv:GetBool() then
				ang.y = -ang.y
			end
		end
	elseif self:GetStatL("ScopeAngleTransformISAngleFallback") then
		local isang = self:GetStatL("IronSightsAngle") * self:GetIronSightsProgress()

		ang:RotateAroundAxis(ang:Forward(), -isang.z)
		ang:RotateAroundAxis(ang:Right(), -isang.x)
		ang:RotateAroundAxis(ang:Up(), -isang.y)

		ang:RotateAroundAxis(ang:Forward(), isang.z)
	end

	-- WHY WHY WHY WHY WHY WHY WHY WHY
	for _, v in ipairs(self:GetStatL("ScopeAngleTransforms")) do
		if v[1] == "P" then
			ang:RotateAroundAxis(ang:Right(), v[2])
		elseif v[1] == "Y" then
			ang:RotateAroundAxis(ang:Up(), v[2])
		elseif v[1] == "R" then
			ang:RotateAroundAxis(ang:Forward(), v[2])
		end
	end

	cd.angles = ang
	cd.origin = self:GetOwner():GetShootPos()

	if not self.RTScopeOffset then
		self.RTScopeOffset = {0, 0}
	end

	if not self.RTScopeScale then
		self.RTScopeScale = {1, 1}
	end

	local rtow, rtoh = self.RTScopeOffset[1], self.RTScopeOffset[2]
	local rtw, rth = rttw * self.RTScopeScale[1], rtth * self.RTScopeScale[2]

	cd.x = 0
	cd.y = 0
	cd.w = rtw
	cd.h = rth
	cd.fov = self:GetStatL("RTScopeFOV")
	cd.drawviewmodel = false
	cd.drawhud = false
	render.Clear(0, 0, 0, 255, true, true)
	render.SetScissorRect(0 + rtow, 0 + rtoh, rtw + rtow, rth + rtoh, true)

	if self:GetIronSightsProgress() > 0.01 and self.Scoped_3D then
		render.RenderView(cd)
	end

	render.SetScissorRect(0, 0, rtw, rth, false)
	render.OverrideAlphaWriteEnable(false, true)
	cam.Start2D()
	draw.NoTexture()
	surface.SetTexture(self.myshadowmask)
	surface.SetDrawColor(color_white)

	if self:Do3DScopeOverlay() then
		surface.DrawTexturedRect(scrpos.x + rtow - rtw / 2, scrpos.y + rtoh - rth / 2, rtw * 2, rth * 2)
	end

	if self.ScopeReticule_CrossCol then
		crosscol.r = cv_cc_r:GetFloat()
		crosscol.g = cv_cc_g:GetFloat()
		crosscol.b = cv_cc_b:GetFloat()
		crosscol.a = cv_cc_a:GetFloat()
		surface.SetDrawColor(crosscol)
	end

	surface.SetMaterial(self.myreticule)
	local tmpborderw = rtw * (1 - self.ScopeReticule_Scale[1]) / 2
	local tmpborderh = rth * (1 - self.ScopeReticule_Scale[2]) / 2
	surface.DrawTexturedRect(rtow + tmpborderw, rtoh + tmpborderh, rtw - tmpborderw * 2, rth - tmpborderh * 2)
	surface.SetDrawColor(color_black)
	draw.NoTexture()

	if self:Do3DScopeOverlay() then
		surface.DrawRect(scrpos.x - 2048 + rtow, -1024 + rtoh, 2048, 2048)
		surface.DrawRect(scrpos.x + rtw + rtow, -1024 + rtoh, 2048, 2048)
		surface.DrawRect(-1024 + rtow, scrpos.y - 2048 + rtoh, 2048, 2048)
		surface.DrawRect(-1024 + rtow, scrpos.y + rth + rtoh, 2048, 2048)
	end

	surface.SetDrawColor(ColorAlpha(color_black, 255 - 255 * (math.Clamp(self:GetIronSightsProgress() - 0.75, 0, 0.25) * 4)))
	surface.DrawRect(-1024 + rtow, -1024 + rtoh, 2048, 2048)
	surface.SetMaterial(self.mydirt)
	surface.SetDrawColor(ColorAlpha(color_white, 128))
	surface.DrawTexturedRect(0, 0, rtw, rth)
	surface.SetDrawColor(ColorAlpha(color_white, 64))
	surface.DrawTexturedRectUV(rtow, rtoh, rtw, rth, 2, 0, 0, 2)
	cam.End2D()
end

local function l_Lerp(v, f, t)
	return f + (t - f) * v
end

function SWEP:AdjustMouseSensitivity(...)
	local retVal = BaseClass.AdjustMouseSensitivity(self, ...)

	retVal = retVal * l_Lerp(self:GetIronSightsProgress(), 1, self:Get3DSensitivity())

	return retVal
end

return SWEP

--PATH lua/tfa/modules/tfa_npc_weaponmenu.lua:
return gluapack()()
--PATH lua/tfa/modules/cl_tfa_attachment_icon.lua:
return gluapack()()
--PATH lua/tfa/modules/cl_tfa_attachment_tip.lua:
if SERVER then
	AddCSLuaFile()
	return
end

local padding = TFA.Attachments.UIPadding
local PANEL = {}

PANEL.Wep = nil
PANEL.Header = nil
PANEL.TextTable = {}
PANEL.DefaultWidth = 0
PANEL.DefaultHeight = 0

function PANEL:SetWidthNeue( val )
	self.DefaultWidth = val
end

function PANEL:SetHeightNeue( val )
	self.DefaultHeight = val
end

function PANEL:Init()
	self.Wep = nil
	self.Header = nil
	self.TextTable = {}
	self.DefaultHeight = 0
	self.DefaultWidth = 0
	self:SetMouseInputEnabled(false)
	self:SetZPos(0)
	self.SetWidthOld = self.SetWidthOld or self.SetWidth
	self.SetWidth = self.SetWidthNeue
	self.SetHeightOld = self.SetHeightOld or self.SetHeight
	self.SetHeight = self.SetHeightNeue
end

function PANEL:SetWeapon( wepv )
	if IsValid(wepv) then
		self.Wep = wepv
	end
end

function PANEL:SetAttachment( att )
	if att ~= nil then
		self:SetZPos( 200 - att )
	end
end

function PANEL:SetHeader( h )
	self.Header = h
end

function PANEL:SetTextTable( t )
	self.TextTable = t or {}
end

PANEL.HeaderFont = "TFAAttachmentTTHeader"
PANEL.BodyFont = "TFAAttachmentTTBody"

function PANEL:GetHeaderHeight()
	if not IsValid(self.Wep) then return 0 end
	if not self.Header then return 0 end
	surface.SetFont(self.HeaderFont)
	local _, th = surface.GetTextSize( language.GetPhrase(self.Header) )
	return th + padding * 2
end

function PANEL:GetHeaderSize()
	if not IsValid(self.Wep) then return 0, 0 end
	if not self.Header then return 0, 0 end
	surface.SetFont(self.HeaderFont)
	local tw, th = surface.GetTextSize( language.GetPhrase(self.Header) )
	return tw + padding * 2, th + padding * 2
end

function PANEL:GetTextTableHeight()
	if not self.TextTable or #self.TextTable <= 0 then return 0 end
	local hv = padding
	surface.SetFont(self.BodyFont)
	for _,v in pairs(self.TextTable) do
		if type(v) == "string" then
			v = language.GetPhrase(v)
			local _, th = surface.GetTextSize( v )
			hv = hv + th
		end
	end
	hv = hv + padding
	return hv
end

function PANEL:GetTextTableSize(  )
	if not self.TextTable or #self.TextTable <= 0 then return 0, 0 end
	local mw = 0
	local hv = padding
	surface.SetFont(self.BodyFont)
	for _,v in pairs(self.TextTable) do
		if type(v) == "string" then
			v = language.GetPhrase(v)
			local tw, th = surface.GetTextSize( v )
			hv = hv + th
			mw = math.max( mw, tw )
		end
	end
	hv = hv + padding
	return mw + padding * 2, hv
end

function PANEL:DrawHeader( w, h )
	if not self.Header then return 0 end
	surface.SetFont(self.HeaderFont)

	local header = language.GetPhrase(self.Header)
	local _, th = surface.GetTextSize( header )
	draw.RoundedBox( 0, 0, 0, w, th + padding * 2, ColorAlpha( TFA.Attachments.Colors["background"], self.Wep:GetInspectingProgress() * 192 ) )
	if self.AnchoredH then
		draw.DrawText( header, self.HeaderFont, self:GetWide() / 2 , padding, ColorAlpha( TFA.Attachments.Colors["primary"], self.Wep:GetInspectingProgress() * 225 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP )
		--draw.RoundedBox( 0, w / 2 - tw / 2, padding + th + padding / 4, tw, padding / 2, ColorAlpha( TFA.Attachments.Colors["primary"], self.Wep:GetInspectingProgress() * 225 ) )

		--draw.DrawText( header, self.HeaderFont, self:GetWide() - padding, padding, ColorAlpha( TFA.Attachments.Colors["primary"], self.Wep:GetInspectingProgress() * 225 ), TEXT_ALIGN_RIGHT, TEXT_ALIGN_TOP )
		--draw.RoundedBox( 0, w - padding - tw, padding + th + padding / 4, tw, padding / 2, ColorAlpha( TFA.Attachments.Colors["primary"], self.Wep:GetInspectingProgress() * 225 ) )
	else
		draw.DrawText( header, self.HeaderFont, padding, padding, ColorAlpha( TFA.Attachments.Colors["primary"], self.Wep:GetInspectingProgress() * 225 ), TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP )
		--draw.RoundedBox( 0, padding, padding + th + padding / 4, tw, padding / 2, ColorAlpha( TFA.Attachments.Colors["primary"], self.Wep:GetInspectingProgress() * 225 ) )
	end
	return th + padding * 2
end

function PANEL:DrawTextTable( x, y )
	if not self.TextTable then return 0 end
	--y = y + padding
	local hv = padding
	local acol = TFA.Attachments.Colors["primary"]
	surface.SetFont(self.BodyFont)
	for _,v in pairs(self.TextTable) do
		if type(v) == "table" or type(v) == "vector" then
			if v.r then
				acol = Color( v.r or 0, v.g or 0, v.b or 0, v.a or 255 )
			elseif v.x then
				acol = Color( v.x or 0, v.y or 0, v.z or 0, v.a or 255 )
			end
		end
		if type(v) == "string" then
			v = language.GetPhrase(v)
			local _, th = surface.GetTextSize( v )
			if self.AnchoredH then
				--draw.DrawText( v, self.BodyFont, x + self:GetWide() - padding, y + hv, ColorAlpha( acol, self.Wep:GetInspectingProgress() * 225 ), TEXT_ALIGN_RIGHT, TEXT_ALIGN_TOP )
				draw.DrawText( v, self.BodyFont, x + padding * 2, y + hv, ColorAlpha( acol, self.Wep:GetInspectingProgress() * 225 ), TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP )
			else
				draw.DrawText( v, self.BodyFont, x + padding * 2, y + hv, ColorAlpha( acol, self.Wep:GetInspectingProgress() * 225 ), TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP )
			end
			hv = hv + th
		end
	end
	hv = hv + padding
	return hv
end

function PANEL:CalcSize()
	local header_w, header_h = self:GetHeaderSize()
	local text_w, text_h = self:GetTextTableSize()
	self:SetWidthOld( math.max( self.DefaultWidth, math.max( header_w, text_w ) + padding * 2 ))
	local h = header_h + text_h
	if text_h > 0 then
		h = h + padding * 2
	end
	if IsValid( self.ContentPanel ) and not self:GetActive() then
		local _, cph = self.ContentPanel:LocalToScreen(0,self.ContentPanel:GetTall())
		local _, yy = self:LocalToScreen(0,0)
		h = math.min( h, cph - yy )
	end
	self:SetHeightOld( h )
end

function PANEL:CalcPos()
	if IsValid(self.Anchor) then
		local x,y = self.Anchor:LocalToScreen(0,0)
		y = y
		if self.Anchor:GetAnchoredH() then
			self.AnchoredH = true
			if IsValid( self.ContentPanel ) and self:GetActive() then
				local _, cph = self.ContentPanel:LocalToScreen(0,self.ContentPanel:GetTall())
				self:SetPos( x + self.Anchor:GetWide() - self:GetWide() , math.min( y + self.Anchor:GetTall(), cph - self:GetTall() ) )
			else
				self:SetPos( x + self.Anchor:GetWide() - self:GetWide() , math.min( y + self.Anchor:GetTall(), ScrH() - self:GetTall() ) )
			end
		else
			self.AnchoredH = false
			self:SetPos( x, y + self.Anchor:GetTall() )
		end
	end
end

function PANEL:Think()
	self:CalcSize()
	self:CalcPos()
end

function PANEL:SetContentPanel( p )
	if IsValid(p) then
		self.ContentPanel = p
	else
		self.ContentPanel = nil
	end
end

function PANEL:Paint( w, h )
	if not IsValid(self.Wep) then return end
	if ( self.Wep:GetInspectingProgress() or 0 ) < 0.01 then self:Remove() end
	if IsValid( self.ContentPanel ) and not self:GetActive() then
		local _, cph = self.ContentPanel:LocalToScreen(0,math.max(self.ContentPanel:GetTall(),32))
		local _, yy = self:LocalToScreen(0,0)
		if  cph - yy <= 0 then
			return
		end
	end
	draw.RoundedBox( 0, 0, 0, w, h, ColorAlpha( TFA.Attachments.Colors["background"], self.Wep:GetInspectingProgress() * 192 ) )
	local hh = self:DrawHeader( w, h )
	self:DrawTextTable( 0, hh )
	render.SetScissorRect(0,0,ScrW(),ScrH(),false)
end

function PANEL:SetActive( a )
	self.Active = a
end

function PANEL:GetActive( a )
	return self.Active
end

vgui.Register( "TFAAttachmentTip", PANEL, "Panel" )
--PATH tfa_dev_tools:
		local rshift = bit.rshift
		local band = bit.band
		return function(state)
			return band(rshift(state, 0), 1) == 0 and 0 or 1, band(rshift(state, 1), 1) == 0 and 0 or 1, band(rshift(state, 2), 1) == 0 and 0 or 1, band(rshift(state, 3), 1) == 0 and 0 or 1, band(rshift(state, 4), 1) == 0 and 0 or 1, band(rshift(state, 5), 1) == 0 and 0 or 1, band(rshift(state, 6), 1) == 0 and 0 or 1		end
	
--PATH lua/tfa/modules/cl_tfa_vgui.lua:
return gluapack()()
--PATH lua/tfa/modules/cl_tfa_subcategories.lua:
local cv_enable = CreateClientConVar("cl_tfa_subcategories_enabled", "1", true, false, "Enable spawnmenu subcategories? (Update spawnmenu with spawnmenu_reload command after changing this!)")
local cv_autoassign = CreateClientConVar("cl_tfa_subcategories_auto", "0", true, false, "Attempt to auto-assign missing subcategories based on weapon's type?")

local function PopulateWeapons(pnlContent, tree, browseNode)
	if not cv_enable:GetBool() then return end

	local cats, subs = {}, {}

	for class, _wep in pairs(list.Get("Weapon") or {}) do
		if not _wep.Spawnable then continue end

		local cat = _wep.Category or "Other2"
		cats[cat] = cats[cat] or {}

		if not weapons.IsBasedOn(class, "tfa_gun_base") then
			table.insert(cats[cat], _wep)

			continue
		end

		local wep = weapons.Get(class)
		local sub = wep.SubCategory or (cv_autoassign:GetBool() and wep:GetType())
		if not sub or sub == "" then
			table.insert(cats[cat], wep)

			continue
		end

		subs[cat] = subs[cat] or {}
		subs[cat][sub] = subs[cat][sub] or {}

		table.insert(subs[cat][sub], wep)
	end

	local root = tree:Root()
	if not IsValid(root) then return end

	for _, node in ipairs(root:GetChildNodes()) do
		local name = node:GetText()
		if not name or not subs[name] then continue end

		node.DoPopulate = function(self)
			if self.PropPanel then return end

			self.PropPanel = vgui.Create("ContentContainer", pnlContent)
			self.PropPanel:SetVisible(false)
			self.PropPanel:SetTriggerSpawnlistChange(false)

			for sname, subcat in SortedPairs(subs[name]) do
				spawnmenu.CreateContentIcon("header", self.PropPanel, {text = sname})

				for _, ent in SortedPairsByMemberValue(subcat, "PrintName") do
					spawnmenu.CreateContentIcon(ent.ScriptedEntityType or "weapon", self.PropPanel, {
						nicename	= ent.PrintName or ent.ClassName,
						spawnname	= ent.ClassName,
						material	= ent.IconOverride or "entities/" .. ent.ClassName .. ".png",
						admin		= ent.AdminOnly
					})
				end
			end

			if cats[name] and #cats[name] > 0 then
				spawnmenu.CreateContentIcon("header", self.PropPanel, {text = "Other"})

				for _, ent in SortedPairsByMemberValue(cats[name], "PrintName") do
					spawnmenu.CreateContentIcon(ent.ScriptedEntityType or "weapon", self.PropPanel, {
						nicename	= ent.PrintName or ent.ClassName,
						spawnname	= ent.ClassName,
						material	= ent.IconOverride or "entities/" .. ent.ClassName .. ".png",
						admin		= ent.AdminOnly
					})
				end
			end
		end
	end
end

hook.Add("PopulateWeapons", "AddTFAWeaponContent", function(pnlContent, tree, browseNode)
	timer.Simple(0, function()
		PopulateWeapons(pnlContent, tree, browseNode)
	end)
end, 1)

TFA.BASE_LOAD_COMPLETE = true
--PATH lua/tfa/att/mod_stun15_servius.lua:
if not ATTACHMENT then
	ATTACHMENT = {}
end


ATTACHMENT.Name = "Charge Round Charlie"
ATTACHMENT.ShortName = "15s" --Abbreviation, 5 chars or less please
--ATTACHMENT.ID = "base" -- normally this is just your filename
ATTACHMENT.Description = { 
	TFA.AttachmentColors["+"],"Stunned for 15 Seconds",
}
ATTACHMENT.Icon = "entities/icon/mod_stun15.png" --Revers to label, please give it an icon though!  This should be the path to a png, like "entities/tfa_ammo_match.png"

ATTACHMENT.WeaponTable = {
	["Primary"] = {
		["AmmoConsumption"] = 7,
		["StatusEffect"] = "stun",
		["StatusEffectDmg"] = 45,
		["StatusEffectDur"] = 15,
		["StatusEffectParticle"] = true,
	},
	["TracerName"] = "effect_sw_laser_blue_stun",
}

function ATTACHMENT:Attach(wep)
	wep.CustomBulletCallbackOld = wep.CustomBulletCallbackOld or wep.CustomBulletCallback
	wep.CustomBulletCallback = function(a, tr, dmg)
		local wep = dmg:GetInflictor()
		if wep:GetStat("Primary.StatusEffect") then
			GMSERV:AddStatus(tr.Entity, wep:GetOwner(), wep:GetStat("Primary.StatusEffect"), wep:GetStat("Primary.StatusEffectDur"), wep:GetStat("Primary.StatusEffectDmg"), wep:GetStat("Primary.StatusEffectParticle"))
			--util.Effect("BGOLightning", ED_Stun, true, true)
		end
	end
end

function ATTACHMENT:Detach(wep)
	wep.CustomBulletCallback = wep.CustomBulletCallbackOld
	wep.CustomBulletCallbackOld = nil
end

if not TFA_ATTACHMENT_ISUPDATING then
	TFAUpdateAttachments()
end
--PATH lua/tfa/att/mod_stun5_servius.lua:
if not ATTACHMENT then
	ATTACHMENT = {}
end


ATTACHMENT.Name = "Charge Round Alpha"
ATTACHMENT.ShortName = "5s" --Abbreviation, 5 chars or less please
--ATTACHMENT.ID = "base" -- normally this is just your filename
ATTACHMENT.Description = { 
	TFA.AttachmentColors["+"],"Stunned for 5 Seconds",
}
ATTACHMENT.Icon = "entities/icon/mod_stun5.png" --Refers to label, please give it an icon though!  This should be the path to a png, like "entities/tfa_ammo_match.png"

ATTACHMENT.WeaponTable = {
	["Primary"] = {
		["AmmoConsumption"] = 7,
		["StatusEffect"] = "stun",
		["StatusEffectDmg"] = 5,
		["StatusEffectDur"] = 5,
		["StatusEffectParticle"] = true,
	},
	["TracerName"] = "effect_sw_laser_blue_stun",
}

function ATTACHMENT:Attach(wep)
	wep.CustomBulletCallbackOld = wep.CustomBulletCallbackOld or wep.CustomBulletCallback
	wep.CustomBulletCallback = function(a, tr, dmg)
		local wep = dmg:GetInflictor()
		if wep:GetStat("Primary.StatusEffect") then
			GMSERV:AddStatus(tr.Entity, wep:GetOwner(), wep:GetStat("Primary.StatusEffect"), wep:GetStat("Primary.StatusEffectDur"), wep:GetStat("Primary.StatusEffectDmg"), wep:GetStat("Primary.StatusEffectParticle"))
			--util.Effect("BGOLightning", ED_Stun, true, true)
		end
	end
end

function ATTACHMENT:Detach(wep)
	wep.CustomBulletCallback = wep.CustomBulletCallbackOld
	wep.CustomBulletCallbackOld = nil
end

if not TFA_ATTACHMENT_ISUPDATING then
	TFAUpdateAttachments()
end
--PATH lua/autorun/tfa_comm_sw_yodamundi.lua:
player_manager.AddValidModel("TFA-SW-Yoda","models/tfa/comm/gg/pm_sw_yoda.mdl")
player_manager.AddValidModel("TFA-SW-Yoda-NoJiggle","models/tfa/comm/gg/pm_sw_yodanojig.mdl")
--PATH addons/[misc] trzecia_osoba/lua/autorun/thirdperson.lua:
/*                                                                                                             
 ,---. ,--.              ,--.          ,--------,--.    ,--.        ,--,------.                                 
'   .-'`--,--,--,--.,---.|  |,---.     '--.  .--|  ,---.`--,--.--.,-|  |  .--. ',---.,--.--.,---. ,---.,--,--,  
`.  `-.,--|        | .-. |  | .-. :       |  |  |  .-.  ,--|  .--' .-. |  '--' | .-. |  .--(  .-'| .-. |      \ 
.-'    |  |  |  |  | '-' |  \   --.       |  |  |  | |  |  |  |  \ `-' |  | --'\   --|  |  .-'  `' '-' |  ||  | 
`-----'`--`--`--`--|  |-'`--'`----'       `--'  `--' `--`--`--'   `---'`--'     `----`--'  `----' `---'`--''--'
By FailCake :D (edunad)
A simple Thirdperson Addon. Press C (context menu) then Thirdperson 
*/

// SHARED
CreateConVar("simple_thirdperson_maxdistance", "0", { FCVAR_REPLICATED, FCVAR_ARCHIVE } , "Sets the max distance the player can go (0 = disabled)")
CreateConVar("simple_thirdperson_maxpitch", "0", { FCVAR_REPLICATED, FCVAR_ARCHIVE } , "Sets the max pitch the player can go (0 = disabled)")
CreateConVar("simple_thirdperson_maxright", "0", { FCVAR_REPLICATED, FCVAR_ARCHIVE } , "Sets the max right the player can go (0 = disabled)")
CreateConVar("simple_thirdperson_maxyaw", "0", { FCVAR_REPLICATED, FCVAR_ARCHIVE } , "Sets the max yaw the player can go (0 = disabled)")
CreateConVar("simple_thirdperson_maxup", "0", { FCVAR_REPLICATED, FCVAR_ARCHIVE } , "Sets the min up the player can go (0 = disabled)")

CreateConVar("simple_thirdperson_mindistance", "0", { FCVAR_REPLICATED, FCVAR_ARCHIVE } , "Sets the min distance the player can go (0 = disabled)")
CreateConVar("simple_thirdperson_minpitch", "0", { FCVAR_REPLICATED, FCVAR_ARCHIVE } , "Sets the min pitch the player can go (0 = disabled)")
CreateConVar("simple_thirdperson_minright", "0", { FCVAR_REPLICATED, FCVAR_ARCHIVE } , "Sets the min right the player can go (0 = disabled)")
CreateConVar("simple_thirdperson_minyaw", "0", { FCVAR_REPLICATED, FCVAR_ARCHIVE } , "Sets the min yaw the player can go (0 = disabled)")
CreateConVar("simple_thirdperson_minup", "0", { FCVAR_REPLICATED, FCVAR_ARCHIVE } , "Sets the min up the player can go (0 = disabled)")

CreateConVar("simple_thirdperson_shoulder_maxdist", "0", { FCVAR_REPLICATED, FCVAR_ARCHIVE } , "Sets the max shoulder distance the player can go (0 = disabled)")
CreateConVar("simple_thirdperson_shoulder_mindist", "0", { FCVAR_REPLICATED, FCVAR_ARCHIVE } , "Sets the min shoulder distance the player can go (0 = disabled)")
CreateConVar("simple_thirdperson_shoulder_maxup", "0", { FCVAR_REPLICATED, FCVAR_ARCHIVE } , "Sets the max shoulder up the player can go (0 = disabled)")
CreateConVar("simple_thirdperson_shoulder_minup", "0", { FCVAR_REPLICATED, FCVAR_ARCHIVE } , "Sets the min shoulder up the player can go (0 = disabled)")
CreateConVar("simple_thirdperson_shoulder_maxright", "0", { FCVAR_REPLICATED, FCVAR_ARCHIVE } , "Sets the max shoulder right the player can go (0 = disabled)")
CreateConVar("simple_thirdperson_shoulder_minright", "0", { FCVAR_REPLICATED, FCVAR_ARCHIVE } , "Sets the min shoulder right the player can go (0 = disabled)")

CreateConVar("simple_thirdperson_forcecollide", "0", { FCVAR_REPLICATED, FCVAR_ARCHIVE } , "Forces the player to use collide or not (0 = disabled,1 = on,2 = off)")
CreateConVar("simple_thirdperson_forceshoulder", "0", { FCVAR_REPLICATED, FCVAR_ARCHIVE} , "Forces the player to use shoulder view or not (0 = disabled,1 = on,2 = off)")
CreateConVar("simple_thirdperson_forcesmooth", "0", { FCVAR_REPLICATED, FCVAR_ARCHIVE } , "Forces the player to use smooth view or not (0 = disabled,1 = on,2 = off)")

if CLIENT then	

	CreateClientConVar( "simple_thirdperson_enabled", "0", true, false )
	
	CreateClientConVar( "simple_thirdperson_smooth", "1", true, false )
	CreateClientConVar( "simple_thirdperson_smooth_mult_x", "0.3", true, false )
	CreateClientConVar( "simple_thirdperson_smooth_mult_y", "0.3", true, false )
	CreateClientConVar( "simple_thirdperson_smooth_mult_z", "0.3", true, false )
	CreateClientConVar( "simple_thirdperson_smooth_delay", "10", true, false )
	
	CreateClientConVar( "simple_thirdperson_collision", "1", true, false )
	CreateClientConVar( "simple_thirdperson_cam_distance", "100", true, false )
	CreateClientConVar( "simple_thirdperson_cam_right", "0", true, false )
	CreateClientConVar( "simple_thirdperson_cam_up", "0", true, false )
	
	CreateClientConVar( "simple_thirdperson_cam_pitch", "0", true, false )
	CreateClientConVar( "simple_thirdperson_cam_yaw", "0", true, false )
	
	CreateClientConVar( "simple_thirdperson_shoulderview_dist", "50", true, false )
	CreateClientConVar( "simple_thirdperson_shoulderview_up", "0", true, false )
	CreateClientConVar( "simple_thirdperson_shoulderview_right", "40", true, false )
	CreateClientConVar( "simple_thirdperson_shoulderview", "0", true, false )
	CreateClientConVar( "simple_thirdperson_shoulderview_bump", "1", true, false )
	
	CreateClientConVar( "simple_thirdperson_fov_smooth", "1", true, false )
	CreateClientConVar( "simple_thirdperson_fov_smooth_mult", "0.3", true, false )
	
	CreateClientConVar( "simple_thirdperson_hide_crosshair", "0", true, false )
	CreateClientConVar( "simple_thirdperson_enable_custom_crosshair", "0", true, false )
	
	CreateClientConVar( "simple_thirdperson_custom_crosshair_r", "255", true, false )
	CreateClientConVar( "simple_thirdperson_custom_crosshair_g", "230", true, false )
	CreateClientConVar( "simple_thirdperson_custom_crosshair_b", "0", true, false )
	CreateClientConVar( "simple_thirdperson_custom_crosshair_a", "240", true, false )
	
	local Editor = {}

	Editor.DelayPos = nil
	Editor.ViewPos = nil
	
	Editor.ShoulderToggle = GetConVar( "simple_thirdperson_shoulderview" ):GetBool() or false
	Editor.EnableToggle = GetConVar( "simple_thirdperson_enabled" ):GetBool() or false
	Editor.CollisionToggle = GetConVar( "simple_thirdperson_collision" ):GetBool() or false
	Editor.FOVToggle = GetConVar( "simple_thirdperson_fov_smooth" ):GetBool() or false
	Editor.SmoothToggle = GetConVar( "simple_thirdperson_smooth" ):GetBool() or true
	Editor.ShoulderBumpToggle = GetConVar( "simple_thirdperson_shoulderview_bump" ):GetBool() or false
	
	Editor.CustomCrossToggle = GetConVar( "simple_thirdperson_enable_custom_crosshair" ):GetBool() or false
	Editor.CrossToggle = GetConVar( "simple_thirdperson_hide_crosshair" ):GetBool() or false
	
	list.Set(
		"DesktopWindows", 
		"ThirdPerson",
		{
			title = "Simple ThirdPerson",
			icon = "icon32/zoom_extend.png",
			width = 300,
			height = 170,
			onewindow = true,
			init = function(icn, pnl)
				BuildMenu(pnl)
			end
		}
	)
	
	function BuildMenu(PNL)
	
		if Editor.PANEL != nil then
			Editor.PANEL:Remove()
		end
		
		if PNL == nil then	
			PNL = vgui.Create( "DFrame" )
			PNL:SetSize( 300, 170 )
			PNL:SetTitle( "Simple ThirdPerson" )
			PNL:SetVisible( true )
			PNL:SetDraggable( true )
			PNL:ShowCloseButton( true )
			PNL:MakePopup()
		end

		Editor.PANEL = PNL
		Editor.PANEL:SetPos(ScrW() - 310,40)
		
		Editor.PANEL.Sheet = Editor.PANEL:Add( "DPropertySheet" )
		Editor.PANEL.Sheet:Dock(LEFT)
		Editor.PANEL.Sheet:SetSize( 290, 0 )
		Editor.PANEL.Sheet:SetPos(5,0)
		
		Editor.PANEL.Settings = Editor.PANEL.Sheet:Add( "DPanelSelect" )
		Editor.PANEL.Sheet:AddSheet( "Settings", Editor.PANEL.Settings, "icon16/cog_edit.png" )
		
		Editor.PANEL.CameraSettings = Editor.PANEL.Sheet:Add( "DPanelSelect" )
		Editor.PANEL.Sheet:AddSheet( "Camera", Editor.PANEL.CameraSettings, "icon16/camera_edit.png" )
		
		Editor.PANEL.SmoothSettings = Editor.PANEL.Sheet:Add( "DPanelSelect" )
		Editor.PANEL.Sheet:AddSheet( "Smooth", Editor.PANEL.SmoothSettings, "icon16/chart_line.png" )
		
		Editor.PANEL.ShoulderSettings = Editor.PANEL.Sheet:Add( "DPanelSelect" )
		Editor.PANEL.Sheet:AddSheet( "Shoulder", Editor.PANEL.ShoulderSettings, "icon16/camera_go.png" )
		
		Editor.PANEL.CrossSettings = Editor.PANEL.Sheet:Add( "DPanelSelect" )
		Editor.PANEL.Sheet:AddSheet( "Crosshair", Editor.PANEL.CrossSettings, "icon16/collision_on.png" )
		
		Editor.PANEL.CreditsSettings = Editor.PANEL.Sheet:Add( "DPanelSelect" )
		Editor.PANEL.Sheet:AddSheet( "Credits :D", Editor.PANEL.CreditsSettings, "icon16/star.png" )
		
		Editor.PANEL.EnableThrd = Editor.PANEL.Settings:Add( "DButton" )
		Editor.PANEL.EnableThrd:SizeToContents()
		
		if Editor.EnableToggle then
			Editor.PANEL.EnableThrd:SetText("Disable ThirdPerson")
			Editor.PANEL.EnableThrd:SetTextColor(Color(150,0,0))
		else
			Editor.PANEL.EnableThrd:SetText("Enable ThirdPerson")
			Editor.PANEL.EnableThrd:SetTextColor(Color(0,150,0))
		end
		
		Editor.PANEL.EnableThrd:SetPos(10,6)
		Editor.PANEL.EnableThrd:SetSize(250,20)
		Editor.PANEL.EnableThrd.DoClick = function()

			Editor.EnableToggle = !Editor.EnableToggle
			RunConsoleCommand("simple_thirdperson_enabled",BoolToInt(Editor.EnableToggle))
			
			if Editor.EnableToggle then
				Editor.PANEL.EnableThrd:SetText("Disable ThirdPerson")
				Editor.PANEL.EnableThrd:SetTextColor(Color(150,0,0))
			else
				Editor.PANEL.EnableThrd:SetText("Enable ThirdPerson")
				Editor.PANEL.EnableThrd:SetTextColor(Color(0,150,0))
			end
					
		end

		Editor.PANEL.Lbl_SPLIT = Editor.PANEL.Settings:Add("DLabel")
		Editor.PANEL.Lbl_SPLIT:SetPos(20,29)
		Editor.PANEL.Lbl_SPLIT:SetText("------------------------ RESETS ------------------------")
		Editor.PANEL.Lbl_SPLIT:SizeToContents() 
	
		Editor.PANEL.ResetCam = Editor.PANEL.Settings:Add( "DButton" )
		Editor.PANEL.ResetCam:SizeToContents()
		Editor.PANEL.ResetCam:SetText("Camera Reset")
		Editor.PANEL.ResetCam:SetPos(10,46)
		Editor.PANEL.ResetCam:SetSize(120,20)
		Editor.PANEL.ResetCam.DoClick = function()
			RunConsoleCommand("simple_thirdperson_cam_distance",100)
			RunConsoleCommand("simple_thirdperson_cam_right",0)
			RunConsoleCommand("simple_thirdperson_cam_up",0)
			RunConsoleCommand("simple_thirdperson_cam_yaw",0)
			RunConsoleCommand("simple_thirdperson_cam_pitch",0)
			chat.AddText(Color(255,255,255),"[",Color(255,155,0),"Simple ThirdPerson",Color(255,255,255),"] Camera Reset !")
			Editor.PANEL:Close()
		end
		
		Editor.PANEL.ResetShoulder = Editor.PANEL.Settings:Add( "DButton" )
		Editor.PANEL.ResetShoulder:SizeToContents()
		Editor.PANEL.ResetShoulder:SetText("ShoulderView Reset")
		Editor.PANEL.ResetShoulder:SetPos(140,46)
		Editor.PANEL.ResetShoulder:SetSize(120,20)
		Editor.PANEL.ResetShoulder.DoClick = function()
			RunConsoleCommand("simple_thirdperson_shoulderview_dist",50)
			RunConsoleCommand("simple_thirdperson_shoulderview_up",0)
			RunConsoleCommand("simple_thirdperson_shoulderview_right",40)
			chat.AddText(Color(255,255,255),"[",Color(255,155,0),"Simple ThirdPerson",Color(255,255,255),"] ShoulderView Reset !")
			Editor.PANEL:Close()
		end
		
		Editor.PANEL.ResetSmooth = Editor.PANEL.Settings:Add( "DButton" )
		Editor.PANEL.ResetSmooth:SizeToContents()
		Editor.PANEL.ResetSmooth:SetText("Smooth Settings Reset")
		Editor.PANEL.ResetSmooth:SetPos(10,76)
		Editor.PANEL.ResetSmooth:SetSize(130,20)
		Editor.PANEL.ResetSmooth.DoClick = function()
			RunConsoleCommand("simple_thirdperson_smooth",1)
			RunConsoleCommand("simple_thirdperson_smooth_mult_x",0.3)
			RunConsoleCommand("simple_thirdperson_smooth_mult_y",0.3)
			RunConsoleCommand("simple_thirdperson_smooth_mult_z",0.3)
			RunConsoleCommand("simple_thirdperson_smooth_delay",10)
			chat.AddText(Color(255,255,255),"[",Color(255,155,0),"Simple ThirdPerson",Color(255,255,255),"] Smooth Reset !")
			Editor.PANEL:Close()
		end
		
		Editor.PANEL.ResetFOV = Editor.PANEL.Settings:Add( "DButton" )
		Editor.PANEL.ResetFOV:SizeToContents()
		Editor.PANEL.ResetFOV:SetText("FOV Settings Reset")
		Editor.PANEL.ResetFOV:SetPos(145,76)
		Editor.PANEL.ResetFOV:SetSize(115,20)
		Editor.PANEL.ResetFOV.DoClick = function()
			RunConsoleCommand("simple_thirdperson_fov_smooth",1)
			RunConsoleCommand("simple_thirdperson_fov_smooth_mult",0.3)
			chat.AddText(Color(255,255,255),"[",Color(255,155,0),"Simple ThirdPerson",Color(255,255,255),"] FOV Reset !")
			Editor.PANEL:Close()
		end
		
		
		// ---------------- PANEL CAMERA ---------------- //
		
		Editor.PANEL.CollisionButton = Editor.PANEL.CameraSettings:Add( "DButton" )
		Editor.PANEL.CollisionButton:SizeToContents()
		
			if Editor.CollisionToggle then
				Editor.PANEL.CollisionButton:SetText("Disable Camera Collision")
				Editor.PANEL.CollisionButton:SetTextColor(Color(150,0,0))
			else
				Editor.PANEL.CollisionButton:SetText("Enable Camera Collision")
				Editor.PANEL.CollisionButton:SetTextColor(Color(0,150,0))
			end
			
		Editor.PANEL.CollisionButton:SetText("Toggle Camera Collision")
		Editor.PANEL.CollisionButton:SetPos(10,6)
		Editor.PANEL.CollisionButton:SetSize(250,20)
		Editor.PANEL.CollisionButton.DoClick = function()
		
			Editor.CollisionToggle = !Editor.CollisionToggle
			RunConsoleCommand("simple_thirdperson_collision",BoolToInt(Editor.CollisionToggle))	
			
			if Editor.CollisionToggle then
				Editor.PANEL.CollisionButton:SetText("Disable Camera Collision")
				Editor.PANEL.CollisionButton:SetTextColor(Color(150,0,0))
			else
				Editor.PANEL.CollisionButton:SetText("Enable Camera Collision")
				Editor.PANEL.CollisionButton:SetTextColor(Color(0,150,0))
			end
								
		end
		
		Editor.PANEL.CamDistanceTxt = Editor.PANEL.CameraSettings:Add("DLabel")
		Editor.PANEL.CamDistanceTxt:SetPos(10,35)
		Editor.PANEL.CamDistanceTxt:SetText("Camera Distance : ")
		Editor.PANEL.CamDistanceTxt:SizeToContents() 
		
		Editor.PANEL.CamDistanceLb = Editor.PANEL.CameraSettings:Add("DTextEntry")
		Editor.PANEL.CamDistanceLb:SetPos(110,30)
		Editor.PANEL.CamDistanceLb:SetValue(GetConVar( "simple_thirdperson_cam_distance" ):GetFloat())
		Editor.PANEL.CamDistanceLb:SetSize(40,20)
		Editor.PANEL.CamDistanceLb:SetNumeric(true)	
		Editor.PANEL.CamDistanceLb:SetUpdateOnType( true )
		
		Editor.PANEL.CamDistanceLb.OnTextChanged  = function()
			RunConsoleCommand("simple_thirdperson_cam_distance",Editor.PANEL.CamDistanceLb:GetValue())
			Editor.PANEL.CamDistance_PRF:SetValue(Editor.PANEL.CamDistanceLb:GetValue())
		end
		
		Editor.PANEL.CamDistance_PRF = Editor.PANEL.CameraSettings:Add("DNumberScratch")
		Editor.PANEL.CamDistance_PRF:SetPos(155,32)
		Editor.PANEL.CamDistance_PRF:SetValue(GetConVar( "simple_thirdperson_cam_distance" ):GetFloat())
		Editor.PANEL.CamDistance_PRF:SetMin( -100 )
		Editor.PANEL.CamDistance_PRF:SetMax( 1000 )
		Editor.PANEL.CamDistance_PRF.OnValueChanged  = function()
			Editor.PANEL.CamDistanceLb:SetValue(Editor.PANEL.CamDistance_PRF:GetTextValue())
			RunConsoleCommand("simple_thirdperson_cam_distance",Editor.PANEL.CamDistance_PRF:GetTextValue())
		end
		
		
		Editor.PANEL.CamYawTxt = Editor.PANEL.CameraSettings:Add("DLabel")
		Editor.PANEL.CamYawTxt:SetPos(150,62)
		Editor.PANEL.CamYawTxt:SetText("| Yaw : ")
		Editor.PANEL.CamYawTxt:SizeToContents() 
		
		Editor.PANEL.CamYawLb = Editor.PANEL.CameraSettings:Add("DTextEntry")
		Editor.PANEL.CamYawLb:SetPos(190,57)
		Editor.PANEL.CamYawLb:SetValue(GetConVar( "simple_thirdperson_cam_yaw" ):GetFloat())
		Editor.PANEL.CamYawLb:SetSize(40,20)
		Editor.PANEL.CamYawLb:SetNumeric(true)
		Editor.PANEL.CamYawLb:SetUpdateOnType( true )
		Editor.PANEL.CamYawLb.OnTextChanged  = function()
			RunConsoleCommand("simple_thirdperson_cam_yaw",Editor.PANEL.CamYawLb:GetValue())
			Editor.PANEL.CamYawLb_PRF:SetValue(Editor.PANEL.CamYawLb:GetValue())
		end
		
		Editor.PANEL.CamYawLb_PRF = Editor.PANEL.CameraSettings:Add("DNumberScratch")
		Editor.PANEL.CamYawLb_PRF:SetPos(235,59)
		Editor.PANEL.CamYawLb_PRF:SetValue(GetConVar( "simple_thirdperson_cam_yaw" ):GetFloat())
		Editor.PANEL.CamYawLb_PRF:SetMin( 0 )
		Editor.PANEL.CamYawLb_PRF:SetMax( 360 )
		Editor.PANEL.CamYawLb_PRF.OnValueChanged  = function()
			RunConsoleCommand("simple_thirdperson_cam_yaw",Editor.PANEL.CamYawLb_PRF:GetTextValue())
			Editor.PANEL.CamYawLb:SetValue(Editor.PANEL.CamYawLb_PRF:GetTextValue())	
		end
		

		Editor.PANEL.CamPitchTxt = Editor.PANEL.CameraSettings:Add("DLabel")
		Editor.PANEL.CamPitchTxt:SetPos(160,85)
		Editor.PANEL.CamPitchTxt:SetText("| Pitch : ")
		Editor.PANEL.CamPitchTxt:SizeToContents() 
		
		Editor.PANEL.CamPitchLb = Editor.PANEL.CameraSettings:Add("DTextEntry")
		Editor.PANEL.CamPitchLb:SetPos(200,80)
		Editor.PANEL.CamPitchLb:SetValue(GetConVar( "simple_thirdperson_cam_pitch" ):GetFloat())
		Editor.PANEL.CamPitchLb:SetSize(40,20)
		Editor.PANEL.CamPitchLb:SetNumeric(true)
		Editor.PANEL.CamPitchLb:SetUpdateOnType( true )
		Editor.PANEL.CamPitchLb.OnTextChanged  = function()
			RunConsoleCommand("simple_thirdperson_cam_pitch",Editor.PANEL.CamPitchLb:GetValue())
			Editor.PANEL.CamPitchLb_PRF:SetValue(Editor.PANEL.CamPitchLb:GetValue())
		end
		
		Editor.PANEL.CamPitchLb_PRF = Editor.PANEL.CameraSettings:Add("DNumberScratch")
		Editor.PANEL.CamPitchLb_PRF:SetPos(245,82)
		Editor.PANEL.CamPitchLb_PRF:SetValue(GetConVar( "simple_thirdperson_cam_pitch" ):GetFloat())
		Editor.PANEL.CamPitchLb_PRF:SetMin( 0 )
		Editor.PANEL.CamPitchLb_PRF:SetMax( 360 )
		Editor.PANEL.CamPitchLb_PRF.OnValueChanged  = function()
			RunConsoleCommand("simple_thirdperson_cam_pitch",Editor.PANEL.CamPitchLb_PRF:GetTextValue())
			Editor.PANEL.CamPitchLb:SetValue(Editor.PANEL.CamPitchLb_PRF:GetTextValue())
		end
		
		Editor.PANEL.CamUpTxt = Editor.PANEL.CameraSettings:Add("DLabel")
		Editor.PANEL.CamUpTxt:SetPos(10,62)
		Editor.PANEL.CamUpTxt:SetText("Camera Up : ")
		Editor.PANEL.CamUpTxt:SizeToContents() 
		
		Editor.PANEL.CamUpTxtLB = Editor.PANEL.CameraSettings:Add("DTextEntry")
		Editor.PANEL.CamUpTxtLB:SetPos(80,57)
		Editor.PANEL.CamUpTxtLB:SetValue(GetConVar( "simple_thirdperson_cam_up" ):GetFloat())
		Editor.PANEL.CamUpTxtLB:SetSize(40,20)
		Editor.PANEL.CamUpTxtLB:SetNumeric(true)
		Editor.PANEL.CamUpTxtLB:SetUpdateOnType( true )
		Editor.PANEL.CamUpTxtLB.OnTextChanged  = function()
			RunConsoleCommand("simple_thirdperson_cam_up",Editor.PANEL.CamUpTxtLB:GetValue())
			Editor.PANEL.CamUpTxtLB_PRF:SetValue(Editor.PANEL.CamUpTxtLB:GetValue())
		end
		
		Editor.PANEL.CamUpTxtLB_PRF = Editor.PANEL.CameraSettings:Add("DNumberScratch")
		Editor.PANEL.CamUpTxtLB_PRF:SetPos(125,59)
		Editor.PANEL.CamUpTxtLB_PRF:SetValue(GetConVar( "simple_thirdperson_cam_up" ):GetFloat())
		Editor.PANEL.CamUpTxtLB_PRF:SetMin( -1000 )
		Editor.PANEL.CamUpTxtLB_PRF:SetMax( 1000 )
		Editor.PANEL.CamUpTxtLB_PRF.OnValueChanged  = function()
			RunConsoleCommand("simple_thirdperson_cam_up",Editor.PANEL.CamUpTxtLB_PRF:GetTextValue())
			Editor.PANEL.CamUpTxtLB:SetValue(Editor.PANEL.CamUpTxtLB_PRF:GetTextValue())	
		end
		
		Editor.PANEL.CamLeftTxt = Editor.PANEL.CameraSettings:Add("DLabel")
		Editor.PANEL.CamLeftTxt:SetPos(10,85)
		Editor.PANEL.CamLeftTxt:SetText("Camera Right : ")
		Editor.PANEL.CamLeftTxt:SizeToContents() 
		
		Editor.PANEL.CamLeftTxtLB = Editor.PANEL.CameraSettings:Add("DTextEntry")
		Editor.PANEL.CamLeftTxtLB:SetPos(90,80)
		Editor.PANEL.CamLeftTxtLB:SetValue(GetConVar( "simple_thirdperson_cam_right" ):GetFloat())
		Editor.PANEL.CamLeftTxtLB:SetSize(40,20)
		Editor.PANEL.CamLeftTxtLB:SetNumeric(true)
		Editor.PANEL.CamLeftTxtLB:SetUpdateOnType( true )
		Editor.PANEL.CamLeftTxtLB.OnTextChanged  = function()
			RunConsoleCommand("simple_thirdperson_cam_right",Editor.PANEL.CamLeftTxtLB:GetValue())
			Editor.PANEL.CamLeftTxtLB_PRF:SetValue(Editor.PANEL.CamLeftTxtLB:GetValue())
		end
		
		Editor.PANEL.CamLeftTxtLB_PRF = Editor.PANEL.CameraSettings:Add("DNumberScratch")	
		Editor.PANEL.CamLeftTxtLB_PRF:SetPos(135,82)
		Editor.PANEL.CamLeftTxtLB_PRF:SetValue(GetConVar( "simple_thirdperson_cam_right" ):GetFloat())
		Editor.PANEL.CamLeftTxtLB_PRF:SetMin( -1000 )
		Editor.PANEL.CamLeftTxtLB_PRF:SetMax( 1000 )
		Editor.PANEL.CamLeftTxtLB_PRF.OnValueChanged  = function()
			RunConsoleCommand("simple_thirdperson_cam_right",Editor.PANEL.CamLeftTxtLB_PRF:GetTextValue())
			Editor.PANEL.CamLeftTxtLB:SetValue(Editor.PANEL.CamLeftTxtLB_PRF:GetTextValue())	
		end
		
		// ---------------- PANEL SMOOTH ---------------- //
		
		Editor.PANEL.SmoothButton = Editor.PANEL.SmoothSettings:Add( "DButton" )
		Editor.PANEL.SmoothButton:SizeToContents()
		
		if Editor.SmoothToggle then
			Editor.PANEL.SmoothButton:SetText("Disable Camera Smoothing")
			Editor.PANEL.SmoothButton:SetTextColor(Color(150,0,0))
		else
			Editor.PANEL.SmoothButton:SetText("Enable Camera Smoothing")
			Editor.PANEL.SmoothButton:SetTextColor(Color(0,150,0))
		end

		Editor.PANEL.SmoothButton:SetPos(10,6)
		Editor.PANEL.SmoothButton:SetSize(250,20)
		Editor.PANEL.SmoothButton.DoClick = function()
			Editor.SmoothToggle = !Editor.SmoothToggle
			RunConsoleCommand("simple_thirdperson_smooth",BoolToInt(Editor.SmoothToggle))	

			if Editor.SmoothToggle then
				Editor.PANEL.SmoothButton:SetText("Disable Camera Smoothing")
				Editor.PANEL.SmoothButton:SetTextColor(Color(150,0,0))
			else
				Editor.PANEL.SmoothButton:SetText("Enable Camera Smoothing")
				Editor.PANEL.SmoothButton:SetTextColor(Color(0,150,0))
			end					
		end
		
		Editor.PANEL.SmoothFOVButton = Editor.PANEL.SmoothSettings:Add( "DButton" )
		Editor.PANEL.SmoothFOVButton:SizeToContents()
		
		if Editor.FOVToggle then
			Editor.PANEL.SmoothFOVButton:SetText("Disable FOV Smoothing")
			Editor.PANEL.SmoothFOVButton:SetTextColor(Color(150,0,0))
		else
			Editor.PANEL.SmoothFOVButton:SetText("Enable FOV Smoothing")
			Editor.PANEL.SmoothFOVButton:SetTextColor(Color(0,150,0))
		end
		
		Editor.PANEL.SmoothFOVButton:SetPos(10,30)
		Editor.PANEL.SmoothFOVButton:SetSize(250,20)
		Editor.PANEL.SmoothFOVButton.DoClick = function()
			Editor.FOVToggle = !Editor.FOVToggle
			RunConsoleCommand("simple_thirdperson_fov_smooth",BoolToInt(Editor.FOVToggle))

			if Editor.FOVToggle then
				Editor.PANEL.SmoothFOVButton:SetText("Disable FOV Smoothing")
				Editor.PANEL.SmoothFOVButton:SetTextColor(Color(150,0,0))
			else
				Editor.PANEL.SmoothFOVButton:SetText("Enable FOV Smoothing")
				Editor.PANEL.SmoothFOVButton:SetTextColor(Color(0,150,0))
			end					
		end
		
		Editor.PANEL.CamSmoothDeTxt = Editor.PANEL.SmoothSettings:Add("DLabel")
		Editor.PANEL.CamSmoothDeTxt:SetPos(10,60)
		Editor.PANEL.CamSmoothDeTxt:SetText("Smooth Delay : ")
		Editor.PANEL.CamSmoothDeTxt:SizeToContents() 
		
		Editor.PANEL.CamSmoDelayLb = Editor.PANEL.SmoothSettings:Add("DTextEntry")
		Editor.PANEL.CamSmoDelayLb:SetPos(90,55)
		Editor.PANEL.CamSmoDelayLb:SetValue(math.Round(GetConVar( "simple_thirdperson_smooth_delay" ):GetFloat(),2))
		Editor.PANEL.CamSmoDelayLb:SetSize(40,20)
		Editor.PANEL.CamSmoDelayLb:SetNumeric(true)
		Editor.PANEL.CamSmoDelayLb:SetUpdateOnType( true )
		Editor.PANEL.CamSmoDelayLb.OnTextChanged  = function()
			RunConsoleCommand("simple_thirdperson_smooth_delay",Editor.PANEL.CamSmoDelayLb:GetValue())
			Editor.PANEL.CamSmoDelayLb_PRF:SetValue(Editor.PANEL.CamSmoDelayLb:GetValue())
		end
		
		Editor.PANEL.CamSmoDelayLb_PRF = Editor.PANEL.SmoothSettings:Add("DNumberScratch")
		Editor.PANEL.CamSmoDelayLb_PRF:SetPos(135,57)
		Editor.PANEL.CamSmoDelayLb_PRF:SetValue(math.Round(GetConVar( "simple_thirdperson_smooth_delay" ):GetFloat(),2))
		Editor.PANEL.CamSmoDelayLb_PRF:SetMin( 1 )
		Editor.PANEL.CamSmoDelayLb_PRF:SetMax( 100 )
		Editor.PANEL.CamSmoDelayLb_PRF.OnValueChanged  = function()
			RunConsoleCommand("simple_thirdperson_smooth_delay",Editor.PANEL.CamSmoDelayLb_PRF:GetTextValue())
			Editor.PANEL.CamSmoDelayLb:SetValue(Editor.PANEL.CamSmoDelayLb_PRF:GetTextValue())	
		end
		
		
		Editor.PANEL.CamSmoothMultXTxt = Editor.PANEL.SmoothSettings:Add("DLabel")
		Editor.PANEL.CamSmoothMultXTxt:SetPos(160,60)
		Editor.PANEL.CamSmoothMultXTxt:SetText("| Mult X : ")
		Editor.PANEL.CamSmoothMultXTxt:SizeToContents() 
		
		Editor.PANEL.CamSmoothMultXTxtLb = Editor.PANEL.SmoothSettings:Add("DTextEntry")
		Editor.PANEL.CamSmoothMultXTxtLb:SetPos(210,55)
		Editor.PANEL.CamSmoothMultXTxtLb:SetValue(math.Round(GetConVar( "simple_thirdperson_smooth_mult_x" ):GetFloat(),2))
		Editor.PANEL.CamSmoothMultXTxtLb:SetSize(40,20)
		Editor.PANEL.CamSmoothMultXTxtLb:SetNumeric(true)
		Editor.PANEL.CamSmoothMultXTxtLb:SetUpdateOnType( true )
		Editor.PANEL.CamSmoothMultXTxtLb.OnTextChanged  = function()
			RunConsoleCommand("simple_thirdperson_smooth_mult_x",Editor.PANEL.CamSmoothMultXTxtLb:GetValue())
			Editor.PANEL.CamSmoothMultXTxtLb_PRF:SetValue(Editor.PANEL.CamSmoothMultXTxtLb:GetValue())
		end
		
		Editor.PANEL.CamSmoothMultXTxtLb_PRF = Editor.PANEL.SmoothSettings:Add("DNumberScratch")
		Editor.PANEL.CamSmoothMultXTxtLb_PRF:SetPos(255,57)
		Editor.PANEL.CamSmoothMultXTxtLb_PRF:SetValue(math.Round(GetConVar( "simple_thirdperson_smooth_mult_x" ):GetFloat(),2))
		Editor.PANEL.CamSmoothMultXTxtLb_PRF:SetMin( 0.01 )
		Editor.PANEL.CamSmoothMultXTxtLb_PRF:SetMax( 1 )
		Editor.PANEL.CamSmoothMultXTxtLb_PRF.OnValueChanged  = function()
			RunConsoleCommand("simple_thirdperson_smooth_mult_x",Editor.PANEL.CamSmoothMultXTxtLb_PRF:GetTextValue())
			Editor.PANEL.CamSmoothMultXTxtLb:SetValue(Editor.PANEL.CamSmoothMultXTxtLb_PRF:GetTextValue())
		end
		
		
		Editor.PANEL.CamSmoothMultYTxt = Editor.PANEL.SmoothSettings:Add("DLabel")
		Editor.PANEL.CamSmoothMultYTxt:SetPos(10,85)
		Editor.PANEL.CamSmoothMultYTxt:SetText("Mult Y : ")
		Editor.PANEL.CamSmoothMultYTxt:SizeToContents() 
		
		Editor.PANEL.CamSmoothMultYTxtLb = Editor.PANEL.SmoothSettings:Add("DTextEntry")
		Editor.PANEL.CamSmoothMultYTxtLb:SetPos(50,80)
		Editor.PANEL.CamSmoothMultYTxtLb:SetValue(math.Round(GetConVar( "simple_thirdperson_smooth_mult_y" ):GetFloat(),2))
		Editor.PANEL.CamSmoothMultYTxtLb:SetSize(40,20)
		Editor.PANEL.CamSmoothMultYTxtLb:SetNumeric(true)
		Editor.PANEL.CamSmoothMultYTxtLb:SetUpdateOnType( true )
		Editor.PANEL.CamSmoothMultYTxtLb.OnTextChanged  = function()
			RunConsoleCommand("simple_thirdperson_smooth_mult_y",Editor.PANEL.CamSmoothMultYTxtLb:GetValue())
			Editor.PANEL.CamSmoothMultYTxtLb_PRF:SetValue(Editor.PANEL.CamSmoothMultYTxtLb:GetValue())
		end
		
		Editor.PANEL.CamSmoothMultYTxtLb_PRF = Editor.PANEL.SmoothSettings:Add("DNumberScratch")
		Editor.PANEL.CamSmoothMultYTxtLb_PRF:SetPos(95,82)
		Editor.PANEL.CamSmoothMultYTxtLb_PRF:SetValue(math.Round(GetConVar( "simple_thirdperson_smooth_mult_y" ):GetFloat(),2))
		Editor.PANEL.CamSmoothMultYTxtLb_PRF:SetMin( 0.01 )
		Editor.PANEL.CamSmoothMultYTxtLb_PRF:SetMax( 1 )
		Editor.PANEL.CamSmoothMultYTxtLb_PRF.OnValueChanged  = function()
			RunConsoleCommand("simple_thirdperson_smooth_mult_y",Editor.PANEL.CamSmoothMultYTxtLb_PRF:GetTextValue())
			Editor.PANEL.CamSmoothMultYTxtLb:SetValue(Editor.PANEL.CamSmoothMultYTxtLb_PRF:GetTextValue())
		end
		
		Editor.PANEL.CamSmoothMultZTxt = Editor.PANEL.SmoothSettings:Add("DLabel")
		Editor.PANEL.CamSmoothMultZTxt:SetPos(120,85)
		Editor.PANEL.CamSmoothMultZTxt:SetText("| Mult Z : ")
		Editor.PANEL.CamSmoothMultZTxt:SizeToContents() 
		
		Editor.PANEL.CamSmoothMultZTxtLb = Editor.PANEL.SmoothSettings:Add("DTextEntry")
		Editor.PANEL.CamSmoothMultZTxtLb:SetPos(170,80)
		Editor.PANEL.CamSmoothMultZTxtLb:SetValue(math.Round(GetConVar( "simple_thirdperson_smooth_mult_z" ):GetFloat(),2))
		Editor.PANEL.CamSmoothMultZTxtLb:SetSize(40,20)
		Editor.PANEL.CamSmoothMultZTxtLb:SetNumeric(true)
		Editor.PANEL.CamSmoothMultZTxtLb:SetUpdateOnType( true )
		Editor.PANEL.CamSmoothMultZTxtLb.OnTextChanged  = function()
			Editor.PANEL.CamSmoothMultZTxtLb_PRF:SetValue(Editor.PANEL.CamSmoothMultZTxtLb:GetValue())
			RunConsoleCommand("simple_thirdperson_smooth_mult_z",Editor.PANEL.CamSmoothMultZTxtLb:GetValue())
		end
		
		Editor.PANEL.CamSmoothMultZTxtLb_PRF = Editor.PANEL.SmoothSettings:Add("DNumberScratch")
		Editor.PANEL.CamSmoothMultZTxtLb_PRF:SetPos(215,82)
		Editor.PANEL.CamSmoothMultZTxtLb_PRF:SetValue(math.Round(GetConVar( "simple_thirdperson_smooth_mult_z" ):GetFloat(),2))
		Editor.PANEL.CamSmoothMultZTxtLb_PRF:SetMin( 0.01 )
		Editor.PANEL.CamSmoothMultZTxtLb_PRF:SetMax( 1 )
		Editor.PANEL.CamSmoothMultZTxtLb_PRF.OnValueChanged  = function()
			RunConsoleCommand("simple_thirdperson_smooth_mult_z",Editor.PANEL.CamSmoothMultZTxtLb_PRF:GetTextValue())
			Editor.PANEL.CamSmoothMultZTxtLb:SetValue(Editor.PANEL.CamSmoothMultZTxtLb_PRF:GetTextValue())
		end
		
		// ---------------- PANEL SHOULDERVIEW ---------------- //
		
		Editor.PANEL.ShoulderButton = Editor.PANEL.ShoulderSettings:Add( "DButton" )
		Editor.PANEL.ShoulderButton:SizeToContents()
		
		if Editor.ShoulderToggle then
				Editor.PANEL.ShoulderButton:SetText("Disable ShoulderView")
				Editor.PANEL.ShoulderButton:SetTextColor(Color(150,0,0))
			else
				Editor.PANEL.ShoulderButton:SetText("Enable ShoulderView")
				Editor.PANEL.ShoulderButton:SetTextColor(Color(0,150,0))
		end		
		
		Editor.PANEL.ShoulderButton:SetPos(10,6)
		Editor.PANEL.ShoulderButton:SetSize(250,20)
		Editor.PANEL.ShoulderButton.DoClick = function()
			Editor.ShoulderToggle = !Editor.ShoulderToggle
			RunConsoleCommand("simple_thirdperson_shoulderview",BoolToInt(Editor.ShoulderToggle))
			if Editor.ShoulderToggle then
				Editor.PANEL.ShoulderButton:SetText("Disable ShoulderView")
				Editor.PANEL.ShoulderButton:SetTextColor(Color(150,0,0))
			else
				Editor.PANEL.ShoulderButton:SetText("Enable ShoulderView")
				Editor.PANEL.ShoulderButton:SetTextColor(Color(0,150,0))
			end						
		end
		
		Editor.PANEL.ShoulderBumpButton = Editor.PANEL.ShoulderSettings:Add( "DButton" )
		Editor.PANEL.ShoulderBumpButton:SizeToContents()
		
		if Editor.ShoulderBumpToggle then
				Editor.PANEL.ShoulderBumpButton:SetText("Disable ShoulderView Bump")
				Editor.PANEL.ShoulderBumpButton:SetTextColor(Color(150,0,0))
		else
				Editor.PANEL.ShoulderBumpButton:SetText("Enable ShoulderView Bump")
				Editor.PANEL.ShoulderBumpButton:SetTextColor(Color(0,150,0))
		end	
		
		Editor.PANEL.ShoulderBumpButton:SetPos(10,30)
		Editor.PANEL.ShoulderBumpButton:SetSize(250,20)
		Editor.PANEL.ShoulderBumpButton.DoClick = function()
			Editor.ShoulderBumpToggle = !Editor.ShoulderBumpToggle
			RunConsoleCommand("simple_thirdperson_shoulderview_bump",BoolToInt(Editor.ShoulderBumpToggle))	
			if Editor.ShoulderBumpToggle then
					Editor.PANEL.ShoulderBumpButton:SetText("Disable ShoulderView Bump")
					Editor.PANEL.ShoulderBumpButton:SetTextColor(Color(150,0,0))
			else
					Editor.PANEL.ShoulderBumpButton:SetText("Enable ShoulderView Bump")
					Editor.PANEL.ShoulderBumpButton:SetTextColor(Color(0,150,0))
			end						
		end
		
		Editor.PANEL.ShoulderDistTxt = Editor.PANEL.ShoulderSettings:Add("DLabel")
		Editor.PANEL.ShoulderDistTxt:SetPos(10,60)
		Editor.PANEL.ShoulderDistTxt:SetText("Shoulder Dist : ")
		Editor.PANEL.ShoulderDistTxt:SizeToContents() 
		
		Editor.PANEL.ShoulderDistLb = Editor.PANEL.ShoulderSettings:Add("DTextEntry")
		Editor.PANEL.ShoulderDistLb:SetPos(90,55)
		Editor.PANEL.ShoulderDistLb:SetValue(math.Round(GetConVar( "simple_thirdperson_shoulderview_dist" ):GetFloat(),2))
		Editor.PANEL.ShoulderDistLb:SetSize(40,20)
		Editor.PANEL.ShoulderDistLb:SetNumeric(true)
		Editor.PANEL.ShoulderDistLb:SetUpdateOnType( true )
		Editor.PANEL.ShoulderDistLb.OnTextChanged  = function()
			RunConsoleCommand("simple_thirdperson_shoulderview_dist",Editor.PANEL.ShoulderDistLb:GetValue())
				Editor.PANEL.ShoulderDistLb_PRF:SetValue(Editor.PANEL.ShoulderDistLb:GetValue())
		end
		
		Editor.PANEL.ShoulderDistLb_PRF = Editor.PANEL.ShoulderSettings:Add("DNumberScratch")
		Editor.PANEL.ShoulderDistLb_PRF:SetPos(135,57)
		Editor.PANEL.ShoulderDistLb_PRF:SetValue(math.Round(GetConVar( "simple_thirdperson_shoulderview_dist" ):GetFloat(),2))
		Editor.PANEL.ShoulderDistLb_PRF:SetMin( -100 )
		Editor.PANEL.ShoulderDistLb_PRF:SetMax( 1000 )
		Editor.PANEL.ShoulderDistLb_PRF.OnValueChanged  = function()
			RunConsoleCommand("simple_thirdperson_shoulderview_dist",Editor.PANEL.ShoulderDistLb_PRF:GetTextValue())
			Editor.PANEL.ShoulderDistLb:SetValue(Editor.PANEL.ShoulderDistLb_PRF:GetTextValue())
		end
		
		
		Editor.PANEL.ShoulderUPTxt = Editor.PANEL.ShoulderSettings:Add("DLabel")
		Editor.PANEL.ShoulderUPTxt:SetPos(10,85)
		Editor.PANEL.ShoulderUPTxt:SetText("Shoulder Up : ")
		Editor.PANEL.ShoulderUPTxt:SizeToContents() 
		
		Editor.PANEL.ShoulderUpLb = Editor.PANEL.ShoulderSettings:Add("DTextEntry")
		Editor.PANEL.ShoulderUpLb:SetPos(80,80)
		Editor.PANEL.ShoulderUpLb:SetValue(math.Round(GetConVar( "simple_thirdperson_shoulderview_up" ):GetFloat(),2))
		Editor.PANEL.ShoulderUpLb:SetSize(40,20)
		Editor.PANEL.ShoulderUpLb:SetNumeric(true)
		Editor.PANEL.ShoulderUpLb:SetUpdateOnType( true )
		Editor.PANEL.ShoulderUpLb.OnTextChanged  = function()
			RunConsoleCommand("simple_thirdperson_shoulderview_up",Editor.PANEL.ShoulderUpLb:GetValue())
			Editor.PANEL.ShoulderUpLb_PRF:SetValue(Editor.PANEL.ShoulderUpLb:GetValue())
		end
		
		
		Editor.PANEL.ShoulderUpLb_PRF = Editor.PANEL.ShoulderSettings:Add("DNumberScratch")
		Editor.PANEL.ShoulderUpLb_PRF:SetPos(125,82)
		Editor.PANEL.ShoulderUpLb_PRF:SetValue(math.Round(GetConVar( "simple_thirdperson_shoulderview_up" ):GetFloat(),2))
		Editor.PANEL.ShoulderUpLb_PRF:SetMin( -1000 )
		Editor.PANEL.ShoulderUpLb_PRF:SetMax( 1000 )
		Editor.PANEL.ShoulderUpLb_PRF.OnValueChanged  = function()
			RunConsoleCommand("simple_thirdperson_shoulderview_up",Editor.PANEL.ShoulderUpLb_PRF:GetTextValue())
			Editor.PANEL.ShoulderUpLb:SetValue(Editor.PANEL.ShoulderUpLb_PRF:GetTextValue())
		end
		
		Editor.PANEL.ShoulderRIGTxt = Editor.PANEL.ShoulderSettings:Add("DLabel")
		Editor.PANEL.ShoulderRIGTxt:SetPos(180,60)
		Editor.PANEL.ShoulderRIGTxt:SetText("Shoulder Right")
		Editor.PANEL.ShoulderRIGTxt:SizeToContents() 
		
		Editor.PANEL.ShoulderRIGLb = Editor.PANEL.ShoulderSettings:Add("DTextEntry")
		Editor.PANEL.ShoulderRIGLb:SetPos(182,80)
		Editor.PANEL.ShoulderRIGLb:SetValue(math.Round(GetConVar( "simple_thirdperson_shoulderview_right" ):GetFloat(),2))
		Editor.PANEL.ShoulderRIGLb:SetSize(40,20)
		Editor.PANEL.ShoulderRIGLb:SetNumeric(true)
		Editor.PANEL.ShoulderRIGLb:SetUpdateOnType( true )
		Editor.PANEL.ShoulderRIGLb.OnTextChanged  = function()
			RunConsoleCommand("simple_thirdperson_shoulderview_right",Editor.PANEL.ShoulderRIGLb:GetValue())
			Editor.PANEL.ShoulderRIGLb_PRF:SetValue(Editor.PANEL.ShoulderRIGLb:GetValue())
		end
		
		Editor.PANEL.ShoulderRIGLb_PRF = Editor.PANEL.ShoulderSettings:Add("DNumberScratch")
		Editor.PANEL.ShoulderRIGLb_PRF:SetPos(227,82)
		Editor.PANEL.ShoulderRIGLb_PRF:SetValue(math.Round(GetConVar( "simple_thirdperson_shoulderview_right" ):GetFloat(),2))
		Editor.PANEL.ShoulderRIGLb_PRF:SetMin( -1000 )
		Editor.PANEL.ShoulderRIGLb_PRF:SetMax( 1000 )
		Editor.PANEL.ShoulderRIGLb_PRF.OnValueChanged  = function()
			RunConsoleCommand("simple_thirdperson_shoulderview_right",Editor.PANEL.ShoulderRIGLb_PRF:GetTextValue())
			Editor.PANEL.ShoulderRIGLb:SetValue(Editor.PANEL.ShoulderRIGLb_PRF:GetTextValue())
		end
		
		
		// ---------------- CROSSHAIR CAMERA ---------------- //
		
		Editor.PANEL.CustomCrossButton = Editor.PANEL.CrossSettings:Add( "DButton" )
		Editor.PANEL.CustomCrossButton:SizeToContents()
		
		if Editor.CustomCrossToggle then
				Editor.PANEL.CustomCrossButton:SetText("Disable Custom Crosshair")
				Editor.PANEL.CustomCrossButton:SetTextColor(Color(150,0,0))
			else
				Editor.PANEL.CustomCrossButton:SetText("Enable Custom Crosshair")
				Editor.PANEL.CustomCrossButton:SetTextColor(Color(0,150,0))
		end		
		
		Editor.PANEL.CustomCrossButton:SetPos(10,6)
		Editor.PANEL.CustomCrossButton:SetSize(250,20)
		Editor.PANEL.CustomCrossButton.DoClick = function()
			Editor.CustomCrossToggle = !Editor.CustomCrossToggle
			RunConsoleCommand("simple_thirdperson_enable_custom_crosshair",BoolToInt(Editor.CustomCrossToggle))
			if Editor.CustomCrossToggle then
				Editor.PANEL.CustomCrossButton:SetText("Disable Custom Crosshair")
				Editor.PANEL.CustomCrossButton:SetTextColor(Color(150,0,0))
			else
				Editor.PANEL.CustomCrossButton:SetText("Enable Custom Crosshair")
				Editor.PANEL.CustomCrossButton:SetTextColor(Color(0,150,0))
			end						
		end
		
		Editor.PANEL.CrossButton = Editor.PANEL.CrossSettings:Add( "DButton" )
		Editor.PANEL.CrossButton:SizeToContents()
		
		if Editor.CrossToggle then
				Editor.PANEL.CrossButton:SetText("Hide Default Crosshair")
				Editor.PANEL.CrossButton:SetTextColor(Color(150,0,0))
		else
				Editor.PANEL.CrossButton:SetText("Show Default Crosshair")
				Editor.PANEL.CrossButton:SetTextColor(Color(0,150,0))
		end	
		
		Editor.PANEL.CrossButton:SetPos(10,30)
		Editor.PANEL.CrossButton:SetSize(250,20)
		Editor.PANEL.CrossButton.DoClick = function()
			Editor.CrossToggle = !Editor.CrossToggle
			RunConsoleCommand("simple_thirdperson_hide_crosshair",BoolToInt(Editor.CrossToggle))	
			if Editor.CrossToggle then
					Editor.PANEL.CrossButton:SetText("Hide Default Crosshair")
					Editor.PANEL.CrossButton:SetTextColor(Color(150,0,0))
			else
					Editor.PANEL.CrossButton:SetText("Show Default Crosshair")
					Editor.PANEL.CrossButton:SetTextColor(Color(0,150,0))
			end						
		end
		
		
		
		Editor.PANEL.RCrossTxt = Editor.PANEL.CrossSettings:Add("DLabel")
		Editor.PANEL.RCrossTxt:SetPos(10,60)
		Editor.PANEL.RCrossTxt:SetText("Red : ")
		Editor.PANEL.RCrossTxt:SizeToContents() 
		
		Editor.PANEL.RCrossTxtLb = Editor.PANEL.CrossSettings:Add("DTextEntry")
		Editor.PANEL.RCrossTxtLb:SetPos(50,55)
		Editor.PANEL.RCrossTxtLb:SetValue(math.abs(GetConVar( "simple_thirdperson_custom_crosshair_r" ):GetInt()))
		Editor.PANEL.RCrossTxtLb:SizeToContents()
		Editor.PANEL.RCrossTxtLb:SetNumeric(true)
		Editor.PANEL.RCrossTxtLb:SetUpdateOnType( true )
		Editor.PANEL.RCrossTxtLb.OnTextChanged  = function()
			local RValue = tonumber(Editor.PANEL.RCrossTxtLb:GetValue())
			if RValue == nil then return end
			local RVal = math.abs(RValue)
			if RVal > 255 then RVal = 255 end
			RunConsoleCommand("simple_thirdperson_custom_crosshair_r",tostring(RVal))
		end
		
		Editor.PANEL.GCrossTxt = Editor.PANEL.CrossSettings:Add("DLabel")
		Editor.PANEL.GCrossTxt:SetPos(120,60)
		Editor.PANEL.GCrossTxt:SetText("| Green : ")
		Editor.PANEL.GCrossTxt:SizeToContents() 
		
		Editor.PANEL.GCrossTxtLb = Editor.PANEL.CrossSettings:Add("DTextEntry")
		Editor.PANEL.GCrossTxtLb:SetPos(170,55)
		Editor.PANEL.GCrossTxtLb:SetValue(math.abs(GetConVar( "simple_thirdperson_custom_crosshair_g" ):GetInt()))
		Editor.PANEL.GCrossTxtLb:SizeToContents()
		Editor.PANEL.GCrossTxtLb:SetNumeric(true)
		Editor.PANEL.GCrossTxtLb:SetUpdateOnType( true )
		Editor.PANEL.GCrossTxtLb.OnTextChanged  = function()
			local GValue = tonumber(Editor.PANEL.GCrossTxtLb:GetValue())
			if GValue == nil then return end
			local GVal = math.abs(GValue)
			if GVal > 255 then GVal = 255 end
			RunConsoleCommand("simple_thirdperson_custom_crosshair_g",tostring(GVal))
		end
		
		Editor.PANEL.BCrossTxt = Editor.PANEL.CrossSettings:Add("DLabel")
		Editor.PANEL.BCrossTxt:SetPos(10,85)
		Editor.PANEL.BCrossTxt:SetText("Blue : ")
		Editor.PANEL.BCrossTxt:SizeToContents() 
		
		Editor.PANEL.BCrossTxtLb = Editor.PANEL.CrossSettings:Add("DTextEntry")
		Editor.PANEL.BCrossTxtLb:SetPos(50,80)
		Editor.PANEL.BCrossTxtLb:SetValue(math.abs(GetConVar( "simple_thirdperson_custom_crosshair_b" ):GetInt()))
		Editor.PANEL.BCrossTxtLb:SizeToContents()
		Editor.PANEL.BCrossTxtLb:SetNumeric(true)
		Editor.PANEL.BCrossTxtLb:SetUpdateOnType( true )
		Editor.PANEL.BCrossTxtLb.OnTextChanged  = function()
			local BValue = tonumber(Editor.PANEL.BCrossTxtLb:GetValue())
			if BValue == nil then return end
			local BVal = math.abs(BValue)
			if BVal > 255 then BVal = 255 end
			RunConsoleCommand("simple_thirdperson_custom_crosshair_b",tostring(BVal))
		end
		
		Editor.PANEL.ACrossTxt = Editor.PANEL.CrossSettings:Add("DLabel")
		Editor.PANEL.ACrossTxt:SetPos(120,85)
		Editor.PANEL.ACrossTxt:SetText("| Alpha : ")
		Editor.PANEL.ACrossTxt:SizeToContents() 
		
		Editor.PANEL.ACrossTxtLb = Editor.PANEL.CrossSettings:Add("DTextEntry")
		Editor.PANEL.ACrossTxtLb:SetPos(170,80)
		Editor.PANEL.ACrossTxtLb:SetValue(math.abs(GetConVar( "simple_thirdperson_custom_crosshair_a" ):GetInt()))
		Editor.PANEL.ACrossTxtLb:SizeToContents()
		Editor.PANEL.ACrossTxtLb:SetNumeric(true)
		Editor.PANEL.ACrossTxtLb:SetUpdateOnType( true )
		Editor.PANEL.ACrossTxtLb.OnTextChanged  = function()
			local AValue = tonumber(Editor.PANEL.ACrossTxtLb:GetValue())
			if AValue == nil then return end
			local AVal = math.abs(AValue)
			if AVal > 255 then AVal = 255 end
			RunConsoleCommand("simple_thirdperson_custom_crosshair_a",tostring(AVal))
		end
		
		
		// ---------------- Credits CAMERA ---------------- //
		Editor.PANEL.CreedTxt = Editor.PANEL.CreditsSettings:Add("DLabel")
		Editor.PANEL.CreedTxt:SetPos(98,80)
		Editor.PANEL.CreedTxt:SetText("By FailCake :D")
		Editor.PANEL.CreedTxt:SizeToContents() 
		
		Editor.PANEL.CreedImg = Editor.PANEL.CreditsSettings:Add("DImageButton")
		Editor.PANEL.CreedImg:SetPos( 100, 10 )
		Editor.PANEL.CreedImg:SetSize( 64, 64 )
		Editor.PANEL.CreedImg:SetImage( "icon32/zoom_extend.png" )
		Editor.PANEL.CreedImg.DoClick = function()
			gui.OpenURL("http://steamcommunity.com/id/edunad")
		end
	end
	
	function ServerBool(cmd_server,cmd_client)
		
		local srv_shoulder = GetConVar(cmd_server):GetInt()
		
		if srv_shoulder == 0 then
			return IntToBool(GetConVar( cmd_client ):GetInt())
		elseif srv_shoulder == 1 then
			return true
		elseif srv_shoulder == 2 then
			return false
		end
	end
	
	function ServerNumber(cmd_server_max,cmd_server_min,cmd_client,default)
	
		local value = default
		
		local SrvMax = GetConVar( cmd_server_max ):GetFloat() or 0
		local SrvMin = GetConVar( cmd_server_min ):GetFloat() or 0
		
		local ClnVal = GetConVar( cmd_client ):GetFloat() or default
		
		if SrvMax != 0 and SrvMin != 0 then
			if SrvMin > SrvMax then return ClnVal end
			
			if ClnVal <= SrvMax and ClnVal >= SrvMin then
				value = ClnVal
			else
				value = SrvMax
			end
		else
			value = ClnVal
		end
		
		return value
	end
	
	function IntToBool(it)
		if it == 1 then
			return true
		else
			return false
		end
	end
	
	function BoolToInt(bol)
		if bol then
			return 1
		else
			return 0
		end
	end
	
	concommand.Add( "simple_thirdperson_shoulder_toggle", function()
		Editor.ShoulderToggle = !Editor.ShoulderToggle
		RunConsoleCommand("simple_thirdperson_shoulderview",BoolToInt(Editor.ShoulderToggle))
	end)
	
	concommand.Add( "simple_thirdperson_crosshair_toggle", function()
		Editor.CrossToggle = !Editor.CrossToggle
		RunConsoleCommand("simple_thirdperson_hide_crosshair",BoolToInt(Editor.CrossToggle))
	end)
	
	concommand.Add( "simple_thirdperson_custom_crosshair_toggle", function()
		Editor.CustomCrossToggle = !Editor.CustomCrossToggle
		RunConsoleCommand("simple_thirdperson_enable_custom_crosshair",BoolToInt(Editor.CustomCrossToggle))
	end)
	
	concommand.Add( "simple_thirdperson_enable_toggle", function()
		Editor.EnableToggle = !Editor.EnableToggle
		RunConsoleCommand("simple_thirdperson_enabled",BoolToInt(Editor.EnableToggle))
	end)
	
	concommand.Add( "stp", function()
		Editor.EnableToggle = !Editor.EnableToggle
		RunConsoleCommand("simple_thirdperson_enabled",BoolToInt(Editor.EnableToggle))
	end)
	
	hook.Add("ShouldDrawLocalPlayer", "SimpleTP.ShouldDraw", function(ply)
		if GetConVar( "simple_thirdperson_enabled" ):GetBool() then
			return true
		end
	end)

	hook.Add("HUDShouldDraw", "SimpleTP.HUDShouldDraw", function(name)
		if GetConVar( "simple_thirdperson_enabled" ):GetBool() and GetConVar( "simple_thirdperson_enable_custom_crosshair" ):GetBool() or GetConVar( "simple_thirdperson_hide_crosshair" ):GetBool() then
			if name == "CHudCrosshair" then
				return false
			end
		end
	end)
	
	hook.Add("HUDPaint", "SimpleTP.HUDPaint", function()
	
		if !GetConVar( "simple_thirdperson_enable_custom_crosshair" ):GetBool() then return end
	
		local ply = LocalPlayer()
		
		local t = {}
		t.start = ply:GetShootPos()
		t.endpos = t.start + ply:GetAimVector() * 9000
		t.filter = ply
		
		local tr = util.TraceLine(t)
		local pos = tr.HitPos:ToScreen()
		
		local dist = (tr.HitPos - t.start):Length()

		if dist < 3500 then
		
			local R = GetConVar( "simple_thirdperson_custom_crosshair_r" ):GetInt()
			local G = GetConVar( "simple_thirdperson_custom_crosshair_g" ):GetInt()
			local B = GetConVar( "simple_thirdperson_custom_crosshair_b" ):GetInt()
			local A = GetConVar( "simple_thirdperson_custom_crosshair_a" ):GetInt()
			surface.SetDrawColor(R, G, B, A)
			
			surface.DrawLine(pos.x - 5, pos.y, pos.x - 8, pos.y)
			surface.DrawLine(pos.x + 5, pos.y, pos.x + 8, pos.y)
	
			surface.DrawLine(pos.x, pos.y - 5, pos.x, pos.y - 8)
			surface.DrawLine(pos.x, pos.y + 5, pos.x, pos.y + 8)
			
		end
		
	end)
	
	hook.Add("CalcView","SimpleTP.Camera.View",function(ply, pos, angles, fov)
		local isEnabled = GetConVar( "simple_thirdperson_enabled" ):GetBool() or false
		
		if isEnabled and IsValid(ply) then
		
			if Editor.DelayPos == nil then
				Editor.DelayPos = ply:EyePos()
			end
			
			if Editor.ViewPos == nil then
				Editor.ViewPos = ply:EyePos()
			end
			

			Editor.DelayFov = fov
			
			local view = {}
		
			local Forward = ServerNumber("simple_thirdperson_maxdistance","simple_thirdperson_mindistance","simple_thirdperson_cam_distance")
			
			local Up = ServerNumber("simple_thirdperson_maxup","simple_thirdperson_minup","simple_thirdperson_cam_up")
			local Right = ServerNumber("simple_thirdperson_maxright","simple_thirdperson_minright","simple_thirdperson_cam_right")
			
			local Pitch = ServerNumber("simple_thirdperson_maxpitch","simple_thirdperson_minpitch","simple_thirdperson_cam_pitch")
			local Yaw = ServerNumber("simple_thirdperson_maxyaw","simple_thirdperson_minyaw","simple_thirdperson_cam_yaw")
			
			if ServerBool("simple_thirdperson_forceshoulder","simple_thirdperson_shoulderview") then
			
				if GetConVar( "simple_thirdperson_shoulderview_bump" ):GetBool() and ply:GetMoveType() != MOVETYPE_NOCLIP then
					angles.pitch = angles.pitch + (ply:GetVelocity():Length() / 300) * math.sin(CurTime() * 10)
					angles.roll = angles.roll + (ply:GetVelocity():Length() / 300) * math.cos(CurTime() * 10)
				end
				
				Forward = ServerNumber("simple_thirdperson_shoulder_maxdist","simple_thirdperson_shoulder_mindist","simple_thirdperson_shoulderview_dist")
				Up = ServerNumber("simple_thirdperson_shoulder_maxup","simple_thirdperson_shoulder_minup","simple_thirdperson_shoulderview_up")
				Right = ServerNumber("simple_thirdperson_shoulder_maxright","simple_thirdperson_shoulder_minright","simple_thirdperson_shoulderview_right")
			else
			
				angles.p = angles.p + Pitch
				angles.y = angles.y + Yaw
			
			end
			
			if ServerBool("simple_thirdperson_forcesmooth","simple_thirdperson_smooth") then
			
				Editor.DelayPos = Editor.DelayPos + (ply:GetVelocity() * (FrameTime() / GetConVar( "simple_thirdperson_smooth_delay" ):GetFloat()))
				Editor.DelayPos.x = math.Approach(Editor.DelayPos.x, pos.x, math.abs(Editor.DelayPos.x - pos.x) * GetConVar( "simple_thirdperson_smooth_mult_x" ):GetFloat())
				Editor.DelayPos.y = math.Approach(Editor.DelayPos.y, pos.y, math.abs(Editor.DelayPos.y - pos.y) * GetConVar( "simple_thirdperson_smooth_mult_y" ):GetFloat())
				Editor.DelayPos.z = math.Approach(Editor.DelayPos.z, pos.z, math.abs(Editor.DelayPos.z - pos.z) * GetConVar( "simple_thirdperson_smooth_mult_z" ):GetFloat())

			else
				Editor.DelayPos = pos
			end
			
			if GetConVar( "simple_thirdperson_fov_smooth" ):GetBool() then
				Editor.DelayFov = Editor.DelayFov + 20
				fov = math.Approach(fov, Editor.DelayFov, math.abs(Editor.DelayFov - fov) * GetConVar( "simple_thirdperson_fov_smooth_mult" ):GetFloat())
			else
				fov = Editor.DelayFov
			end
			
			if ServerBool("simple_thirdperson_forcecollide","simple_thirdperson_collision") then
			
				local traceData = {}
				traceData.start = Editor.DelayPos
				traceData.endpos = traceData.start + angles:Forward() * -Forward
				traceData.endpos = traceData.endpos + angles:Right() * Right
				traceData.endpos = traceData.endpos + angles:Up() * Up
				traceData.filter = ply
				
				local trace = util.TraceLine(traceData)
				
				pos = trace.HitPos
				
				if trace.Fraction < 1.0 then
					pos = pos + trace.HitNormal * 5
				end
				
				view.origin = pos
			else
			
				local View = Editor.DelayPos + ( angles:Forward()* -Forward )
				View = View + ( angles:Right() * Right )
				View = View + ( angles:Up() * Up )
				
				view.origin = View
				
			end

			view.angles = angles
			view.fov = fov
		 
			return view
		end
	end)

	concommand.Add( "simple_thirdperson	_menu",function() BuildMenu(nil) end)
	concommand.Add( "simple_thirdperson_dumpHook",function()
	print("====== Simple ThirdPerson Dump ======")
		for k,v in pairs(hook.GetTable()) do
			if k == "CalcView" or k == "ShouldDrawLocalPlayer" or k == "HUDShouldDraw" then
				print("\n------- ".. k .. " -------\n")
				for k2,v2 in pairs(v) do
					PrintTable(debug.getinfo(v2))
					print("#####--#####")
				end
			end
		end
	print("\n====== +++++++++++++++++++++++ ======")
	end)
	
	print("[SimpleThirdPerson] Addon Loaded")
end
--PATH lua/autorun/turk_addon.lua:
return gluapack()()
--PATH lua/autorun/venator_hdrenabler.lua:

--Created by Mattzi
--Oninoni helped too

if game.GetMap() ~= "rp_venator_extensive_v1_4" then
	return
end

if SERVER then 
	AddCSLuaFile()
end

if CLIENT then
	timer.Simple(5, function()
	local deathstar_mat_hdr_level = GetConVar( "mat_hdr_level" ):GetInt()
		if deathstar_mat_hdr_level < 2 then
			local HDRFrame = vgui.Create("DFrame")
			HDRFrame:SetSize(ScrW()*0.2, ScrH()*0.1)
			HDRFrame:Center()
			HDRFrame:MakePopup()
			HDRFrame:SetTitle("Change HDR Level?")
			HDRFrame:ShowCloseButton(false)
		
			local RichTextHDR = vgui.Create("RichText", HDRFrame)
			RichTextHDR:InsertColorChange(255,70,70,255)
			RichTextHDR:Dock(FILL)
			RichTextHDR:SetVerticalScrollbarEnabled(false)
			RichTextHDR:AppendText("This map only supports HDR. Enable it or live with this horrid mess.")
			function RichTextHDR:PerformLayout()
				self:SetFontInternal( "DermaLarge" )
			end
		
			local acceptbutton = vgui.Create("DButton", HDRFrame)
			acceptbutton:SetText("Activate and reconnect")
			acceptbutton:Dock(BOTTOM)
			acceptbutton.DoClick = function()
				RunConsoleCommand( "mat_hdr_level", "2" )
				timer.Simple( 3, function() RunConsoleCommand( "retry" ) end )
			end
		
			local leavebutton = vgui.Create("DButton", HDRFrame)
			leavebutton:SetText("I dont care")
			leavebutton:Dock(BOTTOM)
			leavebutton.DoClick = function()
				-- RunConsoleCommand("disconnect")
				HDRFrame:Remove()
			end
		end
	end)
end
--PATH lua/autorun/venator_turbolasers.lua:
return gluapack()()
--PATH lua/autorun/venator_visual_alarm.lua:
// Created by Airfox aka. Konsti
// Huge thanks to him!

if game.GetMap() ~= "rp_venator_extensive_v1_4" then return end

-- Set default values (thats why it also resists a lua refresh)
local nextTick = 0

local materialWallLamp = Material("kingpommes/starwars/venator/corridor_wall_lamps")
local materialCorridorLamp = Material("kingpommes/starwars/venator/corridor_lights")
local materialCorridorLampb = Material("kingpommes/starwars/venator/corridor_lightsb")
local materialLightDecal = Material("kingpommes/starwars/venator/lights_decal")

local defaultTextureWallLamp = "kingpommes/starwars/venator/corridor_wall_lamps"
local defaultTextureCorridorLamp = "kingpommes/starwars/venator/corridor_lights"
local defaultTextureCorridorLampb = "kingpommes/starwars/venator/corridor_lightsb"
local defaultTextureLightDecal = "kingpommes/starwars/venator/lights_decal"

local redAlarmTextureWallLamp = "kingpommes/starwars/venator/corridor_wall_lamps_red"
local redAlarmTextureCorridorLamp = "kingpommes/starwars/venator/corridor_lights_red"
local redAlarmTextureCorridorLampb = "kingpommes/starwars/venator/corridor_lightsb_red"
local redAlarmTextureLightDecal = "kingpommes/starwars/venator/lights_decal_red"

local alarmOn = false
local networkSend = false

materialWallLamp:SetTexture("$basetexture", defaultTextureWallLamp)
materialCorridorLamp:SetTexture("$basetexture", defaultTextureCorridorLamp)
materialCorridorLampb:SetTexture("$basetexture", defaultTextureCorridorLampb) 
materialLightDecal:SetTexture("$basetexture", defaultTextureLightDecal)

if SERVER then
	util.AddNetworkString("Venator_Ext_AlarmNet")

	-- Networks current alarm state to every new player that joins the server.
	hook.Add("PlayerInitialSpawn", "Venator_Ext_AlarmConnectSync", function(ply)
		net.Start("Venator_Ext_AlarmNet")
			net.WriteBool(alarmOn)
		net.Send(ply)
	end)
end

function EnableVisualAlarm()
	net.Start("Venator_Ext_AlarmNet")
	net.WriteBool(true)
	net.Broadcast()
	
	alarmOn = true
	networkSend = true
end

function DisableVisualAlarm()
	net.Start("Venator_Ext_AlarmNet")
	net.WriteBool(false)
	net.Broadcast()
	networkSend = false
	alarmOn = false
end

hook.Add("Think", "Venator_Ext_AlarmThink", function()
	if CurTime() > nextTick then
		nextTick = CurTime() + 0.56
		
		-- Checks if alarm is on.
		if CLIENT and alarmOn then
			-- Changes between textured.
			if materialWallLamp:GetTexture("$basetexture"):GetName() == defaultTextureWallLamp then
				materialWallLamp:SetTexture("$basetexture", redAlarmTextureWallLamp)
				materialCorridorLamp:SetTexture("$basetexture", redAlarmTextureCorridorLamp)
				materialCorridorLampb:SetTexture("$basetexture", redAlarmTextureCorridorLampb) 
				materialLightDecal:SetTexture("$basetexture", redAlarmTextureLightDecal)
				
			elseif materialWallLamp:GetTexture("$basetexture"):GetName() == redAlarmTextureWallLamp then
				materialWallLamp:SetTexture("$basetexture", defaultTextureWallLamp)
				materialCorridorLamp:SetTexture("$basetexture", defaultTextureCorridorLamp)
				materialCorridorLampb:SetTexture("$basetexture", defaultTextureCorridorLampb) 
				materialLightDecal:SetTexture("$basetexture", defaultTextureLightDecal)
			end
		elseif CLIENT and not alarmOn then
			-- If the alarm is off and texture is not resetted, reset it.
			if materialWallLamp:GetTexture("$basetexture"):GetName() == redAlarmTextureWallLamp then
				materialWallLamp:SetTexture("$basetexture", defaultTextureWallLamp)
				materialCorridorLamp:SetTexture("$basetexture", defaultTextureCorridorLamp)
				materialCorridorLampb:SetTexture("$basetexture", defaultTextureCorridorLampb) 
				materialLightDecal:SetTexture("$basetexture", defaultTextureLightDecal)
			end
		end
	end
end)

hook.Add("PostCleanupMap", "Venator_Ext_AlarmCleanup", function()
	alarmOn = false
end)

if CLIENT then
	-- Receives current alarm state.
	net.Receive("Venator_Ext_AlarmNet", function(len)
		alarmOn = net.ReadBool()
	end)
end
--PATH lua/autorun/vj_controls.lua:
/*--------------------------------------------------
	=============== VJ Controls ===============
	*** Copyright (c) 2012-2023 by DrVrej, All rights reserved. ***
	No parts of this code or any of its contents may be reproduced, copied, modified or adapted,
	without the prior written consent of the author, unless otherwise indicated for stand-alone materials.
--------------------------------------------------*/
if (!file.Exists("autorun/vj_base_autorun.lua","LUA")) then return end

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------ VJ Spawnmenu Controls ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
local killIconColor = Color(255, 80, 0, 255)

if !VJ then VJ = {} end -- If VJ isn't initialized, initialize it!

-- Variables ----------------------------------------------------------------------------------------------------
if !VJ.Plugins then VJ.Plugins = {} end
---------------------------------------------------------------------------------------------------------------------------------------------
--[[---------------------------------------------------------
	Registers the addon to the VJ plugin list
		- name = Addon name
		- type = Type of addon | EX: NPC, Weapon, etc.
-----------------------------------------------------------]]
VJ.AddAddonProperty = function(name, type)
	table.insert(VJ.Plugins, {Name = name, Type = type})
end
---------------------------------------------------------------------------------------------------------------------------------------------
--[[---------------------------------------------------------
	Registers spawn menu category information
		- name = Category name
		- options = Table that holds all possible options
			- Icon = Category icon
-----------------------------------------------------------]]
VJ.AddCategoryInfo = function(category, options)
	list.Set("VJBASE_CATEGORY_INFO", category, {
		icon = options.Icon or "icon16/monkey.png",
	})
end
---------------------------------------------------------------------------------------------------------------------------------------------
--[[---------------------------------------------------------
	Adds an NPC to the spawn menu
		- name = NPC's name
		- class = NPC's class
		- category = The spawn menu category it should be in
		- adminOnly = Is this an admin only NPC?
		- customFunc(property) = Used to apply more options (Located in GMod's source code) | EX: OnCeiling, Offset, etc.
-----------------------------------------------------------]]
VJ.AddNPC = function(name, class, category, adminOnly, customFunc)
	local property = {Name = name, Class = class, Category = category, AdminOnly = adminOnly}
	if (customFunc) then customFunc(property) end
	list.Set("NPC", class, property)
	list.Set("VJBASE_SPAWNABLE_NPC", class, property)
	if CLIENT then
		language.Add(class, name)
		killicon.Add(class, "HUD/killicons/default", killIconColor)
		language.Add("#" .. class, name)
		killicon.Add("#" .. class, "HUD/killicons/default", killIconColor)
	end
end
---------------------------------------------------------------------------------------------------------------------------------------------
--[[---------------------------------------------------------
	Adds a human NPC to the spawn menu
		- name = NPC's name
		- class = NPC's class
		- weapons = Default weapon list for this NPC
		- category = The spawn menu category it should be in
		- adminOnly = Is this an admin only NPC?
		- customFunc(property) = Used to apply more options (Located in GMod's source code) | EX: OnCeiling, Offset, etc.
-----------------------------------------------------------]]
VJ.AddNPC_HUMAN = function(name, class, weapons, category, adminOnly, customFunc)
	local property = {Name = name, Class = class, Weapons = weapons, Category = category, AdminOnly = adminOnly}
	if (customFunc) then customFunc(property) end
	list.Set("NPC", class, property)
	list.Set("VJBASE_SPAWNABLE_NPC", class, property)
	if CLIENT then
		language.Add(class, name)
		killicon.Add(class, "HUD/killicons/default", killIconColor)
		language.Add("#" .. class, name)
		killicon.Add("#" .. class, "HUD/killicons/default", killIconColor)
	end
end
---------------------------------------------------------------------------------------------------------------------------------------------
--[[---------------------------------------------------------
	Adds a weapon to the NPC weapon override list
		- name = Weapon's name
		- class = Weapon's class
		- category = The category group it should be in
-----------------------------------------------------------]]
VJ.AddNPCWeapon = function(name, class, category)
	local property = {title = name, class = class, category = category or "VJ Base"}
	list.Add("NPCUsableWeapons", property)
	list.Add("VJBASE_SPAWNABLE_NPC_WEAPON", property)
end
---------------------------------------------------------------------------------------------------------------------------------------------
--[[---------------------------------------------------------
	Adds a weapon to the weapon spawn list
		- name = Weapon's name
		- class = Weapon's class
		- adminOnly = Is this an admin only weapon?
		- category = The spawn menu category it should be in
		- customFunc(property) = Used to apply more options (Located in GMod's source code)
-----------------------------------------------------------]]
VJ.AddWeapon = function(name, class, adminOnly, category, customFunc)
	local property = {PrintName = name, ClassName = class, Category = category, AdminOnly = adminOnly, Spawnable = true}
	if (customFunc) then customFunc(property) end
	list.Set("Weapon", class, property)
	list.Set("VJBASE_SPAWNABLE_WEAPON", class, property)
	duplicator.Allow(class)
end
---------------------------------------------------------------------------------------------------------------------------------------------
--[[---------------------------------------------------------
	Adds an entity to the weapon spawn list
		- name = Entity's name
		- class = Entity's class
		- author = Author's name
		- adminOnly = Is this an admin only entity?
		- offset = Spawn offset
		- dropToFloor = Should it drop to the floor on spawn?
		- category = The spawn menu category it should be in
		- customFunc(property) = Used to apply more options (Located in GMod's source code)
-----------------------------------------------------------]]
VJ.AddEntity = function(name, class, author, adminOnly, offset, dropToFloor, category, customFunc)
	local Ent = {PrintName = name, ClassName = class, Author = author, AdminOnly = adminOnly, NormalOffset = offset, DropToFloor = dropToFloor, Category = category, Spawnable = true}
	if (customFunc) then customFunc(Ent) end
	list.Set("SpawnableEntities", class, Ent)
	list.Set("VJBASE_SPAWNABLE_ENTITIES", class, Ent)
	duplicator.Allow(class)
end
---------------------------------------------------------------------------------------------------------------------------------------------
--[[---------------------------------------------------------
	Adds and registers a particle file
		- fileName = Addon name | EX: "particles/explosion.pcf"
		- particleList = List of particles to precache from the given particle file
-----------------------------------------------------------]]
VJ.AddParticle = function(fileName, particleList)
	game.AddParticles(fileName)
	for _, name in ipairs(particleList) do
		PrecacheParticleSystem(name)
	end
end
---------------------------------------------------------------------------------------------------------------------------------------------
--[[---------------------------------------------------------
	Registers a ConVar
		- name = Convar name
		- defValue = Default value
		- flags = Convar's flags | Can be a bitflag or a table | Flag List: https://wiki.facepunch.com/gmod/Enums/FCVAR
		- helpText = Help text to display in the console
		- min = If set, the ConVar cannot be changed to a number lower than this value
		- max = If set, the ConVar cannot be changed to a number higher than this value
-----------------------------------------------------------]]
VJ.AddConVar = function(name, defValue, flags, helpText, min, max)
	if !ConVarExists(name) then
		CreateConVar(name, defValue, flags or FCVAR_NONE, helpText or "", min, max)
	end
end
---------------------------------------------------------------------------------------------------------------------------------------------
--[[---------------------------------------------------------
	Registers a client ConVar
		- name = ConVar name
		- defValue = Default value
		- helpText = Help text to display in the console
		- min = If set, the ConVar cannot be changed to a number lower than this value
		- max = If set, the ConVar cannot be changed to a number higher than this value
-----------------------------------------------------------]]
VJ.AddClientConVar = function(name, defValue, helpText, min, max)
	if !ConVarExists(name) then
		CreateClientConVar(name, defValue, true, true, helpText or "", min, max)
	end
end

/*
if CLIENT then
local gmod_npcweapon = CreateConVar("gmod_npcweapon","",{FCVAR_ARCHIVE})
spawnmenu.AddContentType( "vjbase_npc", function( container, obj )
	if ( !obj.material ) then return end
	if ( !obj.nicename ) then return end
	if ( !obj.spawnname ) then return end
	if ( !obj.weapon ) then obj.weapon = { "" } end
	local icon = vgui.Create( "ContentIcon", container )
		icon:SetContentType( "vjbase_npc" )
		icon:SetSpawnName( obj.spawnname )
		icon:SetName( obj.nicename )
		icon:SetMaterial( obj.material )
		icon:SetAdminOnly( obj.admin )
		icon:SetNPCWeapon( obj.weapon )
		icon:SetColor(Color(244,164,96,255))
		icon.DoClick = function() 
			local weapon = table.Random( obj.weapon )
			if ( gmod_npcweapon:GetString() != "" ) then weapon = gmod_npcweapon:GetString() end
			RunConsoleCommand( "vjbase_spawnnpc", obj.spawnname, weapon ) 
			surface.PlaySound( "ui/buttonclickrelease.wav" )
		end
		icon.OpenMenu = function( icon ) 
			local menu = DermaMenu()
			local weapon = table.Random( obj.weapon )
			if ( gmod_npcweapon:GetString() != "" ) then weapon = gmod_npcweapon:GetString() end
			menu:AddOption( "Copy to Clipboard", function() SetClipboardText( obj.spawnname ) end )
			menu:AddOption( "Spawn Using Toolgun", function() RunConsoleCommand( "gmod_tool", "creator" ) RunConsoleCommand( "creator_type", "2" ) RunConsoleCommand( "creator_name", obj.spawnname ) RunConsoleCommand( "creator_arg", weapon ) end )
			menu:AddSpacer()
			menu:AddOption( "Delete", function() icon:Remove() hook.Run( "SpawnlistContentChanged", icon ) end )
			menu:Open()
		end
	if (IsValid(container)) then
		container:Add(icon)
	end
	return icon
end)
-------------------------------------------------------------------------------------------------------------------------
hook.Add("PopulateVJBaseWeapons","AddVJBaseSpawnMenu_weapon",function(pnlContent,tree,node)
	local weapontree = tree:AddNode("Weapons", "icon16/gun.png")
	local Weapons = list.Get("VJBASE_SPAWNABLE_WEAPON")  -- Get a list of available Weapons
	local WeaponCatagory = {}
	for k, weapon in pairs( Weapons ) do
		if ( !weapon.Spawnable ) then continue end
		WeaponCatagory[ weapon.Category ] = WeaponCatagory[ weapon.Category ] or {}
		table.insert( WeaponCatagory[ weapon.Category ], weapon )
	end
	Weapons = nil
	for CategoryName, v in SortedPairs(WeaponCatagory) do -- Create an icon for each one and put them on the panel
		local node = weapontree:AddNode(CategoryName,"icon16/page_white_go.png") -- Add a node to the tree
		node.DoPopulate = function(self) -- When we click on the node - populate it using this function
			if ( self.PropPanel ) then return end -- If we've already populated it - forget it.
			self.PropPanel = vgui.Create("ContentContainer", pnlContent) -- Create the container panel
			self.PropPanel:SetVisible( false )
			self.PropPanel:SetTriggerSpawnlistChange( false )
			for k, ent in SortedPairsByMemberValue( v, "PrintName" ) do
				spawnmenu.CreateContentIcon( ent.ScriptedEntityType or "weapon", self.PropPanel, 
				{ 
					nicename	= ent.PrintName or ent.ClassName,
					spawnname	= ent.ClassName,
					material	= "entities/"..ent.ClassName..".png",
					admin		= ent.AdminOnly
				})
			end
		end
		node.DoClick = function(self) -- If we click on the node populate it and switch to it.
			self:DoPopulate()		
			pnlContent:SwitchPanel( self.PropPanel );
		end
	end
	//local FirstNode = tree:Root():GetChildNode(0) -- Select the first node
	//if ( IsValid( FirstNode ) ) then
		//FirstNode:InternalDoClick()
	//end
	weapontree:SetExpanded(true)
end)
-------------------------------------------------------------------------------------------------------------------------
hook.Add("PopulateVJBaseEntities","AddVJBaseSpawnMenu_Entity",function(pnlContent,tree,node)
	local entitytree = tree:AddNode("Entities", "icon16/bricks.png")
	local EntitiesCategories = {}
	local EntitiesList = list.Get("VJBASE_SPAWNABLE_ENTITIES") -- Get a list of available Entities
	if (EntitiesList) then
		for k, v in pairs(EntitiesList) do
			v.SpawnName = k
			v.Category = v.Category or "Other"
			EntitiesCategories[ v.Category ] = EntitiesCategories[ v.Category ] or {}
			table.insert( EntitiesCategories[ v.Category ], v )
		end
	end
	for CategoryName, v in SortedPairs(EntitiesCategories) do -- Create an icon for each one and put them on the panel
		local node = entitytree:AddNode(CategoryName,"icon16/page_white_go.png") -- Add a node to the tree
		node.DoPopulate = function(self) -- When we click on the node - populate it using this function
			if ( self.PropPanel ) then return end -- If we've already populated it - forget it.
			self.PropPanel = vgui.Create("ContentContainer", pnlContent) -- Create the container panel
			self.PropPanel:SetVisible( false )
			self.PropPanel:SetTriggerSpawnlistChange( false )
			for k, ent in SortedPairsByMemberValue( v, "PrintName" ) do
				spawnmenu.CreateContentIcon( ent.ScriptedEntityType or "entity", self.PropPanel, 
				{ 
					nicename	= ent.PrintName or ent.ClassName,
					spawnname	= ent.SpawnName,
					material	= "entities/"..ent.SpawnName..".png",
					admin		= ent.AdminOnly
				})
			end
		end
		node.DoClick = function(self) -- If we click on the node populate it and switch to it.
			self:DoPopulate()		
			pnlContent:SwitchPanel( self.PropPanel );
		end
	end
	//local FirstNode = tree:Root():GetChildNode(0) -- Select the first node
	//if ( IsValid( FirstNode ) ) then
		//FirstNode:InternalDoClick()
	//end
	entitytree:SetExpanded(true)
end)
-------------------------------------------------------------------------------------------------------------------------
hook.Add("PopulateVJBaseNPC","AddVJBaseSpawnMenu_NPC",function(pnlContent,tree,node)
	local npctree = tree:AddNode("NPCs", "icon16/monkey.png")
	local NPCList = list.Get("VJBASE_SPAWNABLE_NPC") -- Get a list of available NPCs
	local NPCCategories = {} -- Categorize them
	for k, v in pairs(NPCList) do
		local Category = v.Category or "Other"
		local Tab = NPCCategories[Category] or {}
		Tab[ k ] = v
		NPCCategories[Category] = Tab
	end
	for CategoryName, v in SortedPairs(NPCCategories) do -- Create an icon for each one and put them on the panel
		local node = npctree:AddNode(CategoryName,"icon16/page_white_go.png") -- Add a node to the tree
		node.DoPopulate = function(self) -- When we click on the node - populate it using this function
			if ( self.PropPanel ) then return end -- If we've already populated it - forget it.
			self.PropPanel = vgui.Create("ContentContainer", pnlContent) -- Create the container panel
			self.PropPanel:SetVisible( false )
			self.PropPanel:SetTriggerSpawnlistChange( false )
			for name, ent in SortedPairsByMemberValue( v, "Name" ) do
				spawnmenu.CreateContentIcon( "vjbase_npc", self.PropPanel, 
				{ 
					nicename	= ent.Name or name,
					spawnname	= name,
					material	= "entities/"..name..".png",
					weapon		= ent.Weapons,
					admin		= ent.AdminOnly
				})
			end
		end
		node.DoClick = function(self) -- If we click on the node populate it and switch to it.
			self:DoPopulate()		
			pnlContent:SwitchPanel(self.PropPanel)
		end	
	end
	//local FirstNode = tree:Root():GetChildNode(0) -- Select the first node
	//if (IsValid(FirstNode)) then
		//FirstNode:InternalDoClick()
	//end
	npctree:SetExpanded(true)
end)
-------------------------------------------------------------------------------------------------------------------------
spawnmenu.AddCreationTab("VJ Base",function()
	local ctrl = vgui.Create("SpawnmenuContentPanel")
	ctrl:CallPopulateHook("PopulateVJBaseWeapons")
	ctrl:CallPopulateHook("PopulateVJBaseEntities")
	ctrl:CallPopulateHook("PopulateVJBaseNPC")
	return ctrl
end, "icon16/plugin.png", 60 )
*/
--PATH lua/autorun/vj_controls.lua:
/*--------------------------------------------------
	=============== VJ Controls ===============
	*** Copyright (c) 2012-2023 by DrVrej, All rights reserved. ***
	No parts of this code or any of its contents may be reproduced, copied, modified or adapted,
	without the prior written consent of the author, unless otherwise indicated for stand-alone materials.
--------------------------------------------------*/
if (!file.Exists("autorun/vj_base_autorun.lua","LUA")) then return end

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------ VJ Spawnmenu Controls ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
local killIconColor = Color(255, 80, 0, 255)

if !VJ then VJ = {} end -- If VJ isn't initialized, initialize it!

-- Variables ----------------------------------------------------------------------------------------------------
if !VJ.Plugins then VJ.Plugins = {} end
---------------------------------------------------------------------------------------------------------------------------------------------
--[[---------------------------------------------------------
	Registers the addon to the VJ plugin list
		- name = Addon name
		- type = Type of addon | EX: NPC, Weapon, etc.
-----------------------------------------------------------]]
VJ.AddAddonProperty = function(name, type)
	table.insert(VJ.Plugins, {Name = name, Type = type})
end
---------------------------------------------------------------------------------------------------------------------------------------------
--[[---------------------------------------------------------
	Registers spawn menu category information
		- name = Category name
		- options = Table that holds all possible options
			- Icon = Category icon
-----------------------------------------------------------]]
VJ.AddCategoryInfo = function(category, options)
	list.Set("VJBASE_CATEGORY_INFO", category, {
		icon = options.Icon or "icon16/monkey.png",
	})
end
---------------------------------------------------------------------------------------------------------------------------------------------
--[[---------------------------------------------------------
	Adds an NPC to the spawn menu
		- name = NPC's name
		- class = NPC's class
		- category = The spawn menu category it should be in
		- adminOnly = Is this an admin only NPC?
		- customFunc(property) = Used to apply more options (Located in GMod's source code) | EX: OnCeiling, Offset, etc.
-----------------------------------------------------------]]
VJ.AddNPC = function(name, class, category, adminOnly, customFunc)
	local property = {Name = name, Class = class, Category = category, AdminOnly = adminOnly}
	if (customFunc) then customFunc(property) end
	list.Set("NPC", class, property)
	list.Set("VJBASE_SPAWNABLE_NPC", class, property)
	if CLIENT then
		language.Add(class, name)
		killicon.Add(class, "HUD/killicons/default", killIconColor)
		language.Add("#" .. class, name)
		killicon.Add("#" .. class, "HUD/killicons/default", killIconColor)
	end
end
---------------------------------------------------------------------------------------------------------------------------------------------
--[[---------------------------------------------------------
	Adds a human NPC to the spawn menu
		- name = NPC's name
		- class = NPC's class
		- weapons = Default weapon list for this NPC
		- category = The spawn menu category it should be in
		- adminOnly = Is this an admin only NPC?
		- customFunc(property) = Used to apply more options (Located in GMod's source code) | EX: OnCeiling, Offset, etc.
-----------------------------------------------------------]]
VJ.AddNPC_HUMAN = function(name, class, weapons, category, adminOnly, customFunc)
	local property = {Name = name, Class = class, Weapons = weapons, Category = category, AdminOnly = adminOnly}
	if (customFunc) then customFunc(property) end
	list.Set("NPC", class, property)
	list.Set("VJBASE_SPAWNABLE_NPC", class, property)
	if CLIENT then
		language.Add(class, name)
		killicon.Add(class, "HUD/killicons/default", killIconColor)
		language.Add("#" .. class, name)
		killicon.Add("#" .. class, "HUD/killicons/default", killIconColor)
	end
end
---------------------------------------------------------------------------------------------------------------------------------------------
--[[---------------------------------------------------------
	Adds a weapon to the NPC weapon override list
		- name = Weapon's name
		- class = Weapon's class
		- category = The category group it should be in
-----------------------------------------------------------]]
VJ.AddNPCWeapon = function(name, class, category)
	local property = {title = name, class = class, category = category or "VJ Base"}
	list.Add("NPCUsableWeapons", property)
	list.Add("VJBASE_SPAWNABLE_NPC_WEAPON", property)
end
---------------------------------------------------------------------------------------------------------------------------------------------
--[[---------------------------------------------------------
	Adds a weapon to the weapon spawn list
		- name = Weapon's name
		- class = Weapon's class
		- adminOnly = Is this an admin only weapon?
		- category = The spawn menu category it should be in
		- customFunc(property) = Used to apply more options (Located in GMod's source code)
-----------------------------------------------------------]]
VJ.AddWeapon = function(name, class, adminOnly, category, customFunc)
	local property = {PrintName = name, ClassName = class, Category = category, AdminOnly = adminOnly, Spawnable = true}
	if (customFunc) then customFunc(property) end
	list.Set("Weapon", class, property)
	list.Set("VJBASE_SPAWNABLE_WEAPON", class, property)
	duplicator.Allow(class)
end
---------------------------------------------------------------------------------------------------------------------------------------------
--[[---------------------------------------------------------
	Adds an entity to the weapon spawn list
		- name = Entity's name
		- class = Entity's class
		- author = Author's name
		- adminOnly = Is this an admin only entity?
		- offset = Spawn offset
		- dropToFloor = Should it drop to the floor on spawn?
		- category = The spawn menu category it should be in
		- customFunc(property) = Used to apply more options (Located in GMod's source code)
-----------------------------------------------------------]]
VJ.AddEntity = function(name, class, author, adminOnly, offset, dropToFloor, category, customFunc)
	local Ent = {PrintName = name, ClassName = class, Author = author, AdminOnly = adminOnly, NormalOffset = offset, DropToFloor = dropToFloor, Category = category, Spawnable = true}
	if (customFunc) then customFunc(Ent) end
	list.Set("SpawnableEntities", class, Ent)
	list.Set("VJBASE_SPAWNABLE_ENTITIES", class, Ent)
	duplicator.Allow(class)
end
---------------------------------------------------------------------------------------------------------------------------------------------
--[[---------------------------------------------------------
	Adds and registers a particle file
		- fileName = Addon name | EX: "particles/explosion.pcf"
		- particleList = List of particles to precache from the given particle file
-----------------------------------------------------------]]
VJ.AddParticle = function(fileName, particleList)
	game.AddParticles(fileName)
	for _, name in ipairs(particleList) do
		PrecacheParticleSystem(name)
	end
end
---------------------------------------------------------------------------------------------------------------------------------------------
--[[---------------------------------------------------------
	Registers a ConVar
		- name = Convar name
		- defValue = Default value
		- flags = Convar's flags | Can be a bitflag or a table | Flag List: https://wiki.facepunch.com/gmod/Enums/FCVAR
		- helpText = Help text to display in the console
		- min = If set, the ConVar cannot be changed to a number lower than this value
		- max = If set, the ConVar cannot be changed to a number higher than this value
-----------------------------------------------------------]]
VJ.AddConVar = function(name, defValue, flags, helpText, min, max)
	if !ConVarExists(name) then
		CreateConVar(name, defValue, flags or FCVAR_NONE, helpText or "", min, max)
	end
end
---------------------------------------------------------------------------------------------------------------------------------------------
--[[---------------------------------------------------------
	Registers a client ConVar
		- name = ConVar name
		- defValue = Default value
		- helpText = Help text to display in the console
		- min = If set, the ConVar cannot be changed to a number lower than this value
		- max = If set, the ConVar cannot be changed to a number higher than this value
-----------------------------------------------------------]]
VJ.AddClientConVar = function(name, defValue, helpText, min, max)
	if !ConVarExists(name) then
		CreateClientConVar(name, defValue, true, true, helpText or "", min, max)
	end
end

/*
if CLIENT then
local gmod_npcweapon = CreateConVar("gmod_npcweapon","",{FCVAR_ARCHIVE})
spawnmenu.AddContentType( "vjbase_npc", function( container, obj )
	if ( !obj.material ) then return end
	if ( !obj.nicename ) then return end
	if ( !obj.spawnname ) then return end
	if ( !obj.weapon ) then obj.weapon = { "" } end
	local icon = vgui.Create( "ContentIcon", container )
		icon:SetContentType( "vjbase_npc" )
		icon:SetSpawnName( obj.spawnname )
		icon:SetName( obj.nicename )
		icon:SetMaterial( obj.material )
		icon:SetAdminOnly( obj.admin )
		icon:SetNPCWeapon( obj.weapon )
		icon:SetColor(Color(244,164,96,255))
		icon.DoClick = function() 
			local weapon = table.Random( obj.weapon )
			if ( gmod_npcweapon:GetString() != "" ) then weapon = gmod_npcweapon:GetString() end
			RunConsoleCommand( "vjbase_spawnnpc", obj.spawnname, weapon ) 
			surface.PlaySound( "ui/buttonclickrelease.wav" )
		end
		icon.OpenMenu = function( icon ) 
			local menu = DermaMenu()
			local weapon = table.Random( obj.weapon )
			if ( gmod_npcweapon:GetString() != "" ) then weapon = gmod_npcweapon:GetString() end
			menu:AddOption( "Copy to Clipboard", function() SetClipboardText( obj.spawnname ) end )
			menu:AddOption( "Spawn Using Toolgun", function() RunConsoleCommand( "gmod_tool", "creator" ) RunConsoleCommand( "creator_type", "2" ) RunConsoleCommand( "creator_name", obj.spawnname ) RunConsoleCommand( "creator_arg", weapon ) end )
			menu:AddSpacer()
			menu:AddOption( "Delete", function() icon:Remove() hook.Run( "SpawnlistContentChanged", icon ) end )
			menu:Open()
		end
	if (IsValid(container)) then
		container:Add(icon)
	end
	return icon
end)
-------------------------------------------------------------------------------------------------------------------------
hook.Add("PopulateVJBaseWeapons","AddVJBaseSpawnMenu_weapon",function(pnlContent,tree,node)
	local weapontree = tree:AddNode("Weapons", "icon16/gun.png")
	local Weapons = list.Get("VJBASE_SPAWNABLE_WEAPON")  -- Get a list of available Weapons
	local WeaponCatagory = {}
	for k, weapon in pairs( Weapons ) do
		if ( !weapon.Spawnable ) then continue end
		WeaponCatagory[ weapon.Category ] = WeaponCatagory[ weapon.Category ] or {}
		table.insert( WeaponCatagory[ weapon.Category ], weapon )
	end
	Weapons = nil
	for CategoryName, v in SortedPairs(WeaponCatagory) do -- Create an icon for each one and put them on the panel
		local node = weapontree:AddNode(CategoryName,"icon16/page_white_go.png") -- Add a node to the tree
		node.DoPopulate = function(self) -- When we click on the node - populate it using this function
			if ( self.PropPanel ) then return end -- If we've already populated it - forget it.
			self.PropPanel = vgui.Create("ContentContainer", pnlContent) -- Create the container panel
			self.PropPanel:SetVisible( false )
			self.PropPanel:SetTriggerSpawnlistChange( false )
			for k, ent in SortedPairsByMemberValue( v, "PrintName" ) do
				spawnmenu.CreateContentIcon( ent.ScriptedEntityType or "weapon", self.PropPanel, 
				{ 
					nicename	= ent.PrintName or ent.ClassName,
					spawnname	= ent.ClassName,
					material	= "entities/"..ent.ClassName..".png",
					admin		= ent.AdminOnly
				})
			end
		end
		node.DoClick = function(self) -- If we click on the node populate it and switch to it.
			self:DoPopulate()		
			pnlContent:SwitchPanel( self.PropPanel );
		end
	end
	//local FirstNode = tree:Root():GetChildNode(0) -- Select the first node
	//if ( IsValid( FirstNode ) ) then
		//FirstNode:InternalDoClick()
	//end
	weapontree:SetExpanded(true)
end)
-------------------------------------------------------------------------------------------------------------------------
hook.Add("PopulateVJBaseEntities","AddVJBaseSpawnMenu_Entity",function(pnlContent,tree,node)
	local entitytree = tree:AddNode("Entities", "icon16/bricks.png")
	local EntitiesCategories = {}
	local EntitiesList = list.Get("VJBASE_SPAWNABLE_ENTITIES") -- Get a list of available Entities
	if (EntitiesList) then
		for k, v in pairs(EntitiesList) do
			v.SpawnName = k
			v.Category = v.Category or "Other"
			EntitiesCategories[ v.Category ] = EntitiesCategories[ v.Category ] or {}
			table.insert( EntitiesCategories[ v.Category ], v )
		end
	end
	for CategoryName, v in SortedPairs(EntitiesCategories) do -- Create an icon for each one and put them on the panel
		local node = entitytree:AddNode(CategoryName,"icon16/page_white_go.png") -- Add a node to the tree
		node.DoPopulate = function(self) -- When we click on the node - populate it using this function
			if ( self.PropPanel ) then return end -- If we've already populated it - forget it.
			self.PropPanel = vgui.Create("ContentContainer", pnlContent) -- Create the container panel
			self.PropPanel:SetVisible( false )
			self.PropPanel:SetTriggerSpawnlistChange( false )
			for k, ent in SortedPairsByMemberValue( v, "PrintName" ) do
				spawnmenu.CreateContentIcon( ent.ScriptedEntityType or "entity", self.PropPanel, 
				{ 
					nicename	= ent.PrintName or ent.ClassName,
					spawnname	= ent.SpawnName,
					material	= "entities/"..ent.SpawnName..".png",
					admin		= ent.AdminOnly
				})
			end
		end
		node.DoClick = function(self) -- If we click on the node populate it and switch to it.
			self:DoPopulate()		
			pnlContent:SwitchPanel( self.PropPanel );
		end
	end
	//local FirstNode = tree:Root():GetChildNode(0) -- Select the first node
	//if ( IsValid( FirstNode ) ) then
		//FirstNode:InternalDoClick()
	//end
	entitytree:SetExpanded(true)
end)
-------------------------------------------------------------------------------------------------------------------------
hook.Add("PopulateVJBaseNPC","AddVJBaseSpawnMenu_NPC",function(pnlContent,tree,node)
	local npctree = tree:AddNode("NPCs", "icon16/monkey.png")
	local NPCList = list.Get("VJBASE_SPAWNABLE_NPC") -- Get a list of available NPCs
	local NPCCategories = {} -- Categorize them
	for k, v in pairs(NPCList) do
		local Category = v.Category or "Other"
		local Tab = NPCCategories[Category] or {}
		Tab[ k ] = v
		NPCCategories[Category] = Tab
	end
	for CategoryName, v in SortedPairs(NPCCategories) do -- Create an icon for each one and put them on the panel
		local node = npctree:AddNode(CategoryName,"icon16/page_white_go.png") -- Add a node to the tree
		node.DoPopulate = function(self) -- When we click on the node - populate it using this function
			if ( self.PropPanel ) then return end -- If we've already populated it - forget it.
			self.PropPanel = vgui.Create("ContentContainer", pnlContent) -- Create the container panel
			self.PropPanel:SetVisible( false )
			self.PropPanel:SetTriggerSpawnlistChange( false )
			for name, ent in SortedPairsByMemberValue( v, "Name" ) do
				spawnmenu.CreateContentIcon( "vjbase_npc", self.PropPanel, 
				{ 
					nicename	= ent.Name or name,
					spawnname	= name,
					material	= "entities/"..name..".png",
					weapon		= ent.Weapons,
					admin		= ent.AdminOnly
				})
			end
		end
		node.DoClick = function(self) -- If we click on the node populate it and switch to it.
			self:DoPopulate()		
			pnlContent:SwitchPanel(self.PropPanel)
		end	
	end
	//local FirstNode = tree:Root():GetChildNode(0) -- Select the first node
	//if (IsValid(FirstNode)) then
		//FirstNode:InternalDoClick()
	//end
	npctree:SetExpanded(true)
end)
-------------------------------------------------------------------------------------------------------------------------
spawnmenu.AddCreationTab("VJ Base",function()
	local ctrl = vgui.Create("SpawnmenuContentPanel")
	ctrl:CallPopulateHook("PopulateVJBaseWeapons")
	ctrl:CallPopulateHook("PopulateVJBaseEntities")
	ctrl:CallPopulateHook("PopulateVJBaseNPC")
	return ctrl
end, "icon16/plugin.png", 60 )
*/
--PATH lua/autorun/vj_menu_main.lua:
return gluapack()()
--PATH lua/autorun/vj_menu_spawninfo.lua:
return gluapack()()
--PATH lua/autorun/vj_sbd_autorun.lua:
return gluapack()()
--PATH addons/[fix] wiltos_animation_fix/lua/wos/anim_extension/extensions/wos_dod.lua:
return gluapack()()
--PATH addons/[fix] wiltos_animation_fix/lua/wos/anim_extension/extensions/wos_exp.lua:
-- "addons\\wosanim_fixes\\lua\\wos\\anim_extension\\extensions\\wos_exp.lua"
-- Retrieved by https://github.com/lewisclark/glua-steal
--[[-------------------------------------------------------------------
	wiltOS Animation Extension Register:
		Prints some feedback saying the Animation Extension successfully loaded.
			Powered by
						  _ _ _    ___  ____  
				__      _(_) | |_ / _ \/ ___| 
				\ \ /\ / / | | __| | | \___ \ 
				 \ V  V /| | | |_| |_| |___) |
				  \_/\_/ |_|_|\__|\___/|____/ 
											  
 _____         _                 _             _           
|_   _|__  ___| |__  _ __   ___ | | ___   __ _(_) ___  ___ 
  | |/ _ \/ __| '_ \| '_ \ / _ \| |/ _ \ / _` | |/ _ \/ __|
  | |  __/ (__| | | | | | | (_) | | (_) | (_| | |  __/\__ \
  |_|\___|\___|_| |_|_| |_|\___/|_|\___/ \__, |_|\___||___/
                                         |___/             
-------------------------------------------------------------------]]--[[
							  
	Lua Developer: King David
	Contact: http://steamcommunity.com/groups/wiltostech
		
----------------------------------------]]--

wOS.AnimExtension.Mounted[ "Experimental" ] = true
MsgC( Color( 255, 255, 255 ), "[wOS] Successfully mounted animation extension: Experimental\n" )
--PATH addons/[fix] wiltos_animation_fix/lua/wos/anim_extension/extensions/wos_l4d.lua:
-- "addons\\wosanim_fixes\\lua\\wos\\anim_extension\\extensions\\wos_l4d.lua"
-- Retrieved by https://github.com/lewisclark/glua-steal
--[[-------------------------------------------------------------------
	wiltOS Animation Extension Register:
		Prints some feedback saying the Animation Extension successfully loaded.
			Powered by
						  _ _ _    ___  ____  
				__      _(_) | |_ / _ \/ ___| 
				\ \ /\ / / | | __| | | \___ \ 
				 \ V  V /| | | |_| |_| |___) |
				  \_/\_/ |_|_|\__|\___/|____/ 
											  
 _____         _                 _             _           
|_   _|__  ___| |__  _ __   ___ | | ___   __ _(_) ___  ___ 
  | |/ _ \/ __| '_ \| '_ \ / _ \| |/ _ \ / _` | |/ _ \/ __|
  | |  __/ (__| | | | | | | (_) | | (_) | (_| | |  __/\__ \
  |_|\___|\___|_| |_|_| |_|\___/|_|\___/ \__, |_|\___||___/
                                         |___/             
-------------------------------------------------------------------]]--[[
							  
	Lua Developer: King David
	Contact: http://steamcommunity.com/groups/wiltostech
		
----------------------------------------]]--

wOS.AnimExtension.Mounted[ "Left 4 Dead" ] = true
MsgC( Color( 255, 255, 255 ), "[wOS] Successfully mounted animation extension: Left 4 Dead\n" )
--PATH addons/[fix] wiltos_animation_fix/lua/wos/anim_extension/core/sh_metatable.lua:
-- "addons\\wosanim_fixes\\lua\\wos\\anim_extension\\core\\sh_metatable.lua"
-- Retrieved by https://github.com/lewisclark/glua-steal
--[[-------------------------------------------------------------------
	wiltOS Hold Type Meta Tables:
		Creating functions for your Hold Types since 2017
			Powered by
						  _ _ _    ___  ____  
				__      _(_) | |_ / _ \/ ___| 
				\ \ /\ / / | | __| | | \___ \ 
				 \ V  V /| | | |_| |_| |___) |
				  \_/\_/ |_|_|\__|\___/|____/ 
											  
 _____         _                 _             _           
|_   _|__  ___| |__  _ __   ___ | | ___   __ _(_) ___  ___ 
  | |/ _ \/ __| '_ \| '_ \ / _ \| |/ _ \ / _` | |/ _ \/ __|
  | |  __/ (__| | | | | | | (_) | | (_) | (_| | |  __/\__ \
  |_|\___|\___|_| |_|_| |_|\___/|_|\___/ \__, |_|\___||___/
                                         |___/             
-------------------------------------------------------------------]]--[[
							  
	Lua Developer: King David
	Contact: http://steamcommunity.com/groups/wiltostech
		
----------------------------------------]]--

wOS = wOS or {}
wOS.AnimExtension.HoldTypeMeta = wOS.AnimExtension.HoldTypeMeta or {}

local HOLDTYPE = {}

HOLDTYPE.GetName = function( self ) 
	return self.Name or nil
end

HOLDTYPE.GetID = function( self )
	return self.HoldType or "wos-custom"
end

HOLDTYPE.GetActivityList = function( self )
	local index = wOS.AnimExtension.ActIndex[ self:GetBaseHoldType() ]
	return {
		[ACT_MP_STAND_IDLE] 				= index,
	    [ACT_MP_WALK] 						= index+1,
		[ACT_MP_RUN] 						= index+2,
		[ACT_MP_CROUCH_IDLE] 				= index+3,
		[ACT_MP_CROUCHWALK] 				= index+4,
		[ACT_MP_ATTACK_STAND_PRIMARYFIRE] 	= index+5,
		[ACT_MP_ATTACK_CROUCH_PRIMARYFIRE] = index+5,
		[ACT_MP_RELOAD_STAND]		 		= index+6,
		[ACT_MP_RELOAD_CROUCH]		 		= index+6,
		[ACT_MP_JUMP] 						= index+7,
		[ACT_RANGE_ATTACK1] 				= index+8,
		[ACT_MP_SWIM] 						= index+9,	
	}
end

HOLDTYPE.GetBaseHoldType = function( self )
	return self.BaseHoldType or "normal"
end

HOLDTYPE.SetBaseHoldType = function( self, newtype )
	self.BaseHoldType = newtype
end

//This is a god damn mess mostly because of legacy support, I need to redo this part for sure.
//OR at least make the old hold-types switch over to the new one
HOLDTYPE.GetActData = function( self, act ) 

	local base = self.Translations[ act ]
	local tbl
	
	if base then
		tbl = {}
		if istable( base ) then
			if base.Sequence then
				tbl.Sequence = base.Sequence
				tbl.Weight = base.Weight or 1
			else
				local seed = ( game.SinglePlayer() and math.random( 1, #base ) ) or util.SharedRandom( "wOS.AnimExtension." .. self:GetName() .. "[" .. act .. "]", 1, #base )
				local key = math.Round( seed )
				local innerbase = base[key]
				if istable( innerbase ) then
					tbl = innerbase
				elseif isstring( innerbase ) then
					tbl.Sequence = innerbase
					tbl.Weight = 1
				end
			end
		elseif isstring( base ) then
			tbl.Sequence = base
		end
	end

	return tbl
	
end

HOLDTYPE.__index = HOLDTYPE

function wOS.AnimExtension.HoldTypeMeta:CreateMetaType( tbl )
	setmetatable( tbl, HOLDTYPE )
end
--PATH lua/wos/anim_extension/holdtypes/a_combo2.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/wos/anim_extension/holdtypes/arrogant.lua:
return gluapack()()
--PATH lua/wos/anim_extension/holdtypes/g_restart.lua:
return gluapack()()
--PATH lua/wos/anim_extension/holdtypes/g_rollback.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/wos/anim_extension/holdtypes/greaterer_melee.lua:
local DATA = {}
DATA.Name = "melee"
DATA.HoldType = "wos-melee-type"
DATA.BaseHoldType = "melee2"
DATA.Translations = {} 

DATA.Translations[ ACT_MP_RUN ] = {
	{ Sequence = "b_run", Weight = 1 },
}

DATA.Translations[ ACT_MP_WALK ] = {
	{ Sequence = "b_run", Weight = 1 },
}

DATA.Translations[ ACT_MP_SPRINT ] = {
	{ Sequence = "b_run", Weight = 1 },
}

DATA.Translations[ ACT_MP_STAND_IDLE ] = {
	{ Sequence = "h_idle", Weight = 1 },
}

DATA.Translations[ ACT_MP_JUMP ] = {
	{ Sequence = "balanced_jump", Weight = 1 },
}


wOS.AnimExtension:RegisterHoldtype( DATA )
--=====================================================================
--PATH addons/[miecze] moce i hilty/lua/wos/anim_extension/holdtypes/lscs_holdtypes.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/wos/anim_extension/holdtypes/ninja.lua:
local DATA = {}
DATA.Name = "melee3"
DATA.HoldType = "wos-ninja-corvinus"
DATA.BaseHoldType = "melee2"
DATA.Translations = {} 

DATA.Translations[ ACT_MP_RUN ] = {
	{ Sequence = "zombie_run", Weight = 1 },
}

DATA.Translations[ ACT_MP_WALK ] = {
	{ Sequence = "zombie_run", Weight = 1 },
}

DATA.Translations[ ACT_MP_SPRINT ] = {
	{ Sequence = "zombie_run_fast", Weight = 1 },
}

DATA.Translations[ ACT_MP_STAND_IDLE ] = {
	{ Sequence = "idle_all_angry", Weight = 1 },
}

DATA.Translations[ ACT_MP_JUMP ] = {
	{ Sequence = "zombie_leap_start", Weight = 1 },
}

DATA.Translations[ ACT_MP_CROUCH_IDLE ] = {
	{ Sequence = "zombie_cidle_02", Weight = 1 },
}

DATA.Translations[ ACT_MP_CROUCHWALK ] = {
	{ Sequence = "zombie_cwalk_01", Weight = 1 },
}

wOS.AnimExtension:RegisterHoldtype( DATA )
--=====================================================================
--PATH lua/wos/anim_extension/holdtypes/rollsword.lua:
return gluapack()()
--PATH lua/wos/anim_extension/holdtypes/skyrim_holdtype.lua:

local DATA = {}
DATA.Name = "[LSCS] HoldType Skyrim"
DATA.HoldType = "skyrim_holdtype"
DATA.BaseHoldType = "melee2"
DATA.Translations = {} 
DATA.Translations[ ACT_MP_STAND_IDLE ] = "2hw_idle"
DATA.Translations[ ACT_MP_WALK ] = "2hm_walk"
DATA.Translations[ ACT_MP_RUN ] = "2hm_run"
wOS.AnimExtension:RegisterHoldtype( DATA )

--PATH addons/[miecze] moce i hilty/lua/wos/anim_extension/holdtypes/warrior.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/wos/anim_extension/holdtypes/youngli.lua:
return gluapack()()
--PATH lua/autorun/wiltos_dynabase_loader.lua:

--[[-------------------------------------------------------------------
	Dynamic Base:
		Bringing the power everyone. Developer, server owner, and player.
			Powered by
						  _ _ _    ___  ____  
				__      _(_) | |_ / _ \/ ___| 
				\ \ /\ / / | | __| | | \___ \ 
				 \ V  V /| | | |_| |_| |___) |
				  \_/\_/ |_|_|\__|\___/|____/ 
											  
 _____         _                 _             _           
|_   _|__  ___| |__  _ __   ___ | | ___   __ _(_) ___  ___ 
  | |/ _ \/ __| '_ \| '_ \ / _ \| |/ _ \ / _` | |/ _ \/ __|
  | |  __/ (__| | | | | | | (_) | | (_) | (_| | |  __/\__ \
  |_|\___|\___|_| |_|_| |_|\___/|_|\___/ \__, |_|\___||___/
                                         |___/             
-------------------------------------------------------------------]]--[[
							  
	Lua Developer: King David
	Contact: http://steamcommunity.com/groups/wiltostech
		
----------------------------------------]]--

if SERVER then
	AddCSLuaFile( "wos/dynabase/loader/loader.lua" )
end

include( "wos/dynabase/loader/loader.lua" )
--PATH lua/wos/dynabase/registers/exp_register.lua:
return gluapack()()
--PATH lua/wos/dynabase/registers/prone_extend.lua:
return gluapack()()
--PATH lua/xeninui/libs/time.lua:
function XeninUI:GetUTCTime()

	return os.time()
end

function XeninUI:SecondsToTimeString(s, _format, as_tbl)
	local d = (s / 86400)
	local h = math.floor(math.fmod(s, 86400) / 3600)
	local m = math.floor(math.fmod(s, 3600) / 60)
	local s = math.floor(math.fmod(s, 60))

	if as_tbl then
		return {
			d = d,
			h = h,
			m = m,
			s = s
		}
	end

	return string.format(_format or "%d:%02d:%02d:%02d", d, h, m, s)
end

function XeninUI:SecondsToSmallTime(s, _format, as_tbl)
	local m = math.floor(math.fmod(s, 3600) / 60)
	local s = math.floor(math.fmod(s, 60))

	if as_tbl then
		return {
			d = d,
			h = h,
			m = m,
			s = s
		}
	end

	return string.format(_format or "%02d:%02d", m, s)
end

--PATH lua/xeninui/libs/wyvern.lua:
XeninUI.openTime = 0.15
XeninUI.closeTime = 0.15

function XeninUI:GetColorLightness(color)
    local uiColors = {
        color.r / 255,
        color.g / 255,
        color.b / 255
    }
    for i, c in ipairs(uiColors) do
        if c <= 0.03928 then
            uiColors[i] = c / 12.92
        else
            uiColors[i] = math.pow((c + 0.055) / 1.055, 2.4)
        end
    end
    return 0.2126 * uiColors[1] + 0.6152 * uiColors[2] + 0.0622 * uiColors[3]
end

function XeninUI:GetContrastColor(bgColor, colLight, colDark, darkRequirement)
    colLight = colLight or Color(255, 255, 255)
    colDark = colDark or Color(0, 0, 0)
    darkRequirement = darkRequirement or 0.21

    if XeninUI:GetColorLightness(bgColor) > darkRequirement then
        return colDark
    end

    return colLight
end

function XeninUI:GetCommonRippleColor()
    return XeninUI:GetContrastColor(XeninUI.Theme.Accent, ColorAlpha(XeninUI.Theme.Accent, 20), ColorAlpha(XeninUI.Theme.Accent, 100))
end

function XeninUI:ManipulateColor(col, deltaH, deltaS, deltaV)
    local h, s, v = ColorToHSV(col)

    return HSVToColor(math.Clamp(h + deltaH, 0, 360), math.Clamp(s + deltaS, 0, 1), math.Clamp(v + deltaV, 0, 1))
end

local surface_SetDrawColor = surface.SetDrawColor
local rad = math.rad
local sin = math.sin
local cos = math.cos

function XeninUI:CalculateCircle(sx, sy, radius, vertexCount, angle)
    local vertices = {}
    local ang = -rad(angle or 0)
    local c = cos(ang)
    local s = sin(ang)
    for i = 0, 360, 360 / vertexCount do
        local radd = rad(i)
        local x = cos(radd)
        local y = sin(radd)

        local tempx = x * radius * c - y * radius * s + sx
        y = x * radius * s + y * radius * c + sy
        x = tempx

        vertices[#vertices + 1] = {
            x = x,
            y = y,
            u = u,
            v = v
        }
    end

    return vertices
end

function XeninUI:DrawCachedCircle(vertices, color)
    if vertices and #vertices > 0 then
        draw.NoTexture()
        surface_SetDrawColor(color)
        surface.DrawPoly(vertices)
    end
end

function XeninUI:DrawCircle(sx, sy, radius, vertexCount, color)
    local vertices = {}
    local ang = -rad(0)
    local c = cos(ang)
    local s = sin(ang)
    for i = 0, 360, 360 / vertexCount do
        local radd = rad(i)
        local x = cos(radd)
        local y = sin(radd)

        local tempx = x * radius * c - y * radius * s + sx
        y = x * radius * s + y * radius * c + sy
        x = tempx

        vertices[#vertices + 1] = {
            x = x,
            y = y,
            u = u,
            v = v
        }
    end

    if vertices and #vertices > 0 then
        draw.NoTexture()
        surface_SetDrawColor(color)
        surface.DrawPoly(vertices)
    end
end

local matCorner8 = Material("materials/wyvernf4/corner_8.png")
local matCorner16 = Material("materials/wyvernf4/corner_16.png")





function XeninUI:Ease2(t, b, c, d)
    t = t / d
    local ts = t * t
    local tc = ts * t
    return b + c * (9.3475 * tc * ts + -22.6425 * ts * ts + 15.495 * tc + -1.3 * ts + 0.1 * t)
end

function XeninUI:AddRippleFunctions(pnl)
    pnl.ripples = {}

    function pnl:PaintRipples(w, h)
        draw.NoTexture()
        for i, ripple in ipairs(self.ripples) do
            local t = ripple.endTime - CurTime()
            local f = math.Clamp(1 - (t / ripple.duration), 0, 1)
            local f2 = XeninUI:Ease2(f, 0, 1, 1)

            local r = self:GetFurthestDistanceFrom(ripple.x, ripple.y) + 5
            XeninUI:DrawCircle(ripple.x, ripple.y, r * f2, ripple.vertexCount, ColorAlpha(ripple.color, math.Clamp(ripple.alpha * ripple.color.a, 0, 100)))

            if f >= 1 then
                local doFade = true
                if input.IsMouseDown(MOUSE_LEFT) and i == #self.ripples and pnl:IsHovered() then
                    doFade = false
                end

                if doFade then
                    ripple.alpha = ripple.alpha + (0 - ripple.alpha) * 10 * FrameTime()

                    if not ripple.isFading then
                        if ripple.callback then ripple.callback(false)end

                        ripple.isFading = true
                    end
                end
            end
        end

        for i = #self.ripples, 1, -1 do
            local ripple = self.ripples[i]
            if ripple.alpha < 0.01 then
                if ripple.callback then
                    ripple.callback(true)
                end

                table.remove(self.ripples, i)
            end
        end
    end

    local oldPaint = pnl.Paint
    function pnl:Paint(w, h)
        if oldPaint then oldPaint(self, w, h)end

        XeninUI:Mask(function()
            XeninUI:DrawRoundedBox(8, 0, 0, w, h, color_white)
        end, function()
            self:PaintRipples(w, h)
        end)
    end

    function pnl:AddRipple(x, y, options)
        local duration = options.duration or 0.5

        self.ripples[#self.ripples + 1] = {
            x = x,
            y = y,
            endTime = CurTime() + duration,
            alpha = 1,
            duration = duration,
            color = options.color or Color(255, 255, 255, 2),
            vertexCount = options.vertexCount or 30,
            callback = options.callback
        }
    end

    function pnl:GetFurthestDistanceFrom(x, y)
        local w, h = self:GetSize()
        local dx, dy

        if x < w / 2 then
            if y < h / 2 then
                dx = w - x
                dy = h - y
            else
                dx = w - x
                dy = 0 - y
            end
        else
            if y < h / 2 then
                dx = 0 - x
                dy = h - y
            else
                dx = 0 - x
                dy = 0 - y
            end
        end

        return math.sqrt(dx * dx + dy * dy)
    end
end

function XeninUI:AddRippleClickEffect(pnl, color, duration)
    self:AddRippleFunctions(pnl)

    pnl.rippleColor = color
    pnl.rippleDuration = duration

    function pnl:OnMousePressedRipple(code)
        if self.GetDisabled and self:GetDisabled() then return end

        if code == MOUSE_LEFT then
            local cx, cy = self:CursorPos()
            self:AddRipple(cx, cy, {
                color = pnl.rippleColor,
                duration = pnl.rippleDuration
            })
        end
    end

    local oldMousePressed = pnl.OnMousePressed
    function pnl:OnMousePressed(code)
        pnl:OnMousePressedRipple(code)

        if oldMousePressed then
            return oldMousePressed(self, code)
        end
    end
end

--PATH lua/xeninui/libs/languages/network/client.lua:
return gluapack()()
--PATH lua/xeninui/libs/languages/network/client.lua:
local LanguagesNetwork
do
  local _class_0
  local _parent_0 = XeninUI.Network
  local _base_0 = {
    __name = "LanguagesNetwork",
    __base = XeninUI.Network.__base,
    receiveLanguage = function(self, ply)
      local addonId = net.ReadString()
      local lang = net.ReadString()
      local data = self:decompress()

      XeninUI.LanguageAddons[addonId]:SetLocalLanguage(lang, data)
    end,
    sendRequestLanguage = function(self, addonId, lang)
      self:send("XeninUI.Language", function(self)
        net.WriteString(addonId)
        net.WriteString(lang)
      end)
    end,
    __type = function(self)
      return "XeninUI.LanguagesNetwork"end
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__index)
  _class_0 = setmetatable({
    __init = function(self)
      LanguagesNetwork.__parent.__init(self)

      self:receiver("XeninUI.Language", self.receiveLanguage)
    end,
    __base = _base_0,
    __parent = _parent_0
  }, {
    __index = function(cls, parent)
      local val = rawget(_base_0, parent)
      if val == nil then local _parent = rawget(cls, "__parent")
        if _parent then return _parent[parent]
        end
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  if _parent_0.__inherited then _parent_0.__inherited(_parent_0, _class_0)
  end
  LanguagesNetwork = _class_0
end

XeninUI.LanguagesNetwork = LanguagesNetwork()

--PATH lua/xeninui/libs/configurator/main.lua:
return gluapack()()
--PATH lua/xeninui/libs/configurator/classes/entity.lua:
return gluapack()()
--PATH lua/xeninui/libs/configurator/ui/settings.lua:
return gluapack()()
--PATH lua/xeninui/libs/configurator/ui/inputs/blank.lua:
return gluapack()()
--PATH lua/xeninui/libs/configurator/ui/inputs/key.lua:
return gluapack()()
--PATH lua/xeninui/libs/configurator/ui/inputs/key.lua:
local x

--PATH lua/xeninui/libs/configurator/ui/inputs/keyvalue.lua:
return gluapack()()
--PATH lua/xeninui/libs/configurator/ui/inputs/sliderpad.lua:
local x

--PATH lua/xeninui/libs/configurator/ui/inputs/textentrylist.lua:
return gluapack()()
--PATH lua/xeninui/libs/configurator/ui/inputs/textentrywithlabel.lua:
local x

--PATH lua/xeninui/libs/config/class.lua:
return gluapack()()
--PATH lua/xeninui/elements/button_v2.lua:
local PANEL = {}




AccessorFunc(PANEL, "_cStartCol", "StartColor")
AccessorFunc(PANEL, "_cEndcol", "EndColor")
AccessorFunc(PANEL, "_iRoundness", "Roundness")
AccessorFunc(PANEL, "_iOffsetX", "XOffset", FORCE_NUMBER)
AccessorFunc(PANEL, "_iOffsetY", "YOffset", FORCE_NUMBER)
AccessorFunc(PANEL, "_sIcon", "Icon")
AccessorFunc(PANEL, "_cHoverColor", "HoverColor")
AccessorFunc(PANEL, "_cSolidColor", "SolidColor")
AccessorFunc(PANEL, "_cTextColor", "TextColor")
AccessorFunc(PANEL, "_iIconSize", "IconSize", FORCE_NUMBER)


XeninUI:CreateFont("XeninUI.GradientButton.Default", 24)

function PANEL:SetSolidColor(col)
	self.SolidColorStatic = col

	self._cSolidColor = col
end

function PANEL:Init()
	self:SetText("")
	self:SetSolidColor(Color(158, 53, 210))
	self:SetStartColor(Color(158, 53, 210))
	self:SetEndColor(Color(109, 77, 213))
	self:SetFont("XeninUI.GradientButton.Default")
	self:SetRoundness(self:GetTall())
	self:SetContentAlignment(5)
	self:SetXOffset(0)
	self:SetYOffset(0)
	self:SetGradient(false)
	self:SetTextColor(color_white)

	self.ButtonAlpha = 255

	self.SetText = function(self, text)
		self._sText = text
	end
	self.GetText = function(self)
		return self._sText
	end
end

function PANEL:SizeToContentsX(padding)
	if padding == nil then padding = 0
	end
	surface.SetFont(self:GetFont())
	local tw = surface.GetTextSize(self:GetText())

	self:SetWide(tw + padding)
end

function PANEL:IsGradient()
	return self._bUniform
end

function PANEL:SetGradient(bBool)
	self._bUniform = bBool
end

function PANEL:RoundFromTallness()
	self:SetRoundness(self:GetTall())
end

function PANEL:SetContentAlignment(iInteger)
	self._iHorizontalAlignment = (iInteger - 1) % 3
	self._iVerticalAlignment = (iInteger == 5 or iInteger == 6 or iInteger == 4) and 1 or (iInteger == 1 or iInteger == 2 or iInteger == 3) and 4 or 3

	self._bTopAligned = self._iVerticalAlignment == 3
	self._bBottomAligned = self._iVerticalAlignment == 4

	self._bLeftAligned = self._iHorizontalAlignment == 0
	self._bRightAligned = self._iHorizontalAlignment == 2
end

local ShadowColor = Color(0, 0, 0, 50)
function PANEL:Paint(w, h)
	local aX, aY = self:LocalToScreen()
	local cStartColor, cEndColor, cColor = ColorAlpha(self:GetStartColor(), self.ButtonAlpha), ColorAlpha(self:GetEndColor(), self.ButtonAlpha), ColorAlpha(self:GetSolidColor(), self.ButtonAlpha)

	if self:GetRoundness() > 0 then
		XeninUI:Mask(function()
			XeninUI:DrawRoundedBox(self:GetRoundness(), 0, 0, w, h, color_white)
		end, function()
			if self:IsGradient() then
				draw.SimpleLinearGradient(aX, aY, w, h, cStartColor, cEndColor, true)
			else
				surface.SetDrawColor(cColor)
				surface.DrawRect(0, 0, w, h)
			end
		end)
	else
		if self:IsGradient() then
			draw.SimpleLinearGradient(aX, aY, w, h, cStartColor, cEndColor, true)
		else
			surface.SetDrawColor(cColor)
			surface.DrawRect(0, 0, w, h)
		end
	end

	local iconID = self:GetIcon()
	local icon = iconID and XeninUI:GetIcon(iconID) or false
	local size = 0
	if icon then
		size = self:GetIconSize() or h * 0.8
		if (icon != "Loading") then
			surface.SetMaterial(icon)

			surface.SetDrawColor(ShadowColor)
			surface.DrawTexturedRect(5 + 1, h / 2 - Size / 2 + 2, Size, Size)

			surface.SetDrawColor(iconColor or Color(235, 235, 235))
			surface.DrawTexturedRect(5, h / 2 - Size / 2 + 1, Size, Size)
		else
			XeninUI:DrawLoadingCircle(h / 2, h / 2, h - 24, XeninUI.Theme.Blue)
		end
	end
	local XOffset, YOffset = self:GetXOffset() + (self._bLeftAligned and Size or 0), self:GetYOffset()

	draw.SimpleText(self:GetText(), self:GetFont(), self._bLeftAligned and XOffset or self._bRightAligned and w + XOffset or w / 2 + XOffset, self._bTopAligned and YOffset or self._bBottomAligned and (h + YOffset) or h / 2 + YOffset, self:GetTextColor(), self._iHorizontalAlignment, self._iVerticalAlignment)
end

function PANEL:OnCursorEntered()
	if (self:GetHoverColor() and !self:IsGradient()) then
		self:LerpColor("_cSolidColor", self:GetHoverColor())
	else
		self:Lerp("ButtonAlpha", 127.5)
	end
end

function PANEL:OnCursorExited()
	if (self:GetHoverColor() and !self:IsGradient()) then
		self:LerpColor("_cSolidColor", self.SolidColorStatic)
	else
		self:Lerp("ButtonAlpha", 255)
	end
end
vgui.Register("XeninUI.ButtonV2", PANEL, "DButton")

--PATH lua/xeninui/elements/colorpicker.lua:
local PANEL = {}


function PANEL:OnChange(color) end

function PANEL:UpdateColor()
  self.Color = XeninUI:HSLToColor(self.Hue, self.Saturation, self.Lightness)
  self:OnChange(self.Color)
end

function PANEL:SetColor(color)
  local h, s, l = ColorToHSL(color)
  h = h / (360 / 5)
  self.Hue = h
  self.Saturation = s
  self.Lightness = l

  self.Color = color
  self:OnChange(color)

  self:UpdatePositions()
end

function PANEL:UpdatePositions()
  local radius = self:GetTriangleRadius()
  local hue = self.Hue
  local third = (2 / 3) * math.pi
  local sat = self.Saturation
  local light = 1 - self.Lightness

  local hX = math.cos(hue)
  local hY = math.sin(hue)
  local sX = math.cos(hue - third)
  local sY = math.sin(hue - third)
  local vX = math.cos(hue + third)
  local vY = math.sin(hue + third)

  local mX = (sX + vX) / 2
  local mY = (sY + vY) / 2
  local a = (1 - 2 * math.abs(light - 0.5)) * sat

  self.TriX = sX + (vX - sX) * light + (hX - mX) * a
  self.TriY = sY + (vY - sY) * light + (hY - mY) * a
end

function PANEL:Think()
  local cursorX, cursorY = self:CursorPos()
  local cX, cY = self:GetCenter()
  local center = Vector(cX, cY, 0)
  local radius = self:GetRadius()
  local triangleRadius = self:GetTriangleRadius()

  if (!self.Pressed) then return end

  local diffX = cursorX - cX
  local diffY = cursorY - cY
  local rad = math.atan2(diffY, diffX)
  if (rad < 0) then
    rad = rad + (2 * math.pi)
  end

  if self.PressedWheel then
    self.Hue = rad
    self:UpdatePositions()
    self:UpdateColor()

    return
  end

  local rad0 = (rad + 2 * math.pi - self.Hue) % (2 * math.pi)
  local rad1 = rad0 % ((2 / 3) * math.pi) - (math.pi / 3)
  local a = 0.5 * triangleRadius
  local b = math.tan(rad1) * a
  local r = math.sqrt(diffX * diffX + diffY * diffY)
  local maxR = math.sqrt(a * a + b * b)

  if (r > maxR) then
    local dx = math.tan(rad1) * r
    local rad2 = math.Clamp(math.atan(dx / maxR), -math.pi / 3, math.pi / 3)
    rad = rad + (rad2 - rad1)
    rad0 = (rad + 2 * math.pi - self.hue) % (2 * math.pi)
    rad1 = rad0 % ((2 / 3) * math.pi) - (math.pi / 3)
    b = math.tan(rad1) * a
    maxR = math.sqrt(a * a + b * b)
    r = maxR
  end

  self.TriX = math.cos(rad) * r / triangleRadius
  self.TriY = math.sin(rad) * r / triangleRadius

  local triangleSideLen = math.sqrt(3) * triangleRadius
  local light = ((math.sin(rad0) * r) / triangleSideLen) + 0.5
  local widthShare = 1.0 - math.abs(light - 0.5) * 2.0
  local saturation = (((math.cos(rad0) * r) + (triangleRadius / 2)) / (1.5 * triangleRadius)) / widthShare
  saturation = math.Clamp(saturation, 0, 1)

  self.Lightness = 1 - light
  self.Saturation = saturation

  self:UpdateColor()
end

function PANEL:Init()
  self.Hue = 0
  self.SmoothHue = 0

  self.Lightness = 0
  self.Saturation = 0

  self.TriX = 0
  self.TriY = 0

  self:UpdateColor()
  self:UpdatePositions()

  XeninUI:DownloadIcon(self, "i0xcO1R")
  XeninUI:DownloadIcon(self, "k5mtok6", "Ring")
  XeninUI:DownloadIcon(self, "t0k86qy", "Picker")
end

function PANEL:OnMousePressed()
  self.Pressed = true

  local cX, cY = self:GetCenter()
  local cursorX, cursorY = self:CursorPos()
  local cursor = Vector(cursorX, cursorY)
  local center = Vector(cX, cY, 0)

  if (cursor:Distance(center) > self:GetTriangleRadius()) then
    self.PressedWheel = true

    return
  end

  self.PressedTriangle = true
end

function PANEL:OnMouseReleased()
  self.Pressed = false
  self.PressedWheel = false
  self.PressedTriangle = false
end

function PANEL:GetCenter()
  return self:GetWide() / 2, self:GetTall() / 2
end

function PANEL:GetRadius()
  return self:GetTall() / 2
end

function PANEL:GetTriangleRadius()
  return self:GetRadius() * 0.7
end

function PANEL:GetRingThickness()
  return self:GetRadius() * 0.2
end

function PANEL:GetHueColor()
  return XeninUI:HSLToColor(self.Hue, 1, 0.5)
end

function PANEL:Paint(w, h)
  local cX, cY = self:GetCenter()
  local radius = self:GetRadius()
  local triangleRadius = self:GetTriangleRadius()

  draw.NoTexture()

  local triangleAng = self.Hue
  local triangleOff = math.pi * 2 / 3
  local vertices = {
    {
      x = cX + math.cos(triangleAng - triangleOff) * triangleRadius,
      y = cY + math.sin(triangleAng - triangleOff) * triangleRadius,
      u = 0.5,
      v = 0.99
    },
    {
      x = cX + math.cos(triangleAng) * triangleRadius,
      y = cY + math.sin(triangleAng) * triangleRadius,
      u = 0.99,
      v = 0.01
    },
    {
      x = cX + math.cos(triangleAng + triangleOff * 1) * triangleRadius,
      y = cY + math.sin(triangleAng + triangleOff * 1) * triangleRadius,
      u = 0.01,
      v = 0.01
    }
  }

  local col = self:GetHueColor()
  surface.SetDrawColor(col)
  surface.DrawPoly(vertices)

  surface.SetDrawColor(255, 255, 255)
  surface.SetMaterial(self.Icon)
  surface.DrawPoly(vertices)
  surface.DrawPoly(vertices)

  vertices[1].u = 0.99
  vertices[1].v = 0.01

  vertices[2].u = 0.01
  vertices[2].v = 0.01

  vertices[3].u = 0.5
  vertices[3].v = 0.99

  surface.SetDrawColor(0, 0, 0)
  surface.SetMaterial(self.Icon)
  surface.DrawPoly(vertices)

  surface.SetDrawColor(255, 255, 255)
  surface.SetMaterial(self.Ring)
  surface.DrawTexturedRect(cX - radius, cY - radius, radius * 2, radius * 2)

  local pickerVerts = {
    {
      x = cX + self.TriX * triangleRadius + 2,
      y = cY + self.TriY * triangleRadius + 2,
      u = 1,
      v = 1
    },
    {
      x = cX + self.TriX * triangleRadius - 2,
      y = cY + self.TriY * triangleRadius + 2,
      u = 0,
      v = 1
    },
    {
      x = cX + self.TriX * triangleRadius - 2,
      y = cY + self.TriY * triangleRadius - 2,
      u = 0,
      v = 0
    },
    {
      x = cX + self.TriX * triangleRadius + 2,
      y = cY + self.TriY * triangleRadius - 2,
      u = 1,
      v = 0
    }
  }

  surface.SetDrawColor(255, 255, 255)
  surface.SetMaterial(self.Picker)
  surface.DrawPoly(pickerVerts)

  local hpX = cX + math.cos(self.Hue) * (radius - self:GetRingThickness() / 2)
  local hpY = cY + math.sin(self.Hue) * (radius - self:GetRingThickness() / 2)
  local size = 16
  local huePickerVerts = {
    {
      x = hpX + size / 2,
      y = hpY + size / 2,
      u = 1,
      v = 1
    },
    {
      x = hpX - size / 2,
      y = hpY + size / 2,
      u = 0,
      v = 1
    },
    {
      x = hpX - size / 2,
      y = hpY - size / 2,
      u = 0,
      v = 0
    },
    {
      x = hpX + size / 2,
      y = hpY - size / 2,
      u = 1,
      v = 0
    }
  }
  surface.SetDrawColor(255, 255, 255)
  surface.SetMaterial(self.Picker)
  surface.DrawPoly(huePickerVerts)
end

vgui.Register("XeninUI.ColorPicker", PANEL)

--PATH lua/xeninui/elements/combobox.lua:
local x

--PATH lua/xeninui/elements/dropdown_popup.lua:
return gluapack()()
--PATH lua/xeninui/elements/query_single_button.lua:
local PANEL = {}

XeninUI:CreateFont("XeninUI.Query.Text", 18)
XeninUI:CreateFont("XeninUI.Query.Button", 18)

function PANEL:Init()
  self.onAccept = function() end
  self.onDecline = function() end

  self.background.text = self.background:Add("DLabel")
  self.background.text:SetText("XD")
  self.background.text:SetFont("XeninUI.Query.Text")
  self.background.text:SetContentAlignment(8)
  self.background.text:SetTextColor(Color(200, 200, 200))

  self.background.accept = self.background:Add("DButton")
  self.background.accept:SetText("Accept")
  self.background.accept:SetFont("XeninUI.Query.Button")
  self.background.accept:SetTextColor(Color(21, 21, 21))
  self.background.accept.Paint = function(pnl, w, h)
    draw.RoundedBox(6, 0, 0, w, h, self.acceptBtnColor or XeninUI.Theme.Green)
  end
  self.background.accept.DoClick = function(pnl)
    self:onAccept(pnl)
    self:Remove()
  end
end

function PANEL:PerformLayout(w, h)
  surface.SetFont(self.background.text:GetFont())
  local tw = surface.GetTextSize(self.background.text:GetText())
  self:SetBackgroundWidth(tw + 32)

  self.BaseClass.PerformLayout(self, w, h)

  self.background.text:SetWide(self.background:GetWide())
  self.background.text:SizeToContentsY()
  self.background.text:SetPos(0, 56)

  self.background.accept:SizeToContentsX(32)
  self.background.accept:SizeToContentsY(16)

  local y = self.background:GetTall() - self.background.accept:GetTall() - 16

  self.background.accept:SetPos(self.background:GetWide() / 2 - self.background.accept:GetWide() / 2, y)
end

function PANEL:SetText(text)
  self.background.text:SetText(text)
end

function PANEL:SetAccept(text, func)
  self.background.accept:SetText(text)
  self.onAccept = func
end

vgui.Register("XeninUI.QuerySingleButton", PANEL, "XeninUI.Popup")

function XeninUI:SimpleQuerySingle(title, text, yesText, yesFunc)
  local queryMenu = vgui.Create("XeninUI.QuerySingleButton")
  queryMenu:SetSize(ScrW(), ScrH())
  queryMenu:SetBackgroundHeight(140)

  queryMenu:SetTitle(title or "Title")
  queryMenu:SetText(text or "Text")

  queryMenu:SetAccept(yesText or "Yes", yesFunc or (function() end))

  queryMenu:MakePopup()

  return queryMenu
end

--PATH lua/xeninui/libs/units/classes/assert.lua:
return gluapack()()
--PATH lua/xeninui/libs/units/classes/result.lua:
do
  local _class_0
  local _base_0 = {
    __name = "XeninUI.Units.Result",
    setError = function(self, err)
      self.returnVal = err end,
    setSuccess = function(self, bool)
      self.success = bool end,
    getReturn = function(self)
      return self.returnVal end,
    isSuccess = function(self)
      return self.success end,
    getMessagePrint = function(self)
      local prefix = self.success and "+" or "-"
      local color = self.success and XeninUI.Theme.Green or XeninUI.Theme.Red
      local str = tostring(prefix) .. " " .. tostring(self.name)
      if (!self.success) then str = str .. " ** FAILED **"
        if isstring(self.returnVal) then

          local errMsg = self.returnVal:Split("stack traceback")
          errMsg = errMsg[1]:sub(1, #errMsg[1] - 1)
          str = str .. "\nError was: " .. tostring(errMsg)
        end
      end

      return {
        color,
        str
      }
    end,
    __type = function(self)
      return self.__name
    end
  }
  _base_0.__index = _base_0
  _class_0 = setmetatable({
    __init = function(self, name, success, returnVal)
      self.isResult = true

      self.name = name
      self.success = success
      self.returnVal = returnVal
    end,
    __base = _base_0
  }, {
    __index = _base_0,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  XeninUI.Units.Result = _class_0
end

--PATH addons/[technik] darkrp-city-worker/lua/autorun/client/cityworker_client.lua:
return gluapack()()
--PATH addons/[tfres] frest_levels/lua/autorun/client/lvlpanel.lua:
fstands = fstands or {}
fstands.lvl = fstands.lvl or {}

hook.Add( "PopulateToolMenu", "flevels", function()
	spawnmenu.AddToolMenuOption( "Options", "fstands", "Custom_Menu", "LevelSystem", "", "", function( panel )
		panel:Clear()
        local button = vgui.Create("DButton",panel)
        button:Center()
        button:Dock(TOP)
        button:SetText("Open Admin Panel")
        function button:DoClick()
            if LocalPlayer():IsSuperAdmin() then
                net.Start("flvladmin")
                    net.WriteBool(false)
                net.SendToServer()
                self:SetEnabled(false)
                timer.Simple(2,function()
                    if IsValid(self) then
                        self:SetEnabled(true)
                    end
                end)
            end
            
        end
        
		-- Add stuff here
	end )
end )

net.Receive("flvladmin",function(len)
    local json = net.ReadString()
    local tbl = util.JSONToTable(json)
    fstands.Config.Levels = tbl
    dermaflvl()
end)

local premakelvl = {
    "ID",
    "Print Name",
    "Color",
    "Sort Order",
}
local config = {
    ["multexp"] = {"group","Group exp boost (E.g. Vip get 2x exp)"},
    ["time"] = {"float","How often should give EXP (in minutes)",0.5,30},
    ["exp"] = {"float","How much EXP give per time",1,200},
    ["weekendexpboost"] = {"float","Weekend Boost (0 = Disabled,| this value multiply exp by its value)",0,10},
    ["contexp"] = {"bool","Continue Exp after Level UP"},
    ["hard"] = {"float","Scaling of Exp for level",0.001,20},
    ["showcustom"] = {"bool","Custom Display - If true then will remove Required LVL ... into desc of job",0.001,20},
}

local function flibconfirm(f,text,callback)
    callback = callback or function() end
    f:SetMouseInputEnabled(false)
    local frame = vgui.Create("FFrame")
    frame:SetSize(ScrW()*0.2,ScrH()*0.2)
    frame:Center()
    frame:FadeIn(1)
    frame:SetColor(Color(38,49,66))
    local t = vgui.Create("DLabel",frame)
    t:SetText(text)
    t:SetTextColor(Color(255,255,255))
    t:Dock(FILL)
    t:SetFont("Trebuchet24")
    t:SetContentAlignment(5)
    local dow = vgui.Create("DPanel",frame)
    dow:Dock(BOTTOM)
    dow.Paint = nil 
    local accept = vgui.Create("FButton",dow)
    accept:SetText("Confirm")
    
    accept:Dock(RIGHT)
    accept:SetBackground(Color(0,100,0))
    accept:SetTextColor(Color(255,255,255))
    function accept:DoClick()
        if IsValid(f) then
            f:SetMouseInputEnabled(true)
        end
        frame:FadeOut(1)
        callback()

    end
    local decline = vgui.Create("FButton",dow)
    decline:Dock(LEFT)
    decline:SetText("DECLINE")
    decline:SetBackground(Color(100,0,0)) 
    decline:SetTextColor(Color(255,255,255))
    function decline:DoClick()
        if IsValid(f) then
            f:SetMouseInputEnabled(true)
        end
        frame:FadeOut(1)
    end
    frame:MakePopup()

end

local function hexToLua(hex)
    hex = string.gsub(hex,"#", "")
    
    if #hex == 6 then
        local r = tonumber(hex:sub(1, 2), 16)
        local g = tonumber(hex:sub(3, 4), 16)
        local b = tonumber(hex:sub(5, 6), 16)
        return r, g, b
    elseif #hex == 8 then
        -- RGBA
        local r = tonumber(hex:sub(1, 2), 16)
        local g = tonumber(hex:sub(3, 4), 16)
        local b = tonumber(hex:sub(5, 6), 16)
        local a = tonumber(hex:sub(7, 8), 16)
        return r, g, b, a
    end
end

function dermaflvl()
    local frame = vgui.Create("FFrame")
    fstands.lvl.derma = frame
    frame:SetSize(ScrW()*0.8,ScrH()*0.8)
    local w,h = frame:GetWide(),frame:GetTall()
    frame:Center()
    frame:TVLIKE(1)
    frame:MakePopup()
    local top = vgui.Create("DPanel",frame)
    top:Dock(TOP)
    top:SetSize(w,h*0.05)
    top.Paint = function(self,w,h)
        surface.SetDrawColor(Color(230,230,230))
        surface.DrawRect(0,0,w,h)
    end
    local button = vgui.Create("FButton",top)
    button:SetSize(w*0.1,h*0.2)
    button:SetText("Close")
    button:Dock(RIGHT)
    button:SetTextColor(Color(0,0,0))
    function button:DoClick()
        frame:Slide(BOTTOM,2)
    end
    local one = vgui.Create("DPanel",frame)
    one:Dock(LEFT)
    one:SetSize(w*0.2)
    one:DockPadding(w*0.01,h*0.01,0,h*0.01)
    one.Paint = nil
    local levele = vgui.Create("DListView",one)
    levele:Dock(FILL)
    levele:SetMultiSelect(false)
    local column = levele:AddColumn( "Levele" )
    column.Header:SetEnabled(false)
    function column.Header:DoClick()
    end 
    function levele:Update()
        self:Clear()
        for k,v in pairs(fstands.Config.Levels.Type) do
            levele:AddLine(k)
        end
    end
    levele:Update()
    local remove = vgui.Create("FButton",one)
    remove:Dock(BOTTOM)
    remove:SetBackground(Color(185,0,0))
    remove:SetText("DELETE")
    remove:SetTextColor(Color(255,255,255))
    function remove:DoClick()
        if levele:GetSelected()[1] == nil then return end
        flibconfirm(frame,"Do you want to DELETE ".. levele:GetSelected()[1]:GetColumnText(1) .." level?")
    end
    local bra = vgui.Create("DPanel",one)
    bra:Dock(BOTTOM)
    bra:SetSize(0,h*0.01)
    bra.Paint = nil

    local two = vgui.Create("DPanel",frame)
    two:Dock(LEFT)
    two:SetSize(w*0.15)
    two:DockPadding(w*0.01,h*0.01,0,h*0.01)
    two.Paint = nil
    local tbl = {}
    for k,v in ipairs(premakelvl) do
        local p = vgui.Create("DLabel",two)
        p:SetText(v)
        p:Dock(TOP)
        local entry
        if v ~= "Color" then
            entry = vgui.Create("DTextEntry",two)
            entry:Dock(TOP)
        else
            entry = vgui.Create("DColorMixer",two)
            entry:SetColor(Color(255,255,255))
            entry:SetPalette(false)
            entry:Dock(TOP)
            hex = vgui.Create("DTextEntry",two)
            hex:Dock(TOP)
            hex:SetPlaceholderText("Color Hex")
            function hex:OnEnter(value)
                entry:SetColor(Color(hexToLua(value)))
            end

        end
        tbl[v] = entry
    end
    local br = vgui.Create("DPanel",two)
    br:Dock(TOP)
    br.Paint = nil
    local update = vgui.Create("FButton",two)
    update:Dock(TOP)
    update:SetText("Update/Add New")
    function update:DoClick()
        local id = tbl["ID"]:GetValue()
        id = string.lower(id)
        local packeddata = {}
        for k,v in pairs(tbl) do

            if k == "Color" then
                packeddata[k] = tbl[k]:GetColor()
                continue
            end
            if tbl[k]:GetValue() == "" then continue end
            packeddata[k] = tbl[k]:GetValue()
            if k == "ID" then
                packeddata[k] = string.lower(packeddata[k])
            end
        end

        flibconfirm(frame,"Do you want to save changes in levels?",function()
            fstands.Config.Levels.Type[id] = packeddata
            PrintTable(fstands.Config.Levels.Type[id])
            levele:Update()
        end)
    end
    levele.OnRowSelected = function( lst, index, pnl )
        local index = pnl:GetColumnText(1)
        index = string.lower(index)
        local data = fstands.Config.Levels.Type[index]
        if data == true then tbl["ID"]:SetValue(index) end
        for k,v in pairs(tbl) do
            if k == "Color" then
                v:SetColor(Color(255,255,255))
            elseif k ~= "ID" then
                v:SetValue("")
            end
            if data == true then continue end
            if data[k] ~= nil then
                if k == "Color" then
                    v:SetColor(data[k])
                    continue
                end
                v:SetValue(data[k])
            end
        end
    end
    local conf = {}
    local tre = vgui.Create("DPanel",frame)
    tre:Dock(LEFT)
    tre:SetSize(w - w*0.35)
    tre:DockPadding(w*0.01,h*0.01,0,h*0.01)
    tre.Paint = nil
    for k,v in pairs(config) do
        local avalue = fstands.Config.Levels[k]
        local p = vgui.Create("DLabel",tre)
        p:SetText(v[2])
        p:Dock(TOP)
        local entry
        if v[1] == "float" then 
            entry = vgui.Create( "DNumSlider", tre )
            entry:SetMin(v[3])
            entry:SetMax(v[4])
            entry:SetDecimals(2)
        elseif v[1] == "bool" then
            local pan = vgui.Create("DPanel",tre)
            pan:Dock(TOP)
            pan.Paint = nil
            entry = vgui.Create("DCheckBox",pan)
            entry:Center()
        elseif v[1] == "group" then
            entry = vgui.Create("DListView",tre)
            entry:AddColumn("Group")
            entry:AddColumn("multiplier")
            entry:Dock(TOP)
            entry:SetSize(0,h*0.2)
            local pan = vgui.Create("DPanel",tre)
            pan:Dock(TOP)
            pan.Paint = nil
            local group = vgui.Create("DTextEntry",pan)
            group:Dock(LEFT)
            group:SetPlaceholderText("E.g. VIP or SuperAdmin")
            group:SetSize(w*0.2)
            function group:OnEnter(value)
                mult:RequestFocus()
            end
            local mult = vgui.Create("DTextEntry",pan)
            mult:Dock(RIGHT)
            mult:SetSize(w*0.2)
            mult:SetPlaceholderText("Number (0 0.5 2.3 8 etc)")
            mult:SetNumeric(true)
            function group:OnEnter(value)
                mult:RequestFocus()
            end
            function mult:OnEnter(value)
                if group:GetValue() == "" then
                    return
                end
                if mult:GetValue() == "" then
                    return
                end
                entry:AddLine(group:GetValue(),mult:GetValue())
            end
        end
        if v[1] ~= "group" and v[1] ~= "bool" then
            entry:SetValue(avalue)
            entry:Dock(TOP)
        elseif v[1] == "group" then
            for i,p in pairs(avalue) do
                entry:AddLine(i,p)
            end
        end
       
        
        conf[k] = entry
    end 
    local save = vgui.Create("FButton",tre)
    save:SetText("Save config")
    save:Dock(BOTTOM)
    function save:DoClick()
        local dane = {}
        dane.Type = fstands.Config.Levels.Type
        for k,v in pairs(conf) do
            
            if v:GetName() == "DListView" then 
                local t = {}
                for i,p in ipairs(v:GetLines()) do
                    t[p:GetValue( 1 )] = p:GetValue( 2 )
                end
                dane[k]=t
                continue
            end
            if v:GetName() == "DCheckBox" then 
                dane[k] = v:GetChecked() or false
                continue
            end
            dane[k] = v:GetValue()
        end
        local compresed = util.TableToJSON(dane)
        flibconfirm(frame,"Do you want to save changes in config?",function()
            net.Start("flvladmin")
                net.WriteBool(true)
                net.WriteString(compresed)
            net.SendToServer()
        end)
    end

end
--PATH lua/autorun/client/tfa_shared_convars.lua:
-- Toggle dynamic lighting on blaster bolts
if !ConVarExists("cl_dynamic_tracer") then
    CreateClientConVar("cl_dynamic_tracer", 1, true, false, "Enable/Disable dynamic lighting on Star Wars weapons")
end
--PATH lua/autorun/client/vj_menu_snpc.lua:
return gluapack()()
--PATH lua/vgui/bvgui/columnlayout.lua:
return gluapack()()
--PATH lua/vgui/bvgui/grid.lua:
local PANEL = {}

bVGUI.GRID_ALIGN_LEFT   = 0
bVGUI.GRID_ALIGN_CENTER = 1
bVGUI.GRID_ALIGN_RIGHT  = 2

function PANEL:Init()
	self.Items = {}
	self.ColumnPadding = 0
	self.RowPadding = 0
	self.Alignment = bVGUI.GRID_ALIGN_CENTER

	function self.pnlCanvas:PerformLayout()
		self:GetParent():LayoutItems()
	end

	self.BottomPadding = vgui.Create("bVGUI.BlankPanel", self)
	self.BottomPadding:Dock(BOTTOM)
	self.BottomPadding:SetTall(1)
end

function PANEL:SetAlignment(alignment)
	self.Alignment = alignment
end

function PANEL:SetPadding(c,r)
	self:SetColumnPadding(c)
	self:SetRowPadding(r)
end

function PANEL:SetColumnPadding(padding)
	self.ColumnPadding = padding
end

function PANEL:SetRowPadding(padding)
	self.RowPadding = padding
end

function PANEL:AddToGrid(item)
	table.insert(self.Items, item)
end

function PANEL:LayoutItems()
	self:CalculateGridSize()

	local columns = math.floor(self:GetWide() / self.MinColumnSize)
	local column_w = self:GetWide() / columns
	local column_i = 0
	local column_x = 0
	local row_y = 0
	for _,child in ipairs(self.Items) do
		if (self.Alignment == bVGUI.GRID_ALIGN_CENTER) then
			child:SetPos(column_x + (column_w / 2 - child:GetWide() / 2), row_y + (self.MinRowSize / 2 - child:GetTall() / 2))
		elseif (self.Alignment == bVGUI.GRID_ALIGN_LEFT) then
			child:SetPos(column_x, row_y + (self.MinRowSize / 2 - child:GetTall() / 2))
		elseif (self.Alignment == bVGUI.GRID_ALIGN_RIGHT) then
			child:SetPos(column_x + (column_w - child:GetWide()), row_y + (self.MinRowSize / 2 - child:GetTall() / 2))
		end
		column_x = column_x + column_w

		column_i = column_i + 1
		if (column_i >= columns) then
			column_i = 0
			column_x = 0
			row_y = row_y + self.MinRowSize + self.RowPadding
		end
	end

	self.BottomPadding:SetPos(0, row_y - 1)

	self:InvalidateLayout(true)
end

function PANEL:CalculateGridSize()
	local biggest_column = 0
	local biggest_row = 0
	for _,child in ipairs(self.Items) do
		if (child:GetWide() > biggest_column) then
			biggest_column = child:GetWide()
		end
		if (child:GetTall() > biggest_row) then
			biggest_row = child:GetTall()
		end
	end
	self.MinRowSize = biggest_row + (self.RowPadding * 2)
	self.MinColumnSize = biggest_column + (self.ColumnPadding * 2)
end

derma.DefineControl("bVGUI.Grid", nil, PANEL, "bVGUI.ScrollPanel")
--PATH lua/vgui/bvgui/option_selector.lua:
return gluapack()()
--PATH lua/vgui/bvgui/player_tooltip.lua:
return gluapack()()
--PATH lua/vgui/gas_workshop_item.lua:
local function L(phrase, ...)
	if (#({...}) == 0) then
		return GAS:Phrase(phrase, "workshop")
	else
		return GAS:PhraseFormat(phrase, "workshop", ...)
	end
end

file.CreateDir("gmodadminsuite/workshop")

local PANEL = {}

function PANEL:Init()
	self:SetMouseInputEnabled(true)
	self:SetCursor("hand")
	self:Dock(TOP)
	self:SetTall(105)
	self:SetLoading(true)

	self.ItemImage = vgui.Create("bVGUI.LoadingPanel", self)
	self.ItemImage:Dock(LEFT)
	self.ItemImage:SetMouseInputEnabled(false)
	self.ItemImage:DockPadding(10,10,10,10)
	self.ItemImage:SetLoading(false)
	self.ItemImage:SetWide(105)

		self.ItemImage.ImagePnl = vgui.Create("DImage", self.ItemImage)
		self.ItemImage.ImagePnl:Dock(FILL)

	self.Content = vgui.Create("bVGUI.BlankPanel", self)
	self.Content:Dock(FILL)
	self.Content:SetMouseInputEnabled(false)
	self.Content:DockPadding(0,10,10,10)

		self.Content.ItemName = vgui.Create("DLabel", self.Content)
		self.Content.ItemName:Dock(TOP)
		self.Content.ItemName:SetFont(bVGUI.FONT(bVGUI.FONT_RUBIK, "BOLD", 16))
		self.Content.ItemName:SetTextColor(bVGUI.COLOR_WHITE)
		self.Content.ItemName:SetContentAlignment(4)
		self.Content.ItemName:SetText("")

		self.Content.Description = vgui.Create("DLabel", self.Content)
		self.Content.Description:Dock(FILL)
		self.Content.Description:SetFont(bVGUI.FONT(bVGUI.FONT_RUBIK, "REGULAR", 14))
		self.Content.Description:SetTextColor(bVGUI.COLOR_WHITE)
		self.Content.Description:SetContentAlignment(7)
		self.Content.Description:SetText("")
		self.Content.Description:SetWrap(true)
end

function PANEL:OnMouseReleased(m)
	if (m ~= MOUSE_LEFT) then return end
	local menu = DermaMenu()

	menu:AddOption(L"copy_item_id", function()
		GAS:SetClipboardText(self.ItemInfo.publishedfileid)
	end):SetIcon("icon16/page_copy.png")

	local open_workshop_page, _ = menu:AddSubMenu(L"open_workshop_page") _:SetIcon("materials/gmodadminsuite/steam.png")

		open_workshop_page:AddOption(L"steam_browser", function()
			GAS:OpenURL("https://steamcommunity.com/sharedfiles/filedetails/?id=" .. self.ItemInfo.publishedfileid)
		end):SetIcon("materials/gmodadminsuite/steam.png")

		open_workshop_page:AddOption(L"copy_link", function()
			GAS:SetClipboardText("https://steamcommunity.com/sharedfiles/filedetails/?id=" .. self.ItemInfo.publishedfileid)
		end):SetIcon("icon16/page_copy.png")

	menu:AddOption(L"open_creator_profile", function()
		GAS:OpenURL("https://steamcommunity.com/profiles/" .. self.ItemInfo.creator)
	end):SetIcon("icon16/user_gray.png")

	menu:Open()
end

function PANEL:SetItemInfo(item_info)
	self.ItemInfo = item_info
	self.ItemID = tonumber(item_info.publishedfileid)

	self.Content.ItemName:SetText(item_info.title or L"error")
	self.Content.ItemName:SizeToContentsY()

	self.Content.Description:SetText(item_info.description or L"error")

	if (file.Read("gmodadminsuite/workshop/" .. item_info.publishedfileid .. ".png", "DATA")) then
		self.ItemImage:SetLoading(false)
		self.ItemImage.ImagePnl:SetImage("data/gmodadminsuite/workshop/" .. item_info.publishedfileid .. ".png")
	else
		self.ItemImage:SetLoading(true)
		http.Fetch(item_info.preview_url, function(body, len, headers, code)
			self.ItemImage:SetLoading(false)
			if (len > 0 and code == 200) then
				file.Write("gmodadminsuite/workshop/" .. item_info.publishedfileid .. ".png", body)
				self.ItemImage.ImagePnl:SetImage("data/gmodadminsuite/workshop/" .. item_info.publishedfileid .. ".png")
			else
				self.ItemImage.ImagePnl:SetImage("missing")
			end
		end)
	end
end

function PANEL:Paint(w,h)
	surface.SetDrawColor(40,64,87)
	surface.DrawRect(0,0,w,h)

	surface.SetMaterial(bVGUI.MATERIAL_GRADIENT_LIGHT)
	surface.DrawTexturedRect(0,0,w,h)
end

derma.DefineControl("GAS.Workshop.Item", nil, PANEL, "bVGUI.LoadingPanel")
--PATH lua/vgui/openpermissions_addon.lua:
local function markup_Escape(str)
	return (tostring(str):gsub("&", "&amp;"):gsub("<", "&lt;"):gsub(">", "&gt;"))
end

local PANEL = {}

function PANEL:Init()
	self:SetText("")
end

function PANEL:GenerateMarkup(text, maxwidth)
	self.Addon.Markup = markup.Parse("<color=255,255,255>" .. markup_Escape(text) .. "</color>", maxwidth)
end

function PANEL:Setup(id, options)
	self.Addon = {}

	self.Addon.Name = options.Name or id
	self.Addon.Color = options.Color or OpenPermissions.COLOR_BLACK

	if (options.Logo and options.Logo.Path and options.Logo.Width and options.Logo.Height) then
		self.Addon.Logo = {
			Material = Material(options.Logo.Path),
			Width = options.Logo.Width / 2,
			Height = options.Logo.Height / 2
		}
	end
end

function PANEL:Paint(w,h)
	derma.SkinHook("Paint", "Button", self, w, h)

	if (not self.Addon) then return end

	surface.SetDrawColor(self.Addon.Color)
	surface.DrawRect(5, 5, w - 10, h - 10)

	if (self.Addon.Logo) then
		local x,y = w / 2 - self.Addon.Logo.Width / 2, h / 2 - self.Addon.Logo.Height / 2
		surface.SetDrawColor(255,255,255)
		surface.SetMaterial(self.Addon.Logo.Material)
		surface.DrawTexturedRect(x, y, self.Addon.Logo.Width, self.Addon.Logo.Height)
	elseif (self.Addon.Markup) then
		self.Addon.Markup:Draw(w / 2, h / 2, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
	else
		self:GenerateMarkup(self.Addon.Name, w - 20)
	end
end

derma.DefineControl("OpenPermissions.Addon", nil, PANEL, "DButton")
--PATH lua/vgui/openpermissions_combobox.lua:
return gluapack()()
--PATH lua/vgui/openpermissions_scrollpanel.lua:
local PANEL = {}

function PANEL:Init()
	self.CurrentOffset = 0
	self.TargetOffset = 0
	self.StartTime = 0
	self.EndTime = 0

	self.VBar:SetHideButtons(true)
	self.VBar:SetWide(5)
	self.VBar:DockMargin(3,3,3,3)

	function self.VBar:Paint() end
	function self.VBar.btnGrip:Paint(w,h)
		surface.SetDrawColor(0,0,0,150)
		surface.DrawRect(0,0,w,h)
	end

	self.VBar.CurrentY = 0
	self.VBar.TargetY = 0
	function self.VBar:PerformLayout()

		local Wide = self:GetWide()
		local BtnHeight = Wide
		if ( self:GetHideButtons() ) then BtnHeight = 0 end
		local Scroll = self:GetScroll() / self.CanvasSize
		local BarSize = math.max( self:BarScale() * ( self:GetTall() - ( BtnHeight * 2 ) ), 10 )
		local Track = self:GetTall() - ( BtnHeight * 2 ) - BarSize
		Track = Track + 1

		Scroll = Scroll * Track

		self.TargetY = BtnHeight + Scroll
		self.btnGrip:SetSize( Wide, BarSize )

		if ( BtnHeight > 0 ) then
			self.btnUp:SetPos( 0, 0, Wide, Wide )
			self.btnUp:SetSize( Wide, BtnHeight )

			self.btnDown:SetPos( 0, self:GetTall() - BtnHeight )
			self.btnDown:SetSize( Wide, BtnHeight )
			
			self.btnUp:SetVisible( true )
			self.btnDown:SetVisible( true )
		else
			self.btnUp:SetVisible( false )
			self.btnDown:SetVisible( false )
			self.btnDown:SetSize( Wide, BtnHeight )
			self.btnUp:SetSize( Wide, BtnHeight )
		end

	end

	function self.VBar:Think()
		self.CurrentY = Lerp(FrameTime() * 10, self.CurrentY, self.TargetY)
		self.btnGrip:SetPos(0, math.Round(self.CurrentY))
	end

	self.pnlCanvas.CurrentOffset = 0
	self.pnlCanvas.TargetOffset = 0
	function self.pnlCanvas:Think()
		self.CurrentOffset = Lerp(FrameTime() * 10, self.CurrentOffset, self.TargetOffset)
		self:SetPos(0, math.Round(self.CurrentOffset))
	end
end

function PANEL:OnVScroll(offset)
	self.pnlCanvas.TargetOffset = offset
end

function PANEL:PerformLayoutInternal()

	local Tall = self.pnlCanvas:GetTall()
	local Wide = self:GetWide()
	local YPos = 0

	self:Rebuild()

	self.VBar:SetUp( self:GetTall(), self.pnlCanvas:GetTall() )
	YPos = self.VBar:GetOffset()

	if ( self.VBar.Enabled ) then Wide = Wide - self.VBar:GetWide() end

	self.pnlCanvas:SetPos( 0, YPos )
	self.pnlCanvas:SetWide( Wide + self.VBar:GetWide() )

	self:Rebuild()

	if ( Tall != self.pnlCanvas:GetTall() ) then
		self.VBar:SetScroll( self.VBar:GetScroll() ) -- Make sure we are not too far down!
	end

end

derma.DefineControl("OpenPermissions.ScrollPanel", nil, PANEL, "DScrollPanel")
--PATH lua/vgui/openpermissions_tooltip.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/gamemode/config/config.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/gamemode/libraries/tablecheck.lua:
--[[
tablecheck

WIP

Author: FPtje Falco

Purpose:
Allow validating tables by creating schemas of tables. Inspired by Joi (https://github.com/hapijs/joi)

Requires fn library (https://github.com/FPtje/GModFunctional),

Example:
```lua
local schema = tc.checkTable{
    name   = tc.addHint(isstring, "The name must be a string!"),
    id     = tc.addHint(isnumber, "The id must be a number!"),
    gender = tc.addHint(tc.oneOf{"male", "female", "carp"}, "Gender missing or not recognised!", {"Perhaps you are a carp?"}),
}

local correct, err, hints = schema({name = "Dick", id = 3, gender = "carp"})
print(correct) -- true


local correct, err, hints = schema({name = "Dick", id = 3, gender = "crap"})
print(correct) -- false
print(err) -- Gender missing or not recognised!
PrintTable(hints) -- {"Perhaps you are a carp?"}
```

For further examples, including nesting and combining of schemas, please see the `unitTests` function for now.
--]]

module("tc", package.seeall)

-- Helpers for quick access to metatables
angle                  = FindMetaTable("Angle")
convar                 = FindMetaTable("ConVar")
effectdata             = FindMetaTable("CEffectData")
entity                 = FindMetaTable("Entity")
file                   = FindMetaTable("File")
imaterial              = FindMetaTable("IMaterial")
irestore               = FindMetaTable("IRestore")
isave                  = FindMetaTable("ISave")
itexture               = FindMetaTable("ITexture")
lualocomotion          = FindMetaTable("CLuaLocomotion")
movedata               = FindMetaTable("CMoveData")
navarea                = FindMetaTable("CNavArea")
navladder              = FindMetaTable("CNavLadder")
nextbot                = FindMetaTable("NextBot")
npc                    = FindMetaTable("NPC")
pathfollower           = FindMetaTable("PathFollower")
physobj                = FindMetaTable("PhysObj")
player                 = FindMetaTable("Player")
recipientfilter        = FindMetaTable("CRecipientFilter")
soundpatch             = FindMetaTable("CSoundPatch")
takedamageinfo         = FindMetaTable("CTakeDamageInfo")
usercmd                = FindMetaTable("CUserCmd")
vector                 = FindMetaTable("Vector")
vehicle                = FindMetaTable("Vehicle")
vmatrix                = FindMetaTable("VMatrix")
weapon                 = FindMetaTable("Weapon")

-- Assert function, asserts a property and returns the error if false.
-- Allows f to override err and hints by simply returning them
addHint = function(f, err, hints) return function(...)
    local res = {f(...)}
    res[2] = err
    res[3] = hints

    return unpack(res)
end end

--[[ Validates a table against a schema
Capable of nesting
--]]
function checkTable(schema)
    return function(tbl)
        if not istable(tbl) then
            return false, "Not a table!"
        end

        for k, v in pairs(schema or {}) do
            local correct, err, hints = tbl[v] ~= nil
            if isfunction(v) then correct, err, hints, replace, replaceWith = v(tbl[k], tbl) end


            if not correct then
                err = err or string.format("Element '%s' is corrupt!", k)
                return correct, err, hints
            end

            -- Update the value
            if correct and replace == true and replaceWith then
                tbl[k] = replaceWith
            end
        end

        return true
    end
end

-- Returns whether a value is nil
isnil = fn.Curry(fn.Eq, 2)(nil)

-- Returns whether a value is a color
iscolor = IsColor

-- Returns true on the client
client = function() return CLIENT end

-- returns true on the server
server = function() return SERVER end

-- Optional value, when filled in it must meet the conditions
optional = function(...) return fn.FOr{isnil, ...} end

-- Default value, implies optional. Only works in combination with tc.checkTable
-- Note that the tc.addHint is to be the second parameter of default.
--      tc.addHint(tc.default(x)) does NOT work, default(x, tc.addHint(...)) does.
-- example: tc.checkTable{test = tc.default(3, tc.addHint(isnumber, "must be a number"))}
-- example: tc.checkTable{test = tc.default(3)}
default = function(def, f)
    return function(val, ...)
        if val == nil then
            -- second return value is the default value. Expects parent function to actually change the value
            return true, nil, nil, true, def
        end
        -- Return in if statement rather than "return f and f(val) or true" to allow multiple return values
        if f then return f(val, ...) else return true end
    end
end

-- A table of which each element must meet condition f
-- i.e. "this must be a table of xxx"
-- example: tc.tableOf(isnumber) demands that the table contains only numbers
tableOf = function(f) return function(tbl, parentTbl)
    if not istable(tbl) then return false end
    for _, v in pairs(tbl) do
        local res = {f(v, parentTbl)}
        if not res[1] then
            return unpack(res)
        end
    end

    return true
end end

-- Checks whether a value is amongst a given set of values
-- exapmle: tc.oneOf{"jobs", "entities", "shipments", "weapons", "vehicles", "ammo"}
oneOf = function(f) return fp{table.HasValue, f} end

-- A table that is non-empty, also useful for wrapping around tableOf
-- example: tc.nonEmpty(tc.tableOf(isnumber))
-- example: tc.nonEmpty() -- just checks that the table is non-empty
nonEmpty = function(f) return function(tbl, parentTbl)
    if not istable(tbl) or table.IsEmpty(tbl) then return false end
    if not f then return true end
    return f(tbl, parentTbl)
end end

-- Number check: minimum
min = function(n) return fn.FAnd{isnumber, fp{fn.Lte, n}} end

-- Number check: maximum
max = function(n) return fn.FAnd{isnumber, fp{fn.Gte, n}} end

-- Number check: positive
positive = min(0)

-- Number check: negative
negative = max(0)


-- Whether the input matches regex
-- Note: uses string.match, so it doesn't support full regex.
-- May also allow numbers, since string.match also accepts numbers.
-- Note, also matches on substrings. Use ^pattern$ for a full match.
regex = function(pattern, startpos) return function(val)
    return (isstring(val) or isnumber(val)) and tobool(string.match(val, pattern, startpos))
end end

-- Requires that the value only contains alphanumeric characters
alphanum = regex("^[a-zA-Z0-9]+$")


-- Test cases. Also serve as nice examples
function unitTests()
    local id = 0

    -- unit test helper functions
    local function checkCorrect(correct, err, hints)
        id = id + 1

        if correct ~= true then
            print(id, "Incorrect value that should be correct!", correct, err, hints)
            if hints then PrintTable(hints) end
            return
        end

        print(id, "Correct")
    end

    local function checkIncorrect(correct, err, hints)
        id = id + 1

        if correct then
            print(id, "Correct value that should be incorrect!", correct, err, hints)
            if hints then PrintTable(hints) end
            return
        end

        print(id, "Correct")
    end

    --[[
    Simple value schema. Checks whether the input is a number.
    ]]
    local simpleSchema = tc.addHint(isnumber, "Must be a number!")

    -- This is how a schema is to be used. Just call it with the value you want to check.
    -- In further unit tests, the schema function is immediately called inside the checkCorrect/checIncorrect call for brevity
    local correct, err, hints = simpleSchema(3)

    checkCorrect(correct, err, hints)


    --[[
    Simple table schema
    ]]
    local simpleTableSchema = tc.checkTable{
        name        = tc.addHint(isstring, "The name must be a string!"),
        id          = tc.addHint(isnumber, "The id must be a number!"),
        gender      = tc.addHint(tc.oneOf{"male", "female", "carp"}, "Gender missing or not recognised!", {"Perhaps you are a carp?"}),
        nilthing    = tc.addHint(tc.isnil, "nilthing must be nil"),
        nonEmpty    = tc.addHint(tc.nonEmpty(tc.tableOf(isnumber)), "nonEmpty not table of numbers"),
        optnum      = tc.addHint(tc.optional(isnumber), "optnum given, but not a number"),
        strnum      = tc.addHint(fn.FOr{isstring, isnumber}, "strnum must either be a string or a number"),
        minmax      = tc.addHint(fn.FAnd{tc.min(5), tc.max(10)}),
        pos         = tc.addHint(tc.optional(tc.positive)),
        regx        = tc.addHint(tc.optional(tc.regex("[a-z]+"))),
        letters     = tc.addHint(tc.optional(tc.alphanum)),
    }

    checkCorrect(simpleTableSchema({name = "Dick", id = 3, gender = "carp", nonEmpty = {1,2,3}, strnum = "str", minmax = 5, regx = "asdf", letters = "asdfj", pos = 3}))

    -- Counterexamples, should throw errors
    local badTables = {
        {},
        {name = 1, id = 3, gender = "carp", nonEmpty = {1,2,3}, strnum = "str", minmax = 7},
        {name = "Dick", id = "3", gender = "carp", nonEmpty = {1,2,3}, strnum = "str", minmax = 7},
        {name = "Dick", id = 3, gender = "other", nonEmpty = {1,2,3}, strnum = "str", minmax = 7},
        {name = "Dick", id = 3, gender = "carp", nonEmpty = {}, strnum = "str", minmax = 7},
        {name = "Dick", id = 3, gender = "carp", nonEmpty = {1,2,3}, strnum = {}, minmax = 7},
        {name = "Dick", id = 3, gender = "carp", nonEmpty = {1,2,3}, strnum = "str", optnum = "nope", minmax = 7},
        {name = "Dick", id = 3, gender = "carp", nonEmpty = {1,2,3}, strnum = "str", minmax = 4},
        {name = "Dick", id = 3, gender = "carp", nonEmpty = {1,2,3}, strnum = "str", minmax = 11},
        {name = "Dick", id = 3, gender = "carp", nonEmpty = {1,2,3}, strnum = "str"},
        {name = "Dick", id = 3, gender = "carp", nonEmpty = {1,2,3}, strnum = "str", minmax = 7, regx = "666"},
        {name = "Dick", id = 3, gender = "carp", nonEmpty = {1,2,3}, strnum = "str", minmax = 7, regx = "asdf", letters = ">:D"},
        {name = "Dick", id = 3, gender = "carp", nonEmpty = {1,2,3}, strnum = "str", minmax = 7, regx = "asdf", letters = ">:D", pos = -1},
    }

    for _, tbl in pairs(badTables) do
        checkIncorrect(simpleTableSchema(tbl))
    end

    --[[
    Table Schema with no explicit keys
    ]]
    local nokeysSchema = tc.checkTable{
        tc.addHint(isstring, "The first value must be a string."),
        tc.addHint(isnumber, "The second value must be a number!"),
    }
    checkCorrect(nokeysSchema({"string", 3}))

    --[[
    Nested table schema
    ]]
    local nestedSchema = tc.checkTable{
        nested = tc.checkTable{
            val = tc.addHint(isnumber, "'val' must be a number!")
        }
    }

    checkCorrect(nestedSchema({nested = {val = 3}}))
    checkIncorrect(nestedSchema({}))

    --[[
    Combining schemas using the fn library
    ]]
    local andSchema = fn.FAnd{
        tc.checkTable{
            num = tc.addHint(isnumber, "num is not a number")
        },
        tc.checkTable{
            str = tc.addHint(isstring, "str is not a string")
        }
    }

    checkCorrect(andSchema({num = 1, str = "string!"}))
    checkIncorrect(andSchema({num = 1}))
    checkIncorrect(andSchema({str = "string!"}))

    local orSchema = fn.FOr{
        tc.checkTable{
            num = tc.addHint(isnumber, "num is not a number")
        },
        tc.checkTable{
            str = tc.addHint(isstring, "str is not a string")
        }
    }
    checkCorrect(orSchema({num = 1}))
    checkCorrect(orSchema({str = "string!"}))

    --[[
    Default value with a check
    ]]
    local withDefaultSchema = tc.checkTable{
        value = tc.default(10, tc.addHint(isnumber, "must be a number!"))
    }
    checkCorrect(withDefaultSchema({value = 30}))
    checkIncorrect(withDefaultSchema({value = "string"}))

    local empty = {}
    checkCorrect(withDefaultSchema(empty))
    if empty.value ~= 10 then
        print("Default did NOT set the value to 10!")
    else
        print("Default test OK!")
    end

    --[[
    Default value with no checks
    ]]
    local withDefaultNoCheck = tc.checkTable{
        value = tc.default(10)
    }
    checkCorrect(withDefaultNoCheck({}))
    checkCorrect(withDefaultNoCheck({value = "string"}))

    --[[
    Creating your own checker function that returns an error message
    When both the function and the tc.addHint define error messages, there's a conflict
    ]]
    local function customCheck(val)
        return false, "function error message", {"function hint"}
    end

    local customCheckSchema = tc.checkTable{
        value = tc.addHint(customCheck, "added error message", {"added hint"})
    }
    checkIncorrect(customCheckSchema{value = 1})
    checkIncorrect(customCheckSchema{})

    _, err, hints = customCheckSchema{value = 2}
    if err ~= "added error message" or hints[1] ~= "added hint" then
        print("Wrong conflict solution", err, hints[1])
    else
        print("Conflict solution OK!")
    end

    print("finished")
end

--PATH gamemodes/starwarsrp/gamemode/modules/medic/sh_interface.lua:
DarkRP.PLAYER.isMedic = DarkRP.stub{
    name = "isMedic",
    description = "Whether this player is a medic.",
    parameters = {
    },
    returns = {
        {
            name = "answer",
            description = "Whether this player is a medic.",
            type = "boolean"
        }
    },
    metatable = DarkRP.PLAYER
}

--PATH gamemodes/starwarsrp/gamemode/modules/hud/cl_interface.lua:
DarkRP.stub{
    name = "drawPlayerInfo",
    description = "Draw player info above a player's head (name, health job). Override this function to disable or change drawing behaviour in DarkRP.",
    parameters = {
    },
    returns = {
    },
    metatable = DarkRP.PLAYER
}

DarkRP.stub{
    name = "drawWantedInfo",
    description = "Draw the wanted info above a player's head. Override this to disable or change the drawing of wanted info above players' heads.",
    parameters = {
    },
    returns = {
    },
    metatable = DarkRP.PLAYER
}

--PATH gamemodes/starwarsrp/gamemode/config/licenseweapons.lua:
GM.NoLicense["weapon_physcannon"] = true
GM.NoLicense["weapon_physgun"] = true
GM.NoLicense["weapon_bugbait"] = true
GM.NoLicense["gmod_tool"] = true
GM.NoLicense["gmod_camera"] = true

--PATH gamemodes/starwarsrp/gamemode/modules/tipjar/cl_communication.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/gamemode/modules/playerscale/cl_playerscale.lua:
local function doScale(um)
    local ply = um:ReadEntity()
    local scale = um:ReadFloat()

    if not IsValid(ply) then return end
    ply:SetModelScale(scale, 1)
    ply:SetHull(Vector(-16, -16, 0), Vector(16, 16, 72 * scale))
end
usermessage.Hook("darkrp_playerscale", doScale)

--PATH gamemodes/starwarsrp/gamemode/modules/events/sh_events.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/gamemode/modules/darkrpmessages/cl_darkrpmessage.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/gamemode/modules/base/sh_commands.lua:
DarkRP.declareChatCommand{
    command = "rpname",
    description = "Set your RP name",
    delay = 1.5
}

DarkRP.declareChatCommand{
    command = "name",
    description = "Set your RP name",
    delay = 1.5
}

DarkRP.declareChatCommand{
    command = "nick",
    description = "Set your RP name",
    delay = 1.5
}

DarkRP.declareChatCommand{
    command = "buy",
    description = "Buy a pistol",
    delay = 1.5,
    condition = fn.FAnd {
        fn.Compose{fn.Curry(fn.GetValue, 2)("enablebuypistol"), fn.Curry(fn.GetValue, 2)("Config"), gmod.GetGamemode},
        fn.Compose{fn.Not, fn.Curry(fn.GetValue, 2)("noguns"), fn.Curry(fn.GetValue, 2)("Config"), gmod.GetGamemode}
    }
}

DarkRP.declareChatCommand{
    command = "buyshipment",
    description = "Buy a shipment",
    delay = 1.5
}

DarkRP.declareChatCommand{
    command = "buyvehicle",
    description = "Buy a vehicle",
    delay = 1.5
}

DarkRP.declareChatCommand{
    command = "buyammo",
    description = "Purchase ammo",
    delay = 1.5,
    condition = fn.Compose{fn.Not, fn.Curry(fn.GetValue, 2)("noguns"), fn.Curry(fn.GetValue, 2)("Config"), gmod.GetGamemode}
}

DarkRP.declareChatCommand{
    command = "price",
    description = "Set the price of the microwave or gunlab you're looking at",
    delay = 1.5
}

DarkRP.declareChatCommand{
    command = "setprice",
    description = "Set the price of the microwave or gunlab you're looking at",
    delay = 1.5
}

DarkRP.declareChatCommand{
    command = "forcerpname",
    description = "Forcefully change a player's RP name",
    delay = 0.5,
    tableArgs = true
}

DarkRP.declareChatCommand{
    command = "freerpname",
    description = "Remove a RP name from the database so a player can use it",
    delay = 1.5
}

--PATH gamemodes/starwarsrp/gamemode/modules/base/cl_fonts.lua:
--[[---------------------------------------------------------------------------
The fonts that DarkRP uses
---------------------------------------------------------------------------]]
local function loadFonts()
    surface.CreateFont("DarkRPHUD1", {
        size = 20,
        weight = 600,
        antialias = true,
        shadow = true,
        font = "Roboto",
        extended = true,
    })

    surface.CreateFont("DarkRPHUD2", {
        size = 23,
        weight = 400,
        antialias = true,
        shadow = false,
        font = "Roboto",
        extended = true,
    })

    surface.CreateFont("Roboto20", {
        size = 20,
        weight = 600,
        antialias = true,
        shadow = false,
        font = "Roboto",
        extended = true,
    })

    surface.CreateFont("Trebuchet18", {
        size = 18,
        weight = 500,
        antialias = true,
        shadow = false,
        font = "Trebuchet MS",
        extended = true,
    })

    surface.CreateFont("Trebuchet20", {
        size = 20,
        weight = 500,
        antialias = true,
        shadow = false,
        font = "Trebuchet MS",
        extended = true,
    })

    surface.CreateFont("Trebuchet24", {
        size = 24,
        weight = 500,
        antialias = true,
        shadow = false,
        font = "Trebuchet MS",
        extended = true,
    })

    surface.CreateFont("Trebuchet48", {
        size = 48,
        weight = 500,
        antialias = true,
        shadow = false,
        font = "Trebuchet MS",
        extended = true,
    })

    surface.CreateFont("TabLarge", {
        size = 18,
        weight = 700,
        antialias = true,
        shadow = false,
        font = "Roboto",
        extended = true,
    })

    surface.CreateFont("UiBold", {
        size = 16,
        weight = 800,
        antialias = true,
        shadow = false,
        font = "Verdana",
        extended = true,
    })

    surface.CreateFont("HUDNumber5", {
        size = 30,
        weight = 800,
        antialias = true,
        shadow = false,
        font = "Verdana",
        extended = true,
    })

    surface.CreateFont("ScoreboardHeader", {
        size = 32,
        weight = 500,
        antialias = true,
        shadow = false,
        font = "Roboto",
        extended = true,
    })

    surface.CreateFont("ScoreboardSubtitle", {
        size = 22,
        weight = 500,
        antialias = true,
        shadow = false,
        font = "Roboto",
        extended = true,
    })

    surface.CreateFont("ScoreboardPlayerName", {
        size = 19,
        weight = 500,
        antialias = true,
        shadow = false,
        font = "Roboto",
        extended = true,
    })

    surface.CreateFont("ScoreboardPlayerName2", {
        size = 15,
        weight = 500,
        antialias = true,
        shadow = false,
        font = "Roboto",
        extended = true,
    })

    surface.CreateFont("ScoreboardPlayerNameBig", {
        size = 22,
        weight = 500,
        antialias = true,
        shadow = false,
        font = "Roboto",
        extended = true,
    })

    surface.CreateFont("AckBarWriting", {
        size = 20,
        weight = 500,
        antialias = true,
        shadow = false,
        font = "Akbar",
        extended = true,
    })

    surface.CreateFont("DarkRP_tipjar", {
        size = 100,
        weight = 500,
        antialias = true,
        shadow = true,
        font = "Verdana",
        extended = true,
    })
end
loadFonts()
--PATH gamemodes/starwarsrp/gamemode/config/ammotypes.lua:
return gluapack()()
--PATH addons/!jobs/lua/darkrp_language/english.lua:
--[[-----------------------------------------------------------------------
English (example) language file
---------------------------------------------------------------------------

This is the english language file. The things on the left side of the equals sign are the things you should leave alone
The parts between the quotes are the parts you should translate. You can also copy this file and create a new language.

= Warning =
Sometimes when DarkRP is updated, new phrases are added.
If you don't translate these phrases to your language, it will use the English sentence.
To fix this, join your server, open your console and enter darkp_getphrases yourlanguage
For English the command would be:
    darkrp_getphrases "en"
because "en" is the language code for English.

You can copy the missing phrases to this file and translate them.

= Note =
Make sure the language code is right at the bottom of this file

= Using a language =
Make sure the convar gmod_language is set to your language code. You can do that in a server CFG file.
---------------------------------------------------------------------------]]

local my_language = {
    -- Admin things
    need_admin = "You need admin privileges in order to be able to %s",
    need_sadmin = "You need super admin privileges in order to be able to %s",
    no_privilege = "You don't have the right privileges to perform this action",
    no_jail_pos = "No jail position",
    invalid_x = "Invalid %s! %s",

    -- F1 menu
    f1ChatCommandTitle = "Chat commands",
    f1Search = "Search...",

    -- Money things:
    price = "Price: %s%d",
    priceTag = "Price: %s",
    reset_money = "%s has reset all players' money!",
    has_given = "%s has given you %s",
    you_gave = "You gave %s %s",
    npc_killpay = "%s for killing an NPC!",
    profit = "profit",
    loss = "loss",
    Donate = "Donate",
    you_donated = "You have donated %s to %s!",
    has_donated = "%s has donated %s!",

    -- backwards compatibility
    deducted_x = "Deducted %s%d",
    need_x = "Need %s%d",

    deducted_money = "Deducted %s",
    need_money = "Need %s",

    payday_message = "Payday! You received %s!",
    payday_unemployed = "You received no salary because you are unemployed!",
    payday_missed = "Pay day missed! (You're Arrested)",

    property_tax = "Property tax! %s",
    property_tax_cant_afford = "You couldn't pay the taxes! Your property has been taken away from you!",
    taxday = "Tax Day! %s%% of your income was taken!",

    found_cheque = "You have found %s%s in a cheque made out to you from %s.",
    cheque_details = "This cheque is made out to %s.",
    cheque_torn = "You have torn up the cheque.",
    cheque_pay = "Pay: %s",
    signed = "Signed: %s",

    found_cash = "You have picked up %s%d!", -- backwards compatibility
    found_money = "You have picked up %s!",

    owner_poor = "The %s owner is too poor to subsidize this sale!",

    -- Police
    Wanted_text = "Wanted!",
    wanted = "Wanted by Police!\nReason: %s",
    youre_arrested = "You have been arrested. Time left: %d seconds!",
    youre_arrested_by = "You have been arrested by %s.",
    youre_unarrested_by = "You were unarrested by %s.",
    hes_arrested = "%s has been arrested for %d seconds!",
    hes_unarrested = "%s has been released from jail!",
    warrant_ordered = "%s ordered a search warrant for %s. Reason: %s",
    warrant_request = "%s requests a search warrant for %s\nReason: %s",
    warrant_request2 = "Search warrant request sent to Mayor %s!",
    warrant_approved = "Search warrant approved for %s!\nReason: %s\nOrdered by: %s",
    warrant_approved2 = "You are now able to search his house.",
    warrant_denied = "Mayor %s has denied your search warrant request.",
    warrant_expired = "The search warrant for %s has expired!",
    warrant_required = "You need a warrant in order to be able to open this door.",
    warrant_required_unfreeze = "You need a warrant in order to be able to unfreeze this prop.",
    warrant_required_unweld = "You need a warrant in order to be able to unweld this prop.",
    wanted_by_police = "%s is wanted by the police!\nReason: %s\nOrdered by: %s",
    wanted_by_police_print = "%s has made %s wanted, reason: %s",
    wanted_expired = "%s is no longer wanted by the Police.",
    wanted_revoked = "%s is no longer wanted by the Police.\nRevoked by: %s",
    cant_arrest_other_cp = "You cannot arrest other CPs!",
    must_be_wanted_for_arrest = "The player must be wanted in order to be able to arrest them.",
    cant_arrest_fadmin_jailed = "You cannot arrest a player who has been jailed by an admin.",
    cant_arrest_no_jail_pos = "You cannot arrest people since there are no jail positions set!",
    cant_arrest_spawning_players = "You cannot arrest players who are spawning.",

    suspect_doesnt_exist = "Suspect does not exist.",
    actor_doesnt_exist = "Actor does not exist.",
    get_a_warrant = "get a warrant",
    remove_a_warrant = "remove a warrant",
    make_someone_wanted = "make someone wanted",
    remove_wanted_status = "remove wanted status",
    already_a_warrant = "There already is a search warrant for this suspect.",
    not_warranted = "There is no search warrant for this person.",
    already_wanted = "The suspect is already wanted.",
    not_wanted = "The suspect is not wanted.",
    need_to_be_cp = "You have to be a member of the police force.",
    suspect_must_be_alive_to_do_x = "The suspect must be alive in order to %s.",
    suspect_already_arrested = "The suspect is already in jail.",

    -- Players
    health = "Health: %s",
    job = "Job: %s",
    salary = "Salary: %s%s",
    wallet = "Wallet: %s%s",
    weapon = "Weapon: %s",
    kills = "Kills: %s",
    deaths = "Deaths: %s",
    rpname_changed = "%s changed their RPName to: %s",
    disconnected_player = "Disconnected player",
    player = "player",

    -- Teams
    need_to_be_before = "You need to be %s first in order to be able to become %s",
    need_to_make_vote = "You need to make a vote to become a %s!",
    team_limit_reached = "Can not become %s as the limit is reached",
    wants_to_be = "%s\nwants to be\n%s",
    has_not_been_made_team = "%s has not been made %s!",
    job_has_become = "%s has been made a %s!",

    -- Disasters
    meteor_approaching = "WARNING: Meteor storm approaching!",
    meteor_passing = "Meteor storm passing.",
    meteor_enabled = "Meteor Storms are now enabled.",
    meteor_disabled = "Meteor Storms are now disabled.",
    earthquake_report = "Earthquake reported of magnitude %sMw",
    earthtremor_report = "Earth tremor reported of magnitude %sMw",

    -- Keys, vehicles and doors
    keys_allowed_to_coown = "You are allowed to co-own this\n(Press Reload with keys or press F2 to co-own)\n",
    keys_other_allowed = "Allowed to co-own:",
    keys_allow_ownership = "(Press Reload with keys or press F2 to allow ownership)",
    keys_disallow_ownership = "(Press Reload with keys or press F2 to disallow ownership)",
    keys_owned_by = "Owned by:",
    keys_unowned = "Unowned\n(Press Reload with keys or press F2 to own)",
    keys_everyone = "(Press Reload with keys or press F2 to enable for everyone)",
    door_unown_arrested = "You can not own or unown things while arrested!",
    door_unownable = "This door cannot be owned or unowned!",
    door_sold = "You have sold this for %s",
    door_already_owned = "This door is already owned by someone!",
    door_cannot_afford = "You can not afford this door!",
    door_hobo_unable = "You can not buy a door if you are a hobo!",
    vehicle_cannot_afford = "You can not afford this vehicle!",
    door_bought = "You've bought this door for %s%s",
    vehicle_bought = "You've bought this vehicle for %s%s",
    door_need_to_own = "You need to own this door in order to be able to %s",
    door_rem_owners_unownable = "You can not remove owners if a door is non-ownable!",
    door_add_owners_unownable = "You can not add owners if a door is non-ownable!",
    rp_addowner_already_owns_door = "%s already owns (or is already allowed to own) this door!",
    add_owner = "Add owner",
    remove_owner = "Remove owner",
    coown_x = "Co-own %s",
    allow_ownership = "Allow ownership",
    disallow_ownership = "Disallow ownership",
    edit_door_group = "Edit door group",
    door_groups = "Door groups",
    door_group_doesnt_exist = "Door group does not exist!",
    door_group_set = "Door group set successfully.",
    sold_x_doors_for_y = "You have sold %d doors for %s%d!", -- backwards compatibility
    sold_x_doors = "You have sold %d doors for %s!",
    no_doors_owned = "You don't own any doors!",

    -- Entities
    drugs = "drugs",
    Drugs = "Drugs",
    drug_lab = "Drug Lab",
    gun_lab = "Gun Lab",
    any_lab = "any lab",
    gun = "gun",
    microwave = "Microwave",
    food = "food",
    Food = "Food",
    money_printer = "Money Printer",
    tip_jar = "Tip Jar",

    sign_this_letter = "Sign this letter",
    signed_yours = "Yours,",

    money_printer_exploded = "Your money printer has exploded!",
    money_printer_overheating = "Your money printer is overheating!",

    contents = "Contents: ",
    amount = "Amount: ",

    picking_lock = "Picking lock",

    cannot_pocket_x = "You cannot put this in your pocket!",
    cannot_pocket_gravgunned = "You cannot put this in your pocket: it is being held by a gravgun.",
    object_too_heavy = "This object is too heavy.",
    pocket_full = "Your pocket is full!",
    pocket_no_items = "Your pocket contains no items.",
    drop_item = "Drop item",

    bonus_destroying_entity = "destroying this illegal entity.",

    switched_burst = "Switched to burst-fire mode.",
    switched_fully_auto = "Switched to fully automatic fire mode.",
    switched_semi_auto = "Switched to semi-automatic fire mode.",

    keypad_checker_shoot_keypad = "Shoot a keypad to see what it controls.",
    keypad_checker_shoot_entity = "Shoot an entity to see which keypads are connected to it",
    keypad_checker_click_to_clear = "Right click to clear.",
    keypad_checker_entering_right_pass = "Entering the right password",
    keypad_checker_entering_wrong_pass = "Entering the wrong password",
    keypad_checker_after_right_pass = "after having entered the right password",
    keypad_checker_after_wrong_pass = "after having entered the wrong password",
    keypad_checker_right_pass_entered = "Right password entered",
    keypad_checker_wrong_pass_entered = "Wrong password entered",
    keypad_checker_controls_x_entities = "This keypad controls %d entities",
    keypad_checker_controlled_by_x_keypads = "This entity is controlled by %d keypads",
    keypad_on = "ON",
    keypad_off = "OFF",
    seconds = "seconds",

    persons_weapons = "%s's weapons:",
    returned_persons_weapons = "Returned %s's confiscated weapons.",
    no_weapons_confiscated = "%s had no weapons confiscated!",
    no_illegal_weapons = "%s had no weapons.",
    confiscated_these_weapons = "Confiscated these weapons:",
    checking_weapons = "Confiscating weapons",

    shipment_antispam_wait = "Please wait before spawning another shipment.",
    createshipment = "Create a shipment",
    splitshipment = "Split this shipment",
    shipment_cannot_split = "Cannot split this shipment.",

    -- Talking
    hear_noone = "No-one can hear you %s!",
    hear_everyone = "Everyone can hear you!",
    hear_certain_persons = "Players who can hear you %s: ",

    whisper = "whisper",
    yell = "yell",
    broadcast = "[Broadcast!]",
    radio = "radio",
    request = "(REQUEST!)",
    group = "(group)",
    demote = "(DEMOTE)",
    ooc = "OOC",
    radio_x = "Radio %d",

    talk = "talk",
    speak = "speak",

    speak_in_ooc = "speak in OOC",
    perform_your_action = "perform your action",
    talk_to_your_group = "talk to your group",

    channel_set_to_x = "Channel set to %s!",
    channel = "channel",

    -- Notifies
    disabled = "%s has been disabled! %s",
    gm_spawnvehicle = "spawn vehicles",
    gm_spawnsent = "spawn scripted entities (SENTs)",
    gm_spawnnpc = "spawn Non-Player Characters (NPCs)",
    see_settings = "Please see the DarkRP settings.",
    limit = "You have reached the %s limit!",
    have_to_wait = "You need to wait another %d seconds before using %s!",
    must_be_looking_at = "You need to be looking at a %s!",
    incorrect_job = "You do not have the right job to %s",
    unavailable = "This %s is unavailable",
    unable = "You are unable to %s. %s",
    cant_afford = "You cannot afford this %s",
    created_x = "%s created a %s",
    cleaned_up = "Your %s were cleaned up.",
    you_bought_x = "You have bought %s for %s%d.", -- backwards compatibility
    you_bought = "You have bought %s for %s.",
    you_got_yourself = "You got yourself a %s.",
    you_received_x = "You have received %s for %s.",

    created_first_jailpos = "You have created the first jail position!",
    added_jailpos = "You have added one extra jail position!",
    reset_add_jailpos = "You have removed all jail positions and you have added a new one here.",
    created_spawnpos = "You have added a spawn position for %s.",
    updated_spawnpos = "You have removed all spawn positions for %s and added a new one here.",
    remove_spawnpos = "You have removed all spawn positions for %s.",
    do_not_own_ent = "You do not own this entity!",
    cannot_drop_weapon = "Can't drop this weapon!",
    job_switch = "Jobs switched successfully!",
    job_switch_question = "Switch jobs with %s?",
    job_switch_requested = "Job switch requested.",
    switch_jobs = "switch jobs",

    cooks_only = "Cooks only.",

    -- Misc
    unknown = "Unknown",
    arguments = "arguments",
    no_one = "no one",
    door = "door",
    vehicle = "vehicle",
    door_or_vehicle = "door/vehicle",
    driver = "Driver: %s",
    name = "Name: %s",
    locked = "Locked.",
    unlocked = "Unlocked.",
    player_doesnt_exist = "Player does not exist.",
    job_doesnt_exist = "Job does not exist!",
    must_be_alive_to_do_x = "You must be alive in order to %s.",
    banned_or_demoted = "Banned/demoted",
    wait_with_that = "Wait with that.",
    could_not_find = "Could not find %s",
    f3tovote = "Hit F3 to vote",
    listen_up = "Listen up:", -- In rp_tell or rp_tellall
    nlr = "New Life Rule: Do Not Revenge Arrest/Kill.",
    reset_settings = "You have reset all settings!",
    must_be_x = "You must be a %s in order to be able to %s.",
    agenda = "agenda",
    agenda_updated = "The agenda has been updated",
    job_set = "%s has set their job to '%s'",
    demote_vote = "demote",
    demoted = "%s has been demoted",
    demoted_not = "%s has not been demoted",
    demote_vote_started = "%s has started a vote for the demotion of %s",
    demote_vote_text = "Demotion nominee:\n%s", -- '%s' is the reason here
    cant_demote_self = "You cannot demote yourself.",
    i_want_to_demote_you = "I want to demote you. Reason: %s",
    tried_to_avoid_demotion = "You tried to escape demotion. You failed and have been demoted.", -- naughty boy!
    lockdown_started = "The mayor has initiated a Lockdown, please return to your homes!",
    lockdown_ended = "The lockdown has ended",
    gunlicense_requested = "%s has requested %s a gun license",
    gunlicense_granted = "%s has granted %s a gun license",
    gunlicense_denied = "%s has denied %s a gun license",
    gunlicense_question_text = "Grant %s a gun license?",
    gunlicense_remove_vote_text = "%s has started a vote for the gun license removal of %s",
    gunlicense_remove_vote_text2 = "Revoke gunlicense:\n%s", -- Where %s is the reason
    gunlicense_removed = "%s's license has been removed!",
    gunlicense_not_removed = "%s's license has not been removed!",
    vote_specify_reason = "You need to specify a reason!",
    vote_started = "The vote has been created",
    vote_alone = "You have won the vote since you are alone in the server.",
    you_cannot_vote = "You cannot vote!",
    x_cancelled_vote = "%s cancelled the last vote.",
    cant_cancel_vote = "Could not cancel the last vote as there was no last vote to cancel!",
    jail_punishment = "Punishment for disconnecting! Jailed for: %d seconds.",
    admin_only = "Admin only!", -- When doing /addjailpos
    chief_or = "Chief or ",-- When doing /addjailpos
    frozen = "Frozen.",
    recipient = "recipient",
    forbidden_name = "Forbidden name.",
    illegal_characters = "Illegal characters.",
    too_long = "Too long.",
    too_short = "Too short.",

    dead_in_jail = "You now are dead until your jail time is up!",
    died_in_jail = "%s has died in jail!",

    credits_for = "CREDITS FOR %s\n",
    credits_see_console = "DarkRP credits printed to console.",

    rp_getvehicles = "Available vehicles for custom vehicles:",

    data_not_loaded_one = "Your data has not been loaded yet. Please wait.",
    data_not_loaded_two = "If this persists, try rejoining or contacting an admin.",

    cant_spawn_weapons = "You cannot spawn weapons.",
    drive_disabled = "Drive disabled for now.",
    property_disabled = "Property disabled for now.",

    not_allowed_to_purchase = "You are not allowed to purchase this item.",

    rp_teamban_hint = "rp_teamban [player name/ID] [team name/id]. Use this to ban a player from a certain team.",
    rp_teamunban_hint = "rp_teamunban [player name/ID] [team name/id]. Use this to unban a player from a certain team.",
    x_teambanned_y_for_z = "%s has banned %s from being a %s for %s minutes.",
    x_teamunbanned_y = "%s has unbanned %s from being a %s.",

    -- Backwards compatibility:
    you_set_x_salary_to_y = "You set %s's salary to %s%d.",
    x_set_your_salary_to_y = "%s set your salary to %s%d.",
    you_set_x_money_to_y = "You set %s's money to %s%d.",
    x_set_your_money_to_y = "%s set your money to %s%d.",

    you_set_x_salary = "You set %s's salary to %s.",
    x_set_your_salary = "%s set your salary to %s.",
    you_set_x_money = "You set %s's money to %s.",
    x_set_your_money = "%s set your money to %s.",
    you_set_x_name = "You set %s's name to %s",
    x_set_your_name = "%s set your name to %s",

    someone_stole_steam_name = "Someone is already using your Steam name as their RP name so we gave you a '1' after your name.", -- Uh oh
    already_taken = "Already taken.",

    job_doesnt_require_vote_currently = "This job does not require a vote at the moment!",

    x_made_you_a_y = "%s has made you a %s!",

    cmd_cant_be_run_server_console = "This command cannot be run from the server console.",

    -- The lottery
    lottery_started = "There is a lottery! Participate for %s%d?", -- backwards compatibility
    lottery_has_started = "There is a lottery! Participate for %s?",
    lottery_entered = "You entered the lottery for %s",
    lottery_not_entered = "%s did not enter the lottery",
    lottery_noone_entered = "No-one has entered the lottery",
    lottery_won = "%s has won the lottery! They have won %s",
    lottery = "lottery",
    lottery_please_specify_an_entry_cost = "Please specify an entry cost (%s-%s)",
    too_few_players_for_lottery = "There are too few players to start a lottery. There need to be at least %d players",
    lottery_ongoing = "Cannot start a lottery, there is already a lottery ongoing",

    -- Animations
    custom_animation = "Custom animation!",
    bow = "Bow",
    sexy_dance = "Sexy dance",
    follow_me = "Follow me!",
    laugh = "Laugh",
    lion_pose = "Lion pose",
    nonverbal_no = "Non-verbal no",
    thumbs_up = "Thumbs up",
    wave = "Wave",
    dance = "Dance",

    -- Hungermod
    starving = "Starving!",

    -- AFK
    afk_mode = "AFK Mode",
    unable_afk_spam_prevention = "Please wait before going AFK again.",
    salary_frozen = "Your salary has been frozen.",
    salary_restored = "Welcome back, your salary has now been restored.",
    no_auto_demote = "You will not be auto-demoted.",
    youre_afk_demoted = "You were demoted for being AFK for too long. Next time use /afk.",
    hes_afk_demoted = "%s has been demoted for being AFK for too long.",
    afk_cmd_to_exit = "Type /afk to exit AFK mode.",
    player_now_afk = "%s is now AFK.",
    player_no_longer_afk = "%s is no longer AFK.",

    -- Hitmenu
    hit = "hit",
    hitman = "Hitman",
    current_hit = "Hit: %s",
    cannot_request_hit = "Cannot request hit! %s",
    hitmenu_request = "Request",
    player_not_hitman = "This player is not a hitman!",
    distance_too_big = "Distance too big.",
    hitman_no_suicide = "The hitman won't kill themself.",
    hitman_no_self_order = "A hitman cannot order a hit for themself.",
    hitman_already_has_hit = "The hitman already has a hit ongoing.",
    price_too_low = "Price too low!",
    hit_target_recently_killed_by_hit = "The target was recently killed by a hit,",
    customer_recently_bought_hit = "The customer has recently requested a hit.",
    accept_hit_question = "Accept hit from %s\nregarding %s for %s%d?", -- backwards compatibility
    accept_hit_request = "Accept hit from %s\nregarding %s for %s?",
    hit_requested = "Hit requested!",
    hit_aborted = "Hit aborted! %s",
    hit_accepted = "Hit accepted!",
    hit_declined = "The hitman declined the hit!",
    hitman_left_server = "The hitman has left the server!",
    customer_left_server = "The customer has left the server!",
    target_left_server = "The target has left the server!",
    hit_price_set_to_x = "Hit price set to %s%d.", -- backwards compatibility
    hit_price_set = "Hit price set to %s.",
    hit_complete = "Hit by %s complete!",
    hitman_died = "The hitman died!",
    target_died = "The target has died!",
    hitman_arrested = "The hitman was arrested!",
    hitman_changed_team = "The hitman changed team!",
    x_had_hit_ordered_by_y = "%s had an active hit ordered by %s",
    place_a_hit = "place a hit!",
    hit_cancel = "hit cancellation!",
    hit_cancelled = "The hit was cancelled!",
    no_active_hit = "You have no active hit!",

    -- Vote Restrictions
    hobos_no_rights = "Hobos have no voting rights!",
    gangsters_cant_vote_for_government = "Gangsters cannot vote for government things!",
    government_cant_vote_for_gangsters = "Government officials cannot vote for gangster things!",

    -- VGUI and some more doors/vehicles
    vote = "Vote",
    time = "Time: %d",
    yes = "Yes",
    no = "No",
    ok = "Okay",
    cancel = "Cancel",
    add = "Add",
    remove = "Remove",
    none = "None",

    x_options = "%s options",
    sell_x = "Sell %s",
    set_x_title = "Set %s title",
    set_x_title_long = "Set the title of the %s you are looking at.",
    jobs = "Jobs",
    buy_x = "Buy %s",

    -- F4menu
    ammo = "ammo",
    weapon_ = "weapon",
    no_extra_weapons = "This job has no extra weapons.",
    become_job = "Become job",
    create_vote_for_job = "Create vote",
    shipment = "shipment",
    Shipments = "Shipments",
    shipments = "shipments",
    F4guns = "Weapons",
    F4entities = "Miscellaneous",
    F4ammo = "Ammo",
    F4vehicles = "Vehicles",

    -- Tab 1
    give_money = "Give money to the player you're looking at",
    drop_money = "Drop money",
    change_name = "Change your DarkRP name",
    go_to_sleep = "Go to sleep/wake up",
    drop_weapon = "Drop current weapon",
    buy_health = "Buy health(%s)",
    request_gunlicense = "Request gunlicense",
    demote_player_menu = "Demote a player",

    searchwarrantbutton = "Make a player wanted",
    unwarrantbutton = "Remove the wanted status from a player",
    noone_available = "No one available",
    request_warrant = "Request a search warrant for a player",
    make_wanted = "Make someone wanted",
    make_unwanted = "Make someone unwanted",
    set_jailpos = "Set the jail position",
    add_jailpos = "Add a jail position",

    set_custom_job = "Set a custom job (press enter to activate)",

    set_agenda = "Set the agenda (press enter to activate)",

    initiate_lockdown = "Initiate a lockdown",
    stop_lockdown = "Stop the lockdown",
    start_lottery = "Start a lottery",
    give_license_lookingat = "Give <lookingat> a gun license",

    laws_of_the_land = "LAWS OF THE LAND",
    law_added = "Law added.",
    law_removed = "Law removed.",
    law_reset = "Laws reset.",
    law_too_short = "Law too short.",
    laws_full = "The laws are full.",
    default_law_change_denied = "You are not allowed to change the default laws.",

    -- Second tab
    job_name = "Name: ",
    job_description = "Description: ",
    job_weapons = "Weapons: ",

    -- Entities tab
    buy_a = "Buy %s: %s",

    -- Licenseweaponstab
    license_tab = [[License weapons

    Tick the weapons people should be able to get WITHOUT a license!
    ]],
    license_tab_other_weapons = "Other weapons:",
}

-- The language code is usually (but not always) a two-letter code. The default language is "en".
-- Other examples are "nl" (Dutch), "de" (German)
-- If you want to know what your language code is, open GMod, select a language at the bottom right
-- then enter gmod_language in console. It will show you the code.
-- Make sure language code is a valid entry for the convar gmod_language.
DarkRP.addLanguage("en", my_language)

--PATH lua/weapons/alydus_fortificationbuildertablet.lua:
 --[[
 - Fortification Builder Tablet
 - 
 - /lua/weapons/alydus_fortificationbuildertablet.lua
 -
 - Primary weapon definition file, utilises meta functions defined in /lua/autorun/server/sv_alydusfortificationbuildertablet_meta.lua
 - 
 - Feel free to modify, but please leave appropriate credit.
 - Do not reupload this (modified or original) to this workshop, however you may ruin modified versions on your servers.
 - Assets included for fortifications Alydus does not own the rights to, so do as you wish, but its suggested you also leave appropriate credit.
 -
 - Thanks so much for the support with the addon since it's creation in 2018.
 -
 --]]

AddCSLuaFile()

if CLIENT then
	SWEP.PrintName = "Fortification Tablet"
	SWEP.Slot = 1
	SWEP.SlotPos = 1
	SWEP.DrawAmmo = false
	SWEP.DrawCrosshair = false

	surface.CreateFont("Alydus.FortificationsTablet.Title", {font = "Roboto Condensed", size = 50})
	surface.CreateFont("Alydus.FortificationsTablet.Subtitle", {font = "Roboto Condensed", size = 35})
	surface.CreateFont("Alydus.FortificationsTablet.TitleVM", {font = "Roboto Condensed", size = 60})
	surface.CreateFont("Alydus.FortificationsTablet.SubtitleVM", {font = "Roboto Condensed", size = 52})
	surface.CreateFont("Alydus.FortificationsTablet.HealthSubtitle", {font = "Roboto Condensed", size = 30})
	surface.CreateFont("Alydus.FortificationsTablet.HealthEmbeddedTitle", {font = "Roboto Condensed", size = 25})

	if GAMEMODE.IsSandboxDerived then
		language.Add("SBoxLimit_fortifications", "You've hit the Fortification limit!")
	end

	language.Add("Undone_Fortification", "Undone Fortification")

	language.Add("Cleanup_fortifications", "Fortifications")
	language.Add("Cleaned_fortifications", "Cleaned up all fortifications")
elseif SERVER then
	CreateConVar("sbox_maxfortifications", 10)
end

cleanup.Register("fortifications")

SWEP.Author = "Alydus"
SWEP.Instructions = "A utility weapon that allows the user to build fortifications."
SWEP.Contact = ""
SWEP.Purpose = ""
SWEP.Spawnable = true
SWEP.AdminOnly = false
SWEP.Category = "Alydus's Weapons"

SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"
SWEP.Primary.Delay = 3.5

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"
SWEP.Secondary.Delay = 3.5

SWEP.HoldType = "slam"
SWEP.ViewModelFOV = 65
SWEP.ViewModelFlip = false
SWEP.UseHands = false
SWEP.ViewModel = "models/weapons/v_grenade.mdl"
SWEP.WorldModel = "models/nirrti/tablet/tablet_sfm.mdl"
SWEP.ShowViewModel = true
SWEP.ShowWorldModel = true
SWEP.ViewModelBoneMods = {
	["ValveBiped.Grenade_body"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) }
}

SWEP.IronSightsPos = Vector(12.72, 0, 0.36)
SWEP.IronSightsAng = Vector(0, 0, 0)

-- Define fortifications
SWEP.Fortifications = {
	{name = "Sandbags Corner 1", model = "models/props_fortifications/sandbags_corner1.mdl"},
	{name = "Sandbags Corner 1 Tall", model = "models/props_fortifications/sandbags_corner1_tall.mdl"},
	{name = "Sandbags Corner 2", model = "models/props_fortifications/sandbags_corner2.mdl"},
	{name = "Sandbags Corner 2 Tall", model = "models/props_fortifications/sandbags_corner2_tall.mdl"},
	{name = "Sandbags Corner 3", model = "models/props_fortifications/sandbags_corner3.mdl"},
	{name = "Sandbags Line 1", model = "models/props_fortifications/sandbags_line1.mdl"},
	{name = "Sandbags Line 1 Tall", model = "models/props_fortifications/sandbags_line1_tall.mdl"},
	{name = "Sandbags Line 2", model = "models/props_fortifications/sandbags_line2.mdl"},
	{name = "Sandbags Line 2 Tall", model = "models/props_fortifications/sandbags_line2_tall.mdl"},
	{name = "Sandbags Line 3", model = "models/props_fortifications/sandbags_line2b.mdl"},
	{name = "Concrete Wall", model = "models/props_fortifications/concrete_wall001_96_reference.mdl"},
	{name = "Concrete Barrier 1", model = "models/props_c17/concrete_barrier001a.mdl"},
	{name = "Concrete Barrier 2 Small", model = "models/props_fortifications/concrete_barrier001_96_reference.mdl"},
	{name = "Concrete Barrier 2 Large", model = "models/props_fortifications/concrete_barrier001_128_reference.mdl"},
	{name = "Concrete Barrier 3", model = "models/jbarnes/props/concrete barricade.mdl"},
	{name = "Small Fence", model = "models/props_c17/fence01b.mdl"},
	{name = "Medium Fence", model = "models/props_c17/fence01a.mdl"},
	{name = "Large Fence", model = "models/props_c17/fence03a.mdl"},
	{name = "Small Anti-Climb Fence", model = "models/props_wasteland/exterior_fence002b.mdl",},
	{name = "Medium Anti-Climb Fence", model = "models/props_wasteland/exterior_fence002c.mdl"},
	{name = "Large Anti-Climb Fence", model = "models/props_wasteland/exterior_fence002d.mdl"},
	{name = "Police Barricade Single", model = "models/props_street/police_barricade.mdl"},
	{name = "Police Barricade Triple", model = "models/props_street/police_barricade2.mdl"},
	{name = "Hesco Small", model = "models/static_afghan/prop_fortification_hesco_small.mdl"},
	{name = "Hesco Tall", model = "models/iraq/ir_hesco_basket_01.mdl"},
	{name = "Hesco Tall Leaning", model = "models/iraq/ir_hesco_basket_01b.mdl"}
}

-- Setup developer add fortification hook
hook.Add("Alydus.FortificationBuilderTablet.AddFortification", "Alydus_FortificationBuilderTablet_AddFortificationHook", function(fortification)
	if fortification["name"] and fortification["model"] then
		table.insert(SWEP.Fortifications, fortification)
	else
		print("Invalid fortification data, failed to add fortification. Please include name, and model.")
	end
end)

-- Cache fortification models
SWEP.FortificationsModelList = {}

print("Caching fortifications models for builder tablet...")

for _, fortification in pairs(SWEP.Fortifications) do
	util.PrecacheModel(fortification["model"])
	table.insert(SWEP.FortificationsModelList, fortification["model"])
end

print("Fortifications models successfully cached.")

-- Define SWEP render elements
SWEP.VElements = {
	["tablet"] = { type = "Model", model = "models/nirrti/tablet/tablet_sfm.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(5.714, 6.714, -3.636), angle = Angle(29, 100, -127.403), size = Vector(0.95, 0.95, 0.95), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 1, bodygroup = {} }
}

SWEP.WElements = {
	["tablet"] = { type = "Model", model = "models/nirrti/tablet/tablet_sfm.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(6.513, 5.714, -2.597), angle = Angle(26.882, 113.376, -127.403), size = Vector(0.82, 0.82, 0.82), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 1, bodygroup = {} },
	["light"] = { type = "Sprite", sprite = "sprites/blueglow1", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(4.675, 1, -2.398), size = { x = 1.729, y = 1.729 }, color = Color(255, 255, 255, 255), nocull = true, additive = true, vertexalpha = true, vertexcolor = true, ignorez = false}
}

-- Setup networking for SWEP
function SWEP:SetupDataTables()
	self:NetworkVar("Bool", 0, "IsBootingUp")
	self:NetworkVar("Int", 0, "SelectedFortification")
end

if SERVER then
	resource.AddWorkshop("1461735659")
	
	-- Handle placing fortifications
	hook.Add("KeyPress", "Alydus_KeyPress_HandleBuildTabletHologramFinished", function(ply, key)
		if key == IN_USE and IsValid(ply) and ply:CanBuildAlydusFortification() then
			local fortificationClass = "prop_physics"
			
			if alydusDestructibleFortificationExtension then
				fortificationClass = "alydus_destructiblefortification"
			end

			local fortification = ents.Create(fortificationClass)
			fortification:SetAngles(Angle(0, ply:EyeAngles().y - 180, 0))

			if alydusDestructibleFortificationExtension then
				fortification:SetFortificationHealth(GetConVar("alydus_defaultfortificationhealth"):GetInt())
				fortification:SetMaximumFortificationHealth(GetConVar("alydus_defaultfortificationhealth"):GetInt())
			end

			fortification:SetModel(ply:GetActiveWeapon().Fortifications[ply:GetActiveWeapon():GetSelectedFortification()]["model"])
			fortification:Spawn()
			fortification:SetPos(ply:GetEyeTrace().HitPos - ply:GetEyeTrace().HitNormal * fortification:OBBMins().z)

			fortification:SetGravity(150)
			fortification.isPlayerPlacedFortification = ply

			if GAMEMODE.IsSandboxDerived then
				ply:AddCount("fortifications", fortification)
				ply:AddCleanup("fortifications", fortification)
			end

			fortification:EmitSound("physics/concrete/rock_impact_hard" .. math.random(1, 6) .. ".wav")

			local phys = fortification:GetPhysicsObject()
			if IsValid(phys) then
				phys:SetMass(50000)
				phys:EnableMotion(false)
			end

			local effectdata = EffectData()
			effectdata:SetOrigin(Vector(fortification:GetPos().x, fortification:GetPos().y, fortification:GetPos().z) + (fortification:GetUp() * fortification:OBBMaxs().z / 2))
			effectdata:SetMagnitude(3)
			effectdata:SetScale(5)
			effectdata:SetRadius(2)
			util.Effect("cball_explode", effectdata, true, true)

			undo.Create("Fortification")
				undo.AddEntity(fortification)
				undo.SetPlayer(ply)
			undo.Finish()
		end
	end)

	-- Handle tablet bootup and tablet shutdown
	hook.Add("PlayerSwitchWeapon", "Alydus_PlayerSwitchWeapon_FortificationBuilderTabletBootup", function(ply, oldWep, newWep)
		if newWep:GetClass() == "alydus_fortificationbuildertablet" and newWep:GetIsBootingUp() == false then
			newWep:SetIsBootingUp(true)

			ply:EmitSound("ambient/machines/thumper_startup1.wav")

			timer.Simple(2.5, function()
				if IsValid(ply) and newWep:GetIsBootingUp() == true and ply:HasWeapon("alydus_fortificationbuildertablet") then
					ply:EmitSound("npc/scanner/combat_scan4.wav")
					newWep:SetIsBootingUp(false)
					newWep:SetSelectedFortification(1)
				end
			end)
		elseif ply:HasWeapon("alydus_fortificationbuildertablet") and IsValid(oldWep) and oldWep:GetClass() == "alydus_fortificationbuildertablet" then
			ply:EmitSound("npc/roller/mine/combine_mine_deactivate1.wav")

			if ply.fortificationHologram != nil and IsValid(ply.fortificationHologram) then
				ply.fortificationHologram:Remove()
				ply.fortificationHologram = nil
			end
		end
	end)
else
	playerFortificationHolograms = playerFortificationHolograms or {}

	-- Handle clientside fortification holograms for every player
	hook.Add("Tick", "Alydus_Tick_DrawFortificationHolograms", function()
		for steamid64, fortificationHologram in pairs(playerFortificationHolograms) do
			if !IsValid(player.GetBySteamID64(steamid64)) then
				if IsValid(fortificationHologram) then
					fortificationHologram:Remove()
				end

				playerFortificationHolograms[steamid64] = nil
			end
		end

		for _, ply in ipairs(player.GetHumans()) do
			if IsValid(ply) and IsValid(ply:GetActiveWeapon()) and ply:GetActiveWeapon():GetClass() == "alydus_fortificationbuildertablet" and ply:GetActiveWeapon().Fortifications[ply:GetActiveWeapon():GetSelectedFortification()] then
				local tr = ply:GetEyeTrace()
				local wep = ply:GetActiveWeapon()
				local fortificationHologramAngles = Angle(0, ply:EyeAngles().y - 180, 0)
				local fortificationModel = wep.Fortifications[wep:GetSelectedFortification()]["model"]

				if !playerFortificationHolograms[ply:SteamID64()] or !IsValid(playerFortificationHolograms[ply:SteamID64()]) then
					playerFortificationHolograms[ply:SteamID64()] = ClientsideModel(fortificationModel)

					local fortificationHologram = playerFortificationHolograms[ply:SteamID64()]
					fortificationHologram:SetPos(tr.HitPos - tr.HitNormal * fortificationHologram:OBBMins().z)
					fortificationHologram:SetAngles(fortificationHologramAngles)
					fortificationHologram:SetRenderMode(RENDERMODE_TRANSALPHA)
					fortificationHologram:DrawShadow(false)
					fortificationHologram:Spawn()
					fortificationHologram.isAlydusFortificationHologram = true
				elseif IsValid(playerFortificationHolograms[ply:SteamID64()]) then
					local fortificationHologram = playerFortificationHolograms[ply:SteamID64()]

					if fortificationHologram:GetModel() != fortificationModel then
						fortificationHologram:SetModel(fortificationModel)
					end

					local visualPos = Lerp(20 * FrameTime(), fortificationHologram:GetPos(), (tr.HitPos - tr.HitNormal * fortificationHologram:OBBMins().z))
					local visualAngle = LerpAngle(20 * FrameTime(), fortificationHologram:GetAngles(), fortificationHologramAngles, 0)

					fortificationHologram:SetPos(visualPos)
					fortificationHologram:SetAngles(fortificationHologramAngles)

					if ply:CanDrawAlydusFortification() then
						fortificationHologram:SetColor(Color(46, 204, 113, 150))
					else
						fortificationHologram:SetColor(Color(255, 0, 0, 0))
					end
				end
			elseif playerFortificationHolograms[ply:SteamID64()] then
				playerFortificationHolograms[ply:SteamID64()]:Remove()
				playerFortificationHolograms[ply:SteamID64()] = nil
			end
		end
	end)

	-- Draw HUD
	function SWEP:DrawHUD()
		local ply = LocalPlayer()

		if IsValid(ply) and IsValid(ply:GetActiveWeapon()) and ply:GetActiveWeapon():GetClass() == "alydus_fortificationbuildertablet" then

			-- Destructable Fortification Display
			for _, destructibleFortification in ipairs(ents.FindByClass("alydus_destructiblefortification")) do
				if IsValid(destructibleFortification) and destructibleFortification:GetFortificationHealth() > 0 and destructibleFortification:GetPos():DistToSqr(ply:GetPos()) < (250 ^ 2) then
					local pos = Vector(destructibleFortification:GetPos().x, destructibleFortification:GetPos().y, destructibleFortification:GetPos().z)

					pos = pos + destructibleFortification:GetUp() * destructibleFortification:OBBMaxs().z / 2

					local pos2d = pos:ToScreen()

					local healthBarWidth = 300
					local healthBarHeight = 40

					surface.SetDrawColor(60, 60, 60, 150)

					surface.DrawRect(pos2d.x + (-healthBarWidth / 2), pos2d.y + (healthBarWidth / 2) - 210, healthBarWidth, healthBarHeight)

					surface.SetDrawColor(46, 204, 113, 150)

					surface.DrawRect(pos2d.x + (-healthBarWidth / 2), pos2d.y + (healthBarWidth / 2) - 210, (destructibleFortification:GetFortificationHealth() / destructibleFortification:GetMaximumFortificationHealth()) * healthBarWidth, healthBarHeight)

					draw.DrawText("DESTRUCTIBLE FORTIFICATION", "Alydus.FortificationsTablet.HealthSubtitle", pos2d.x, pos2d.y, Color(150, 150, 150), TEXT_ALIGN_CENTER)

					draw.DrawText(math.Round((destructibleFortification:GetFortificationHealth() / destructibleFortification:GetMaximumFortificationHealth()) * 100) .. "%", "Alydus.FortificationsTablet.HealthEmbeddedTitle", pos2d.x, pos2d.y - 55, Color(255, 255, 255), TEXT_ALIGN_CENTER)
				end
			end

			-- Selected Fortification Display
			if IsValid(playerFortificationHolograms[ply:SteamID64()]) and ply:CanDrawAlydusFortification() then
				local fortificationHologram = playerFortificationHolograms[ply:SteamID64()]

				local pos = Vector(fortificationHologram:GetPos().x, fortificationHologram:GetPos().y, fortificationHologram:GetPos().z) + (fortificationHologram:GetUp() * fortificationHologram:OBBMaxs().z / 2)

				local pos2d = pos:ToScreen()

				draw.DrawText(ply:GetActiveWeapon().Fortifications[ply:GetActiveWeapon():GetSelectedFortification()]["name"], "Alydus.FortificationsTablet.Title", pos2d.x, pos2d.y, Color(255, 255, 255), TEXT_ALIGN_CENTER)
				draw.DrawText("Placing...", "Alydus.FortificationsTablet.Subtitle", pos2d.x, pos2d.y + 50, Color(150, 150, 150), TEXT_ALIGN_CENTER)
			end
		end
	end

	local entityTabletMat = Material("entities/alydus_fortificationbuildertablet.png")

	-- Draw Weapon Selection
	function SWEP:DrawWeaponSelection(x, y, w, h, a)
		surface.SetDrawColor(255, 255, 255, 255)
		surface.SetMaterial(entityTabletMat)
		surface.DrawTexturedRect(x + 75, y + 20, 185, 185)

		self:PrintWeaponInfo(x + w + 20, y + h * 0.95, a)
	end
end

function SWEP:Initialize()
	if SERVER then
		self:SetIsBootingUp(false)
		self:SetSelectedFortification(1)
	end
end

function SWEP:PrimaryAttack()
	local ply = self:GetOwner()

	if SERVER then
		if IsValid(ply) and ply:CanSelectNextAlydusFortification() then
			print(self.Fortifications[self:GetSelectedFortification() + 1])
			if self.Fortifications[self:GetSelectedFortification() + 1] then
				self:SetSelectedFortification(self:GetSelectedFortification() + 1)
			else
				self:SetSelectedFortification(1)
			end
		end
	else
		if IsValid(ply) and ply:CanSelectNextAlydusFortification() and IsFirstTimePredicted() then
			surface.PlaySound("physics/concrete/rock_impact_hard1.wav")
		end
	end
end

function SWEP:SecondaryAttack()
	local ply = self:GetOwner()

	if SERVER then
		if IsValid(ply) and ply:CanSelectPreviousAlydusFortification() then
			if self.Fortifications[self:GetSelectedFortification() - 1] then
				self:SetSelectedFortification(self:GetSelectedFortification() - 1)
			else
				self:SetSelectedFortification(table.Count(self.Fortifications))
			end
		end
	else
		if IsValid(ply) and ply:CanSelectPreviousAlydusFortification() and IsFirstTimePredicted() then
			surface.PlaySound("physics/concrete/rock_impact_hard3.wav")
		end
	end
end

function SWEP:Reload()
	if SERVER then
		local ply = self:GetOwner()

		if not ply:KeyPressed(IN_RELOAD) then
			return
		end

		if IsValid(ply) and ply:CanRemoveAlydusFortification() then
			local fortificationToDelete = ply:GetEyeTrace().Entity

			local effectdata = EffectData()
			effectdata:SetOrigin(Vector(fortificationToDelete:GetPos().x, fortificationToDelete:GetPos().y, fortificationToDelete:GetPos().z) + (fortificationToDelete:GetUp() * fortificationToDelete:OBBMaxs().z / 2))
			effectdata:SetMagnitude(3)
			effectdata:SetScale(5)
			effectdata:SetRadius(2)
			util.Effect("cball_explode", effectdata, true, true)

			fortificationToDelete:EmitSound("physics/concrete/rock_impact_hard" .. math.random(1, 6) .. ".wav")
			fortificationToDelete:Remove()
		end

		return
	end
end

if CLIENT then
	local wrenchMat = Material("alydus/icons/wrench.png")
	local nextMat = Material("alydus/icons/next.png")
	local lastMat = Material("alydus/icons/last.png")
	local shieldMat = Material("alydus/icons/shield.png")
	local refreshMat = Material("alydus/icons/refresh.png")

	local toolsMat = Material("alydus/icons/tools.png")

	local useBind = input.LookupBinding("+use") or "E"
	local reloadBind = input.LookupBinding("+reload") or "R"

	function SWEP:PostDrawViewModel(vm, wep, ply)
		if IsValid(vm) then
			local atch = vm:GetBoneMatrix(vm:LookupBone("ValveBiped.Bip01_R_Hand"))
			local pos, ang = vm:GetBonePosition(vm:LookupBone("ValveBiped.Bip01_R_Hand")), vm:GetBoneMatrix(vm:LookupBone("ValveBiped.Bip01_R_Hand")):GetAngles()
			ang:RotateAroundAxis(ang:Right(), 90)

			local baseAng = ang

			baseAng:RotateAroundAxis(baseAng:Right(), 20)
			baseAng:RotateAroundAxis(baseAng:Forward(), -11)
			baseAng:RotateAroundAxis(baseAng:Up(), 57)
			
			cam.Start3D2D(pos - ang:Right() * 3 - ang:Forward() * 8.5 + ang:Right() * -1, baseAng, 0.012)
				surface.SetDrawColor(255, 255, 255, 255)
				if self:GetIsBootingUp() == false then
					draw.SimpleText("Fortification Builder", "Alydus.FortificationsTablet.TitleVM", 15, 0, Color(255, 255, 255, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)

					surface.SetMaterial(nextMat)
					surface.DrawTexturedRect(230, 42, 40, 40)
					surface.SetMaterial(lastMat)
					surface.DrawTexturedRect(-235, 38, 40, 40)

					draw.SimpleText("LMB: Last | RMB: Next", "Alydus.FortificationsTablet.SubtitleVM", 15, 60, Color(150, 150, 150, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)

					surface.SetMaterial(wrenchMat)
					surface.DrawTexturedRect(-215, 98, 40, 40)

					draw.SimpleText("    [" .. string.upper(useBind) .. "]: Build | [" .. string.upper(reloadBind) .. "]: Remove", "Alydus.FortificationsTablet.SubtitleVM", 15, 120, Color(150, 150, 150, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)

					if alydusDestructibleFortificationExtension then
						surface.SetMaterial(toolsMat)
						surface.DrawTexturedRect(-95, 158, 40, 40)

						draw.SimpleText("      [G]: Repair", "Alydus.FortificationsTablet.SubtitleVM", 15, 180, Color(150, 150, 150, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)

						surface.SetMaterial(shieldMat)
						surface.DrawTexturedRect(-237, 222, 40, 40)

						draw.SimpleText("      " .. table.Count(self.Fortifications) .. " Fortifications Available", "Alydus.FortificationsTablet.SubtitleVM", 15, 240, Color(100, 100, 100, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
					else
						surface.SetMaterial(shieldMat)
						surface.DrawTexturedRect(-237, 158, 40, 40)

						draw.SimpleText("      " .. table.Count(self.Fortifications) .. " Fortifications Available", "Alydus.FortificationsTablet.SubtitleVM", 15, 180, Color(100, 100, 100, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
					end
				else
					draw.SimpleText("Fortification Builder", "Alydus.FortificationsTablet.TitleVM", 15, 30, Color(255, 255, 255, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)

					surface.SetMaterial(refreshMat)
					surface.DrawTexturedRect(-130, 70, 40, 40)

					draw.SimpleText("    Booting up...", "Alydus.FortificationsTablet.SubtitleVM", 15, 90, Color(150, 150, 150, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
				end
			cam.End3D2D()
		end
	end
end

function SWEP:GetViewModelPosition(pos, ang)
	self.SwayScale = 0
	self.BobScale = 0.1

	return pos, ang
end

function SWEP:Initialize()
	self:SetHoldType("slam")

	if CLIENT then
		self.VElements = table.FullCopy(self.VElements)
		self.WElements = table.FullCopy(self.WElements)
		self.ViewModelBoneMods = table.FullCopy(self.ViewModelBoneMods)

		self:CreateModels(self.VElements)
		self:CreateModels(self.WElements)
		
		if IsValid(self.Owner) then
			local vm = self.Owner:GetViewModel()
			if IsValid(vm) then
				self:ResetBonePositions(vm)
				
				if (self.ShowViewModel == nil or self.ShowViewModel) then
					vm:SetColor(Color(255,255,255,255))
				else
					vm:SetColor(Color(255,255,255,1))
					vm:SetMaterial("Debug/hsv")			
				end
			end
		end
	end
end

function SWEP:Holster()
	if CLIENT and IsValid(self.Owner) then
		local vm = self.Owner:GetViewModel()
		if IsValid(vm) then
			self:ResetBonePositions(vm)
		end
	end
	
	return true
end

function SWEP:OnRemove()
	self:Holster()
end

if CLIENT then
	SWEP.vRenderOrder = nil
	function SWEP:ViewModelDrawn()
		
		local vm = self.Owner:GetViewModel()
		if !IsValid(vm) then return end
		
		if (!self.VElements) then return end
		
		self:UpdateBonePositions(vm)

		if (!self.vRenderOrder) then
			// we build a render order because sprites need to be drawn after models
			self.vRenderOrder = {}

			for k, v in pairs( self.VElements ) do
				if (v.type == "Model") then
					table.insert(self.vRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.vRenderOrder, k)
				end
			end
		end

		for k, name in ipairs(self.vRenderOrder) do
			local v = self.VElements[name]
			if (!v) then self.vRenderOrder = nil break end
			if (v.hide) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (!v.bone) then continue end
			
			local pos, ang = self:GetBoneOrientation(self.VElements, v, vm)
			
			if (!pos) then continue end
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix("RenderMultiply", matrix)
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial(v.material)
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
			elseif (v.type == "Sprite" and sprite) then
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z

				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z

				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func(self)
				cam.End3D2D()
			end
		end
	end

	SWEP.wRenderOrder = nil

	function SWEP:DrawWorldModel()
		if (self.ShowWorldModel == nil or self.ShowWorldModel) then
			self:DrawModel()
		end
		
		if (!self.WElements) then return end
		
		if (!self.wRenderOrder) then
			self.wRenderOrder = {}

			for k, v in pairs(self.WElements) do
				if (v.type == "Model") then
					table.insert(self.wRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.wRenderOrder, k)
				end
			end

		end
		
		if (IsValid(self.Owner)) then
			bone_ent = self.Owner
		else
			// when the weapon is dropped
			bone_ent = self
		end
		
		for k, name in pairs(self.wRenderOrder) do
			local v = self.WElements[name]
			if (!v) then self.wRenderOrder = nil break end
			if (v.hide) then continue end
			
			local pos, ang
			
			if (v.bone) then
				pos, ang = self:GetBoneOrientation(self.WElements, v, bone_ent)
			else
				pos, ang = self:GetBoneOrientation(self.WElements, v, bone_ent, "ValveBiped.Bip01_R_Hand")
			end
			
			if (!pos) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (v.type == "Model" and IsValid(model)) then
				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z)
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix("RenderMultiply", matrix)
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial(v.material)
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func(self)
				cam.End3D2D()
			end
		end
	end

	function SWEP:GetBoneOrientation(basetab, tab, ent, bone_override)
		local bone, pos, ang
		if (tab.rel and tab.rel != "") then
			
			local v = basetab[tab.rel]
			
			if (!v) then return end
			
			// Technically, if there exists an element with the same name as a bone
			// you can get in an infinite loop. Let's just hope nobody's that stupid.
			pos, ang = self:GetBoneOrientation(basetab, v, ent)
			
			if (!pos) then return end
			
			pos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
			ang:RotateAroundAxis(ang:Up(), v.angle.y)
			ang:RotateAroundAxis(ang:Right(), v.angle.p)
			ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
		else
		
			bone = ent:LookupBone(bone_override or tab.bone)

			if (!bone) then return end
			
			pos, ang = Vector(0,0,0), Angle(0,0,0)
			local m = ent:GetBoneMatrix(bone)
			if (m) then
				pos, ang = m:GetTranslation(), m:GetAngles()
			end
			
			if (IsValid(self.Owner) and self.Owner:IsPlayer() and 
				ent == self.Owner:GetViewModel() and self.ViewModelFlip) then
				ang.r = -ang.r // Fixes mirrored models
			end
		
		end
		
		return pos, ang
	end

	function SWEP:CreateModels(tab)
		if (!tab) then return end

		// Create the clientside models here because Garry says we can't do it in the render hook
		for k, v in pairs(tab) do
			if (v.type == "Model" and v.model and v.model != "" and (!IsValid(v.modelEnt) or v.createdModel != v.model) and 
					string.find(v.model, ".mdl") and file.Exists (v.model, "GAME") ) then
				
				v.modelEnt = ClientsideModel(v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE)
				if (IsValid(v.modelEnt)) then
					v.modelEnt:SetPos(self:GetPos())
					v.modelEnt:SetAngles(self:GetAngles())
					v.modelEnt:SetParent(self)
					v.modelEnt:SetNoDraw(true)
					v.createdModel = v.model
				else
					v.modelEnt = nil
				end
				
			elseif (v.type == "Sprite" and v.sprite and v.sprite != "" and (!v.spriteMaterial or v.createdSprite != v.sprite) 
				and file.Exists ("materials/"..v.sprite..".vmt", "GAME")) then
				
				local name = v.sprite.."-"
				local params = { ["$basetexture"] = v.sprite }
				// make sure we create a unique name based on the selected options
				local tocheck = {"nocull", "additive", "vertexalpha", "vertexcolor", "ignorez"}
				for i, j in pairs(tocheck) do
					if (v[j]) then
						params["$"..j] = 1
						name = name.."1"
					else
						name = name.."0"
					end
				end

				v.createdSprite = v.sprite
				v.spriteMaterial = CreateMaterial(name, "UnlitGeneric", params)
				
			end
		end
		
	end
	
	local allbones
	local hasGarryFixedBoneScalingYet = false

	function SWEP:UpdateBonePositions(vm)
		if self.ViewModelBoneMods then
			
			if (!vm:GetBoneCount()) then return end
			
			local loopthrough = self.ViewModelBoneMods
			if (!hasGarryFixedBoneScalingYet) then
				allbones = {}
				for i=0, vm:GetBoneCount() do
					local bonename = vm:GetBoneName(i)
					if (self.ViewModelBoneMods[bonename]) then 
						allbones[bonename] = self.ViewModelBoneMods[bonename]
					else
						allbones[bonename] = { 
							scale = Vector(1,1,1),
							pos = Vector(0,0,0),
							angle = Angle(0,0,0)
						}
					end
				end
				
				loopthrough = allbones
			end
			
			for k, v in pairs(loopthrough) do
				local bone = vm:LookupBone(k)
				if (!bone) then continue end
				
				local s = Vector(v.scale.x,v.scale.y,v.scale.z)
				local p = Vector(v.pos.x,v.pos.y,v.pos.z)
				local ms = Vector(1,1,1)
				if (!hasGarryFixedBoneScalingYet) then
					local cur = vm:GetBoneParent(bone)
					while(cur >= 0) do
						local pscale = loopthrough[vm:GetBoneName(cur)].scale
						ms = ms * pscale
						cur = vm:GetBoneParent(cur)
					end
				end
				
				s = s * ms
				
				if vm:GetManipulateBoneScale(bone) != s then
					vm:ManipulateBoneScale(bone, s)
				end
				if vm:GetManipulateBoneAngles(bone) != v.angle then
					vm:ManipulateBoneAngles(bone, v.angle)
				end
				if vm:GetManipulateBonePosition(bone) != p then
					vm:ManipulateBonePosition(bone, p)
				end
			end
		else
			self:ResetBonePositions(vm)
		end
	end
	 
	function SWEP:ResetBonePositions(vm)
		if (!vm:GetBoneCount()) then return end

		for i=0, vm:GetBoneCount() do
			vm:ManipulateBoneScale(i, Vector(1, 1, 1))
			vm:ManipulateBoneAngles(i, Angle(0, 0, 0))
			vm:ManipulateBonePosition(i, Vector(0, 0, 0))
		end
	end

	function table.FullCopy( tab )
		if (!tab) then return nil end
		
		local res = {}

		for k, v in pairs( tab ) do
			if (type(v) == "table") then
				res[k] = table.FullCopy(v)
			elseif (type(v) == "Vector") then
				res[k] = Vector(v.x, v.y, v.z)
			elseif (type(v) == "Angle") then
				res[k] = Angle(v.p, v.y, v.r)
			else
				res[k] = v
			end
		end
		
		return res
	end
end


--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/cl_customize_ui_bottombar.lua:
local scrolleles = {}

local foldericon = Material("arc9/ui/folder.png", "mips smooth")
local folderfavicon = Material("arc9/ui/folder_favorites.png", "mips smooth")
local backicon = Material("arc9/ui/back.png", "mips smooth")
local adminicon = Material("arc9/admin.png", "mips smooth")

local ARC9ScreenScale = ARC9.ScreenScale

local clicksound = "arc9/newui/uimouse_click.ogg"
local foldersound = "arc9/newui/uimouse_click_forward.ogg"
local backsound = "arc9/newui/uimouse_click_return.ogg"
local tabsound = "arc9/newui/uimouse_click_tab.ogg"

local function spacer(self, scroll, margin)
    local spacer = vgui.Create("DPanel", scroll)
    spacer:DockMargin(ARC9ScreenScale(margin), 0, ARC9ScreenScale(4), 0)
    spacer:Dock(LEFT)
    spacer:SetSize(ARC9ScreenScale(1), ARC9ScreenScale(2))

    scroll:AddPanel(spacer)
    table.insert(scrolleles, spacer)
    spacer.Paint = function(self2, w, h)
        if !IsValid(self) then return end

        surface.SetDrawColor(ARC9.GetHUDColor("bg"))
        surface.DrawRect(0, ARC9ScreenScale(2), w, ARC9ScreenScale(40))
    end
end

SWEP.BottomBar = nil
SWEP.BottomBarAnchor = nil

-- 0: Preset
-- 1: Attachment
SWEP.BottomBarMode = 0

SWEP.BottomBarAddress = 0

SWEP.BottomBarFolders = {}
SWEP.BottomBarPath = {}
SWEP.BottomBarAtts = {}

-- 0: Customization
-- 1: Personalization
SWEP.BottomBarCategory = 0

SWEP.LastScroll = 0

function SWEP:ClearBottomBar()
    if self.BottomBar then
        self.BottomBar:Remove()
        self.BottomBar = nil
    end

    self:ClearAttInfoBar()
end

local function recursivefoldercount(folder)
    local count = 0

    for i, k in pairs(folder) do
        if istable(k) then
            count = count + recursivefoldercount(k)
        else
            local atttbl = ARC9.GetAttTable(i)

            if !atttbl then continue end

            if atttbl.Free or GetConVar("arc9_hud_showunowned"):GetBool() or GetConVar("arc9_free_atts"):GetBool() or ARC9:PlayerGetAtts(i) > 0 then
                count = count + 1
            end
        end
    end

    return count
end

local function enterfolder(self, scroll, slottbl, fname)
    if fname != true then
        if fname == nil then
            table.remove(self.BottomBarPath)
        else
            table.insert(self.BottomBarPath, fname)
        end
    end

    local folders = self.BottomBarFolders
    for _, v in ipairs(self.BottomBarPath) do
        folders = folders[v]
    end

    for _, p in pairs(scrolleles) do
        p:Remove()
    end

    if IsValid(self.BottomBarAnchor) then
        self.BottomBarAnchor:Remove()
        self.BottomBarAnchor = nil
    end

    local anchor = vgui.Create("DPanel", self.BottomBar)
    anchor:SetPos(ARC9ScreenScale(3), ARC9ScreenScale(3))
    anchor:SetSize(ARC9ScreenScale(57.5), ARC9ScreenScale(57.5))

    function anchor:Paint(w, h)
    end

    self.BottomBarAnchor = anchor

    local backbtn = vgui.Create("ARC9AttButton", anchor)
    backbtn:SetIcon(backicon)
    backbtn:SetEmpty(true)

    backbtn:DockMargin(ARC9ScreenScale(5), 0, 0, 0)
    backbtn:Dock(LEFT)

    local newspacer = vgui.Create("DPanel", anchor)
    newspacer:DockMargin(ARC9ScreenScale(3.5), 0, ARC9ScreenScale(4), 0)
    newspacer:Dock(LEFT)
    newspacer:SetSize(ARC9ScreenScale(1), ARC9ScreenScale(2))

    newspacer.Paint = function(self2, w, h)
        if !IsValid(self) then return end

        surface.SetDrawColor(ARC9.GetHUDColor("bg"))
        surface.DrawRect(0, ARC9ScreenScale(2), w, ARC9ScreenScale(40))
    end

    if #self.BottomBarPath > 0 then
        backbtn:SetButtonText(ARC9:GetPhrase("folder.back"))
        backbtn.OnMousePressed = function(self2, kc)
            if kc == MOUSE_LEFT then
                enterfolder(self, scroll, slottbl, nil)
                surface.PlaySound(backsound)
            end
        end
    else
        backbtn:SetButtonText(ARC9:GetPhrase("folder.deselect"))
        backbtn.OnMousePressed = function(self2, kc)
            if kc == MOUSE_LEFT then
                self.BottomBarAddress = nil
                self.BottomBarMode = 0
                self:CreateHUD_Bottom()
                surface.PlaySound(backsound)
            end
        end
    end
    -- backbtn.Think = function(self2)
    --     if !IsValid(self) then return end
    --     if self2:IsHovered() then
    --         self.CustomizeHints["customize.hint.select"] = "Return"
    --     end
    -- end

    scroll:SetPos(anchor:GetWide(), ARC9ScreenScale(3))
    scroll:SetWide(self.BottomBar:GetWide() - anchor:GetWide())

    local foldercount = 0
    if folders then
        for folder, children in SortedPairs(folders) do
            if !folders then
                table.remove(self.BottomBarPath)
            end
            if isbool(children) then continue end

            local count = recursivefoldercount(children)

            -- if count > 99 then count = "99+" end

            if count == 0 then continue end

            foldercount = foldercount + 1

            local folderbtn = vgui.Create("ARC9AttButton", scroll)

            folderbtn:SetButtonText(folder == "!favorites" and ARC9:GetPhrase("folder.favorites") or ARC9:GetPhrase("folder." .. folder) or folder)
            folderbtn:SetIcon(folder == "!favorites" and folderfavicon or foldericon)
            folderbtn:SetEmpty(true)

            folderbtn:DockMargin(0, 0, ARC9ScreenScale(4), 0)
            folderbtn:Dock(LEFT)

            scroll:AddPanel(folderbtn)
            table.insert(scrolleles, folderbtn)
            folderbtn.folder = folder

            folderbtn:SetFolderContain(tostring(count))

            folderbtn.OnMousePressed = function(self2, kc)
                if kc == MOUSE_LEFT then
                    enterfolder(self, scroll, slottbl, self2.folder)
                    surface.PlaySound(foldersound)
                end
                -- if kc == MOUSE_RIGHT then -- randomizing attachments from folder! -- Moved to cl_bind reload
                --     local randompool = {}

                --     for _, v in ipairs(self.BottomBarAtts) do
                --         local atbl = ARC9.GetAttTable(v.att)

                --         local checkfolder = self2.folder

                --         local pathprefix = string.Implode("/", self.BottomBarPath)
                --         if pathprefix != "" then checkfolder = pathprefix .. "/" .. self2.folder end
                        
                --         if atbl.Folder == checkfolder or (self2.folder == "!favorites" and ARC9.Favorites[v.att]) then
                --             table.insert(randompool, atbl)
                --             randompool[#randompool].fuckthis = v.slot
                --         end               
                --     end
                    
                --     local thatatt = randompool[math.random(0, #randompool)]
                --     if thatatt then
                --         self:Attach(thatatt.fuckthis, thatatt.ShortName, true)
                --     end
                    
                --     surface.PlaySound(tabsound)
                -- end
            end

            folderbtn.Think = function(self2)
                if !IsValid(self) then return end
                if self2:IsHovered() then
                    self.CustomizeHints["customize.hint.select"] = "customize.hint.select"
                    self.CustomizeHints["customize.hint.random"] = "customize.hint.randomize"
                    self.CustomizeLastHoveredFolder = self2
                end
            end
        end
    end

    if foldercount > 1 then spacer(self, scroll, 0) end

    local strpath = string.Implode("/", self.BottomBarPath)

    for _, att in pairs(self.BottomBarAtts) do
        local qty = ARC9:PlayerGetAtts(self:GetOwner(), att.att)

        local atttbl = ARC9.GetAttTable(att.att)
        local aslottbl = self:LocateSlotFromAddress(att.slot)
        local installedtbl = ARC9.GetAttTable(aslottbl.Installed) or {}

        if !GetConVar("arc9_hud_showunowned"):GetBool() and !GetConVar("arc9_free_atts"):GetBool() and qty <= 0 and !atttbl.Free and (installedtbl.InvAtt or aslottbl.Installed) != (atttbl.InvAtt or att.att) then continue end

        if atttbl.AdminOnly and !self:GetOwner():IsAdmin() then continue end

        if strpath != "!favorites" and ((!atttbl.Folder and #self.BottomBarPath > 0) or (atttbl.Folder and atttbl.Folder != strpath)) then continue end

        if strpath == "!favorites" and !ARC9.Favorites[att.att] then continue end

        local attname = ARC9:GetPhraseForAtt(att.att, "CompactName") or ARC9:GetPhraseForAtt(att.att, "PrintName") or ARC9:GetPhraseForAtt(att.att, "ShortName") or ""

        local attbtn2 = vgui.Create("ARC9AttButton", scroll)
        attbtn2:DockMargin(0, 0, ARC9ScreenScale(4), 0)
        attbtn2:Dock(LEFT)
        attbtn2:SetButtonText(attname)
        attbtn2:SetIcon(atttbl.Icon)
        attbtn2.att = att.att
        attbtn2.attslot = att.slot
        attbtn2.address = aslottbl.Address
        attbtn2.slottbl = aslottbl

        scroll:AddPanel(attbtn2)
        table.insert(scrolleles, attbtn2)
        attbtn2.OnMousePressed = function(self2, kc)
            if kc == MOUSE_LEFT then
                self:Attach(self2.attslot, self2.att, self2.slottbl.Installed == self2.att) -- third parameter is Silent, so sound won't be played twice though att will updated (might be helpful)
                self.CustomizeSelectAddr = self2.address
            elseif kc == MOUSE_RIGHT then
                if self2.slottbl.Integral and isstring(self2.slottbl.Integral) then
                    self:Attach(self2.address, self2.slottbl.Integral)
                else
                    self:DetachAllFromSubSlot(self2.address)
                end
                self.CustomizeSelectAddr = self2.address
            end
        end

        attbtn2.Think = function(self2)
            if !IsValid(self) then return end

            local slot = self:LocateSlotFromAddress(self2.attslot)

            if !slot then return end

            if slot != self2.slottbl then
                local c1 = slot.Category
                local c2 = self2.slottbl.Category

                if istable(c1) then
                    c1 = table.concat(c1, " ")
                end

                if istable(c2) then
                    c2 = table.concat(c2, " ")
                end

                if c1 != c2 then
                    self:ClearAttInfoBar()
                    self:ClearBottomBar()
                    self.BottomBarAddress = nil
                    self.AttInfoBarAtt = nil
                    return
                end

                self2.slottbl = slot
            end

            attbtn2:SetInstalled(slot.Installed == att.att)
            attbtn2:SetHasModes(!!atttbl.ToggleStats)
            attbtn2:SetHasSlots(!!atttbl.Attachments)
            attbtn2:SetCanAttach(self:CanAttach(slot.Address, att.att, slot, true))
            attbtn2:SetMissingDependents(self:GetSlotMissingDependents(slot.Address, att.att, slot))
            attbtn2:SetFullColorIcon(atttbl.FullColorIcon)

            if self2:IsHovered() then
                if (qty > 0) and slot.Installed != att.att then
                    self.CustomizeHints["customize.hint.select"] = "customize.hint.attach"
                elseif self2.slottbl.Installed then
                    self.CustomizeHints["customize.hint.deselect"] = "customize.hint.unattach"
                end

                if ARC9.Favorites[att.att] then
                    self.CustomizeHints["customize.hint.favorite"] = "customize.hint.unfavorite"
                else
                    self.CustomizeHints["customize.hint.favorite"] = "customize.hint.favorite"
                end

                if self.AttInfoBarAtt != self2.att then
                    self.AttInfoBarAtt = self2.att
                    self.AttInfoBarAttSlot = slot
                    self:CreateHUD_AttInfo()
                end

                self.CustomizeLastHovered = self2
            end
        end
    end

    scroll:RefreshScrollBar(self.BottomBar)
end

surface.CreateFont("ARC9_KeybindPreview_Cust", {
    font = "Arial",
    size = ARC9ScreenScale(8),
    weight = 1000,
    antialias = true,
})

function SWEP:CreateHUD_Bottom()
    -- if true then return end
    local bg = self.CustomizeHUD
    local lowerpanel = bg.lowerpanel

    self:ClearBottomBar()

    self.AttInfoBarAtt = nil

    local bp = vgui.Create("DPanel", lowerpanel)
    bp:SetSize(lowerpanel:GetWide(), ARC9ScreenScale(62))
    bp:SetPos(0, ARC9ScreenScale(15.5))
    bp.Paint = function() end

    self.BottomBar = bp

    scrolleles = {}
    local scroll = vgui.Create("ARC9HorizontalScroller", bp)
    scroll:SetPos(0, ARC9ScreenScale(3))
    scroll:SetSize(lowerpanel:GetWide(), ARC9ScreenScale(57.3))
    scroll:SetOverlap(-ARC9ScreenScale(5)) -- If this is too small, the right side will be cut out. idk why and idk how to fix it elegantly so here you go
    scroll:MoveToFront()

    function scroll.btnLeft:Paint(w, h) end
    function scroll.btnRight:Paint(w, h) end

    local deadzonex = GetConVar("arc9_hud_deadzonex"):GetInt()

    if self.BottomBarMode == 1 then
        self.CustomizeHUD.lowerpanel:MoveTo(ARC9ScreenScale(19) + deadzonex, ScrH() - ARC9ScreenScale(93+73.5), 0.2, 0, 0.5, nil)
        self.CustomizeHUD.lowerpanel:SizeTo(ScrW() - ARC9ScreenScale(38) - deadzonex*2, ARC9ScreenScale(74+73.5), 0.2, 0, 0.5, nil)
        self.CustomizeHUD.lowerpanel.Extended = true

        self:ClosePresetMenu()

        local slottbl = self:LocateSlotFromAddress(self.BottomBarAddress)

        if !slottbl then return end

        if slottbl.Installed then
            self.AttInfoBarAtt = slottbl.Installed
            self.AttInfoBarAttSlot = slottbl
            self:CreateHUD_AttInfo()
        else
            self:ClearAttInfoBar()
        end

        local atts = ARC9.GetAttsForCats(slottbl.Category or "")
        local atts_slots = {}
        local atts_fav = {}

        for _, att in pairs(atts) do
            if (slottbl.RejectAttachments or {})[att] then continue end
            if ARC9.Favorites[att] then atts_fav[att] = true end
            table.insert(atts_slots, {
                att = att,
                slot = self.BottomBarAddress
            })
        end

        if slottbl.MergeSlotAddresses then
            for _, addr in pairs(slottbl.MergeSlotAddresses) do
                local slottbl2 = self:LocateSlotFromAddress(addr)

                local atts2 = ARC9.GetAttsForCats(slottbl2.Category or "")
                table.Add(atts, atts2)
                for _, att in pairs(atts2) do
                    if (slottbl2.RejectAttachments or {})[att] then continue end
                    table.insert(atts_slots, {
                        att = att,
                        slot = addr
                    })
                end
            end
        end

        table.sort(atts_slots, function(a, b)
            a = a.att or ""
            b = b.att or ""

            if a == "" or b == "" then return true end

            local atttbl_a = ARC9.GetAttTable(a)
            local atttbl_b = ARC9.GetAttTable(b)

            local order_a = 0
            local order_b = 0

            order_a = atttbl_a.SortOrder or order_a
            order_b = atttbl_b.SortOrder or order_b

            if ARC9.Favorites[a] then order_a = order_a - ARC9.FavoritesWeight end
            if ARC9.Favorites[b] then order_b = order_b - ARC9.FavoritesWeight end

            local qty_a = ARC9:PlayerGetAtts(self:GetOwner(), a)
            local qty_b = ARC9:PlayerGetAtts(self:GetOwner(), b)

            if ( (qty_a <= 0) and (slottbl.Installed != a) ) then order_a = order_a - ARC9.UnownedWeight end
            if ( (qty_b <= 0) and (slottbl.Installed != b) ) then order_b = order_b - ARC9.UnownedWeight end

            if order_a == order_b then
                return (atttbl_a.CompactName or atttbl_a.PrintName or "") < (atttbl_b.CompactName or atttbl_b.PrintName or "")
            end

            return order_a < order_b
        end)

        -- BottomBarFolders actually contains every folder and attachment, not just folders!
        self.BottomBarFolders = ARC9.GetFoldersForAtts(atts)
        self.BottomBarAtts = atts_slots

        local foldercount = 0
        local firstfolder = nil
        for k, v in pairs(self.BottomBarFolders) do
            if istable(v) then
                foldercount = foldercount + 1
                firstfolder = k
            end
        end

        if foldercount > 0 and atts_fav != {} then
            self.BottomBarFolders["!favorites"] = atts_fav
        end

        if table.Count(self.BottomBarFolders) == 1 then
            local sub = firstfolder

            -- print(sub)

            if istable(self.BottomBarFolders[sub]) then
                self.BottomBarPath = {}
                enterfolder(self, scroll, slottbl, sub)
                return
            end
        end

        enterfolder(self, scroll, slottbl, true)
    else
        self:CreateHUD_Slots(scroll)
    end

    scroll:RefreshScrollBar(self.BottomBar)

    if self.LastScroll then
        scroll:SetScroll(self.LastScroll)
    end
end

SWEP.AttInfoBar = nil
SWEP.AttInfoBarAtt = nil

function SWEP:ClearAttInfoBar()
    if self.AttInfoBar then
        self.AttInfoBar:Remove()
        self.AttInfoBar = nil
    end
end

function SWEP:CreateHUD_AttInfo()
    local lowerpanel = self.CustomizeHUD.lowerpanel
    -- if true then return end
    local atttbl = ARC9.GetAttTable(self.AttInfoBarAtt)

    self:ClearAttInfoBar()

    if !atttbl then return end

    local infopanel = vgui.Create("DPanel", lowerpanel)
    infopanel:SetSize(lowerpanel:GetWide(), ARC9ScreenScale(70))
    infopanel:SetPos(0, ARC9ScreenScale(75.5))
    infopanel.title = ARC9:GetPhraseForAtt(self.AttInfoBarAtt, "PrintName") or atttbl.PrintName
    infopanel.Paint = function(self2, w, h)
        if !IsValid(self) then return end
        -- surface.SetFont("ARC9_10")
        -- surface.SetTextPos(0, 0)
        -- surface.SetTextColor(ARC9.GetHUDColor("fg"))
        -- ARC9.DrawTextRot(self2, self2.title, 0, 0, ARC9ScreenScale(6), ARC9ScreenScale(3), w, true)

        markup.Parse("<font=ARC9_10>" .. self2.title):Draw(ARC9ScreenScale(6), ARC9ScreenScale(3), TEXT_ALIGN_LEFT, TEXT_ALIGN_LEFT)
    end

    self.AttInfoBar = infopanel

    local descscroller = vgui.Create("ARC9ScrollPanel", infopanel)
    descscroller:SetSize(lowerpanel:GetWide() / 2 - ARC9ScreenScale(5), infopanel:GetTall() - ARC9ScreenScale(16))
    descscroller:SetPos(ARC9ScreenScale(4), ARC9ScreenScale(14))

    local multiline = {}
    local desc = ARC9:GetPhraseForAtt(self.AttInfoBarAtt, "Description") or atttbl.Description

    multiline = ARC9MultiLineText(desc, descscroller:GetWide() - (ARC9ScreenScale(3.5)), "ARC9_9_Slim")

    for i, text in ipairs(multiline) do
        local desc_line = vgui.Create("DPanel", descscroller)
        desc_line:SetSize(descscroller:GetWide(), ARC9ScreenScale(9))
        desc_line:Dock(TOP)
        desc_line.Paint = function(self2, w, h)
            -- surface.SetFont("ARC9_9_Slim")
            -- surface.SetTextColor(ARC9.GetHUDColor("fg"))
            -- surface.SetTextPos(ARC9ScreenScale(2), 0)
            -- surface.DrawText(text)
            markup.Parse("<font=ARC9_9_Slim>" .. text):Draw(ARC9ScreenScale(2), 0, TEXT_ALIGN_LEFT, TEXT_ALIGN_LEFT)
        end
    end

    local slot = self.AttInfoBarAttSlot

    if slot and atttbl.ToggleStats then
        local mode_toggle = vgui.Create("ARC9TopButton", infopanel)
        mode_toggle.addr = slot.Address
        surface.SetFont("ARC9_12")
        local curmode = "Togglable"
        local tw = surface.GetTextSize(curmode)
        mode_toggle:SetPos(descscroller:GetWide()/2-(ARC9ScreenScale(24)+tw)/2, ARC9ScreenScale(50))
        mode_toggle:SetSize(0, 0) -- ARC9ScreenScale(24)+tw, ARC9ScreenScale(21*0.75)
        mode_toggle:SetButtonText(curmode, "ARC9_12")
        mode_toggle:SetIcon(Material("arc9/ui/modes.png", "mips smooth"))
        mode_toggle.DoClick = function(self2)
            -- surface.PlaySound(clicksound)
            -- self:PlayAnimation("toggle")
            self:EmitSound(self:RandomChoice(self:GetProcessedValue("ToggleAttSound", true)), 75, 100, 1, CHAN_ITEM)
            self:ToggleStat(self2.addr)
            self:PostModify()
        end

        mode_toggle.DoRightClick = function(self2)
            -- surface.PlaySound(clicksound)
            -- self:PlayAnimation("toggle")
            self:EmitSound(self:RandomChoice(self:GetProcessedValue("ToggleAttSound", true)), 75, 100, 1, CHAN_ITEM)
            self:ToggleStat(self2.addr, -1)
            self:PostModify()
        end

        mode_toggle.Think = function(self2)
            if !IsValid(self) then return end

            slot = self:LocateSlotFromAddress(self2.addr)

            if slot.Installed == self.AttInfoBarAtt then
                curmode = atttbl.ToggleStats[slot.ToggleNum] and atttbl.ToggleStats[slot.ToggleNum].PrintName or "Toggle"
                
                surface.SetFont("ARC9_12")
                tw = surface.GetTextSize(curmode)
                mode_toggle:SetPos(descscroller:GetWide() / 2-(ARC9ScreenScale(24) + tw) / 2, ARC9ScreenScale(50))
                mode_toggle:SetSize(ARC9ScreenScale(21) + tw, ARC9ScreenScale(21 * 0.75))
                mode_toggle:SetButtonText(curmode, "ARC9_12")
            else
                mode_toggle:SetSize(0, 0)
            end

            if self2:IsHovered() then
                self.CustomizeHints["customize.hint.select"] = "customize.hint.nextmode"
                self.CustomizeHints["customize.hint.deselect"] = "customize.hint.lastmode"
            end

        end
        descscroller:SetSize(lowerpanel:GetWide()/2 - ARC9ScreenScale(5), infopanel:GetTall() - ARC9ScreenScale(38)) -- making desc smaller
    end


    local prosscroller = vgui.Create("ARC9ScrollPanel", infopanel)
    prosscroller:SetSize(lowerpanel:GetWide()*0.25 - ARC9ScreenScale(3), infopanel:GetTall() - ARC9ScreenScale(4))
    prosscroller:SetPos(lowerpanel:GetWide()*0.5 + ARC9ScreenScale(3), ARC9ScreenScale(3))

    local consscroller = vgui.Create("ARC9ScrollPanel", infopanel)
    consscroller:SetSize(lowerpanel:GetWide()*0.25 - ARC9ScreenScale(3), infopanel:GetTall() - ARC9ScreenScale(4))
    consscroller:SetPos(lowerpanel:GetWide()*0.75 + ARC9ScreenScale(3), ARC9ScreenScale(3))

    local prosname, prosnum, consname, consnum = ARC9.GetProsAndCons(atttbl, self)

    if table.Count(prosname) > 0 then
        lowerpanel.HasPros = true
        for k, stat in ipairs(prosname) do
            local pro_stat = vgui.Create("DPanel", prosscroller)
            pro_stat:SetSize(prosscroller:GetWide(), ARC9ScreenScale(9))
            pro_stat:Dock(TOP)
            pro_stat.text = stat
            pro_stat.Paint = function(self2, w, h)
                if !IsValid(self) then return end
                surface.SetFont("ARC9_9")
                surface.SetTextColor(ARC9.GetHUDColor("fg"))
                surface.SetTextPos(ARC9ScreenScale(2), 0)
                local tw = surface.GetTextSize(self2.text)
                ARC9.DrawTextRot(self2, self2.text, ARC9ScreenScale(2), 0, ARC9ScreenScale(2), 0, ARC9ScreenScale(110), false)

                local tw = surface.GetTextSize(prosnum[k])
                ARC9.DrawTextRot(self2, prosnum[k], 0, 0, prosscroller:GetWide()-tw-ARC9ScreenScale(6), 0, w, true)
            end
        end
    else
        lowerpanel.HasPros = nil
    end

    if table.Count(consname) > 0 then
        lowerpanel.HasCons = true
        for k, stat in ipairs(consname) do
            local con_stat = vgui.Create("DPanel", consscroller)
            con_stat:SetSize(consscroller:GetWide(), ARC9ScreenScale(9))
            con_stat:Dock(TOP)
            con_stat.text = stat
            con_stat.Paint = function(self2, w, h)
                if !IsValid(self) then return end
                surface.SetFont("ARC9_9")
                surface.SetTextColor(ARC9.GetHUDColor("fg"))
                surface.SetTextPos(ARC9ScreenScale(2), 0)
                local tw = surface.GetTextSize(self2.text)
                ARC9.DrawTextRot(self2, self2.text, ARC9ScreenScale(2), 0, ARC9ScreenScale(2), 0, ARC9ScreenScale(110), false)

                local tw = surface.GetTextSize(consnum[k])
                ARC9.DrawTextRot(self2, consnum[k], 0, 0, consscroller:GetWide()-tw-ARC9ScreenScale(6), 0, w, true)
            end
        end
    else
        lowerpanel.HasCons = nil
    end
end
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/cl_flare.lua:
local badcolor = Color(255, 255, 255)

SWEP.FlaresAlreadyDrawn = {}

function SWEP:DrawLightFlare(pos, ang, col, size, flareid, vm, nodotter)
    col = col or badcolor
    size = size or 1
    local lp = LocalPlayer()
    local campos = vm and EyePos() or lp:GetViewEntity():GetPos()

    if !vm then -- walls!!!!!
        local tr = util.TraceLine({
            start = campos,
            endpos = pos,
            mask = MASK_OPAQUE,
            filter = lp,
        })

        if tr.Fraction != 1 then return end
    end

    local dotter = 1
    if !nodotter then
        local diff = campos - pos
        if -ang:Right():Dot(diff) < 0 then return end
        dotter = math.max(0, -ang:Right():Dot(diff) / diff:Length())

        if dotter < 0.4 then return end
        dotter = math.ease.InExpo(dotter)
    end

    local distancer = math.ease.InExpo(math.max(1 - campos:DistToSqr(pos) * 0.0000005, 0))

    size = size * dotter * 3 * distancer

    if self.FlaresAlreadyDrawn[flareid] then return end
    self.FlaresAlreadyDrawn[flareid] = true

    table.insert(ARC9.Flares, {
        pos = pos,
        size = math.Clamp(size, 0, 1000),
        color = col,
        invm = vm
    })
end
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/cl_peek.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/cl_presets.lua:
function SWEP:GetPresetBase()
    return self.SaveBase or self:GetClass()
end

function SWEP:GetPresets()
    local path = ARC9.PresetPath .. self:GetPresetBase() .. "/*.txt"

    local files = file.Find(path, "DATA")

    for i, k in pairs(files) do
        files[i] = string.sub(k, 1, string.len(k) - 4)
    end

    return files
end

function SWEP:WriteAttachmentTree(tree)
    if tree and tree.Installed then
        local tbl = {
            Installed = tree.Installed,
            ToggleNum = tree.ToggleNum or 1
        }

        local atttbl = ARC9.GetAttTable(tree.Installed)

        if atttbl.Attachments then
            tbl.SubAttachments = {}

            for i, k in pairs(atttbl.Attachments) do
                tbl.SubAttachments[i] = self:WriteAttachmentTree(tree.SubAttachments[i])
            end
        end

        return tbl
    else
        return {}
    end
end

function SWEP:DeletePreset(filename)
    if LocalPlayer() != self:GetOwner() then return end

    filename = ARC9.PresetPath .. self:GetPresetBase() .. "/" .. filename

    if file.Exists(filename .. ".txt", "DATA") then
        file.Delete(filename .. ".txt")
    end

    if file.Exists(filename .. "." .. ARC9.PresetIconFormat, "DATA") then
        file.Delete(filename .. "." .. ARC9.PresetIconFormat)
    end
end

function SWEP:IgnorePreset(filename)
    if LocalPlayer() != self:GetOwner() then return end

    filename = ARC9.PresetPath .. self:GetPresetBase() .. "/" .. filename

    if file.Exists(filename .. ".txt", "DATA") then
        file.Write(filename .. ".txt", "name=ignore\n")
    end
end

function SWEP:StripWeapon()
    for slot, slottbl in ipairs(self.Attachments) do
        slottbl.Installed = nil
        slottbl.SubAttachments = nil
    end

    self:PostModify()
end

function SWEP:ClearPreset()
    -- for slot, slottbl in ipairs(self.Attachments) do
    --     slottbl.Installed = nil
    --     slottbl.SubAttachments = nil
    -- end

    -- self:BuildSubAttachments(self.DefaultAttachments)

    -- self:PostModify()
    self:LoadPreset("default")
end

function SWEP:LoadPresetFromTable(tbl)
    self.Attachments = baseclass.Get(self:GetClass()).Attachments

    for slot, slottbl in ipairs(self.Attachments) do
        slottbl.Installed = nil
        slottbl.SubAttachments = nil
    end

    self:PruneAttachments()

    self:BuildSubAttachments(tbl)
    self:PostModify()
end

function SWEP:LoadPresetFromCode(str, standard)
    onlysave = onlysave or false

    local name, tblstr = self:SplitPresetContents(str)
    local tbl = self:ImportPresetCode(tblstr)

    if !tbl then return false end

    self:LoadPresetFromTable(tbl)

    if !standard then
        surface.PlaySound("arc9/preset_install.ogg")
    end

    self:SavePreset(name, false, standard and name)


    return name or true
end

function SWEP:GetPresetName(preset)
    local filename = ARC9.PresetPath .. self:GetPresetBase() .. "/" .. preset .. ".txt"

    if !file.Exists(filename, "DATA") then return end

    local f = file.Open(filename, "r", "DATA")
    if !f then return end

    local str = f:Read()

    if string.sub(str, 1, 5) == "name=" then
        local strs = string.Split(str, "\n")
        f:Close()
        return string.sub(strs[1], 6)
    else
        f:Close()
        return preset
    end
end

function SWEP:GetPresetData(preset)
    local filename = ARC9.PresetPath .. self:GetPresetBase() .. "/" .. preset .. ".txt"

    if !file.Exists(filename, "DATA") then return end

    local f = file.Open(filename, "r", "DATA")
    if !f then return end

    local str = f:Read()

    local name = ""
    local code = ""

    if string.sub(str, 1, 5) == "name=" then
        local strs = string.Split(str, "\n")
        name = string.sub(strs[1], 6)
        code = strs[2]
    else
        name = preset
        code = str
    end

    local tbl = self:ImportPresetCode(code)
    local count = 0
    if tbl then count = self:GetAttCountFromTable(tbl) end

    f:Close()

    return name, count
end

function SWEP:GetAttCountFromTable(tbl)
    local count = 0
    for i, k in pairs(tbl) do
        if k.Installed then
            count = count + 1
        end

        if k.SubAttachments then
            count = count + self:GetAttCountFromTable(k.SubAttachments)
        end
    end

    return count
end

local arc9_atts_nocustomize = GetConVar("arc9_atts_nocustomize")
local arc9_autosave = GetConVar("arc9_autosave")

function SWEP:LoadPreset(filename)
    if arc9_atts_nocustomize:GetBool() then return end
    if LocalPlayer() != self:GetOwner() then return end

    filename = filename or "autosave"

    if filename == "autosave" then
        if !arc9_autosave:GetBool() then return end
    end

    filename = ARC9.PresetPath .. self:GetPresetBase() .. "/" .. filename .. ".txt"

    if !file.Exists(filename, "DATA") then return end

    local f = file.Open(filename, "r", "DATA")
    if !f then return end

    local str = f:Read()

    if str[1] == "{" then
        self:LoadPresetFromTable(util.JSONToTable(str))
    elseif string.sub(str, 1, 5) == "name=" then
        -- first line is name second line is data
        local strs = string.Split(str, "\n")
        self:LoadPresetFromTable(self:ImportPresetCode(strs[2]))
    else
        self:LoadPresetFromTable(self:ImportPresetCode(str))
    end

    if self.CustomizeHUD and self.CustomizeHUD.lowerpanel then
        timer.Simple(0, function()
            if !IsValid(self) then return end
            self:CreateHUD_Bottom()
        end)
    end

    f:Close()
end

local ratio = ScrW() / ScrH()
local pr_h = 256
local pr_w = 256 * ratio
local cammat = GetRenderTarget("arc9_cammat", pr_w, pr_h, false)

SWEP.PresetCapture = nil

function SWEP:SavePreset(presetname, nooverride, forcedname)
    presetname = presetname or "autosave"

    local str = self:GeneratePresetExportCode()

    local filename = ARC9.PresetPath .. self:GetPresetBase() .. "/" .. os.time()

    if forcedname then filename = ARC9.PresetPath .. self:GetPresetBase() .. "/" .. forcedname end

    if presetname == "autosave" then
        filename =  ARC9.PresetPath .. self:GetPresetBase() .. "/autosave"
    elseif presetname == "default" then
        filename =  ARC9.PresetPath .. self:GetPresetBase() .. "/default"
    end

    if nooverride and file.Exists(filename .. ".txt", "DATA") then return end

    file.CreateDir(ARC9.PresetPath .. self:GetPresetBase())
    local f = file.Open(filename .. ".txt", "w", "DATA")

    if !f then return end

    f:Write("name=" .. presetname .. "\n" .. str)
    f:Close()

    if presetname != "autosave" then
        self:DoPresetCapture(filename)
    end
end

local arc9_killfeed_colour = GetConVar("arc9_killfeed_colour")
local matshiny = Material("models/shiny")

local colormodifyicontabll = {
	[ "$pp_colour_addr" ] = 0,
	[ "$pp_colour_addg" ] = 0,
	[ "$pp_colour_addb" ] = 0,
	[ "$pp_colour_brightness" ] = 0,
	[ "$pp_colour_contrast" ] = 1.4,
	[ "$pp_colour_colour" ] = 1.3,
	[ "$pp_colour_mulr" ] = 0,
	[ "$pp_colour_mulg" ] = 0,
	[ "$pp_colour_mulb" ] = 0
}

function SWEP:DoPresetCapture(filename, foricon)
    local colorrr = arc9_killfeed_colour:GetBool()

    render.PushRenderTarget(cammat)

    render.SetColorMaterial()
    render.DrawScreenQuad()
    render.Clear(0, 0, 0, 0, true, true)

    local ref = 64

    render.UpdateScreenEffectTexture()
    render.ClearStencil()
    render.SetStencilEnable(true)
    render.SetStencilCompareFunction(STENCIL_ALWAYS)
    render.SetStencilPassOperation(STENCIL_REPLACE)
    render.SetStencilFailOperation(STENCIL_KEEP)
    render.SetStencilZFailOperation(STENCIL_KEEP)
    render.SetStencilWriteMask(255)
    render.SetStencilTestMask(255)

    render.SetStencilReferenceValue(ref)

    render.SetWriteDepthToDestAlpha(false)
    render.OverrideAlphaWriteEnable(true, true)

    ARC9.PresetCam = true

    -- local ppos, pang = EyePos(), EyeAngles()
    local campos, camang = Vector(0, 0, 0), Angle(0, 0, 0)
    local custpos, custang = self:GetProcessedValue("CustomizePos", true), self:GetProcessedValue("CustomizeAng", true)
    custpos = custpos + self.CustomizeSnapshotPos
    custang = custang + self.CustomizeSnapshotAng
    local pos, ang = Vector(0, 0, 1), Angle(0, 0, 0)

    pos = pos + (camang:Right() * custpos[1])
    pos = pos + (camang:Forward() * custpos[2])
    pos = pos + (camang:Up() * custpos[3])

    ang:RotateAroundAxis(camang:Up(), custang[1])
    ang:RotateAroundAxis(camang:Right(), custang[2])
    ang:RotateAroundAxis(camang:Forward(), custang[3])

    -- camang = self.LastViewModelAng or EyeAngles()
    -- campos = self.LastViewModelPos or EyePos()

    -- camang:RotateAroundAxis(camang:Up(), -custang.p)
    -- camang:RotateAroundAxis(camang:Right(), -custang.y)
    -- camang:RotateAroundAxis(camang:Forward(), -custang.r)

    -- campos = campos + camang:Right() * -custpos.x
    -- campos = campos + camang:Forward() * -custpos.y
    -- campos = campos + camang:Up() * -custpos.z
    local scrrw, scrrh = ScrW(), ScrH()
    if scrrw/scrrh > 1.8 then -- ultrawide fix
        cam.Start3D(campos, camang, self:GetProcessedValue("CustomizeSnapshotFOV"), (scrrw-scrrh*1.77777777)*0.5, 0, scrrh*1.77777777, scrrh, 1, 1024)
    else
        cam.Start3D(campos, camang, self:GetProcessedValue("CustomizeSnapshotFOV"), 0, 0, scrrw, scrrh, 1, 1024)
    end

    render.ClearDepth()

    render.SuppressEngineLighting(true)
    -- render.SetWriteDepthToDestAlpha(false)

    self:SetupModel(true, 0, true)

    -- local mdl = self.CModel[1]

    -- local anim = self:TranslateAnimation("idle")
    -- local ae = self:GetAnimationEntry(anim)
    -- local seq = mdl:LookupSequence(self:RandomChoice(ae.Source))

    -- mdl:ResetSequence(seq)
    -- mdl:SetPoseParameter("sights", 1)

    -- mdl:SetupBones()
    -- mdl:InvalidateBoneCache()

    render.SetBlend(1)
    render.SetColorModulation(1, 1, 1)
    render.MaterialOverride(matshiny)

    render.OverrideColorWriteEnable(true, false)
    -- self:GetVM():DrawModel()
    self:DrawCustomModel(true, pos + Vector(0.5, -0.5, -0.5), ang)
    render.OverrideColorWriteEnable(false, false)

    render.BlurRenderTarget(cammat, 3, 3, 2)

    render.MaterialOverride(matshiny)
    self:DrawCustomModel(true, pos, ang)

    render.MaterialOverride()
    
    if colorrr then
        render.SetWriteDepthToDestAlpha( true )
        render.OverrideBlend( true, BLEND_ONE, BLEND_ZERO, BLENDFUNC_ADD, BLEND_ZERO, BLEND_ONE, BLENDFUNC_ADD )

        self:DrawCustomModel(true, pos, ang)

        render.MaterialOverride()
        render.SetWriteDepthToDestAlpha( false )
    end

    DrawSharpen(0.2, 0.5)
    DrawColorModify(colormodifyicontabll)

    self:KillModel(true)
    render.OverrideBlend( false )
    render.SuppressEngineLighting(false)

    cam.End3D()

    ARC9.PresetCam = false

    render.SetStencilEnable(false)

    -- render.RenderView({
    --     x = 0,
    --     y = 0,
    --     w = preset_res,
    --     h = preset_res,
    --     origin = EyePos(),
    --     angles = EyeAngles(),
    --     fov = 90,
    --     dopostprocess = false,
    --     drawhud = false,
    --     drawmonitors = false,
    --     drawviewmodel = true
    -- })

    local x = (pr_w - 256) / 2

    local data = render.Capture( {
        -- format = ARC9.PresetIconFormat,
        format = "png",
        x = x,
        y = 0,
        w = 256,
        h = 256
    } )

    file.CreateDir(ARC9.PresetPath .. self:GetPresetBase())
    file.Write(filename .. "." .. ARC9.PresetIconFormat, data)
    -- file.Write(ARC9.PresetPath .. self:GetPresetBase() .. "/icon.png", "DATA")

    render.PopRenderTarget()

    self.AutoSelectIcon = Material("data/" .. filename .. "." .. ARC9.PresetIconFormat, "smooth")
    self.InvalidateSelectIcon = false
end

function SWEP:PruneUnnecessaryAttachmentDataRecursive(tbl)

    tbl.t = tbl.ToggleNum
    tbl.i = tbl.Installed
    tbl.s = tbl.SubAttachments

    for i, k in pairs(tbl) do
        if i != "i" and i != "s" and i != "t" then
            tbl[i] = nil
        end
    end

    if table.Count(tbl.s or {}) > 0 then
        for i, k in pairs(tbl.s) do
            self:PruneUnnecessaryAttachmentDataRecursive(k)
        end
    else
        tbl.s = nil
    end

    tbl.BaseClass = nil
end

function SWEP:DecompressTableRecursive(tbl)
    for i, k in pairs(tbl) do
        if i == "i" then
            tbl["i"] = nil
            tbl["Installed"] = k
        elseif i == "s" then
            tbl["s"] = nil
            tbl["SubAttachments"] = k
        elseif i == "t" then
            tbl["t"] = nil
            tbl["ToggleNum"] = k
        end
    end

    if table.Count(tbl.SubAttachments or {}) > 0 then
        for i, k in pairs(tbl.SubAttachments) do
            self:DecompressTableRecursive(k)
        end
    end
end

function SWEP:GetPresetJSON()
    local newtbl = {}

    newtbl = table.Copy(self.Attachments)

    for i, k in pairs(newtbl) do
        self:PruneUnnecessaryAttachmentDataRecursive(k)
    end

    return util.TableToJSON(newtbl)
end

function SWEP:GeneratePresetExportCode()
    local str = self:GetPresetJSON()

    str = util.Compress(str)
    str = util.Base64Encode(str, true)

    return str
end

function SWEP:ImportPresetCode(str)
    if !str then return end
    str = util.Base64Decode(str)
    str = util.Decompress(str)

    if !str then return end

    local tbl = util.JSONToTable(str)

    if tbl then
        for i, k in pairs(tbl) do
            self:DecompressTableRecursive(k)
        end
    end

    return tbl
end

function SWEP:SplitPresetContents(str)
    if str[1] != "[" then return end
    if !string.find(str, "]X") then return end
    local name = string.sub(string.Split(str, "]")[1], 2)
    local tbl = string.Split(str, "]")[2]

    return name, tbl
end

function SWEP:CreateStandardPresets()
    local newloaded

    if self.StandardPresets then
        for _, v in ipairs(self.StandardPresets) do
            local name = self:SplitPresetContents(v)
            if !name then continue end

            if file.Exists(ARC9.PresetPath .. self:GetPresetBase() .. "/" .. name .. ".txt", "DATA") then continue end

            if !self:LoadPresetFromCode(v, true) then print("Something gone wrong with standard preset!") continue end

            newloaded = true
        end

        if newloaded then
            self:LoadPreset("default")
        end
    end
end

local function deletefolder(path)
    local files, folders = file.Find(path .. "*", "DATA")
    for _, v in ipairs(files) do file.Delete(path .. v) end
    for _, v in ipairs(folders) do deletefolder(path .. v .. "/") end

    file.Delete(path)
end

concommand.Add("arc9_presets_clear", function(ply)
    if !IsValid(ply) then return end

    local weapon = ply:GetActiveWeapon()

    if IsValid(weapon) and weapon.ARC9 then
        deletefolder(ARC9.PresetPath .. (weapon.SaveBase or weapon:GetClass()) .. "/")
    else
        deletefolder(ARC9.PresetPath)
    end
end)

--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/cl_sway.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/cl_sway.lua:
SWEP.ViewModelVelocityPos = Vector()
SWEP.ViewModelVelocityAng = Angle()
SWEP.ViewModelPos = Vector()
SWEP.ViewModelAng = Angle()

local lasteyeang = Angle()
local smootheyeang = Angle()
local posoffset = Vector()
local smoothswayroll = 0
local smoothswaypitch = 0

function SWEP:GetViewModelSway(pos, ang)
    local ft = FrameTime()
    local sightmult = 0.5 + math.Clamp(1/ft/100, 0, 5) -- for consistent offset on high and low fps
    sightmult = sightmult * Lerp(self:GetSightAmount(), 1, 0.25)

    smootheyeang = LerpAngle(math.Clamp(ft * 24, 0.075, 1), smootheyeang, EyeAngles() - lasteyeang)
    lasteyeang = EyeAngles()

    smoothswayroll = Lerp(math.Clamp(ft * 24, 0.075, 1), smoothswayroll, smootheyeang.y)
    if self.SprintVerticalOffset then
        local sprintoffset = (ang.p * 0.06) * Lerp(self:GetSprintAmount(), 0, 1)
        pos:Add(ang:Up() * sprintoffset)
        pos:Add(ang:Forward() * sprintoffset)
    end

    smootheyeang.p = math.Clamp(smootheyeang.p * 0.95, -10, 10)
    smootheyeang.y = math.Clamp(smootheyeang.y * 0.9, -4, 4)
    smootheyeang.r = math.Clamp(smoothswayroll * (0.5 + math.Clamp(ft * 64, 0, 4)), -2, 2)
    
    local inertiaanchor = Vector(self.CustomizeRotateAnchor)
    inertiaanchor.x = inertiaanchor.x * 0.75

    local rap_pos, rap_ang = self:RotateAroundPoint2(pos, ang, inertiaanchor, vector_origin, smootheyeang * sightmult)
    pos:Set(rap_pos)
    ang:Set(rap_ang)

    return pos, ang
end

SWEP.ViewModelLastEyeAng = Angle()
SWEP.ViewModelSwayInertia = Angle()

function SWEP:GetViewModelInertia(pos, ang)
    local eyeangg = self:GetOwner():EyeAngles()
    local ft = FrameTime()

    local d = 1 - self:GetSightAmount()
    local diff = eyeangg - self.ViewModelLastEyeAng
    diff = diff / 4
    diff.p = math.Clamp(diff.p, -1, 1)
    diff.y = math.Clamp(diff.y, -1, 1)
    local vsi = self.ViewModelSwayInertia
    vsi.p = math.ApproachAngle(vsi.p, diff.p, vsi.p / 10 * ft / 0.5)
    vsi.y = math.ApproachAngle(vsi.y, diff.y, vsi.y / 10 * ft / 0.5)
    self.ViewModelLastEyeAng = eyeangg
    ang:RotateAroundAxis(ang:Up(), vsi.y * 12 * d)
    ang:RotateAroundAxis(ang:Right(), -vsi.p * 12 * d)
    -- pos = pos - (ang:Up() * vsi.p * 0.5 * d)
    -- pos = pos - (ang:Right() * vsi.y * 0.5 * d)

    return pos, ang
end

function SWEP:GetViewModelSmooth(pos, ang)
    return pos, ang
end

SWEP.ViewModelBobVelocity = 0
SWEP.ViewModelNotOnGround = 0
SWEP.BobCT = 0

local v = 0

local offset = Vector()
local affset = Angle()

local airtime = 0

local stammer = 0
local stammer_moving = false

local function FesiugBob(self, pos, ang)
    if self:GetCustomize() then return pos, ang end
    local owner = self:GetOwner()

    local sharedmult = owner:IsSprinting() and self.BobSprintMult or self.BobWalkMult

    local cv = owner:GetVelocity():Length()
    v = math.Approach(v, cv, FrameTime()*400/0.4)
    v = math.Clamp(v, 0, 400)
    local tv = v / 400
    tv = tv * 1.1
    local mulp = Lerp(self:GetSightDelta(), 1, 0.15)
    local mulk = Lerp(self:GetSightDelta(), 1, 0.3)
    local tk = tv * mulk
    tv = tv * mulp
    self.BobScale = 0
    local p = math.pi
    local spe = self:GetIsSprinting()

    local grounded = (owner:IsOnGround() or owner:GetMoveType() == MOVETYPE_NOCLIP)
    airtime = math.Approach(airtime, (grounded and 0 or 1), FrameTime()*5*(grounded and 10 or 1))

    offset:Set(vector_origin)
    affset:Set(angle_zero)

    local ct = ( (CurTime() * 1.1) % (0.975 * ((1/1.1)+0.1)) )

    offset.x = offset.x + math.sin( ct * p * 2 ) * 0.2 * ( spe and -2 or 1 )
    offset.y = offset.y + math.pow(math.sin( ct * p * 2 ), 2) * -0.5 * ( spe and -2 or 1 )
    offset.z = offset.z + math.abs(math.sin( ct * p * -1 )) * -0.15

    offset.z = offset.z + math.pow(math.abs( math.sin(ct * p * 2) ), 6) * -0.395 * ( spe and -4 or 0 )

    offset.z = offset.z + ( (-0.395/2)*3 * tv )

    offset.z = offset.z + ( math.pow(math.sin((ct+0)*p*2.5), 2) * -0.3 )
    offset.z = offset.z + ( math.pow(math.sin((ct+0.3)*p*2.5), 2) * -0.3 )

    affset.x = affset.x - ( math.pow( math.sin( ct * p ) * 2.2, 2 ) - ( (2.2/2) * tv ) ) * ( spe and 2 or 1 )
    affset.y = affset.y + math.sin( ct * p * -(3) ) * 0.5 * 1.5
    affset.z = affset.z + ( ( ((ct/2) % 1) < 0.5 and -1 or 2 ) * math.sin( ct * p * 2 ) * 2 * 1.5 ) * ( spe and 2 or 1 )
    affset.z = affset.z + ( ( ((ct/2) % 1) > 0.5 and -1 or 2 ) * math.sin( ct * p * 2 ) * 2 * 1.5 ) * ( spe and 2 or 1 )

    affset.x = affset.x + ( (-2) * tv )

    pos:Add( ang:Right()     *   offset.x * tv * sharedmult )
    pos:Add( ang:Forward()   *   offset.y * tv * sharedmult )
    pos:Add( ang:Up()        *   offset.z * tv * sharedmult )

    local stammertime_pos = Vector()
    local stammertime_ang = Angle()

    local pep = owner:KeyDown(IN_FORWARD) or owner:KeyDown(IN_BACK) or owner:KeyDown(IN_MOVELEFT) or owner:KeyDown(IN_MOVERIGHT)
    if tk > 0.1 then
        stammer = 1
        stammer_moving = true
    else
        stammer_moving = false
        stammer = math.Approach(stammer, 0, FrameTime()*3)
    end
    local elistam = (!pep and stammer or 0)*Lerp(self:GetSightDelta(), 1, 0.3)

    stammertime_pos.x = stammertime_pos.x + math.sin( ct * p * 5*1.334 ) * -0.05
    stammertime_pos.y = stammertime_pos.y + elistam*-0.5
    stammertime_pos.z = stammertime_pos.z + elistam*-0.25
    stammertime_ang.y = stammertime_ang.y + math.sin( ct * p * 2*1.334 ) * 0.8
    stammertime_ang.z = stammertime_ang.z + math.sin( ct * p * 5*1.334 ) * 0.5

    pos:Add( ang:Right()     *   stammertime_pos.x * elistam * sharedmult )
    pos:Add( ang:Forward()   *   stammertime_pos.y * elistam * sharedmult )
    pos:Add( ang:Up()        *   stammertime_pos.z * elistam * sharedmult )

    ang:RotateAroundAxis( ang:Forward(),        affset.x * tv * sharedmult )
    ang:RotateAroundAxis( ang:Right(),          affset.y * tv * sharedmult )
    ang:RotateAroundAxis( ang:Up(),             affset.z * tv * sharedmult )

    ang:RotateAroundAxis( ang:Forward(),        stammertime_ang.x * elistam * sharedmult )
    ang:RotateAroundAxis( ang:Right(),          stammertime_ang.y * elistam * sharedmult )
    ang:RotateAroundAxis( ang:Up(),             stammertime_ang.z * elistam * sharedmult )
    ang:RotateAroundAxis( ang:Up(),             (owner:KeyDown(IN_MOVELEFT) and 2 or owner:KeyDown(IN_MOVERIGHT) and -2 or 0) * tv )

    ang:RotateAroundAxis( ang:Forward(),          math.sin( ct * p * 1 ) * airtime*-5 * mulp * 2)
    ang:RotateAroundAxis( ang:Right(),          ( math.sin( ct * p * 1 ) * airtime*3 * mulp ) + ( (3/2) * airtime * mulp ) ) 
    ang:RotateAroundAxis( ang:Up(),          math.sin( ct * p * 2 ) * airtime*2 * mulp )

    return pos, ang
end

local function ArcticBob(self, pos, ang)
    local step = 10
    local mag = 1
    local ts = 0 -- self:GetTraversalSprintAmount()
    -- ts = 1
    if self:GetCustomize() then return pos, ang end

    local owner = self:GetOwner()
    local ft = FrameTime()

    local sharedmult = owner:IsSprinting() and self.BobSprintMult or self.BobWalkMult

    local v = owner:GetVelocity():Length()
    v = math.Clamp(v, 0, 350)
    self.ViewModelBobVelocity = math.Approach(self.ViewModelBobVelocity, v, ft * 10000)
    local d = math.Clamp(self.ViewModelBobVelocity / 350, 0, 1)

    if owner:OnGround() and owner:GetMoveType() != MOVETYPE_NOCLIP then
        self.ViewModelNotOnGround = math.Approach(self.ViewModelNotOnGround, 0, ft / 0.1)
    else
        self.ViewModelNotOnGround = math.Approach(self.ViewModelNotOnGround, 1, ft / 0.1)
    end

    d = d * Lerp(self:GetSightAmount(), 1, 0.5) * Lerp(ts, 1, 1.5)
    mag = d * 2
    mag = mag * Lerp(ts, 1, 1.5)
    step = 10
    ang:RotateAroundAxis(ang:Forward(), math.sin(self.BobCT * step * 0.5) * ((math.sin(self.BobCT * 6.151) * 0.2) + 1) * 4.5 * d * sharedmult)
    ang:RotateAroundAxis(ang:Right(), math.sin(self.BobCT * step * 0.12) * ((math.sin(self.BobCT * 1.521) * 0.2) + 1) * 2.11 * d * sharedmult)
    pos = pos - (ang:Up() * math.sin(self.BobCT * step) * 0.1 * ((math.sin(self.BobCT * 3.515) * 0.2) + 1) * mag * sharedmult)
    pos = pos + (ang:Forward() * math.sin(self.BobCT * step * 0.3) * 0.11 * ((math.sin(self.BobCT * 2) * ts * 1.25) + 1) * ((math.sin(self.BobCT * 1.615) * 0.2) + 1) * mag * sharedmult)
    pos = pos + (ang:Right() * (math.sin(self.BobCT * step * 0.15) + (math.cos(self.BobCT * step * 0.3332))) * 0.16 * mag * sharedmult)
    
    local steprate = Lerp(d, 1, 2.5)
    steprate = Lerp(self.ViewModelNotOnGround, steprate, 0.25)

    if IsFirstTimePredicted() or game.SinglePlayer() then
        self.BobCT = self.BobCT + (ft * steprate)
    end

    return pos, ang
end

local smoothsidemove = 0
local smoothjumpmove = 0

local function ArcticBreadBob(self, pos, ang)
    local step = 10
    local mag = 1
    local ts = 0 -- self:GetTraversalSprintAmount()
    -- ts = 1
    if self:GetCustomize() then return pos, ang end

    local owner = self:GetOwner()
    local ft = FrameTime()

    local sharedmult = owner:IsSprinting() and self.BobSprintMult or self.BobWalkMult

    local velocityangle = owner:GetVelocity()
    local v = velocityangle:Length()
    v = math.Clamp(v, 0, 350)
    self.ViewModelBobVelocity = math.Approach(self.ViewModelBobVelocity, v, ft * 10000)
    local d = math.Clamp(self.ViewModelBobVelocity / 350, 0, 1)

    if owner:OnGround() and owner:GetMoveType() != MOVETYPE_NOCLIP then
        self.ViewModelNotOnGround = math.Approach(self.ViewModelNotOnGround, 0, ft / 0.1)
    else
        self.ViewModelNotOnGround = math.Approach(self.ViewModelNotOnGround, 1, ft / 0.1)
    end

    local sightamount = self:GetSightAmount()

    d = d * Lerp(sightamount, 1,0.03) * Lerp(ts, 1, 1.5)
    mag = d * 2
    mag = mag * Lerp(ts, 1, 2)
    step = 10

    local sidemove = ((owner:KeyDown(IN_MOVERIGHT) and 1 or 0) - (owner:KeyDown(IN_MOVELEFT) and 1 or 0)) * 8 * (1.1-sightamount)
    smoothsidemove = Lerp(math.Clamp(ft*8, 0, 1), smoothsidemove, sidemove)

    local crouchmult = 1
    if owner:Crouching() then 
        crouchmult = 3.5 + sightamount* 10
        step = 6
    end
    
    local jumpmove = math.Clamp(math.ease.InExpo(math.Clamp(velocityangle.z, -150, 0)/-150)*0.5 + math.ease.InExpo(math.Clamp(velocityangle.z, 0, 350)/350)*-50, -4, 2.5) * 0.5   -- crazy math for jump movement
    smoothjumpmove = Lerp(math.Clamp(ft*8, 0, 1), smoothjumpmove, jumpmove)
    local smoothjumpmove2 = math.Clamp(smoothjumpmove, -0.3, 0.01) * (1.5-sightamount)


    if owner.GetSliding then if owner:GetSliding() then mag = 0 step = 5 smoothsidemove = 0 end end

    if owner:IsSprinting() then 
        pos = pos - (ang:Up() * math.sin(self.BobCT * step) * 0.45 * ((math.sin(self.BobCT * 3.515) * 0.2) + 1) * mag * sharedmult)
        pos = pos + (ang:Forward() * math.sin(self.BobCT * step * 0.3) * 0.11 * ((math.sin(self.BobCT * 2) * ts * 1.25) + 1) * ((math.sin(self.BobCT * 0.615) * 0.2) + 2) * mag * sharedmult)
        pos = pos + (ang:Right() * (math.sin(self.BobCT * step * 0.5) + (math.cos(self.BobCT * step * 0.5))) * 0.55 * mag * sharedmult)
        ang:RotateAroundAxis(ang:Forward(), math.sin(self.BobCT * step * 0.5) * ((math.sin(self.BobCT * 6.151) * 0.2) + 1) * 9 * d * sharedmult + smoothsidemove * 1.5)
        ang:RotateAroundAxis(ang:Right(), math.sin(self.BobCT * step * 0.12) * ((math.sin(self.BobCT * 1.521) * 0.2) + 1) * 1 * d * sharedmult)
        ang:RotateAroundAxis(ang:Up(), math.sin(self.BobCT * step * 0.5) * ((math.sin(self.BobCT * 1.521) * 0.2) + 1) * 6 * d * sharedmult)
        ang:RotateAroundAxis(ang:Right(), smoothjumpmove2 * 5)
    else
        pos = pos - (ang:Up() * math.sin(self.BobCT * step) * 0.1 * ((math.sin(self.BobCT * 3.515) * 0.2) + 2) * mag * crouchmult * sharedmult) - (ang:Up() * smoothsidemove * -0.05) - (ang:Up() * smoothjumpmove2 * 0.2)
        pos = pos + (ang:Forward() * math.sin(self.BobCT * step * 0.3) * 0.11 * ((math.sin(self.BobCT * 2) * ts * 1.25) + 1) * ((math.sin(self.BobCT * 0.615) * 0.2) + 1) * mag * sharedmult)
        pos = pos + (ang:Right() * (math.sin(self.BobCT * step * 0.5) + (math.cos(self.BobCT * step * 0.5))) * 0.55 * mag * sharedmult)
        ang:RotateAroundAxis(ang:Forward(), math.sin(self.BobCT * step * 0.5) * ((math.sin(self.BobCT * 6.151) * 0.2) + 1) * 5 * d * sharedmult + smoothsidemove)
        ang:RotateAroundAxis(ang:Right(), math.sin(self.BobCT * step * 0.12) * ((math.sin(self.BobCT * 1.521) * 0.2) + 1) * 0.1 * d * sharedmult)
        ang:RotateAroundAxis(ang:Right(), smoothjumpmove2 * 5)
    end

    local steprate = Lerp(d, 1, 2.75)
    steprate = Lerp(self.ViewModelNotOnGround, steprate, 0.75)

    if IsFirstTimePredicted() or game.SinglePlayer() then
        self.BobCT = self.BobCT + (ft * steprate)
    end

    return pos, ang
end


local function ArcticBreadDarsuBob(self, pos, ang)
    local step = 10
    local mag = 1
    local ts = 0 -- self:GetTraversalSprintAmount()
    -- ts = 1
    if self:GetCustomize() then return pos, ang end

    local owner = self:GetOwner()
    local ft = FrameTime()

    local sharedmult = owner:IsSprinting() and self.BobSprintMult or self.BobWalkMult

    local velocityangle = owner:GetVelocity()
    local v = velocityangle:Length()
    v = math.Clamp(v, 0, 350)
    self.ViewModelBobVelocity = math.Approach(self.ViewModelBobVelocity, v, ft * 10000)
    local d = math.Clamp(self.ViewModelBobVelocity / 350, 0, 1)
    -- d = math.ease.InSine(d)
    if owner:OnGround() and owner:GetMoveType() != MOVETYPE_NOCLIP then
        self.ViewModelNotOnGround = math.Approach(self.ViewModelNotOnGround, 0, ft / 0.1)
    else
        self.ViewModelNotOnGround = math.Approach(self.ViewModelNotOnGround, 1, ft / 0.1)
    end
    
    local sightamount = self:GetSightAmount() - (self.Peeking and 0.72 or 0.1)

    d = d * Lerp(sightamount, 1,0.03) * Lerp(ts, 1, 1.5)
    mag = d * 2
    mag = mag * Lerp(ts, 1, 2)
    step = 9.25

    local sidemove = ((owner:KeyDown(IN_MOVERIGHT) and 1 or 0) - (owner:KeyDown(IN_MOVELEFT) and 1 or 0)) * 3 * (1.5-sightamount)
    smoothsidemove = Lerp(math.Clamp(ft*8, 0, 1), smoothsidemove, sidemove)

    local crouchmult = 1
    if owner:Crouching() then 
        crouchmult = 3.5 + sightamount * 3
        step = 6
    end
    
    local jumpmove = math.Clamp(math.ease.InExpo(math.Clamp(velocityangle.z, -150, 0)/-150)*0.5 + math.ease.InExpo(math.Clamp(velocityangle.z, 0, 350)/350)*-50, -4, 2.5) * 0.5   -- crazy math for jump movement
    smoothjumpmove = Lerp(math.Clamp(ft*8, 0, 1), smoothjumpmove, jumpmove)
    local smoothjumpmove2 = math.Clamp(smoothjumpmove, -0.3, 0.01) * (1.5-sightamount) * 2


    if owner.GetSliding then if owner:GetSliding() then mag = 0 step = 5 smoothsidemove = 0 end end
    

    if owner:IsSprinting() then 
        pos = pos - (ang:Up() * math.sin(self.BobCT * step) * 0.45 * ((math.sin(self.BobCT * 3.515) * 0.2) + 1) * mag * sharedmult)
        pos = pos + (ang:Forward() * math.sin(self.BobCT * step * 0.3) * 0.13 * ((math.sin(self.BobCT * 2) * ts * 1.25) + 2) * ((math.sin(self.BobCT * 0.615) * 0.2) + 2) * mag * sharedmult)
        pos = pos + (ang:Right() * (math.sin(self.BobCT * step * 0.5) + (math.cos(self.BobCT * step * 0.5))) * 0.55 * mag * sharedmult)
        ang:RotateAroundAxis(ang:Forward(), math.sin(self.BobCT * step * 0.5) * ((math.sin(self.BobCT * 6.151) * 0.2) + 1) * 9 * d * sharedmult + smoothsidemove * 1.5)
        ang:RotateAroundAxis(ang:Right(), math.sin(self.BobCT * step * 0.12) * ((math.sin(self.BobCT * 1.521) * 0.2) + 1) * 1 * d * sharedmult)
        ang:RotateAroundAxis(ang:Up(), math.sin(self.BobCT * step * 0.5) * ((math.sin(self.BobCT * 1.521) * 0.2) + 1) * 6 * d * sharedmult)
        ang:RotateAroundAxis(ang:Right(), smoothjumpmove2 * 5)
    else
        pos = pos - (ang:Up() * math.sin(self.BobCT * step) * 0.1 * ((math.sin(self.BobCT * 3.515) * 0.2) + 1.5) * mag * crouchmult * sharedmult) - (ang:Up() * smoothsidemove * -0.05) - (ang:Up() * smoothjumpmove2 * 0.2)
        pos = pos + (ang:Forward() * math.sin(self.BobCT * step * 0.3) * 0.11 * ((math.sin(self.BobCT * 2) * ts * 1.25) + 1) * ((math.sin(self.BobCT * 0.615) * 0.2) + 1) * mag * sharedmult)
        pos = pos + (ang:Right() * (math.sin(self.BobCT * step * 0.5) + (math.cos(self.BobCT * step * 0.5))) * 0.2 * mag * sharedmult)
        ang:RotateAroundAxis(ang:Forward(), math.sin(self.BobCT * step * 0.5) * ((math.sin(self.BobCT * 6.151) * 0.2) + 1) * 5 * d * sharedmult + smoothsidemove)
        ang:RotateAroundAxis(ang:Right(), math.sin(self.BobCT * step * 0.12) * ((math.sin(self.BobCT * 1.521) * 0.2) + 1) * 0.1 * d * sharedmult)
        ang:RotateAroundAxis(ang:Right(), smoothjumpmove2 * 5)
    end

    local steprate = Lerp(d, 1, 2.75)
    steprate = Lerp(self.ViewModelNotOnGround, steprate, 0.75)

    if IsFirstTimePredicted() or game.SinglePlayer() then
        self.BobCT = self.BobCT + (ft * steprate)
    end

    return pos, ang
end

local notonground = 0

-- Default table will be close to old movement to keep compat with all guns
local defbobsettingstable  = {0.5, 0.25, 1,    0.75, 2, 0.875} -- x y z   p y r
local defbobsettingstable2 = {1, 0.75, 1,      1, 1, 0.75}       -- x y z   p y r
-- Edit SWEP.BobSettingsMove/Speed in your own swep to make it better for you! values can be negaitve

local function DarsuBob(self, pos, ang)
    self.BobScale = 0 -- hl2 bob removal
    if self:GetCustomize() then return pos, ang end

    local owner = self:GetOwner()
    local ft = FrameTime()
    local velocityangle = owner:GetVelocity()
    local sightamount = self:GetSightAmount() - (self.Peeking and 0.72 or 0)
    local sprintamount = self:GetSprintAmount()

    local sharedmult = owner:IsSprinting() and self.BobSprintMult or self.BobWalkMult

    local velocity = math.Clamp(velocityangle:Length(), 0, 350)

    self.ViewModelBobVelocity = math.Approach(self.ViewModelBobVelocity, velocity, ft * 10000)
    
    local d = math.Clamp(self.ViewModelBobVelocity / 350, 0, 0.75)

    notonground = math.Approach(notonground, (owner:OnGround() and owner:GetMoveType() != MOVETYPE_NOCLIP) and 0 or 1, ft / 0.1)
    local steprate = Lerp(d, 1, 2.5)
    steprate = Lerp(notonground, steprate, 0.5)


    local jumpmove = math.Clamp(math.ease.InExpo(math.Clamp(velocityangle.z, -350, 0)/-350)*25 + math.ease.InExpo(math.Clamp(velocityangle.z, 0, 350)/350)*-60, -5, 3.5) * (1.5-sightamount) -- crazy math for jump movement
    smoothjumpmove = Lerp(math.Clamp(ft*8, 0, 1), smoothjumpmove, jumpmove)


    if IsFirstTimePredicted() or game.SinglePlayer() then self.BobCT = self.BobCT + (ft * steprate) end
    
    d = d * Lerp(sightamount, 1.4, 0.8) -- If we in sights make less moves

    local d2 = math.ease.InQuart(d)
    local d3 = math.ease.InQuad(d) * 0.6
    local speedmult = 1.4
    local speedmultang = 1.45

    local settings = self.BobSettingsMove or defbobsettingstable -- custom bob per gun
    local settings2 = self.BobSettingsSpeed or defbobsettingstable2
    local xm, ym, zm, pm, yym, rm = settings[1], settings[2], settings[3], settings[4], settings[5], settings[6]
    local xms, yms, zms, pms, yyms, rms = settings2[1], settings2[2], settings2[3], settings2[4], settings2[5], settings2[6]

    local sidemove = ((owner:KeyDown(IN_MOVERIGHT) and 1 or 0) - (owner:KeyDown(IN_MOVELEFT) and 1 or 0)) * 3 * (1.1-sightamount)
    smoothsidemove = Lerp(math.Clamp(ft*8, 0, 1), smoothsidemove, sidemove)

    local crouchmult = (owner:Crouching() and not owner:IsSprinting()) and 2.5*(1.3-sightamount)  or 1
    
    if owner.GetSliding then if owner:GetSliding() then speedmult = 0.01 d3 = 0 smoothsidemove = -10 end end

    pos:Sub(ang:Right() *          math.sin(speedmult * self.BobCT * 5 * xms)  * d2 * 0.5 * Lerp(sprintamount, 1, 0.05) * xm * sharedmult)                                   -- X 
    pos:Sub(ang:Up() *             math.cos(speedmult * self.BobCT * 7 * yms)    * d * 0.05 * (crouchmult*crouchmult*crouchmult) * Lerp(sprintamount, 1, 0.3) * ym * sharedmult)                     -- Y
    pos:Sub(ang:Forward() *        math.sin(speedmult * self.BobCT * 4 * zms)  * d2 * 0.75 * crouchmult * zm * sharedmult)                   -- Z

    ang:RotateAroundAxis(ang:Right(),   math.sin(speedmultang * self.BobCT * 5.5 * pms + 0.3)    * d3 * 2.25 * pm * sharedmult + smoothjumpmove)                  -- P
    ang:RotateAroundAxis(ang:Up(),      math.cos(speedmultang * self.BobCT * 3.3 * yyms)  * d3 * 1 * Lerp(sprintamount, 1, 0.1) * yym * sharedmult)                                   -- Y
    ang:RotateAroundAxis(ang:Forward(), math.sin(speedmultang * self.BobCT * 6 * rms)    * d3 * 4.5 * crouchmult * rm * sharedmult + smoothsidemove)   -- R

    return pos, ang
end

local arc9_vm_bobstyle = GetConVar("arc9_vm_bobstyle")

function SWEP:GetViewModelBob(pos, ang)
    self.SwayScale = 0
    self.BobScale = 0
    local bobb = arc9_vm_bobstyle:GetInt()

    if bobb == 1 then
        return FesiugBob(self, pos, ang)
    elseif bobb == 2 then
        return ArcticBob(self, pos, ang)
    elseif bobb == 3 then
        return DarsuBob(self, pos, ang)
    elseif bobb == 4 then
        return ArcticBreadBob(self, pos, ang)
    elseif bobb == 0 then
        return ArcticBreadDarsuBob(self, pos, ang)
    else
        self.SwayScale = Lerp(self:GetSightDelta(), 1, 0.01)
        self.BobScale = Lerp(self:GetSightDelta(), 1, 0.01)

        return pos, ang
    end
end


SWEP.LastViewModelVerticalVelocity = 0

-- SWEP.ViewModelLanded = 0
-- SWEP.ViewModelLanding = 0
function SWEP:GetMidAirBob(pos, ang)
    if self:GetCustomize() then return pos, ang end
    local v = -self:GetOwner():GetVelocity().z / 200
    v = math.Clamp(v, -1, 1)
    -- if v == 0 and self.LastViewModelVerticalVelocity != 0 then
    --     self.ViewModelLanding = self.LastViewModelVerticalVelocity
    --     self.ViewModelLanded = 1
    -- end
    -- if self.ViewModelLanded > 0 then
    --     self.ViewModelLanded = math.Approach(self.ViewModelLanded, 0, FrameTime() / 0.25)
    v = Lerp(5 * FrameTime(), self.LastViewModelVerticalVelocity, v)
    -- end
    self.LastViewModelVerticalVelocity = v
    local d = self.ViewModelNotOnGround
    d = d * Lerp(self:GetSightAmount(), 1, 0.1)
    -- ang:RotateAroundAxis(ang:Right(), -v * d * 8 * math.sin(CurTime() * 0.15))
    pos = pos + ang:Up() * -v * d * 2 * math.sin(CurTime() * 0.15)

    return pos, ang
end

SWEP.ViewModelInertiaX = 0
SWEP.ViewModelInertiaY = 0

function SWEP:GetViewModelLeftRight(pos, ang)
    if self:GetCustomize() then return pos, ang end
    local owner = self:GetOwner()
    local ft = FrameTime()

    local v = owner:GetVelocity()
    local d = Lerp(self:GetSightDelta(), 1, 0)
    v, _ = WorldToLocal(v, Angle(), Vector(), owner:EyeAngles())
    local vx = math.Clamp(v.x / 200, -1, 1)
    local vy = math.Clamp(v.y / 200, -1, 1)
    self.ViewModelInertiaX = math.Approach(self.ViewModelInertiaX, vx, math.abs(vx) * ft / 0.1)
    self.ViewModelInertiaY = math.Approach(self.ViewModelInertiaY, vy, math.abs(vy) * ft / 0.1)
    pos = pos + (ang:Right() * -self.ViewModelInertiaX * 0.65 * d)
    pos = pos + (ang:Forward() * self.ViewModelInertiaY * 0.5 * d)

    return pos, ang
end
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/cl_thirdarm.lua:
SWEP.ThirdArmModel = nil
SWEP.ThirdArmAnimationTime = 0
SWEP.ThirdArmAnimationLength = 0
SWEP.ThirdArmAnimation = {}
SWEP.ThirdArmPersist = false

SWEP.ThirdArmGunOffsetPos = Vector(0, 0, 0)
SWEP.ThirdArmGunOffsetAngle = Angle(0, 0, 0)

SWEP.ThirdArmCamOffsetPos = Vector(0, 0, 0)
SWEP.ThirdArmCamOffsetAngle = Angle(0, 0, 0)

-- local tbl = {
--     rig = "path/to/model.mdl",
--     sequence = "sequence",
--     mult = 1,
--     invisible = false,
--     gun_controller_attachment = 1,
--     cam_controller_attachment = 2,
--     offsetang = Angle(0, 0, 0),
--     timeline = {
--         {
--             t = 0,
--             lhik = 0,
--             rhik = 0.2
--         },
--         {
--             t = 0.5,
--             lhik = 1,
--         },
--         {
--             t = 1,
--             lhik = 0
--         }
--     },
--     soundtable = {}
-- }

local function qerp(delta, a, b)
    local qdelta = -(delta ^ 2) + (delta * 2)

    qdelta = math.Clamp(qdelta, 0, 1)

    return Lerp(qdelta, a, b)
end

function SWEP:PlayThirdArmAnim(tbl, persist)
    local rig = tbl.rig

    -- if !self.ThirdArmModel or tbl.rig != (self.ThirdArmAnimation or {}).rig then
        if IsValid(self.ThirdArmModel) then
            SafeRemoveEntity(self.ThirdArmModel)
        end
        self.ThirdArmModel = ClientsideModel(rig)
    -- end

    table.insert(ARC9.CSModelPile, {Model = self.ThirdArmModel, Weapon = self})

    if !IsValid(self.ThirdArmModel) then return end

    local seq = self.ThirdArmModel:LookupSequence(self:RandomChoice(tbl.sequence))
    self.ThirdArmModel:ResetSequence(seq)

    -- if tbl.invisible then
        self.ThirdArmModel:SetNoDraw(true)
    -- end

    local mult = tbl.mult or 1

    self.ThirdArmModel:SetPlaybackRate(mult)

    self.ThirdArmAnimation = tbl
    self.ThirdArmAnimationTime = CurTime()
    self.ThirdArmAnimationLength = math.abs(self.ThirdArmModel:SequenceDuration() / self.ThirdArmModel:GetPlaybackRate())

    self.ThirdArmPersist = persist

    self.ThirdArmModel:SetPos(vector_origin)
    self.ThirdArmModel:SetAngles(angle_zero)

    self.ThirdArmModel:SetupBones()
    self.ThirdArmModel:InvalidateBoneCache()

    if tbl.gun_controller_attachment != nil then
        local posang = self.ThirdArmModel:GetAttachment(tbl.gun_controller_attachment)
        self.ThirdArmGunOffsetAngle = posang.Ang
        self.ThirdArmGunOffsetPos = posang.Pos
    end

    if tbl.cam_controller_attachment != nil then
        local posang = self.ThirdArmModel:GetAttachment(tbl.cam_controller_attachment)
        self.ThirdArmCamOffsetAngle = posang.Ang
        self.ThirdArmCamOffsetPos = posang.Pos
    end

    if tbl.soundtable then
        self:PlaySoundTable(tbl.soundtable, mult)
    end

    self.ThirdArmModel:SetPos(EyePos())
    self.ThirdArmModel:SetAngles(EyeAngles())
end

function SWEP:PreDrawThirdArm()
    if IsValid(self.ThirdArmModel) then
        self.ThirdArmModel:SetPos(EyePos())
        self.ThirdArmModel:SetAngles(EyeAngles())

        local iket = self.ThirdArmAnimationLength
        local iklt = math.Clamp((CurTime() - self.ThirdArmAnimationTime) / iket, 0, 1)
        self.ThirdArmModel:SetCycle(iklt)

        if !self.ThirdArmAnimation.invisible then
            self.ThirdArmModel:DrawModel()
        end
    end
end

function SWEP:ThinkThirdArm()
    if IsValid(self.ThirdArmModel) then
        if (!self.ThirdArmPersist) and (self.ThirdArmAnimationTime + self.ThirdArmAnimationLength < CurTime()) then
            SafeRemoveEntity(self.ThirdArmModel)
            self.ThirdArmModel = nil
        end
    end
end

function SWEP:LHIKThirdArm()
    -- local vm = self:GetOwner():GetHands()
    local vm = self:GetVM()

    if !IsValid(vm) then return end
    if !self.UseHands then return end

    -- vm:SetupBones()

    local lh_delta = 1
    local rh_delta = 1

    local iktl = self.ThirdArmAnimation.timeline

    if !iktl then return end

    local iket = self.ThirdArmAnimationLength
    local iklt = math.Clamp((CurTime() - self.ThirdArmAnimationTime) / iket, 0, 1)

    if iktl then
        local next_stage_index

        for i, k in ipairs(iktl) do
            if !k or !k.t then continue end
            if k.t > iklt then
                next_stage_index = i
                break
            end
        end

        if next_stage_index then
            if next_stage_index == 1 then
                -- we are on the first stage.
                stage = {t = 0, lhik = 0}
                next_stage = iktl[next_stage_index]
            else
                stage = iktl[next_stage_index - 1]
                next_stage = iktl[next_stage_index]
            end
        else
            stage = iktl[#iktl]
            next_stage = {t = iket, lhik = iktl[#iktl].lhik}
        end

        local local_time = iklt

        local delta_time = next_stage.t - stage.t
        delta_time = (local_time - stage.t) / delta_time

        delta_time = math.ease.InOutQuart(delta_time)

        lh_delta = qerp(delta_time, stage.lhik, next_stage.lhik)

        next_stage_index = nil

        for i, k in ipairs(iktl) do
            if !k or !k.t then continue end
            if k.t > iklt then
                next_stage_index = i
                break
            end
        end

        if next_stage_index then
            if next_stage_index == 1 then
                -- we are on the first stage.
                stage = {t = 0, rhik = 0}
                next_stage = iktl[next_stage_index]
            else
                stage = iktl[next_stage_index - 1]
                next_stage = iktl[next_stage_index]
            end
        else
            stage = iktl[#iktl]
            next_stage = {t = iket, rhik = iktl[#iktl].rhik}
        end

        local_time = iklt

        delta_time = next_stage.t - stage.t
        delta_time = (local_time - stage.t) / delta_time

        delta_time = math.ease.InOutQuart(delta_time)

        rh_delta = qerp(delta_time, stage.rhik, next_stage.rhik)
    end

    local rhik_model = self.ThirdArmModel

    if IsValid(rhik_model) then
        rhik_model:SetupBones()
        for _, bone in ipairs(ARC9.RHIKBones) do
            local vm_bone = vm:LookupBone(bone)
            local target_bone = rhik_model:LookupBone(bone)

            if !vm_bone or !target_bone then continue end

            local vm_bone_matrix = vm:GetBoneMatrix(vm_bone)
            local target_bone_matrix = rhik_model:GetBoneMatrix(target_bone)

            local lerped_pos = LerpVector(rh_delta, vm_bone_matrix:GetTranslation(), target_bone_matrix:GetTranslation())
            local lerped_ang = LerpAngle(rh_delta, vm_bone_matrix:GetAngles(), target_bone_matrix:GetAngles())

            local newtransform = Matrix()
            newtransform:SetTranslation(lerped_pos)
            newtransform:SetAngles(lerped_ang)

            local matrix = Matrix(newtransform)

            vm:SetBoneMatrix(vm_bone, matrix)
        end
    end

    local lhik_model = self.ThirdArmModel

    if IsValid(lhik_model) then
        lhik_model:SetupBones()
        for _, bone in ipairs(ARC9.LHIKBones) do
            local vm_bone = vm:LookupBone(bone)
            local target_bone = lhik_model:LookupBone(bone)

            if !vm_bone or !target_bone then continue end

            local vm_bone_matrix = vm:GetBoneMatrix(vm_bone)
            local target_bone_matrix = lhik_model:GetBoneMatrix(target_bone)

            local lerped_pos = LerpVector(lh_delta, vm_bone_matrix:GetTranslation(), target_bone_matrix:GetTranslation())
            local lerped_ang = LerpAngle(lh_delta, vm_bone_matrix:GetAngles(), target_bone_matrix:GetAngles())

            local newtransform = Matrix()
            newtransform:SetTranslation(lerped_pos)
            newtransform:SetAngles(lerped_ang)

            vm:SetBoneMatrix(vm_bone, newtransform)
        end
    end
end

function SWEP:CamThirdArm()
end

function SWEP:GunControllerThirdArm(pos, ang)
    if (self.ThirdArmAnimationTime + self.ThirdArmAnimationLength) < CurTime() then return pos, ang end

    if IsValid(self.ThirdArmModel) and self.ThirdArmAnimation.gun_controller_attachment != nil then
        local posang = self.ThirdArmModel:GetAttachment(self.ThirdArmAnimation.gun_controller_attachment)
        if !posang then return pos, ang end
        local offset_ang = posang.Ang
        local offset_pos =  posang.Pos

        offset_pos, offset_ang = WorldToLocal(offset_pos, offset_ang, EyePos(), EyeAngles() + (self.ThirdArmAnimation.offsetang or Angle(0, 0, 0)))

        -- offset_pos = offset_pos - self.ThirdArmGunOffsetPos
        -- offset_ang = offset_ang - self.ThirdArmGunOffsetAngle

        offset_pos, offset_ang = WorldToLocal(offset_pos, offset_ang, self.ThirdArmGunOffsetPos, self.ThirdArmGunOffsetAngle - (self.ThirdArmAnimation.offsetang or Angle(0, 0, 0)))

        -- print(offset_pos)

        pos, ang = LocalToWorld(offset_pos, offset_ang, pos, ang)

        return pos, ang
    end

    return pos, ang
end
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/sh_attach.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/sh_bipod.lua:
function SWEP:ThinkBipod()
    local bip = self:GetBipod()
    local owner = self:GetOwner()

    if bip then
        if owner:KeyDown(IN_BACK) or self:MustExitBipod() then
            self:ExitBipod()
        end
    else
        if owner:KeyPressed(IN_ATTACK2) and self:CanBipod() then
            self:EnterBipod()
        end
    end
end

function SWEP:MustExitBipod()
    if !self:GetProcessedValue("Bipod", true) then return true end
    if self:GetSprintAmount() > 0 then return true end
    -- if self:GetBlindFireAmount() > 0 then return true end
    if self:GetUBGL() then return true end

    if self:GetOwner():GetVelocity():LengthSqr() > 100 then return true end

    return false
end

function SWEP:CanBipod(ang)
    if !self:GetProcessedValue("Bipod", true) then return end
    if self:GetSprintAmount() > 0 then return end
    if self:GetReloading() and !self:GetBipod() then return end
    -- if self:GetBlindFireAmount() > 0 then return end
    if self:GetUBGL() then return end
    if self:GetAnimLockTime() > CurTime() then return end

    if self:GetEnterBipodTime() + 1 > CurTime() then return end

    local owner = self:GetOwner()

    if owner:KeyDown(IN_FORWARD) or owner:KeyDown(IN_BACK) or owner:KeyDown(IN_MOVELEFT) or owner:KeyDown(IN_MOVERIGHT) then return end

    local pos = owner:EyePos()
    ang = ang or owner:EyeAngles()

    local maxs = Vector(2, 2, 2)
    local mins = Vector(-2, -2, -48)

    local tr = util.TraceLine({
        start = pos,
        endpos = pos + (ang:Forward() * 64),
        filter = owner,
        mask = MASK_PLAYERSOLID
    })

    if tr.Hit then return end

    -- ang:RotateAroundAxis(ang:Right(), -30)

    local d = (tr.HitPos - pos):Length()
    d = d / 2

    mins.z = -d

    local tr2 = util.TraceHull({
        start = pos,
        endpos = pos + (ang:Forward() * 24),
        filter = owner,
        maxs = maxs,
        mins = mins,
        mask = MASK_PLAYERSOLID
    })

    if tr2.Hit then
        return true
    else
        return false
    end
end

function SWEP:EnterBipod()
    if self:GetBipod() then return end

    self:SetBipod(true)
    local soundtab1 = {
        name = "enterbipod",
        sound = self:RandomChoice(self:GetProcessedValue("EnterBipodSound", true))
    }
    self:PlayTranslatedSound(soundtab1)
    self:PlayAnimation(self.SightIsAlsoBipodAnims and "enter_sights" or "enter_bipod", 1, true)
    self:SetEnterBipodTime(CurTime())

    local owner = self:GetOwner()

    self:SetBipodAng(owner:EyeAngles())
    self:SetBipodPos(owner:EyePos() + (owner:EyeAngles():Forward() * 4) - Vector(0, 0, 2))

    self:ExitSights()
end

function SWEP:ExitBipod(force)
    if !self:GetBipod() then return end

    self:SetBipod(false)
    local soundtab1 = {
        name = "exitbipod",
        sound = self:RandomChoice(self:GetProcessedValue("ExitBipodSound", true))
    }
    self:PlayTranslatedSound(soundtab1)
    self:SetEnterBipodTime(CurTime())

    self:PlayAnimation(self.SightIsAlsoBipodAnims and "exit_sights" or "exit_bipod", 1, true)

    self:CancelReload()

    self:ExitSights()
end

SWEP.BipodTime = 0.5

function SWEP:GetBipodAmount()
    local bipodamount = 0

    if self:GetBipod() then
        local d = math.Clamp(CurTime() - self:GetEnterBipodTime(), 0, self:GetValue("BipodTime"))
        bipodamount = d / self:GetValue("BipodTime")
    end

    return bipodamount
end
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/sh_bodygroups.lua:
local v0 = Vector(0, 0, 0)
local v1 = Vector(1, 1, 1)

function SWEP:DoBodygroups(wm, cm)
    if cm then wm = true end
    local owner = self:GetOwner()

    if !wm and !IsValid(owner) then return end
    if !wm and owner:IsNPC() then return end

    local dbg = self.DefaultBodygroups

    local mdl

    if wm then
        mdl = self:GetWM()
        if cm then
            mdl = self.CModel[1]
        end
    else
        mdl = self:GetVM()
    end

    if !IsValid(mdl) then return end

    mdl:SetSkin(self.DefaultSkin)
    mdl:SetBodyGroups(dbg or "")

    for i = 0, mdl:GetBoneCount() do
        mdl:ManipulateBoneScale(i, v1)
    end

    local eles = self:GetAttachmentElements()

    for _, ele in ipairs(eles) do
        for _, j in pairs(ele.Bodygroups or {}) do
            if !istable(j) then continue end
            if !isnumber(j[1]) then continue end -- print("arc9: something gone horribly wrong in bodygroup code!")
            mdl:SetBodygroup(j[1] or 0, j[2] or 0)
        end

        if ele.Skin then
            mdl:SetSkin(ele.Skin)
        end
    end

    local bbg = self.BulletBodygroups

    if bbg then
        local amt = self:Clip1()

        if self:GetReloading() then
            amt = self:GetLoadedRounds()
        end

        for c, bgs in ipairs(bbg or {}) do
            if !isnumber(c) then continue end
            if amt < c then
                mdl:SetBodygroup(bgs[1], bgs[2])
                break
            end
        end
    end

    local stbg = self.SoundTableBodygroups
    if stbg then
        for i, k in pairs(stbg) do
            mdl:SetBodygroup(i, k)
        end
    end

    if CLIENT then
        for i = 0, mdl:GetNumPoseParameters() - 1 do
            mdl:SetPoseParameter(i, 0)
            local ii = mdl:GetPoseParameterName(i)

            if self.SoundTablePoseParams[ii] then
                mdl:SetPoseParameter(i, self.SoundTablePoseParams[ii])
            end
        end
    end

    local hidebones = self:GetHiddenBones(wm)

    for bone, a in pairs(hidebones or {}) do
        if !a then continue end
        local boneid = isnumber(bone) and bone or mdl:LookupBone(bone)

        if !boneid then continue end

        mdl:ManipulateBoneScale(boneid, v0)
    end

    local bulletbones = self:GetProcessedValue("BulletBones", true)

    if bulletbones then
        for i, bone in ipairs(bulletbones or {}) do
            local bones = bone
            if !istable(bones) then
                bones = {bone}
            end

            local loaded = self:GetLoadedRounds() - (self.BulletBonesSub1 and 1 or 0)
            if self:GetProcessedValue("BottomlessClip", true) then loaded = self:Ammo1() end

            for _, bone2 in ipairs(bones) do
                local boneid = isnumber(bone2) and bone2 or mdl:LookupBone(bone2)

                if !boneid then continue end

                if i > loaded and !clear then
                    mdl:ManipulateBoneScale(boneid, v0)
                end
            end
        end
    end

    local stripperbones = self:GetProcessedValue("StripperClipBones", true)
    if stripperbones then
        for i, bone in ipairs(stripperbones or {}) do
            local bones = bone
            if !istable(bones) then
                bones = {bone}
            end

            for _, bone2 in ipairs(bones) do
                local boneid = isnumber(bone2) and bone2 or mdl:LookupBone(bone2)

                if !boneid then continue end

                if i > self:GetLoadingIntoClip() and !clear then
                    mdl:ManipulateBoneScale(boneid, v0)
                end
            end
        end
    end

    mdl.CustomCamoTexture = self:GetProcessedValue("CustomCamoTexture", true)
    mdl.CustomCamoScale = self:GetProcessedValue("CustomCamoScale", true)
    mdl.CustomBlendFactor = self:GetProcessedValue("CustomBlendFactor", true)

    -- PrintTable(mdl:GetMaterials())

    self:RunHook("Hook_ModifyBodygroups", {model = mdl, elements = self:GetElements()})

    if CLIENT then
        local pptables = self:GetReloadPoseParameterTable(wm)

        for pp, ppv in pairs(pptables or {}) do
            if !pp then continue end

            mdl:SetPoseParameter(pp, ppv)
        end
    end
end

function SWEP:GetReloadPoseParameterTable(wm)
    local hide = true

    local pptables = self:GetProcessedValue("ReloadPoseParameterTables", true)

    local pps = {}

    local index = self:GetPoseParameterIndex()

    if index != 0 then
        for pp, ppv in pairs(pptables[index] or {}) do
            pps[pp] = ppv
        end
    end

    return pps
end

function SWEP:GetHiddenBones(wm)
    local hide = false
    -- optimize this later pls
    
    if self.CustomizeDelta > 0 then
        hide = true
    end

    local hidefp = self:GetProcessedValue("ReloadHideBonesFirstPerson", true)

    if wm or hidefp then
        hide = true
    end

    local hidebones = self:GetProcessedValue("HideBones", true)
    local reloadhidebones = self:GetProcessedValue("ReloadHideBoneTables", true)

    local bones = {}

    if self:GetReloading() then
        hide = false
    end

    local index = self:GetHideBoneIndex()

    if hidefp or (self:GetAnimLockTime() >= CurTime() and reloadhidebones and self:ShouldTPIK() and wm) and index != 0 then
        for _, bone in ipairs(reloadhidebones[index] or {}) do
            bones[bone] = true
        end
    else
        if hidebones and hide then
            for _, bone in ipairs(hidebones) do
                bones[bone] = true
            end
        end
    end

    bones = self:RunHook("Hook_HideBones", bones) or bones

    return bones
end

-- function SWEP:GetElements()
--     return {}
-- end
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/sh_lockon.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/sh_loopingsound.lua:
SWEP.LoopingSound = nil
SWEP.LoopingSoundIndoor = nil

function SWEP:StartLoop()
    if self.LoopingSound then return end
    local s = self:GetProcessedValue("ShootSoundLooping", true)

    if !s then return end

    self.LoopingSound = CreateSound(self, s)
    self.LoopingSound:Play()
    self.LoopingSound:SetSoundLevel(math.Clamp(self:GetProcessedValue("ShootVolume", true), 51, 149))
    self.LoopingSound:ChangePitch(self:GetProcessedValue("ShootPitch", true), 0)
    self.LoopingSound:ChangeVolume(self:GetProcessedValue("ShootVolumeActual", true))
    -- self.LoopingSound = self:StartLoopingSound(s)

    local si = self:GetProcessedValue("ShootSoundLoopingIndoor")

    if !si then return end

    self.LoopingSoundIndoor = CreateSound(self, si)
    self.LoopingSoundIndoor:Play()
    self.LoopingSoundIndoor:SetSoundLevel(math.Clamp(self:GetProcessedValue("ShootVolume", true), 51, 149))
    self.LoopingSoundIndoor:ChangePitch(self:GetProcessedValue("ShootPitch", true), 0)
    self.LoopingSoundIndoor:ChangeVolume(0)
end

function SWEP:EndLoop()
    if !self.LoopingSound then return end

    self.LoopingSound:Stop()
    -- self:StopLoopingSound(self.LoopingSound)
    self.LoopingSound = nil

    if self.LoopingSoundIndoor then
        self.LoopingSoundIndoor:Stop()
    -- self:StopLoopingSound(self.LoopingSound)
        self.LoopingSoundIndoor = nil

        if self:GetIndoor() then
            local soundtab1 = {
                name = "shootlooptailindoor",
                sound = self:GetProcessedValue("ShootSoundTailIndoor", true) or self:GetProcessedValue("ShootSoundWindDownIndoor", true) or "",
            }
            self:PlayTranslatedSound(soundtab1)
        else
            local soundtab1 = {
                name = "shootlooptail",
                sound = self:GetProcessedValue("ShootSoundTail", true) or self:GetProcessedValue("ShootSoundWindDown", true) or "",
            }
            self:PlayTranslatedSound(soundtab1)
        end
    else
        local soundtab1 = {
            name = "shootlooptail",
            sound = self:GetProcessedValue("ShootSoundTail", true) or self:GetProcessedValue("ShootSoundWindDown", true) or "",
        }
        self:PlayTranslatedSound(soundtab1)
    end
end

function SWEP:ThinkLoopingSound()

    if self.LoopingSound then
        if self:GetNextPrimaryFire() + (60 / self:GetProcessedValue("RPM")) <= CurTime() then
            self:EndLoop()
        else
            self.LoopingSound:Play()

            if self.LoopingSoundIndoor then
                self.LoopingSoundIndoor:Play()

                if self:GetIndoor() then
                    self.LoopingSoundIndoor:ChangeVolume(1, 0.1)
                    self.LoopingSound:ChangeVolume(0, 0.1)
                else
                    self.LoopingSoundIndoor:ChangeVolume(0, 0.1)
                    self.LoopingSound:ChangeVolume(1, 0.1)
                end
            end
        end
    end
end

SWEP.IndoorTick = 0
SWEP.IsIndoors = 0

local traces = {
    -- Up
    {
        Distance = Vector(0, 0, 1024),
        Influence = 1,
    },
    {
        Distance = Vector(512, 0, 768),
        Influence = 1,
    },
    {
        Distance = Vector(-512, 0, 768),
        Influence = 1,
    },
    {
        Distance = Vector(0, 512, 768),
        Influence = 1,
    },
    {
        Distance = Vector(0, -512, 768),
        Influence = 1,
    },
    -- Forward
    {
        Distance = Vector(0, 768, 128),
        Influence = 0.5,
    },
    -- Left/Right
    {
        Distance = Vector(768, 768, 256),
        Influence = 0.5,
    },
    {
        Distance = Vector(-768, 768, 256),
        Influence = 0.5,
    },
}


local traceResultTable = {}

local traceTable = {
    start = 0,
    endpos = 0,
    mask = 16513,
    output = traceResultTable
}

function SWEP:GetIndoor()
    if !self.ShootSoundIndoor and !self.DistantShootSoundIndoor and !self.ShootSoundSilencedIndoor and !self.DistantShootSoundSilencedIndoor then return 0 end -- non realism guns!!!

    if self.IndoorTick == UnPredictedCurTime() then return self.IsIndoors end
    self.IndoorTick = UnPredictedCurTime()

    local vol = 0
    local wo = self:GetOwner()
    if !IsValid(wo) then return end
    local wop = wo:EyePos()
    local woa = Angle(0, wo:EyeAngles().y, 0)
    local t_influ = 0

    for _, tin in ipairs(traces) do
        traceTable.start = wop
        offset = Vector()
        offset = offset + (tin.Distance.x * woa:Right())
        offset = offset + (tin.Distance.y * woa:Forward())
        offset = offset + (tin.Distance.z * woa:Up())
        traceTable.endpos = wop + offset
        traceTable.filter = wo
        t_influ = t_influ + (tin.Influence or 1)
        local result = util.TraceLine(traceTable)
        if ARC9.Dev(2) then
            debugoverlay.Line(wop - (vector_up * 4), result.HitPos - (vector_up * 4), 5, Color((_ / 4) * 255, 0, (1 - (_ / 4)) * 255))
            debugoverlay.Text(result.HitPos - (vector_up * 4), math.Round((result.HitSky and 1 or result.Fraction) * 100) .. "%", 5)
        end
        vol = vol + (result.HitSky and 1 or result.Fraction) ^ 1.5 * tin.Influence
    end

    self.IsIndoors = 1 - vol / t_influ
    if ARC9.Dev(2) then
        print(self.IsIndoors)
    end

    return self.IsIndoors
end
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/sh_reload.lua:

function SWEP:SetReloadTimer( time, amount )
    self:SetReloadTime( time )
    self:SetReloadAmount( amount )
end

function SWEP:KillReloadTimer()
    self:SetReloadTime( 0 )
    self:SetReloadAmount( 0 )
end

function SWEP:Reload()
    if self:GetOwner():IsNPC() then
        self:NPC_Reload()
        return
    end

    -- if !self:GetOwner():KeyPressed(IN_RELOAD) then
    --     return
    -- end

    if !self:GetProcessedValue("CanReloadWhileUnCycled", true) and self:GetNeedsCycle() then
        return
    end

    -- if !self:GetProcessedValue("UBGLInsteadOfSights") and self:GetValue("UBGL") then
    --     if self:GetOwner():KeyDown(IN_USE) then
    --         return
    --     end
    -- end

    if self:GetJammed() then
        self:UnJam()
        return
    end

    if self:GetOwner():KeyDown(IN_WALK) then
        return
    end

    if !self:CanReload() then return end

    local clip = self:Clip1()
    local ammo = self:Ammo1()
    local getUBGL = self:GetUBGL()

    if getUBGL then
        clip = self:Clip2()
        ammo = self:Ammo2()
    end

    if !self:GetProcessedValue("BottomlessClip", true) then
        if clip >= self:GetCapacity(getUBGL) then return end

        if !self:GetInfiniteAmmo() and ammo <= 0 then
            return
        end
    else
        return
    end


    -- if CLIENT and !self:ShouldTPIK() then
        -- self:DoPlayerAnimationEvent(self:GetProcessedValue("NonTPIKAnimReload"))
    -- else
        -- self:DoPlayerAnimationEvent(self:GetProcessedValue("AnimReload"))
    -- end

    self:CallOnClient("CallNonTPIKAnim", "AnimReload")

    -- self:ScopeToggle(0)
    -- self:ToggleCustomize(false)

    if clip == 0 then
        self:SetEmptyReload(true)
    else
        self:SetEmptyReload(false)
    end

    local anim = "reload"

    if getUBGL then
        anim = "reload_ubgl"
    end

    if self:GetShouldShotgunReload() then
        anim = "reload_start"

        if getUBGL then
            anim = "reload_ubgl_start"
        end

        local anim2

        for i = 1, self:GetCapacity(getUBGL) - clip do
            anim2 = anim .. "_" .. tostring(i)

            if self:HasAnimation(anim2) then
                anim = anim2
                break
            end
        end
    end

    if !self:GetProcessedValue("ReloadInSights", true) then
        self:ExitSights()
    end

    anim = self:RunHook("Hook_SelectReloadAnimation", anim) or anim

    local t = self:PlayAnimation(anim, self:GetProcessedValue("ReloadTime"), true)

    if !self:GetShouldShotgunReload() then
		local animation = self:GetAnimationEntry(self:TranslateAnimation(anim))

        local minprogress = animation.RefillProgress or animation.MinProgress or 1
        minprogress = math.min(minprogress, 0.95)

        if !self:GetAnimationEntry(self:TranslateAnimation(anim)).RestoreAmmo then
            self:SetReloadTimer( CurTime() + (t * minprogress), self:GetValue(getUBGL and "UBGLClipSize" or "ClipSize") )
        end

        local newcliptime = self:GetAnimationEntry(self:TranslateAnimation(anim)).MagSwapTime or 0.5

        if !getUBGL then
            if !self:GetAnimationEntry(self:TranslateAnimation(anim)).NoMagSwap then
                self:SetTimer(self:GetProcessedValue("ReloadTime") * newcliptime, function()
                    local ammo1 = self:Ammo1()

                    if self:GetInfiniteAmmo() then
                        ammo1 = math.huge
                    end

                    self:SetLoadedRounds(math.min((clip == 0 and self:GetValue("ClipSize") or self:GetCapacity(false)), self:Clip1() + ammo1))
                    self:SetLastLoadedRounds(self:GetLoadedRounds())
                end)
            end
        end
    end

    if !self:PredictionFilter() then
        if self:GetProcessedValue("ShouldDropMag", true) or self:GetProcessedValue("ShouldDropMagEmpty", true) and clip == 0 then
            self:SetTimer(self:GetProcessedValue("DropMagazineTime", true), function()
                self:DropMagazine()
            end)
        end
    end

    if !self.NoForceSetLoadedRoundsOnReload then -- sorry
        self:SetLoadedRounds(self:Clip1())
    end

    self:SetReloading(true)
    self:SetEndReload(false)
    self:SetCycleFinishTime(0)
    -- self:ToggleBlindFire(false)
    self:SetRequestReload(false)
    self:SetRecoilAmount(0)
    self:SetNeedTriggerPress(false) -- Allows you to keep spraying with Auto-Reload
    self:SetBurstCount(0)

    -- self:SetTimer(t * 0.9, function()
    --     if !IsValid(self) then return end

    --     self:SetEndReload(false)
    --     self:EndReload()
    -- end)

    self:SetReloadFinishTime(CurTime() + (t * 0.95))

    self:RunHook("Hook_PostReload")
end

function SWEP:CanReload()
    if self:GetOwner():KeyDown(IN_WALK) then return false end
    if self:StillWaiting() then return end
    if self:GetCapacity(self:GetUBGL()) <= 0 then return end
    -- if self:GetTraversalSprintAmount() >= 0 then return end
    local ammo = self:Ammo1()
    if self:GetUBGL() then
        ammo = self:Ammo2()
    end
    if ammo <= 0 and !self:GetInfiniteAmmo() then return end
    if !self:GetProcessedValue("ReloadWhileSprint", true) and self:GetSprintAmount() > 0 then
        return
    end
    if self:GetJammed() then return end
    if self:GetCustomize() then
        return
    end

    return true
end

function SWEP:Unload()
    if SERVER then
        self:GetOwner():GiveAmmo(self:Clip1(), self.Ammo, true)
    end
    self:SetClip1(0)
    self:SetLoadedRounds(0)
end

function SWEP:CancelReload()
    if !self:GetReloading() then return end

    self:SetReloading(false)
    self:SetReloadFinishTime(0)
    self:SetCycleFinishTime(0)
    self:SetNeedTriggerPress(false) -- Allows you to keep spraying with Auto-Reload
    local vm = self:GetVM()
    vm:SetSequence(0)
    vm:SetCycle(0)
    self:SetAnimLockTime(0)
    self:PlayAnimation("idle")
    self:DoPlayerAnimationEvent(ACT_HL2MP_GESTURE_RELOAD_MAGIC)
    self:CancelSoundTable()
    self:KillReloadTimer()
    self:SetIKTimeLineStart(0)
    self:SetIKTime(0)
    self:SetEmptyReload(false)
end

function SWEP:DropMagazine()
    -- if !IsFirstTimePredicted() and !game.SinglePlayer() then return end

    local mdl = self:GetProcessedValue("DropMagazineModel", true)

    if mdl then
        util.PrecacheModel(mdl) -- garry newman moment

        for i = 1, self:GetProcessedValue("DropMagazineAmount", true) do
            local drop_qca = self:GetQCAMagdrop()

            local data = EffectData()
            data:SetEntity(self)
            data:SetAttachment(drop_qca)

            util.Effect("arc9_magdropeffect", data, true)
            -- local mag = ents.Create("ARC9_droppedmag")

            -- if mag then
            --     mag:SetPos(self:GetOwner():EyePos() - (self:GetOwner():EyeAngles():Up() * 8))
            --     mag:SetAngles(self:GetOwner():EyeAngles())
            --     mag.Model = self:GetProcessedValue("DropMagazineModel")
            --     mag.ImpactSounds = self:GetProcessedValue("DropMagazineSounds")
            --     mag:SetOwner(self:GetOwner())
            --     mag:Spawn()
            --     mag:SetSkin(self:GetProcessedValue("DropMagazineSkin"))

            --     local phys = mag:GetPhysicsObject()

            --     if IsValid(phys) then
            --         phys:AddAngleVelocity(Vector(math.Rand(-300, 300), math.Rand(-300, 300), math.Rand(-300, 300)))
            --     end
            -- end
        end
    end
end

function SWEP:TakeAmmo(amt)
    amt = amt or self:GetProcessedValue("AmmoPerShot")
    if self:GetUBGL() then
        self:TakeSecondaryAmmo(amt)
    else
        if self:GetProcessedValue("BottomlessClip", true) then
            if !self:GetInfiniteAmmo() then
                self:RestoreClip(self:GetValue("ClipSize"))

                if self:Ammo1() > 0 then
                    local ammotype = self:GetValue("Ammo")
                    self:GetOwner():SetAmmo(self:GetOwner():GetAmmoCount(ammotype) - amt, ammotype)
                else
                    self:TakePrimaryAmmo(amt)
                end
            end
        else
            self:TakePrimaryAmmo(amt)
        end
    end
end

function SWEP:GetCapacity(ubgl)
    local cap = 0

    if ubgl then
        cap = math.Round(self:GetValue("UBGLClipSize")) + math.Round(self:GetValue("UBGLChamberSize"))
    else
        cap = math.Round(self:GetValue("ClipSize") or 1) + math.Round(self:GetValue("ChamberSize") or 0)
    end

    return cap
end

function SWEP:RestoreClip(amt)
    if CLIENT then return end

    amt = amt or math.huge

    amt = math.Round(amt)

    local inf = self:GetInfiniteAmmo()
    local clip = self:Clip1()
    local ammo = self:Ammo1()

    if self:GetUBGL() then
        clip = self:Clip2()
        ammo = self:Ammo2()
    end

    -- amt = math.max(amt, -clip)

    -- clip can be -1 here if defaultclip is being set
    local reserve = inf and math.huge or (math.max(0, clip) + ammo)

    local lastclip

    if self:GetUBGL() then
        lastclip = self:Clip2()

        self:SetClip2(math.min(math.min(clip + amt, self:GetCapacity(true)), reserve))

        reserve = reserve - self:Clip2()

        if !inf and IsValid(self:GetOwner()) then
            self:GetOwner():SetAmmo(reserve, self.Secondary.Ammo)
        end

        clip = self:Clip2()
    else
        lastclip = self:Clip1()

        self:SetClip1(math.min(math.min(clip + amt, self:GetCapacity(false)), reserve))

        reserve = reserve - self:Clip1()

        if !inf and IsValid(self:GetOwner()) then
            self:GetOwner():SetAmmo(reserve, self.Primary.Ammo)
        end

        clip = self:Clip1()

        if !self.NoForceSetLoadedRoundsOnReload then -- sorry
            self:SetLoadedRounds(self:Clip1())
            self:SetLastLoadedRounds(self:Clip1())
        end
    end

    return clip - lastclip
end

function SWEP:GetShouldShotgunReload()
    if self:GetProcessedValue("HybridReload") then
        if (self:Clip1() > self:GetProcessedValue("ChamberSize")) and !self:GetEmptyReload() then
            return true
        else
            return false
        end
    end

    return self:GetProcessedValue("ShotgunReload")
end

local arc9_infinite_ammo = GetConVar("arc9_infinite_ammo")

function SWEP:GetInfiniteAmmo()
    return arc9_infinite_ammo:GetBool() or self:GetProcessedValue("InfiniteAmmo", true)
end

function SWEP:EndReload()
    if self:GetShouldShotgunReload() then
        local clip = self:Clip1()
        local ammo = self:Ammo1()
        local getUBGL = self:GetUBGL()

        if getUBGL then
            clip = self:Clip2()
            ammo = self:Ammo2()
        end

        if self:GetInfiniteAmmo() then
            ammo = math.huge
        end

        local capacity

        if getUBGL then
            capacity = self:GetProcessedValue("UBGLClipSize")
        else
            capacity = self:GetProcessedValue("ClipSize")
        end

        if !self.ShotgunReloadNoChamber then
            if getUBGL then
                if !self:GetEmptyReload() or self:GetProcessedValue("ShotgunReloadIncludesChamber", true) then
                    capacity = capacity + self:GetProcessedValue("UBGLChamberSize")
                end
            else
                if !self:GetEmptyReload() or self:GetProcessedValue("ShotgunReloadIncludesChamber", true) then
                    capacity = capacity + self:GetProcessedValue("ChamberSize")
                end
            end
        end

        if clip >= capacity or ammo == 0 or (self:GetEndReload() and clip > 0) then
            -- finish
            local anim = "reload_finish"

            if getUBGL then
                anim = "reload_ubgl_finish"
            end

            local anim2

            for i = 1, self:GetCapacity(getUBGL) - clip do
                anim2 = anim .. "_" .. tostring(i)

                if self:HasAnimation(anim2) then
                    anim = anim2
                    break
                end
            end

            self:PlayAnimation(anim, self:GetProcessedValue("ReloadTime", nil, 1), true)
            self:SetReloading(false)
            self:SetCycleFinishTime(0)

            self:SetNthShot(0)

            if self:GetEmptyReload() or self:GetProcessedValue("PartialReloadCountsTowardsNthReload", true) then
                self:SetNthReload(self:GetNthReload() + 1)
            end

            self:SetNeedTriggerPress(false) -- Allows you to keep spraying with Auto-Reload
            self:SetEmptyReload(false)
        else
            local anim = "reload_insert"
            if getUBGL then
                anim = "reload_ubgl_insert"
            end

            local attempt_to_restore = 1
            local anim2
            local end_clipsize = self:Clip1()

            for i = 1, self:GetCapacity(getUBGL) - clip do
                anim2 = anim .. "_" .. tostring(i)

                if self:HasAnimation(anim2) then
                    anim = anim2
                    attempt_to_restore = i
                    break
                else
                    anim2 = anim .. "_bullet_" .. tostring(i)

                    if self:HasAnimation(anim2) then
                        anim = anim2
                        attempt_to_restore = 1
                        break
                    end
                end
            end

            end_clipsize = end_clipsize + attempt_to_restore

            local minprogress = (self:GetAnimationEntry(anim) or {}).MinProgress or 0.75
            minprogress = math.min(minprogress, 0.99)

            local t = self:PlayAnimation(anim, self:GetProcessedValue("ReloadTime", nil, 1), true, true)

            local magswaptime = (self:GetAnimationEntry(anim) or {}).MagSwapTime or 0

            if !self.NoForceSetLoadedRoundsOnReload then -- sorry
                self:SetTimer(magswaptime * t, function()
                    self:SetLoadedRounds(end_clipsize)
                    self:SetLastLoadedRounds(end_clipsize)
                end)
            end

            self:SetTimer(minprogress * t, function()
                self:RestoreClip(attempt_to_restore)
            end)

            self:SetReloadFinishTime(CurTime() + t)
        end
    else
        self:SetReloading(false)

        self:SetNthShot(self:GetMaxClip1() - self:Clip1() + self:GetProcessedValue("ChamberSize"))

        if self:GetEmptyReload() or self:GetProcessedValue("PartialReloadCountsTowardsNthReload", true) then
            self:SetNthReload(self:GetNthReload() + 1)
        end
        -- self:SetLoadedRounds(self:Clip1())

        self:SetEmptyReload(false)
    end

    self:RunHook("Hook_EndReload")
end

function SWEP:ThinkReload()
    if self:GetReloadTime() != 0 and self:GetReloadTime() <= CurTime() then
        self:RestoreClip( self:GetReloadAmount() )
        self:SetReloadTime( 0 )
        self:SetReloadAmount( 0 )
    end
    if self:GetReloading() and self:GetReloadFinishTime() <= CurTime() then
        self:EndReload()
    end
end

function SWEP:GetLoadingIntoClip()
    local capacity = self:GetCapacity()
    local ammo = self:Ammo1() + self:Clip1()

    if self:GetInfiniteAmmo() then
        ammo = math.huge
    end

    if self:GetProcessedValue("BottomlessClip", true) then
        capacity = ammo
    end

    local newclipsize = math.min(capacity, ammo)

    return newclipsize - self:GetLoadedRounds()
end

function SWEP:GetLoadedClip()
    local clip = self:Clip1()
    local ammo = self:Ammo1()

    if self:GetInfiniteAmmo() then
        ammo = math.huge
    end

    if self:GetUBGL() then
        clip = self:Clip2()

        if self:GetProcessedValue("BottomlessClip", true) then
            clip = self:Ammo2()
        end
    elseif self:GetProcessedValue("BottomlessClip", true) then
        clip = ammo
    end

    return clip
end

function SWEP:HasAmmoInClip()
    if self:GetProcessedValue("BottomlessClip", true) then
        if self:GetUBGL() then
            return self:Clip2() + self:Ammo2() >= self:GetProcessedValue("AmmoPerShot")
        else
            return self:Clip1() + self:Ammo1() >= self:GetProcessedValue("AmmoPerShot")
        end
    else
        if self:GetUBGL() then
            return self:Clip2() >= self:GetProcessedValue("AmmoPerShot")
        else
            return self:Clip1() >= self:GetProcessedValue("AmmoPerShot")
        end
    end
end

function SWEP:DoBulletPose()
    if SERVER then return end
    local pp = self:Clip1()

    local vm = self:GetVM()

    pp = self:RunHook("HookP_ModifyBulletPoseParam", pp) or pp

    vm:SetPoseParameter("bullets", pp)
end

function SWEP:Ammo1()
    if !IsValid(self:GetOwner()) then return math.huge end

    if self:GetInfiniteAmmo() then
        return math.huge
    end

    return self:GetOwner():GetAmmoCount(self:GetProcessedValue("Ammo"))
end

function SWEP:Ammo2()
    if !IsValid(self:GetOwner()) then return math.huge end

    if self:GetInfiniteAmmo() then
        return math.huge
    end

    return self:GetOwner():GetAmmoCount(self:GetProcessedValue("UBGLAmmo"))
end


--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/sh_think.lua:
return gluapack()()
--PATH lua/weapons/arccw_base/cl_holosight.lua:
return gluapack()()
--PATH lua/weapons/arccw_base/cl_holosight.lua:
function SWEP:DoHolosight()

    -- In VRMod, we draw all holosights all the time
    if vrmod and vrmod.IsPlayerInVR(self:GetOwner()) then
        for i, asight in pairs(self.SightTable) do
            local aslot = self.Attachments[asight.Slot] or {}
            local atttbl = asight.HolosightData

            if !atttbl and aslot.Installed then
                atttbl = ArcCW.AttachmentTable[aslot.Installed]

                if !atttbl.Holosight then return end
            end

            if atttbl then
                local hsp = asight.HolosightPiece or self.HSPElement
                local hsm = asight.HolosightModel

                if !hsp and !hsm then
                    self:SetupActiveSights()
                    return
                end

                self:DrawHolosight(atttbl, hsm, hsp, asight)
            end
        end

        return
    end

    local asight = self:GetActiveSights()
    if !asight then return end
    local aslot = self.Attachments[asight.Slot] or {}

    local atttbl = asight.HolosightData

    if !atttbl and aslot.Installed then
        atttbl = ArcCW.AttachmentTable[aslot.Installed]

        if !atttbl.Holosight then return end
    end

    if atttbl then
        local hsp = asight.HolosightPiece or self.HSPElement
        local hsm = asight.HolosightModel

        if !hsp and !hsm then
            self:SetupActiveSights()
            return
        end

        self:DrawHolosight(atttbl, hsm, hsp)
    end
end

function SWEP:ShouldFlatScope()
    return false -- this system was removed, but we need to keep this function
end

local rtsize = ScrH()

local rtmat = GetRenderTarget("arccw_rtmat", rtsize, rtsize, false)
local rtmat_cheap = GetRenderTarget("arccw_rtmat_cheap", ScrW(), ScrH(), false)
local rtmat_spare = GetRenderTarget("arccw_rtmat_spare", ScrW(), ScrH(), false)


local thermal = Material("models/debug/debugwhite")
local colormod = Material("pp/colour")
local coldtime = 30

local additionalFOVconvar = ArcCW.ConVars["vm_add_ads"]

local matRefract = Material("pp/arccw/refract_rt")
local matRefract_cheap = Material("pp/arccw/refract_cs") -- cheap scopes stretches square overlays so i need to make it 16x9

matRefract:SetTexture("$fbtexture", render.GetScreenEffectTexture())
matRefract_cheap:SetTexture("$fbtexture", render.GetScreenEffectTexture())

timer.Create("ihategmod", 5, 0, function() -- i really dont know what the fucking problem with cheap scopes they dont want to set texture as not cheap ones
    matRefract_cheap:SetTexture("$fbtexture", render.GetScreenEffectTexture())
    matRefract:SetTexture("$fbtexture", render.GetScreenEffectTexture()) -- not cheap scope here why not
end)

local pp_ca_base, pp_ca_r, pp_ca_g, pp_ca_b = Material("pp/arccw/ca_base"), Material("pp/arccw/ca_r"), Material("pp/arccw/ca_g"), Material("pp/arccw/ca_b")
local pp_ca_r_thermal, pp_ca_g_thermal, pp_ca_b_thermal = Material("pp/arccw/ca_r_thermal"), Material("pp/arccw/ca_g_thermal"), Material("pp/arccw/ca_b_thermal")

pp_ca_r:SetTexture("$basetexture", render.GetScreenEffectTexture())
pp_ca_g:SetTexture("$basetexture", render.GetScreenEffectTexture())
pp_ca_b:SetTexture("$basetexture", render.GetScreenEffectTexture())

pp_ca_r_thermal:SetTexture("$basetexture", render.GetScreenEffectTexture())
pp_ca_g_thermal:SetTexture("$basetexture", render.GetScreenEffectTexture())
pp_ca_b_thermal:SetTexture("$basetexture", render.GetScreenEffectTexture())

local greenColor = Color(0, 255, 0)  -- optimized +10000fps
local whiteColor = Color(255, 255, 255)
local blackColor = Color(0, 0, 0)

local function DrawTexturedRectRotatedPoint( x, y, w, h, rot, x0, y0 ) -- stolen from gmod wiki
    local c = math.cos( math.rad( rot ) )
    local s = math.sin( math.rad( rot ) )

    local newx = y0 * s - x0 * c
    local newy = y0 * c + x0 * s

    surface.DrawTexturedRectRotated( x + newx, y + newy, w, h, rot )
end


local function IsWHOT(ent)
    if !ent:IsValid() or ent:IsWorld() then return false end

    if ent:IsPlayer() then -- balling
        if ent.ArcticMedShots_ActiveEffects and ent.ArcticMedShots_ActiveEffects["coldblooded"] or ent:Health() <= 0 then return false end -- arc stims
        return true
    end

    if ent:IsNPC() or ent:IsNextBot() then -- npcs
        if ent.ArcCWCLHealth and ent.ArcCWCLHealth <= 0 or ent:Health() <= 0 then return false end
        return true
    end

    if ent:IsRagdoll() then -- ragdolling
        if !ent.ArcCW_ColdTime then ent.ArcCW_ColdTime = CurTime() + coldtime end
        return ent.ArcCW_ColdTime > CurTime()
    end

    if ent:IsVehicle() or ent:IsOnFire() or ent.ArcCW_Hot or ent:IsScripted() and !ent:GetOwner():IsValid() then -- vroom vroom + :fire: + ents but not guns (guns on ground will be fine)
        return true
    end

    return false
end

function SWEP:FormThermalImaging(tex)
    if !tex then
        tex = render.GetRenderTarget()
    end

    render.PushRenderTarget(tex)

    cam.Start3D()

    if tex then
        colormod:SetTexture("$fbtexture", tex)
    else
        colormod:SetTexture("$fbtexture", render.GetScreenEffectTexture())
    end

    local asight = self:GetActiveSights()

    local nvsc = asight.ThermalScopeColor or whiteColor
    local tvsc = asight.ThermalHighlightColor or whiteColor

    local tab = ents.GetAll()

    -- table.Add(tab, player.GetAll())
    -- table.Add(tab, ents.FindByClass("npc_*"))

    render.SetStencilEnable(true)
    render.SetStencilWriteMask(255)
    render.SetStencilTestMask(255)
    render.ClearStencil()

    local sw = ScrH()
    local sh = sw

    local sx = (ScrW() - sw) / 2
    local sy = (ScrH() - sh) / 2

    render.SetScissorRect( sx, sy, sx + sw, sy + sh, true )

    render.SetStencilReferenceValue(64)

    render.SetStencilPassOperation(STENCIL_REPLACE)
    render.SetStencilFailOperation(STENCIL_KEEP)
    render.SetStencilZFailOperation(STENCIL_KEEP)
    render.SetStencilCompareFunction(STENCIL_ALWAYS)

    for _, v in pairs(tab) do

        if !IsWHOT(v) then continue end

        if !asight.ThermalScopeSimple then
            render.SetBlend(0.5)
            render.SuppressEngineLighting(true)

            render.SetColorModulation(250, 250, 250)

            v:DrawModel()
        end
    end

    render.SetColorModulation(1, 1, 1)

    render.SuppressEngineLighting(false)

    render.MaterialOverride()

    render.SetBlend(1)

    render.SetStencilCompareFunction(STENCIL_EQUAL)

    if asight.ThermalScopeSimple then
        surface.SetDrawColor(255, 255, 255, 255)
        surface.DrawRect(0, 0, ScrW(), ScrH())
    end

    DrawColorModify({
        ["$pp_colour_addr"] = 0,
        ["$pp_colour_addg"] = 0,
        ["$pp_colour_addb"] = 0,
        ["$pp_colour_brightness"] = 0,
        ["$pp_colour_contrast"] = 1,
        ["$pp_colour_colour"] = 0,
        ["$pp_colour_mulr"] = 0,
        ["$pp_colour_mulg"] = 0,
        ["$pp_colour_mulb"] = 0
    })

    DrawColorModify({
        ["$pp_colour_addr"] = tvsc.r - 255,
        ["$pp_colour_addg"] = tvsc.g - 255,
        ["$pp_colour_addb"] = tvsc.b - 255,
        ["$pp_colour_addr"] = 0,
        ["$pp_colour_addg"] = 0,
        ["$pp_colour_addb"] = 0,
        ["$pp_colour_brightness"] = 0,
        ["$pp_colour_contrast"] = 1,
        ["$pp_colour_colour"] = 1,
        ["$pp_colour_mulr"] = 0,
        ["$pp_colour_mulg"] = 0,
        ["$pp_colour_mulb"] = 0
    })

    if !asight.ThermalNoCC then
        render.SetStencilCompareFunction(STENCIL_NOTEQUAL)
        render.SetStencilPassOperation(STENCIL_KEEP)

        if !asight.ThermalFullColor then
            DrawColorModify({
                ["$pp_colour_addr"] = 0,
                ["$pp_colour_addg"] = 0,
                ["$pp_colour_addb"] = 0,
                ["$pp_colour_brightness"] = 0,
                ["$pp_colour_contrast"] = 1,
                ["$pp_colour_colour"] = 0,
                ["$pp_colour_mulr"] = 0,
                ["$pp_colour_mulg"] = 0,
                ["$pp_colour_mulb"] = 0
            })
        end

        if ArcCW.ConVars["thermalpp"]:GetBool() and ArcCW.ConVars["scopepp"]:GetBool() then
            -- chromatic abberation

            render.CopyRenderTargetToTexture(render.GetScreenEffectTexture())

            render.SetMaterial( pp_ca_base )
            render.DrawScreenQuad()
            render.SetMaterial( pp_ca_r_thermal )
            render.DrawScreenQuad()
            render.SetMaterial( pp_ca_g_thermal )
            render.DrawScreenQuad()
            render.SetMaterial( pp_ca_b_thermal )
            render.DrawScreenQuad()
            -- pasted here cause otherwise either target colors will get fucked either pp either motion blur
        end

        DrawColorModify({
            ["$pp_colour_addr"] = nvsc.r - 255,
            ["$pp_colour_addg"] = nvsc.g - 255,
            ["$pp_colour_addb"] = nvsc.b - 255,
            -- ["$pp_colour_addr"] = 0,
            -- ["$pp_colour_addg"] = 0,
            -- ["$pp_colour_addb"] = 0,
            ["$pp_colour_brightness"] = asight.Brightness or 0.1,
            ["$pp_colour_contrast"] = asight.Contrast or 0.5,
            ["$pp_colour_colour"] = asight.Colormult or 1,
            ["$pp_colour_mulr"] = 0,
            ["$pp_colour_mulg"] = 0,
            ["$pp_colour_mulb"] = 0
        })
    end

    render.SetScissorRect( sx, sy, sx + sw, sy + sh, false )

    render.SetStencilEnable(false)

    colormod:SetTexture("$fbtexture", render.GetScreenEffectTexture())

    cam.End3D()

    if ArcCW.ConVars["thermalpp"]:GetBool() then
        if !render.SupportsPixelShaders_2_0() then return end

        DrawSharpen(0.3,0.9)
        DrawBloom(0,0.3,5,5,3,0.5,1,1,1)
        -- DrawMotionBlur(0.7,1,1/(asight.FPSLock or 45)) -- upd i changed order and it fucking worked lmao     //////i cant fucking understand why motionblur fucks render target
    end

    render.PopRenderTarget()
end

function SWEP:FormNightVision(tex)
    local asight = self:GetActiveSights()

    local orig = colormod:GetTexture("$fbtexture")

    colormod:SetTexture("$fbtexture", tex)

    render.PushRenderTarget(tex)

    local nvsc = asight.NVScopeColor or greenColor

    if !asight.NVFullColor then
        DrawColorModify({
            ["$pp_colour_addr"] = 0,
            ["$pp_colour_addg"] = 0,
            ["$pp_colour_addb"] = 0,
            ["$pp_colour_brightness"] = 0,
            ["$pp_colour_contrast"] = 1,
            ["$pp_colour_colour"] = 0,
            ["$pp_colour_mulr"] = 0,
            ["$pp_colour_mulg"] = 0,
            ["$pp_colour_mulb"] = 0
        })
    end

    DrawColorModify({
        ["$pp_colour_addr"] = nvsc.r - 255,
        ["$pp_colour_addg"] = nvsc.g - 255,
        ["$pp_colour_addb"] = nvsc.b - 255,
        ["$pp_colour_brightness"] = asight.Brightness or -0.05,
        ["$pp_colour_contrast"] = asight.Contrast or 4,
        ["$pp_colour_colour"] = 1,
        ["$pp_colour_mulr"] = 0,
        ["$pp_colour_mulg"] = 0,
        ["$pp_colour_mulb"] = 0
    })

    render.PopRenderTarget()

    colormod:SetTexture("$fbtexture", orig)
end

local pp_cc_tab = {
    ["$pp_colour_addr"] = 0,
    ["$pp_colour_addg"] = 0,
    ["$pp_colour_addb"] = 0,
    ["$pp_colour_brightness"] = 0, -- why nothing works hh
    ["$pp_colour_contrast"] = 0.9,  -- but same time chroma dont work without calling it
    ["$pp_colour_colour"] = 1,
    ["$pp_colour_mulr"] = 0,
    ["$pp_colour_mulg"] = 0,
    ["$pp_colour_mulb"] = 0
}

function SWEP:FormPP(tex)
    if !render.SupportsPixelShaders_2_0() then return end

    local asight = self:GetActiveSights()

    if asight.Thermal then return end -- eyah

    local cs = ArcCW.ConVars["cheapscopes"]:GetBool()
    local refract = ArcCW.ConVars["scopepp_refract"]:GetBool()
    local pp = ArcCW.ConVars["scopepp"]:GetBool()


    if refract or pp then
        if !cs then render.PushRenderTarget(tex) end
        render.CopyRenderTargetToTexture(render.GetScreenEffectTexture())

        if pp then
            render.SetMaterial( pp_ca_base )
            render.DrawScreenQuad()
            render.SetMaterial( pp_ca_r )
            render.DrawScreenQuad()
            render.SetMaterial( pp_ca_g )
            render.DrawScreenQuad()
            render.SetMaterial( pp_ca_b )
            render.DrawScreenQuad()
                -- Color modify

            DrawColorModify( pp_cc_tab )
                -- Sharpen
            DrawSharpen(-0.1, 5) -- dont work for some reason
        end

        if refract then
            local addads = math.Clamp(additionalFOVconvar:GetFloat(), -2, 14)
            local refractratio = ArcCW.ConVars["scopepp_refract_ratio"]:GetFloat() or 0
            local refractamount = (-0.6 + addads / 30) * refractratio
            local refractmat = cs and matRefract_cheap or matRefract

            refractmat:SetFloat( "$refractamount", refractamount )

            render.SetMaterial(refractmat)
            render.DrawScreenQuad()
        end

        if !cs then render.PopRenderTarget() end
    end
end

function SWEP:FormCheapScope()
    local screen = render.GetRenderTarget()

    render.CopyTexture( screen, rtmat_spare )

    render.PushRenderTarget(screen)
    cam.Start3D(EyePos(), EyeAngles(), nil, nil, nil, nil, nil, 0, nil)
        ArcCW.LaserBehavior = true
        self:DoLaser(false)
        ArcCW.LaserBehavior = false
    cam.End3D()

    self:FormPP(screen)

    render.PopRenderTarget()

    -- so, in order to avoid the fact that copying RTs doesn't transfer depth buffer data, we just take the screen texture and...
    -- redraw it to cover up the thermal scope stuff. Don't think too hard about this. You have plenty of VRAM.

    local asight = self:GetActiveSights()

    if asight.Thermal then
        self:FormThermalImaging(screen)
    end

    if asight.SpecialScopeFunction then
        asight.SpecialScopeFunction(screen)
    end

    -- integrated render delay for better optimization
    if asight.FPSLock then
        asight.fpsdelay = CurTime() + 1 / (asight.FPSLock or 45)
    end

    render.CopyTexture( screen, rtmat_cheap )

    render.DrawTextureToScreen(rtmat_spare)

    render.UpdateFullScreenDepthTexture()
end

function SWEP:FormRTScope()
    local asight = self:GetActiveSights()

    if !asight then return end

    if !asight.MagnifiedOptic then return end

    local mag = asight.ScopeMagnification

    cam.Start3D()

    ArcCW.Overdraw = true
    ArcCW.LaserBehavior = true
    ArcCW.VMInRT = true

    local rtangles, rtpos, rtdrawvm

    if self:GetState() == ArcCW.STATE_SIGHTS then
        if ArcCW.ConVars["drawbarrel"]:GetBool() and ArcCW.ConVars["vm_coolsway"]:GetBool() and asight.Slot and asight.Slot == 1 then -- slot check to ignore integrated
            rtangles = self.VMAng - self.VMAngOffset - (self:GetOurViewPunchAngles() * mag * 0.1)
            rtangles.x = rtangles.x - self.VMPosOffset_Lerp.z * 10
            rtangles.y = rtangles.y + self.VMPosOffset_Lerp.y * 10

            rtpos = self.VMPos + self.VMAng:Forward() * (asight.EVPos.y + 7 + (asight.ScopeMagnificationMax and asight.ScopeMagnificationMax / 3 or asight.HolosightData.HolosightMagnification / 3)) -- eh
            rtdrawvm = true
        else
            rtangles = EyeAngles()
            rtpos = EyePos()
            rtdrawvm = false

            -- HACK HACK HACK HACK HACK
            -- If we do not draw the viewmodel in RT scope, calling GetAttachment on the vm seems to break LHIK.
            -- So... just draw it! The results gets drawn over again so it doesn't affect the outcome
            render.RenderView({drawviewmodel = true}) -- ?????
        end
    end

    local addads = math.Clamp(additionalFOVconvar:GetFloat(), -2, 14)

    local rt = {
        w = rtsize,
        h = rtsize,
        angles = rtangles,
        origin = rtpos,
        drawviewmodel = rtdrawvm,
        fov = self:GetOwner():GetFOV() / mag / 1.2 - (addads or 0) / 4,
    }

    rtsize = ScrH()

    if ScrH() > ScrW() then rtsize = ScrW() end

    local rtres = asight.ForceLowRes and ScrH() * 0.6 or ScrH() -- we can emit low res lcd displays for scopes

    rtmat = GetRenderTarget("arccw_rtmat" .. rtres, rtres, rtres, false)

    render.PushRenderTarget(rtmat, 0, 0, rtsize, rtsize)

    render.ClearRenderTarget(rt, blackColor)

    if self:GetState() == ArcCW.STATE_SIGHTS then
        render.RenderView(rt)
        cam.Start3D(EyePos(), EyeAngles(), rt.fov, 0, 0, nil, nil, 0, nil)
            self:DoLaser(false)
        cam.End3D()
    end

    ArcCW.Overdraw = false
    ArcCW.LaserBehavior = false
    ArcCW.VMInRT = false

    self:FormPP(rtmat)

    render.PopRenderTarget()

    cam.End3D()

    if asight.Thermal then
        self:FormThermalImaging(rtmat)
    end

    if asight.SpecialScopeFunction then
        asight.SpecialScopeFunction(rtmat)
    end

    -- integrated render delay for better optimization
    if asight.FPSLock then
        asight.fpsdelay = CurTime() + 1 / (asight.FPSLock or 45)
    end

end

-- local fpsdelay = CurTime()

hook.Add("RenderScene", "ArcCW", function()
    if ArcCW.ConVars["cheapscopes"]:GetBool() then return end

    local wpn = LocalPlayer():GetActiveWeapon()

    if !wpn.ArcCW then return end
    if wpn:GetActiveSights() and wpn:GetActiveSights().FPSLock
            and (wpn:GetActiveSights().fpsdelay or 0) > CurTime() then
        return
    end
    wpn:FormRTScope()
end)

local black = Material("arccw/hud/black.png")
local defaultdot = Material("arccw/hud/hit_dot.png")

function SWEP:DrawHolosight(hs, hsm, hsp, asight)
    -- holosight structure
    -- holosight model

    local ref = 32

    asight = asight or self:GetActiveSights()
    local delta = self:GetSightDelta()

    if asight.HolosightData then
        hs = asight.HolosightData
    end

    if self:GetState() != ArcCW.STATE_SIGHTS and delta > 0.5 or self:GetBarrelNearWall() > 0 then return end

    if !hs then return end

    if delta != 0 and ArcCW.ConVars["scopepp"]:GetBool() then
        pp_ca_r:SetVector("$color2", Vector(1-delta, 0, 0))
        pp_ca_g:SetVector("$color2", Vector(0, 1-delta, 0))
        pp_ca_b:SetVector("$color2", Vector(0, 0, 1-delta))
        pp_ca_base:SetFloat("$alpha", 1-delta)
    end

    local hsc = Color(255, 255, 255) -- putting here global or white local SOMEHOW FUCKS IT EVEN GLOBAL BEING FUCKED WTF I HATE

    if hs.Colorable then
        hsc.r = ArcCW.ConVars["scope_r"]:GetInt()
        hsc.g = ArcCW.ConVars["scope_g"]:GetInt()
        hsc.b = ArcCW.ConVars["scope_b"]:GetInt()
    else
        hsc = hs.HolosightColor or hsc
    end

    local attid = 0

    if hsm then

        attid = hsm:LookupAttachment(asight.HolosightBone or hs.HolosightBone or "holosight")

        if attid == 0 then
            attid = hsm:LookupAttachment("holosight")
        end

    end

    local ret, pos, ang

    if attid != 0 then

        ret = hsm:GetAttachment(attid)
        pos = ret.Pos
        ang = ret.Ang

    else

        pos = EyePos()
        ang = EyeAngles()

    end

    local hsmag = asight.ScopeMagnification or 1

    local size = hs.HolosightSize or 1

    local addads = math.Clamp(additionalFOVconvar:GetFloat(), -2, 14)

    local addconvar = asight.MagnifiedOptic and (addads or 0) or 0

    size = size + addconvar + (addconvar > 5.5 and (addconvar-5.5) * 2 or 0)


    -- if asight.NightVision then

    if hsmag and hsmag > 1 and delta < 1 and asight.NVScope then
        local screen = rtmat

        if ArcCW.ConVars["cheapscopes"]:GetBool() then
            screen = rtmat_cheap
        end

        if asight.NVScope then
            self:FormNightVision(screen)
        end
    end

    render.UpdateScreenEffectTexture()
    render.ClearStencil()
    render.SetStencilEnable(true)
    render.SetStencilCompareFunction(STENCIL_ALWAYS)
    render.SetStencilPassOperation(STENCIL_REPLACE)
    render.SetStencilFailOperation(STENCIL_KEEP)
    render.SetStencilZFailOperation(STENCIL_REPLACE)
    render.SetStencilWriteMask(255)
    render.SetStencilTestMask(255)

    render.SetBlend(0)

        render.SetStencilReferenceValue(ref)

        ArcCW.Overdraw = true

        render.OverrideDepthEnable( true, true )

        if !hsm then
            hsp:DrawModel()
        else

            hsm:SetBodygroup(1, 0)

            if !hsp or hs.HolosightNoHSP then
                hsm:DrawModel()
            end

            -- render.MaterialOverride()

            render.SetStencilReferenceValue(0)

            hsm:SetBodygroup(1, 1)
            -- hsm:SetSubMaterial(0, "dev/no_pixel_write")
            hsm:DrawModel()
            -- hsm:SetSubMaterial()
            hsm:SetBodygroup(1, 0)

            -- local vm = self:GetOwner():GetViewModel()

            -- ArcCW.Overdraw = true
            -- vm:DrawModel()

            -- ArcCW.Overdraw = false

            render.SetStencilReferenceValue(ref)

            if hsp then
                hsp:DrawModel()
            end
        end

        -- render.MaterialOverride()

        render.OverrideDepthEnable( false, true )

        ArcCW.Overdraw = false

    render.SetBlend(1)

    render.SetStencilPassOperation(STENCIL_REPLACE)
    render.SetStencilCompareFunction(STENCIL_EQUAL)

    -- local pos = EyePos()
    -- local ang = EyeAngles()

    ang:RotateAroundAxis(ang:Forward(), -90)

    local dir = ang:Up()

    local pdiff = (pos - EyePos()):Length()

    pos = LerpVector(delta, EyePos(), pos)

    local eyeangs = self:GetOwner():EyeAngles() - self:GetOurViewPunchAngles() * hsmag * 0.1

    -- local vm = hsm or hsp

    -- eyeangs = eyeangs + (eyeangs - vm:GetAngles())

    dir = LerpVector(delta, eyeangs:Forward(), dir:GetNormalized())

    pdiff = Lerp(delta, pdiff, 0)

    local d = (8 + pdiff)

    d = hs.HolosightConstDist or d

    local vmscale = (self.Attachments[asight.Slot] or {}).VMScale or Vector(1, 1, 1)

    if hs.HolosightConstDist then
        vmscale = Vector(1, 1, 1)
    end

    local hsx = vmscale[2] or 1
    local hsy = vmscale[3] or 1

    pos = pos + (dir * d)

    local pos2 = pos + (dir * -8)

    local a = self:GetOwner():InVehicle() and {x = ScrW() / 2, y = ScrH() / 2} or pos:ToScreen()
    local x = a.x - (self.VMAngOffset.y - self.VMPosOffset_Lerp.y * 10) * (hsmag * 1.5) ^ 2
    local y = a.y + (self.VMAngOffset.x * 5 + self.VMPosOffset_Lerp.z * 10) * (hsmag * 1.5) ^ 2

    local a2 = self:GetOwner():InVehicle() and {x = ScrW() / 2, y = ScrH() / 2} or pos2:ToScreen()

    local off_x = a2.x - (ScrW() / 2)
    local off_y = a2.y - (ScrH() / 2)

    --pos = pos + Vector(ArcCW.StrafeTilt(self), 0, 0)

    -- local corner1, corner2, corner3, corner4

    -- corner2 = pos + (ang:Right() * (-0.5 * size)) + (ang:Forward() * (0.5 * size))
    -- corner1 = pos + (ang:Right() * (-0.5 * size)) + (ang:Forward() * (-0.5 * size))
    -- corner4 = pos + (ang:Right() * (0.5 * size)) + (ang:Forward() * (-0.5 * size))
    -- corner3 = pos + (ang:Right() * (0.5 * size)) + (ang:Forward() * (0.5 * size))

    -- render.SetColorMaterialIgnoreZ()
    -- render.DrawScreenQuad()

    -- render.SetStencilEnable( false )
    -- local fovmag = asight.Magnification or 1

    if hsmag and hsmag > 1 and delta < 1 then
        local screen = rtmat

        -- local sw2 = ScrH()
        -- local sh2 = sw2

        -- local sx2 = (ScrW() - sw2) / 2
        -- local sy2 = (ScrH() - sh2) / 2

        -- render.SetScissorRect( sx2, sy2, sx2 + sw2, sy2 + sh2, true )

        if render.GetHDREnabled() and delta < 0.07 then
            render.SetToneMappingScaleLinear(Vector(1,1,1)) -- hdr fix
        end

        if ArcCW.ConVars["cheapscopes"]:GetBool() then

            screen = rtmat_cheap

            local addads = math.Clamp(additionalFOVconvar:GetFloat(), -2, 14)
            local csratio = math.Clamp(GetConVar("arccw_cheapscopesv2_ratio"):GetFloat(), 0, 1)

            local ssmag = 1 + csratio * hsmag + (addads or 0) / 20 -- idk why 20
            local sw = ScrW() * ssmag
            local sh = ScrH() * ssmag

            -- local sx = -(sw - ScrW()) / 2
            -- local sy = -(sh - ScrH()) / 2

            local cpos = self:GetOwner():EyePos() + ((EyeAngles() + (self:GetOurViewPunchAngles() * 0.5)):Forward() * 2048)

            --cpos:Rotate(Angle(0, -ArcCW.StrafeTilt(self), 0))

            local ts = self:GetOwner():InVehicle() and {x = ScrW() / 2, y = ScrH() / 2} or cpos:ToScreen()

            local sx = ts.x - (sw / 2) - off_x - (self.VMAngOffset.y - self.VMPosOffset_Lerp.y * 15) * (hsmag * 1) ^ 2
            local sy = ts.y - (sh / 2) - off_y + (self.VMAngOffset.x * 5 + self.VMPosOffset_Lerp.z * 15) * (hsmag * 1) ^ 2

            render.SetMaterial(black)
            render.DrawScreenQuad()

            render.DrawTextureToScreenRect(screen, sx, sy, sw, sh)

        else

            local sw = ScrH()
            local sh = sw

            local sx = ((ScrW() - sw) / 2) - off_x
            local sy = ((ScrH() - sh) / 2) - off_x

            render.SetMaterial(black)
            render.DrawScreenQuad()

            render.DrawTextureToScreenRect(screen, sx, sy, sw, sh)

        end
    end

    -- cam.Start3D()

    -- render.SetColorMaterialIgnoreZ()
    -- render.DrawScreenQuad()

    -- render.DrawQuad( corner1, corner2, corner3, corner4, hsc or hs.HolosightColor )
    cam.IgnoreZ( true )

    render.SetStencilReferenceValue(ref)

    -- render.SetMaterial(hs.HolosightReticle or defaultdot)
    -- render.DrawSprite( pos, size * hsx, size * hsy, hsc or Color(255, 255, 255) )
    -- if !hs.HolosightNoFlare then
    --     render.SetMaterial(hs.HolosightFlare or hs.HolosightReticle or defaultdot)
    --     local hss = 0.75
    --     if hs.HolosightFlare then
    --         hss = 1
    --     end
    --     render.DrawSprite( pos, size * hss * hsx, size * hss * hsy, Color(255, 255, 255, 255) )
    -- end

    cam.Start2D()

    if hs.HolosightBlackbox then
        render.SetStencilPassOperation(STENCIL_KEEP)

        surface.SetDrawColor(0, 0, 0, 255 * delta)
        surface.DrawRect(0, 0, ScrW(), ScrH())
    end

    render.SetStencilPassOperation(STENCIL_DECR)
    render.SetStencilCompareFunction(STENCIL_EQUAL)

    local hss = size * 32 * math.min(ScrW(), ScrH()) / 800

    --local thej = self.TheJ.anga + LocalPlayer():GetViewPunchAngles() + self:GetOurViewPunchAngles()
                    -- AYE, UR ACTIVE ANG BEIN TWISTED DUNT GIVE AUH SHET

    surface.SetMaterial(hs.HolosightReticle or defaultdot)
    surface.SetDrawColor(hsc or 255, 255, 255)
    -- surface.DrawTexturedRect(x - (hss / 2), y - (hss / 2), hss, hss)

    DrawTexturedRectRotatedPoint(x, y, hss, hss, -(self.VMAngOffset.r+self.VMAngOffset_Lerp.r+self:GetOurViewPunchAngles().r)*5 , 0, 0)

    if !hs.HolosightNoFlare then
        render.SetStencilPassOperation(STENCIL_KEEP)
        render.SetStencilReferenceValue(ref - 1)
        surface.SetMaterial(hs.HolosightFlare or hs.HolosightReticle or defaultdot)
        surface.SetDrawColor(255, 255, 255, 150)

        local hss2 = hss

        if !hs.HolosightFlare then
            hss2 = hss - 2
        end

        surface.DrawTexturedRect(x - (hss2 / 2), y - (hss2 / 2), hss2, hss2)
        --surface.DrawTexturedRectRotated(x, y, hss2, hss2, -thej.r or 0)

        render.SetStencilReferenceValue(ref)
    end

    if hs.HolosightBlackbox then
        -- render.SetColorMaterialIgnoreZ()
        -- render.DrawScreenQuad()

        surface.SetDrawColor(0, 0, 0)
        surface.DrawRect(0, 0, ScrW(), ScrH())
        -- surface.DrawRect(0, (ScrH() - hss) / 2, ScrW(), (ScrH() - hss) / 2)
    end

    cam.End2D()

    render.SetStencilEnable( false )

    cam.IgnoreZ( false )

    -- cam.End3D()

    if hsp then

        cam.IgnoreZ(true)

        if ArcCW.ConVars["glare"]:GetBool() then
            render.SetBlend(delta + 0.1)
        else
            render.SetBlend(delta)
        end
        hsp:DrawModel()
        render.SetBlend(1)

        cam.IgnoreZ( false )

    end
end


--           I wanted to make here procedural normal map for refract using rt but steamsnooze


-- local TEX_SIZE = 512

-- local tex = GetRenderTarget( "ExampleRT", TEX_SIZE, TEX_SIZE )

-- local txBackground = surface.GetTextureID( "pp/arccw/lense_nrm2" )
-- local myMat = CreateMaterial( "ExampleRTMat3", "UnlitGeneric", {
-- 	["$basetexture"] = tex:GetName() -- Make the material use our render target texture
-- } )

-- hook.Add( "HUDPaint", "DrawExampleMat", function()
    -- render.PushRenderTarget( tex )
    -- cam.Start2D()

    --     surface.SetDrawColor( 128,128,255 )
    --     surface.DrawRect(0,0,TEX_SIZE, TEX_SIZE)
    --     surface.SetDrawColor( color_white )
    --     surface.SetTexture( txBackground )
        -- local joke = math.sin(CurTime()*5)/4

    --     surface.DrawTexturedRect( TEX_SIZE/4-joke/2, TEX_SIZE/4-joke/2, TEX_SIZE/2+joke, TEX_SIZE/2+joke )

    -- cam.End2D()
    -- render.PopRenderTarget()
    -- surface.SetDrawColor( color_white )
    -- surface.SetMaterial( myMat )
    -- surface.DrawTexturedRect( 25, 25, TEX_SIZE, TEX_SIZE )
    -- print()
    -- DrawTexturedRectRotatedPoint(250+250/2,250+250/2,250,250,(CurTime()%360)*50,0,0)
    -- surface.DrawRect(250,250,250,250)

-- end )

--PATH lua/weapons/arccw_base/cl_lhik.lua:
return gluapack()()
--PATH lua/weapons/arccw_base/cl_lhik.lua:
local function qerp(delta, a, b)
    local qdelta = -(delta ^ 2) + (delta * 2)

    qdelta = math.Clamp(qdelta, 0, 1)

    return Lerp(qdelta, a, b)
end

SWEP.LHIKAnimation_IsIdle = false
SWEP.LHIKAnimation = nil
SWEP.LHIKAnimationStart = 0
SWEP.LHIKAnimationTime = 0

SWEP.LHIKCamAng = Angle(0, 0, 0)
SWEP.LHIKGunAng = Angle(0, 0, 0)

function SWEP:DoLHIKAnimation(key, time, spbitch)
    if !IsValid(self:GetOwner()) then return end

    if game.SinglePlayer() and !spbitch then
        timer.Simple(0, function() if IsValid(self) then self:DoLHIKAnimation(key, time, true) end end)
        return
    end

    local vm = self:GetOwner():GetViewModel()
    if !IsValid(vm) then return end

    local lhik_model
    local lhik_anim_model
    local LHIK_GunDriver
    local LHIK_CamDriver
    local offsetang

    local tranim = self:GetBuff_Hook("Hook_LHIK_TranslateAnimation", key)

    key = tranim or key

    for i, k in pairs(self.Attachments) do
        if !k.Installed then continue end
        if !k.VElement then continue end

        if self:GetBuff_Stat("LHIK", i) then
            lhik_model = k.VElement.Model
            lhik_anim_model = k.GodDriver and k.GodDriver.Model or false
            offsetang = k.VElement.OffsetAng

            if self:GetBuff_Stat("LHIK_GunDriver", i) then
                LHIK_GunDriver = self:GetBuff_Stat("LHIK_GunDriver", i)
            end

            if self:GetBuff_Stat("LHIK_CamDriver", i) then
                LHIK_CamDriver = self:GetBuff_Stat("LHIK_CamDriver", i)
            end
        end
    end

    if !IsValid(lhik_model) then return false end

    local seq = lhik_model:LookupSequence(key)

    if !seq then return false end
    if seq == -1 then return false end

    lhik_model:ResetSequence(seq)
    if IsValid(lhik_anim_model) then
        lhik_anim_model:ResetSequence(seq)
    end

    if !time or time < 0 then time = lhik_model:SequenceDuration(seq) end

    self.LHIKAnimation = seq
    self.LHIKAnimationStart = UnPredictedCurTime()
    self.LHIKAnimationTime = time

    self.LHIKAnimation_IsIdle = false

    if IsValid(lhik_anim_model) and LHIK_GunDriver then
        local att = lhik_anim_model:LookupAttachment(LHIK_GunDriver)
        local ang = lhik_anim_model:GetAttachment(att).Ang
        local pos = lhik_anim_model:GetAttachment(att).Pos

        self.LHIKGunAng = lhik_anim_model:WorldToLocalAngles(ang) - Angle(0, 90, 90)
        self.LHIKGunPos = lhik_anim_model:WorldToLocal(pos)

        self.LHIKGunAngVM = vm:WorldToLocalAngles(ang) - Angle(0, 90, 90)
        self.LHIKGunPosVM = vm:WorldToLocal(pos)
    end

    if IsValid(lhik_anim_model) and LHIK_CamDriver then
        local att = lhik_anim_model:LookupAttachment(LHIK_CamDriver)
        local ang = lhik_anim_model:GetAttachment(att).Ang

        self.LHIKCamOffsetAng = offsetang
        self.LHIKCamAng = lhik_anim_model:WorldToLocalAngles(ang)
    end

    -- lhik_model:SetCycle(0)
    -- lhik_model:SetPlaybackRate(dur / time)

    return true
end

SWEP.LHIKDelta = {}
SWEP.LHIKDeltaAng = {}
SWEP.ViewModel_Hit = Vector(0, 0, 0)
SWEP.Customize_Hide = 0

function SWEP:GetLHIKAnim()
    local cyc = (UnPredictedCurTime() - self.LHIKAnimationStart) / self.LHIKAnimationTime

    if cyc > 1 then return nil end
    if self.LHIKAnimation_IsIdle then return nil end

    return self.LHIKAnimation
end

function SWEP:DoLHIK()
    if !IsValid(self:GetOwner()) then return end

    local justhide = false
    local lhik_model = nil
    local lhik_anim_model = nil
    local hide_component = false
    local delta = 1

    local vm = self:GetOwner():GetViewModel()

    if !ArcCW.ConVars["reloadincust"]:GetBool() and !self.NoHideLeftHandInCustomization and !self:GetBuff_Override("Override_NoHideLeftHandInCustomization") then
        if self:GetState() == ArcCW.STATE_CUSTOMIZE then
            self.Customize_Hide = math.Approach(self.Customize_Hide, 1, FrameTime() / 0.25)
        else
            self.Customize_Hide = math.Approach(self.Customize_Hide, 0, FrameTime() / 0.25)
        end
    end

    for i, k in pairs(self.Attachments) do
        if !k.Installed then continue end
        -- local atttbl = ArcCW.AttachmentTable[k.Installed]

        -- if atttbl.LHIKHide then
        if self:GetBuff_Stat("LHIKHide", i) then
            justhide = true
        end

        if !k.VElement then continue end

        -- if atttbl.LHIK then
        if self:GetBuff_Stat("LHIK", i) then
            lhik_model = k.VElement.Model
            if k.GodDriver then
                lhik_anim_model = k.GodDriver.Model
            end
        end
    end

    if self.LHIKTimeline then
        local tl = self.LHIKTimeline

        local stage, next_stage, next_stage_index

        for i, k in pairs(tl) do
            if !k or !k.t then continue end
            if k.t + self.LHIKStartTime > UnPredictedCurTime() then
                next_stage_index = i
                break
            end
        end

        if next_stage_index then
            if next_stage_index == 1 then
                -- we are on the first stage.
                stage = {t = 0, lhik = 0}
                next_stage = self.LHIKTimeline[next_stage_index]
            else
                stage = self.LHIKTimeline[next_stage_index - 1]
                next_stage = self.LHIKTimeline[next_stage_index]
            end
        else
            stage = self.LHIKTimeline[#self.LHIKTimeline]
            next_stage = {t = self.LHIKEndTime, lhik = self.LHIKTimeline[#self.LHIKTimeline].lhik}
        end

        local local_time = UnPredictedCurTime() - self.LHIKStartTime

        local delta_time = next_stage.t - stage.t
        delta_time = (local_time - stage.t) / delta_time

        delta = qerp(delta_time, stage.lhik, next_stage.lhik)

        if lhik_model and IsValid(lhik_model) then
            local key

            if stage.lhik > next_stage.lhik then
                key = "in"
            elseif next_stage.lhik > stage.lhik then
                key = "out"
            end

            if key then
                local tranim = self:GetBuff_Hook("Hook_LHIK_TranslateAnimation", key)

                key = tranim or key

                local seq = lhik_model:LookupSequence(key)

                if seq and seq > 0 then
                    lhik_model:SetSequence(seq)
                    lhik_model:SetCycle(delta)
                    if lhik_anim_model then
                        lhik_anim_model:SetSequence(seq)
                        lhik_anim_model:SetCycle(delta)
                    end
                end
            end
        end

        -- if tl[4] <= UnPredictedCurTime() then
        --     -- it's over
        --     delta = 1
        -- elseif tl[3] <= UnPredictedCurTime() then
        --     -- transition back to 1
        --     delta = (UnPredictedCurTime() - tl[3]) / (tl[4] - tl[3])
        --     delta = qerp(delta, 0, 1)

        --     if lhik_model and IsValid(lhik_model) then
        --         local key = "out"

        --         local tranim = self:GetBuff_Hook("Hook_LHIK_TranslateAnimation", key)

        --         key = tranim or key

        --         local seq = lhik_model:LookupSequence(key)

        --         if seq and seq > 0 then
        --             lhik_model:SetSequence(seq)
        --             lhik_model:SetCycle(delta)
        --         end
        --     end
        -- elseif tl[2] <= UnPredictedCurTime() then
        --     -- hold 0
        --     delta = 0
        -- elseif tl[1] <= UnPredictedCurTime() then
        --     -- transition to 0
        --     delta = (UnPredictedCurTime() - tl[1]) / (tl[2] - tl[1])
        --     delta = qerp(delta, 1, 0)

        --     if lhik_model and IsValid(lhik_model) then
        --         local key = "in"

        --         local tranim = self:GetBuff_Hook("Hook_LHIK_TranslateAnimation", key)

        --         key = tranim or key

        --         local seq = lhik_model:LookupSequence(key)

        --         if seq and seq > 0 then
        --             lhik_model:SetSequence(seq)
        --             lhik_model:SetCycle(delta)
        --         end
        --     end
    else
        -- hasn't started yet
        delta = 1
    end

    if delta == 1 and self.Customize_Hide > 0 then
        if !lhik_model or !IsValid(lhik_model) then
            justhide = true
            delta = math.min(self.Customize_Hide, delta)
        else
            hide_component = true
        end
    end

    if justhide then
        for _, bone in pairs(ArcCW.LHIKBones) do
            local vmbone = vm:LookupBone(bone)

            if !vmbone then continue end -- Happens when spectating someone prolly

            local vmtransform = vm:GetBoneMatrix(vmbone)

            if !vmtransform then continue end -- something very bad has happened

            local vm_pos = vmtransform:GetTranslation()
            local vm_ang = vmtransform:GetAngles()

            local newtransform = Matrix()

            newtransform:SetTranslation(LerpVector(delta, vm_pos, vm_pos - (EyeAngles():Up() * 12) - (EyeAngles():Forward() * 12) - (EyeAngles():Right() * 4)))
            newtransform:SetAngles(vm_ang)

            vm:SetBoneMatrix(vmbone, newtransform)
        end
    end

    if !lhik_model or !IsValid(lhik_model) then return end

    lhik_model:SetupBones()

    if justhide then return end

    local cyc = (UnPredictedCurTime() - self.LHIKAnimationStart) / self.LHIKAnimationTime

    if self.LHIKAnimation and cyc < 1 then
        lhik_model:SetSequence(self.LHIKAnimation)
        lhik_model:SetCycle(cyc)
        if IsValid(lhik_anim_model) then
            lhik_anim_model:SetSequence(self.LHIKAnimation)
            lhik_anim_model:SetCycle(cyc)
        end
    else
        local key = "idle"

        local tranim = self:GetBuff_Hook("Hook_LHIK_TranslateAnimation", key)

        key = tranim or key

        if key and key != "DoNotPlayIdle" then
            self:DoLHIKAnimation(key, -1)
        end

        self.LHIKAnimation_IsIdle = true
    end

    local cf_deltapos = Vector(0, 0, 0)
    local cf = 0


    for _, bone in pairs(ArcCW.LHIKBones) do
        local vmbone = vm:LookupBone(bone)
        local lhikbone = lhik_model:LookupBone(bone)

        if !vmbone then continue end
        if !lhikbone then continue end

        local vmtransform = vm:GetBoneMatrix(vmbone)
        local lhiktransform = lhik_model:GetBoneMatrix(lhikbone)

        if !vmtransform then continue end
        if !lhiktransform then continue end

        local vm_pos = vmtransform:GetTranslation()
        local vm_ang = vmtransform:GetAngles()
        local lhik_pos = lhiktransform:GetTranslation()
        local lhik_ang = lhiktransform:GetAngles()

        local newtransform = Matrix()

        newtransform:SetTranslation(LerpVector(delta, vm_pos, lhik_pos))
        newtransform:SetAngles(LerpAngle(delta, vm_ang, lhik_ang))

        if !self:GetBuff_Override("LHIK_GunDriver") and self.LHIKDelta[lhikbone] and self.LHIKAnimation and cyc < 1 then
            local deltapos = lhik_model:WorldToLocal(lhik_pos) - self.LHIKDelta[lhikbone]

            if !deltapos:IsZero() then
                cf_deltapos = cf_deltapos + deltapos
                cf = cf + 1
            end
        end

        self.LHIKDelta[lhikbone] = lhik_model:WorldToLocal(lhik_pos)

        if hide_component then
            local new_pos = newtransform:GetTranslation()
            newtransform:SetTranslation(LerpVector(self.Customize_Hide, new_pos, new_pos - (EyeAngles():Up() * 12) - (EyeAngles():Forward() * 12) - (EyeAngles():Right() * 4)))
        end

        local matrix = Matrix(newtransform)

        vm:SetBoneMatrix(vmbone, matrix)

        -- local vm_pos, vm_ang = vm:GetBonePosition(vmbone)
        -- local lhik_pos, lhik_ang = lhik_model:GetBonePosition(lhikbone)

        -- local pos = LerpVector(delta, vm_pos, lhik_pos)
        -- local ang = LerpAngle(delta, vm_ang, lhik_ang)

        -- vm:SetBonePosition(vmbone, pos, ang)
    end

    if !cf_deltapos:IsZero() and cf > 0 and self:GetBuff_Override("LHIK_Animation") then
        local new = Vector(0, 0, 0)
        local viewmult = self:GetBuff_Override("LHIK_MovementMult") or 1

        new[1] = cf_deltapos[2] * viewmult
        new[2] = cf_deltapos[1] * viewmult
        new[3] = cf_deltapos[3] * viewmult

        self.ViewModel_Hit = LerpVector(0.25, self.ViewModel_Hit, new / cf):GetNormalized()
    end
end
--PATH lua/weapons/arccw_base/sh_bipod.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arccw_base/sh_custom.lua:

function SWEP:GetShootPos()
    local owner = self:GetOwner()

    if !IsValid(owner) then return Vector(), Angle() end

    if SERVER and owner:IsNPC() then
        return owner:GetShootPos()
    end

    local pos = owner:EyePos()

    local ang = self:GetShootDir()
    local height = ang:Up()

    height:Mul(Vector(5, 5, 5))
    pos:Add(height)

    --pos = pos + (owner:EyeAngles():Right() * self:GetLeanOffset())

    local rightVec = owner:EyeAngles():Right()
    rightVec:Mul(Vector(5, 5, 5))

    pos:Add(rightVec)

    local shootposoffset = Vector(5, 5, 5)

    local angRight = ang:Right()
    local angForward = ang:Forward()
    local angUp = ang:Up()

    angRight:Mul(shootposoffset[1])
    angForward:Mul(shootposoffset[2])
    angUp:Mul(shootposoffset[3])

    pos:Add(angRight)
    pos:Add(angForward)
    pos:Add(angUp)

    pos, ang = Vector(5, 5, 5)

    return pos, ang
end

function SWEP:GetShootDir()
    local owner = self:GetOwner()
    if !owner:IsValid() then return self:GetAngles() end
    local dir = owner:EyeAngles()
    local shootangoffset = Vector(0, 0, 0)

    dir:RotateAroundAxis(dir:Right(), shootangoffset[1])
    dir:RotateAroundAxis(dir:Up(), shootangoffset[2])
    dir:RotateAroundAxis(dir:Forward(), shootangoffset[3])

    dir:Add(self:GetFreeAimOffset())

    return dir
end
--PATH lua/weapons/arccw_base/sh_deploy.lua:
local ang0 = Angle(0, 0, 0)
local dev_alwaysready = ArcCW.ConVars["dev_alwaysready"]

function SWEP:Deploy()
    if !IsValid(self:GetOwner()) or self:GetOwner():IsNPC() then
        return
    end

    if self.UnReady then
        local sp = game.SinglePlayer()

        if sp then
            if SERVER then
                self:CallOnClient("LoadPreset", "autosave")
            else
                self:LoadPreset("autosave")
            end
        else
            if SERVER then
                -- the server... can't get the client's attachments in time.
                -- can make it so client has to do a thing and tell the server it's ready,
                -- and that's probably what i'll do later.
            else
                self:LoadPreset("autosave")
            end
        end
    end

    self:InitTimers()

    self:SetShouldHoldType()

    self:SetReloading(false)
    self:SetPriorityAnim(false)
    self:SetInUBGL(false)
    self:SetMagUpCount(0)
    self:SetMagUpIn(0)
    self:SetShotgunReloading(0)
    self:SetHolster_Time(0)
    self:SetHolster_Entity(NULL)

    self:SetFreeAimAngle(ang0)
    self:SetLastAimAngle(ang0)

    self.LHIKAnimation = nil
    self.CrosshairDelta = 0

    self:SetBurstCount(0)

    self:WepSwitchCleanup()
    if game.SinglePlayer() then self:CallOnClient("WepSwitchCleanup") end

    if !self:GetOwner():InVehicle() then -- Don't play anim if in vehicle. This can be caused by HL2 level changes
        local prd = false

        local r_anim = self:SelectAnimation("ready")
        local d_anim = self:SelectAnimation("draw")

        if (CLIENT and !game.SinglePlayer() and LocalPlayer():IsListenServerHost()) then
            self.ReadySoundTableHack = true
        end

        if self.Animations[r_anim] and ( dev_alwaysready:GetBool() or self.UnReady ) then
            self:PlayAnimation(r_anim, 1, true, 0, false)
            prd = self.Animations[r_anim].ProcDraw

            self:SetPriorityAnim(CurTime() + self:GetAnimKeyTime(r_anim, true))

            if CLIENT then
                self:SetTimer(self:GetAnimKeyTime(r_anim, true), function() self.UnReady = false end, "UnReady")
            end
        elseif self.Animations[d_anim] then
            self:PlayAnimation(d_anim, self:GetBuff_Mult("Mult_DrawTime"), true, 0, false)
            prd = self.Animations[d_anim].ProcDraw

            self:SetPriorityAnim(CurTime() + self:GetAnimKeyTime(d_anim, true) * self:GetBuff_Mult("Mult_DrawTime"))
        end

        if prd or (!self.Animations[r_anim] and !self.Animations[d_anim]) then
            self:ProceduralDraw()
        end
    end

    self:SetState(ArcCW.STATE_DISABLE)

    if (SERVER or game.SinglePlayer()) and self.UnReady then
        if SERVER then
            self:InitialDefaultClip()
        end
        self.UnReady = false
    end

    if self:GetBuff_Override("Override_AutoReload", self.AutoReload) then
        self:RestoreAmmo()
    end

    timer.Simple(0, function()
        if IsValid(self) then self:SetupModel(false) end
    end)

    if SERVER then
        self:SetupShields()
        -- Networking the weapon at this time is too early - entity is not yet valid on client
        -- Also not a good idea because networking many weapons will cause mass lag (e.g. TTT round setup)
        -- Instead, make client send a request when it is valid there
        --self:NetworkWeapon()
        self:GetOwner():SetSaveValue("m_flNextAttack", 0) -- the magic fix-it-all solution for custom deploy problems including sounds
    elseif CLIENT and !self.CertainAboutAtts and !self.AttReqSent and IsValid(self:GetOwner()) then
        -- If client is aware of this weapon and it's not on the ground, ask for attachment info
        -- If it is not on a player, delay networking until it is rendered (in cl_viewmodel)
        -- print(self, "network weapon from sh_deploy")
        self.AttReqSent = true
        net.Start("arccw_rqwpnnet")
            net.WriteEntity(self)
        net.SendToServer()
    end

    -- self:RefreshBGs()

    self:GetBuff_Hook("Hook_OnDeploy")

    return true
end

function SWEP:ResetCheckpoints()
    self.CheckpointAnimation = nil

    if game.SinglePlayer() and SERVER then
        net.Start("arccw_sp_checkpoints")
        net.Broadcast()
    end
end

function SWEP:InitialDefaultClip()
    if !self.Primary.Ammo then return end
    if engine.ActiveGamemode() == "darkrp" then return end -- DarkRP is god's second biggest mistake after gmod

    if self:GetOwner() and self:GetOwner():IsPlayer() then
        if self:HasBottomlessClip() then
            self:SetClip1(0)
        end
        if self.ForceDefaultAmmo then
            self:GetOwner():GiveAmmo(self.ForceDefaultAmmo, self.Primary.Ammo)
        elseif engine.ActiveGamemode() != "terrortown" then
            self:GetOwner():GiveAmmo(self:GetCapacity() * ArcCW.ConVars["mult_defaultammo"]:GetInt(), self.Primary.Ammo)
        end
    end
end

function SWEP:Initialize()
    if SERVER and game.SinglePlayer() and IsValid(self:GetOwner()) and self:GetOwner():IsPlayer() then
        self:CallOnClient("Initialize")
    end

    if CLIENT then
        local class = self:GetClass()

        if self.KillIconAlias then
            killicon.AddAlias(class, self.KillIconAlias)
            class = self.KillIconAlias
        end

        local path = "arccw/weaponicons/" .. class
        local mat = Material(path)

        if !mat:IsError() then

            local tex = mat:GetTexture("$basetexture")
            if tex then
                local texpath = tex:GetName()
                killicon.Add(class, texpath, Color(255, 255, 255))
                self.WepSelectIcon = surface.GetTextureID(texpath)

                if self.ShootEntity then
                killicon.Add(self.ShootEntity, texpath, Color(255, 255, 255))
                end
            end
        end

        -- Check for incompatibile addons once
        if LocalPlayer().ArcCW_IncompatibilityCheck != true and game.SinglePlayer() then
            LocalPlayer().ArcCW_IncompatibilityCheck = true

            local incompatList = {}
            local addons = engine.GetAddons()
            for _, addon in pairs(addons) do
                if ArcCW.IncompatibleAddons[tostring(addon.wsid)] and addon.mounted then
                    incompatList[tostring(addon.wsid)] = addon
                end
            end

            local predrawvmhooks = hook.GetTable().PreDrawViewModel
            if predrawvmhooks and (predrawvmhooks.DisplayDistancePlaneLS or predrawvmhooks.DisplayDistancePlane) then -- vtools lua breaks arccw with stupid return in vm hook, ya dont need it if you going to play with guns
                hook.Remove("PreDrawViewModel", "DisplayDistancePlane")
                hook.Remove("PreDrawViewModel", "DisplayDistancePlaneLS")
                incompatList["DisplayDistancePlane"] = {
                    title = "Light Sprayer / Scenic Dispenser tool",
                    wsid = "DisplayDistancePlane",
                    nourl = true,
                }
            end
            local shouldDo = true
            -- If never show again is on, verify we have no new addons
            if file.Exists("arccw_incompatible.txt", "DATA") then
                shouldDo = false
                local oldTbl = util.JSONToTable(file.Read("arccw_incompatible.txt"))
                for id, addon in pairs(incompatList) do
                    if !oldTbl[id] then shouldDo = true break end
                end
                if shouldDo then file.Delete("arccw_incompatible.txt") end
            end
            if shouldDo and !table.IsEmpty(incompatList) then
                ArcCW.MakeIncompatibleWindow(incompatList)
            elseif !table.IsEmpty(incompatList) then
                print("ArcCW ignored " .. table.Count(incompatList) .. " incompatible addons. If things break, it's your fault.")
            end
        end
    end

    if ArcCW.ConVars["equipmentsingleton"]:GetBool() and self.Throwing then
        self.Singleton = true
        self.Primary.ClipSize = -1
        self.Primary.Ammo = ""
    end

    self:SetState(0)
    self:SetClip2(0)
    self:SetLastLoad(self:Clip1())

    self.Attachments["BaseClass"] = nil

    if !self:GetOwner():IsNPC() then
        self:SetHoldType(self.HoldtypeActive)
    end

    local og = weapons.Get(self:GetClass())

    self.RegularClipSize = og.Primary.ClipSize

    self.OldPrintName = self.PrintName

    self:InitTimers()

    if engine.ActiveGamemode() == "terrortown" then
        self:TTT_Init()
    end

    hook.Run("ArcCW_WeaponInit", self)

    if (!IsValid(self:GetOwner()) or self:GetOwner():IsNPC()) and self:IsValid() and self.NPC_Initialize then
        self:NPC_Initialize()
    else
        self:AdjustAtts()
        self:RefreshBGs()
    end
end

function SWEP:Holster(wep)
    if !IsFirstTimePredicted() then return end
    if self:GetOwner():IsNPC() then return end

    if CLIENT and self:GetOwner() == LocalPlayer() and ArcCW.InvHUD then ArcCW.InvHUD:Remove() end

    if self:GetBurstCount() > 0 and self:Clip1() > self:GetBuff("AmmoPerShot") then return false end

    if CLIENT and LocalPlayer() != self:GetOwner() then
        return
    end

    if self:GetGrenadePrimed() then
        self:GrenadeDrop(true)
    end

    self:WepSwitchCleanup()
    if game.SinglePlayer() then self:CallOnClient("WepSwitchCleanup") end

    if wep == self then self:Deploy() return false end
    if self:GetHolster_Time() > CurTime() then return false end

    self.UnReady = false

    -- Props deploy to NULL, finish holster on NULL too
    if (self:GetHolster_Time() != 0 and self:GetHolster_Time() <= CurTime()) or !IsValid(wep) then
        self:SetHolster_Time(0)
        self:SetHolster_Entity(NULL)
        self:FinishHolster()
        self:GetBuff_Hook("Hook_OnHolsterEnd")
        return true
    else
        self:SetHolster_Entity(wep)

        if self:GetGrenadePrimed() then
            self:Throw()
        end

        self.Sighted = false
        self.Sprinted = false
        self:SetShotgunReloading(0)
        self:SetMagUpCount(0)
        self:SetMagUpIn(0)

        local time = 0.25
        local anim = self:SelectAnimation("holster")
        if anim then
            local prd = self.Animations[anim].ProcHolster
            time = self:GetAnimKeyTime(anim)
            if prd then
                self:ProceduralHolster()
                time = 0.25
            end
            self:PlayAnimation(anim, self:GetBuff_Mult("Mult_DrawTime"), true, nil, nil, nil, true)
            self:SetHolster_Time(CurTime() + time * self:GetBuff_Mult("Mult_DrawTime"))
        else
            self:ProceduralHolster()
            self:SetHolster_Time(CurTime() + time * self:GetBuff_Mult("Mult_DrawTime"))
        end
        self:SetPriorityAnim(CurTime() + time * self:GetBuff_Mult("Mult_DrawTime"))
        self:SetWeaponOpDelay(CurTime() + time * self:GetBuff_Mult("Mult_DrawTime"))

        self:GetBuff_Hook("Hook_OnHolster")
    end
end

function SWEP:FinishHolster()
    self:KillTimers()

    if CLIENT then
        self:KillFlashlights()
    else
        if self:GetBuff_Override("UBGL_UnloadOnDequip") then
            local clip = self:Clip2()

            local ammo = self:GetBuff_Override("UBGL_Ammo") or "smg1_grenade"

            if IsValid(self:GetOwner()) then
                self:GetOwner():GiveAmmo(clip, ammo, true)
            end

            self:SetClip2(0)
        end

        self:KillShields()

        local vm = self:GetOwner():GetViewModel()
        if IsValid(vm) then
            for i = 0, vm:GetNumBodyGroups() do
                vm:SetBodygroup(i, 0)
            end
            vm:SetSkin(0)
            vm:SetPlaybackRate(1)
        end

        if self.Disposable and self:Clip1() == 0 and self:Ammo1() == 0 then
            self:GetOwner():StripWeapon(self:GetClass())
        end
    end
end

-- doesn't work if they dont call in prediction blah blah

function SWEP:ProceduralDraw()
    if SERVER and self:GetOwner():IsValid() then
        self:CallOnClient("ProceduralDraw")
    end

    self.InProcDraw = true
    self.ProcDrawTime = CurTime()
end

function SWEP:ProceduralHolster()
    if SERVER and self:GetOwner():IsValid() then
        self:CallOnClient("ProceduralHolster")
    end

    self.InProcHolster = true
    self.ProcHolsterTime = CurTime()
end

function SWEP:WepSwitchCleanup()
    -- table.Empty(self.EventTable)
    self.InProcDraw = false
    self.InProcHolster = false
end

function SWEP:ProceduralBash()
    if game.SinglePlayer() and self:GetOwner():IsValid() then
        self:CallOnClient("ProceduralBash")
    end

    local mult = self:GetBuff_Mult("Mult_MeleeTime")
    local mt = self.MeleeTime * mult

    self.InProcBash = true
    self.ProcBashTime = CurTime()
    self:SetTimer(mt, function()
        self.InProcBash = false
    end)
end

--PATH lua/weapons/arccw_base/sh_grenade.lua:
SWEP.GrenadePrimeTime = 0

function SWEP:PreThrow()

    if self:GetNWState() == ArcCW.STATE_SPRINT and !self:CanShootWhileSprint() then return end

    local bot, inf = self:HasBottomlessClip(), self:HasInfiniteAmmo()
    local aps = self:GetBuff("AmmoPerShot")

    if !inf and (bot and self:Ammo1() or self:Clip1()) < aps then
        if self:Ammo1() == 0 and self:Clip1() == 0 and !self:GetBuff_Override("Override_KeepIfEmpty", self.KeepIfEmpty) then
            self:GetOwner():StripWeapon(self:GetClass())
        end
        return
    end

    if self:GetGrenadePrimed() then return end

    if engine.ActiveGamemode() == "terrortown" and GetRoundState and GetRoundState() == ROUND_PREP and
        ((GetConVar("ttt_no_nade_throw_during_prep") and GetConVar("ttt_no_nade_throw_during_prep"):GetBool())
            or (GetConVar("ttt_nade_throw_during_prep") and !GetConVar("ttt_nade_throw_during_prep"):GetBool())) then
        return
    end

    self.GrenadePrimeTime = CurTime()
    local alt = self:GetOwner():KeyDown(IN_ATTACK2)
    self:SetGrenadeAlt(alt)
    self:SetGrenadePrimed(true)

    local pulltime = self:GetBuff("PullPinTime")
    local anim = alt and self:SelectAnimation("pre_throw_alt") or self:SelectAnimation("pre_throw")
    self:PlayAnimation(anim, self.PullPinTime / pulltime, true, 0, true, nil, true)

    self.isCooked = (!alt and self:GetBuff("CookPrimFire", true)) or (alt and self:GetBuff("CookAltFire", true)) or nil

    self:SetNextPrimaryFire(CurTime() + pulltime)
    self:SetPriorityAnim(CurTime() + pulltime)

    self:SetShouldHoldType()

    self:GetBuff_Hook("Hook_PreThrow")

    if pulltime == 0 then
        self:Throw()
        return
    end
end

function SWEP:Throw()
    if self:GetNextPrimaryFire() > CurTime() then return end

    local isCooked = self.isCooked
    self:SetGrenadePrimed(false)
    self.isCooked = nil

    local alt = self:GetGrenadeAlt()

    local anim = alt and self:SelectAnimation("throw_alt") or self:SelectAnimation("throw")
    self:PlayAnimation(anim, self:GetBuff_Mult("Mult_ThrowTime"), false, 0, true)

    local animevent = alt and self:GetBuff_Override("Override_AnimShootAlt", self.AnimShootAlt) or self:GetBuff_Override("Override_AnimShoot", self.AnimShoot)
    self:GetOwner():DoAnimationEvent(animevent)

    local heldtime = CurTime() - self.GrenadePrimeTime

    local mv = 0

    if alt then
        mv = self:GetBuff("MuzzleVelocityAlt", true) or self:GetBuff("MuzzleVelocity")
    else
        mv = self:GetBuff("MuzzleVelocity")
        local chg = self:GetBuff("WindupTime")
        if chg > 0 then
            mv = Lerp(math.Clamp(heldtime / chg, 0, 1), mv * self:GetBuff("WindupMinimum"), mv)
        end
    end

    local force = mv * ArcCW.HUToM

    self:SetTimer(self:GetBuff("ShootEntityDelay"), function()

        local ft = self:GetBuff("FuseTime", true)
        local data = {
            dodefault = true,
            force = force,
            shootentity = self:GetBuff_Override("Override_ShootEntity", self.ShootEntity),
            fusetime = ft and (ft - (isCooked and heldtime or 0)),
        }
        local ovr = self:GetBuff_Hook("Hook_Throw", data)
        if !ovr or ovr.dodefault then
            local rocket = self:FireRocket(self:GetBuff_Override("Override_ShootEntity", self.ShootEntity), force / ArcCW.HUToM)
            if !rocket then return end

            if ft then
                if isCooked then
                    rocket.FuseTime = ft - heldtime
                else
                    rocket.FuseTime = ft
                end
            else
                rocket.FuseTime = math.huge
            end

            local phys = rocket:GetPhysicsObject()

            local inertia = self:GetBuff_Override("Override_ThrowInertia", self.ThrowInertia)
            if inertia == nil then inertia = ArcCW.ConVars["throwinertia"]:GetBool() end
            if inertia and mv > 100 then
                phys:AddVelocity(self:GetOwner():GetVelocity())
            end

            phys:AddAngleVelocity( Vector(0, 750, 0) )
        end
        if !self:HasInfiniteAmmo() then
            local aps = self:GetBuff("AmmoPerShot")
            local a1 = self:Ammo1()
            if self:HasBottomlessClip() or a1 >= aps then
                self:TakePrimaryAmmo(aps)
            elseif a1 < aps then
                self:SetClip1(math.min(self:GetCapacity() + self:GetChamberSize(), self:Clip1() + a1))
                self:TakePrimaryAmmo(a1)
            end

            if (self.Singleton or self:Ammo1() == 0) and !self:GetBuff_Override("Override_KeepIfEmpty", self.KeepIfEmpty) then
                self:GetOwner():StripWeapon(self:GetClass())
                return
            end
        end

    end)
    local t = self:GetAnimKeyTime(anim) * self:GetBuff_Mult("Mult_ThrowTime")
    self:SetPriorityAnim(CurTime() + t)
    self:SetTimer(t, function()
        if !self:IsValid() then return end
        local a = self:SelectAnimation("reload") or self:SelectAnimation("draw")
        self:PlayAnimation(a, self:GetBuff_Mult("Mult_ReloadTime"), true, 0, nil, nil, true)
        self:SetPriorityAnim(CurTime() + self:GetAnimKeyTime(a, true) * self:GetBuff_Mult("Mult_ReloadTime"))
    end)

    self:SetNextPrimaryFire(CurTime() + self:GetFiringDelay())

    self:SetGrenadeAlt(false)

    self:SetShouldHoldType()

    self:GetBuff_Hook("Hook_PostThrow")
end

function SWEP:GrenadeDrop(doammo)
    local rocket = self:FireRocket(self.ShootEntity, 0)

    if IsValid(rocket) then
        local phys = rocket:GetPhysicsObject()

        if ArcCW.ConVars["throwinertia"]:GetBool() then
            phys:AddVelocity(self:GetOwner():GetVelocity())
        end

        local ft = self:GetBuff_Override("Override_FuseTime") or self.FuseTime

        if ft then
            if self.isCooked then
                rocket.FuseTime = ft - (CurTime() - self.GrenadePrimeTime)
            else
                rocket.FuseTime = ft
            end
        end
    end

    if doammo then
        if !self:HasInfiniteAmmo() then
            local aps = self:GetBuff("AmmoPerShot")
            local a1 = self:Ammo1()
            if self:HasBottomlessClip() or a1 >= aps then
                self:TakePrimaryAmmo(aps)
            elseif a1 < aps then
                self:SetClip1(math.min(self:GetCapacity() + self:GetChamberSize(), self:Clip1() + a1))
                self:TakePrimaryAmmo(a1)
            end

            if (self.Singleton or self:Ammo1() == 0) and !self:GetBuff_Override("Override_KeepIfEmpty", self.KeepIfEmpty) then
                self:GetOwner():StripWeapon(self:GetClass())
                return
            end
        end

        self:SetNextPrimaryFire(CurTime() + 1)
        self:SetGrenadePrimed(false)
    end
end
--PATH lua/weapons/arccw_base/sh_ttt.lua:
return gluapack()()
--PATH lua/weapons/arccw_base_melee/shared.lua:
return gluapack()()
--PATH lua/weapons/arccw_base_nade/shared.lua:
return gluapack()()
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_a620.lua:
return gluapack()()
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/weapons/arccw_k_coruscantguardshield.lua:
return gluapack()()
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_cr2.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3 

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Galactic Expansion v2"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "CR-2"
SWEP.Trivia_Class = "Heavy Pistol"
SWEP.Trivia_Desc = "The CR-2 heavy blaster pistol, also known more simply as a CR-2 blaster pistol, was a heavy blaster pistol manufactured by Corellian Arms that was utilized by the Royal Naboo Security Forces. Small and agile, it had an extreme rate of fire and shoot ionized bolts. It also could be configured with night vision scopes or have an extended stock for reduced recoil."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/galactic/cr2.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "00000000000000000"

SWEP.HideViewmodel = false
SWEP.MirrorVMWM = true
SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/kraken/galactic/v_cr2.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"
SWEP.ViewModelFOV = 70

SWEP.WorldModelOffset = {
    pos = Vector(1.2, 0.6, -3.3),
    ang = Angle(-10, 0, 180),
    scale = 1,
}

-- Damage & Tracer
SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 20
SWEP.DamageMin = 15
SWEP.RangeMin = 0
SWEP.Range = 600
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 9000

SWEP.TraceNum = 1
SWEP.Tracer = "tracer_green"
SWEP.TracerCol = Color(0, 250, 0)

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 60

SWEP.Recoil = 0.75
SWEP.RecoilSide = 0.35
SWEP.RecoilRise = 0.65
SWEP.RecoilPunch = 0.5

SWEP.Delay = 60 / 680
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
        PostBurstDelay = 0.1,
    },
    {
		Mode = 2,
        PostBurstDelay = 0.1,
    },
    {
        Mult_RPM = 2,
		Mode = -3,
        PostBurstDelay = 0.1,
    },
	{
		Mode = 0,
   	}
}

SWEP.AccuracyMOA = 0
SWEP.HipDispersion = 250
SWEP.MoveDispersion = 100
SWEP.JumpDispersion = 150

-- Speed Mult
SWEP.SpeedMult = 1.10
SWEP.SightedSpeedMult = 0.75
SWEP.ShootSpeedMult = 1.05

-- Sounds & Muzzleflash
SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 125
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.05

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.FirstShootSound = "ArcCW_Kraken.SW_CR2"
SWEP.ShootSound = "ArcCW_Kraken.SW_CR2"
SWEP.DistantShootSound = "ArcCW_Kraken.StandardCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.MuzzleFlashColor = Color(0, 250, 0)
SWEP.MuzzleEffect = "blaster_muzzle_green"
SWEP.GMMuzzleEffect = false

-- Ironsight & Holdtype
SWEP.IronSightStruct = {
    Pos = Vector(-1.99, 0, 1.2),
    Ang = Vector(0, 0.2, 2),
     Magnification = 1.5,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 55,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(-1, 2, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(0, 0, 1.5)
SWEP.SprintAng = Angle(0, 0, 0)

SWEP.CrouchPos = Vector(-4, 0, -1)
SWEP.CrouchAng = Angle(0, 0, -10)

SWEP.HolsterPos = Vector(3, 3, 0)
SWEP.HolsterAng = Angle(-7.036, 30.016, 0)

SWEP.BarrelOffsetSighted = Vector(0, 0, -1)
SWEP.BarrelOffsetHip = Vector(2, 0, -2)

SWEP.CustomizePos = Vector(10, 0, 0)
SWEP.CustomizeAng = Angle(20, 30.7, 10.3)

-- Attachments 
SWEP.DefaultElements = {}
SWEP.Attachments = {     
    {
        PrintName = "Optics", 
        DefaultAttName = "None",
        Slot = "optic",
        Bone = "tag_attachments",
        Offset = {
            vpos = Vector(1, -0.0, 1.1),
            vang = Angle(0, 0, 0),
        },
        CorrectivePos = Vector(0, 0, 0),
        CorrectiveAng = Angle(0, 0, 0)
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "stealth_muzzle"},
        VMScale = Vector(1.2, 1.2, 1.2),
        WMScale = Vector(1.2, 1.2, 1.2),
        Bone = "tag_attachments",
        Offset = {
            vpos = Vector(15, -0.0, -1.2),
            vang = Angle(0, 0, 0),
        },
    },
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(1, 1, 1),
        WMScale = Vector(1, 1, 1),
        Bone = "tag_attachments",
        Offset = {
            vpos = Vector(10, 0.8, -1.1),
            vang = Angle(0, 0, -90),
        },
    },  
    {
        PrintName = "Underbarrel",
        DefaultAttName = "None",
        Slot = {"foregrip"},
        VMScale = Vector(1, 1, 1),
        WMScale = Vector(1, 1, 1),
        Bone = "tag_attachments",
        InstalledEles = {"grip_attach"},
        Offset = {
            vpos = Vector(10, 0, -1.8),
            vang = Angle(0, 0, 0),
        },
    },  
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.6, 0.6, 0.6),
        WMScale = Vector(0.6, 0.6, 0.6),
        Bone = "tag_attachments",
        Offset = {
            vpos = Vector(6.5, -0.39, 0.85),
            vang = Angle(0, 0, 0),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        Bone = "tag_attachments",
        Offset = {
            vpos = Vector(10.4, -0.7, -0.5),
            vang = Angle(0, 0, 30),
        },
    },
}

-- Don't touch this unless you know what you're doing
local path = "arccw/kraken/sw_galactic/weapons/cr2/handling/"

SWEP.Animations = {
    ["fire"] = {
        Source = "shoot1",
    },
    ["reload"] = {
        Source = "reload_short",
        LHIK = true,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
		MinProgress = 0.925,
        SoundTable = {
            {s = path .. "wfoly_sm_secho_reload_up.ogg", t = 0.0},
            {s = "ArcCW_Kraken.Overheat", t = 0.5 },
            {s = path .. "wfoly_sm_secho_reload_magout.ogg", t = 0.433},
			{s = path .. "wfoly_sm_secho_reload_maghit.ogg", t = 0.867},
			{s = path .. "wfoly_sm_secho_reload_magin.ogg", t = 1.233},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 1.23},
			{s = path .. "wfoly_sm_secho_reload_end.ogg", t = 1.567},
        },
    },
    ["reload_empty"] = {
        Source = "reload",
		MinProgress = 0.925,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
        LHIK = true,
        SoundTable = {
			{s = path .. "wfoly_sm_secho_reload_empty_up.ogg", t = 0.033},
			{s = path .. "wfoly_sm_secho_reload_empty_magout.ogg", t = 0.467},
            {s = "ArcCW_Kraken.Overheat", t = 0.5 },
			{s = path .. "wfoly_sm_secho_reload_empty_mvmnt.ogg", t = 1.133},
			{s = path .. "wfoly_sm_secho_reload_empty_maghit.ogg", t = 1.25},
			{s = path .. "wfoly_sm_secho_reload_empty_magin.ogg", t = 1.35},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 1.36},
			{s = path .. "wfoly_sm_secho_reload_empty_charge.ogg", t = 1.64},
			{s = path .. "wfoly_sm_secho_reload_empty_end.ogg", t = 1.867},
        },
    },
    ["ready"] = {
        Source = "draw",
        LHIK = true,
		MinProgress = 0.85,
		FireASAP = true,
        SoundTable = {
            {s = path .. "wfoly_sm_secho_raise_first_up.ogg", t = 0.0},
            {s = path .. "wfoly_sm_secho_raise_first_charge.ogg", t = 0.5},
            {s = path .. "wfoly_sm_secho_raise_first_end.ogg", t = 0.667},
        },
    },
    ["draw"] = {
        Source = "draw_short",
		MinProgress = 0.5,
        LHIK = true,
		FireASAP = true,
        SoundTable = {
            {s = path .. "wfoly_sm_secho_raise.ogg", t = 0/30},
        },
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {s = path .. "wfoly_sm_secho_reload_end.ogg", t = 0/30},
        },
    },
    ["idle"] = {
        Source = "idle",
    },
    ["idle_sprint"] = {
        Source = "sprint",
    },
    ["exit_sprint"] = {
        Source = "sprint_out",
		Time = 1.25,
    },
    ["enter_sprint"] = {
        Source = "sprint_in",
		IKTimeLine = { { t = 0,  lhik = 1, rhik = 1} },
		Time = 1.25,
    },
    ["exit_inspect"] = {
        Source = "lookat01",
		MinProgress = 0.9,
		FireASAP = true,
        LHIK = true,
        SoundTable = {
            {s = path .. "wfoly_sm_secho_inspect_magout.ogg", t = 0.033},
			{s = path .. "wfoly_sm_secho_inspect_magin.ogg", t = 1.967},
			{s = path .. "wfoly_sm_secho_inspect_end.ogg", t = 3.4},
        },
    },
    ["bash"] = {
        Source = {"melee","melee2","melee3"},
        LHIK = true,
    },
    ["changefiremode"] = {
        Source = "semi_on",
        SoundTable = {
            {s = path .. "wfoly_sm_secho_selectsemi_on.ogg", t = 0/30},
        },
    },
    ["enter_bipod"] = {
        Source = "bipod_in",
    },
    ["exit_bipod"] = {
        Source = "bipod_out",
    },
}
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_cyclerobrez.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 4 -- Change this if you want to select the weapon with other number

SWEP.Category = "[ArcCW] Kraken's Galactic Expansion v2"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "Cycler Obrez"
SWEP.Trivia_Class = "Shotgun"
SWEP.Trivia_Desc = "Cycler rifles were crude yet reliable slugthrower rifles designed to fire solid projectiles. They could hit targets at extreme ranges and penetrate energy shields. Used primarily by primitive cultures and hunters, they were strong enough to tear whole limbs from a body."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/galactic/cyclerobrez.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "0001000000000000"

SWEP.HideViewmodel = false
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/galactic/v_cycler.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"
SWEP.ViewModelFOV = 70

SWEP.WorldModelOffset = {
    pos = Vector(-1, 0.6, -3),
    ang = Angle(-5, 0, 180),
    scale = 1,
}

-- Damage & Tracer
SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.NoRandSpread = true
SWEP.CanBash = true

SWEP.ShotgunSpreadPattern = {
    [1] = Angle(0, 0, 0),
    [2] = Angle(0, 1, 0),
    [3] = Angle(0, -1, 0),
    [4] = Angle(2.1, 0, 0),
    [5] = Angle(-2.1, 0, 0),
    [6] = Angle(1.4, 1.2, 0),
    [7] = Angle(-1.4, 1.2, 0),
    [8] = Angle(1.4, -1.2, 0),
    [9] = Angle(-1.4, -1.2, 0),
}

SWEP.Damage = 31
SWEP.DamageMin = 25
SWEP.RangeMin = 0
SWEP.Range = 1000
SWEP.Penetration = 8
SWEP.DamageType = DMG_BUCKSHOT
SWEP.MuzzleVelocity = 9000

SWEP.TraceNum = 1
SWEP.Tracer = "tracer_orange"
SWEP.TracerCol = Color(250, 242, 0)

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 2

SWEP.Recoil = 3
SWEP.RecoilSide = 1.5
SWEP.RecoilRise = 2
SWEP.MaxRecoilBlowback = 2
SWEP.RecoilPunch = 1.5
SWEP.RecoilVMShake = 2

SWEP.Delay = 60 / 120
SWEP.Num = 9
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
        PostBurstDelay = 0.1,
    },
	{
		Mode = 0,
   	}
}


SWEP.AccuracyMOA = 0
SWEP.HipDispersion = 100
SWEP.MoveDispersion = 75
SWEP.JumpDispersion = 150

-- Speed Mult
SWEP.SpeedMult = 0.85
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.30

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 100
SWEP.ShootPitch = 100

SWEP.FirstShootSound = "ArcCW_Kraken.SW_CYCLERO"
SWEP.ShootSound = "ArcCW_Kraken.SW_CYCLERO"
SWEP.DistantShootSound = "ArcCW_Kraken.HeavyCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.MuzzleFlashColor = Color(250, 242, 0)
SWEP.MuzzleEffect = "blaster_muzzle_red"
SWEP.GMMuzzleEffect = false

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-3.05, -0, 0.5),
    Ang = Vector(0.5, 0, -2),
     Magnification = 1.5,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 55,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_SHOTGUN

SWEP.ActivePos = Vector(-1, 2, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(4.019, -5.226, 0)
SWEP.SprintAng = Angle(5, 0, 0)

SWEP.CrouchPos = Vector(-4, 0, -1)
SWEP.CrouchAng = Angle(0, 0, -10)

SWEP.HolsterPos = Vector(3, 3, 0)
SWEP.HolsterAng = Angle(-7.036, 30.016, 0)

SWEP.BarrelOffsetSighted = Vector(0, 0, -1)
SWEP.BarrelOffsetHip = Vector(2, 0, -2)

SWEP.CustomizePos = Vector(10, 0, 0)
SWEP.CustomizeAng = Angle(20, 30.7, 10.3)

SWEP.GuaranteeLaser = true

-- Attachments
SWEP.DefaultElements = {}
SWEP.AttachmentElements = {
    ["scope_attach"] = {
        VMBodygroups = {{ind = 3, bg = 0}, {ind = 5, bg = 1}},
    },
    ["grip_attach"] = {
        VMBodygroups = {{ind = 4, bg = 1}},
    },
}

SWEP.Attachments = {     
    {
        PrintName = "Optics", 
        DefaultAttName = "None",
        Slot = "optic",
        Bone = "tag_scope",
        InstalledEles = {"scope_attach"},
        Offset = {
            vpos = Vector(4, 0, -0.1),
            vang = Angle(0, 0, 0),
        },
        CorrectivePos = Vector(0, 0, 0),
        CorrectiveAng = Angle(0, 0, 0)
    },
    {
        PrintName = "Internal Compression",
        DefaultAttName = "None",
        Slot = {"muzzle", "stealth_muzzle"},
    },
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(1, 1, 1),
        WMScale = Vector(1, 1, 1),
        Bone = "tag_scope",
        Offset = {
            vpos = Vector(18, 0.4, -0.6),
            vang = Angle(0, 0, -90),
        },
    },  
    {
        PrintName = "Underbarrel",
        DefaultAttName = "None",
        Slot = {"foregrip"},
        VMScale = Vector(1,1,1),
        WMScale = Vector(1,1,1),
        Bone = "tag_rail",
        InstalledEles = {"grip_attach"},
        Offset = {
            vpos = Vector(0, 0, -2.8),
            vang = Angle(0, 0, 0),
        },
    },  
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.6, 0.6, 0.6),
        WMScale = Vector(0.6, 0.6, 0.6),
        Bone = "tag_rail",
        Offset = {
            vpos = Vector(-3.4, -0.8, -1.1),
            vang = Angle(0, 0, 0),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        Bone = "tag_rail",
        Offset = {
            vpos = Vector(0.8, -0.6, -1.1),
            vang = Angle(0, 0, 0),
        },
    },
}

-- Animations
local path = "arccw/kraken/sw_galactic/weapons/tuskencyclerrifle/handling/"

SWEP.Animations = {
    ["fire"] = {
        Source = "shoot1",
		IKTimeLine = { { t = 0,  lhik = 1, rhik = 1} },
    },
    ["fire_sight"] = {
        Source = "shoot1_scope",
		IKTimeLine = { { t = 0,  lhik = 1, rhik = 1} },
    },
    ["reload"] = {
        Source = "reload_short",
		MinProgress = 0.8,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SHOTGUN,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 0.25},
			{s = path .. "wfoly_plr_sh_charlie725_reload_start.ogg", t = 0.0},
			{s = path .. "wfoly_plr_sh_charlie725_reload_open_01.ogg", t = 0.2},
            {s = path .. "wfoly_plr_sh_charlie725_reload_swing.ogg", t = 0.567},
			{s = path .. "wfoly_plr_sh_charlie725_reload_shellin_01.ogg", t = 1.267},
			{s = path .. "wfoly_plr_sh_charlie725_reload_close_01.ogg", t = 1.733},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 1.74},
			{s = path .. "wfoly_plr_sh_charlie725_reload_end.ogg", t = 2.2},
        },
    },
    ["reload_empty"] = {
        Source = "reload",
		MinProgress = 0.8,
        LHIK = true,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SHOTGUN,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 0.25},
			{s = path .. "wfoly_plr_sh_charlie725_reload_empty_start.ogg", t = 0.0},
			{s = path .. "wfoly_plr_sh_charlie725_reload_empty_open_01.ogg", t = 0.2},
            {s = path .. "wfoly_plr_sh_charlie725_reload_empty_swing.ogg", t = 0.7},
			{s = path .. "wfoly_plr_sh_charlie725_reload_empty_shellsin_v2_01.ogg", t = 1.167},
			{s = path .. "wfoly_plr_sh_charlie725_reload_empty_shellsin_v2_02.ogg", t = 1.5},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 2.05},
			{s = path .. "wfoly_plr_sh_charlie725_reload_empty_close_01.ogg", t = 2.0},
			{s = path .. "wfoly_plr_sh_charlie725_reload_empty_end.ogg", t = 2.333},
        },
    },
    ["ready"] = {
        Source = "draw",
		MinProgress = 0.8,
        LHIK = true,
        SoundTable = {
            {s = path .. "wfoly_plr_sh_charlie725_raise_first_start.ogg", t = 0.1},
			{s = path .. "wfoly_plr_sh_charlie725_raise_first_close_01.ogg", t = 0.25},
			{s = path .. "wfoly_plr_sh_charlie725_raise_first_end.ogg", t = 0.633},
        },
    },
    ["draw"] = {
        Source = "draw_short",
		MinProgress = 0.3,
        LHIK = true,
        SoundTable = {
            {s = path .. "wfoly_plr_sh_charlie725_raise_up.ogg", t = 0/30},
        },
    },
    ["holster"] = {
        Source = "holster",
        LHIK = true,
        SoundTable = {
            {s = path .. "wfoly_plr_sh_charlie725_drop_down.ogg", t = 0/30},
        },
    },
    ["idle"] = {
        Source = "idle",
    },
    ["idle_sprint"] = {
        Source = "sprint",
    },
    ["exit_sprint"] = {
        Source = "sprint_out",
		Time = 1.25,
    },
    ["enter_sprint"] = {
        Source = "sprint_in",
		IKTimeLine = { { t = 0,  lhik = 1, rhik = 1} },
		Time = 1.25,
    },
    ["exit_inspect"] = {
        Source = "lookat01",
		MinProgress = 0.9,
        SoundTable = {
            {s = path .. "wfoly_sh_charlie725_inspect_01.ogg", t = 0.033},
			{s = path .. "wfoly_sh_charlie725_inspect_02.ogg", t = 1.5},
			{s = path .. "wfoly_sh_charlie725_inspect_03.ogg", t = 2.5},
			{s = path .. "wfoly_sh_charlie725_inspect_04.ogg", t = 3.667},
			{s = path .. "wfoly_sh_charlie725_inspect_05.ogg", t = 4.367},
        },
    },
    ["bash"] = {
        Source = {"melee","melee2","melee3"},
        LHIK = true,
    },
    ["changefiremode"] = {
        Source = "firemode",
        SoundTable = {
            {s = path .. "weap_charlie725_fire_first_plr_01.ogg", t = 0/30},
        },
    },
    ["enter_bipod"] = {
        Source = "bipod_in",
    },
    ["exit_bipod"] = {
        Source = "bipod_out",
    },
}
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/weapons/arccw_k_dc15le.lua:
return gluapack()()
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/weapons/arccw_k_dc15s.lua:
return gluapack()()
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_dc15se.lua:
return gluapack()()
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/weapons/arccw_k_dc15x.lua:
return gluapack()()
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/weapons/arccw_k_dc15x.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3 -- Change this if you want to select the weapon with other number

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Republic Arsenal"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "DC-15x"
SWEP.Trivia_Class = "Blaster Sniper Rifle"
SWEP.Trivia_Desc = "The DC-15x sniper rifle was a sniper rifle manufactured for the clone snipers of the Galactic Republic through extensive modifications of the standard-issue DC-15A blaster rifle."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Condensed Tibanna-Gas"
SWEP.Trivia_Country = "Galactic Republic"
SWEP.IconOverride = "entities/arccw/kraken/republic-arsenal/dc15x.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "0001000000000000"

SWEP.MirrorVMWM = true
SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/kraken/republic/v_dc15x.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_dlt19.mdl"
SWEP.ViewModelFOV = 60

SWEP.WorldModelOffset = {
    pos = Vector(-8, 3.5, -4),
    ang = Angle(-10, 0, 180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1,
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 5
SWEP.HeatDissipation = 2
SWEP.HeatLockout = true
SWEP.HeatDelayTime = 1
SWEP.HeatFix = true

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2.5,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 110
SWEP.DamageMin = 51
SWEP.RangeMin = 0
SWEP.Range = 900
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 9000

SWEP.TraceNum = 1
SWEP.Tracer = "tracer_blue"
SWEP.TracerCol = Color(0, 0, 250)

SWEP.HullSize = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 20

SWEP.Recoil = 1.8
SWEP.RecoilSide = 1.5
SWEP.RecoilRise = 2
SWEP.MaxRecoilBlowback = 2
SWEP.RecoilPunch = 1.5
SWEP.RecoilVMShake = 2

SWEP.Delay = 60 / 120
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
	{
		Mode = 0,
   	}
}

SWEP.AccuracyMOA = 5
SWEP.HipDispersion = 200
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.85
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.30

-- Ammo, Sounds & MuzzleEffect
local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0

SWEP.FirstShootSound = "ArcCW_Kraken.SW_DC15X"
SWEP.ShootSound = "ArcCW_Kraken.SW_DC15X"
SWEP.DistantShootSound = "ArcCW_Kraken.HeavyCorebass"
SWEP.ShootSoundSilenced = "armas/disparos/dc19.wav"

SWEP.MuzzleEffect = "blaster_muzzle_blue"
SWEP.MuzzleFlashColor = Color(0, 0, 255)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-2.964, -11.218, -0.41),
    Ang = Vector(0, 0, 0),
     Magnification = 1.5,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_SHOTGUN

SWEP.ActivePos = Vector(-1, 2, -1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(4, -3, -2)
SWEP.SprintAng = Angle(0, 30, -15)

SWEP.CustomizePos = Vector(15, 0, 5)
SWEP.CustomizeAng = Angle(0, 40, 30)

SWEP.HolsterPos = Vector(4, -3, -2)
SWEP.HolsterAng = Angle(0, 30, -15)

-- Attachments
SWEP.DefaultElements = {"muzzle"}
SWEP.AttachmentElements = {
    ["scope_attach"] = {
        VMBodygroups = {{ind = 4, bg = 1}, {ind = 5, bg = 2}},
    },
    ["grip_attach"] = {
        VMBodygroups = {{ind = 3, bg = 0}},
    },
    ["muzzle"] = {
        VMElements = {
           {
               Model = "models/hunter/plates/plate.mdl",
               Bone = "DC_15X_Rifle",
               Scale = Vector(0, 0, 0),                
               Offset = {
                pos = Vector(0, 42, 0),
                ang = Angle(-90, -90, 0)
               },
               IsMuzzleDevice = true
           }
        }
    }
}

SWEP.Attachments = {
    {
        PrintName = "Optic",
        DefaultAttName = "DC-15 Holosight",
        Slot = {"optic"},
        Bone = "DC_15X_Rifle",
        InstalledEles = {"scope_attach"},
        Offset = {
            vpos = Vector(-0.05, 6.2, 3),
            vang = Angle(0, -90, 0),
        },
        CorrectiveAng = Angle(0, 180, 0),
        CorrectivePos = Vector(0, 0, 0),
    },
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        Bone = "DC_15X_Rifle",
        Offset = {
            vpos = Vector(-1, 30, 0.8),
            vang = Angle(0, -90, -90),
        },
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "Standard",
        Slot = {"muzzle", "dlt19_muzzle", "dc15a_muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle", "b1120_muzzle"},
        Bone = "DC_15X_Rifle",
        Offset = {
            vpos = Vector(-0.05, 43.1, 0.8),
            vang = Angle(0, -90, 0),
        },
    },
    {
        PrintName = "Foregrip",
        DefaultAttName = "None",
        Slot = {"foregrip"},
        Bone = "DC_15X_Rifle",
        InstalledEles = {"grip_attach"},
        Offset = {
            vpos = Vector(-0.05, 8, -0.9),
            vang = Angle(90, -90, -90),   
        }, 
    },
    {
        PrintName = "Mode",
        DefaultAttName = "None",
        Slot = {"sw_mode", "sw_mode_sniper"},
    },   
    {
        PrintName = "Ammunition",
        DefaultAttName = "Standard",
        Slot = {"ammo"}
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = {"charm"},
        Bone = "DC_15X_Rifle",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(1.1, -4.67, 0.25),
            vang = Angle(0, -90, 0),
        },
    },
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = {"killcounter"},
        Bone = "DC_15X_Rifle",
        VMScale = Vector(1,1,1),
        WMScale = Vector(1,1,1),
        Offset = {
            vpos = Vector(1.1, -7.5, 0.5),
            vang = Angle(0, -90, 0),
        },
    },
}

SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["fire"] = {
        Source = "fire"
    },
    ["idle_iron"] = {
        Source = false,
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_rifle.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_rifle.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["reload"] = {
        Source = "reload",
        LHIK = true,
        Mult = 1.5,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "arccw/kraken/empire/dlt19/handling/magrelease.wav", t = 0.2 },
            {s = "arccw/kraken/empire/dlt19/handling/magout.wav", t = 0.4 },
            {s = "arccw/kraken/empire/dlt19/handling/mag_fetch.wav", t = 0.6 },   
            {s = "arccw/kraken/empire/dlt19/handling/magin.wav", t = 1.4 },   
            {s = "arccw/kraken/empire/dlt19/handling/boltback.wav", t = 1.6 },   
        },
    },
    ["fix"] = {
        Source = "overheat", 
        Mult = 2.5,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 55 / 30},
            {s = "ArcCW_Kraken.Grab", t = 53 / 30},
        },
    },
}
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/weapons/arccw_k_dc17_stun.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 1 -- Change this if you want to select the weapon with other number

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Republic Arsenal"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "DC-17 Stun"
SWEP.Trivia_Class = "Hand Blaster"
SWEP.Trivia_Desc = "The DC-17 repeater hand blaster, also known more simply as the DC-17 hand blaster or DC-17 blaster pistol, was a model of heavy blaster pistol and the Grand Army of the Republic's standard-issue sidearm. Produced by BlasTech Industries, the DC-17 was usually given to weapon teams, the crews of vehicles, and officers. The weapon was one of the most reliable and toughest models of blaster pistols created, as well as having remarkable stopping power in its small design. The weapon was also well balanced, possessed a respectable rate of fire, and lightweight."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Condensed Tibanna-Gas"
SWEP.Trivia_Country = "Galactic Republic"
SWEP.IconOverride = "entities/arccw/kraken/republic-arsenal/dc17_stun.png"

-- Viewmodel & Entity Properties
SWEP.UseHands = true
SWEP.MirrorVMWM = true
SWEP.NoHideLeftHandInCustomization = false

SWEP.ViewModel = "models/arccw/kraken/republic/v_dc17.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"
SWEP.ViewModelFOV = 60

SWEP.WorldModelOffset = {
    pos = Vector(-16, 5, -3.4),
    ang = Angle(-10, 0, 180),
    bone = "ValveBiped.Bip01_R_Hand",
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 15
SWEP.HeatDissipation = 2
SWEP.HeatLockout = true
SWEP.HeatDelayTime = 0.5
SWEP.HeatFix = true

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2.5,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 22
SWEP.DamageMin = 19
SWEP.RangeMin = 0
SWEP.Range = 180
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 9000

SWEP.TraceNum = 1
SWEP.Tracer = "tracer_blue"
SWEP.TracerCol = Color(0, 0, 250)

SWEP.HullSize = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 25

SWEP.Recoil = 0.9
SWEP.RecoilSide = 0.35
SWEP.RecoilRise = 0.55

SWEP.Delay = 60 / 250
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
	{
		Mode = 0,
   	}
}

SWEP.AccuracyMOA = 5
SWEP.HipDispersion = 200
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.95
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.30

-- Ammo, Sounds & MuzzleEffect
local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0

SWEP.FirstShootSound = "ArcCW_Kraken.SW_DC17"
SWEP.ShootSound = "ArcCW_Kraken.SW_DC17"
SWEP.DistantShootSound = "ArcCW_Kraken.StandardCorebass"
SWEP.ShootSoundSilenced = "armas/disparos/dc19.wav"

SWEP.MuzzleEffect = "blaster_muzzle_blue"
SWEP.MuzzleFlashColor = Color(0, 0, 255)

-- Ironsight & Holdtype
SWEP.IronSightStruct = {
    Pos = Vector(-3.79, -6.251, 0.55),
    Ang = Vector(0, 0, 0),
     Magnification = 1.1,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 55,
}

-- Holdtype
SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "pistol"
SWEP.HoldtypeSights = "revolver"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_PISTOL

SWEP.SprintPos = Vector(0, -6, -9)
SWEP.SprintAng = Angle(40, 0, 0)

SWEP.CustomizePos = Vector(10, -5, 2)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.CrouchPos = Vector(0, 0, 3)
SWEP.CrouchAng = Angle(0, 0, 0)

SWEP.ActivePos = Vector(0, 0, 1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.AttachmentElements = {
    ["akimbo"] = {
        Override_ActivePos = Vector(2, -2, 0),
        Override_CrouchPos = Vector(0, -3, 0),	
        Override_CrouchAng = Angle(0, 0, 0),
        Override_HolsterPos = Vector(2,2,2),
        Override_HolsterAng = Angle(-20, 0, -5),		
    },
    ["scope_attach"] = {
        VMBodygroups = {{ind = 1, bg = 1}},
    },
}

SWEP.Hook_SelectReloadAnimation = function(wep, anim)
    if wep.Attachments[4].Installed then
        return anim .. "_akimbo"
    end

    return anim
end

SWEP.Attachments = {
    {
        PrintName = "Optic",
        Slot = "optic",
        Bone = "frame",
        InstalledEles = {"scope_attach"},
        DefaultAttName = "DC-17 Holosight",
        Offset = {
            vpos = Vector(-2, 4.2, 0.13),
            vang = Angle(180,0,90),
        },
        VMScale = Vector(1.25, 1.25, 1.25),
    },
    {
        PrintName = "Tactical",
        Slot = {"tactical", "tac_pistol", "tac"},
        Bone = "frame",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(-6, 1, 0.15),
            vang = Angle(180,0,90),
        },
        ExtraSightDist = 9,
        CorrectivePos = Vector(1, 0, -1),
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "Standard Muzzle",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle", "b1120_muzzle"},
        VMScale = Vector(1.2, 1.2, 1.2),
        WMScale = Vector(1.2, 1.2, 1.2),
        Bone = "frame",
        Offset = {
            vpos = Vector(-7.88, 2.35, 0.11),
            vang = Angle(180,0,90),
        },
    },
    {
        PrintName = "Left Hand",
        Slot = {"gso_extra_pistol_akimbo", "mifl_fas2_akimbo", "akimbotest"},
        Bone = "Akimbo_Base",
        DefaultAttName = "None",
        Offset = {
            vpos = Vector(6, -2.8, 0.2),
            vang = Angle(0, 0, 0),
        },
        InstalledEles = {"akimbo"},
    },
    {
        PrintName = "Mode",
        DefaultAttName = "None",
        Slot = {"sw_mode", "sw_mode_pistol"},
    },   
    {
        PrintName = "Ammunition",
        DefaultAttName = "Standard",
        Slot = {"ammo", "sw_ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = "uc_fg",
    },
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = {"charm"},
        Bone = "frame",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(0.3, -1, -0.45),
            vang = Angle(180,0,90),
        },
    },     
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = {"killcounter"},
        Bone = "frame",
        VMScale = Vector(1,1,1),
        WMScale = Vector(1,1,1),
        Offset = {
            vpos = Vector(-5.5, 1.7, -0.75),
            vang = Angle(180,0,90),
        },
    },     
}


SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["draw"] = {
        Source = "draw",
    },
    ["holster"] = {
        Source = "holster",
    },
    ["ready"] = {
        Source = "draw",
    },
    ["fire"] = {
        Source = "fire1",
        ShellEjectAt = false,
    },
    ["fire_iron"] = {
        Source = "fire_scoped2",
        ShellEjectAt = false,
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        LHIK = true,
        LHIKIn = 0.4,
        LHIKOut = 0.8,
        LHIKEaseOut = 0.5,
        SoundTable = {
            {s = "arccw/kraken/republic/dc17/handling/magout.wav", t = 5 / 30},
            {s = "arccw/kraken/republic/dc17/handling/magin_partial.wav", t = 30 / 30},
            {s = "arccw/kraken/republic/dc17/handling/magin.wav", t = 40 / 30},
        },
    },
--------------------------------------------------------
    ["reload_akimbo"] = {
        Source = "reload_akimbo",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
    },
    ["reload_empty_akimbo"] = {
        Source = "reload_empty_akimbo",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
    },
    ["reload_nomen_akimbo"] = {
        Source = "reload_nomen_akimbo",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
    },
    ["reload_nomen_empty_akimbo"] = {
        Source = "reload_empty_nomen_akimbo",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
    },

    ["fix"] = {
        Source = "overheat", 
        Mult = 1.5,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 75 / 30},
            {s = "ArcCW_Kraken.Grab", t = 78 / 30},
        },
    },
}
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/weapons/arccw_k_dc17_training.lua:
return gluapack()()
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_dh17.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 2

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Galactic Expansion v2"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "DH-17"
SWEP.Trivia_Class = "Blaster Pistol"
SWEP.Trivia_Desc = "The DH-17 blaster pistol was commonly used by soldiers of the Rebel Alliance for conflicts aboard starships, and sometimes the officers of the Galactic Empire carried it instead of the standard E-11 medium blaster rifles. The DH-17 blaster rifle was a rifle version that featured a shoulder stock, and a hand-calibrated macroscopes. The rifles were black and silver in color."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/galactic/dh17.png"

-- Base
SWEP.DefaultBodygroups = "000000000000"
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/galactic/v_dh17_pistols.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"

SWEP.ViewModelFOV = 65

SWEP.WorldModelOffset = {
    pos = Vector(-18, 6.7, -5.75),
    ang = Angle(0, 0, -180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 14
SWEP.HeatDissipation = 5
SWEP.HeatLockout = true
SWEP.HeatFix = true
SWEP.HeatDelayTime = 0.5

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 27
SWEP.DamageMin = 20
SWEP.RangeMin = 0
SWEP.Range = 400
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 2000

SWEP.TracerNum = 1
SWEP.TracerCol = Color(250, 0, 0)
SWEP.TracerWidth = 1
SWEP.Tracer = "tracer_red"
SWEP.HullSize = 1

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 29

SWEP.Recoil = 0.6
SWEP.RecoilSide = 0.2
SWEP.RecoilRise = 0.2

SWEP.Delay = 60 / 340
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
    {
        Mode = -3,
        PostBurstDelay = 0.1,
        RunawayBurst = false,
        Mult_RPM = 2,
    },
	{
		Mode = 0,
   	}
}

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.AccuracyMOA = 0.5
SWEP.HipDispersion = 100
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.955
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "ArcCW_Kraken.SW_DH17"
SWEP.ShootSound = "ArcCW_Kraken.SW_DH17"
SWEP.DistantShootSound = "ArcCW_Kraken.LightCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "blaster_muzzle_red"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(250, 0, 0)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-5.04, -11.296, 1.25),
    Ang = Angle(0,0,0),
     Magnification = 1.5,
     SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
     SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
     ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "pistol"
SWEP.HoldtypeSights = "revolver"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_PISTOL

SWEP.SprintPos = Vector(2.019, -5.226, -2)
SWEP.SprintAng = Angle(0, 0, 0)

SWEP.CustomizePos = Vector(10, -10, 0)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.CrouchPos = Vector(-3, 0, 2)
SWEP.CrouchAng = Angle(0, 0, 0)

SWEP.ActivePos = Vector(-3, 0, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments
SWEP.DefaultElements = {}
SWEP.AttachmentElements = {
    ["muzzle_attach"] = {
        VMBodygroups = {{ind = 1, bg = 2}, {ind = 2, bg = 2}},
    },
}

SWEP.Attachments = {     
    {
        PrintName = "Sight", 
        DefaultAttName = "None",
        Slot = "optic",
        Bone = "DC-15SA",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(-0.01, -2.35, -5.2),
            vang = Angle(90, 0, -90),
        },
        CorrectivePos = Vector(0, 0, 0),
        CorrectiveAng = Angle(0, 0, 0),
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
        Bone = "DC-15SA",
        InstalledEles = {"muzzle_attach"},
        Offset = {
            vpos = Vector(0, -1, 2.1),
            vang = Angle(90, 0, -90),
        },
    },  
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol"},
        Bone = "DC-15SA",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(-0.3, -1.2, -1),
            vang = Angle(90, 0, 180),
        },
    },
    {
        PrintName = "Energization",
        DefaultAttName = "None",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.5, 0.5, 0.5),
        WMScale = Vector(0.5, 0.5, 0.5),
        Bone = "DC-15SA",
        Offset = {
            vpos = Vector(0.39, -0.1, -2.9),
            vang = Angle(90, 0, -90),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        VMScale = Vector(0.9, 0.9, 0.9),
        WMScale = Vector(0.9, 0.9, 0.9),
        Bone = "DC-15SA",
        Offset = {
            vpos = Vector(0.6, -0.9, -4),
            vang = Angle(90, 0, -90),
        },
    },   
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = false,
    },
    ["idle_iron"] = {
        Source = false,
    },
	["fire"] = {
        Source = {"fire"},
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 45 / 30},
            {s = "ArcCW_Kraken.Grab", t = 43 / 30},
        },
    },
    ["fix"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 45 / 30},
            {s = "ArcCW_Kraken.Grab", t = 43 / 30},
        },
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
}
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_dl18.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 2

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Galactic Expansion v2"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "DL-18"
SWEP.Trivia_Class = "Blaster Pistol"
SWEP.Trivia_Desc = "The DL-18 blaster pistol was a model of blaster pistol commonly used throughout the galaxy, particularly by bounty hunters and smugglers. The blaster, manufactured by BlasTech Industries, was inexpensive and allowed for easy customization; because of this, the blaster pistol became very popular in the Outer Rim. Former Jedi Padawan and Order 66 survivor Kanan Jarrus used a modified DL-18 with a dewback skin handle after the fall of the Jedi Order."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/galactic/dl18.png"

-- Base
SWEP.DefaultBodygroups = "000000000000"
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/galactic/v_dl18.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"

SWEP.ViewModelFOV = 65

SWEP.WorldModelOffset = {
    pos = Vector(-18, 6.7, -5.75),
    ang = Angle(0, 0, -180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1
}

-- Damage & Tracer
SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 32
SWEP.DamageMin = 17
SWEP.RangeMin = 0
SWEP.Range = 220
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 2000

SWEP.TracerNum = 1
SWEP.TracerCol = Color(250, 0, 0)
SWEP.TracerWidth = 1
SWEP.Tracer = "tracer_red"
SWEP.HullSize = 1

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 12

SWEP.Recoil = 0.4
SWEP.RecoilSide = 0.2
SWEP.RecoilRise = 0.2

SWEP.Delay = 60 / 290
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
    {
        Mode = -3,
        PostBurstDelay = 0.1,
        RunawayBurst = false,
        Mult_RPM = 2,
    },
	{
		Mode = 0,
   	}
}

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.AccuracyMOA = 0.5
SWEP.HipDispersion = 100
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.955
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "ArcCW_Kraken.SW_DL18"
SWEP.ShootSound = "ArcCW_Kraken.SW_DL18"
SWEP.DistantShootSound = "ArcCW_Kraken.LightCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "blaster_muzzle_red"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(250, 0, 0)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-5.043, -11.296, 1.7),
    Ang = Angle(0,0,0),
     Magnification = 1.5,
     SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
     SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
     ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "pistol"
SWEP.HoldtypeSights = "revolver"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_PISTOL

SWEP.SprintPos = Vector(2.019, -5.226, -2)
SWEP.SprintAng = Angle(0, 0, 0)

SWEP.CustomizePos = Vector(10, -10, 0)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.CrouchPos = Vector(-3, 0, 2)
SWEP.CrouchAng = Angle(0, 0, 0)

SWEP.ActivePos = Vector(-3, 0, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments
SWEP.DefaultElements = {}
SWEP.AttachmentElements = {}

SWEP.Attachments = {     
    {
        PrintName = "Sight", 
        DefaultAttName = "None",
        Slot = "optic",
        Bone = "DC-15SA",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(0.0, -1.75, -2.1),
            vang = Angle(90, 0, -90),
        },
        CorrectivePos = Vector(0, 0, 0),
        CorrectiveAng = Angle(0, 0, 0),
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
        Bone = "DC-15SA",
        Offset = {
            vpos = Vector(0., -1.45, 6.5),
            vang = Angle(90, 0, -90),
        },
    },  
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol"},
        Bone = "DC-15SA",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(-0.05, -1.49, 3.5),
            vang = Angle(90, 0, 180),
        },
    },
    {
        PrintName = "Energization",
        DefaultAttName = "None",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.5, 0.5, 0.5),
        WMScale = Vector(0.5, 0.5, 0.5),
        Bone = "DC-15SA",
        Offset = {
            vpos = Vector(0.4, -1.3, 0.4),
            vang = Angle(90, 0, -90),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        VMScale = Vector(0.9, 0.9, 0.9),
        WMScale = Vector(0.9, 0.9, 0.9),
        Bone = "DC-15SA",
        Offset = {
            vpos = Vector(0.6, -1.2, -6.5),
            vang = Angle(90, 0, -90),
        },
    },  
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = false,
    },
    ["idle_iron"] = {
        Source = false,
    },
	["fire"] = {
        Source = {"fire"},
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 45 / 30},
            {s = "ArcCW_Kraken.Grab", t = 43 / 30},
        },
    },
    ["fix"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 45 / 30},
            {s = "ArcCW_Kraken.Grab", t = 43 / 30},
        },
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
}
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_dl44.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 2

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Galactic Expansion v2"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "DL-44"
SWEP.Trivia_Class = "Blaster Pistol"
SWEP.Trivia_Desc = "The DL-44 heavy blaster pistol, also known more simply as a DL-44 blaster pistol, was a type of heavy blaster pistol produced by BlasTech Industries that was used during the years of the Galactic Republic and the Age of the Empire. It was considered one of the most powerful blaster pistols in the galaxy, delivering massive damage at close range; however, it overheated quickly. This pistol can also be reconfigure into a blaster rifle by including an extended barrel with the existing flash-suppressor and an attachable stock. This version was used by Tobias Beckett in the trenches of Mimban before he deconstructed his DL-44 and gave it to Han Solo, who used it for the rest of his life."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/galactic/dl44.png"

-- Base
SWEP.DefaultBodygroups = "001000000000"
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/galactic/v_dl44.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"

SWEP.ViewModelFOV = 65

SWEP.WorldModelOffset = {
    pos = Vector(-18, 6.7, -5.75),
    ang = Angle(0, 0, -180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 15
SWEP.HeatDissipation = 5
SWEP.HeatLockout = true
SWEP.HeatFix = true
SWEP.HeatDelayTime = 0.5

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 62
SWEP.DamageMin = 45
SWEP.RangeMin = 0
SWEP.Range = 250
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 2000

SWEP.TracerNum = 1
SWEP.TracerCol = Color(250, 0, 0)
SWEP.TracerWidth = 1
SWEP.Tracer = "tracer_red"
SWEP.HullSize = 1

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 20

SWEP.Recoil = 1
SWEP.RecoilSide = 0.4
SWEP.RecoilRise = 0.6

SWEP.Delay = 60 / 260
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
	{
		Mode = 0,
   	}
}

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.AccuracyMOA = 0.5
SWEP.HipDispersion = 100
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.955
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "ArcCW_Kraken.SW_DH17"
SWEP.ShootSound = "ArcCW_Kraken.SW_DH17"
SWEP.DistantShootSound = "ArcCW_Kraken.HeavyCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "blaster_muzzle_red"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(250, 0, 0)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-5.04, -11.296, 0.5),
    Ang = Angle(0,0,0),
     Magnification = 1.5,
     SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
     SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
     ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "pistol"
SWEP.HoldtypeSights = "revolver"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_PISTOL

SWEP.SprintPos = Vector(2.019, -5.226, -2)
SWEP.SprintAng = Angle(0, 0, 0)

SWEP.CustomizePos = Vector(10, -10, 0)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.CrouchPos = Vector(-3, 0, 2)
SWEP.CrouchAng = Angle(0, 0, 0)

SWEP.ActivePos = Vector(-3, 0, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments
SWEP.DefaultElements = {}
SWEP.AttachmentElements = {}

SWEP.Attachments = {     
    {
        PrintName = "Sight", 
        DefaultAttName = "None",
        Slot = "optic",
        Bone = "DC-15SA",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(-0.05, -2.8, -3.3),
            vang = Angle(90, 0, -90),
        },
        CorrectivePos = Vector(0, 0, 0),
        CorrectiveAng = Angle(0, 0, 0),
    },
    {
        PrintName = "Internal Compression",
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
    },  
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol"},
        Bone = "DC-15SA",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(-0.7, -1.2, -1),
            vang = Angle(90, 0, 180),
        },
    },
    {
        PrintName = "Energization",
        DefaultAttName = "None",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.5, 0.5, 0.5),
        WMScale = Vector(0.5, 0.5, 0.5),
        Bone = "DC-15SA",
        Offset = {
            vpos = Vector(0.4, -0.5, -0.6),
            vang = Angle(90, 0, -90),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        VMScale = Vector(0.9, 0.9, 0.9),
        WMScale = Vector(0.9, 0.9, 0.9),
        Bone = "DC-15SA",
        Offset = {
            vpos = Vector(0.4, -0.9, -2.5),
            vang = Angle(90, 0, -90),
        },
    },   
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = false,
    },
    ["idle_iron"] = {
        Source = false,
    },
	["fire"] = {
        Source = {"fire"},
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 45 / 30},
            {s = "ArcCW_Kraken.Grab", t = 43 / 30},
        },
    },
    ["fix"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 45 / 30},
            {s = "ArcCW_Kraken.Grab", t = 43 / 30},
        },
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
}
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_dlt20s.lua:
return gluapack()()
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_dlt20s.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 4 

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Galactic Expansion v2"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "DLT-20s"
SWEP.Trivia_Class = "Blaster Rifle"
SWEP.Trivia_Desc = "The DLT-20A blaster rifle, also known as the DLT-20A laser rifle, was a model of blaster rifle and longblaster produced by BlasTech Industries. Members of the Galactic Empire's Stormtrooper Corps sometimes used DLT-20As instead of their standard issue E-11 medium blaster rifles. IG-assassin droid IG-11 carried this model of rifle, without the scope attached. Another type of rifle, the pulse cannon, utilized the frame assembly of a DLT-20A. Han Solo used a DLT-20A as a sniper rifle during the Battle of Vrogas Vas."
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.IconOverride = "entities/kraken/galactic/dlt20s.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "00100000000000"

SWEP.UseHands = true
SWEP.MirrorVMWM = true
SWEP.ViewModel = "models/arccw/kraken/galactic/v_dlt20a.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"

SWEP.ViewModelFOV = 70

SWEP.WorldModelOffset = {
    pos = Vector(-7, 3, -3),
    ang = Angle(-15, 0, 180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1,
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 15
SWEP.HeatDissipation = 7
SWEP.HeatLockout = true
SWEP.HeatFix = true
SWEP.HeatDelayTime = 0.5

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2.5,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 45
SWEP.DamageMin = 28
SWEP.RangeMin = 0
SWEP.Range = 650
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 9000

SWEP.TracerNum = 1
SWEP.TracerCol = Color(0, 250, 0)
SWEP.TracerWidth = 1
SWEP.Tracer = "tracer_green"
SWEP.HullSize = 1

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 25

SWEP.Recoil = 0.8
SWEP.RecoilSide = 0.35
SWEP.RecoilRise = 0.75

SWEP.Delay = 60 / 300
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
    {
        Mode = -3,
        Mult_RPM = 3,
        PostBurstDelay = 0.1,
    },
	{
		Mode = 0,
   	}
}

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.AccuracyMOA = 0
SWEP.HipDispersion = 150
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.955
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0

SWEP.FirstShootSound = "ArcCW_Kraken.SW_DLT20"
SWEP.ShootSound = "ArcCW_Kraken.SW_DLT20"
SWEP.DistantShootSound = "ArcCW_Kraken.HeavyCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "blaster_muzzle_green"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(0, 250, 0)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-2.994, 0, 0.004),
    Ang = Vector(2.042, 0, 0),
    Magnification = 1.15,
    SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
    SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
    ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(-1, 2, -1)
SWEP.ActiveAng = Angle(2, 0, -2)

SWEP.SprintPos = Vector(4.019, -5.226, -3)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CustomizePos = Vector(10, 0, 0)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.HolsterPos = Vector(0, 0, 0)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.InBipodPos = Vector(-8, 0, -4)
SWEP.InBipodMult = Vector(2, 0, 1)

-- Attachments
SWEP.DefaultElements = {"muzzle"}
SWEP.AttachmentElements = {
    ["muzzle"] = {
        VMElements = {
           {
               Model = "models/hunter/plates/plate.mdl",
               Bone = "E11S_CONTR",
               Scale = Vector(0, 0, 0),                
               Offset = {
                   pos = Vector(-2.4, 24, 2),
                   ang = Angle(-90, -90, 0),
               },
               IsMuzzleDevice = true,
           }
        }, 
    },
}

SWEP.Attachments = {     
    {
        PrintName = "Optics", 
        DefaultAttName = "Iron Sight",
        Slot = "optic",
        Bone = "E11S_CONTR",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(0.1, 1, 2.4),
            vang = Angle(0, -90, 0),
        },
        CorrectiveAng = Angle(0, 180, 0),
        CorrectivePos = Vector(0, 0, -0.05),
    },
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(-0.8, 8.5, 0.9),
            vang = Angle(-90, -90, 0),
        },
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "Standard",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
        VMScale = Vector(1.5, 1.5, 1.5),
        WMScale = Vector(1.5, 1.5, 1.5),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(-0.1, 25.3, 0.9),
            vang = Angle(0, -90, 0),
        },
    },  
    {
        PrintName = "Foregrip", 
        DefaultAttName = "None",
        Slot = "foregrip",
        Bone = "E11S_CONTR",
        VMScale = Vector(0.9, 0.9, 0.9),
        WMScale = Vector(0.9, 0.9, 0.9),
        Offset = {
            vpos = Vector(0., 6, 0.2),
            vang = Angle(5, -90, 0),
        },
    },
    {
        PrintName = "Energization",
        DefaultAttName = "None",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(0.8, -0.2, -0.8),
            vang = Angle(0, -90, 0),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        VMScale = Vector(0.8, 0.8, 0.8),
        WMScale = Vector(0.8, 0.8, 0.8),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(0.9, -0.33, 0.2),
            vang = Angle(0, -90, 0),
        },
    },   
}
-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
	["fire"] = {
        Source = false,
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 45 / 30},
            {s = "ArcCW_Kraken.Grab", t = 43 / 30},
        },
    },
    ["fix"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 45 / 30},
            {s = "ArcCW_Kraken.Grab", t = 43 / 30},
        },
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
}
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/weapons/arccw_k_e5bx.lua:
return gluapack()()
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/weapons/arccw_k_e5s.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3 -- Change this if you want to select the weapon with other number

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Confederacy Arsenal"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "E-5s"
SWEP.Trivia_Class = "Blaster, Longblaster"
SWEP.Trivia_Desc = "E-5s sniper rifles were a model of sniper rifle and longblaster used by sharpshooters of the Confederacy of Independent Systems and the Galactic Empire. They saw action under the Separatist Droid Army during the Clone Wars on the planet Felucia. To target opponents attempting to take cover, a B1-series battle droid took up position and used the rifle from a distance. A tubular device was used to connected the rifle's targeting scope to a battle droid's photoreceptors, which saw through red electrobinoculars."
SWEP.Trivia_Manufacturer = "Baktoid Armor Workshop"
SWEP.Trivia_Calibre = "Condensed Tibanna-Gas"
SWEP.Trivia_Country = "Confederacy of Independent Systems"
SWEP.IconOverride = "entities/arccw/kraken/republic-arsenal/e5s.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "0000000000000"

SWEP.MirrorVMWM = true
SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/kraken/cis/v_e5s.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_dlt19.mdl"

SWEP.MirrorWorldModel = nil
SWEP.ViewModelFOV = 60


SWEP.WorldModelOffset = {
    pos = Vector(-9, 4, -3),
    ang = Angle(-15, 0, 180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1.2,
}

-- Damage & Tracer
SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2.5,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 143
SWEP.DamageMin = 98
SWEP.RangeMin = 0
SWEP.Range = 700
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 9000

SWEP.TraceNum = 1
SWEP.Tracer = "tracer_red"
SWEP.TracerCol = Color(250, 0, 0)

SWEP.HullSize = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 10

SWEP.Recoil = 1.8
SWEP.RecoilSide = 1.5
SWEP.RecoilRise = 2
SWEP.MaxRecoilBlowback = 2
SWEP.RecoilPunch = 1.5
SWEP.RecoilVMShake = 2

SWEP.Delay = 60 / 120
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
	{
		Mode = 0,
   	}
}

SWEP.AccuracyMOA = 5
SWEP.HipDispersion = 200
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.95
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.30

-- Ammo, Sounds & MuzzleEffect
local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0

SWEP.FirstShootSound = "ArcCW_Kraken.SW_E5S"
SWEP.ShootSound = "ArcCW_Kraken.SW_E5S"
SWEP.DistantShootSound = "ArcCW_Kraken.HeavyCorebass"
SWEP.ShootSoundSilenced = "armas/disparos/dc19.wav"

SWEP.MuzzleEffect = "blaster_muzzle_red"
SWEP.MuzzleFlashColor = Color(250, 0, 0)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-3.721, -9.875, 0.55),
    Ang = Vector(0, 0.192, -0.21),
     Magnification = 2,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(-2, -1, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(0, 0, 0)
SWEP.SprintAng = Angle(0, 0, 0)

SWEP.CustomizePos = Vector(15, -5, 5)
SWEP.CustomizeAng = Angle(0, 40, 30)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Angle(0, 30, -15)

-- Attachments
SWEP.DefaultElements = {}
SWEP.AttachmentElements = {
    ["scope_attach"] = {
        VMBodygroups = {{ind = 1, bg = 1}},
    },
}

SWEP.Attachments = {
    {
        PrintName = "Optic",
        DefaultAttName = "E-5 Holosight",
        Slot = "optic", 
        Bone = "v_weapon.awp_parent",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(0.15, -4.7, 6.9),
            vang = Angle(90, 0, -90),
        },
        CorrectiveAng = Angle(0, 0, 0),
        CorrectivePos = Vector(0, 0, 0),
    },          
    {
        PrintName = "Internal Compression",
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle", "b1120_muzzle"},
    },  
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Bone = "v_weapon.awp_parent", 
        Offset = {
            vpos = Vector(0.15, -2.7, 30),
            vang = Angle(90, 0, -90),
        },
    },    
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = "uc_fg",
    },  
    {
        PrintName = "Mode",
        DefaultAttName = "None",
        Slot = {"sw_mode", "sw_mode_sniper"},
    },    
    {
        PrintName = "Ammunition", 
        DefaultAttName = "Standard",
        Slot = "ammo",
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Charms",
        DefaultAttName = "None",
        Slot = {"charm"},
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Bone = "v_weapon.awp_parent",
        Offset = {
            vpos = Vector(0.65, -2, 2),
            vang = Angle(90, 0, -90),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = {"killcounter"},
        Bone = "v_weapon.awp_parent",
        VMScale = Vector(0.9, 0.9, 0.9),
        WMScale = Vector(0.9, 0.9, 0.9),
        Offset = {
            vpos = Vector(0.7, -2, 7),
            vang = Angle(90, 0, -90),
        },
    },         
}

-- Don't touch this unless you know what you're doing
local path = "arccw/kraken/republic/e5s/handling/"

SWEP.Animations = {
    ["fire"] = {
        Source = {"shoot1"},
        IKTimeLine = {{t = 0, lhik = 1, rhik = 1}},
    },
    ["fire_sights"] = {
        Source = {"shoot1_ads"},
        IKTimeLine = {{t = 0, lhik = 1, rhik = 1}},
    },
    ["reload"] = {
        Source = "reload_short2",
		MinProgress = 0.65,
        LHIK = true,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = path .. "clipout.ogg", t = 7/30},
            {s = path .. "clipin.ogg", t = 40/30},
            {s = path .. "cliphit.ogg", t = 45/30},
        },
    },
    ["draw"] = {
        Source = "draw_short",
    },
    ["holster"] = {
        Source = "holster",
        IKTimeLine = {{t = 0, lhik = 1, rhik = 1}},
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_rifle.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["idle"] = {
        Source = "idle",
    },
    ["enter_sights"] = {
        Source = "idle",
        IKTimeLine = {{t = 0, lhik = 1, rhik = 1}},
    },
    ["idle_sprint"] = {
        Source = "sprint",
    },
    ["exit_sprint"] = {
        Source = "sprint_out",
        Time = 1,
    },
    ["enter_sprint"] = {
        Source = "sprint_in",
        IKTimeLine = {{t = 0, lhik = 1, rhik = 1}},
        Time = 1,
    },
    ["exit_inspect"] = {
        Source = "lookat01",
        MinProgress = 0.9,
        FireASAP = true,
        IKTimeLine = {{t = 0, lhik = 1, rhik = 1}},
        SoundTable = {
            {s = "arccw/kraken/republic/movement1.wav", t = 5/30},
            {s = "arccw/kraken/republic/movement2.wav", t = 91/30},
            {s = "arccw/kraken/republic/movement3.wav", t = 116/30},
        },
    },
    ["bash"] = {
        Source = {"melee", "melee2", "melee3"},
        IKTimeLine = {{t = 0, lhik = 1, rhik = 1}},
    },
}
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_ee3e.lua:
return gluapack()()
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_ee3k.lua:
return gluapack()()
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_el16.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3 

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Galactic Expansion v2"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "EL-16"
SWEP.Trivia_Class = "Blaster Carabine"
SWEP.Trivia_Desc = "The EL-16 blaster rifle was a blaster rifle manufactured by BlasTech Industries. A Heavy Field Edition of the EL-16, the EL-16HFE blaster rifle, was also used by the Resistance. The EL-16 was outdated by the time of the First Order's rise to power. One was given to Finn by Han Solo, but he lost it when Maz's castle was destroyed. He got a new one of the same model at the Resistance base on D'Qar. Both it and the EL-16HFE were utilized during the Battle of Crait."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/galactic/el16c.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "00100000000000"

SWEP.UseHands = true
SWEP.MirrorVMWM = true
SWEP.ViewModel = "models/arccw/kraken/galactic/v_el16.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"

SWEP.ViewModelFOV = 70

SWEP.WorldModelOffset = {
    pos = Vector(-7, 3, -3),
    ang = Angle(-15, 0, 180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1,
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 20
SWEP.HeatDissipation = 7
SWEP.HeatLockout = true
SWEP.HeatFix = true
SWEP.HeatDelayTime = 0.5

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2.5,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 36
SWEP.DamageMin = 24
SWEP.RangeMin = 0
SWEP.Range = 430
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 9000

SWEP.TracerNum = 1
SWEP.TracerCol = Color(0, 0, 250)
SWEP.TracerWidth = 1
SWEP.Tracer = "tracer_blue"
SWEP.HullSize = 1

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 36

SWEP.Recoil = 0.75
SWEP.RecoilSide = 0.40
SWEP.RecoilRise = 0.63

SWEP.Delay = 60 / 320
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
    {
		Mode = 2,
    },
    {
        Mode = -3,
        Mult_RPM = 3,
        PostBurstDelay = 0.1,
    },
	{
		Mode = 0,
   	}
}

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.AccuracyMOA = 0
SWEP.HipDispersion = 100
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.955
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 90
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "ArcCW_Kraken.SW_EL16"
SWEP.ShootSound = "ArcCW_Kraken.SW_EL16"
SWEP.DistantShootSound = "ArcCW_Kraken.StandardCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "blaster_muzzle_blue"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(0, 0, 250)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-3.027, -2, -1.03),
    Ang = Vector(2.8, 0, -0.5),
    Magnification = 1.15,
    SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
    SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
    ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"
SWEP.HoltypeCustomize = "slam"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, 0, -2)
SWEP.ActiveAng = Angle(2, 0, 0)

SWEP.SprintPos = Vector(4.019, -5.226, -0.805)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CustomizePos = Vector(10, 0, 0)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.InBipodPos = Vector(-8, 0, -4)
SWEP.InBipodMult = Vector(2, 0, 1)

-- Attachments
SWEP.DefaultElements = {"muzzle"}
SWEP.AttachmentElements = {
    ["muzzle"] = {
        VMElements = {
           {
               Model = "models/hunter/plates/plate.mdl",
               Bone = "E11S_CONTR",
               Scale = Vector(0, 0, 0),                
               Offset = {
                   pos = Vector(-2.4, 16, -2),
                   ang = Angle(-90, -90, 0),
               },
               IsMuzzleDevice = true,
           }
        }, 
    },
    ["muzzle_attach"] = {
        VMBodygroups = {{ind = 1, bg = 3}},
    },
}

SWEP.Attachments = {     
    {
        PrintName = "Optics", 
        DefaultAttName = "Iron Sight",
        Slot = "optic",
        Bone = "E11S_CONTR",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(0.1, 0, 3.7),
            vang = Angle(0, -90, 0),
        },
        CorrectiveAng = Angle(0, 180, 0),
        CorrectivePos = Vector(0, 0, -0.01),
    },
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(-0.8, 8.5, 0.5),
            vang = Angle(-90, -90, 0),
        },
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "Standard",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
        VMScale = Vector(1.5, 1.5, 1.5),
        WMScale = Vector(1.5, 1.5, 1.5),
        InstalledEles = {"muzzle_attach"},
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(-0, 10.9, 1.2),
            vang = Angle(0, -90, 0),
        },
    },  
    {
        PrintName = "Energization",
        DefaultAttName = "None",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(1.3, -6, 0.5),
            vang = Angle(0, -90, 0),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        VMScale = Vector(0.8, 0.8, 0.8),
        WMScale = Vector(0.8, 0.8, 0.8),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(1.3, -2, 0.4),
            vang = Angle(0, -90, 0),
        },
    },   
}
-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
	["fire"] = {
        Source = false,
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 45 / 30},
            {s = "ArcCW_Kraken.Grab", t = 43 / 30},
        },
    },
    ["fix"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 45 / 30},
            {s = "ArcCW_Kraken.Grab", t = 43 / 30},
        },
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
}
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_f11d.lua:
return gluapack()()
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_glie44.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 2

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Galactic Expansion v2"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "GLIE-44"
SWEP.Trivia_Class = "Blaster Pistol"
SWEP.Trivia_Desc = "The Glie-44 blaster pistol was a blaster pistol manufactured by Eirriss Ryloth Defense Tech and named after Twi'lek freedom fighter Gobi Glie. The blaster had a lightweight, rugged construction. The pistol had a power cartridge as ammunition and a reactant gas port cap in its stock. General Leia Organa also uses the Glie-44 as she prefers compact hand weapons."
SWEP.Trivia_Manufacturer = "Eirriss Ryloth Defense Tech"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/galactic/glie44.png"

-- Base
SWEP.DefaultBodygroups = "010000000000"
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/galactic/v_glie44.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"

SWEP.ViewModelFOV = 65

SWEP.WorldModelOffset = {
    pos = Vector(-18, 6.7, -5.75),
    ang = Angle(0, 0, -180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 10
SWEP.HeatDissipation = 5
SWEP.HeatLockout = true
SWEP.HeatFix = true
SWEP.HeatDelayTime = 0.5

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 28
SWEP.DamageMin = 22
SWEP.RangeMin = 0
SWEP.Range = 270
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 2000

SWEP.TracerNum = 1
SWEP.TracerCol = Color(0, 0, 250)
SWEP.TracerWidth = 1
SWEP.Tracer = "tracer_blue"
SWEP.HullSize = 1

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 19

SWEP.Recoil = 0.7
SWEP.RecoilSide = 0.6
SWEP.RecoilRise = 0.9

SWEP.Delay = 60 / 280
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
    {
        Mode = -3,
        PostBurstDelay = 0.1,
        RunawayBurst = false,
        Mult_RPM = 2,
    },
	{
		Mode = 0,
   	}
}

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.AccuracyMOA = 0.5
SWEP.HipDispersion = 100
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.955
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "ArcCW_Kraken.SW_GLIE44"
SWEP.ShootSound = "ArcCW_Kraken.SW_GLIE44"
SWEP.DistantShootSound = "ArcCW_Kraken.StandardCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "blaster_muzzle_blue"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(0, 0, 250)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-5.025, -11.296, 1.3),
    Ang = Angle(0.5,0,0),
     Magnification = 1.5,
     SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
     SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
     ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "pistol"
SWEP.HoldtypeSights = "revolver"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_PISTOL

SWEP.SprintPos = Vector(2.019, -5.226, -2)
SWEP.SprintAng = Angle(0, 0, 0)

SWEP.CustomizePos = Vector(10, -10, 0)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.CrouchPos = Vector(-3, 0, 2)
SWEP.CrouchAng = Angle(0, 0, 0)

SWEP.ActivePos = Vector(-3, 0, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments
SWEP.DefaultElements = {}
SWEP.AttachmentElements = {}
SWEP.Attachments = {     
    {
        PrintName = "Sight", 
        DefaultAttName = "None",
        Slot = "optic",
        Bone = "DC-15SA",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(-0.01, -2.1, -3),
            vang = Angle(90, 0, -90),
        },
        CorrectivePos = Vector(0, 0, 0),
        CorrectiveAng = Angle(0, 0, 0),
    },
    {
        PrintName = "Internal Compression",
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
    },  
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol"},
        Bone = "DC-15SA",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(-0.7, -1.25, 1.3),
            vang = Angle(90, 0, 180),
        },
    },
    {
        PrintName = "Energization",
        DefaultAttName = "None",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.5, 0.5, 0.5),
        WMScale = Vector(0.5, 0.5, 0.5),
        Bone = "DC-15SA",
        Offset = {
            vpos = Vector(0.8, -1.2, -2),
            vang = Angle(90, 0, -90),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        VMScale = Vector(0.8, 0.8, 0.8),
        WMScale = Vector(0.8, 0.8, 0.8),
        Bone = "DC-15SA",
        Offset = {
            vpos = Vector(0.79, -1.3, -4),
            vang = Angle(90, 0, -90),
        },
    },   
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = false,
    },
    ["idle_iron"] = {
        Source = false,
    },
	["fire"] = {
        Source = {"fire"},
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["fix"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatFix", t = 45 / 30},
            {s = "ArcCW_Kraken.Grab", t = 43 / 30},
        },
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 45 / 30},
            {s = "ArcCW_Kraken.Grab", t = 43 / 30},
        },
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
}
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_glie44_e.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arccw_k_launcher_e60r.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true

SWEP.Slot = 3

SWEP.Category = "[ArcCW] Kraken's Explosives - Rocket Launchers"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "E-60r"
SWEP.Trivia_Class = "Rocket Launcher"
SWEP.Trivia_Desc = "The E-60R was a model of missile launcher utilized by B1-series battle droids of the Confederacy of Independent Systems. They could be used to pierce armor, even when fired at long-range"
SWEP.Trivia_Manufacturer = "Baktoid Armor Workshop"
SWEP.Trivia_Calibre = "Rocket"
SWEP.IconOverride = "entities/kraken/explosives/e60r.png"

-- Base
SWEP.DefaultBodygroups = "0000000000000000000"
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/sw/explosives/v_e60r.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"

SWEP.ViewModelFOV = 60

SWEP.WorldModelOffset = {
    pos = Vector(-6.5, 7, -4),
    ang = Angle(-15, 0, 180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.9
}

-- Damage & Tracer
SWEP.ShootEntity = "rocket_e60r"
SWEP.MuzzleVelocity = 6000

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 1

SWEP.Recoil = 4.3
SWEP.RecoilSide = 0.550
SWEP.RecoilRise = 2
SWEP.RecoilPunch = 2.5
SWEP.RecoilVMShake = 1.5
SWEP.VisualRecoilMult = 0.7

SWEP.Delay = 60 / 60
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
}

SWEP.AccuracyMOA = 0
SWEP.HipDispersion = 200
SWEP.MoveDispersion = 100
SWEP.JumpDispersion = 500

-- Speed Mult
SWEP.SpeedMult = 0.725
SWEP.SightedSpeedMult = 0.70
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.70

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "RPG_Round"
SWEP.ShootVol = 120
SWEP.ShootPitch = 95
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "kraken/launchers/rps/weap_rpapa7_fire_plr_01.ogg"
SWEP.ShootSound = "kraken/launchers/rps/weap_rpapa7_fire_plr_01.ogg"
SWEP.DistantShootSound = "ArcCW_Kraken.HeavyCorebass_ROCKET"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "muzzleflash_m79"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(250, 137, 0)

-- Ironsight
SWEP.IronSightStruct = false 

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "rpg"
SWEP.HoldtypeSights = "rpg"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_SHOTGUN

SWEP.ActivePos = Vector(0, 4, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(1, 0, -2.5)
SWEP.SprintAng = Angle(0, -2, 0)

SWEP.CrouchPos = Vector(-2, -3, -1)
SWEP.CrouchAng = Angle(0, 0, -10)

SWEP.HolsterPos = Vector(0, -10, -15)
SWEP.HolsterAng = Angle(50, 0, 0)

SWEP.BarrelOffsetSighted = Vector(0, 0, -1)
SWEP.BarrelOffsetHip = Vector(12, 40, -5)

SWEP.CustomizePos = Vector(10, 0, 0)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

-- Attachments
SWEP.Attachments = {
    {
        PrintName = "Ammunition",
        DefaultAttName = "Rocket",
        Slot = {"k_rocket_ammo"}
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Bone = "root",
        Offset = {
            vpos = Vector(0.6, 6, .8),
            vang = Angle(90, -90, -90),
        },
    }, 
}


-- Animations!
local path = "kraken/launchers/rps/"

SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["idle_empty"] = {
        Source = "idleempty",
    },
    ["draw"] = {
        Source = "draw",
    },
    ["draw_empty"] = {
        Source = "drawempty",
    },
    ["fire"] = {
        Source = "fire1",
    },
    ["fire_iron"] = {
        Source = "fire1",
    },
    ["enter_sights"] = {
        Source = "idle",
        Time = 0,
    },
    ["idle_sights"] = {
        Source = "idle",
        Time = 0,
    },
    ["exit_sights"] = {
        Source = "idle",
        Time = 0,
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {
                s = "kraken/explosives/grenade_launcher_drum_load.wav",
                t = 1
                },
            {
                s = "kraken/explosives/rocket_reload.wav",
                t = 1.5
                },
            {
                s = "kraken/explosives/bulletchain.wav",
                t = 2.2
                },
        },
    },
}
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_md12.lua:
return gluapack()()
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_s5e.lua:
return gluapack()()
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/weapons/arccw_k_westarm5.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3 -- Change this if you want to select the weapon with other number

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Republic Arsenal"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "WESTAR M5"
SWEP.Trivia_Class = "Blaster, Rifle"
SWEP.Trivia_Desc = "The WESTAR-M5 blaster rifle was a blaster rifle used during the Clone Wars by the Grand Army of the Republic. This blaster improved on the DC-15 design, making it easier to aim. It featured an extendable stock and a larger ammunition magazine."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Laser Bolt"
SWEP.Trivia_Mechanism = "Condensed Tibanna-Gas"
SWEP.Trivia_Country = "Galactic Republic"
SWEP.IconOverride = "entities/arccw/kraken/republic-arsenal/westarm5.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "00001000000000"

SWEP.MirrorVMWM = true
SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/kraken/republic/v_westar.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_dlt19.mdl"

SWEP.MirrorWorldModel = nil
SWEP.ViewModelFOV = 60


SWEP.WorldModelOffset = {
    pos = Vector(-10, 3.5, -3.4),
    ang = Angle(-15, 0, 180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1.7,
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 25
SWEP.HeatDissipation = 5
SWEP.HeatLockout = true
SWEP.HeatDelayTime = 0.2
SWEP.HeatFix = true

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2.5,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 47
SWEP.DamageMin = 27
SWEP.RangeMin = 0
SWEP.Range = 360
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 9000

SWEP.TraceNum = 1
SWEP.Tracer = "tracer_blue"
SWEP.TracerCol = Color(0, 0, 250)

SWEP.HullSize = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 75

SWEP.Recoil = 0.2
SWEP.RecoilSide = 0.3
SWEP.RecoilRise = 0.6

SWEP.Delay = 60 / 300
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
    {
		Mode = 2,
    },
	{
		Mode = 0,
   	}
}

SWEP.AccuracyMOA = 5
SWEP.HipDispersion = 200
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.95
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.30

-- Ammo, Sounds & MuzzleEffect
local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0

SWEP.FirstShootSound = "ArcCW_Kraken.SW_WESTAR"
SWEP.ShootSound = "ArcCW_Kraken.SW_WESTAR"
SWEP.DistantShootSound = "ArcCW_Kraken.StandardCorebass"
SWEP.ShootSoundSilenced = "armas/disparos/dc19.wav"

SWEP.MuzzleEffect = "blaster_muzzle_blue"
SWEP.MuzzleFlashColor = Color(0, 0, 255)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-3.142, -3.314, 2.642),
    Ang = Vector(0, 0, 0),
     Magnification = 1.5,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(-1, -1, 3)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(4, -3, 1)
SWEP.SprintAng = Angle(0, 30, -15)

SWEP.CustomizePos = Vector(8, -5, 6)
SWEP.CustomizeAng = Angle(0, 40, 30)

SWEP.HolsterPos = Vector(2, -3, 2)
SWEP.HolsterAng = Angle(0, 30, -15)

SWEP.DefaultElements = {}
SWEP.AttachmentElements = {
    ["scope_attach"] = {
        VMBodygroups = {{ind = 2, bg = 1}, {ind = 1, bg = 1}, {ind = 3, bg = 1}},
    },
}

SWEP.Attachments = {
	{
		PrintName = "Sight",
		DefaultAttName = "WESTAR M-5 Holosight",
		Slot = "optic",
        InstalledEles = {"scope_attach"},
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
		Bone = "weapon",
		Offset = {
            vpos = Vector(-0.03, -1.5, 2.25),
            vang = Angle(90, 0, -90),
        },
	},
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol"},
		Bone = "weapon",
        VMScale = Vector(0.5, 0.5, 0.5),
        WMScale = Vector(0.5, 0.5, 0.5),
        Offset = {
            vpos = Vector(-0.7, -0.75, 4.7),
            vang = Angle(90, 0, -180),
        },
    },
    {
        PrintName = "Mode",
        DefaultAttName = "None",
        Slot = {"sw_mode", "sw_mode_rifle"},
    },   
    {
        PrintName = "Internal Compression",
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle", "b1120_muzzle"},
    },  
    {
        PrintName = "Energization", 
        DefaultAttName = "Standard",
        Slot = {"ammo", "special_ammo"}
    },
    {
        PrintName = "Perk", 
        DefaultAttName = "None",
        Slot = "perk",
    },  
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = "uc_fg",
    },
    {
        PrintName = "Charms", 
        DefaultAttName = "None",
        Slot = {"charm"},
		Bone = "weapon",
        VMScale = Vector(0.6, 0.6, 0.6),
        WMScale = Vector(0.6, 0.6, 0.6),
        Offset = {
            vpos = Vector(0.75, -1.05, -0.55),
            vang = Angle(90, 0, -90),
        },
    },
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = {"killcounter"},
        Bone = "weapon",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(0.5, 0.07, -1.3),
            vang = Angle(90, 0, -90),
        },
    },                         
}

-- Animations
SWEP.Animations = {
    ["idle"] = {
        Source = false,
    },
	["fire"] = {
        Source = "fire",
    },
    ["fire_iron"] = {
        Source = false,
    },
	["idle_sights"] = {
        Source = false,
    },
	["reload"] = {
        Source = "reload_empty",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
		SoundTable = {
	        {s = "weapon_hand/reload_heavy/mag_eject/023d-000005b2.mp3", t = 0.1 },
            {s = "weapon_hand/reload_heavy/mag_load/023d-0000054d.mp3", t = 1 }
        },
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_rifle.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_rifle.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["fix"] = {
        Source = "overheat", 
        Mult = 1.5,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 55 / 30},
            {s = "ArcCW_Kraken.Grab", t = 53 / 30},
        },
    },
}
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_masita_base.lua:
SWEP.Base = "arccw_base"
SWEP.Spawnable = false -- this obviously has to be set to true

// names and stuff
SWEP.PrintName = "Masita ArcCW Weapon Base"
SWEP.Category = "[MASITA] ArcCW Weapon Base"

SWEP.Description = ""

SWEP.ViewModel = ""
SWEP.WorldModel = ""

SWEP.ViewModelFOV = 56
SWEP.MirrorVMWM = nil --Copy the viewmodel, along with all its attachments, to the worldmodel. Super convenient!
SWEP.MirrorWorldModel = nil -- Use this to set the mirrored viewmodel to a different model, without any floating speedloaders or cartridges you may have. Needs MirrorVMWM

--[[SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1
}]]

SWEP.PresetBase = nil -- make this weapon share saves with this one.

SWEP.KillIconAlias = nil -- set to other weapon class to share select and kill icons

SWEP.DefaultBodygroups = "00000000"
SWEP.DefaultWMBodygroups = "00000000"
SWEP.DefaultSkin = 0
SWEP.DefaultWMSkin = 0

SWEP.WorldModelOffset = nil
-- {
--     pos = Vector(0, 0, 0),
--     ang = Angle(0, 0, 0)
-- }

SWEP.NoHideLeftHandInCustomization = false

SWEP.Damage = 26
SWEP.DamageMin = 10 -- damage done at maximum range
SWEP.DamageRand = 0 -- damage will vary randomly each shot by this fraction
SWEP.RangeMin = 0 -- how far bullets will retain their maximum damage for
SWEP.Range = 200 -- in METRES
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.DamageTypeHandled = false -- set to true to have the base not do anything with damage types
-- this includes: igniting if type has DMG_BURN; adding DMG_AIRBOAT when hitting helicopter; adding DMG_BULLET to DMG_BUCKSHOT

SWEP.ShootEntity = nil -- entity to fire, if any
SWEP.MuzzleVelocity = 400 -- projectile muzzle velocity in m/s
SWEP.PhysBulletMuzzleVelocity = nil -- override phys bullet muzzle velocity
SWEP.PhysBulletDrag = 1
SWEP.PhysBulletGravity = 1
SWEP.PhysBulletDontInheritPlayerVelocity = true

SWEP.BodyDamageMults = nil
-- if a limb is not set the damage multiplier will default to 1
-- that means gmod's stupid default limb mults will **NOT** apply
-- {
--     [HITGROUP_HEAD] = 1.25,
--     [HITGROUP_CHEST] = 1,
--     [HITGROUP_LEFTARM] = 0.9,
--     [HITGROUP_RIGHTARM] = 0.9,
-- }

SWEP.AlwaysPhysBullet = false
SWEP.NeverPhysBullet = false
SWEP.PhysTracerProfile = 0 -- color for phys tracer.
-- there are 8 options:
-- 0 = normal
-- 1 = red
-- 2 = green
-- 3 = blue
-- 4 = yellow
-- 5 = violet
-- 6 = cyan
-- 7 = black/invisible
SWEP.HullSize = 1.5 -- HullSize used by FireBullets

function SWEP:DoImpactEffect(tr, dmgtype)
    if tr.HitSky then return true end

    util.Decal("fadingscorch", tr.HitPos + tr.HitNormal, tr.HitPos - tr.HitNormal);
    if( game.SinglePlayer() or SERVER or not self:IsCarriedByLocalPlayer() or IsFirstTimePredicted() ) then
        local soundToPlay = "impacts/sw752_hit_1.wav"
        local randomSound = math.random(1,14)
        if randomSound == 1 then
            soundToPlay = "impacts/sw752_hit_4.wav"
        elseif randomSound == 2 then
            soundToPlay = "impacts/sw752_hit_5.wav"
        elseif randomSound == 3 then
            soundToPlay = "impacts/sw752_hit_9.wav"
        elseif randomSound == 4 then
            soundToPlay = "impacts/sw752_hit_10.wav"
        elseif randomSound == 5 then
            soundToPlay = "impacts/sw752_hit_12.wav"
        elseif randomSound == 6 then
            soundToPlay = "impacts/sw752_hit_13.wav"
        elseif randomSound == 7 then
            soundToPlay = "impacts/sw752_hit_14.wav"
        elseif randomSound == 8 then
            soundToPlay = "impacts/sw752_hit_19.wav"
        elseif randomSound == 9 then
            soundToPlay = "impacts/sw752_hit_27.wav"
        elseif randomSound == 10 then
            soundToPlay = "impacts/sw752_hit_28.wav"
        elseif randomSound == 11 then
            soundToPlay = "impacts/sw752_hit_30.wav"
        elseif randomSound == 12 then
            soundToPlay = "impacts/sw752_hit_31.wav"
        elseif randomSound == 13 then
            soundToPlay = "impacts/sw752_hit_17.wav"
        end

    
        local effect = EffectData()
        effect:SetOrigin(tr.HitPos)
        effect:SetNormal(tr.HitNormal)

        sound.Play( soundToPlay, tr.HitPos, 75, 100, 1 );

        local effect = EffectData()
        effect:SetOrigin(tr.HitPos)
        effect:SetStart(tr.StartPos)
        effect:SetDamageType(dmgtype)

        util.Effect("RagdollImpact", effect)
    end

    return true;
end

SWEP.ChamberSize = 0 -- how many rounds can be chambered.
SWEP.Primary.ClipSize = 25 -- DefaultClip is automatically set.
SWEP.ExtendedClipSize = 50
SWEP.ReducedClipSize = 10

-- But if you insist...
SWEP.ForceDefaultClip = nil
SWEP.ForceDefaultAmmo = nil

-- The amount of rounds to load in the chamber when the gun is non-empty or empty
-- Defaults to ChamberSize and 0. Don't change unless you have a good reason
SWEP.ChamberLoadNonEmpty = nil
SWEP.ChamberLoadEmpty = nil

SWEP.AmmoPerShot = 1
SWEP.InfiniteAmmo = false -- weapon can reload for free
SWEP.BottomlessClip = false -- weapon never has to reload

SWEP.DoNotEquipmentAmmo = false -- do not automatically give this weapon unique ammo when arccw_equipmentammo is used

SWEP.ShotgunReload = false -- reloads like shotgun instead of magazines
SWEP.HybridReload = false -- reload normally when empty, reload like shotgun when part full

SWEP.ManualAction = false -- pump/bolt action
SWEP.NoLastCycle = false -- do not cycle on last shot

SWEP.RevolverReload = false -- cases all eject on reload

SWEP.ReloadInSights = false
SWEP.ReloadInSights_CloseIn = 0.25
SWEP.ReloadInSights_FOVMult = 0.875
SWEP.LockSightsInReload = false

SWEP.CanFireUnderwater = false

SWEP.Disposable = false -- when all ammo is expended, the gun will remove itself when holstered

SWEP.AutoReload = false -- when weapon is drawn, the gun will reload itself.

SWEP.IsShotgun = false -- weapon receives shotgun ammo types

SWEP.TriggerDelay = false -- Set to true to play the "trigger" animation before firing. Delay time is dependent on animation time.

SWEP.Recoil = 2
SWEP.RecoilSide = 1
SWEP.RecoilRise = 1
SWEP.MaxRecoilBlowback = -1
SWEP.VisualRecoilMult = 1.25
SWEP.RecoilPunch = 1.5
SWEP.RecoilPunchBackMax = 1
SWEP.RecoilPunchBackMaxSights = nil -- may clip with scopes
SWEP.RecoilVMShake = 1 -- random viewmodel offset when shooty

SWEP.Sway = 0

SWEP.ShotgunSpreadDispersion = false -- dispersion will cause pattern to increase instead of shifting
SWEP.ShotgunSpreadPattern = nil
SWEP.ShotgunSpreadPatternOverrun = nil
-- {Angle(1, 1, 0), Angle(1, 0, 0) ..}
-- list of how far each pellet should veer
-- if only one pellet then it'll use the first index
-- if two then the first two
-- in case of overrun pellets will start looping, preferably with the second one, so use that for the loopables
-- precision will still be applied

SWEP.RecoilDirection = Angle(1, 0, 0)
SWEP.RecoilDirectionSide = Angle(0, 1, 0)

SWEP.Delay = 60 / 750 -- 60 / RPM.
SWEP.Num = 1 -- number of shots per trigger pull.
SWEP.Firemode = 1 -- 0: safe, 1: semi, 2: auto, negative: burst
SWEP.Firemodes = {
    -- {
    --     Mode = 1,
    --     CustomBars = "---_!",
    -- }
}

--[[
	Custom bar setup
	Colored variants        Classic
	'a' Filled              '-' Filled
	'b' Outline             '_' Outline
	'd' CLR w Outline       '!' Red w Outline
	'#' Empty
]]
--     PrintName = "PUMP",
--     RunAwayBurst = false,
--     AutoBurst = false, -- hold fire to continue firing bursts
--     PostBurstDelay = 0,
--     ActivateElements = {}

SWEP.ShotRecoilTable = nil -- {[1] = 0.25, [2] = 2} etc.

SWEP.NotForNPCS = true
SWEP.NPCWeaponType = nil -- string or table, the NPC weapons for this gun to replace
-- if nil, this will be based on holdtype
SWEP.NPCWeight = 100 -- relative likeliness for an NPC to have this weapon
SWEP.TTTWeaponType = nil -- string or table, like NPCWeaponType but specifically for TTT weapons (takes precdence over NPCWeaponType)
SWEP.TTTWeight = 100 -- like NPCWeight but for TTT gamemode

SWEP.AccuracyMOA = 15 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 500 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 150 -- inaccuracy added by moving. Applies in sights as well! Walking speed is considered as "maximum".
SWEP.SightsDispersion = 0 -- dispersion that remains even in sights
SWEP.JumpDispersion = 300 -- dispersion penalty when in the air

SWEP.Bipod_Integral = false -- Integral bipod (ie, weapon model has one)
SWEP.BipodDispersion = 1 -- Bipod dispersion for Integral bipods
SWEP.BipodRecoil = 1 -- Bipod recoil for Integral bipods

SWEP.ShootWhileSprint = false

SWEP.Primary.Ammo = "pistol" -- what ammo type the gun uses
SWEP.MagID = "mpk1" -- the magazine pool this gun draws from

SWEP.ShootVol = 125 -- volume of shoot sound
SWEP.ShootPitch = 100 -- pitch of shoot sound
SWEP.ShootPitchVariation = 0.05

SWEP.FirstShootSound = nil
SWEP.ShootSound = ""
SWEP.ShootSoundLooping = nil
SWEP.FirstShootSoundSilenced = nil
SWEP.ShootDrySound = nil -- Add an attachment hook for Hook_GetShootDrySound please!
SWEP.DistantShootSound = nil
SWEP.ShootSoundSilenced = "w/dc19.wav"
SWEP.ShootSoundSilencedLooping = nil
SWEP.FiremodeSound = "weapons/arccw/firemode.wav"
SWEP.MeleeSwingSound = "weapons/arccw/melee_lift.wav"
SWEP.MeleeMissSound = "weapons/arccw/melee_miss.wav"
SWEP.MeleeHitSound = "weapons/arccw/melee_hitworld.wav"
SWEP.MeleeHitNPCSound = "weapons/arccw/melee_hitbody.wav"
SWEP.EnterBipodSound = "weapons/arccw/bipod_down.wav"
SWEP.ExitBipodSound = "weapons/arccw/bipod_up.wav"
SWEP.SelectUBGLSound =  "weapons/arccw/ubgl_select.wav"
SWEP.ExitUBGLSound = "weapons/arccw/ubgl_exit.wav"

SWEP.NoFlash = nil -- disable light flash
SWEP.MuzzleEffect = nil
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false -- Use Gmod muzzle effects rather than particle effects
SWEP.ImpactEffect = nil
SWEP.ImpactDecal = nil

SWEP.ShellModel = "models/shells/shell_556.mdl"
SWEP.ShellMaterial = nil
SWEP.ShellEffect = nil
SWEP.ShellEjectPosCorrection = nil
SWEP.ShellScale = 1
SWEP.ShellPhysScale = 1
SWEP.ShellPitch = 100
SWEP.ShellSounds = "autocheck"--ArcCW.ShellSoundsTable
SWEP.ShellRotate = 0
SWEP.ShellTime = 0.5

SWEP.MuzzleEffectAttachment = 1 -- which attachment to put the muzzle on
SWEP.CaseEffectAttachment = 2 -- which attachment to put the case effect on
SWEP.ProceduralViewBobAttachment = nil -- attachment on which coolview is affected by, default is muzzleeffect
SWEP.CamAttachment = nil -- if set, this attachment will control camera movement
SWEP.MuzzleFlashColor = Color(0, 110, 255)

SWEP.SpeedMult = 0.9
SWEP.SightedSpeedMult = 0.75
SWEP.ShootSpeedMult = 1

SWEP.KeepBaseIrons = false -- do not override iron sights when scope installed
SWEP.BaseIronsFirst = false -- If a sight keeps base irons, irons comes first

SWEP.IronSightStruct = {
    Pos = Vector(-8.728, -13.702, 4.014),
    Ang = Angle(-1.397, -0.341, -2.602),
    Midpoint = { -- Where the gun should be at the middle of it's irons
        Pos = Vector(0, 15, -4),
        Ang = Angle(0, 0, -45),
    },
    Magnification = 1,
    BlackBox = false,
    ScopeTexture = nil,
    SwitchToSound = "", -- sound that plays when switching to this sight
    SwitchFromSound = "",
    ScrollFunc = ArcCW.SCROLL_NONE,
    CrosshairInSights = false,
}

SWEP.ProceduralRegularFire = false
SWEP.ProceduralIronFire = false

-- Override free aim convar and variable
SWEP.FreeAimAngle = nil -- defaults to HipDispersion / 80. overwrite here
SWEP.NeverFreeAim = nil
SWEP.AlwaysFreeAim = nil

-- If Jamming is enabled, a heat meter will gradually build up until it reaches HeatCapacity.
-- Once that happens, the gun will overheat, playing an animation. If HeatLockout is true, it cannot be fired until heat is 0 again.
SWEP.Jamming = false
SWEP.HeatCapacity = 200 -- rounds that can be fired non-stop before the gun jams, playing the "fix" animation
SWEP.HeatDissipation = 2 -- rounds' worth of heat lost per second
SWEP.HeatLockout = false -- overheating means you cannot fire until heat has been fully depleted
SWEP.HeatDelayTime = 0.5
SWEP.HeatFix = false -- when the "fix" animation is played, all heat is restored.
SWEP.HeatOverflow = nil -- if true, heat is allowed to exceed capacity (this only applies when the default overheat handling is overridden)

-- If Malfunction is enabled, the gun has a random chance to be jammed
-- after the gun is jammed, it won't fire unless reload is pressed, which plays the "unjam" animation
-- if no "unjam", "fix", or "cycle" animations exist, the weapon will reload instead
SWEP.Malfunction = false
SWEP.MalfunctionJam = true -- After a malfunction happens, the gun will dryfire until reload is pressed. If unset, instead plays animation right after.
SWEP.MalfunctionTakeRound = true -- When malfunctioning, a bullet is consumed.
SWEP.MalfunctionWait = 0.5 -- The amount of time to wait before playing malfunction animation (or can reload)
SWEP.MalfunctionMean = nil -- The mean number of shots between malfunctions, will be autocalculated if nil
SWEP.MalfunctionVariance = 0.25 -- The fraction of mean for variance. e.g. 0.2 means 20% variance
SWEP.MalfunctionSound = "weapons/arccw/malfunction.wav"

SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "smg"
SWEP.HoldtypeCustomize = "slam"
SWEP.HoldtypeNPC = nil

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.GuaranteeLaser = false -- GUARANTEE that the laser position will be accurate, so don't bother with sighted correction

SWEP.ShieldProps = nil
-- {
--     {
--         Model = "",
--         Pos = Vector(0, 0, 0),
--         Ang = Angle(0, 0, 0),
--         Bone = "", -- leave blank for valvebiped right hand
--         Resistance = 5, -- one unit of this object counts for how much penetration amount
--     }
-- }

SWEP.CanBash = true
SWEP.PrimaryBash = false -- primary attack triggers melee attack

SWEP.MeleeDamage = 25
SWEP.MeleeRange = 16
SWEP.MeleeDamageType = DMG_CLUB
SWEP.MeleeTime = 0.5
SWEP.MeleeGesture = nil
SWEP.MeleeAttackTime = 0.2

SWEP.BashPreparePos = Vector(2.187, -4.117, -7.14)
SWEP.BashPrepareAng = Angle(32.182, -3.652, -19.039)

SWEP.BashPos = Vector(8.876, 0, 0)
SWEP.BashAng = Angle(-16.524, 70, -11.046)

SWEP.ActivePos = Vector(0, 0, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.ReloadPos = nil
SWEP.ReloadAng = nil

SWEP.CrouchPos = nil
SWEP.CrouchAng = nil

SWEP.HolsterPos = Vector(0.532, -6, 0)
SWEP.HolsterAng = Angle(-4.633, 36.881, 0)

-- When using custom sprint animations, set this to the same as ActivePos and ActiveAng
SWEP.SprintPos = nil
SWEP.SprintAng = nil

SWEP.BarrelOffsetSighted = Vector(0, 0, 0)
SWEP.BarrelOffsetCrouch = nil
SWEP.BarrelOffsetHip = Vector(3, 0, -3)

SWEP.CustomizePos = Vector(9.824, 0, -4.897)
SWEP.CustomizeAng = Angle(12.149, 30.547, 0)

SWEP.InBipodPos = Vector(-8, 0, -4)
SWEP.InBipodMult = Vector(2, 1, 1)

SWEP.BarrelLength = 24

SWEP.SightPlusOffset = nil

SWEP.DefaultPoseParams = {} -- {["pose"] = 0.5}
SWEP.DefaultWMPoseParams = {}

SWEP.DefaultElements = {} -- {"ele1", "ele2"}

SWEP.AttachmentElements = {
    -- ["name"] = {
    --     RequireFlags = {}, -- same as attachments
    --     ExcludeFlags = {},
    --     NamePriority = 0, -- higher = more likely to be chosen
    --     NameChange = "",
    --     TrueNameChange = "",
    --     AddPrefix = "",
    --     AddSuffix = "",
    --     VMPoseParams = {}, -- {["pose"] = 0.5}
    --     VMColor = Color(),
    --     VMMaterial = "",
    --     VMBodygroups = {{ind = 1, bg = 1}},
    --     VMElements = {
    --         {
    --             Model = "",
    --             Bone = "",
    --             Offset = {
    --                 pos = Vector(),
    --                 ang = Angle(),
    --             },
    --             ModelSkin = 0,
    --             ModelBodygroups = "",
    --             Scale = Vector(1, 1, 1),
    --             IsMuzzleDevice = false -- this element is a muzzle device, and the muzzle flash should come from here.
    --         }
    --     },
    --     VMOverride = "", -- change the view model to something else. Please make sure it's compatible with the last one.
    --     VMBoneMods = {
    --         ["bone"] = Vector(0, 0, 0)
    --     },
    --     WMPoseParams = {}, -- {["pose"] = 0.5}
    --     WMColor = Color(),
    --     WMMaterial = "",
    --     WMBodygroups = {},
    --     WMElements = {
    --         {
    --             Model = "",
    --             Offset = {
    --                 pos = Vector(),
    --                 ang = Angle(),
    --             },
    --             IsMuzzleDevice = false -- this element is a muzzle device, and the muzzle flash should come from here.
    --         }
    --     },
    --     WMOverride = "", -- change the world model to something else. Please make sure it's compatible with the last one.
    --     WMBoneMods = {
    --         ["bone"] = Vector(0, 0, 0)
    --     },
    --     AttPosMods = {
    --         [1] = {
    --             bone = "", -- optional
    --             vpos = Vector(0, 0, 0),
    --             vang = Angle(0, 0, 0),
    --             wpos = Vector(0, 0, 0),
    --             wang = Angle(0, 0, 0),
    --             SlideAmount = { -- only if base att has slideable
    --                 vmin = Vector(0, 0, 0),
    --                 vmax = Vector(0, 0, 0),
    --                 wmin = Vector(0, 0, 0),
    --                 wmax = Vector(0, 0, 0)
    --             }
    --         }
    --     }
    -- }
}

SWEP.RejectAttachments = {
    -- ["optic_docter"] = true -- stop this attachment from being usable on this gun
}

SWEP.AttachmentOverrides = {
    -- ["optic_docter"] = {} -- allows you to overwrite atttbl values
}

SWEP.TTT_DoNotAttachOnBuy = false -- don't give all attachments when bought

SWEP.Attachments = {}
-- [1] = {
--     PrintName = "Optic", -- print name
--     DefaultAttName = "Iron Sights", -- used to display the "no attachment" text
--     DefaultAttIcon = Material(),
--     Slot = "pic_sight", -- what kind of attachments can fit here
--     MergeSlots = {}, -- these other slots will be merged into this one.
--     Bone = "sight", -- relevant bone any attachments will be mostly referring to
--     WMBone = "ValveBiped.Bip01_L_Hand", -- set it to change parent bone of attachment WM
--     KeepBaseIrons = false,
--     ExtraSightDist = 0,
--     Offset = {
--         vpos = Vector(0, 0, 0), -- offset that the attachment will be relative to the bone
--         vang = Angle(0, 0, 0),
--         wpos = Vector(0, 0, 0), -- same, for the worldmodels
--         wang = Angle(0, 0, 0)
--     },
--     RejectAttachments = {}, -- specific blacklist of attachments this slot cannot accept. Needs to be like {"optic_mrs" = true}
--     VMScale = Vector(1, 1, 1),
--     WMScale = Vector(1, 1, 1),
--     SlideAmount = { -- how far this attachment can slide in both directions.
--         -- overrides Offset.
--         vmin = Vector(0, 0, 0),
--         vmax = Vector(0, 0, 0),
--         wmin = Vector(0, 0, 0),
--         wmax = Vector(0, 0, 0),
--     },
--     CorrectiveAng = Vector(1, 1, 1), -- okay, I know I said sights were pain-free.
--     CorrectivePos = Vector(0, 0, 0), -- that won't always be the case. Use these to fix it. Issues mainly crop up in case of sights parented to bones that are not a root bone.
--     InstalledEles = {"toprail"}, -- activate these AttachmentElements if something is installed
--     DefaultEles = {""} -- activeate these AttachmentElements *unless* something is installed
--     Hidden = false, -- attachment cannot be seen in customize menu
--     Integral = false, -- attachment is assumed never to change
--     RandomChance = 1, -- multiplies chance this slot will get a random attachment
--     DoNotRandomize = false,
--     NoWM = false, -- do not make this show up on worldmodel
--     NoVM = false, -- what do *you* think this one does?
--     FreeSlot = false, -- slot does not count towards attachment capacity
--     -- ABOUT THE FLAG SYSTEM:
--     -- Attachments and slots can give flags
--     -- All attachments automatically give themselves as a flag, e.g. "optic_mrs"
--     -- If requirements are not satisfied, the slot or attachment will not be attachable
--     ExcludeFlags = {}, -- if the weapon has this flag, hide this slot
--     RequireFlags = {}, -- if the weapon does not have all these flags, hide this slot
--     GivesFlags = {} -- give these slots if something is installed here
--     HideIfBlocked = false, -- If flag requirements are not met, do not show the attachment at all
-- }

-- ready: deploy first time
-- draw
-- holster
-- reload
-- fire
-- cycle (for bolt/pump actions)
-- bash
-- fix
-- enter_bipod
-- exit_bipod
-- enter_sight
-- exit_sight
-- a_to_b: switch from firemode a to firemode b. e.g.: 1_to_2
-- idle
-- idle_sights
-- idle_sprint
-- idle_bipod
-- enter_inspect
-- idle_inspect
-- exit_inspect
-- enter_ubgl
-- exit_ubgl
-- idle_ubgl

-- you can append suffixes for different states
-- append list:

-- _iron, _sights, or _sight     for sighted variation
-- _sprint                       for sprinting variation
-- _bipod                        for bipod variation
-- _empty                        for empty variation
-- _jammed                       for jammed variation

-- this does not apply to reload animations.

-- !! they MUST be in the order of this list.
-- example: fire_iron_bipod_empty

-- use SWEP/wep.Hook_TranslateAnimation, same as in attachment, to do even more behaviours
-- use SWEP/wep.Hook_SelectReloadAnimation to change the reload animation
-- use SWEP/wep.Hook_SelectInsertAnimation to change the shotgun reload insert animation
-- use SWEP/wep.Hook_SelectFireAnimation to change the fire animation
-- use SWEP/wep.Hook_SelectCycleAnimation to change the cycle/pump animation
-- use SWEP/wep.Hook_SelectBashAnimation to change the bash animation

-- which sequence to derive the sight autosolver from.
SWEP.AutosolveSourceSeq = "idle"

-- Disclaimer: LHIK is *actually* a type of forward kinematics.
-- If you prefer, LHIK can stand for "Left Hand Individual Kinematics" or some shit

SWEP.Animations = {
    -- ["idle"] = {
    --     Source = "idle",
    --     Time = 10
    -- },
    -- ["draw"] = {
    --     RestoreAmmo = 1, -- only used by shotgun empty insert reload
    --     Source = "deploy",
    --     RareSource = "", -- 1/RareSourceChance of playing this animation instead
    --     RareSourceChance = 100, -- Chance the rapper
    --     Time = 0.5, -- Overwrites the duration of the animation (changes speed). Don't set to use sequence length
    --     Mult = 1, -- Multiplies the rate of animation.
    --     TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2, -- third person animation to play when this animation is played
    --     TPAnimStartTime = 0, -- when to start it from
    --     Checkpoints = {}, -- time checkpoints. If weapon is unequipped, the animation will continue to play from these checkpoints when reequipped.
    --     ShellEjectAt = 0, -- animation includes a shell eject at these times
    --     LHIKIn = 0.25, -- In/Out controls how long it takes to switch to regular animation.
    --     LHIKOut = 0.25, -- (not actually inverse kinematics)
    --     LHIKEaseIn = 0.1, -- how long LHIK eases in.
    --     LHIKEaseOut = 0.1, -- if no value is specified then ease = lhikin
    --     LHIKTimeline = { -- allows arbitrary LHIK values to be interpolated between
    --         {
    --             t = 0.1,
    --             lhik = 0,
    --         },
    --         {
    --             t = 0.25,
    --             lhik = 1
    --         }
    --     },
    --     LHIK = true, -- basically disable foregrips on this anim
    --     SoundTable = {
    --         {
    --             s = "", -- sound; can be string or table
    --             p = 100, -- pitch
    --             v = 75, -- volume
    --             t = 1, -- time at which to play relative to Animations.Time
    --             c = CHAN_ITEM, -- channel to play the sound

    --             -- Can also play an effect at the same time
    --             e = "", -- effect name
    --             att = nil, -- attachment, defaults to shell attachment
    --             mag = 100, -- magnitude
    --             -- also capable of modifying bodygroups
    --             ind = 0,
    --             bg = 0,
    --             -- and poseparams
    --             pp = "pose",
    --             ppv = 0.25,
    --         }
    --     },
    --     ViewPunchTable = {
    --         {
    --             p = Vector(0, 0, 0),
    --             t = 1
    --         }
    --     },
    --     ProcDraw = false, -- for draw/deploy animations, always procedurally draw in addition to playing animation
    --     ProcHolster = false, -- procedural holster weapon, THEN play animation
    --     LastClip1OutTime = 0, -- when should the belt visually replenish on a belt fed
    --     MinProgress = 0, -- how much time in seconds must pass before the animation can be cancelled
    --     ForceEmpty = false, -- Used by empty shotgun reloads that load rounds to force consider the weapon to still be empty.
    -- }
}

--[[
for k, v in ipairs(ents.FindByClass("sb*")) do
	if v.Droid then
		v:Give("arccw_ef_blaster_dc15s")
	end
end
]]

DEFINE_BASECLASS( SWEP.Base )
--PATH addons/[bronie] arccw-special-forces-v3-1/lua/weapons/arccw_sops_empire_dlt23v.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 4 

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Special Forces - Empire"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "DLT-23V"
SWEP.Trivia_Class = "Blaster Heavy Repeater"
SWEP.Trivia_Desc = "In need of a heavy weapon capable of destroying Rebel scum, Blastech Industries designed and created a portable destruction machine. The DLT-23v was born with a single objective: that nothing and no one who is the target remains alive."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/sops/dlt23v.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "000000000000"
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/sops/v_dlt23v_imperio.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_dlt19.mdl"

SWEP.ViewModelFOV = 65

SWEP.WorldModelOffset = {
    pos = Vector(-11.3, 1.5, -7),
    ang = Angle(-10, 5, 220),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 75
SWEP.HeatDissipation = 10
SWEP.HeatLockout = false
SWEP.HeatFix = true
SWEP.HeatDelayTime = 0.1

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 30
SWEP.DamageMin = 13
SWEP.RangeMin = 0
SWEP.Range = 400
SWEP.Penetration = 10
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 2000

SWEP.TracerNum = 1
SWEP.TracerCol = Color(250, 0, 0)
SWEP.TracerWidth = 1
SWEP.Tracer = "tracer_red"
SWEP.HullSize = 1

SWEP.InfiniteAmmo = true
SWEP.BottomlessClip = true

SWEP.Recoil = 0.55
SWEP.RecoilSide = 0.55
SWEP.RecoilRise = 0.90
SWEP.MaxRecoilBlowback = 1
SWEP.RecoilPunch = 0.9
SWEP.RecoilVMShake = 1

SWEP.Delay = 60 / 230
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
    {
		Mode = 2,
    },
	{
		Mode = 0,
   	}
}

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.AccuracyMOA = 0
SWEP.HipDispersion = 250
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.955
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "kraken/sops/dlt24x.wav"
SWEP.ShootSound = "kraken/sops/dlt24x.wav"
SWEP.DistantShootSound = "ArcCW_Kraken.StandardCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "blaster_muzzle_red"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(250, 0, 0)

-- Ironsight
SWEP.IronSightStruct = false

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "shotgun"
SWEP.HoldtypeSights = "shotgun"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.SprintPos = Vector(2, -1, 3)
SWEP.SprintAng = Angle(-10, 26, 0)

SWEP.CustomizePos = Vector(10, 0, 2)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.CrouchPos = Vector(-3, 0, 3)
SWEP.CrouchAng = Angle(0, 0, 0)

SWEP.ActivePos = Vector(0, 0, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments
SWEP.DefaultElements = {}
SWEP.AttachmentElements = {}

SWEP.Attachments = {     
    {
        PrintName = "Energization",
        DefaultAttName = "None",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },     
}


-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = false,
    },
    ["idle_iron"] = {
        Source = false,
    },
    ["fire"] = {
        Source = false,
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["fix"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "kraken/sops/dlt23/dlt23v_reload6.wav", t = 0.1/30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 150 / 30},
        },
    },
}

-- Special properties
SWEP.Hook_ModifyRPM = function(wep, delay)
    return delay / Lerp(wep:GetBurstCount() / 15, 1, 3)
end
--PATH addons/[bronie] arccw-special-forces-v3-1/lua/weapons/arccw_sops_empire_e11x.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 4

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Special Forces - Empire"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "E-11x"
SWEP.Trivia_Class = "Blaster Sniper Rifle"
SWEP.Trivia_Desc = "Blastech's E-11 platform was considered to be one of the most successful blaster designs in history. It was no surprise that when the Galactic Empire wanted a dedicated sniper rifle, the company looked to its most successful design for inspiration. The E-11s used the same frame, but incorporated a composite alloy buttstock and the barrel was double the length than a regular E-11 medium blaster rifle. The elongated barrel featured the same perforated shroud and heat-abating fins the E-11 was known for. Unfortunately, heat management problems reduced the weapon's fire rate well below that of market competitors. The Empire deployed E-11s with scout troopers, infantry platoon sharpshooters and special forces snipers. Other than the Empire, Blastech sold E-11s to special law-enforcement units, planetary defense forces; and permitted bounty hunters and mercenaries. The prevalence of the weapon meant they found their way onto the black market usually through salvage from battlefields or hijacked factory shipments."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/sops/e11x.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "000000000000"
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/sops/v_e11x.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_dlt19.mdl"

SWEP.ViewModelFOV = 65

SWEP.WorldModelOffset = {
    pos = Vector(-9, 5, -5.75),
    ang = Angle(-10, 0, -180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 10
SWEP.HeatDissipation = 5
SWEP.HeatLockout = true
SWEP.HeatFix = true
SWEP.HeatDelayTime = 0.5

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 105
SWEP.DamageMin = 75
SWEP.RangeMin = 0
SWEP.Range = 900
SWEP.Penetration = 10
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 2000

SWEP.TracerNum = 1
SWEP.TracerCol = Color(250, 0, 0)
SWEP.TracerWidth = 1
SWEP.Tracer = "tracer_red"
SWEP.HullSize = 1

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 18

SWEP.Recoil = 1.28
SWEP.RecoilSide = 0.76
SWEP.RecoilRise = 0.98
SWEP.MaxRecoilBlowback = 2
SWEP.RecoilPunch = 1
SWEP.RecoilVMShake = 2

SWEP.Delay = 60 / 120
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
	{
		Mode = 0,
   	}
}

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.AccuracyMOA = 0.5
SWEP.HipDispersion = 100
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.955
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "kraken/sops/ex11.wav"
SWEP.ShootSound = "kraken/sops/ex11.wav"
SWEP.DistantShootSound = "ArcCW_Kraken.HeavyCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "blaster_muzzle_red"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(250, 0, 0)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-4.745, -9.119, 1.574),
    Ang = Vector(2.677, 0, 0),
     Magnification = 1.5,
     SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
     SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
     ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "ar2"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_SHOTGUN

SWEP.SprintPos = Vector(2, -1, 3)
SWEP.SprintAng = Angle(-10, 26, 0)

SWEP.CustomizePos = Vector(10, 0, 2)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.CrouchPos = Vector(-3, 0, 3)
SWEP.CrouchAng = Angle(0, 0, 0)

SWEP.ActivePos = Vector(-3, 0, 1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.BipodDispersion = 1
SWEP.BipodRecoil = 1

SWEP.InBipodPos = Vector(-8, 0, -4)
SWEP.InBipodMult = Vector(2, 1, 1)

-- Attachments
SWEP.DefaultElements = {"muzzle"}
SWEP.AttachmentElements = {
    ["muzzle_attach"] = {
        VMBodygroups = {{ind = 3, bg = 1}},
    },
    ["scope_attach"] = {
        VMBodygroups = {{ind = 2, bg = 1}},
    },
    ["bipod_e11x"] = {
        VMBodygroups = {{ind = 1, bg = 0}},
    },
    ["specialforces_bipod"] = {
        VMBodygroups = {{ind = 1, bg = 1}},
    },
    ["bipod_e11x_hidden"] = {
        VMBodygroups = {{ind = 1, bg = 2}},
    },
    ["muzzle"] = {
        VMElements = {
           {
               Model = "models/hunter/plates/plate.mdl",
               Bone = "dlt34",
               Scale = Vector(0, 0, 0),                
               Offset = {
                   pos = Vector(0, 0, 34),
                   ang = Angle(90, 0, 0),
               },
               IsMuzzleDevice = true,
           }
        }, 
    },
}

SWEP.Attachments = {     
    {
        PrintName = "Sight", 
        DefaultAttName = "None",
        Slot = "optic",
        Bone = "dlt34",
        VMScale = Vector(1,1,1),
        WMScale = Vector(1,1,1),
        InstalledEles = {"scope_attach"},
        Offset = {
            vpos = Vector(-0.01, -2.2, 2),
            vang = Angle(90, 0, -90),
        },
        CorrectivePos = Vector(0, 0, 0),
        CorrectiveAng = Angle(0, 0, 0),
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        InstalledEles = {"muzzle_attach"},
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
        VMScale = Vector(1.2,1.2,1.2),
        WMScale = Vector(1.2,1.2,1.2),
        Bone = "dlt34",
        Offset = {
            vpos = Vector(-0.01, -1, 31.3),
            vang = Angle(90, 0, -90),
        },
        CorrectivePos = Vector(0, 0, 0),
        CorrectiveAng = Angle(0, 0, 0),
    },
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol"},
        Bone = "dlt34",
        VMScale = Vector(1,1,1),
        WMScale = Vector(1,1,1),
        Offset = {
            vpos = Vector(-0.9, -0.75, 20),
            vang = Angle(90, 0, 180),
        },
    },
    {
        PrintName = "Underbarrel",
        DefaultAttName = "E-11X Bipod",
        InstalledEles = {"bipod_e11x_hidden"},
        Slot = {"foregrip", "specialforces_bipod"},
        Bone = "dlt34",
        Offset = {
            vpos = Vector(-0.01, -0.3, 15),
            vang = Angle(90, 0, -90),
        },
    },
    {
        PrintName = "Energization",
        DefaultAttName = "None",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.9, 0.9, 0.9),
        WMScale = Vector(0.9, 0.9, 0.9),
        Bone = "dlt34",
        Offset = {
            vpos = Vector(0.65, -0.82, 11.7),
            vang = Angle(90, 0, -90),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        VMScale = Vector(1,1,1),
        WMScale = Vector(1,1,1),
        Bone = "dlt34",
        Offset = {
            vpos = Vector(0.56, -1.2, 8.5),
            vang = Angle(90, 0, -90),
        },
    },   
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["idle_iron"] = {
        Source = false,
    },
	["fire"] = {
        Source = {"shoot"},
    },
    ["fire_iron"] = {
        Source = {"shoot"},
    },
    ["fix"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        Mult = 0.3,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatFix", t = 60 / 30},
            {s = "ArcCW_Kraken.Grab", t = 65 / 30},
        },
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        Mult = 0.6,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 110 / 30},
            {s = "ArcCW_Kraken.Grab", t = 115 / 30},
        },
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
}
--PATH addons/[bronie] arccw-special-forces-v3-1/lua/weapons/arccw_sops_empire_tl50.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Special Forces - Empire"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "TL-50"
SWEP.Trivia_Class = "Blaster Heavy Repeater"
SWEP.Trivia_Desc = "The TL-50 Heavy Repeater was a model of heavy repeating blaster rifle that was manufactured for the special forces of the Galactic Empire. In addition to sending storms of blaster bolts from its multiple barrels, the rifle could gather its energy into a powerful concussion blast. It could also be modified with an extended barrel for reduced spread and with a power cell for increased cooling power. During the Galactic Civil War against the Rebel Alliance, Commander Iden Versio of the Empire's elite Inferno Squad carried a TL-50 Heavy Repeater."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/sops/tl50.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "000000000000"
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/sops/v_tl50.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"

SWEP.ViewModelFOV = 65

SWEP.WorldModelOffset = {
    pos = Vector(-9, 5, -5.75),
    ang = Angle(-10, 0, -180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 30
SWEP.HeatDissipation = 5
SWEP.HeatLockout = true
SWEP.HeatFix = true
SWEP.HeatDelayTime = 0.5

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 33
SWEP.DamageMin = 26
SWEP.RangeMin = 0
SWEP.Range = 400
SWEP.Penetration = 10
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 2000

SWEP.TracerNum = 1
SWEP.TracerCol = Color(250, 0, 0)
SWEP.TracerWidth = 1
SWEP.Tracer = "tracer_red"
SWEP.HullSize = 1

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 50

SWEP.Recoil = 0.55
SWEP.RecoilSide = 0.55
SWEP.RecoilRise = 0.90
SWEP.MaxRecoilBlowback = 1
SWEP.RecoilPunch = 0.9
SWEP.RecoilVMShake = 1

SWEP.Delay = 60 / 600
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
    {
		Mode = 2,
    },
	{
		Mode = 0,
   	}
}

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.AccuracyMOA = 0.5
SWEP.HipDispersion = 250
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.955
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "kraken/sops/tl50.wav"
SWEP.ShootSound = "kraken/sops/tl50.wav"
SWEP.DistantShootSound = "ArcCW_Kraken.HeavyCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "blaster_muzzle_red"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(250, 0, 0)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-4.86, 0, 0.921),
    Ang = Vector(0, 0, 0),
     Magnification = 1.5,
     SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
     SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
     ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "ar2"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.SprintPos = Vector(2, -1, 3)
SWEP.SprintAng = Angle(-10, 26, 0)

SWEP.CustomizePos = Vector(10, 0, 2)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.CrouchPos = Vector(-3, 0, 3)
SWEP.CrouchAng = Angle(0, 0, 0)

SWEP.ActivePos = Vector(-3, 0, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments
SWEP.DefaultElements = {"muzzle"}
SWEP.AttachmentElements = {
    ["muzzle"] = {
        VMElements = {
           {
               Model = "models/hunter/plates/plate.mdl",
               Bone = "dlt34",
               Scale = Vector(0, 0, 0),                
               Offset = {
                   pos = Vector(0, -2, 20),
                   ang = Angle(90, 0, 0),
               },
               IsMuzzleDevice = true,
           }
        }, 
    },
}

SWEP.Attachments = {     
    {
        PrintName = "Sight", 
        DefaultAttName = "None",
        Slot = "optic",
        Bone = "dlt34",
        VMScale = Vector(1,1,1),
        WMScale = Vector(1,1,1),
        Offset = {
            vpos = Vector(-0.13, -4.9, 10),
            vang = Angle(90, 0, -90),
        },
        CorrectivePos = Vector(0, 0, 0),
        CorrectiveAng = Angle(0, 0, 0),
    },
    {
        PrintName = "Internal Compression",
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
    },
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol"},
        Bone = "dlt34",
        VMScale = Vector(1,1,1),
        WMScale = Vector(1,1,1),
        Offset = {
            vpos = Vector(-1.2, -3.4, 19.5),
            vang = Angle(90, 0, 180),
        },
    },
    {
        PrintName = "Energization",
        DefaultAttName = "None",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.9, 0.9, 0.9),
        WMScale = Vector(0.9, 0.9, 0.9),
        Bone = "dlt34",
        Offset = {
            vpos = Vector(0.9, -2.3, 5),
            vang = Angle(90, 0, -90),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        VMScale = Vector(1,1,1),
        WMScale = Vector(1,1,1),
        Bone = "dlt34",
        Offset = {
            vpos = Vector(0.65, -3.3, 3),
            vang = Angle(90, 0, -90),
        },
    },   
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["idle_iron"] = {
        Source = false,
    },
	["fire"] = {
        Source = {"shoot"},
    },
    ["fire_iron"] = {
        Source = {"shoot"},
    },
    ["fix"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        Mult = 0.3,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatFix", t = 60 / 30},
            {s = "ArcCW_Kraken.Grab", t = 65 / 30},
        },
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        Mult = 0.5,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 110 / 30},
            {s = "ArcCW_Kraken.Grab", t = 115 / 30},
        },
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
}
--PATH addons/[bronie] arccw-special-forces-v3-1/lua/weapons/arccw_sops_galactic_a280cfe.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3

SWEP.Category = "[ArcCW] Kraken's Special Forces - Galactic"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "A-280CFE"
SWEP.Trivia_Class = "Blaster Modular Rifle"
SWEP.Trivia_Desc = "The A280-CFE (covert field edition) convertible heavy blaster pistol, also known as an A280-CFE blaster rifle or simply a A280-CFE blaster, was a modular version of the A280 blaster rifle. It featured a core pistol that could be reconfigured into an assault rifle or sniper rifle.[1] Captain Cassian Andor used an A280-CFE during the Battle on Jedha, the mission to Eadu, and the Battle of Scarif."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/sops/a280cfe.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "000102"
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/sops/v_a280cfe.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_dlt19.mdl"

SWEP.ViewModelFOV = 65

SWEP.WorldModelOffset = {
    pos = Vector(-12, 4, -4.1),
    ang = Angle(-10, 0, -180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1.1
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 25
SWEP.HeatDissipation = 5
SWEP.HeatLockout = true
SWEP.HeatFix = true
SWEP.HeatDelayTime = 0.5

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 40
SWEP.DamageMin = 22
SWEP.RangeMin = 0
SWEP.Range = 500
SWEP.Penetration = 10
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 2000

SWEP.TracerNum = 1
SWEP.TracerCol = Color(250, 0, 0)
SWEP.TracerWidth = 1
SWEP.Tracer = "tracer_red"
SWEP.HullSize = 1

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 25

SWEP.Recoil = 0.75
SWEP.RecoilSide = 0.45
SWEP.RecoilRise = 0.90
SWEP.MaxRecoilBlowback = 1
SWEP.RecoilPunch = 1
SWEP.RecoilVMShake = 1.2

SWEP.Delay = 60 / 460
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
    {
        Mode = -3,
        PostBurstDelay = 0.1,
        RunawayBurst = false,
        Mult_RPM = 3,
    },
    {
		Mode = 2,
    },
	{
		Mode = 0,
   	}
}

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.AccuracyMOA = 0
SWEP.HipDispersion = 250
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.955
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "kraken/sops/a280cfe.wav"
SWEP.ShootSound = "kraken/sops/a280cfe.wav"
SWEP.DistantShootSound = "ArcCW_Kraken.HeavyCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "blaster_muzzle_red"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(250, 0, 0)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-3.89, -5.363, 2.553),
    Ang = Vector(0.6, 0, 0),
     Magnification = 1.5,
     SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
     SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
     ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "ar2"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.SprintPos = Vector(2.019, -2.226, -2)
SWEP.SprintAng = Angle(0, 0, 0)

SWEP.CustomizePos = Vector(10, 0, 2)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.CrouchPos = Vector(-3, 0, 0)
SWEP.CrouchAng = Angle(0, 0, 0)

SWEP.ActivePos = Vector(-3, 0, 1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments
SWEP.DefaultElements = {"muzzle"}
SWEP.AttachmentElements = {
    ["muzzle"] = {
        VMElements = {
           {
               Model = "models/hunter/plates/plate.mdl",
               Bone = "a280cfe",
               Scale = Vector(0, 0, 0),                
               Offset = {
                   pos = Vector(0, 0, 15),
                   ang = Angle(90, 0, 0),
               },
               IsMuzzleDevice = true,
           }
        }, 
    },
    ["a280cfe_barrel_short"] = {
        VMBodygroups = {{ind = 1, bg = 1}},
        AttPosMods = {
            [2] = {
                vpos = Vector(-0.175, -1.65, 15.5   ),
            },
        }
    },
    ["a280cfe_barrel_sniper"] = {
        NameChange = "Sniper A-280CFE",
        VMBodygroups = {{ind = 1, bg = 2}},
        AttPosMods = {
            [2] = {
                vpos = Vector(-0.175, -1.65, 24),
            },
        }
    },
    ["a280cfe_powerpack"] = {
        VMBodygroups = {
            {ind = 4, bg = 1},
        },
    },
    ["a280cfe_stock_assault"] = {
        VMBodygroups = {
            {ind = 5, bg = 0},
        },
    },
    ["a280cfe_stock_heavy"] = {
        VMBodygroups = {
            {ind = 5, bg = 1},
        },
    },
}

SWEP.RejectAttachments = {
     ["a280cfe_stock_heavy"] = true
}

SWEP.Attachments = {     
    {
        PrintName = "Sight", 
        DefaultAttName = "None",
        Slot = "optic",
        Bone = "a280cfe",
        VMScale = Vector(1,1,1),
        WMScale = Vector(1,1,1),
        Offset = {
            vpos = Vector(-0.15, -2.8, 0),
            vang = Angle(90, 0, -90),
        },
        CorrectivePos = Vector(0, 0, 0),
        CorrectiveAng = Angle(0, 0, 0),
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        InstalledEles = {"muzzle_attach"},
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
        VMScale = Vector(1.4,1.4,1.4),
        WMScale = Vector(1.4,1.4,1.4),
        Bone = "a280cfe",
        Offset = {
            vpos = Vector(-0.175, -1.7, 19.2),
            vang = Angle(90, 0, -90),
        },
        CorrectivePos = Vector(0, 0, 0),
        CorrectiveAng = Angle(0, 0, 0),
    },
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol"},
        Bone = "a280cfe",
        VMScale = Vector(1,1,1),
        WMScale = Vector(1,1,1),
        Offset = {
            vpos = Vector(-1.2, -1.3, 19.5),
            vang = Angle(90, 0, 180),
        },
    },
    {
        PrintName = "Barrel",
        DefaultAttName = "None",
        Slot = {"cfe_barrel"},
    },   
    {
        PrintName = "Stock",
        DefaultAttName = "None",
        Slot = {"cfe_stock"},
    },    
    {
        PrintName = "Powerpack", 
        DefaultAttName = "None",
        Slot = {"cfe_powerpack"},
    },
    {
        PrintName = "Energization",
        DefaultAttName = "None",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.9, 0.9, 0.9),
        WMScale = Vector(0.9, 0.9, 0.9),
        Bone = "a280cfe",
        Offset = {
            vpos = Vector(0.4, 0, 4),
            vang = Angle(90, 0, -90),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        VMScale = Vector(1,1,1),
        WMScale = Vector(1,1,1),
        Bone = "a280cfe",
        Offset = {
            vpos = Vector(0.49, -1.4, 6),
            vang = Angle(90, 0, -70),
        },
    },   
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["idle_iron"] = {
        Source = false,
    },
	["fire"] = {
        Source = {"fire"},
    },
    ["fire_iron"] = {
        Source = {"fire"},
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        Mult = 0.6,
        SoundTable = {
            {s = "kraken/sops/firepuncher/reload.wav", t = 1 / 30},
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 110 / 30},
            {s = "ArcCW_Kraken.Grab", t = 115 / 30},
        },
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
}
--PATH addons/[bronie] arccw-special-forces-v3-1/lua/weapons/arccw_sops_galactic_galaar15.lua:
return gluapack()()
--PATH addons/[bronie] arccw-special-forces-v3-1/lua/weapons/arccw_sops_galactic_k0bu.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 2

SWEP.Category = "[ArcCW] Kraken's Special Forces - Galactic"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "K-0Bu"
SWEP.Trivia_Class = "Blaster Pistol"
SWEP.Trivia_Desc = "The K-0Bu is a powerful blaster pistol, designed for both military and civilian use. Known for its high-impact energy shots, it delivers exceptional range and stopping power, making it ideal for both combat and personal defense."
SWEP.Trivia_Manufacturer = "Concordian Crescent Technologies"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/sops/k0bu.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "000000000000"
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/sops/v_k0bu.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"

SWEP.ViewModelFOV = 65

SWEP.WorldModelOffset = {
    pos = Vector(-13.5, 6.7, -7.65),
    ang = Angle(0, 0, -180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 20
SWEP.HeatDissipation = 3
SWEP.HeatLockout = true
SWEP.HeatFix = true
SWEP.HeatDelayTime = 0.5

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 26
SWEP.DamageMin = 21
SWEP.RangeMin = 0
SWEP.Range = 140
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 2000

SWEP.TracerNum = 1
SWEP.TracerCol = Color(250, 0, 0)
SWEP.TracerWidth = 1
SWEP.Tracer = "tracer_red"
SWEP.HullSize = 1

SWEP.InfiniteAmmo = true
SWEP.BottomlessClip = true

SWEP.Recoil = 1
SWEP.RecoilSide = 0.6
SWEP.RecoilRise = 0.9

SWEP.Delay = 60 / 430
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
	{
		Mode = 0,
   	}
}

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.AccuracyMOA = 0.5
SWEP.HipDispersion = 100
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.955
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "kraken/sops/k0bu.wav"
SWEP.ShootSound = "kraken/sops/k0bu.wav"
SWEP.DistantShootSound = "ArcCW_Kraken.HeavyCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "blaster_muzzle_red"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(250, 0, 0)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-6.132, 0, 3.213),
    Ang = Vector(0, 0, 0),
     Magnification = 1.5,
     SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
     SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
     ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "pistol"
SWEP.HoldtypeSights = "revolver"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_PISTOL

SWEP.SprintPos = Vector(-3, -6, -5)
SWEP.SprintAng = Angle(40, 0, 0)

SWEP.CustomizePos = Vector(10, -5, 2)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.CrouchPos = Vector(-3, 0, 3)
SWEP.CrouchAng = Angle(0, 0, 0)

SWEP.ActivePos = Vector(-3, 0, 1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.DefaultElements = {"muzzle"}
SWEP.AttachmentElements = {
    ["muzzle"] = {
        VMElements = {
           {
               Model = "models/hunter/plates/plate.mdl",
               Bone = "a180",
               Scale = Vector(0, 0, 0),                
               Offset = {
                   pos = Vector(0.25, -0, 12),
                   ang = Angle(90, 0, -90),
               },
               IsMuzzleDevice = true,
           }
        }, 
    },
}

-- Attachments
SWEP.Attachments = {     
    {
        PrintName = "Sight", 
        DefaultAttName = "None",
        Slot = "optic",
        Bone = "a180",
        VMScale = Vector(0.8, 0.8, 0.8),
        WMScale = Vector(0.8, 0.8, 0.8),
        Offset = {
            vpos = Vector(0.27, -2.1, 1.2),
            vang = Angle(90, 0, -90),
        },
        CorrectivePos = Vector(0, 0, 0),
        CorrectiveAng = Angle(0, 0, 0),
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
        Bone = "a180",
        Offset = {
            vpos = Vector(0.3, -1.3, 11.4),
            vang = Angle(90, 0, -90),
        },
    },  
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol"},
        Bone = "a180",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(0.3, -0.9, 8),
            vang = Angle(90, 0, -90),
        },
    },
    {
        PrintName = "Energization",
        DefaultAttName = "None",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.6, 0.6, 0.6),
        WMScale = Vector(0.6, 0.6, 0.6),
        Bone = "a180",
        Offset = {
            vpos = Vector(0.55, 0.67, 3.2),
            vang = Angle(90, 0, -90),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        VMScale = Vector(0.9, 0.9, 0.9),
        WMScale = Vector(0.9, 0.9, 0.9),
        Bone = "a180",
        Offset = {
            vpos = Vector(0.93, -1.05, -1.3),
            vang = Angle(90, 0, -50),
        },
    },   
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["idle_iron"] = {
        Source = false,
    },
	["fire"] = {
        Source = {"shoot"},
        Mult = 2,
    },
    ["fire_iron"] = {
        Source = {"shoot"},
    },
    ["fix"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatFix", t = 45 / 30},
            {s = "ArcCW_Kraken.Grab", t = 43 / 30},
        },
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
}

--PATH addons/[bronie] arccw-special-forces-v3-1/lua/weapons/arccw_sops_galactic_k3bu.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 4

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Special Forces - Galactic"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "K3b-u"
SWEP.Trivia_Class = "Blaster Carbine"
SWEP.Trivia_Desc = "The K3b-u is a powerful blaster designed for both military and civilian use, known for its high precision and stopping power. Compact yet formidable, it offers versatile performance, making it suitable for a range of tactical and self-defense situations."
SWEP.Trivia_Manufacturer = "Unknown"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/sops/k3bu.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "000000000000"
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/sops/v_k3bu.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"

SWEP.ViewModelFOV = 65

SWEP.WorldModelOffset = {
    pos = Vector(-11, 5, -1.5),
    ang = Angle(-15, 0, -180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 15
SWEP.HeatDissipation = 5
SWEP.HeatLockout = true
SWEP.HeatFix = true
SWEP.HeatDelayTime = 0.5

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 38
SWEP.DamageMin = 27
SWEP.RangeMin = 0
SWEP.Range = 305
SWEP.Penetration = 10
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 2000

SWEP.TracerNum = 1
SWEP.TracerCol = Color(2500, 0, 0)
SWEP.TracerWidth = 1
SWEP.Tracer = "tracer_red"
SWEP.HullSize = 1

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 32

SWEP.Recoil = 1.05
SWEP.RecoilSide = 0.34
SWEP.RecoilRise = 0.65
SWEP.MaxRecoilBlowback = 1
SWEP.RecoilPunch = 1
SWEP.RecoilVMShake = 1

SWEP.Delay = 60 / 280
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
    {
		Mode = 2,
    },
	{
		Mode = 0,
   	}
}

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.AccuracyMOA = 0
SWEP.HipDispersion = 200
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.955
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "kraken/sops/k3bu.wav"
SWEP.ShootSound = "kraken/sops/k3bu.wav"
SWEP.DistantShootSound = "ArcCW_Kraken.StandardCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "blaster_muzzle_red"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(250, 0, 0)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-4.178, 0, 1.338),
    Ang = Vector(0, 0, 0),
     Magnification = 1.5,
     SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
     SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
     ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "ar2"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.SprintPos = Vector(2, -1, 0)
SWEP.SprintAng = Angle(-10, 26, 0)

SWEP.CustomizePos = Vector(10, 0, 2)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.CrouchPos = Vector(-3, 0, 0)
SWEP.CrouchAng = Angle(0, 0, 0)

SWEP.ActivePos = Vector(-3, 0, 0.5)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.HolsterPos = Vector(4, -3, 0)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments
SWEP.DefaultElements = {"muzzle"}
SWEP.AttachmentElements = {
    ["muzzle"] = {
        VMElements = {
           {
               Model = "models/hunter/plates/plate.mdl",
               Bone = "dc15s",
               Scale = Vector(0, 0, 0),                
               Offset = {
                   pos = Vector(-0.25, 0, 15),
                   ang = Angle(90, 0, 0),
               },
               IsMuzzleDevice = true,
           }
        }, 
    },
}

SWEP.Attachments = {     
    {
        PrintName = "Sight", 
        DefaultAttName = "None",
        Slot = "optic",
        Bone = "dc15s",
        VMScale = Vector(0.9,0.9,0.9),
        WMScale = Vector(0.9,0.9,0.9),
        Offset = {
            vpos = Vector(-0.17, -1.55, 0),
            vang = Angle(90, 0, -90),
        },
        CorrectivePos = Vector(0, 0, 0),
        CorrectiveAng = Angle(0, 0, 0),
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
        VMScale = Vector(1.3,1.3,1.3),
        WMScale = Vector(1.3,1.3,1.3),
        Bone = "dc15s",
        Offset = {
            vpos = Vector(-0.25, -0.7, 19),
            vang = Angle(90, 0, -90),
        },
        CorrectivePos = Vector(0, 0, 0),
        CorrectiveAng = Angle(0, 0, 0),
    },
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol"},
        Bone = "dc15s",
        VMScale = Vector(1,1,1),
        WMScale = Vector(1,1,1),
        Offset = {
            vpos = Vector(-0.14, 0.65, 15),
            vang = Angle(90, 0, -90),
        },
    },
    {
        PrintName = "Energization",
        DefaultAttName = "None",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Bone = "dc15s",
        Offset = {
            vpos = Vector(0.47, 0.9, 2.3),
            vang = Angle(90, 0, -90),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        VMScale = Vector(1,1,1),
        WMScale = Vector(1,1,1),
        Bone = "dc15s",
        Offset = {
            vpos = Vector(0.35, -0.3, -1),
            vang = Angle(90, 0, -90),
        },
    },   
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["idle_iron"] = {
        Source = "idle",
    },
	["fire"] = {
        Source = {"shoot"},
    },
    ["fire_iron"] = {
        Source = {"shoot"},
    },
    ["fix"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        Mult = 1.1,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatFix", t = 60 / 30},
            {s = "ArcCW_Kraken.Grab", t = 65 / 30},
        },
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        Mult = 1.4,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 80 / 30},
            {s = "ArcCW_Kraken.Grab", t = 85 / 30},
        },
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
}
--PATH addons/[bronie] arccw-special-forces-v3-1/lua/weapons/arccw_sops_republic_773firepuncher_short.lua:
return gluapack()()
--PATH addons/[bronie] arccw-special-forces-v3-1/lua/weapons/arccw_sops_republic_dc19.lua:
return gluapack()()
--PATH addons/[bronie] arccw-special-forces-v3-1/lua/weapons/arccw_sops_republic_dlt23v.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/entities/weapons/arrest_stick/shared.lua:
return gluapack()()
--PATH lua/weapons/awhg_bobs_gun_base/shared.lua:
DEFINE_BASECLASS("tfa_gun_base")
--PATH lua/weapons/ce_bcr_config.lua:
return gluapack()()
--PATH addons/[technik] darkrp-city-worker/lua/weapons/cityworker_shovel.lua:
SWEP.PrintName              = "Shovel"
SWEP.Author                 = "Silhouhat"
SWEP.Purpose                = "City Worker"
SWEP.Instructions           = "LMB to clear rubble"

SWEP.Category               = "City Worker"
SWEP.Spawnable              = false

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= -1
SWEP.Primary.Automatic		= true
SWEP.Primary.Ammo		    = "none"

SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Automatic	= false
SWEP.Secondary.Ammo		    = "none"

SWEP.Weight			        = 5
SWEP.AutoSwitchTo		    = false
SWEP.AutoSwitchFrom		    = false

SWEP.Slot			        = 2
SWEP.SlotPos			    = 1
SWEP.DrawAmmo			    = false
SWEP.DrawCrosshair		    = true

SWEP.ViewModel			    = "models/props_junk/shovel01a.mdl"
SWEP.WorldModel			    = "models/props_junk/shovel01a.mdl"

function SWEP:Initialize()
    self:SetHoldType( "melee2" )
end

function SWEP:PrimaryAttack()
    if CLIENT then return end
    if not IsFirstTimePredicted() then return end

    self:SetNextPrimaryFire( CurTime() + 1 )

    local ent = self.Owner:GetEyeTrace().Entity
    if not IsValid( ent ) then return end
    if ent:GetClass() != "cityworker_rubble" then return end
    if ent:GetPos():Distance( self.Owner:GetPos() ) > 200 then return end

    CITYWORKER.Begin( self.Owner, ent )
end

function SWEP:SecondaryAttack()
    return
end

function SWEP:Reload()
    return
end

function SWEP:DrawWorldModel()
    if not IsValid( self.Owner ) then return end

    local pos, ang = self.Owner:GetBonePosition( self.Owner:LookupBone( "ValveBiped.Bip01_R_Hand" ) )
    local offsetPos = ang:Right() * 1 + ang:Forward() * 2 + ang:Up() * 5

    ang:RotateAroundAxis( ang:Right(), 0 )
    ang:RotateAroundAxis( ang:Forward(), 180 )
    ang:RotateAroundAxis( ang:Up(), 0 )

    self:SetRenderOrigin( pos + offsetPos )
    self:SetRenderAngles( ang )

    self:DrawModel()
end

function SWEP:GetViewModelPosition( pos, ang )
    pos = pos + ang:Right() * 20 + ang:Forward() * 35 + ang:Up() * -18

    ang:RotateAroundAxis( ang:Up(), 0 )
    ang:RotateAroundAxis( ang:Right(), 180 )

    return pos, ang
end
--PATH addons/[technik] darkrp-city-worker/lua/weapons/cityworker_wrench.lua:
return gluapack()()
--PATH addons/[technik] darkrp-city-worker/lua/weapons/cityworker_wrench.lua:
SWEP.PrintName              = "Wrench"
SWEP.Author                 = "Silhouhat"
SWEP.Purpose                = "City Worker"
SWEP.Instructions           = "LMB to tighten leak"

SWEP.Category               = "City Worker"
SWEP.Spawnable              = false

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= -1
SWEP.Primary.Automatic		= true
SWEP.Primary.Ammo		    = "none"

SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Automatic	= false
SWEP.Secondary.Ammo		    = "none"

SWEP.Weight			        = 5
SWEP.AutoSwitchTo		    = false
SWEP.AutoSwitchFrom		    = false

SWEP.Slot			        = 2
SWEP.SlotPos			    = 1
SWEP.DrawAmmo			    = false
SWEP.DrawCrosshair		    = true

SWEP.ViewModel			    = "models/props_c17/tools_wrench01a.mdl"
SWEP.WorldModel			    = "models/props_c17/tools_wrench01a.mdl"

function SWEP:Initialize()
    self:SetHoldType( "melee" )
end

function SWEP:PrimaryAttack()
    if CLIENT then return end
    if not IsFirstTimePredicted() then return end

    self:SetNextPrimaryFire( CurTime() + 1 )

    local ent = self.Owner:GetEyeTrace().Entity
    if not IsValid( ent ) then return end
    if ent:GetClass() == "cityworker_leak" or ( ent:GetClass() == "cityworker_hydrant" and ent:GetLeaking() ) then 
        if ent:GetPos():Distance( self.Owner:GetPos() ) > 200 then return end

        CITYWORKER.Begin( self.Owner, ent ) 
    end
end

function SWEP:SecondaryAttack()
    return
end

function SWEP:Reload()
    return
end

function SWEP:DrawWorldModel()
    if not IsValid( self.Owner ) then return end

    local pos, ang = self.Owner:GetBonePosition( self.Owner:LookupBone( "ValveBiped.Bip01_R_Hand" ) )
    local offsetPos = ang:Right() * 1 + ang:Forward() * 3 + ang:Up() * -2

    ang:RotateAroundAxis( ang:Right(), 0 )
    ang:RotateAroundAxis( ang:Forward(), 90 )
    ang:RotateAroundAxis( ang:Up(), 180 )

    self:SetRenderOrigin( pos + offsetPos )
    self:SetRenderAngles( ang )

    self:DrawModel()
end

function SWEP:GetViewModelPosition( pos, ang )
    pos = pos + ang:Right() * 9 + ang:Forward() * 18 + ang:Up() * -9

    ang:RotateAroundAxis( ang:Right(), 90 )
    ang:RotateAroundAxis( ang:Up(), -90 )

    return pos, ang
end
--PATH lua/weapons/cloaking-1/shared.lua:
return gluapack()()
--PATH lua/weapons/ce_bcr_config.lua:
AddCSLuaFile()


-- Per Person Setting

CreateClientConVar("bc2_ShowCloakCharge", 1, false, false, "")

-- Visual

CreateConVar("bc2_CloakType", "Transparent", FCVAR_ARCHIVE, "")
CreateConVar("bc2_CloakMode", "Timer", FCVAR_ARCHIVE, "")
CreateConVar("bc2_CloakUntilVel", 75, FCVAR_ARCHIVE, "")
CreateConVar("bc2_MinimumVisibility", 0, FCVAR_ARCHIVE, "")
CreateConVar("bc2_CloakMaterial", "", FCVAR_ARCHIVE, "")
CreateConVar("bc2_ChargeGainMultiplier", 1, FCVAR_ARCHIVE, "")
CreateConVar("bc2_ChargeLossMultiplier", 1, FCVAR_ARCHIVE, "")
CreateConVar("bc2_MaxCharge1", 10, FCVAR_ARCHIVE, "")
CreateConVar("bc2_MaxCharge2", 20, FCVAR_ARCHIVE, "")
CreateConVar("bc2_MaxCharge3", 30, FCVAR_ARCHIVE, "")
CreateConVar("bc2_MinimumNPCVisibility", 70, FCVAR_ARCHIVE, "")
CreateConVar("bc2_UncloakInVehicle", 1, FCVAR_ARCHIVE, "")
CreateConVar("bc2_CloakOverlay", "", FCVAR_ARCHIVE, "")
CreateConVar("bc2_MinimumIDVisibility", 70, FCVAR_ARCHIVE, "")
CreateConVar("bc2_CloakFireMode", 3, FCVAR_ARCHIVE, "")
CreateConVar("bc2_LoseChargeAmountFire", 5, FCVAR_ARCHIVE, "")
CreateConVar("bc2_TempDisableTimeFire", 2, FCVAR_ARCHIVE, "")
CreateConVar("bc2_CloakDamageMode", 3, FCVAR_ARCHIVE, "")
CreateConVar("bc2_LoseChargeAmountHurt", 5, FCVAR_ARCHIVE, "")
CreateConVar("bc2_TempDisableTimeHurt", 2, FCVAR_ARCHIVE, "")
CreateConVar("bc2_CloakEffectOn", "", FCVAR_ARCHIVE, "")
CreateConVar("bc2_CloakEffectOff", "", FCVAR_ARCHIVE, "")
CreateConVar("bc2_ToggleTime", 3, FCVAR_ARCHIVE, "")

-- Audio

CreateConVar("bc2_DistortSound", 14, FCVAR_ARCHIVE, "")
CreateConVar("bc2_EnableSound", "npc/sniper/reload1.wav", FCVAR_ARCHIVE, "")
CreateConVar("bc2_DisableSound", "AlyxEMP.Discharge", FCVAR_ARCHIVE, "")
CreateConVar("bc2_ForceDisableSound", "npc/roller/mine/combine_mine_deactivate1.wav", FCVAR_ARCHIVE, "")
CreateConVar("bc2_ToggleFailureSound", "npc/roller/mine/combine_mine_deploy1.wav", FCVAR_ARCHIVE, "")
CreateConVar("bc2_FootstepVolume", 0, FCVAR_ARCHIVE, "")
CreateConVar("bc2_TauntSound", "", FCVAR_ARCHIVE, "")
CreateConVar("bc2_TauntVolume", 1, FCVAR_ARCHIVE, "")
CreateConVar("bc2_TauntDelay", 4, FCVAR_ARCHIVE, "")

hook.Add( "PopulateToolMenu", "ce_bc2_configmenu", function()
	spawnmenu.AddToolMenuOption( "Utilities", "JustCrimson", "ce_bc2_config", "Better Cloaking Config", "", "", function( panel )
		panel:ClearControls()
		local CloakTypeBox = panel:ComboBox("Cloak Type", "bc2_CloakType")
		
		CloakTypeBox:AddChoice("Transparent")
		CloakTypeBox:AddChoice("Material")
		
		local CloakModeBox = panel:ComboBox("Cloak Mode", "bc2_CloakMode")
		CloakModeBox:AddChoice("Timer")
		CloakModeBox:AddChoice("Charge")

		panel:TextEntry("Movement Sensitivity", "bc2_CloakUntilVel"):SetNumeric(true)

		panel:TextEntry("Toggle Time", "bc2_ToggleTime"):SetNumeric(true)

		panel:NumSlider("Minimum Visibility", "bc2_MinimumVisibility", 0, 255, 0)

		panel:TextEntry("Cloak Material", "bc2_CloakMaterial")

		local SoundDistortBox = panel:ComboBox("Sound Distortion", "bc2_DistortSound")
		SoundDistortBox:AddChoice("None", 0)
		SoundDistortBox:AddChoice("Light", 14)
		SoundDistortBox:AddChoice("Medium", 15)
		SoundDistortBox:AddChoice("Heavy", 16)

		panel:TextEntry("Enable Sound", "bc2_EnableSound")
		panel:TextEntry("Disable Sound", "bc2_DisableSound")
		panel:TextEntry("Toggle Fail Sound", "bc2_ToggleFailureSound")
		panel:TextEntry("Force Disable Sound", "bc2_ForceDisableSound")


		panel:NumSlider("Visibility For NPC Target", "bc2_MinimumNPCVisibility", 0, 255, 0)
		panel:NumSlider("Visibility To Show ID", "bc2_MinimumIDVisibility", 0, 255, 0)

		panel:NumSlider("Footstep Volume", "bc2_FootstepVolume", 0, 1, 2)

		panel:CheckBox("Uncloak In Vehicle", "bc2_UncloakInVehicle")

		panel:TextEntry("Cloak Overlay", "bc2_CloakOverlay")

		local CloakShootMode = panel:ComboBox("Shooting While Cloaked Mode", "bc2_CloakFireMode")
		CloakShootMode:AddChoice("Disable Cloak", 1)
		CloakShootMode:AddChoice("Lose Charge", 2)
		CloakShootMode:AddChoice("Temp Disable", 3)
		CloakShootMode:AddChoice("Nothing", 4)

		panel:TextEntry("Shooting Lose Charge Amount", "bc2_LoseChargeAmountFire"):SetNumeric(true)
		panel:TextEntry("Shooting Temp Disable Time", "bc2_TempDisableTimeFire"):SetNumeric(true)

		panel:TextEntry("Cloak 1 Max Charge", "bc2_MaxCharge1"):SetNumeric(true)
		panel:TextEntry("Cloak 2 Max Charge", "bc2_MaxCharge2"):SetNumeric(true)
		panel:TextEntry("Cloak 3 Max Charge", "bc2_MaxCharge3"):SetNumeric(true)

		panel:TextEntry("Charge Gain Multiplier", "bc2_ChargeGainMultiplier"):SetNumeric(true)
		panel:TextEntry("Charge Loss Multiplier", "bc2_ChargeLossMultiplier"):SetNumeric(true)

		local CloakDamageMode = panel:ComboBox("Damaged While Cloaked Mode", "bc2_CloakDamageMode")
		CloakDamageMode:AddChoice("Disable Cloak", 1)
		CloakDamageMode:AddChoice("Lose Charge", 2)
		CloakDamageMode:AddChoice("Temp Disable", 3)
		CloakDamageMode:AddChoice("Nothing", 4)
		
		panel:TextEntry("Damaged Lose Charge Amount", "bc2_LoseChargeAmountHurt"):SetNumeric(true)
		panel:TextEntry("Damaged Temp Disable Time", "bc2_TempDisableTimeHurt"):SetNumeric(true)

		panel:TextEntry("Cloak Enable Effect", "bc2_CloakEffectOn")
		panel:TextEntry("Cloak Disable Effect", "bc2_CloakEffectOff")

		panel:TextEntry("Taunt Sound", "bc2_TauntSound")
		panel:NumSlider("Taunt Volume", "bc2_TauntVolume", 0, 1, 2)
		panel:TextEntry("Taunt Delay", "bc2_TauntDelay"):SetNumeric(true)

	end )
end )

cloakconfig = {}

-- Visual
cloakconfig["CloakType"] = GetConVar("bc2_CloakType"):GetString()
cloakconfig["CloakMode"] = GetConVar("bc2_CloakMode"):GetString()
cloakconfig["CloakUntilVel"] = GetConVar("bc2_CloakUntilVel"):GetInt()
cloakconfig["MinimumVisibility"] = GetConVar("bc2_MinimumVisibility"):GetInt()
cloakconfig["CloakMaterial"] = GetConVar("bc2_CloakMaterial"):GetString()
cloakconfig["ChargeGainMultiplier"] = GetConVar("bc2_ChargeGainMultiplier"):GetFloat()
cloakconfig["ChargeLossMultiplier"] = GetConVar("bc2_ChargeLossMultiplier"):GetFloat()
cloakconfig["MaxCharge0"] = 0
cloakconfig["MaxCharge1"] = GetConVar("bc2_MaxCharge1"):GetInt()
cloakconfig["MaxCharge2"] = GetConVar("bc2_MaxCharge2"):GetInt()
cloakconfig["MaxCharge3"] = GetConVar("bc2_MaxCharge3"):GetInt()
cloakconfig["MinimumNPCVisibility"] = GetConVar("bc2_MinimumNPCVisibility"):GetInt()
cloakconfig["UncloakInVehicle"] = GetConVar("bc2_UncloakInVehicle"):GetBool()
cloakconfig["CloakOverlay"] = GetConVar("bc2_CloakOverlay"):GetString()
cloakconfig["MinimumIDVisibility"] = GetConVar("bc2_MinimumIDVisibility"):GetInt()
cloakconfig["CloakFireMode"] = GetConVar("bc2_CloakFireMode"):GetInt()
cloakconfig["LoseChargeAmountFire"] = GetConVar("bc2_LoseChargeAmountFire"):GetFloat()
cloakconfig["TempDisableTimeFire"] = GetConVar("bc2_TempDisableTimeFire"):GetFloat()
cloakconfig["CloakDamageMode"] = GetConVar("bc2_CloakDamageMode"):GetInt()
cloakconfig["LoseChargeAmountHurt"] = GetConVar("bc2_LoseChargeAmountHurt"):GetFloat()
cloakconfig["TempDisableTimeHurt"] = GetConVar("bc2_TempDisableTimeHurt"):GetFloat()
cloakconfig["CloakEffectOn"] = GetConVar("bc2_CloakEffectOn"):GetString()
cloakconfig["CloakEffectOff"] = GetConVar("bc2_CloakEffectOff"):GetString()
cloakconfig["ToggleTime"] = GetConVar("bc2_ToggleTime"):GetFloat()
-- Audio
cloakconfig["DistortSound"] = GetConVar("bc2_DistortSound"):GetInt()
cloakconfig["EnableSound"] = GetConVar("bc2_EnableSound"):GetString()
cloakconfig["DisableSound"] = GetConVar("bc2_DisableSound"):GetString()
cloakconfig["ForceDisableSound"] = GetConVar("bc2_ForceDisableSound"):GetString()
cloakconfig["ToggleFailureSound"] = GetConVar("bc2_ToggleFailureSound"):GetString()
cloakconfig["FootstepVolume"] = GetConVar("bc2_FootstepVolume"):GetFloat()
cloakconfig["TauntSound"] = GetConVar("bc2_TauntSound"):GetString()
cloakconfig["TauntVolume"] = GetConVar("bc2_TauntVolume"):GetFloat()
cloakconfig["TauntDelay"] = GetConVar("bc2_TauntDelay"):GetFloat()




for k,v in pairs(cloakconfig) do
    cvars.AddChangeCallback(k, function(convarName, oldValue, newValue) 

            tableCV[convarName] = newValue


    end)
end
--PATH lua/weapons/gmod_tool/stools/hologramtool.lua:
TOOL.Category = "Ace's Tools"
TOOL.Name = "Hologram Maker"
TOOL.Command = nil
TOOL.ConfigName = ""

if(CLIENT) then
	language.Add("tool.hologramtool.name","Hologram Maker")
	language.Add("tool.hologramtool.desc","Enable/Disable hologram FX on an entity")
	language.Add("tool.hologramtool.0","Left click to enable/disable hologram FX for the entity you're looking at. Right click to enable/disable hologram FX for yourself.")
	
	function TOOL.BuildCPanel(pnl)
		pnl:AddControl("Header",{Text = "Hologram Tool",Description = [[Left-Click to enable/disable hologram FX for the entity you're looking at.
		Right click to enable/disable hologram FX for yourself.
		]]})
	end
end
Hologram = Hologram or {}

Hologram.EntsCache = Hologram.EntsCache or {}
if SERVER then
	util.AddNetworkString("Hologram.Tool.UpdateEntity")
end
function TOOL:LeftClick(tr)
	--if not IsFirstTimePredicted() then return end
	if(CLIENT) then return true end
	local bIsHologram = tr.Entity:GetNWBool("entIsHologram")

	if(tr.Entity:IsValid() && !tr.Entity:IsWorld()) then
		if ( !bIsHologram ) then
			tr.Entity:SetNWBool("entIsHologram", true)
			Hologram.EntsCache[tr.Entity:EntIndex()] = true
			net.Start("Hologram.Tool.UpdateEntity")
				net.WriteUInt(tr.Entity:EntIndex(), 16)
				net.WriteBool(true)
			net.Broadcast()
		else
			tr.Entity:SetNWBool("entIsHologram", false)
			Hologram.EntsCache[tr.Entity:EntIndex()] = nil
			net.Start("Hologram.Tool.UpdateEntity")
				net.WriteUInt(tr.Entity:EntIndex(), 16)
				net.WriteBool(false)
			net.Broadcast()

		end
		if SERVER then
			local l = "notification.AddLegacy(\"" .. (bIsHologram && "Disabled " || "Enabled ") .. "hologram FX for \" .. SQLStr(language.GetPhrase(\"#" .. tr.Entity:GetClass() .. "\")) .. \".\",0,5);"
			l = l .. "surface.PlaySound(\"buttons/button14.wav\")"
			self:GetOwner():SendLua(l)
		end
		return true
	end
end

function TOOL:RightClick(tr)
	--if not IsFirstTimePredicted() then return end
	if(CLIENT) then return true end
	local owner = self:GetOwner()
	local bIsHologram = owner:GetNWBool("entIsHologram")

	if ( !bIsHologram ) then
		owner:SetNWBool("entIsHologram", true)
		Hologram.EntsCache[owner:EntIndex()] = true
		net.Start("Hologram.Tool.UpdateEntity")
			net.WriteUInt(owner:EntIndex(), 16)
			net.WriteBool(true)
		net.Broadcast()

	else
		owner:SetNWBool("entIsHologram", false)
		Hologram.EntsCache[owner:EntIndex()] = nil
		net.Start("Hologram.Tool.UpdateEntity")
			net.WriteUInt(owner:EntIndex(), 16)
			net.WriteBool(false)
		net.Broadcast()
	end

	if SERVER then
		local l = "notification.AddLegacy(\"" .. (bIsHologram && "Disabled " || "Enabled ") .. "hologram FX for " .. SQLStr(owner:GetName()) .. ".\",0,5);"
		l = l .. "surface.PlaySound(\"buttons/button14.wav\")"
		owner:SendLua(l)
	end
	return false
end
--PATH addons/[misc] smartspawnmanager/lua/weapons/gmod_tool/stools/smart_player_spawn.lua:
//
/*
	Smart Prop Control - Ghost Zone Tool 
	Smart Like My Shoe 
	3/3/2018
*/


TOOL.Category       = "Smart' s Tools";
TOOL.Name           = "#Player Spawns";
TOOL.Command        = nil;
TOOL.ConfigName     = "";
 
TOOL.ClientConVar["auto_uniqueid"]			 	= "0";
TOOL.ClientConVar["team"]			 			= "Default";
TOOL.ClientConVar["uniqueid"]			 		= "Default";

function TOOL:LeftClick(trace)
	
	local autoGenerateUniqueID = self:GetClientInfo("auto_uniqueid");
	local teamName = self:GetClientInfo("team");
	local uniqueID = self:GetClientInfo("uniqueid");
	
	hook.Call("smartspawn_addplayerspawn", nil, teamName, uniqueID, trace.HitPos, autoGenerateUniqueID);
	return true;
end

function TOOL:RightClick(trace)
	
	hook.Call("smartspawn_removeplayerspawnbyposition", nil, trace.HitPos);
	return true;
end 

function TOOL:Reload(trace)
	
end

function TOOL:Deploy()
end 

function TOOL:Holster()
end 

function TOOL:Think()

end 

if (CLIENT) then 

	// Top left hud language strings
	language.Add("Tool.smart_player_spawn.name", "Player Spawn Manager");
    language.Add("Tool.smart_player_spawn.desc", "Manage player spawn locations.");
    language.Add("Tool.smart_player_spawn.0", "Primary: Create spawn location | Secondary: Remove spawn location");
	
	// Undo language 
	//language.Add("Undone_smart_npc", "Undone Smart Npc!");
	
	// Derma utility methods 
	local function MakeLabel(text, font)
	
		font = font || "Trebuchet18";
	
		local l = vgui.Create("DLabel");
		l:SetText(text);
		l:SetFont(font);
		l:SetTextColor(Color(0,0,0,255));
		l:SizeToContents();
		
		return l;
	end
	
	// Control panel (derma)
	local function BuildCPanel(panel)
		panel:ClearControls();
		
		panel:AddItem(MakeLabel("Team"));
		
		local teamSelect = vgui.Create("DComboBox");
		for teamID, teamTable in next, team.GetAllTeams() do 
			teamSelect:AddChoice(teamTable.Name, teamID);
		end
		teamSelect:AddChoice("All Teams", "all");
		teamSelect.OnSelect = function(s, index, value, data)
	
			if (value == "All Teams") then 
				RunConsoleCommand("smart_player_spawn_team", data);
			else 
				RunConsoleCommand("smart_player_spawn_team", value);
			end
		end
		teamSelect:ChooseOptionID(2);
		panel:AddItem(teamSelect);
		
		panel:AddItem(MakeLabel("Unique ID"));
		
		local uniqueID = vgui.Create("DTextEntry");
		uniqueID:SetText("Some Unique Name");
		uniqueID.OnValueChange = function(s, value)
			RunConsoleCommand("smart_player_spawn_uniqueid", value);
		end
		uniqueID:SetUpdateOnType(true);
		
		panel:AddItem(uniqueID);
		
		local autoUniqueID = vgui.Create("DCheckBoxLabel");
		autoUniqueID:SetText("Automatically generate unique ID");
		autoUniqueID:SetTextColor(color_black);
		autoUniqueID:SetConVar("smart_player_spawn_auto_uniqueid");
		panel:AddItem(autoUniqueID);
	end
	
	// Called when player selects this tool for the first time
    function TOOL.BuildCPanel(panel)
		
        BuildCPanel(panel);
    end
	
	local function UpdateCPanel()
		local panel = controlpanel.Get("smart_player_spawn");
        if (!panel) then 
			return;
		end
        BuildCPanel(panel);
    end
    concommand.Add("smart_player_spawn_tool_updatecpanel", UpdateCPanel);
end
--PATH lua/weapons/gmod_tool/stools/streamradio_gui_color_individual.lua:
TOOL.Category = "Stream Radio"
TOOL.Name = "#Tool." .. TOOL.Mode .. ".name"

TOOL.Information = {
	{ name = "left" },
	{ name = "right" },
}

TOOL.SkinVars = {
	color = {
		default = Color(255, 255, 255, 255),
		order = 1,
	},

	color_foreground = {
		default = Color(0, 0, 0, 255),
		order = 2,
	},

	color_icon = {
		default = Color(255, 255, 255, 255),
		order = 3,
	},

	color_shadow = {
		default = Color(64, 64, 64, 255),
		order = 4,
	},

	color_hover = {
		default = Color(192, 192, 192, 255),
		order = 5,
	},

	color_foreground_hover = {
		default = Color(0, 0, 0, 255),
		order = 6,
	},

	color_icon_hover = {
		default = Color(255, 255, 255, 255),
		order = 7,
	},

	color_disabled = {
		default = Color(128, 128, 128, 255),
		order = 8,
	},

	color_foreground_disabled = {
		default = Color(255, 255, 255, 255),
		order = 9,
	},

	color_icon_disabled = {
		default = Color(255, 255, 255, 255),
		order = 10,
	},
}

for varname, v in pairs(TOOL.SkinVars) do
	local color = v.default or Color(255, 255, 255, 255)

	TOOL.ClientConVar[varname .. "_t"] = "1"
	TOOL.ClientConVar[varname .. "_r"] = color.r
	TOOL.ClientConVar[varname .. "_g"] = color.g
	TOOL.ClientConVar[varname .. "_b"] = color.b
	TOOL.ClientConVar[varname .. "_a"] = color.a
end

if StreamRadioLib and StreamRadioLib.Loaded then
	StreamRadioLib.Tool.RegisterClientToolHook(TOOL, "LeftClick")
	StreamRadioLib.Tool.RegisterClientToolHook(TOOL, "RightClick")
	StreamRadioLib.Tool.RegisterClientToolHook(TOOL, "Holster")

	StreamRadioLib.Tool.AddLocale(TOOL, "name", "Radio Colorer (Individual)")
	StreamRadioLib.Tool.AddLocale(TOOL, "desc", "Change colors of aimed radio GUI panels")

	StreamRadioLib.Tool.AddLocale(TOOL, "left", "Apply colors of radio GUI panels")
	StreamRadioLib.Tool.AddLocale(TOOL, "right", "Copy the colors from radio GUI panels")

	StreamRadioLib.Tool.AddLocale(TOOL, "list", "List of changeable colors:")
	StreamRadioLib.Tool.AddLocale(TOOL, "color", "Selected color:")

	StreamRadioLib.Tool.AddLocale(TOOL, "list.common.active.desc", "If checked the color will be applied on left click.\nUncheck this if you don't want to change this color on a panel.")

	StreamRadioLib.Tool.AddLocale(TOOL, "list.color", "Background")
	StreamRadioLib.Tool.AddLocale(TOOL, "list.color.desc", "Color of the background.")

	StreamRadioLib.Tool.AddLocale(TOOL, "list.color_foreground", "Foreground/Text")
	StreamRadioLib.Tool.AddLocale(TOOL, "list.color_foreground.desc", "Color of the foreground such as texts or spectrum bars.")

	StreamRadioLib.Tool.AddLocale(TOOL, "list.color_icon", "Icon")
	StreamRadioLib.Tool.AddLocale(TOOL, "list.color_icon.desc", "Color of the icons.")

	StreamRadioLib.Tool.AddLocale(TOOL, "list.color_shadow", "Shadow")
	StreamRadioLib.Tool.AddLocale(TOOL, "list.color_shadow.desc", "Color of the shadow.")

	StreamRadioLib.Tool.AddLocale(TOOL, "list.color_hover", "[Button only] Hover Background")
	StreamRadioLib.Tool.AddLocale(TOOL, "list.color_hover.desc", "Color of the background when hovered. (Button only)")

	StreamRadioLib.Tool.AddLocale(TOOL, "list.color_foreground_hover", "[Button only] Hover Foreground/Text")
	StreamRadioLib.Tool.AddLocale(TOOL, "list.color_foreground_hover.desc", "Color of the foreground when hovered. (Button only)")

	StreamRadioLib.Tool.AddLocale(TOOL, "list.color_icon_hover", "[Button only] Hover Icon")
	StreamRadioLib.Tool.AddLocale(TOOL, "list.color_icon_hover.desc", "Color of the icon when hovered. (Button only)")

	StreamRadioLib.Tool.AddLocale(TOOL, "list.color_disabled", "[Button only] Disabled Background")
	StreamRadioLib.Tool.AddLocale(TOOL, "list.color_disabled.desc", "Color of the background when disabled. (Button only)")

	StreamRadioLib.Tool.AddLocale(TOOL, "list.color_foreground_disabled", "[Button only] Disabled Foreground/Text")
	StreamRadioLib.Tool.AddLocale(TOOL, "list.color_foreground_disabled.desc", "Color of the foreground when disabled. (Button only)")

	StreamRadioLib.Tool.AddLocale(TOOL, "list.color_icon_disabled", "[Button only] Disabled Icon")
	StreamRadioLib.Tool.AddLocale(TOOL, "list.color_icon_disabled.desc", "Color of the icon when disabled. (Button only)")

	StreamRadioLib.Tool.Setup(TOOL)
else
	TOOL.Information = nil

	if CLIENT then
		local StreamRadioLib = StreamRadioLib or {}
		local _mode = TOOL.Mode

		language.Add("Tool." .. _mode .. ".name", "Radio Colorer (Individual)")
		language.Add("Tool." .. _mode .. ".desc", "Change colors of aimed radio GUI panels")
		language.Add("Tool." .. _mode .. ".0", "This tool could not be loaded.")

		function TOOL.BuildCPanel(CPanel)
			if StreamRadioLib.Loader_CreateErrorPanel then
				StreamRadioLib.Loader_CreateErrorPanel(CPanel, "This tool could not be loaded.")
			end
		end
	end
end

function TOOL:IsValid()
	return IsValid(self:GetSWEP()) and IsValid(self:GetOwner())
end

function TOOL:GetColors(forceall)
	local data = {}

	for varname, v in pairs(self.SkinVars) do
		if not forceall then
			local ticked = self:GetClientBool(varname .. "_t")
			if not ticked then continue end
		end

		local r = self:GetClientNumber(varname .. "_r")
		local g = self:GetClientNumber(varname .. "_g")
		local b = self:GetClientNumber(varname .. "_b")
		local a = self:GetClientNumber(varname .. "_a")

		data[varname] = Color(r, g, b, a)
	end

	return data
end

function TOOL:SetColors(data)
	data = data or {}

	for varname, v in pairs(self.SkinVars) do
		local color = data[varname] or v.default or Color(255, 255, 255, 255)

		self:SetClientNumber(varname .. "_r", color.r)
		self:SetClientNumber(varname .. "_g", color.g)
		self:SetClientNumber(varname .. "_b", color.b)
		self:SetClientNumber(varname .. "_a", color.a)
	end
end

function TOOL:AddModeList( panel )
	local listpanel = vgui.Create( "DListView" )
	panel:AddPanel(listpanel)

	listpanel:SetMultiSelect(false)

	local col1 = listpanel:AddColumn("No.")
	listpanel:AddColumn("Item")
	local col3 = listpanel:AddColumn("Color")
	local col4 = listpanel:AddColumn("Active")

	col1:SetFixedWidth(30)
	col3:SetMinWidth(40)
	col3:SetMaxWidth(70)
	col4:SetFixedWidth(40)

	local lines = {}

	listpanel.NextConVarCheck = 0

	local update = function()
		if not IsValid(self) then return end
		if not IsValid(listpanel) then return end

		local data = self:GetColors(true)
		local changed = false

		if ( input.IsMouseDown( MOUSE_LEFT ) ) then return end
		if ( listpanel.NextConVarCheck > RealTime() ) then return end

		listpanel.NextConVarCheck = RealTime() + 0.2

		for varname, line in pairs(lines) do
			if not self.SkinVars[varname] then continue end
			if not IsValid(line) then continue end

			local colortile = line.Columns[line._colorindex]
			if not IsValid(colortile) then continue end

			local activecheckbox = line.Columns[line._activeindex]
			if not IsValid(activecheckbox) then continue end

			local color = data[varname]
			if not color then continue end

			local oldcolor = colortile:GetColor()
			if color == oldcolor then continue end

			colortile:SetColor(color)
			line:SetSortValue(line._colorindex, tostring(color))
			changed = true
		end

		if changed and listpanel.OnColorUpdate then
			listpanel:OnColorUpdate(data)
		end
	end

	local data = self:GetColors(true)

	for varname, color in pairs(data) do
		local colortile = vgui.Create( "DColorButton" )
		local activecheckbox = vgui.Create( "DCheckBoxLabel" )
		if not self.SkinVars[varname] then continue end

		activecheckbox:SetText("")
		activecheckbox:SetConVar(self.Mode .. "_" .. varname  .. "_t")
		activecheckbox:SetIndent(12)
		activecheckbox:SetTooltip(StreamRadioLib.Tool.GetLocaleTranslation(self, "list.common.active.desc"))

		local order = self.SkinVars[varname].order or 0

		local line = listpanel:AddLine(order, StreamRadioLib.Tool.GetLocaleTranslation(self, "list." .. varname), colortile, activecheckbox)
		colortile.DoClick = function()
			listpanel:ClearSelection()
			listpanel:SelectItem(line)
		end

		line:SetTooltip(StreamRadioLib.Tool.GetLocaleTranslation(self, "list." .. varname .. ".desc"))
		line:SetSortValue(1, order)

		line._colorindex = 3
		line._activeindex = 4

		activecheckbox.OnChange = function(this, value)
			local sort = value and 1 or 0
			sort = sort * 1000 - order

			line:SetSortValue(line._activeindex, sort)
		end

		line._varname = varname
		lines[varname] = line
	end

	listpanel:SetTall(230)
	listpanel:SortByColumn(1)

	listpanel.Think = function()
		update()
	end

	update()

	return listpanel
end


function TOOL:BuildToolPanel( CPanel )
	self:AddLabel(CPanel, "list")

	local listpanel = self:AddModeList(CPanel)
	local colorpanel = nil
	local selectedline = nil

	listpanel.OnRowSelected = function(this, LineID, Line)
		selectedline = Line
		if not IsValid(selectedline) then return end
		if not IsValid(colorpanel) then return end
		if not selectedline._varname then return end

		local precmd = self.Mode .. "_" .. selectedline._varname

		colorpanel:SetConVarR(precmd .. "_r")
		colorpanel:SetConVarG(precmd .. "_g")
		colorpanel:SetConVarB(precmd .. "_b")
		colorpanel:SetConVarA(precmd .. "_a")
		colorpanel.txtA:SetConVar(precmd .. "_a")

		local colortile = selectedline.Columns[selectedline._colorindex]
		if not IsValid(colortile) then return end
		colorpanel:SetColor(colortile:GetColor())
	end

	listpanel.DoDoubleClick = function(this, LineID, Line)
		if not IsValid(Line) then return end
		if not IsValid(colorpanel) then return end

		local activecheckbox = selectedline.Columns[selectedline._activeindex]
		if not IsValid(activecheckbox) then return end
		activecheckbox:Toggle()
	end

	listpanel.OnColorUpdate = function(this, data)
		this:OnRowSelected(selectedline:GetID(), selectedline)
	end

	self:AddLabel(CPanel, "color")
	colorpanel = self:AddColorMixer(CPanel)

	listpanel:SelectFirstItem()
end

function TOOL:HighlightHoverPanels(entgui, panels)
	if SERVER then return nil end

	if not IsValid(entgui._ToolHoverHighlighter) then
		entgui._ToolHoverHighlighter = entgui:AddPanelByClassname("highlighter")
		entgui._ToolHoverHighlighter:SetColor(Color(0, 0, 0, 0))
		entgui._ToolHoverHighlighter:SetBorderColor(Color(255, 255, 0, 255))
		entgui._ToolHoverHighlighter:SetBorderColor2(Color(0, 0, 0, 255))
		entgui._ToolHoverHighlighter:SetZPos(9999000)
	end

	if IsValid(self.highlighter_hover) then
		if self.highlighter_hover ~= entgui._ToolHoverHighlighter then
			self.highlighter_hover:Remove()
		end
	end

	local highlighter_hover = entgui._ToolHoverHighlighter
	self.highlighter_hover = highlighter_hover

	if not IsValid(highlighter_hover) then
		return nil
	end

	highlighter_hover:HighlightClear()
	highlighter_hover:HighlightPanels(panels)
	highlighter_hover:Open()

	return highlighter_hover
end

function TOOL:GetTopMostPanel(panels)
	local area = nil
	local panel = nil

	for i, v in ipairs(panels or {}) do
		if not IsValid(v) then continue end
		if not v:IsSkinAble() then continue end

		local w, h = v:GetSize()
		local a = w * h

		if not area or area >= a then
			area = a
			panel = v
		end
	end

	return panel
end

function TOOL:GetAimedObject(trace)
	if not self.ToolLibLoaded then return end

	trace = trace or self:GetFallbackTrace()

	if not trace then return end
	if not trace.Hit then return end

	local ent = trace.Entity
	local owner = self:GetOwner()

	if not self:IsValidGUIRadio(ent) then return end

	local hit, x, y = ent:GetCursor( owner, trace )
	if not hit then return end

	local entgui = ent:GetGUI()
	if not IsValid(entgui) then return end

	local aimedpanel = self:GetTopMostPanel(entgui:GetPanelsAtPos(x, y))
	if not IsValid(aimedpanel) then return end

	return aimedpanel, entgui, ent
end

function TOOL:GetSelectionPanels(entgui, aimedpanel)
	if not self.ToolLibLoaded then return end
	local skinhierarchy = aimedpanel:GetSkinIdentifyerHierarchy()
	local selectedpanels = entgui:GetPanelsBySkinIdentifyer(skinhierarchy)

	return selectedpanels
end

function TOOL:LeftClick(trace)
	if not self.ToolLibLoaded then return end
	local aimedpanel = self:GetAimedObject(trace)
	if not IsValid(aimedpanel) then return false end

	if CLIENT then return true end

	StreamRadioLib.Tool.CallClientToolHook(self, "LeftClick")
	return true
end

function TOOL:RightClick(trace)
	if not self.ToolLibLoaded then return end
	local aimedpanel = self:GetAimedObject(trace)
	if not IsValid(aimedpanel) then return false end

	if CLIENT then return true end

	StreamRadioLib.Tool.CallClientToolHook(self, "RightClick")
	return true
end

function TOOL:LeftClickClient()
	if not self.ToolLibLoaded then return end
	local aimedpanel, entgui = self:GetAimedObject()
	if not IsValid(aimedpanel) then return end

	local skinhierarchy = aimedpanel:GetSkinIdentifyerHierarchy()
	if not skinhierarchy then return false end

	local data = self:GetColors()

	for varname, color in pairs(data) do
		local global = self.SkinVars[varname].global

		if global then
			entgui:SetSkinPropertyOnServer("", varname, color)
			continue
		end

		entgui:SetSkinPropertyOnServer(skinhierarchy, varname, color)
	end
end

function TOOL:RightClickClient()
	if not self.ToolLibLoaded then return end
	local aimedpanel, entgui = self:GetAimedObject()
	if not IsValid(aimedpanel) then return end

	local skindata = aimedpanel:GetSkinValues() or {}

	for varname, v in pairs(self.SkinVars) do
		if not v.global then continue end
		skindata[varname] = entgui:GetSkinValue(varname)
	end

	self:SetColors(skindata)
end

function TOOL:Holster()
	if not self.ToolLibLoaded then return end

	self:Clear()
	StreamRadioLib.Tool.CallClientToolHook(self, "Holster")
end

function TOOL:HolsterClient()
	if not self.ToolLibLoaded then return end
	self:Clear()
end

function TOOL:Clear()
	if IsValid(self.highlighter_hover) then
		self.highlighter_hover:Remove()
	end
end

function TOOL:Think()
	if not self.ToolLibLoaded then return end
	if SERVER then return end

	local aimedpanel, entgui = self:GetAimedObject()
	if not IsValid(aimedpanel) then
		if IsValid(self.highlighter_hover) then
			self.highlighter_hover:Remove()
			self._oldthink_aimedpanel = nil
		end
		return
	end

	if self._oldthink_aimedpanel == aimedpanel then return end
	self._oldthink_aimedpanel = aimedpanel

	local selectedpanels = self:GetSelectionPanels(entgui, aimedpanel)
	self:HighlightHoverPanels(entgui, selectedpanels)
end

--PATH lua/weapons/gmod_tool/stools/vjstool_entityscanner.lua:
TOOL.Name = "#tool.vjstool_entityscanner.name"
TOOL.Tab = "DrVrej"
TOOL.Category = "Tools"
TOOL.Command = nil -- The console command to execute upon being selected in the Q menu.

TOOL.Information = {
	{name = "left"},
}

-- Just to make it easier to reset everything to default
local DefaultConVars = {}
for k,v in pairs(TOOL.ClientConVar) do
	DefaultConVars["vjstool_entityscanner_"..k] = v
end
---------------------------------------------------------------------------------------------------------------------------------------------
if CLIENT then
	local function DoBuildCPanel_EntityScanner(Panel)
		Panel:AddControl("Label", {Text = "#tool.vjstool_entityscanner.label"})
	end
---------------------------------------------------------------------------------------------------------------------------------------------
	function TOOL.BuildCPanel(Panel)
		DoBuildCPanel_EntityScanner(Panel)
	end
end
---------------------------------------------------------------------------------------------------------------------------------------------
function TOOL:LeftClick(tr)
	if CLIENT then return true end
	if !IsValid(tr.Entity) then return false end
	local Ent = tr.Entity
	local Phys = Ent:GetPhysicsObject()
	PrintMessage(HUD_PRINTCONSOLE,"------------------- Name = "..Ent:GetName().." ||| Class = "..Ent:GetClass().." ||| Index = "..Ent:EntIndex().." -------------------")
	PrintMessage(HUD_PRINTCONSOLE,"MODEL: File Path = "..Ent:GetModel().." ||| Skin = "..Ent:GetSkin())
	PrintMessage(HUD_PRINTCONSOLE,"POSITION: Vector("..Ent:GetPos().x..", "..Ent:GetPos().y..", "..Ent:GetPos().z..") ||| X = "..Ent:GetPos().x.." , Y = "..Ent:GetPos().y.." , Z = "..Ent:GetPos().z)
	PrintMessage(HUD_PRINTCONSOLE,"ANGLE: Angle("..Ent:GetAngles().p..", "..Ent:GetAngles().y..", "..Ent:GetAngles().r..") ||| Pitch = "..Ent:GetAngles().p.." , Yaw = "..Ent:GetAngles().y.." , Roll = "..Ent:GetAngles().r)
	PrintMessage(HUD_PRINTCONSOLE,"SEQUENCE: ID = "..Ent:GetSequence().." ||| Name = "..Ent:GetSequenceName(Ent:GetSequence()).." ||| Duration = "..VJ_GetSequenceDuration(Ent,Ent:GetSequenceName(Ent:GetSequence())))
	if IsValid(Phys) then
		PrintMessage(HUD_PRINTCONSOLE,"VELOCITY: Vector("..Phys:GetVelocity().x..", "..Phys:GetVelocity().y..", "..Phys:GetVelocity().z..") ||| X = "..Phys:GetVelocity().x.." , Y = "..Phys:GetVelocity().y.." , Z = "..Phys:GetVelocity().z.." ||| Length = "..Phys:GetVelocity():Length())
		PrintMessage(HUD_PRINTCONSOLE,"PHYSICS: Mass = "..Phys:GetMass().." ||| Surface Area = "..Phys:GetSurfaceArea().." ||| Volume = "..Phys:GetVolume())
	else
		PrintMessage(HUD_PRINTCONSOLE,"VELOCITY: Can't display this information! Reason: Model doesn't have proper physics!")
		PrintMessage(HUD_PRINTCONSOLE,"PHYSICS: Can't display this information! Reason: Model doesn't have proper physics!")
	end
	PrintMessage(HUD_PRINTCONSOLE,"COLOR: Color("..Ent:GetColor().r..", "..Ent:GetColor().g..", "..Ent:GetColor().b..", "..Ent:GetColor().a..") ||| Red = "..Ent:GetColor().r.." , Green = "..Ent:GetColor().g.." , Blue = "..Ent:GetColor().b.." , Alpha = "..Ent:GetColor().a)
	PrintMessage(HUD_PRINTCONSOLE,"-----------------------------------------------------------------------------------------------")
	return true
end
---------------------------------------------------------------------------------------------------------------------------------------------
function TOOL:RightClick(tr)
	if CLIENT then return true end
	return false
end
---------------------------------------------------------------------------------------------------------------------------------------------
function TOOL:Reload(tr)
	if CLIENT then return true end
	return false
end
--PATH lua/weapons/gmod_tool/stools/vjstool_healthmodifier.lua:
TOOL.Name = "#tool.vjstool_healthmodifier.name"
TOOL.Tab = "DrVrej"
TOOL.Category = "Tools"
TOOL.Command = nil -- The console command to execute upon being selected in the Q menu.

TOOL.Information = {
	{name = "left"},
	{name = "right"},
	{name = "reload"},
}

TOOL.ClientConVar["health"] = "100"
TOOL.ClientConVar["godmode"] = 0
TOOL.ClientConVar["healthregen"] = 0
TOOL.ClientConVar["healthregen_amt"] = 4
TOOL.ClientConVar["healthregen_delay"] = 5

-- Just to make it easier to reset everything to default
local DefaultConVars = {}
for k,v in pairs(TOOL.ClientConVar) do
	DefaultConVars["vjstool_healthmodifier_"..k] = v
end
---------------------------------------------------------------------------------------------------------------------------------------------
if CLIENT then
	function DoBuildCPanel_VJ_HealthModifier(Panel)
		local reset = vgui.Create("DButton")
		reset:SetFont("DermaDefaultBold")
		reset:SetText("#vjbase.menu.general.reset.everything")
		reset:SetSize(150,25)
		reset:SetColor(Color(0,0,0,255))
		reset.DoClick = function()
			for k,v in pairs(DefaultConVars) do
				if v == "" then
				LocalPlayer():ConCommand(k.." ".."None")
			else
				LocalPlayer():ConCommand(k.." "..v) end
				timer.Simple(0.05,function()
					GetPanel = controlpanel.Get("vjstool_healthmodifier")
					GetPanel:ClearControls()
					DoBuildCPanel_VJ_HealthModifier(GetPanel)
				end)
			end
		end
		Panel:AddPanel(reset)
		
		local tutorial = vgui.Create("DButton")
		tutorial:SetFont("DermaDefaultBold")
		tutorial:SetText("#tool.vjstool.menu.tutorialvideo")
		tutorial:SetSize(150, 20)
		tutorial:SetColor(Color(0,0,255,255))
		tutorial.DoClick = function()
			gui.OpenURL("http://www.youtube.com/watch?v=kLygPP-vbHY")
		end
		Panel:AddPanel(tutorial)
		
		Panel:AddControl("Label", {Text = "#tool.vjstool_healthmodifier.adminonly"})
		Panel:AddControl("Slider", {Label = "#tool.vjstool_healthmodifier.sliderhealth", min = 0, max = 10000, Command = "vjstool_healthmodifier_health"})
		Panel:AddControl("Label", {Text = "#tool.vjstool_healthmodifier.label1"})
		Panel:AddControl("Checkbox", {Label = "#tool.vjstool_healthmodifier.togglegodmode", Command = "vjstool_healthmodifier_godmode"})
		Panel:AddControl("Checkbox", {Label = "#tool.vjstool_healthmodifier.togglehealthregen", Command = "vjstool_healthmodifier_healthregen"})
		Panel:AddControl("Slider", {Label = "#tool.vjstool_healthmodifier.sliderhealthregenamt", min = 0, max = 10000, Command = "vjstool_healthmodifier_healthregen_amt"})
		Panel:AddControl("Slider", {Label = "#tool.vjstool_healthmodifier.sliderhealthregendelay", min = 0, max = 10000, Command = "vjstool_healthmodifier_healthregen_delay"})
	end
---------------------------------------------------------------------------------------------------------------------------------------------
	function TOOL.BuildCPanel(Panel)
		DoBuildCPanel_VJ_HealthModifier(Panel)
	end
end
---------------------------------------------------------------------------------------------------------------------------------------------
function TOOL:LeftClick(tr)
	if CLIENT then return true end
	if IsValid(tr.Entity) then
		local Ply = self:GetOwner()
		local trent = tr.Entity
		local canheal = true
		if (trent:Health() != 0 or (trent:IsNPC() or trent:IsPlayer())) then
			if trent:IsPlayer() && !Ply:IsAdmin() then
				canheal = false
			end
			if canheal == true then
				trent:SetHealth(self:GetClientNumber("health"))
				Ply:ChatPrint("Set "..trent:GetClass().."'s health to "..self:GetClientNumber("health"))
				if trent:IsNPC() then
					if self:GetClientNumber("godmode") == 1 then trent.GodMode = true else trent.GodMode = false end
					if trent.IsVJBaseSNPC == true && self:GetClientNumber("healthregen") == 1 then
						trent.HasHealthRegeneration = true
						trent.HealthRegenerationAmount = self:GetClientNumber("healthregen_amt")
						trent.HealthRegenerationDelay = VJ_Set(self:GetClientNumber("healthregen_delay"), self:GetClientNumber("healthregen_delay"))
					end
				end
				return true
			end
		end
	end
end
---------------------------------------------------------------------------------------------------------------------------------------------
function TOOL:RightClick(tr)
	if CLIENT then return true end
	if IsValid(tr.Entity) then
		local Ply = self:GetOwner()
		local trent = tr.Entity
		local canheal = true
		if (trent:Health() != 0 or (trent:IsNPC() or trent:IsPlayer())) then
			if trent:IsPlayer() && !Ply:IsAdmin() then
				canheal = false
			end
			if canheal == true then
				trent:SetHealth(self:GetClientNumber("health"))
				trent:SetMaxHealth(self:GetClientNumber("health"))
				Ply:ChatPrint("Set "..trent:GetClass().."'s health and max health to "..self:GetClientNumber("health"))
				if trent:IsNPC() then
					if self:GetClientNumber("godmode") == 1 then trent.GodMode = true else trent.GodMode = false end
					if trent.IsVJBaseSNPC == true && self:GetClientNumber("healthregen") == 1 then
						trent.HasHealthRegeneration = true
						trent.HealthRegenerationAmount = self:GetClientNumber("healthregen_amt")
						trent.HealthRegenerationDelay = VJ_Set(self:GetClientNumber("healthregen_delay"), self:GetClientNumber("healthregen_delay"))
					end
				end
				return true
			end
		end
	end
end
---------------------------------------------------------------------------------------------------------------------------------------------
function TOOL:Reload(tr)
	if CLIENT then return true end
	if IsValid(tr.Entity) then
		local Ply = self:GetOwner()
		local trent = tr.Entity
		local canheal = true
		if (trent:Health() != 0 or (trent:IsNPC() or trent:IsPlayer())) then
			if trent:IsPlayer() && !Ply:IsAdmin() then
				canheal = false
			end
			if canheal == true then
				trent:SetHealth(trent:GetMaxHealth())
				Ply:ChatPrint("Healed "..trent:GetClass().." to its max health ("..trent:GetMaxHealth()..")")
				return true
			end
		end
	end
end
--PATH lua/weapons/gmod_tool/stools/vjstool_npcequipment.lua:
TOOL.Name = "#tool.vjstool_npcequipment.name"
TOOL.Tab = "DrVrej"
TOOL.Category = "Tools"
TOOL.Command = nil -- The console command to execute upon being selected in the Q menu.

TOOL.Information = {
	{name = "left"},
	{name = "right"},
}

TOOL.ClientConVar["weaponclass"] = "None"
TOOL.ClientConVar["weaponname"] = "Unknown"

-- Just to make it easier to reset everything to default
local DefaultConVars = {}
for k,v in pairs(TOOL.ClientConVar) do
	DefaultConVars["vjstool_npcequipment_"..k] = v
end
---------------------------------------------------------------------------------------------------------------------------------------------
if CLIENT then
	local function DoBuildCPanel_VJ_NPCEquipment(Panel)
		local reset = vgui.Create("DButton")
		reset:SetFont("DermaDefaultBold")
		reset:SetText("#vjbase.menu.general.reset.everything")
		reset:SetSize(150,25)
		reset:SetColor(Color(0,0,0,255))
		reset.DoClick = function()
			for k,v in pairs(DefaultConVars) do
				if v == "" then
				LocalPlayer():ConCommand(k.." ".."None")
			else
				LocalPlayer():ConCommand(k.." "..v) end
				timer.Simple(0.05,function()
					GetPanel = controlpanel.Get("vjstool_npcequipment")
					GetPanel:ClearControls()
					DoBuildCPanel_VJ_NPCEquipment(GetPanel)
				end)
			end
		end
		Panel:AddPanel(reset)
		
		Panel:AddControl("Label", {Text = "#tool.vjstool.menu.label.recommendation"})
		Panel:ControlHelp("#tool.vjstool_npcequipment.label")
		
		local selectwep = vgui.Create("DTextEntry")
		selectwep:SetEditable(false)
		selectwep:SetText(language.GetPhrase("#tool.vjstool_npcequipment.selectedequipment")..": "..GetConVarString("vjstool_npcequipment_weaponname").." ["..GetConVarString("vjstool_npcequipment_weaponclass").."]")
		selectwep.OnGetFocus = function() LocalPlayer():ConCommand("vj_npcequipment_openwepselect") end
		Panel:AddItem(selectwep)
	end
---------------------------------------------------------------------------------------------------------------------------------------------
	function TOOL.BuildCPanel(Panel)
		DoBuildCPanel_VJ_NPCEquipment(Panel)
	end
---------------------------------------------------------------------------------------------------------------------------------------------
	concommand.Add("vj_npcequipment_openwepselect",function(pl,cmd,args)
		local MenuFrame = vgui.Create('DFrame')
		MenuFrame:SetSize(420, 440)
		MenuFrame:SetPos(ScrW()*0.6, ScrH()*0.1)
		MenuFrame:SetTitle("#tool.vjstool_npcequipment.print.doubleclick")
		//MenuFrame:SetBackgroundBlur(true)
		MenuFrame:SetFocusTopLevel(true)
		MenuFrame:SetSizable(true)
		MenuFrame:ShowCloseButton(true)
		//MenuFrame:SetDeleteOnClose(false)
		MenuFrame:MakePopup()
		
		local CheckList = vgui.Create("DListView")
			CheckList:SetTooltip(false)
			CheckList:SetParent(MenuFrame)
			CheckList:SetPos(10,30)
			CheckList:SetSize(400,400) -- Size
			CheckList:SetMultiSelect(false)
			CheckList:AddColumn("#tool.vjstool_npcequipment.header1")
			CheckList:AddColumn("#tool.vjstool_npcequipment.header2")
			CheckList.OnRowSelected = function() chat.AddText(Color(0,255,0), "#tool.vjstool_npcequipment.print.doubleclick") end
			function CheckList:DoDoubleClick(lineID,line)
				chat.AddText(Color(0,255,0), "#tool.vjstool_npcequipment.print.weaponselected1", Color(255,100,0), " "..line:GetValue(1).." ", Color(0,255,0), "#tool.vjstool_npcequipment.print.weaponselected2")
				LocalPlayer():ConCommand("vjstool_npcequipment_weaponname "..line:GetValue(1))
				LocalPlayer():ConCommand("vjstool_npcequipment_weaponclass "..line:GetValue(2))
				MenuFrame:Close()
				timer.Simple(0.05,function()
					GetPanel = controlpanel.Get("vjstool_npcequipment")
					GetPanel:ClearControls()
					DoBuildCPanel_VJ_NPCEquipment(GetPanel)
				end)
			end
		//MenuFrame:AddItem(CheckList)
		//CheckList:SizeToContents()
		for _,v in pairs(list.Get("NPCUsableWeapons")) do
			CheckList:AddLine(v.title,v.class)
		end
		CheckList:SortByColumn(1,false)
	end)
end
---------------------------------------------------------------------------------------------------------------------------------------------
function TOOL:LeftClick(tr)
	if CLIENT then return true end
	if !tr.Entity:IsNPC() then return end
	if IsValid(tr.Entity:GetActiveWeapon()) then tr.Entity:GetActiveWeapon():Remove() end
	tr.Entity:Give(GetConVarString("vjstool_npcequipment_weaponclass"))
	return true
end
---------------------------------------------------------------------------------------------------------------------------------------------
function TOOL:RightClick(tr)
	if CLIENT then return true end
	if !tr.Entity:IsNPC() then return end
	if IsValid(tr.Entity:GetActiveWeapon()) then tr.Entity:GetActiveWeapon():Remove() end
	return true
end
---------------------------------------------------------------------------------------------------------------------------------------------
function TOOL:Reload(tr)
	if CLIENT then return true end
end
--PATH lua/weapons/gmod_tool/stools/vjstool_npcmover.lua:
TOOL.Name = "#tool.vjstool_npcmover.name"
TOOL.Tab = "DrVrej"
TOOL.Category = "Tools"
TOOL.Command = nil -- The console command to execute upon being selected in the Q menu.

TOOL.Information = {
	{name = "left"},
	{name = "right"},
	{name = "reload"},
}

-- Just to make it easier to reset everything to default
local DefaultConVars = {}
for k,v in pairs(TOOL.ClientConVar) do
	DefaultConVars["vjstool_npcmover_"..k] = v
end
---------------------------------------------------------------------------------------------------------------------------------------------
if CLIENT then
	local function DoBuildCPanel_Mover(Panel)
		VJ_MOVE_TblCurrentValues = VJ_MOVE_TblCurrentValues or {}
		VJ_MOVE_TblCurrentLines = VJ_MOVE_TblCurrentLines or {}
		
		local reset = vgui.Create("DButton")
		reset:SetFont("DermaDefaultBold")
		reset:SetText("#vjbase.menu.general.reset.everything")
		reset:SetSize(150,25)
		reset:SetColor(Color(0,0,0,255))
		reset.DoClick = function()
			for k,v in pairs(DefaultConVars) do
				if v == "" then
				LocalPlayer():ConCommand(k.." ".."None")
			else
				LocalPlayer():ConCommand(k.." "..v) end
				timer.Simple(0.05,function()
					GetPanel = controlpanel.Get("vjstool_npcmover")
					GetPanel:ClearControls()
					DoBuildCPanel_Mover(GetPanel)
				end)
			end
		end
		Panel:AddPanel(reset)
		
		Panel:AddControl("Label", {Text = "#tool.vjstool.menu.label.recommendation"})
		local CheckList = vgui.Create("DListView")
			CheckList:SetTooltip(false)
			//CheckList:Center() -- No need since Size does it already
			CheckList:SetSize(100, 300) -- Size
			CheckList:SetMultiSelect(false)
			//CheckList.Paint = function()
			//draw.RoundedBox(8, 0, 0, CheckList:GetWide(), CheckList:GetTall(), Color(0, 0, 100, 255))
			//end
			CheckList:AddColumn("#tool.vjstool_npcmover.header1")
			CheckList:AddColumn("#tool.vjstool_npcmover.header2")
			//CheckList:AddColumn("Index")
			CheckList:AddColumn("#tool.vjstool_npcmover.header3")
			//CheckList:AddColumn("Position")
			//CheckList:AddColumn("Equipment")
			for _,v in ipairs(VJ_MOVE_TblCurrentValues) do
				if IsValid(v) then
				local locname = "Unknown"
					for _,lv in pairs(list.Get("NPC")) do
						if v:GetClass() == lv.Class then locname = lv.Name end
					end
					CheckList:AddLine(locname,v:GetClass(),v) //v:EntIndex()
					//CheckList:AddLine(v)
				end
			end
			CheckList.OnRowSelected = function(rowIndex,row) chat.AddText(Color(0,255,0),"Double click to ",Color(255,100,0),"unselect ",Color(0,255,0),"a NPC") end
			function CheckList:DoDoubleClick(lineID,line)
				chat.AddText(Color(0,255,0),"NPC",Color(255,100,0)," "..line:GetValue(1).." ",Color(0,255,0),"unselected!")
				net.Start("vj_npcmover_remove")
				net.WriteTable({line:GetValue(3)})
				net.SendToServer()
				CheckList:RemoveLine(lineID)
				table.Empty(VJ_MOVE_TblCurrentValues)
				for _,vLine in pairs(CheckList:GetLines()) do
					table.insert(VJ_MOVE_TblCurrentValues,vLine:GetValue(3))
				end
			end
		Panel:AddItem(CheckList)
		//VJ_MOVE_TblCurrentLines = CheckList:GetLines()
				
		local unselectall = vgui.Create("DButton")
		unselectall:SetFont("DermaDefaultBold")
		unselectall:SetText("#tool.vjstool_npcmover.buttonunselectall")
		unselectall:SetSize(150, 25)
		unselectall:SetColor(Color(0,0,0,255))
		unselectall.DoClick = function()
			local brah = VJ_MOVE_TblCurrentValues
			if table.Count(brah) > 0 then
				chat.AddText(Color(255,100,0), "#tool.vjstool_npcmover.print.unselectedall")
			else
				chat.AddText(Color(0,255,0), "#tool.vjstool_npcmover.print.unselectedall.error")
			end
			net.Start("vj_npcmover_remove")
			net.WriteTable(brah)
			net.SendToServer()
			table.Empty(brah)
			CheckList:Clear()
		end
		Panel:AddPanel(unselectall)
		//Panel:AddControl("Checkbox", {Label = "Kill The Enemy", Command = "vjstool_npccontroller_killenemy"})
	end
---------------------------------------------------------------------------------------------------------------------------------------------
	net.Receive("vj_npcmover_cl_create", function(len, ply)
		local wep = LocalPlayer():GetActiveWeapon()
		if wep:IsValid() && wep:GetClass() == "gmod_tool" && wep:GetMode() == "vjstool_npcmover" then
			local sventity = net.ReadEntity()
			local sventname = net.ReadString()
			VJ_MOVE_TblCurrentValues = VJ_MOVE_TblCurrentValues or {}
			//if svchangetype == "AddNPC" then table.insert(VJ_MOVE_TblCurrentValues,sventity) end
			local changetype = 0 -- Check if we are removing or adding an NPC | 0 = Add, 1 = Remove
			for k,v in ipairs(VJ_MOVE_TblCurrentValues) do
				if !IsValid(v) then table.remove(VJ_MOVE_TblCurrentValues,k) continue end -- Remove any NPCs that no longer exist!
				if v == sventity then -- If the selected NPC already exists then unselect it!
					chat.AddText(Color(0,255,0),"NPC",Color(255,100,0)," "..sventname.." ",Color(0,255,0),"unselected!")
					changetype = 1
					table.remove(VJ_MOVE_TblCurrentValues, k)
				end
			end
			if changetype == 0 then -- Only if we are adding
				chat.AddText(Color(0,255,0),"NPC",Color(255,100,0)," "..sventname.." ",Color(0,255,0),"selected!")
				table.insert(VJ_MOVE_TblCurrentValues,sventity)
			end
			-- Refresh the tool menu
			GetPanel = controlpanel.Get("vjstool_npcmover")
			GetPanel:ClearControls()
			DoBuildCPanel_Mover(GetPanel)
			net.Start("vj_npcmover_sv_create")
			net.WriteEntity(sventity)
			net.WriteBit(changetype)
			net.SendToServer()
			//print("Current Entity: ",sventity)
			//print("--------------")
			//PrintTable(VJ_MOVE_TblCurrentValues)
			//print("--------------")
		end
	end)
---------------------------------------------------------------------------------------------------------------------------------------------
	net.Receive("vj_npcmover_cl_startmove", function(len, ply)
		local svwalktype = net.ReadBit()
		local svvector = net.ReadVector()
		local wep = LocalPlayer():GetActiveWeapon()
		if wep:IsValid() && wep:GetClass() == "gmod_tool" && wep:GetMode() == "vjstool_npcmover" then
			for k,v in ipairs(VJ_MOVE_TblCurrentValues) do
				if !IsValid(v) then -- Remove any NPCs that no longer exist!
					table.remove(VJ_MOVE_TblCurrentValues,k)
					GetPanel = controlpanel.Get("vjstool_npcmover")
					GetPanel:ClearControls()
					DoBuildCPanel_Mover(GetPanel)
				end
			end
			net.Start("vj_npcmover_sv_startmove")
			net.WriteTable(VJ_MOVE_TblCurrentValues)
			net.WriteBit(svwalktype)
			net.WriteVector(svvector)
			net.SendToServer()
		end
	end)
---------------------------------------------------------------------------------------------------------------------------------------------
	function TOOL.BuildCPanel(Panel)
		DoBuildCPanel_Mover(Panel)
	end
else -- If SERVER
	util.AddNetworkString("vj_npcmover_cl_create")
	util.AddNetworkString("vj_npcmover_sv_create")
	util.AddNetworkString("vj_npcmover_cl_startmove")
	util.AddNetworkString("vj_npcmover_sv_startmove")
	util.AddNetworkString("vj_npcmover_remove")
---------------------------------------------------------------------------------------------------------------------------------------------
	net.Receive("vj_npcmover_sv_create", function(len, ply)
		local wep = ply:GetActiveWeapon()
		if wep:IsValid() && wep:GetClass() == "gmod_tool" && wep:GetMode() == "vjstool_npcmover" then
			local sventity = net.ReadEntity()
			local svchangetype = net.ReadBit()
			if svchangetype == 0 then
				//print("fully added")
				sventity.VJ_IsBeingControlled_Tool = true
				sventity:StopMoving()
				if sventity.IsVJBaseSNPC == true then
					sventity.DisableWandering = true
					sventity.DisableChasingEnemy = true
				end
			elseif svchangetype == 1 then
				//print("fully removed")
				sventity.VJ_IsBeingControlled_Tool = false
				if sventity.IsVJBaseSNPC == true then
					sventity.DisableWandering = false
					sventity.DisableChasingEnemy = false
					sventity:SelectSchedule()
				end
			end
		end
	end)
	
	net.Receive("vj_npcmover_remove", function(len, ply)
		local wep = ply:GetActiveWeapon()
		if wep:IsValid() && wep:GetClass() == "gmod_tool" && wep:GetMode() == "vjstool_npcmover" then
			local brahtbl = net.ReadTable()
			for _,v in ipairs(brahtbl) do
				v.VJ_IsBeingControlled_Tool = false
				if v.IsVJBaseSNPC == true then
					v.DisableWandering = false
					v.DisableChasingEnemy = false
					v:SelectSchedule()
				end
			end
		end
	end)
	
	net.Receive("vj_npcmover_sv_startmove", function(len, ply)
		local wep = ply:GetActiveWeapon()
		if wep:IsValid() && wep:GetClass() == "gmod_tool" && wep:GetMode() == "vjstool_npcmover" then
			local sventtable = net.ReadTable()
			local svwalktype = net.ReadBit()
			local svvector = net.ReadVector()
			local type_task = "TASK_WALK_PATH"
			local type_sched = SCHED_FORCED_GO
			if svwalktype == 1 then
				type_task = "TASK_RUN_PATH"
				type_sched = SCHED_FORCED_GO_RUN
			end
			for k, v in ipairs(sventtable) do
				if IsValid(v) then -- Move the NPC if it's valid!
					v:StopMoving()
					v:SetLastPosition(svvector)
					if v.IsVJBaseSNPC == true then
						if k == 1 or math.random(1, 5) == 1 then v:PlaySoundSystem("OnReceiveOrder") end
						v:VJ_TASK_GOTO_LASTPOS(type_task, function(x)
							if IsValid(v:GetEnemy()) && v:Visible(v:GetEnemy()) then
								x:EngTask("TASK_FACE_ENEMY", 0)
								x.CanShootWhenMoving = true
								x.ConstantlyFaceEnemy = true
							end
						end)
					else -- For non-VJ NPCs
						v:SetSchedule(type_sched)
					end
				end
			end
			//self:MoveNPC(sventity,svvector,svwalktype)
		end
	end)
end
---------------------------------------------------------------------------------------------------------------------------------------------
function TOOL:LeftClick(tr)
	if CLIENT then return true end
	if !tr.Entity:IsNPC() then return end
	net.Start("vj_npcmover_cl_create")
	net.WriteEntity(tr.Entity)
	if tr.Entity:GetName() == "" then
		net.WriteString(list.Get("NPC")[tr.Entity:GetClass()].Name)
	else
		net.WriteString(tr.Entity:GetName())
	end
	net.Send(self:GetOwner())
	return true
end
---------------------------------------------------------------------------------------------------------------------------------------------
function TOOL:RightClick(tr)
	if CLIENT then return true end
	net.Start("vj_npcmover_cl_startmove")
	net.WriteBit(1)
	net.WriteVector(tr.HitPos)
	net.Send(self:GetOwner())
	return true
end
---------------------------------------------------------------------------------------------------------------------------------------------
function TOOL:Reload(tr)
	if CLIENT then return true end
	net.Start("vj_npcmover_cl_startmove")
	net.WriteBit(0)
	net.WriteVector(tr.HitPos)
	net.Send(self:GetOwner())
	return true
end
---------------------------------------------------------------------------------------------------------------------------------------------
function TOOL:Holster()
	/*if CLIENT then return end
	self.TblCurrentNPCs = self.TblCurrentNPCs or {}
	for k,v in pairs(self.TblCurrentNPCs) do
		self:RemoveNPC(v)
	end*/
end
--PATH lua/weapons/gmod_tool/stools/vjstool_npcspawner.lua:
TOOL.Name = "#tool.vjstool_npcspawner.name"
TOOL.Tab = "DrVrej"
TOOL.Category = "Tools"
TOOL.Command = nil -- The console command to execute upon being selected in the Q menu.

TOOL.Information = {
	{name = "left"},
	{name = "right"},
}

TOOL.ClientConVar["playsound"] = 1
TOOL.ClientConVar["nextspawntime"] = 1
TOOL.ClientConVar["spawnent"] = "None"
TOOL.ClientConVar["spawnentname"] = "Unknown"
TOOL.ClientConVar["spawnnpclass"] = ""
TOOL.ClientConVar["fritoplyallies"] = 1
TOOL.ClientConVar["spawnpos_forward"] = 0
TOOL.ClientConVar["spawnpos_right"] = 0
TOOL.ClientConVar["spawnpos_up"] = 0
TOOL.ClientConVar["weaponequip"] = "None"
TOOL.ClientConVar["weaponequipname"] = "None"
TOOL.ClientConVar["nextspawntime"] = 3

-- Just to make it easier to reset everything to default
local DefaultConVars = {}
for k,v in pairs(TOOL.ClientConVar) do
	DefaultConVars["vjstool_npcspawner_"..k] = v
end
---------------------------------------------------------------------------------------------------------------------------------------------
if CLIENT then
	local function DoBuildCPanel_Spawner(Panel)
		local reset = vgui.Create("DButton")
		reset:SetFont("DermaDefaultBold")
		reset:SetText("#vjbase.menu.general.reset.everything")
		reset:SetSize(150,25)
		reset:SetColor(Color(0,0,0,255))
		reset.DoClick = function()
			for k,v in pairs(DefaultConVars) do
				-- Ignore "vjstool_npcspawner_spawnnpclass" because we don't want it set to "None", we need it to stay ""
				if k == "vjstool_npcspawner_spawnnpclass" then
					LocalPlayer():ConCommand("vjstool_npcspawner_spawnnpclass \"\"")
				elseif v == "" then
					LocalPlayer():ConCommand(k.." ".."None")
				else
					LocalPlayer():ConCommand(k.." "..v)
				end
				timer.Simple(0.05,function()
					GetPanel = controlpanel.Get("vjstool_npcspawner")
					GetPanel:ClearControls()
					DoBuildCPanel_Spawner(GetPanel)
				end)
			end
		end
		Panel:AddPanel(reset)
		
		local tutorial = vgui.Create("DButton")
		tutorial:SetFont("DermaDefaultBold")
		tutorial:SetText("#tool.vjstool.menu.tutorialvideo")
		tutorial:SetSize(150, 20)
		tutorial:SetColor(Color(0,0,255,255))
		tutorial.DoClick = function()
			gui.OpenURL("http://www.youtube.com/watch?v=5H_hIz35W90")
		end
		Panel:AddPanel(tutorial)
		
		VJ_NPCSPAWNER_TblCurrentValues = VJ_NPCSPAWNER_TblCurrentValues or {}
		VJ_NPCSPAWNER_TblCurrentLines = VJ_NPCSPAWNER_TblCurrentLines or {}
		VJ_NPCSPAWNER_TblCurrentLinesUsable = VJ_NPCSPAWNER_TblCurrentLinesUsable or {}
		
		Panel:AddControl("Label", {Text = "#tool.vjstool.menu.label.recommendation"})
		local selectnpc = vgui.Create("DTextEntry")
			selectnpc:SetEditable(false)
			selectnpc:SetText(language.GetPhrase("#tool.vjstool_npcspawner.selectednpc")..": "..GetConVarString("vjstool_npcspawner_spawnentname").." ["..GetConVarString("vjstool_npcspawner_spawnent").."]")
			selectnpc.OnGetFocus = function() LocalPlayer():ConCommand("vj_npcspawner_opennpcselect") end
		Panel:AddItem(selectnpc)
		Panel:AddControl("TextBox",{Label = "#tool.vjstool_npcspawner.spawnpos.forward",MaxLength = 10,Type = "Float",WaitForEnter = false,Command = "vjstool_npcspawner_spawnpos_forward"})
		Panel:AddControl("TextBox",{Label = "#tool.vjstool_npcspawner.spawnpos.right",MaxLength = 10,Type = "Float",WaitForEnter = false,Command = "vjstool_npcspawner_spawnpos_right"})
		Panel:AddControl("TextBox",{Label = "#tool.vjstool_npcspawner.spawnpos.up",MaxLength = 10,Type = "Float",WaitForEnter = false,Command = "vjstool_npcspawner_spawnpos_up"})
		local selectwep = vgui.Create("DTextEntry")
			selectwep:SetEditable(false)
			selectwep:SetText(language.GetPhrase("#tool.vjstool_npcspawner.selectweapon")..": "..GetConVarString("vjstool_npcspawner_weaponequipname").." ["..GetConVarString("vjstool_npcspawner_weaponequip").."]")
			selectwep.OnGetFocus = function() LocalPlayer():ConCommand("vj_npcspawner_openwepselect") end
		Panel:AddItem(selectwep)
		Panel:AddControl("TextBox",{Label = "#tool.vjstool_npcspawner.spawnnpclass",WaitForEnter = false,Command = "vjstool_npcspawner_spawnnpclass"})
		Panel:AddControl("CheckBox",{Label = "#tool.vjstool_npcspawner.fritoplyallies",Command = "vjstool_npcspawner_fritoplyallies"})
		Panel:ControlHelp("#tool.vjstool_npcspawner.label.fritoplyallies")
		Panel:AddControl("Button",{Label = "#tool.vjstool_npcspawner.button.updatelist",Command = "vj_npcspawner_updatelist"})
		Panel:ControlHelp("#tool.vjstool_npcspawner.label1")
		local CheckList = vgui.Create("DListView")
			CheckList:SetTooltip(false)
			CheckList:SetSize(100, 307) -- Size
			CheckList:SetMultiSelect(false)
			CheckList:AddColumn("#tool.vjstool_npcspawner.header1")
			CheckList:AddColumn("#tool.vjstool_npcspawner.header2")
			CheckList:AddColumn("#tool.vjstool_npcspawner.header3")
			CheckList.OnRowSelected = function(rowIndex,row) chat.AddText(Color(0,255,0),"Double click to ",Color(255,100,0),"remove ",Color(0,255,0),"a NPC") end
			function CheckList:DoDoubleClick(lineID,line)
				chat.AddText(Color(0,255,0),"NPC",Color(255,100,0)," "..line:GetValue(1).." ",Color(0,255,0),"removed!")
				CheckList:RemoveLine(lineID)
				table.Empty(VJ_NPCSPAWNER_TblCurrentLinesUsable)
				for _,vLine in pairs(VJ_NPCSPAWNER_TblCurrentLines) do
					table.insert(VJ_NPCSPAWNER_TblCurrentLinesUsable,{Entities=vLine:GetValue(4),SpawnPosition=vLine:GetValue(2),WeaponsList=vLine:GetValue(3),EntityName=vLine:GetValue(1),Relationship=vLine:GetValue(5)})
				end
			end
		Panel:AddItem(CheckList)
		for k,v in pairs(VJ_NPCSPAWNER_TblCurrentValues) do
			if v.Entities == "" or v.Entities == "none" or v.Entities == {} then table.remove(VJ_NPCSPAWNER_TblCurrentValues,k) continue end
			if v.Entities != "" && v.Entities != "none" && v.Entities != {} then
				CheckList:AddLine(v.EntityName,Vector(v.SpawnPosition.vForward,v.SpawnPosition.vRight,v.SpawnPosition.vUp),v.WeaponsList,v.Entities,v.Relationship)
				//CheckList:AddLine(v.Entities,"x:"..v.SpawnPosition.vForward.." y:"..v.SpawnPosition.vRight.." z:"..v.SpawnPosition.vUp)
			end
		end
		table.Empty(VJ_NPCSPAWNER_TblCurrentValues)
		for _,vLine in pairs(VJ_NPCSPAWNER_TblCurrentLines) do
			CheckList:AddLine(vLine:GetValue(1),vLine:GetValue(2),vLine:GetValue(3),vLine:GetValue(4),vLine:GetValue(5))
		end
		VJ_NPCSPAWNER_TblCurrentLines = CheckList:GetLines()
		table.Empty(VJ_NPCSPAWNER_TblCurrentLinesUsable)
		for _,vLine in pairs(VJ_NPCSPAWNER_TblCurrentLines) do
			table.insert(VJ_NPCSPAWNER_TblCurrentLinesUsable,{Entities=vLine:GetValue(4),SpawnPosition=vLine:GetValue(2),WeaponsList=vLine:GetValue(3),EntityName=vLine:GetValue(1),Relationship=vLine:GetValue(5)})
		end
		Panel:AddControl("Label", {Text = language.GetPhrase("#tool.vjstool_npcspawner.label2")..":"})
		Panel:AddControl("Checkbox", {Label = "#tool.vjstool_npcspawner.toggle.spawnsound", Command = "vjstool_npcspawner_playsound"})
		Panel:AddControl("Slider", {Label = "#tool.vjstool_npcspawner.nextspawntime",min = 0,max = 1000,Command = "vjstool_npcspawner_nextspawntime"})
	end
---------------------------------------------------------------------------------------------------------------------------------------------
	concommand.Add("vj_npcspawner_opennpcselect",function(ply,cmd,args)
		local MenuFrame = vgui.Create('DFrame')
		MenuFrame:SetSize(420, 440)
		MenuFrame:SetPos(ScrW()*0.6, ScrH()*0.1)
		MenuFrame:SetTitle("#tool.vjstool_npcspawner.title1")
		//MenuFrame:SetBackgroundBlur(true)
		MenuFrame:SetFocusTopLevel(true)
		MenuFrame:SetSizable(true)
		MenuFrame:ShowCloseButton(true)
		//MenuFrame:SetDeleteOnClose(false)
		MenuFrame:MakePopup()
		
		local CheckList = vgui.Create("DListView")
			CheckList:SetTooltip(false)
			//CheckList:Center() -- No need since Size does it already
			CheckList:SetParent(MenuFrame)
			CheckList:SetPos(10,30)
			CheckList:SetSize(400,400) -- Size
			CheckList:SetMultiSelect(false)
			CheckList:AddColumn("#tool.vjstool_npcspawner.popup.header1")
			CheckList:AddColumn("#tool.vjstool_npcspawner.popup.header2")
			CheckList:AddColumn("#tool.vjstool_npcspawner.popup.header3")
			CheckList.OnRowSelected = function() chat.AddText(Color(0,255,0),"#tool.vjstool_npcspawner.title1") end
			function CheckList:DoDoubleClick(lineID,line)
				chat.AddText(Color(0,255,0),"NPC",Color(255,100,0)," "..line:GetValue(1).." ",Color(0,255,0),"selected!")
				LocalPlayer():ConCommand("vjstool_npcspawner_spawnentname "..line:GetValue(1))
				LocalPlayer():ConCommand("vjstool_npcspawner_spawnent "..line:GetValue(2))
				MenuFrame:Close()
				timer.Simple(0.05,function()
				GetPanel = controlpanel.Get("vjstool_npcspawner")
				GetPanel:ClearControls()
				DoBuildCPanel_Spawner(GetPanel)
				end)
			end
		//MenuFrame:AddItem(CheckList)
		//CheckList:SizeToContents()
		for _,v in pairs(list.Get("NPC")) do
			getcat = v.Category
			if v.Category == "" then getcat = "Unknown" end
			CheckList:AddLine(v.Name,v.Class,getcat)
		end
		CheckList:SortByColumn(1,false)
	end)
---------------------------------------------------------------------------------------------------------------------------------------------
	concommand.Add("vj_npcspawner_openwepselect",function(ply,cmd,args)
		local MenuFrame = vgui.Create('DFrame')
		MenuFrame:SetSize(420, 440)
		MenuFrame:SetPos(ScrW()*0.6, ScrH()*0.1)
		MenuFrame:SetTitle("#tool.vjstool_npcspawner.title2")
		//MenuFrame:SetBackgroundBlur(true)
		MenuFrame:SetFocusTopLevel(true)
		MenuFrame:SetSizable(true)
		MenuFrame:ShowCloseButton(true)
		//MenuFrame:SetDeleteOnClose(false)
		MenuFrame:MakePopup()
		
		local CheckList = vgui.Create("DListView")
			CheckList:SetTooltip(false)
			//CheckList:Center() -- No need since Size does it already
			CheckList:SetParent(MenuFrame)
			CheckList:SetPos(10,30)
			CheckList:SetSize(400,400) -- Size
			CheckList:SetMultiSelect(false)
			CheckList:AddColumn("#tool.vjstool_npcspawner.popup.header1")
			CheckList:AddColumn("#tool.vjstool_npcspawner.popup.header2")
			CheckList.OnRowSelected = function() chat.AddText(Color(0,255,0),"#tool.vjstool_npcspawner.title2") end
			function CheckList:DoDoubleClick(lineID,line)
				chat.AddText(Color(0,255,0),"Weapon",Color(255,100,0)," "..line:GetValue(1).." ",Color(0,255,0),"selected!")
				LocalPlayer():ConCommand("vjstool_npcspawner_weaponequipname "..line:GetValue(1))
				LocalPlayer():ConCommand("vjstool_npcspawner_weaponequip "..line:GetValue(2))
				MenuFrame:Close()
				timer.Simple(0.05,function()
				GetPanel = controlpanel.Get("vjstool_npcspawner")
				GetPanel:ClearControls()
				DoBuildCPanel_Spawner(GetPanel)
				end)
			end
		//MenuFrame:AddItem(CheckList)
		//CheckList:SizeToContents()
		for _,v in pairs(list.Get("NPCUsableWeapons")) do
			CheckList:AddLine(v.title,v.class)
		end
		CheckList:SortByColumn(1,false)
		CheckList:AddLine("None","None")
		CheckList:AddLine("Default","Default")
	end)
---------------------------------------------------------------------------------------------------------------------------------------------
	concommand.Add("vj_npcspawner_updatelist",function(ply,cmd,args)
		local spawnent = string.lower(GetConVarString("vjstool_npcspawner_spawnent"))
		local spawnentname = GetConVarString("vjstool_npcspawner_spawnentname")
		local spawnposfor = GetConVarString("vjstool_npcspawner_spawnpos_forward")
		local spawnposright = GetConVarString("vjstool_npcspawner_spawnpos_right")
		local spawnposup = GetConVarString("vjstool_npcspawner_spawnpos_up")
		local spawnnpclass = GetConVarString("vjstool_npcspawner_spawnnpclass")
		local spawnfritoplyallies = GetConVarString("vjstool_npcspawner_fritoplyallies")
		local spawnequip = string.lower(GetConVarString("vjstool_npcspawner_weaponequip"))
		table.insert(VJ_NPCSPAWNER_TblCurrentValues,{EntityName=spawnentname, Entities=spawnent, SpawnPosition={vForward=spawnposfor,vRight=spawnposright,vUp=spawnposup}, WeaponsList=spawnequip, Relationship={Class = spawnnpclass, FriToPlyAllies = spawnfritoplyallies}})
		GetPanel = controlpanel.Get("vjstool_npcspawner")
		GetPanel:ClearControls()
		DoBuildCPanel_Spawner(GetPanel)
	end)
---------------------------------------------------------------------------------------------------------------------------------------------
	net.Receive("vj_npcspawner_cl_create", function(len, ply)
		local wep = LocalPlayer():GetActiveWeapon()
		if wep:IsValid() && wep:GetClass() == "gmod_tool" && wep:GetMode() == "vjstool_npcspawner" then
			local svpos = net.ReadVector()
			local svclicktype = net.ReadString()
			local convartbl = {}
			for k,_ in pairs(DefaultConVars) do
				convartbl[k] = GetConVarNumber(k)
			end
			net.Start("vj_npcspawner_sv_create")
			net.WriteTable(convartbl)
			net.WriteVector(svpos)
			net.WriteType(VJ_NPCSPAWNER_TblCurrentLinesUsable)
			net.WriteString(svclicktype)
			net.SendToServer()
		end
	end)
---------------------------------------------------------------------------------------------------------------------------------------------
	function TOOL.BuildCPanel(Panel)
		DoBuildCPanel_Spawner(Panel)
	end
else -- If SERVER
	util.AddNetworkString("vj_npcspawner_cl_create")
	util.AddNetworkString("vj_npcspawner_sv_create")
---------------------------------------------------------------------------------------------------------------------------------------------
	local spawnSounds = {"garrysmod/save_load1.wav","garrysmod/save_load2.wav","garrysmod/save_load3.wav","garrysmod/save_load4.wav"}
	--
	net.Receive("vj_npcspawner_sv_create", function(len, ply)
		local wep = ply:GetActiveWeapon()
		if wep:IsValid() && wep:GetClass() == "gmod_tool" && wep:GetMode() == "vjstool_npcspawner" then
			local convartbl = net.ReadTable()
			local svpos = net.ReadVector()
			local svgetlines = net.ReadType()
			local svgettype = net.ReadString()
			if !IsValid(ply) then return false end
			if table.Count(svgetlines) <= 0 then ply:ChatPrint("#tool.vjstool_npcspawner.print.nothingspawn") return false end
			local spawner = ents.Create("obj_vj_spawner_base")
			spawner.EntitiesToSpawn = {}
			spawner:SetPos(svpos)
			local angs = Angle(0,0,0)
			if IsValid(ply) then
				angs = ply:GetAngles()
				angs.pitch = 0
				angs.roll = 0
				angs.yaw = angs.yaw + 180
			end
			spawner:SetAngles(angs)
			for _,v in pairs(svgetlines) do
				//if v.IsVJBaseSpawner == true then ply:ChatPrint("Can't be spawned because it's a spawner") end
				table.insert(spawner.EntitiesToSpawn,{SpawnPosition={vForward=v.SpawnPosition.x,vRight=v.SpawnPosition.y,vUp=v.SpawnPosition.z}, Entities={v.Entities}, WeaponsList={v.WeaponsList}, NPC_Class = v.Relationship.Class, FriToPlyAllies = tobool(v.Relationship.FriToPlyAllies)})
			end
			//spawner.EntitiesToSpawn = {entitiestospawntbl}
			if convartbl.vjstool_npcspawner_playsound == 1 then
				spawner.SoundTbl_SpawnEntity = spawnSounds
			end
			spawner.TimedSpawn_Time = convartbl.vjstool_npcspawner_nextspawntime //GetConVarNumber("vjstool_npcspawner_nextspawntime")
			if svgettype == "RightClick" then spawner.SingleSpawner = true end
			spawner:SetCreator(ply)
			spawner:Spawn()
			spawner:Activate()
			undo.Create("NPC Spawner")
			undo.AddEntity(spawner)
			undo.SetPlayer(ply)
			undo.Finish()
			for vpk,vpv in pairs(spawner.CurrentEntities) do
				if IsValid(vpv.TheEntity) && vpv.TheEntity.IsVJBaseSpawner == true && vpv.TheEntity.SingleSpawner == true then
					vpv.TheEntity:SetCreator(ply)
					table.remove(spawner.CurrentEntities,vpk)
					if table.Count(spawner.CurrentEntities) <= 0 then spawner:Remove() end
				end
			end
		end
	end)
end
---------------------------------------------------------------------------------------------------------------------------------------------
function TOOL:LeftClick(tr)
	if CLIENT then return true end
	net.Start("vj_npcspawner_cl_create")
	net.WriteVector(tr.HitPos)
	net.WriteString("LeftClick")
	net.Send(self:GetOwner())
	return true
end
---------------------------------------------------------------------------------------------------------------------------------------------
function TOOL:RightClick(tr)
	if CLIENT then return true end
	net.Start("vj_npcspawner_cl_create")
	net.WriteVector(tr.HitPos)
	net.WriteString("RightClick")
	net.Send(self:GetOwner())
	return true
end
---------------------------------------------------------------------------------------------------------------------------------------------
function TOOL:Reload(tr)
	if CLIENT then return true end
end
--PATH lua/weapons/jet_mk1.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/entities/weapons/keys/cl_menu.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/weapons/masita_dc15s.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/weapons/masita_dc15s_modular.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/weapons/masita_dc17s.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 1 -- Change this if you want to select the weapon with other number

SWEP.Category = "[ArcCW] Republic Essentials - Masita"
SWEP.Credits = "Kraken/Masita"
SWEP.PrintName = "DC-17s [Blue]"
SWEP.Trivia_Class = "Heavy Blaster Pistol"
SWEP.Trivia_Desc = "The DC-17s hand blaster, also known as DC-17s blaster pistol, was a heavy blaster pistol wielded by the clone troopers of the Grand Army of the Galactic Republic during the Clone Wars. An advanced firearm, it was fielded to elite soldiers in the army, most notably Advanced Recon Commandos, clone trooper commanders, and clone jet troopers. This one version is a powerful one."
SWEP.Trivia_Manufacturer = "BlasTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.Trivia_Year = 2023
SWEP.IconOverride = "entities/masita/dc17s_blue.png"

-- Viewmodel & Entity Properties
SWEP.MirrorVMWM = false
SWEP.UseHands = true
SWEP.ViewModel = "models/weapon/ven/ggn/dc17s_single.mdl"
SWEP.WorldModel = "models/arccw/bf2017/w_scoutblaster.mdl"
SWEP.ViewModelFOV = 60
SWEP.HideViewmodel = false
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.009
}

SWEP.DefaultSkin = 1

-- Damage & Tracer
SWEP.BodyDamageMults =  {
    [HITGROUP_HEAD] = 1.5,
    [HITGROUP_CHEST] = 1,
    [HITGROUP_LEFTARM] = 0.9,
    [HITGROUP_RIGHTARM] = 0.9,
}

SWEP.AutoReload = true
SWEP.Damage = 32
SWEP.RangeMin = 133
SWEP.DamageMin = 16
SWEP.Range = 550
SWEP.Penetration = 1.1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400
SWEP.PhysTracerProfile = 1
SWEP.TracerNum = 1
SWEP.Tracer = "tracer_blue"
SWEP.TracerCol = Color(0, 0, 255)
SWEP.HullSize = 1.5
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 20
SWEP.Recoil = 0.5
SWEP.RecoilPunch = 0.3
SWEP.RecoilSide = 0.2
SWEP.RecoilRise = 0.17
SWEP.Delay = 60 / 337
SWEP.Num = 1
SWEP.Firemodes = {
	{
		Mode = 1
	},
    {
        Mode = 2
    },
    {
        Mode = 0
    },    
}

SWEP.AccuracyMOA = 0.57
SWEP.HipDispersion = 576
SWEP.MoveDispersion = 53

-- Sounds & Muzzleflash
SWEP.ShootSound = "armas/disparos/dc17s.wav"
SWEP.ShootSoundSilenced = "armas/disparos/dc19.wav"
SWEP.NoFlash = nil 
SWEP.MuzzleEffect = "wpn_muzzleflash_dc17"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(0, 0, 255)


-- Ironsight & Holdtype
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.IronSightStruct = {
    Pos = Vector(-3.947, 1.389, 0.526),
    Ang = Angle(0, 0, 0),
     Magnification = 1,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 60,
}

SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "pistol"
SWEP.HoldtypeSights = "revolver"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_PISTOL

SWEP.ActivePos = Vector(1, 6, 1)
SWEP.ActiveAng = Angle(-3.2, -3, 0)

SWEP.SprintPos = Vector(1, -6, -10)
SWEP.SprintAng = Angle(40, 0, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.CustomizePos = Vector(10, 0, -1.08)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)


-- Attachments
SWEP.DefaultElements = {"dc17s"}
SWEP.AttachmentElements = {
    ["dc17s"] = { 
        WMElements = {
            {
                Model = "models/weapon/ven/ggn/dc17s_single_world.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1, 1, 1),
                ModelSkin = 1,
                Offset = {
                    pos = Vector(450, 50, -100),
                    ang = Angle(0, -10, -180),
                }
            },
            {
                Model = "models/hunter/plates/plate.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(0, 0, 0),
                Offset = {
                    pos = Vector(1900, 200, -200),
                    ang = Angle(0, -10, 180)
                },
                IsMuzzleDevice = true
            }, 
        },
    },
}
WMOverride = "models/weapon/ven/ggn/dc17s_single_world.mdl"

SWEP.Attachments = {
    {
        PrintName = "Sight", -- name of the attachment
        DefaultAttName = "Standard", -- default name (like: 'default', 'none', 'standard')
        Slot = "optic", -- slots, you can add attachments per slot using this: Slot = {"optic", "optics", "etc"},
        Bone = "DC17S_Root",
        WMScale = Vector(111, 111, 111),
        Offset = {
            vpos = Vector(0.001, -1.9, -2.32),
            vang = Angle(90, 0, -90),
            wpos = Vector(600, 100, -475),
            wang = Angle(0, -10, 180)
        },
    },
    {
        PrintName = "Laser/Flashlight", 
        DefaultAttName = "None",
        Slot = {"tac_pistol", "tactical"},
        Bone = "DC17S_Root",
        WMScale = Vector(111, 111, 111),
        Offset = {
            vpos = Vector(-0.101, 0.557, 7.738),
            vang = Angle(90, 0, -90),
            wpos = Vector(1450, 265, -175),
            wang = Angle(0, -10, 180)
        },
    },    
    {
        PrintName = "Ammo",
        DefaultAttName = "Standard",
        Slot = {"ammo", "special_ammo"}
    },
    {
        PrintName = "Perk", 
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = {"charm"},
        WMScale = Vector(111, 111, 111),
        Bone = "DC17S_Root",
        Offset = {
            vpos = Vector(0.768, -0.238, 0),
            vang = Angle(90, 0, -90),
            wpos = Vector(750, 225, -350),
            wang = Angle(0, -10, 180)
        },
    },          
}


-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["sprint"] = {
        Source = "base_sprint_loop"
    },
    ["fire"] = {
        Source = "shoot"
    },
    ["draw"] = {
        Source = "draw",
        Mult = 1.1,
        SoundTable = {
            {
                s = "armas/misc/dc17s_draw.wav",
                p = 100,
                v = 75, 
                t = 0,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "armas/misc/dc17s_holster.wav",
                p = 100, 
                v = 75,
                t = 0,
                c = CHAN_ITEM,
            },
        }
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL, 
        SoundTable = {
            {s = "dc17s_1", t = 1 / 30},
        },
    },
    ["reload_empty"] = {
        Source = "reload_empty",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL, 
        SoundTable = {
            {s = "dc17s_2", t = 4 / 30},
        },
    },


sound.Add({
    name =          "dc17s_1",
    channel =       CHAN_ITEM,
    volume =        1.5,
    sound =             "armas/misc/dc17s_reload.wav"
    }),
sound.Add({
    name =          "dc17s_2",
    channel =       CHAN_ITEM,
    volume =        1.5,
    sound =             "armas/misc/dc17s_empty.wav"
    }),
}



--PATH addons/[bronie] republic-essentials-v2d/lua/weapons/masita_dc17s_red.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/weapons/masita_valken38x.lua:
return gluapack()()
--PATH lua/weapons/mortar_constructor/shared.lua:
return gluapack()()
--PATH lua/weapons/mortar_constructor/shared.lua:
AddCSLuaFile()

SWEP.PrintName = "Mortar"
SWEP.Base = "weapon_base"

SWEP.Author = "DolUnity"
SWEP.Purpose = "Place a Mortar"
SWEP.Instructions = "Place the mortar with attack \nPick it up with duck and use"
SWEP.Category = "DolUnity"
SWEP.Spawnable = true
SWEP.ViewModel = "models/weapons/c_pistol.mdl"
SWEP.UseHands = true
SWEP.DrawAmmo = false

SWEP.Slot = 4

SWEP.Primary.ClipSize = 0
SWEP.Primary.DefaultClipSize = 0

SWEP.Secondary.ClipSize = 0
SWEP.Secondary.DefaultClipSize = 0

if (CLIENT) then
    SWEP.PreviewModel = ClientsideModel("models/dolunity/starwars/mortar.mdl")
    SWEP.PreviewModel:SetNoDraw(true)
    SWEP.PreviewModel:SetMaterial("models/wireframe")
end

function SWEP:PrimaryAttack()
    if (SERVER) then
        local ply = self.Owner
        if (ply:Alive() and IsValid(ply:GetActiveWeapon()) and (ply:GetActiveWeapon():GetClass() or ""):StartWith("mortar_constructor")) then
            local trace = ply:GetEyeTrace()
            local hitAngle = trace.HitNormal:Angle()

            local ent = ents.Create("mortar")
            ent:SetPos(trace.HitPos)
            ent:SetAngles(Angle(0,0,0))

            ent:SetLocalAngles(ent:WorldToLocalAngles(hitAngle) + Angle(90,0,0))

            ent:Spawn()
            if (ent:GetLocalAngles().x > 45 or ent:GetLocalAngles().z > 45) then
                ent:Remove()
            else
                ply:StripWeapon(self:GetClass())
            end
            self:OnSpawn(ent)
        end
    end
end

function SWEP:OnSpawn(ent)
end

function SWEP:SecondaryAttack() end

function SWEP:ShouldDrawViewModel()
    return false
end

function SWEP:DrawWorldModel()
end

hook.Add("PostDrawOpaqueRenderables", "DrawMortarPreview", function ()
    local ply = LocalPlayer()
    if (ply:Alive()
            and IsValid(ply:GetActiveWeapon())
            and (ply:GetActiveWeapon():GetClass() or ""):StartWith("mortar_constructor")
            and not ply:InVehicle()) then
        local weapon = ply:GetActiveWeapon()
        local trace = LocalPlayer():GetEyeTrace()
        weapon.PreviewModel:SetPos(trace.HitPos)
        weapon.PreviewModel:SetAngles(Angle(0,0,0))

        local hitAngle = trace.HitNormal:Angle()
        weapon.PreviewModel:SetLocalAngles(weapon.PreviewModel:WorldToLocalAngles(hitAngle) + Angle(90,0,0))

        if (weapon.PreviewModel:GetLocalAngles().x > 45 or weapon.PreviewModel:GetLocalAngles().z > 45) then
            weapon.Placeable = false
            render.SetColorModulation(255/255,0,0)
        else
            weapon.Placeable = true
            render.SetColorModulation(0,180/255,25/255)
        end
        weapon.PreviewModel:DrawModel()
        render.SetColorModulation(0,0,0)
    end
end)
--PATH gamemodes/starwarsrp/entities/weapons/pocket/shared.lua:
return gluapack()()
--PATH lua/weapons/tfa_gun_base/common/anims.lua:
return gluapack()()
--PATH lua/weapons/tfa_gun_base/common/autodetection.lua:
function SWEP:RunAutoDetection()
	local self2 = self:GetTable()

	self2.PatchAmmoTypeAccessors(self)

	self2.FixRPM(self)
	self2.FixIdles(self)
	self2.FixIS(self)
	self2.FixCone(self)
	self2.FixProjectile(self)
	self2.FixAkimbo(self) -- external: akimbo.lua
	self2.FixSprintAnimBob(self)
	self2.FixWalkAnimBob(self)

	self2.AutoDetectMuzzle(self)
	self2.AutoDetectDamage(self)
	self2.AutoDetectDamageType(self)
	self2.AutoDetectForce(self)
	self2.AutoDetectPenetrationPower(self)
	self2.AutoDetectKnockback(self)
	self2.AutoDetectSpread(self)
	self2.AutoDetectRange(self)
	self2.AutoDetectLowAmmoSound(self)

	self2.CreateFireModes(self)
	self2.IconFix(self)

	self2.RemoveEmptyRTCode(self)
end

function SWEP:FixSprintAnimBob()
	local self2 = self:GetTable()

	if self:GetStatRawL("Sprint_Mode") == TFA.Enum.LOCOMOTION_ANI then
		self:SetStatRawL("SprintBobMult", 0)
	end
end

function SWEP:FixWalkAnimBob()
	local self2 = self:GetTable()
	if self:GetStatRawL("Walk_Mode") == TFA.Enum.LOCOMOTION_ANI then
		self:SetStatRawL("WalkBobMult_Iron", self:GetStatRawL("WalkBobMult"))
		self:SetStatRawL("WalkBobMult", 0)
	end
end

function SWEP:PatchAmmoTypeAccessors()
	local self2 = self:GetTable()
	self:SetStatRawL("GetPrimaryAmmoTypeOld", self:GetStatRawL("GetPrimaryAmmoTypeOld") or self:GetStatRawL("GetPrimaryAmmoType"))
	self:SetStatRawL("GetPrimaryAmmoType", function(myself, ...) return myself.GetPrimaryAmmoTypeC(myself, ...) end)
	self:SetStatRawL("GetSecondaryAmmoTypeOld", self:GetStatRawL("GetSecondaryAmmoTypeOld") or self:GetStatRawL("GetSecondaryAmmoType"))
	self:SetStatRawL("GetSecondaryAmmoType", function(myself, ...) return myself.GetSecondaryAmmoTypeC(myself, ...) end)
end

function SWEP:FixProjectile()
	local self2 = self:GetTable()
	if self:GetStatRawL("ProjectileEntity") and self:GetStatRawL("ProjectileEntity") ~= "" then
		self:SetStatRawL("Primary.Projectile", self:GetStatRawL("ProjectileEntity"))
		self:SetStatRawL("ProjectileEntity", nil)
	end

	if self:GetStatRawL("ProjectileModel") and self:GetStatRawL("ProjectileModel") ~= "" then
		self:SetStatRawL("Primary.ProjectileModel", self:GetStatRawL("ProjectileModel"))
		self:SetStatRawL("ProjectileModel", nil)
	end

	if self:GetStatRawL("ProjectileVelocity") and self:GetStatRawL("ProjectileVelocity") ~= "" then
		self:SetStatRawL("Primary.ProjectileVelocity", self:GetStatRawL("ProjectileVelocity"))
		self:SetStatRawL("ProjectileVelocity", nil)
	end
end

local sv_tfa_range_modifier = GetConVar("sv_tfa_range_modifier")

function SWEP:AutoDetectRange()
	local self2 = self:GetTable()

	if self:GetStatL("Primary.FalloffMetricBased") and not self:GetStatRawL("Primary.RangeFalloffLUT") then
		self:SetStatRawL("Primary.RangeFalloffLUT_IsConverted", true)

		self:SetStatRawL("Primary.RangeFalloffLUT", {
			bezier = false,
			range_func = "linear", -- function to spline range
			units = "meters",
			lut = {
				{range = self:GetStatL("Primary.MinRangeStartFalloff"), damage = 1},
				{range = self:GetStatL("Primary.MinRangeStartFalloff") + self:GetStatL("Primary.MaxFalloff") / self:GetStatL("Primary.FalloffByMeter"),
					damage = (self:GetStatL("Primary.Damage") - self:GetStatL("Primary.MaxFalloff")) / self:GetStatL("Primary.Damage")},
			}
		})

		return
	end

	if self:GetStatL("Primary.FalloffMetricBased") or self:GetStatL("Primary.RangeFalloffLUT") then return end

	if self:GetStatL("Primary.Range") <= 0 then
		self:SetStatRawL("Primary.Range", math.sqrt(self:GetStatL("Primary.Damage") / 32) * self:MetersToUnits(350) * self:AmmoRangeMultiplier())
	end

	if self:GetStatL("Primary.RangeFalloff") <= 0 then
		self:SetStatRawL("Primary.RangeFalloff", 0.5)
	end

	self:SetStatRawL("Primary.RangeFalloffLUT_IsConverted", true)

	self:SetStatRawL("Primary.RangeFalloffLUT", {
		bezier = false,
		range_func = "linear", -- function to spline range
		units = "hammer",
		lut = {
			{range = self:GetStatL("Primary.Range") * self:GetStatL("Primary.RangeFalloff"), damage = 1},
			{range = self:GetStatL("Primary.Range"), damage = 1 - sv_tfa_range_modifier:GetFloat()},
		}
	})
end

function SWEP:FixProceduralReload()
	-- do nothing
end

function SWEP:FixRPM()
	local self2 = self:GetTable()
	if not self:GetStatRawL("Primary.RPM") then
		if self:GetStatRawL("Primary.Delay") then
			self:SetStatRawL("Primary.RPM", 60 / self:GetStatRawL("Primary.Delay"))
		else
			self:SetStatRawL("Primary.RPM", 120)
		end
	end
end

function SWEP:FixCone()
	local self2 = self:GetTable()
	if self:GetStatRawL("Primary.Cone") then
		if (not self:GetStatRawL("Primary.Spread")) or self:GetStatRawL("Primary.Spread") < 0 then
			self:SetStatRawL("Primary.Spread", self:GetStatRawL("Primary.Cone"))
		end

		self:SetStatRawL("Primary.Cone", nil)
	end
end

--legacy compatibility
function SWEP:FixIdles()
	local self2 = self:GetTable()
	if self:GetStatRawL("DisableIdleAnimations") ~= nil and self:GetStatRawL("DisableIdleAnimations") == true then
		self:SetStatRawL("Idle_Mode", TFA.Enum.IDLE_LUA)
	end
end

function SWEP:FixIS()
	local self2 = self:GetTable()
	if self:GetStatRawL("SightsPos") and (not self:GetStatRawL("IronSightsPosition") or (self:GetStatRawL("IronSightsPosition").x ~= self:GetStatRawL("SightsPos").x and self:GetStatRawL("SightsPos").x ~= 0)) then
		self:SetStatRawL("IronSightsPosition", self:GetStatRawL("SightsPos") or Vector())
		self:SetStatRawL("IronSightsAngle", self:GetStatRawL("SightsAng") or Vector())
	end
end

local legacy_spread_cv = GetConVar("sv_tfa_spread_legacy")

function SWEP:AutoDetectSpread()
	local self2 = self:GetTable()
	if legacy_spread_cv and legacy_spread_cv:GetBool() then
		self:SetUpSpreadLegacy()

		return
	end

	if self:GetStatRawL("Primary.SpreadMultiplierMax") == -1 or not self:GetStatRawL("Primary.SpreadMultiplierMax") then
		self:SetStatRawL("Primary.SpreadMultiplierMax", math.Clamp(math.sqrt(math.sqrt(self:GetStatRawL("Primary.Damage") / 35) * 10 / 5) * 5, 0.01 / self:GetStatRawL("Primary.Spread"), 0.1 / self:GetStatRawL("Primary.Spread")))
	end

	if self:GetStatRawL("Primary.SpreadIncrement") == -1 or not self:GetStatRawL("Primary.SpreadIncrement") then
		self:SetStatRawL("Primary.SpreadIncrement", self:GetStatRawL("Primary.SpreadMultiplierMax") * 60 / self:GetStatRawL("Primary.RPM") * 0.85 * 1.5)
	end

	if self:GetStatRawL("Primary.SpreadRecovery") == -1 or not self:GetStatRawL("Primary.SpreadRecovery") then
		self:SetStatRawL("Primary.SpreadRecovery", math.max(self:GetStatRawL("Primary.SpreadMultiplierMax") * math.pow(self:GetStatRawL("Primary.RPM") / 600, 1 / 3) * 0.75, self:GetStatRawL("Primary.SpreadMultiplierMax") / 1.5))
	end
end

--[[
Function Name:  AutoDetectMuzzle
Syntax: self:AutoDetectMuzzle().  Call only once, or it's redundant.
Returns:  Nothing.
Notes:  Detects the proper muzzle flash effect if you haven't specified one.
Purpose:  Autodetection
]]
--
function SWEP:AutoDetectMuzzle()
	local self2 = self:GetTable()
	if not self:GetStatRawL("MuzzleFlashEffect") then
		local a = string.lower(self:GetStatRawL("Primary.Ammo"))
		local cat = string.lower(self:GetStatRawL("Category") and self:GetStatRawL("Category") or "")

		if self:GetStatRawL("Silenced") or self:GetSilenced() then
			self:SetStatRawL("MuzzleFlashEffect", "tfa_muzzleflash_silenced")
		elseif string.find(a, "357") or self:GetStatRawL("Revolver") or string.find(cat, "revolver") then
			self:SetStatRawL("MuzzleFlashEffect", "tfa_muzzleflash_revolver")
		elseif self:GetStatL("LoopedReload") or a == "buckshot" or a == "slam" or a == "airboatgun" or string.find(cat, "shotgun") then
			self:SetStatRawL("MuzzleFlashEffect", "tfa_muzzleflash_shotgun")
		elseif string.find(a, "smg") or string.find(cat, "smg") or string.find(cat, "submachine") or string.find(cat, "sub-machine") then
			self:SetStatRawL("MuzzleFlashEffect", "tfa_muzzleflash_smg")
		elseif string.find(a, "sniper") or string.find(cat, "sniper") then
			self:SetStatRawL("MuzzleFlashEffect", "tfa_muzzleflash_sniper")
		elseif string.find(a, "pistol") or string.find(cat, "pistol") then
			self:SetStatRawL("MuzzleFlashEffect", "tfa_muzzleflash_pistol")
		elseif string.find(a, "ar2") or string.find(a, "rifle") or (string.find(cat, "revolver") and not string.find(cat, "rifle")) then
			self:SetStatRawL("MuzzleFlashEffect", "tfa_muzzleflash_rifle")
		else
			self:SetStatRawL("MuzzleFlashEffect", "tfa_muzzleflash_generic")
		end
	end
end

--[[
Function Name:  AutoDetectDamage
Syntax: self:AutoDetectDamage().  Call only once.  Hopefully you call this only once on like SWEP:Initialize() or something.
Returns:  Nothing.
Notes:  Fixes the damage for GDCW.
Purpose:  Autodetection
]]
--
function SWEP:AutoDetectDamage()
	local self2 = self:GetTable()
	if self:GetStatRawL("Primary.Damage") and self:GetStatRawL("Primary.Damage") ~= -1 then return end

	if self:GetStatRawL("Primary.Round") then
		local rnd = string.lower(self:GetStatRawL("Primary.Round"))

		if string.find(rnd, ".50bmg") then
			self:SetStatRawL("Primary.Damage", 185)
		elseif string.find(rnd, "5.45x39") then
			self:SetStatRawL("Primary.Damage", 22)
		elseif string.find(rnd, "5.56x45") then
			self:SetStatRawL("Primary.Damage", 30)
		elseif string.find(rnd, "338_lapua") then
			self:SetStatRawL("Primary.Damage", 120)
		elseif string.find(rnd, "338") then
			self:SetStatRawL("Primary.Damage", 100)
		elseif string.find(rnd, "7.62x51") then
			self:SetStatRawL("Primary.Damage", 100)
		elseif string.find(rnd, "9x39") then
			self:SetStatRawL("Primary.Damage", 32)
		elseif string.find(rnd, "9mm") then
			self:SetStatRawL("Primary.Damage", 22)
		elseif string.find(rnd, "9x19") then
			self:SetStatRawL("Primary.Damage", 22)
		elseif string.find(rnd, "9x18") then
			self:SetStatRawL("Primary.Damage", 20)
		end

		if string.find(rnd, "ap") then
			self:SetStatRawL("Primary.Damage", self:GetStatRawL("Primary.Damage") * 1.2)
		end
	end

	if (not self:GetStatRawL("Primary.Damage")) or (self:GetStatRawL("Primary.Damage") <= 0.01) and self:GetStatRawL("Velocity") then
		self:SetStatRawL("Primary.Damage", self:GetStatRawL("Velocity") / 5)
	end

	if (not self:GetStatRawL("Primary.Damage")) or (self:GetStatRawL("Primary.Damage") <= 0.01) then
		self:SetStatRawL("Primary.Damage", (self:GetStatRawL("Primary.KickUp") + self:GetStatRawL("Primary.KickUp") + self:GetStatRawL("Primary.KickUp")) * 10)
	end
end

--[[
Function Name:  AutoDetectDamageType
Syntax: self:AutoDetectDamageType().  Call only once.  Hopefully you call this only once on like SWEP:Initialize() or something.
Returns:  Nothing.
Notes:  Sets a damagetype
Purpose:  Autodetection
]]
--
function SWEP:AutoDetectDamageType()
	local self2 = self:GetTable()
	if self:GetStatRawL("Primary.DamageType") == -1 or not self:GetStatRawL("Primary.DamageType") then
		if self:GetStatRawL("DamageType") and not self:GetStatRawL("Primary.DamageType") then
			self:SetStatRawL("Primary.DamageType", self:GetStatRawL("DamageType"))
		else
			self:SetStatRawL("Primary.DamageType", DMG_BULLET)
		end
	end
end

--[[
Function Name:  AutoDetectForce
Syntax: self:AutoDetectForce().  Call only once.  Hopefully you call this only once on like SWEP:Initialize() or something.
Returns:  Nothing.
Notes:  Detects force from damage
Purpose:  Autodetection
]]
--
function SWEP:AutoDetectForce()
	local self2 = self:GetTable()
	if self:GetStatRawL("Primary.Force") == -1 or not self:GetStatRawL("Primary.Force") then
		self:SetStatRawL("Primary.Force", self:GetStatRawL("Force") or (math.sqrt(self:GetStatRawL("Primary.Damage") / 16) * 3 / math.sqrt(self:GetStatRawL("Primary.NumShots"))))
	end
end

function SWEP:AutoDetectPenetrationPower()
	local self2 = self:GetTable()

	if self:GetStatRawL("Primary.PenetrationPower") == -1 or not self:GetStatRawL("Primary.PenetrationPower") then
		local am = string.lower(self:GetStatL("Primary.Ammo"))
		local m = 1

		if (am == "pistol") then
			m = 0.4
		elseif (am == "357") then
			m = 1.75
		elseif (am == "smg1") then
			m = 0.34
		elseif (am == "ar2") then
			m = 1.1
		elseif (am == "buckshot") then
			m = 0.3
		elseif (am == "airboatgun") then
			m = 2.25
		elseif (am == "sniperpenetratedround") then
			m = 3
		end

		self:SetStatRawL("Primary.PenetrationPower", self:GetStatRawL("PenetrationPower") or math.sqrt(self:GetStatRawL("Primary.Force") * 200 * m))
	end
end

--[[
Function Name:  AutoDetectKnockback
Syntax: self:AutoDetectKnockback().  Call only once.  Hopefully you call this only once on like SWEP:Initialize() or something.
Returns:  Nothing.
Notes:  Detects knockback from force
Purpose:  Autodetection
]]
--
function SWEP:AutoDetectKnockback()
	local self2 = self:GetTable()
	if self:GetStatRawL("Primary.Knockback") == -1 or not self:GetStatRawL("Primary.Knockback") then
		self:SetStatRawL("Primary.Knockback", self:GetStatRawL("Knockback") or math.max(math.pow(self:GetStatRawL("Primary.Force") - 3.25, 2), 0) * math.pow(self:GetStatRawL("Primary.NumShots"), 1 / 3))
	end
end

--[[
Function Name:  IconFix
Syntax: self:IconFix().  Call only once.  Hopefully you call this only once on like SWEP:Initialize() or something.
Returns:  Nothing.
Notes:  Fixes the icon.  Call this if you give it a texture path, or just nothing.
Purpose:  Autodetection
]]
--
local selicon_final = {}

function SWEP:IconFix()
	local self2 = self:GetTable()

	if not surface then return end

	local class = self2.ClassName

	if selicon_final[class] then
		self:SetStatRawL("WepSelectIcon", selicon_final[class])

		return
	end

	if self2.WepSelectIcon and type(self2.WepSelectIcon) == "string" then
		self:SetStatRawL("WepSelectIcon", surface.GetTextureID(self2.WepSelectIcon))
	else
		if file.Exists("materials/vgui/hud/" .. class .. ".png", "GAME") then
			self:SetStatRawL("WepSelectIcon", Material("vgui/hud/" .. class .. ".png", "smooth noclamp")) -- NOTHING should access this variable directly and our DrawWeaponSelection override supports IMaterial.
		elseif file.Exists("materials/vgui/hud/" .. class .. ".vmt", "GAME") then
			self:SetStatRawL("WepSelectIcon", surface.GetTextureID("vgui/hud/" .. class))
		end
	end

	selicon_final[class] = self2.WepSelectIcon
end

--[[
Function Name:  CorrectScopeFOV
Syntax: self:CorrectScopeFOV( fov ).  Call only once.  Hopefully you call this only once on like SWEP:Initialize() or something.
Returns:  Nothing.
Notes:  If you're using scopezoom instead of FOV, this translates it.
Purpose:  Autodetection
]]
--
function SWEP:CorrectScopeFOV(fov)
	local self2 = self:GetTable()
	fov = fov or self:GetStatRawL("DefaultFOV")

	if not self:GetStatRawL("Secondary.OwnerFOV") or self:GetStatRawL("Secondary.OwnerFOV") <= 0 then
		if self:GetStatRawL("Scoped") and self:GetStatL("Secondary.ScopeZoom", -1) >= 1 then
			self:SetStatRawL("Secondary.OwnerFOV", fov / self:GetStatL("Secondary.ScopeZoom"))
		elseif self:GetStatRawL("Scoped_3D") then
			self:SetStatRawL("Secondary.OwnerFOV", 70)
		else
			self:SetStatRawL("Secondary.OwnerFOV", 32)
		end
	end
end

--[[
Function Name:  CreateFireModes
Syntax: self:CreateFireModes( is first draw).  Call as much as you like.  isfirstdraw controls whether the default fire mode is set.
Returns:  Nothing.
Notes:  Autodetects fire modes depending on what params you set up.
Purpose:  Autodetection
]]
--
SWEP.FireModeCache = {}

function SWEP:CreateFireModes(isfirstdraw)
	local self2 = self:GetTable()
	if not self2.FireModes then
		self:SetStatRawL("FireModes", {})
		local burstcnt = self:FindEvenBurstNumber()

		if self2.SelectiveFire then
			if self2.OnlyBurstFire then
				if burstcnt then
					self2.FireModes[1] = burstcnt .. "Burst"
					self2.FireModes[2] = "Single"
				else
					self2.FireModes[1] = "Single"
				end
			else
				self2.FireModes[1] = "Automatic"

				if self2.DisableBurstFire then
					self2.FireModes[2] = "Single"
				else
					if burstcnt then
						self2.FireModes[2] = burstcnt .. "Burst"
						self2.FireModes[3] = "Single"
					else
						self2.FireModes[2] = "Single"
					end
				end
			end
		else
			if self2.Primary_TFA.Automatic then
				self2.FireModes[1] = "Automatic"

				if self2.OnlyBurstFire and burstcnt then
					self2.FireModes[1] = burstcnt .. "Burst"
				end
			else
				self2.FireModes[1] = "Single"
			end
		end
	end

	if self2.FireModes[#self2.FireModes] ~= "Safe" then
		self2.FireModes[#self2.FireModes + 1] = "Safe"
	end

	if not self2.FireModeCache or #self2.FireModeCache <= 0 then
		for k, v in ipairs(self2.FireModes) do
			self2.FireModeCache[v] = k
		end

		if type(self2.DefaultFireMode) == "number" then
			self:SetFireMode(self2.DefaultFireMode or (self2.Primary_TFA.Automatic and 1 or #self2.FireModes - 1))
		else
			self:SetFireMode(self2.FireModeCache[self2.DefaultFireMode] or (self2.Primary_TFA.Automatic and 1 or #self2.FireModes - 1))
		end
	end
end

--[[
Function Name:  CacheAnimations
Syntax: self:CacheAnimations().  Call as much as you like.
Returns:  Nothing.
Notes:  This is what autodetects animations for the SWEP.SequenceEnabled and SWEP.SequenceLength tables.
Purpose:  Autodetection
]]
--
--SWEP.actlist = {ACT_VM_DRAW, ACT_VM_DRAW_EMPTY, ACT_VM_DRAW_SILENCED, ACT_VM_DRAW_DEPLOYED, ACT_VM_HOLSTER, ACT_VM_HOLSTER_EMPTY, ACT_VM_IDLE, ACT_VM_IDLE_EMPTY, ACT_VM_IDLE_SILENCED, ACT_VM_PRIMARYATTACK, ACT_VM_PRIMARYATTACK_1, ACT_VM_PRIMARYATTACK_EMPTY, ACT_VM_PRIMARYATTACK_SILENCED, ACT_VM_SECONDARYATTACK, ACT_VM_RELOAD, ACT_VM_RELOAD_EMPTY, ACT_VM_RELOAD_SILENCED, ACT_VM_ATTACH_SILENCER, ACT_VM_RELEASE, ACT_VM_DETACH_SILENCER, ACT_VM_FIDGET, ACT_VM_FIDGET_EMPTY, ACT_VM_FIDGET_SILENCED, ACT_SHOTGUN_RELOAD_START, ACT_VM_DRYFIRE, ACT_VM_DRYFIRE_SILENCED }
--If you really want, you can remove things from SWEP.actlist and manually enable animations and set their lengths.
SWEP.SequenceEnabled = {}
SWEP.SequenceLength = {}
SWEP.SequenceLengthOverride = {} --Override this if you want to change the length of a sequence but not the next idle
SWEP.ActCache = {}
local vm, seq

function SWEP:CacheAnimations()
	local self2 = self:GetTable()
	table.Empty(self2.ActCache)

	if self:GetStatRawL("CanBeSilenced") and self2.SequenceEnabled[ACT_VM_IDLE_SILENCED] == nil then
		self2.SequenceEnabled[ACT_VM_IDLE_SILENCED] = true
	end

	if not self2.VMIV(self) then return end
	vm = self2.OwnerViewModel

	if IsValid(vm) then
		self:BuildAnimActivities()

		for _, v in ipairs(table.GetKeys(self2.AnimationActivities)) do
			if isnumber(v) then
				seq = vm:SelectWeightedSequence(v)

				if seq ~= -1 and vm:GetSequenceActivity(seq) == v and not self2.ActCache[seq] then
					self2.SequenceEnabled[v] = true
					self2.SequenceLength[v] = vm:SequenceDuration(seq)
					self2.ActCache[seq] = v
				else
					self2.SequenceEnabled[v] = false
					self2.SequenceLength[v] = 0.0
				end
			else
				local s = vm:LookupSequence(v)

				if s and s > 0 then
					self2.SequenceEnabled[v] = true
					self2.SequenceLength[v] = vm:SequenceDuration(s)
					self2.ActCache[s] = v
				else
					self2.SequenceEnabled[v] = false
					self2.SequenceLength[v] = 0.0
				end
			end
		end
	else
		return false
	end

	if self:GetStatRawL("ProceduralHolsterEnabled") == nil then
		if self2.SequenceEnabled[ACT_VM_HOLSTER] then
			self:SetStatRawL("ProceduralHolsterEnabled", false)
		else
			self:SetStatRawL("ProceduralHolsterEnabled", true)
		end
	end

	self:SetStatRawL("HasDetectedValidAnimations", true)

	return true
end

function SWEP:GetType()
	if self:GetStatRawL("Type") then return self:GetStatRawL("Type") end
	local at = string.lower(self:GetStatRawL("Primary.Ammo") or "")
	local ht = string.lower((self:GetStatRawL("DefaultHoldType") or self:GetStatRawL("HoldType")) or "")
	local rpm = self:GetStatRawL("Primary.RPM_Displayed") or self:GetStatRawL("Primary.RPM") or 600

	if self:GetStatRawL("Primary.Projectile") or self:GetStatRawL("ProjectileEntity") then
		if (self:GetStatRawL("Primary.ProjectileVelocity") or self:GetStatRawL("ProjectileVelocity")) > 400 then
			self:SetStatRawL("Type", "Launcher")
		else
			self:SetStatRawL("Type", "Grenade")
		end

		return self:GetType()
	end

	if at == "buckshot" then
		self:SetStatRawL("Type", "Shotgun")

		return self:GetType()
	end

	if self:GetStatRawL("Pistol") or (at == "pistol" and (ht == "pistol" or ht == "revolver")) then
		self:SetStatRawL("Type", "Pistol")

		return self:GetType()
	end

	if self:GetStatRawL("SMG") or (at == "smg1" and (ht == "smg" or ht == "pistol" or ht == "357")) then
		self:SetStatRawL("Type", "Sub-Machine Gun")

		return self:GetType()
	end

	if self:GetStatRawL("Revolver") or (at == "357" and ht == "revolver") then
		self:SetStatRawL("Type", "Revolver")

		return self:GetType()
	end

	--Detect Sniper Type
	if ( (self:GetStatRawL("Scoped") or self:GetStatRawL("Scoped_3D")) and rpm < 600 ) or at == "sniperpenetratedround" then
		if rpm > 180 and (self:GetStatRawL("Primary.Automatic") or self:GetStatRawL("Primary.SelectiveFire")) then
			self:SetStatRawL("Type", "Designated Marksman Rifle")

			return self:GetType()
		else
			self:SetStatRawL("Type", "Sniper Rifle")

			return self:GetType()
		end
	end

	--Detect based on holdtype
	if ht == "pistol" then
		if self:GetStatRawL("Primary.Automatic") then
			self:SetStatRawL("Type", "Machine Pistol")
		else
			self:SetStatRawL("Type", "Pistol")
		end

		return self:GetType()
	end

	if ht == "duel" then
		if at == "pistol" then
			self:SetStatRawL("Type", "Dual Pistols")

			return self:GetType()
		elseif at == "357" then
			self:SetStatRawL("Type", "Dual Revolvers")

			return self:GetType()
		elseif at == "smg1" then
			self:SetStatRawL("Type", "Dual Sub-Machine Guns")

			return self:GetType()
		else
			self:SetStatRawL("Type", "Dual Guns")

			return self:GetType()
		end
	end

	--If it's using rifle ammo, it's a rifle or a carbine
	if at == "ar2" then
		if self:GetStatRawL("Primary.ClipSize") >= 60 then
			self:SetStatRawL("Type", "Light Machine Gun")

			return self:GetType()
		elseif ht == "rpg" or ht == "revolver" then
			self:SetStatRawL("Type", "Carbine")

			return self:GetType()
		else
			self:SetStatRawL("Type", "Rifle")

			return self:GetType()
		end
	end

	--Check SMG one last time
	if ht == "smg" or at == "smg1" then
		self:SetStatRawL("Type", "Sub-Machine Gun")

		return self:GetType()
	end

	if self:GetStatRawL("IsMelee") then
		self:SetStatRawL("Type", "Melee")

		return self:GetType()
	end

	if self:GetStatRawL("IsBow") then
		self:SetStatRawL("Type", "Bow")

		return self:GetType()
	end

	--Fallback to generic
	self:SetStatRawL("Type", "Weapon")

	return self:GetType()
end

function SWEP:SetUpSpreadLegacy()
	local ht = self:GetStatRawL("DefaultHoldType") and self:GetStatRawL("DefaultHoldType") or self:GetStatRawL("HoldType")

	if not self:GetStatRawL("Primary.SpreadMultiplierMax") or self:GetStatRawL("Primary.SpreadMultiplierMax") <= 0 or self:GetStatRawL("AutoDetectSpreadMultiplierMax") then
		self:SetStatRawL("Primary.SpreadMultiplierMax", 2.5 * math.max(self:GetStatRawL("Primary.RPM"), 400) / 600 * math.sqrt(self:GetStatRawL("Primary.Damage") / 30 * self:GetStatRawL("Primary.NumShots"))) --How far the spread can expand when you shoot.

		if ht == "smg" then
			self:SetStatRawL("Primary.SpreadMultiplierMax", self:GetStatRawL("Primary.SpreadMultiplierMax") * 0.8)
		end

		if ht == "revolver" then
			self:SetStatRawL("Primary.SpreadMultiplierMax", self:GetStatRawL("Primary.SpreadMultiplierMax") * 2)
		end

		if self:GetStatRawL("Scoped") then
			self:SetStatRawL("Primary.SpreadMultiplierMax", self:GetStatRawL("Primary.SpreadMultiplierMax") * 1.5)
		end

		self:SetStatRawL("AutoDetectSpreadMultiplierMax", true)
	end

	if not self:GetStatRawL("Primary.SpreadIncrement") or self:GetStatRawL("Primary.SpreadIncrement") <= 0 or self:GetStatRawL("AutoDetectSpreadIncrement") then
		self:SetStatRawL("AutoDetectSpreadIncrement", true)
		self:SetStatRawL("Primary.SpreadIncrement", 1 * math.Clamp(math.sqrt(self:GetStatRawL("Primary.RPM")) / 24.5, 0.7, 3) * math.sqrt(self:GetStatRawL("Primary.Damage") / 30 * self:GetStatRawL("Primary.NumShots"))) --What percentage of the modifier is added on, per shot.

		if ht == "revolver" then
			self:SetStatRawL("Primary.SpreadIncrement", self:GetStatRawL("Primary.SpreadIncrement") * 2)
		end

		if ht == "pistol" then
			self:SetStatRawL("Primary.SpreadIncrement", self:GetStatRawL("Primary.SpreadIncrement") * 1.35)
		end

		if ht == "ar2" or ht == "rpg" then
			self:SetStatRawL("Primary.SpreadIncrement", self:GetStatRawL("Primary.SpreadIncrement") * 0.65)
		end

		if ht == "smg" then
			self:SetStatRawL("Primary.SpreadIncrement", self:GetStatRawL("Primary.SpreadIncrement") * 1.75)
			self:SetStatRawL("Primary.SpreadIncrement", self:GetStatRawL("Primary.SpreadIncrement") * (math.Clamp((self:GetStatRawL("Primary.RPM") - 650) / 150, 0, 1) + 1))
		end

		if ht == "pistol" and self:GetStatRawL("Primary.Automatic") == true then
			self:SetStatRawL("Primary.SpreadIncrement", self:GetStatRawL("Primary.SpreadIncrement") * 1.5)
		end

		if self:GetStatRawL("Scoped") then
			self:SetStatRawL("Primary.SpreadIncrement", self:GetStatRawL("Primary.SpreadIncrement") * 1.25)
		end

		self:SetStatRawL("Primary.SpreadIncrement", self:GetStatRawL("Primary.SpreadIncrement") * math.sqrt(self:GetStatRawL("Primary.Recoil") * (self:GetStatRawL("Primary.KickUp") + self:GetStatRawL("Primary.KickDown") + self:GetStatRawL("Primary.KickHorizontal"))) * 0.8)
	end

	if not self:GetStatRawL("Primary.SpreadRecovery") or self:GetStatRawL("Primary.SpreadRecovery") <= 0 or self:GetStatRawL("AutoDetectSpreadRecovery") then
		self:SetStatRawL("AutoDetectSpreadRecovery", true)
		self:SetStatRawL("Primary.SpreadRecovery", math.sqrt(math.max(self:GetStatRawL("Primary.RPM"), 300)) / 29 * 4) --How much the spread recovers, per second.

		if ht == "smg" then
			self:SetStatRawL("Primary.SpreadRecovery", self:GetStatRawL("Primary.SpreadRecovery") * (1 - math.Clamp((self:GetStatRawL("Primary.RPM") - 600) / 200, 0, 1) * 0.33))
		end
	end
end

SWEP.LowAmmoSoundTypeBlacklist = {
	["launcher"] = true,
	["grenade"] = true,
}

SWEP.LowAmmoSoundByType = {
	["handgun"] = "TFA.LowAmmo.Handgun",
	["pistol"] = "TFA.LowAmmo.Handgun",
	["dualpistols"] = "TFA.LowAmmo.Handgun",
	["machinepistol"] = "TFA.LowAmmo.Handgun",
	["handcannon"] = "TFA.LowAmmo.Revolver",
	["revolver"] = "TFA.LowAmmo.Revolver",
	["dualrevolvers"] = "TFA.LowAmmo.Revolver",
	["shotgun"] = "TFA.LowAmmo.Shotgun",
	["machinegun"] = "TFA.LowAmmo.MachineGun",
	["lightmachinegun"] = "TFA.LowAmmo.MachineGun",
	["heavymachinegun"] = "TFA.LowAmmo.MachineGun",
	["carbine"] = "TFA.LowAmmo.AssaultRifle",
	["rifle"] = "TFA.LowAmmo.AssaultRifle",
	["assaultrifle"] = "TFA.LowAmmo.AssaultRifle",
	["dmr"] = "TFA.LowAmmo.DMR",
	["designatedmarksmanrifle"] = "TFA.LowAmmo.DMR",
	["sniperrifle"] = "TFA.LowAmmo.Sniper",
	["smg"] = "TFA.LowAmmo.SMG",
	["submachinegun"] = "TFA.LowAmmo.SMG",
}
SWEP.LastAmmoSoundByType = {
	["handgun"] = "TFA.LowAmmo.Handgun_Dry",
	["pistol"] = "TFA.LowAmmo.Handgun_Dry",
	["dualpistols"] = "TFA.LowAmmo.Handgun_Dry",
	["machinepistol"] = "TFA.LowAmmo.Handgun_Dry",
	["handcannon"] = "TFA.LowAmmo.Revolver_Dry",
	["revolver"] = "TFA.LowAmmo.Revolver_Dry",
	["dualrevolvers"] = "TFA.LowAmmo.Revolver_Dry",
	["shotgun"] = "TFA.LowAmmo.Shotgun_Dry",
	["machinegun"] = "TFA.LowAmmo.MachineGun_Dry",
	["lightmachinegun"] = "TFA.LowAmmo.MachineGun_Dry",
	["heavymachinegun"] = "TFA.LowAmmo.MachineGun_Dry",
	["carbine"] = "TFA.LowAmmo.AssaultRifle_Dry",
	["rifle"] = "TFA.LowAmmo.AssaultRifle_Dry",
	["assaultrifle"] = "TFA.LowAmmo.AssaultRifle_Dry",
	["dmr"] = "TFA.LowAmmo.DMR_Dry",
	["designatedmarksmanrifle"] = "TFA.LowAmmo.DMR_Dry",
	["sniperrifle"] = "TFA.LowAmmo.Sniper_Dry",
	["smg"] = "TFA.LowAmmo.SMG_Dry",
	["submachinegun"] = "TFA.LowAmmo.SMG_Dry",
}

function SWEP:AutoDetectLowAmmoSound()
	if not self.FireSoundAffectedByClipSize then return end

	local t1, t2 = self:GetType():lower():gsub("[^%w]+", ""), (self:GetStatRawL("Type_Displayed") or ""):lower():gsub("[^%w]+", "")

	if self.LowAmmoSoundTypeBlacklist[t2] or self.LowAmmoSoundTypeBlacklist[t1] then return end

	local clip1 = self:GetStatRawL("Primary.ClipSize")
	if (not clip1 or clip1 <= 4) then return end

	if not self.LowAmmoSound then
		local snd = self.LowAmmoSoundByType[t2] or self.LowAmmoSoundByType[t1] or "TFA.LowAmmo"

		if (t2 == "shotgun" or t1 == "shotgun") and not self:GetStatL("LoopedReload") then
			snd = "TFA.LowAmmo.AutoShotgun"
		end

		self:SetStatRawL("LowAmmoSound", snd)
	end

	if not self.LastAmmoSound then
		local snd = self.LastAmmoSoundByType[t2] or self.LastAmmoSoundByType[t1] or "TFA.LowAmmo_Dry"

		if (t2 == "shotgun" or t1 == "shotgun") and not self:GetStatL("LoopedReload") then
			snd = "TFA.LowAmmo.AutoShotgun_Dry"
		end

		self:SetStatRawL("LastAmmoSound", snd)
	end
end

local EmptyFunctions = {
	string.dump(function() end, true),
	string.dump(function(self) end, true),
}
function SWEP:RemoveEmptyRTCode()
	if not self.RTCode or type(self.RTCode) ~= "function" then return end

	local dump = string.dump(self.RTCode, true)
	for _, str in ipairs(EmptyFunctions) do
		if dump == str then
			self.RTCode = nil

			break
		end
	end
end
--PATH lua/weapons/tfa_gun_base/common/utils.lua:
return gluapack()()
--PATH lua/weapons/tfa_swsft_base_servius/cl_init.lua:
return gluapack()()
--PATH addons/[bronie] kajdanki/lua/weapons/weapon_cuff_rope.lua:
return gluapack()()
--PATH addons/[bronie] kajdanki/lua/weapons/weapon_cuff_standard.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/entities/weapons/weapon_deagle2/shared.lua:
return gluapack()()
--PATH lua/weapons/weapon_drakamassif/shared.lua:
--THIS SHIT YOU SHOULD NOT NEED TO MESS WITH
if (SERVER) then
	AddCSLuaFile("shared.lua")
	
	resource.AddFile("sound/weapons/weapon_drakamassif/dogbark_1.wav")
	resource.AddFile("sound/weapons/weapon_drakamassif/dogbark_2.wav")
	resource.AddFile("sound/weapons/weapon_drakamassif/dogbark_3.wav")
	resource.AddFile("sound/weapons/weapon_drakamassif/doggrowl_1.wav")
	
	resource.AddFile("materials/vgui/weapons/weapon_drakamassif/biteicon.vtf")
	resource.AddFile("materials/vgui/weapons/weapon_drakamassif/biteicon.vmt")
	
	resource.AddFile("models/weapons/blank.mdl")
	
	SWEP.Weight = 10
end
--END OF SHIT THAT SHOULDN'T BE MESSED WITH

if (CLIENT) then
	SWEP.BounceWeaponIcon = false
	SWEP.WepSelectIcon = surface.GetTextureID("vgui/weapons/weapon_drakamassif/biteicon")
	killicon.Add("weapon_drakamassif", "vgui/weapons/weapon_drakamassif/biteicon", Color(255, 80, 0, 255))
end

SWEP.Author = "Draka"
--Credit for audio resources: audioblocks.com
SWEP.Contact = ""
SWEP.Purpose = "Taper... Grogner... Grogner.. Taper.."
SWEP.Instructions = "M1: Taper, M2: Grogner"

SWEP.Category = "Massif Swep"
SWEP.PrintName = "Massif Swep"
SWEP.AutoSwitchTo = true
SWEP.AutoSwitchFrom	= true

--Configured for DarkRP.
--For Sandbox set these two to "true"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 1
SWEP.SlotPos = 3
SWEP.DrawAmmo = false
SWEP.DrawCrosshair = true

--How should we hold the ability to bite?
SWEP.HoldType = "fist"

--Should they bite underwater?
SWEP.FiresUnderwater = true

--Since it's a pet's ability to bite, it doesn't need ammo
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1

--Attributes of biting someone
SWEP.Primary.NumberofShots = 1
SWEP.Primary.Force = 20
SWEP.Primary.Damage = 250
SWEP.Primary.Recoil = 5

--Semi-auto biting preferred, unless it's a beaver on cocainum
SWEP.Primary.Automatic = false

--Ammo is capacity to bite... so none.
SWEP.Primary.Ammo = ""

--The sound of biting
SWEP.Primary.Sound = Sound("weapons/weapon_drakamassif/doggrowl_1.wav")

--How beaver-like the bites should be in seconds
SWEP.Primary.Delay = 0.5

--Basically the same for the Secondary functions
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = ""

--How Alley Cat-like the barking should be in seconds
SWEP.Secondary.Delay = 0.5

--Open wide (initialize the biting)
function SWEP:Initialize()	
	util.PrecacheSound("sound/weapons/weapon_drakamassif/dogbark_1.wav")
	util.PrecacheSound("sound/weapons/weapon_drakamassif/dogbark_2.wav")
	util.PrecacheSound("sound/weapons/weapon_drakamassif/dogbark_3.wav")
	util.PrecacheSound("sound/weapons/weapon_drakamassif/doggrowl_1.wav")
	
	if (SERVER) then
		self:SetWeaponHoldType(self.HoldType)
		self.Weapon:SetMoveType( MOVETYPE_WALK )
	end
	
	--The sounds of barking
	DogBarks = {
		Sound( "weapons/weapon_drakamassif/dogbark_1.wav" ),
		Sound( "weapons/weapon_drakamassif/dogbark_2.wav" ),
		Sound( "weapons/weapon_drakamassif/dogbark_3.wav" )
	}
end

function SWEP:Deploy()
	if SERVER then
		self.Owner:DrawViewModel(false)
		self.Owner:DrawWorldModel(false)
	end
end

--The bite of the pet.
function SWEP:PrimaryAttack()
	if (!self:CanPrimaryAttack()) then return end
	
	--the meat of the bite
	if self.Owner:Alive() then
		self.Weapon:EmitSound(self.Primary.Sound)
		self:Bite()
		self.Owner:ViewPunch(Angle(rnda, rndb, rnda))
		self.Weapon:SetNextPrimaryFire(CurTime()+self.Primary.Delay)
		self.Weapon:SetNextSecondaryFire(CurTime()+self.Primary.Delay)
	end
end

function SWEP:CanPrimaryAttack()
	if (self.Weapon.Primary.ClipSize <= 0) then
		return true
	end
end

function SWEP:Bite()
	pos = self.Owner:GetShootPos()
	ang = self.Owner:GetAimVector()
	dmg = self.Primary.Damage
	
	local trace = self.Owner:GetEyeTrace()
	
	if trace.HitPos:Distance(self.Owner:GetShootPos()) <= 100 then
		if(trace.Entity:GetClass() == "prop_physics") then
			self.Weapon:EmitSound(self.Primary.Sound)
			return
		end
		local bite = {}
		bite.Num = self.Primary.NumberofShots
		bite.Src = pos
		bite.Dir = ang
		bite.Spread = Vector(0, 0, 0)
		bite.Tracer = 0
		bite.Force = self.Primary.Force
		bite.Damage = dmg
		local rnda = self.Primary.Recoil*-1
		local rndb = self.Primary.Recoil*math.random(-1,1)
		self.Owner:FireBullets(bite)
	
		if(trace.Entity:IsPlayer() || trace.Entity:IsNPC() || trace.Entity:GetClass() == "prop_ragdoll") then
			self:EmitSound(Sound("Weapon_Crowbar.Melee_Hit"))
			local effectdata = EffectData()
			util.Effect( "BloodImpact", effectdata )
		end
	end
end

--The bark, should be worse than the bite.
function SWEP:SecondaryAttack()
	self:CanSecondaryAttack()

	--the wood of the bark
	if self.Owner:Alive() then
		self:Bark()
		self.Owner:ViewPunch(Angle(rnda, rndb, rnda))
		self.Weapon:SetNextPrimaryFire(CurTime()+self.Secondary.Delay)
		self.Weapon:SetNextSecondaryFire(CurTime()+self.Secondary.Delay)
	end
end

function SWEP:CanSecondaryAttack()
	if (self.Weapon.Secondary.ClipSize <= 0) then
		return true
	end
end

function SWEP:Bark()
	pos = self.Owner:GetShootPos()
	ang = self.Owner:GetAimVector()
	
	self.Weapon:EmitSound(DogBarks[math.random(1,#DogBarks)])
	
	if (SERVER) and IsValid(self.Owner) and IsValid(self.Weapon) then
		local bark = {}
		bark.Num = self.Primary.NumberofShots
		bark.Src = pos
		bark.Dir = ang
		local rnda = self.Primary.Recoil*-1
		local rndb = self.Primary.Recoil*math.random(-1,1)
		self.Weapon:EmitSound(DogBarks[math.random(1,#DogBarks)])
	end
end

--extra necessary unnecessary shit
function SWEP:Reload()
end

function SWEP:Think()
end
--PATH lua/weapons/weapon_grapplehook_mk2.lua:
return gluapack()()
--PATH lua/weapons/weapon_hl2bottle/shared.lua:

AddCSLuaFile()

SWEP.PrintName				= "Bottle"
SWEP.Author				= "Dr. Towers"
SWEP.Instructions			= "Primary attack: Swing - Secondary attack: Throw (One hit and it breaks)"
SWEP.Category				= "HL2 Melee Pack"

SWEP.Slot				= 1
SWEP.SlotPos				= 0

SWEP.Spawnable				= true

SWEP.ViewModel				= Model( "models/weapons/HL2meleepack/v_bottle.mdl" )
SWEP.WorldModel				= Model( "models/weapons/HL2meleepack/w_bottle.mdl" )
SWEP.ViewModelFOV			= 62
SWEP.UseHands				= true

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= -1
SWEP.Primary.Automatic		= true
SWEP.Primary.Ammo		= "none"

SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Automatic	= true
SWEP.Secondary.Ammo		= "none"

SWEP.DrawAmmo			= false

SWEP.HitDistance		= 30
SWEP.HitInclination		= 0.2
SWEP.HitPushback		= 100
SWEP.HitRate			= 0.50
SWEP.MinDamage			= 2
SWEP.MaxDamage			= 8

local SwingSound = Sound( "WeaponFrag.Roll" )
local HitSoundWorld = Sound( "GlassBottle.Break" )
local HitSoundBody = Sound( "GlassBottle.Break" )

function SWEP:Initialize()

	self:SetHoldType( "melee" )
end

function SWEP:PrimaryAttack()

	self.Owner:SetAnimation( PLAYER_ATTACK1 )

	local vm = self.Owner:GetViewModel()
	
	self:EmitSound( SwingSound )
	self.Weapon:SetNextPrimaryFire( CurTime() + self.HitRate )
	self.Weapon:SetNextSecondaryFire( CurTime() + self.HitRate )

	vm:SendViewModelMatchingSequence( vm:LookupSequence( "misscenter1" ) )

	timer.Create("hitdelay", 0.2, 1, function() self:Hitscan() end)

	timer.Start( "hitdelay" )

end

function SWEP:SecondaryAttack()

	self.Weapon:SetNextSecondaryFire( CurTime() + 1 )

	self.Owner:SetAnimation( PLAYER_ATTACK1 )

	self:EmitSound( SwingSound )

	local vm = self.Owner:GetViewModel()
	vm:SendViewModelMatchingSequence( vm:LookupSequence( "misscenter1" ) )

	timer.Create("throwdelay", 0.2, 1, function() self:Throwbottle() end)

	timer.Start( "throwdelay" )
	
end

function SWEP:OnDrop()

	
end

function SWEP:Hitscan()

//This function calculate the trajectory

	for i=0, 170 do

	local tr = util.TraceLine( {
		start = (self.Owner:GetShootPos() - (self.Owner:EyeAngles():Up() * 10)),
		endpos = (self.Owner:GetShootPos() - (self.Owner:EyeAngles():Up() * 10)) + ( self.Owner:EyeAngles():Up() * ( self.HitDistance * 0.7 * math.cos(math.rad(i)) ) ) + ( self.Owner:EyeAngles():Forward() * ( self.HitDistance * 1.5 * math.sin(math.rad(i)) ) ) + ( self.Owner:EyeAngles():Right() * self.HitInclination * self.HitDistance * math.cos(math.rad(i)) ),
		filter = self.Owner,
		mask = MASK_SHOT_HULL
	} )

//This if shot the bullets

	if ( tr.Hit ) then
		
		local strikevector = ( self.Owner:EyeAngles():Up() * ( self.HitDistance * 0.5 * math.cos(math.rad(i)) ) ) + ( self.Owner:EyeAngles():Forward() * ( self.HitDistance * 1.5 * math.sin(math.rad(i)) ) ) + ( self.Owner:EyeAngles():Right() * self.HitInclination * self.HitDistance * math.cos(math.rad(i)) )

		
		bullet = {}
		bullet.Num    = 1
		bullet.Src    = (self.Owner:GetShootPos() - (self.Owner:EyeAngles():Up() * 15))
		bullet.Dir    = strikevector:GetNormalized()
		bullet.Spread = Vector(0, 0, 0)
		bullet.Tracer = 0
		bullet.Force  = 10
		bullet.Hullsize = 0
		bullet.Distance = self.HitDistance * 1.5
		bullet.Damage = math.random( 2, 8 )
		self.Owner:FireBullets(bullet)

		self:EmitSound( SwingSound )

		//vm:SendViewModelMatchingSequence( vm:LookupSequence( "hitcenter1" ) )

		if tr.Entity:IsPlayer() or string.find(tr.Entity:GetClass(),"npc") or string.find(tr.Entity:GetClass(),"prop_ragdoll") then
			self:EmitSound( HitSoundBody )
			tr.Entity:SetVelocity( self.Owner:GetAimVector() * Vector( 1, 1, 0 ) * self.HitPushback )
		else
			self:EmitSound( HitSoundWorld )
		end

		if (SERVER) then self.Owner:Give("weapon_hl2brokenbottle") end
		self.Owner:SelectWeapon("weapon_hl2brokenbottle")
		self.Owner:StripWeapon("weapon_hl2bottle")
//if break
		break

//if end
		//else vm:SendViewModelMatchingSequence( vm:LookupSequence( "misscenter1" ) )
		end
end

end

function SWEP:Throwbottle()

	local ent = ents.Create( "prop_physics" )

	if ( !IsValid( ent ) ) then return end
	
	ent:SetModel( "models/props_junk/garbage_glassbottle003a.mdl" )
	ent:SetPos( self.Owner:EyePos() + ( self.Owner:GetAimVector() * 20 ) )
	ent:SetAngles( self.Owner:EyeAngles() - Angle( 0, 50, 190 ) )
	ent:Spawn()

	local phys = ent:GetPhysicsObject();
 
	//local shot_length = tr.HitPos:Length();
	phys:ApplyForceCenter (self.Owner:GetAimVector()*2000 )
	phys:AddAngleVelocity(Vector( -250, -250, 0 ))

	self.Owner:StripWeapon("weapon_hl2bottle")

end

function SWEP:Deploy()

	local vm = self.Owner:GetViewModel()
	vm:SendViewModelMatchingSequence( vm:LookupSequence( "draw" ) )
	
	self.Weapon:SetNextPrimaryFire( CurTime() + 0.5 )
	self.Weapon:SetNextSecondaryFire( CurTime() + 0.5 )
	
	return true
end

function SWEP:Holster()

	return true
end

function SWEP:OnRemove()

	timer.Remove("hitdelay")
	timer.Remove("throwdelay")
	return true
end
--PATH lua/weapons/weapon_hl2pipe/shared.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/weapons/weapon_lscs/cl_init.lua:
include( "shared.lua" )
include("sh_combo.lua")
include("sh_animations.lua")
include("sh_blockpoints.lua")
include( "sh_stance_override.lua" )
include("cl_worldmodel.lua")
include("cl_effects.lua")

SWEP.Slot = 0
SWEP.SlotPos = 0

language.Add( "lscsGlowstick", "Lightsaber" )

local circles = include("includes/circles/circles.lua")

local X = ScrW() - 110
local Y = ScrH() - 100

-- removed for performance optimization
--local BP_BG = circles.New(CIRCLE_OUTLINED, 126, 0, 0, 12)
--BP_BG:SetColor( Color(0, 0, 0, 200) )
--BP_BG:SetX( X )
--BP_BG:SetY( Y )

local BP = circles.New(CIRCLE_OUTLINED, 125, 0, 0, 10)
BP:SetColor( Color(255, 0, 0, 255) )
BP:SetX( X )
BP:SetY( Y )

-- removed for performance optimization
--local CH_BG = circles.New(CIRCLE_OUTLINED, 106, 0, 0, 12)
--CH_BG:SetColor( Color(0, 0, 0, 200) )
--CH_BG:SetX( X )
--CH_BG:SetY( Y )

local CH = circles.New(CIRCLE_OUTLINED, 105, 0, 0, 10)
CH:SetColor( Color(255, 200, 0, 255) )
CH:SetX( X )
CH:SetY( Y )

local mat_xhair = Material( "sprites/hud/v_crosshair1" )
local mat_glow = Material( "sprites/light_glow02_add" )

local COLOR_WHITE = Color( 255, 255, 255, 255 )
local VECTOR_NULL = Vector(0,0,0)

local segmentLength = 5
local segmentSpace = 10

local OldCombo
local ComboIcon = Material("entities/item_stance_yongli.png")

local advBG = Material( "lscs/ui/hud_adv.png" ) -- added for performance optimization
local bpBG = Material( "lscs/ui/hud_bp.png" ) -- added for performance optimization

function SWEP:DrawHUD()
	local ply = LocalPlayer()

	if ply:InVehicle() and not ply:GetAllowWeaponsInVehicle() then return end

	local combo = self:GetCombo()

	local T = CurTime()
	local notifyTime = self:GetBlockPointNotifyTime()

	local segmentDist = segmentLength + segmentSpace

	local BlockPoints = self:GetBlockPoints()

	local ActiveValueCH = 160 * self:GetComboHits()
	local ActiveValueBP = (160 /  self:GetMaxBlockPoints()) * BlockPoints

	if combo ~= OldCombo then
		OldCombo = combo

		ComboIcon = self:GetCombo().icon
	end

	if not LSCS:HUDShouldHide( LSCS_HUD_STANCE ) then
		if ComboIcon then
			surface.SetMaterial( ComboIcon )
			surface.SetDrawColor( COLOR_WHITE )
			surface.DrawTexturedRectRotated( X - 170, Y + 5, 128,128, 0 )
		end
		draw.SimpleText( combo.name, "LSCS_FONT", X - 170, Y + 80, COLOR_WHITE, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end


	-- added for performance optimization
	surface.SetDrawColor( Color( 0, 0, 0, 200 ) )

	if not LSCS:HUDShouldHide( LSCS_HUD_POINTS_ADVANTAGE ) then
		surface.SetMaterial( advBG )
		surface.DrawTexturedRect( X - 146, Y - 156, 256,256, 0 )
	end

	if combo.AutoBlock and not LSCS:HUDShouldHide( LSCS_HUD_POINTS_BLOCK ) then
		if notifyTime > T and BlockPoints <= 1 then
			local Mul = math.abs( math.cos( T * 7.5 ) )

			surface.SetDrawColor( Color( 255 * Mul, 0, 0, 200 + 55 * Mul ) )
		end

		surface.SetMaterial( bpBG )
		surface.DrawTexturedRect( X - 146, Y - 156, 256,256, 0 )
	end


	draw.NoTexture()

	-- the way im using circles is probably not ideal...  but fuck it, it looks so awesome.  This is probably the thing that will pop up in your profiler
	local Offset = 150
	for A = 0, 170 - segmentDist, segmentDist do
		local Start = Offset + A

		-- removed for performance optimization
		--CH_BG:SetStartAngle( Start - 1 )
		--CH_BG:SetEndAngle( Start  + segmentLength + 1 )
		--CH_BG()

		if A < ActiveValueCH and not LSCS:HUDShouldHide( LSCS_HUD_POINTS_ADVANTAGE ) then
			CH:SetStartAngle( Start  )
			CH:SetEndAngle( Start  + segmentLength )
			CH()
		end

		if not combo.AutoBlock or LSCS:HUDShouldHide( LSCS_HUD_POINTS_BLOCK ) then continue end

		-- removed for performance optimization
		--BP_BG:SetStartAngle( Start - 1 )
		--BP_BG:SetEndAngle( Start  + segmentLength + 1 )
		--BP_BG()

		if A < ActiveValueBP then
			BP:SetStartAngle( Start  )
			BP:SetEndAngle( Start  + segmentLength )
			BP()
		end
	end

	local Pos = ply:GetPos()

	if self:IsComboActive() then return end	

	for _,v in ipairs( player.GetAll() ) do -- oh no he did it again... How else would you do it tho?
		if v == ply or (v:GetPos() - Pos):Length() > 400 then continue end

		local _pos = self:GetPlayerBlockPos( v )

		if _pos and _pos ~= VECTOR_NULL then
			local Pos2D = _pos:ToScreen()
			if not Pos2D.visible then continue end

			local BlockDistance = self:GetBlockDistanceTo( _pos )

			local Col

			if BlockDistance < self:GetBlockDistanceNormal() then
				if BlockDistance < self:GetBlockDistancePerfect() then
					Col = Color( 0, 255, 0, 255 ) -- why
				else
					Col = Color( 255, 255, 0, 255 ) -- am i not
				end
			else
				Col = Color( 255, 0, 0, 255 ) -- caching these?
			end

			surface.SetDrawColor( Col.r, Col.g, Col.b, Col.a )

			if self:GetPlayerCurComboUnblockable( v ) then
				draw.SimpleText( "!", "LSCS_BLOCK_FONT", Pos2D.x, Pos2D.y, Col, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
			else
				surface.SetMaterial( mat_xhair )
				surface.DrawTexturedRectRotated( Pos2D.x, Pos2D.y, 40, 40, 0 )
			end

			surface.SetDrawColor( Col.r * 0.5, Col.g * 0.5, Col.b * 0.5, Col.a )
			local SZ = 1000 * self:GetAttackMultiplier( v )
			surface.SetMaterial( mat_glow )
			surface.DrawTexturedRectRotated( Pos2D.x, Pos2D.y, SZ, SZ, 0 )
		end
	end
end

function SWEP:GetPlayerBlockPos( ply )
	if not IsValid( ply ) or not ply.GetActiveWeapon then return false end

	local wep = ply:GetActiveWeapon()

	if not IsValid( wep ) or not wep.LSCS or not wep.GetBlockPos then return false end

	return wep:GetBlockPos()
end

function SWEP:GetPlayerCurComboUnblockable( ply )
	if not IsValid( ply ) or not ply.GetActiveWeapon then return false end

	local wep = ply:GetActiveWeapon()

	if not IsValid( wep ) or not wep.LSCS or not wep.CurComboUnblockable then return false end

	return wep:CurComboUnblockable()
end

function SWEP:GetAttackMultiplier( ply )
	if not IsValid( ply ) or not ply.GetActiveWeapon then return false end

	local wep = ply:GetActiveWeapon()

	if not IsValid( wep ) or not wep.LSCS or not wep.GetComboHits then return false end

	return wep:GetComboHits()
end

local circle = Material( "vgui/circle" )
local size = 5

function SWEP:DoDrawCrosshair( x, y )
	local ply = LocalPlayer()

	local pos = ply:lscsGetViewOrigin() + ply:EyeAngles():Forward() * 100 -- this method IS needed in case some other third person addon is overwriting the view

	local scr = pos:ToScreen()

	if scr.visible then
		surface.SetMaterial( circle )
		surface.SetDrawColor( 0, 0, 0, 255 )
		surface.DrawTexturedRect( scr.x - size * 0.5 + 1, scr.y - size * 0.5 + 1, size, size )

		surface.SetDrawColor( 255, 255, 255, 255 )
		surface.DrawTexturedRect( scr.x - size * 0.5, scr.y - size * 0.5, size, size )
	end

	return true
end

function SWEP:DrawWeaponSelection( x, y, wide, tall, alpha )
	draw.SimpleText( "n", "WeaponIcons", x + wide/2, y + tall*0.2, Color( 255, 210, 0, 255 ), TEXT_ALIGN_CENTER )
end

function SWEP:CalcView( ply, pos, angles, fov )
	if not IsValid( ply ) or ply:GetViewEntity() ~= ply or not ply:Alive() then return end

	ply._lscsCalcViewTime = CurTime() + 0.1 -- this is used to detect if its broken

	return ply:lscsGetViewOrigin(), ply:EyeAngles(), fov
end

function SWEP:Reload()
end

function SWEP:OnActiveChanged( oldActive, active )
end

function SWEP:OnTick()
end

function SWEP:OnRemove()
	self:ClearWorldModel()
	self:ClearBladeModel()
end

function SWEP:EmitSoundUnpredicted( sound )
	-- dont do anything on client
end

surface.CreateFont( "LSCS_BP_FONT", {
	font = "Verdana",
	extended = false,
	size = 16,
	weight = 2000,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = true,
	additive = false,
	outline = false,
} )

surface.CreateFont( "LSCS_BLOCK_FONT", {
	font = "Verdana",
	extended = false,
	size = 60,
	weight = 2000,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = true,
	additive = false,
	outline = false,
} )
--PATH addons/[miecze] moce i hilty/lua/weapons/weapon_lscs/sh_combo.lua:

if SERVER then
	util.AddNetworkString( "lscs_cancelattack" )

	function SWEP:CancelCombo( delay )
		self:SetNextPrimaryAttack( math.max(self:GetNextPrimaryAttack(),CurTime()) + (delay or 0) )

		self:FinishCombo()
		self:StopAnimation()

		net.Start( "lscs_cancelattack" )
			net.WriteEntity( self )
		net.Broadcast()
	end
else
	function SWEP:CancelCombo()
		self:FinishCombo()
		self:StopAnimation()
	end

	net.Receive( "lscs_cancelattack", function( len )
		local ent = net.ReadEntity()
		if not IsValid( ent ) or not ent.LSCS then return end

		ent:CancelCombo()
	end )
end

function SWEP:CurComboUnblockable()
	return self:GetAnimHasCancelAnim()
end

function SWEP:GetCombo()
	local CurStance = self:GetNWStance()

	if CurStance == -1 then
		return LSCS:GetStance( self:GetLockedCombo() )
	end

	local ply = self:GetOwner()

	if IsValid( ply ) then
		local combo = ply:lscsGetCombo()

		if CurStance > #combo then
			self:SetNWStance( 1 )
		end

		return LSCS:GetStance( combo[ self:GetNWStance() ] )
	else
		return LSCS:GetStance( "default" )
	end
end

function SWEP:GetComboObject( id )
	return self:GetCombo().Attacks[ id ]
end

function SWEP:StartCombo( ComboObj )
	self.AttackActive = true

	local Time = CurTime()
	self.ComboStatus = 1
	self.CurCombo = {
		BeginTime = Time + ComboObj.Delay,
		BeginFunc = ComboObj.BeginAttack,
		SwingTime = ComboObj.Duration,
		FinishFunc = ComboObj.FinishAttack,
		FinishTime = (Time + ComboObj.Duration + ComboObj.Delay),
	}
end

function SWEP:FinishCombo()
	self.AttackActive = nil
	self.CurCombo = nil
	self.ComboStatus = nil
	self:FinishAttack()
end

function SWEP:HandleCombo()
	local Time = CurTime()
	local ply = self:GetOwner()

	if not IsValid( ply ) then
		self:FinishCombo()
		return
	end

	if self.ComboStatus == 1 then
		if self.CurCombo.BeginTime <= Time then
			self:BeginAttack()

			ProtectedCall( function() self.CurCombo.BeginFunc( self, ply ) end )

			self.ComboStatus = 2
		end
	end

	if self.ComboStatus == 2 then
		if (self.CurCombo.BeginTime + self.CurCombo.SwingTime) * 0.7 <= Time then
			self.ComboStatus = 3
		end
	end

	if self.ComboStatus == 3 then
		if self.CurCombo.FinishTime <= Time then

			ProtectedCall( function() self.CurCombo.FinishFunc( self, ply ) end )
			
			self:FinishCombo()
		end
	end
end

function SWEP:ComboThink()
	if self.CurCombo and self.ComboStatus then
		self:HandleCombo()
		
		local ply = self:GetOwner()

		if IsValid( ply ) then
			local ID = ply:LookupAttachment( "anim_attachment_RH" )
			local att = ply:GetAttachment( ID )

			if att then
				self:SetBlockPos( att.Pos )
			end
		end
	else
		self:SetBlockPos( Vector(0,0,0) )
	end

	local ply = self:GetOwner()

	if IsValid( ply ) then
		if ply:lscsKeyDown( IN_ATTACK ) then
			self:DoCombo()
		end
	end
end

function SWEP:DoCombo()
	if not self:CanPrimaryAttack() then return end

	self:FinishCombo()

	local ply = self:GetOwner()

	local W = ply:lscsKeyDown( IN_FORWARD ) and "W" or "_"
	local A = ply:lscsKeyDown( IN_MOVELEFT ) and "A" or "_"
	local S = ply:lscsKeyDown( IN_BACK ) and "S" or "_"
	local D = ply:lscsKeyDown( IN_MOVERIGHT ) and "D" or "_"

	local ATTACK_DIR = W..A..S..D
	local Hack45Deg = false -- hack45Deg  is used so +45+ and -45- is counted as ___ so you can not switch between those to get a quickswing

	if not ply:lscsKeyDown( IN_SPEED ) and not ply:lscsKeyDown( IN_JUMP ) then
		if ATTACK_DIR == "____" or ATTACK_DIR == "W___" then
			if ply:EyeAngles().p > 15 then
				if self:GetComboObject( "+45+" ) then
					ATTACK_DIR = "+45+"
					Hack45Deg = true
				end

			elseif ply:EyeAngles().p < -15 then
				if self:GetComboObject( "-45-" ) then
					ATTACK_DIR = "-45-"
					Hack45Deg = true
				end
			else
				if ATTACK_DIR == "W___" then
					if self:GetComboObject(  "-45-" ) then
						ATTACK_DIR =  "-45-"
						Hack45Deg = true
					end
				end
			end
		end
	end

	if not ply:OnGround() then
		if self.LastAttack == "BACKFLIP" and (self:GetNextPrimaryAttack() + 0.5) > CurTime() then
			ATTACK_DIR = "SLAM"
		else
			if ply:lscsKeyDown( IN_JUMP ) then
				if ATTACK_DIR == "W___" then
					ATTACK_DIR = "FRONT_DASH"
				end

				if ATTACK_DIR == "__S_" then
					ATTACK_DIR = "BACKFLIP"
				end

				if ATTACK_DIR == "_A__" then
					ATTACK_DIR = "ROLL_LEFT"
				end

				if ATTACK_DIR == "___D" then
					ATTACK_DIR = "ROLL_RIGHT"
				end
			end
		end
	end

	self:SetActive( true )

	local ComboObj = self:GetComboObject( ATTACK_DIR )

	if not ComboObj then
		ComboObj = self:GetComboObject( "____" )
		ATTACK_DIR = "____"
	end

	if Hack45Deg then
		ATTACK_DIR = "____"
	end

	if self.LastAttack then
		local A = string.Explode( "", ATTACK_DIR )
		local B = string.Explode( "", self.LastAttack )

		if self.LastAttack == ATTACK_DIR or A[2] == B[2] or A[4] == B[4] or self.LastAttack == "____" then
			if (self:GetNextPrimaryAttack() + 0.5) > CurTime() then
				return
			end
		end
	end

	local T = CurTime()

	local IsBlockable = isstring( LSCS.ComboInterupt[ ATTACK_DIR ] )

	if not IsBlockable and self:GetBlockPoints() <= 1 then
		self:SetBlockPointNotifyTime( T + 2 )

		self:DrainBP( 1 )

		return
	end

	if istable(ComboObj.AttackAnim) then
        	local randomAttack = ComboObj.AttackAnim[math.Round(util.SharedRandom("randomAnimations", 1, #ComboObj.AttackAnim))]
        	self:PlayAnimation( randomAttack, ComboObj.AttackAnimStart )
    	else
        	self:PlayAnimation( ComboObj.AttackAnim, ComboObj.AttackAnimStart )
    	end

	local Time = T + ComboObj.Delay + ComboObj.Duration + 0.1
	self:SetNextPrimaryAttack( Time )
	self:SetGestureTime( Time )

	self.LastAttack = ATTACK_DIR

	if IsBlockable then
		self:SetAnimHasCancelAnim( false )
	else
		self:SetAnimHasCancelAnim( true )
		self:DrainBP( 15 )
	end

	self:StartCombo( ComboObj )
end

function SWEP:IsComboActive()
	return self.ComboStatus ~= nil
end

--PATH addons/[miecze] moce i hilty/lua/weapons/weapon_lscs_electrohammer.lua:
AddCSLuaFile()

SWEP.Base = "weapon_lscs"
DEFINE_BASECLASS( "weapon_lscs" )

SWEP.Category		= "[LSCS]"
SWEP.PrintName	= "Electrohammer"
SWEP.Author		= "BadJay707"
SWEP.Slot		= 0
SWEP.SlotPos 	= 3
SWEP.HoldType = "melee2"
SWEP.Spawnable	= true
SWEP.AdminOnly	= false

function SWEP:SetupDataTables()
	BaseClass.SetupDataTables( self )

	if SERVER then
		self:SetHiltR("elechammer") 
		self:SetBladeR("elecham") 
	end
end
--PATH addons/[miecze] moce i hilty/lua/weapons/weapon_lscs_sycthe.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/weapons/weapon_nanosword.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/entities/weapons/weapon_p2282/shared.lua:
AddCSLuaFile()

if CLIENT then
    SWEP.Author = "DarkRP Developers"
    SWEP.Slot = 1
    SWEP.SlotPos = 1
    SWEP.IconLetter = "y"

    killicon.AddFont("weapon_p2282", "CSKillIcons", SWEP.IconLetter, Color(255, 80, 0, 255))
end

SWEP.Base = "weapon_cs_base2"

SWEP.PrintName = "P228"
SWEP.Spawnable = true
SWEP.AdminOnly = false
SWEP.Category = "DarkRP (Weapon)"

SWEP.HoldType = "pistol"
SWEP.LoweredHoldType = "normal"

SWEP.ViewModel = "models/weapons/cstrike/c_pist_p228.mdl"
SWEP.WorldModel = "models/weapons/w_pist_p228.mdl"

SWEP.Weight = 5
SWEP.AutoSwitchTo = false
SWEP.AutoSwitchFrom = false

SWEP.Primary.Sound = Sound("Weapon_p228.Single")
SWEP.Primary.Recoil = 0.8
SWEP.Primary.Damage = 10
SWEP.Primary.NumShots = 1
SWEP.Primary.Cone = 0.04
SWEP.Primary.ClipSize = 12
SWEP.Primary.Delay = 0.1
SWEP.Primary.DefaultClip = 12
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "pistol"

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"

SWEP.IronSightsPos = Vector(-5.985, -6.7, 2.87)
SWEP.IronSightsAng = Vector(-0.3, -0.03, 0)

--PATH lua/weapons/weapon_shield_activator.lua:

AddCSLuaFile()

SWEP.ViewModel = Model( "models/weapons/c_arms_animations.mdl" )
SWEP.WorldModel = ""

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= -1
SWEP.Primary.Automatic		= false
SWEP.Primary.Ammo			= "none"

SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Automatic	= false
SWEP.Secondary.Ammo			= "none"

SWEP.PrintName	= "Shield Activator"
SWEP.Category	= "Star Wars Utility"

SWEP.Slot		= 4
SWEP.SlotPos	= 1

SWEP.DrawAmmo		= false
SWEP.DrawCrosshair	= false
SWEP.Spawnable		= true
SWEP.AdminOnly		= false

if SERVER then
	SWEP.AutoSwitchTo		= false
	SWEP.AutoSwitchFrom		= false
end

function SWEP:Initialize()
	self:SetHoldType('normal')
	if CLIENT then return end
end



function SWEP:Reload() end

function SWEP:PrimaryAttack()
	if CLIENT then return end
	local ply = self.ShieldOwner
	local shield = ply:GetNWEntity('CShield')
	if IsValid(shield) then
		if !shield:GetActive() and !shield:GetDamaged() then
			shield:ToggleShield(true)
		end
	else
		local shield = ents.Create('shuffle_shield')
		shield:Spawn()
		shield:Initialize(ply)
	end
end

function SWEP:SecondaryAttack()
	if CLIENT then return end
	local ply = self.ShieldOwner
	local shield = ply:GetNWEntity('CShield')
	if IsValid(shield) and shield:GetActive() then
		shield:ToggleShield(false)
	end
end

function SWEP:Deploy() return true end

function SWEP:Equip(ent)
	self.ShieldOwner = ent
end

function SWEP:ShouldDropOnDie() return false end

function SWEP:OnRemove()
	if CLIENT then return end
	local ply = self.ShieldOwner
	local shield = ply:GetNWEntity('CShield')
	if IsValid(shield) then
		shield.SoundLoop:Stop()
		shield:Remove()
	end
end

function SWEP:OnDrop()
	if CLIENT then return end
	local ply = self.ShieldOwner
	local shield = ply:GetNWEntity('CShield')
	if IsValid(shield) then
		shield.SoundLoop:Stop()
		shield:Remove()
		self:Remove()
	end
end


if SERVER then return end

--function SWEP:DrawHUD() end
--function SWEP:PrintWeaponInfo( x, y, alpha ) end

--function SWEP:HUDShouldDraw( name )
	--if ( name == "CHudWeaponSelection" ) then return true end
	--if ( name == "CHudChat" ) then return true end
	--return false
--end
--PATH lua/weapons/weapon_vj_9mmpistol/shared.lua:
if (!file.Exists("autorun/vj_base_autorun.lua","LUA")) then return end
---------------------------------------------------------------------------------------------------------------------------------------------
SWEP.Base 						= "weapon_vj_base"
SWEP.PrintName					= "9mm Pistol"
SWEP.Author 					= "DrVrej"
SWEP.Contact					= "http://steamcommunity.com/groups/vrejgaming"
SWEP.Purpose					= "This weapon is made for Players and NPCs"
SWEP.Instructions				= "Controls are like a regular weapon."
SWEP.Category					= "VJ Base"
	-- Client Settings ---------------------------------------------------------------------------------------------------------------------------------------------
if CLIENT then
SWEP.Slot						= 1 -- Which weapon slot you want your SWEP to be in? (1 2 3 4 5 6) 
SWEP.SlotPos					= 1 -- Which part of that slot do you want the SWEP to be in? (1 2 3 4 5 6)
SWEP.SwayScale 					= 4 -- Default is 1, The scale of the viewmodel sway
SWEP.UseHands					= true
end
	-- NPC Settings ---------------------------------------------------------------------------------------------------------------------------------------------
SWEP.NPC_NextPrimaryFire 		= 0.25 -- Next time it can use primary fire
SWEP.NPC_CustomSpread	 		= 0.8 -- This is added on top of the custom spread that's set inside the SNPC! | Starting from 1: Closer to 0 = better accuracy, Farther than 1 = worse accuracy
	-- Main Settings ---------------------------------------------------------------------------------------------------------------------------------------------
SWEP.ViewModel					= "models/weapons/c_pistol.mdl"
SWEP.WorldModel					= "models/weapons/w_pistol.mdl"
SWEP.HoldType 					= "pistol"
SWEP.Spawnable					= true
SWEP.AdminSpawnable				= false
	-- Primary Fire ---------------------------------------------------------------------------------------------------------------------------------------------
SWEP.Primary.Damage				= 8 -- Damage
SWEP.Primary.ClipSize			= 18 -- Max amount of bullets per clip
SWEP.Primary.Delay				= 0.25 -- Time until it can shoot again
SWEP.Primary.Automatic			= true -- Is it automatic?
SWEP.Primary.Ammo				= "Pistol" -- Ammo type
SWEP.Primary.Sound				= {"Weapon_Pistol.Single"}
SWEP.Primary.DistantSound		= {"Weapon_Pistol.NPC_Single"}
SWEP.Primary.AllowFireInWater	= true -- If true, you will be able to use primary fire in water
SWEP.PrimaryEffects_MuzzleAttachment = 1
SWEP.PrimaryEffects_ShellAttachment = 2
SWEP.PrimaryEffects_ShellType = "VJ_Weapon_PistolShell1"
	-- Reload Settings ---------------------------------------------------------------------------------------------------------------------------------------------
SWEP.HasReloadSound				= true -- Does it have a reload sound? Remember even if this is set to false, the animation sound will still play!
SWEP.ReloadSound				= "weapons/pistol/pistol_reload1.wav"
SWEP.Reload_TimeUntilAmmoIsSet	= 1 -- Time until ammo is set to the weapon
--PATH lua/weapons/weapon_vj_flaregun/shared.lua:
return gluapack()()
--PATH lua/weapons/weapon_vj_flaregun/shared.lua:
if (!file.Exists("autorun/vj_base_autorun.lua","LUA")) then return end
---------------------------------------------------------------------------------------------------------------------------------------------
SWEP.Base 						= "weapon_vj_base"
SWEP.PrintName					= "Flare Gun"
SWEP.Author 					= "DrVrej"
SWEP.Contact					= "http://steamcommunity.com/groups/vrejgaming"
SWEP.Purpose					= "This weapon is made for Players and NPCs"
SWEP.Instructions				= "Controls are like a regular weapon."
SWEP.Category					= "VJ Base"
	-- Client Settings ---------------------------------------------------------------------------------------------------------------------------------------------
if CLIENT then
SWEP.Slot						= 1 -- Which weapon slot you want your SWEP to be in? (1 2 3 4 5 6) 
SWEP.SlotPos					= 1 -- Which part of that slot do you want the SWEP to be in? (1 2 3 4 5 6)
SWEP.SwayScale 					= 4 -- Default is 1, The scale of the viewmodel sway
SWEP.UseHands					= true
end
	-- NPC Settings ---------------------------------------------------------------------------------------------------------------------------------------------
SWEP.NPC_NextPrimaryFire 		= 0.9 -- Next time it can use primary fires
	-- Main Settings ---------------------------------------------------------------------------------------------------------------------------------------------
SWEP.ViewModel					= "models/vj_weapons/v_flaregun.mdl"
SWEP.WorldModel					= "models/vj_weapons/w_flaregun.mdl"
SWEP.HoldType 					= "revolver"
SWEP.Spawnable					= true
SWEP.AdminSpawnable				= false
	-- Primary Fire ---------------------------------------------------------------------------------------------------------------------------------------------
SWEP.Primary.Damage				= 20 -- Damage
SWEP.Primary.Force				= 1 -- Force applied on the object the bullet hits
SWEP.Primary.ClipSize			= 1 -- Max amount of bullets per clip
SWEP.Primary.Recoil				= 2 -- How much recoil does the player get?
SWEP.Primary.Delay				= 0.2 -- Time until it can shoot again
SWEP.Primary.Automatic			= false -- Is it automatic?
SWEP.Primary.Ammo				= "357" -- Ammo type
SWEP.Primary.Sound				= {"vj_weapons/flare/fire.wav"}
SWEP.Primary.DistantSound		= {"vj_weapons/flare/fire_dist.wav"}
//SWEP.Primary.DistantSoundVolume	= 0.25 -- Distant sound volume
SWEP.PrimaryEffects_MuzzleParticles = {"vj_rifle_smoke","vj_rifle_smoke_dark","vj_rifle_smoke_flash","vj_rifle_sparks2"}
SWEP.PrimaryEffects_MuzzleParticlesAsOne = true -- If set to true, the base will spawn all the given particles instead of picking one
SWEP.Primary.DisableBulletCode	= true -- The bullet won't spawn, this can be used when creating a projectile-based weapon
SWEP.PrimaryEffects_MuzzleAttachment = 1
SWEP.PrimaryEffects_SpawnShells = false
---------------------------------------------------------------------------------------------------------------------------------------------
function SWEP:CustomOnPrimaryAttack_BeforeShoot()
	if CLIENT then return end
	local proj = ents.Create("obj_vj_flareround")
	local ply_Ang = self:GetOwner():GetAimVector():Angle()
	local ply_Pos = self:GetOwner():GetShootPos()
	if self:GetOwner():IsPlayer() then proj:SetPos(ply_Pos) else proj:SetPos(self:GetNW2Vector("VJ_CurBulletPos")) end
	if self:GetOwner():IsPlayer() then proj:SetAngles(ply_Ang) else proj:SetAngles(self:GetOwner():GetAngles()) end
	proj:SetOwner(self:GetOwner())
	proj:Activate()
	proj:Spawn()
	
	local phys = proj:GetPhysicsObject()
	if IsValid(phys) then
		if self:GetOwner():IsPlayer() then
			phys:SetVelocity(self:GetOwner():GetAimVector() * 15000)
		else
			phys:SetVelocity(self:GetOwner():CalculateProjectile("Line", self:GetNW2Vector("VJ_CurBulletPos"), self:GetOwner():GetEnemy():GetPos() + self:GetOwner():GetEnemy():OBBCenter(), 15000))
		end
	end
end
--PATH lua/weapons/weapon_vj_rpg/shared.lua:
return gluapack()()
--PATH lua/entities/arc170.lua:
ENT.RenderGroup = RENDERGROUP_OPAQUE
ENT.Type = "vehicle"
ENT.Base = "fighter_base"

ENT.PrintName = "ARC-170"
ENT.Author = "Liam0102"
ENT.Category = "Star Wars Vehicles: Republic"
ENT.AutomaticFrameAdvance = true // For smooth animations
ENT.Spawnable = false; // Spawnable
ENT.AdminSpawnable = false; // Is it only Admin spawnable?

ENT.EntModel = "models/arc170/arc1701.mdl" // The model for the vehicle you're using
ENT.Vehicle = "ARC170" // The name of the vehicle, this is very important.
ENT.StartHealth = 2000; // How much health the vehicle will have
ENT.Allegiance = "Republic";
list.Set("SWVehicles", ENT.PrintName, ENT);

if SERVER then

ENT.FireSound = Sound("weapons/xwing_shoot.wav"); // The sound used for the weapon fire
ENT.NextUse = {Wings = CurTime(),Use = CurTime(),Fire = CurTime(),FireMode = CurTime(),}; // Leave this stuff


AddCSLuaFile();
function ENT:SpawnFunction(pl, tr)
	local e = ents.Create("arc170");
	e:SetPos(tr.HitPos + Vector(0,0,10));
	e:SetAngles(Angle(0,pl:GetAimVector():Angle().Yaw,0));
	e:Spawn();
	e:Activate();
	return e;
end

function ENT:Initialize()
	
	self:SetNWInt("Health",self.StartHealth); //This is here to set the health to the variable made above
	self.CanRoll = true; //Set this to true if the vehicle can roll, false if it can't
	self.WeaponLocations = {
		Right = self:GetPos()+self:GetForward()*250+self:GetUp()*45+self:GetRight()*315,
		Left = self:GetPos()+self:GetForward()*250+self:GetUp()*45+self:GetRight()*-322,
	}

	self.WeaponsTable = {}; //This is what holds the players weapons, you must have this here in ENT:Initialize
	self.BoostSpeed = 2200; //This is the speed when holding SHIFT or the Wings are open
	self.ForwardSpeed = 1250; //This is the standard forward speed
	self.UpSpeed = 500; //This is how fast you can go up or down while holding SPACE or CTRL
	self.AccelSpeed = 8; //This is how fast you reach the speeds. The higher the number the quicker it is.
	
	self.Bullet = CreateBulletStructure(90,"blue");
	self.CanShoot = true;
	self.FireDelay = 0.3 // This is how fast you can fire. The smaller, the faster.
	self.AlternateFire = true;
	self.FireGroup = { "Left" , "Right" };
	self.HasWings = true;
	
	self.ExitModifier = {x = 200, y = 0, z = 130};
	
	self.BaseClass.Initialize(self)
end


end

if CLIENT then

	local matPlasma	= Material( "effects/strider_muzzle" )
	function ENT:Draw() 
		self:DrawModel()
		local Flying = self:GetNWBool("Flying".. self.Vehicle);
		local TakeOff = self:GetNWBool("TakeOff");
		local Land = self:GetNWBool("Land");
		local vel = self:GetVelocity():Length();
		if(vel > 150) then
			if(Flying and !TakeOff and !Land) then
				for i=1,2 do
					local vOffset = self.EnginePos[i] 
					local scroll = CurTime() * -20
						
					render.SetMaterial( matPlasma )
					scroll = scroll * 0.9
					
					render.StartBeam( 3 )
						render.AddBeam( vOffset, 40, scroll, Color( 0, 255, 255, 255) )
						render.AddBeam( vOffset + self:GetForward()*-5, 36, scroll + 0.01, Color( 255, 255, 255, 255) )
						render.AddBeam( vOffset + self:GetForward()*-40, 32, scroll + 0.02, Color( 0, 255, 255, 0) )
					render.EndBeam()
					
					scroll = scroll * 0.9
					
					render.StartBeam( 3 )
						render.AddBeam( vOffset, 40, scroll, Color( 0, 255, 255, 255) )
						render.AddBeam( vOffset + self:GetForward()*-5, 36, scroll + 0.01, Color( 255, 255, 255, 255) )
						render.AddBeam( vOffset + self:GetForward()*-40, 32, scroll + 0.02, Color( 0, 255, 255, 0) )
					render.EndBeam()
					
					scroll = scroll * 0.9
					
					render.StartBeam( 3 )
						render.AddBeam( vOffset, 40, scroll, Color( 0, 255, 255, 255) )
						render.AddBeam( vOffset + self:GetForward()*-5, 36, scroll + 0.01, Color( 255, 255, 255, 255) )
						render.AddBeam( vOffset + self:GetForward()*-40, 32, scroll + 0.02, Color( 0, 255, 255, 0) )
					render.EndBeam()
				end
			end
		end
	end
	
	ENT.EnginePos = {} // Positions of the engines for the effects
	ENT.Sounds={
		Engine=Sound("vehicles/xwing/xwing_fly2.wav"), //The flying sounds
	}

	// The flight effects, for the most part you can leave this alone
	function ENT:FlightEffects()
		local normal = (self:GetForward() * -1):GetNormalized()
		local roll = math.Rand(-90,90)
		local p = LocalPlayer()		
		local FWD = self:GetForward();
		local id = self:EntIndex();

		for k,v in pairs(self.EnginePos) do
			local blue = self.FXEmitter:Add("sprites/bluecore",v)
			blue:SetVelocity(normal)
			blue:SetDieTime(0.025)
			blue:SetStartAlpha(255)
			blue:SetEndAlpha(255)
			blue:SetStartSize(15)
			blue:SetEndSize(13)
			blue:SetRoll(roll)
			blue:SetColor(255,255,255)
			
			local dynlight = DynamicLight(id + 4096*k);
			dynlight.Pos = v;
			dynlight.Brightness = 5;
			dynlight.Size = 100;
			dynlight.Decay = 1024;
			dynlight.R = 100;
			dynlight.G = 100;
			dynlight.B = 255;
			dynlight.DieTime = CurTime()+1;

		end
	
	end
	
	local Health = 0;
	function ENT:Think()
		self.BaseClass.Think(self);
		
		local p = LocalPlayer(); //The player
		local Flying = self:GetNWBool("Flying".. self.Vehicle); //Is the vehicle currently inflight?
		local TakeOff = self:GetNWBool("TakeOff");
		local Land = self:GetNWBool("Land");
		local IsFlying = p:GetNWBool("Flying"..self.Vehicle);
		if(Flying) then
			
			// We need to constantly update the engine positions for the effects
			self.EnginePos = {
				self:GetPos()+self:GetForward()*-220+self:GetUp()*95+self:GetRight()*65, 
				self:GetPos()+self:GetForward()*-220+self:GetUp()*95+self:GetRight()*-72,
			}

			if(!TakeOff and !Land) then
				self:FlightEffects(); // Draw the effects
			end
			Health = self:GetNWInt("Health"); // Get the health for the HUD
		end

	end
	
    ENT.ViewDistance = 700;
    ENT.ViewHeight = 200;
    ENT.FPVPos = Vector(80,3,130);
	
	local HUD = surface.GetTextureID("vgui/arc_cockpit");
	ENT.CanFPV = true;
	function ARC170Reticle() // Rename to Vehicle Name Reticle
		
		local p = LocalPlayer();
		local Flying = p:GetNWBool("FlyingARC170"); // Change ARC-170 to your vehicle name
		local self = p:GetNWEntity("ARC170"); // Change ARC-170 to your vehicle name
		

		if(Flying and IsValid(self)) then
			//These should be the same positions for the weapons as above in initialize
			local FPV = self:GetFPV();
			if(FPV) then
				SW_HUD_FPV(HUD);
				SW_HUD_WingsIndicator("ARC",x,y);
			end
			
			SW_HUD_DrawHull(2000);
			SW_WeaponReticles(self);
			SW_HUD_DrawOverheating(self);
			
			local x = ScrW()/10*8.25;
			local y = ScrH()/4*2;
			SW_HUD_Compass(self,x,y);
			SW_HUD_DrawSpeedometer();
			
		end
	end
	hook.Add("HUDPaint", "ARC170Reticle", ARC170Reticle)

end
--PATH lua/entities/arccw_ammo_357.lua:
return gluapack()()
--PATH lua/entities/arccw_ammo_357.lua:
AddCSLuaFile()

ENT.Base                      = "arccw_ammo"
ENT.RenderGroup               = RENDERGROUP_TRANSLUCENT

ENT.PrintName                 = "Magnum Ammo"
ENT.Category                  = "ArcCW - Ammo"

ENT.Spawnable                 = true
ENT.Model                     = "models/items/arccw/magnum_ammo.mdl"

ENT.AmmoType = "357"
ENT.AmmoCount = 12
if engine.ActiveGamemode() == "terrortown" then
    ENT.AmmoType = "AlyxGun"
    ENT.AmmoCount = 18
end


ENT.DetonationDamage = 50
ENT.DetonationRadius = 128
ENT.DetonationSound = "weapons/357_fire2.wav"
--PATH lua/entities/arccw_ammo_pistol.lua:
return gluapack()()
--PATH lua/entities/arccw_gl_ammodet.lua:
return gluapack()()
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/entities/arccw_ubgl_flash.lua:
AddCSLuaFile()

ENT.Base = "arccw_ubgl_he"
ENT.PrintName = "40mm Flash Grenade"

ENT.GrenadeDamage = 50
ENT.GrenadeRadius = 150
ENT.ExplosionEffect = false
ENT.Scorch = false

function ENT:DoDetonation()

    local effectdata = EffectData()
    effectdata:SetOrigin(self:GetPos())

    if self:WaterLevel() >= 1 then
        util.Effect("WaterSurfaceExplosion", effectdata)
        self:EmitSound("weapons/underwater_explode3.wav", 125, 100, 1, CHAN_AUTO)
    else
        effectdata:SetMagnitude(4)
        effectdata:SetScale(1)
        effectdata:SetRadius(4)
        effectdata:SetNormal(self:GetVelocity():GetNormalized())
        util.Effect("Sparks", effectdata)
        self:EmitSound("physics/metal/metal_box_break1.wav", 100, 200, 0.5)
    end

    -- TODO: these sounds need to be replaced (dependency)!
    self:EmitSound("weapons/arccw/flashbang/flashbang_explode1.wav", 100, 100, 1, CHAN_AUTO)
    self:EmitSound("weapons/arccw/flashbang/flashbang_explode1_distant.wav", 140, 100, 1, CHAN_AUTO)

    util.Effect( "arccw_flashexplosion", effectdata)

    local flashorigin = self:GetPos()

    local flashpower = 512
    local targets = ents.FindInSphere(flashorigin, flashpower)

    for _, k in pairs(targets) do
        if k:IsPlayer() then
            local dist = k:EyePos():Distance(flashorigin)
            local dp = (k:EyePos() - flashorigin):Dot(k:EyeAngles():Forward())

            local time = Lerp( dp, 2.5, 0.25 )

            time = Lerp( dist / flashpower, time, 0 )

            if k:VisibleVec( flashorigin ) then
                k:ScreenFade( SCREENFADE.IN, Color( 255, 255, 255, 255 ), 2.5, time )
            end

            k:SetDSP(37, false)

        elseif k:IsNPC() then

            k:SetNPCState(NPC_STATE_PLAYDEAD)

            if timer.Exists( k:EntIndex() .. "_arccw_flashtimer" ) then
                timer.Remove( k:EntIndex() .. "_arccw_flashtimer" )
            end

            timer.Create( k:EntIndex() .. "_arccw_flashtimer", 10, 1, function()
                if !k:IsValid() then return end
                k:SetNPCState(NPC_STATE_ALERT)
            end)

        end
    end

end
--PATH lua/entities/aura_lvs_cargo3/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "NEU (team 0) | Cargo 3"
ENT.Category = "Aura's LVS Big Ships"

DEFINE_BASECLASS( "aura_lvs_capital_ship_base_mk2" )

ENT.Spawnable = true
ENT.AdminSpawnable = true
ENT.Editable = true

ENT.Model 					= "models/props/gemini/gemini.mdl"
ENT.AITEAM 					= 0

ENT.Mass 					= 700

ENT.HealthVal 				= 50000
ENT.MaxHealth  				= ENT.HealthVal
ENT.SPAWNNUMBER				= 1
ENT.SPAWNDELAY				= 3

ENT.SHIPSPAWNPOS 			= {forward = 0, right = 0, up = -1000}
ENT.ENABLETURRETS 			= false
ENT.SHOOTEFFECT 			= "lvs_capital_red_laser"
ENT.SHOOTSOUND				= Sound("weapons/9799_fire.mp3")

ENT.PRIMARYDAMAGE			= 60
ENT.SHOOTDELAY1 			= 0.6
ENT.SEARCHSIZE				= 30000
ENT.LOSE_DIST 				= 31000
ENT.TURRETFORWARDSEARCH 	= 30600

ENT.EXPLOSION_SCALE_MIN		= 4
ENT.EXPLOSION_SCALE_MAX		= 8

ENT.TURRETS = 
{

}

ENT.TURRETANGLES = 
{

}

ENT.BOMBS = 
{
	{forward = 0, right = 0, up = 0},
	{forward = 700, right = 0, up = 0},
	{forward = 0, right = 0, up = 0},
	{forward = -300, right = 0, up = 0},
}
--PATH lua/entities/aura_lvs_cargo5/shared.lua:
return gluapack()()
--PATH lua/entities/aura_lvs_cargo5/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "NEU (team 0) | Cargo 5"
ENT.Category = "Aura's LVS Big Ships"

DEFINE_BASECLASS( "aura_lvs_capital_ship_base_mk2" )

ENT.Spawnable = true
ENT.AdminSpawnable = true
ENT.Editable = true

ENT.Model 					= "models/star_wars/the_clone_wars/vehicles/cis_tank_gtrans.mdl"
ENT.AITEAM 					= 0

ENT.Mass 					= 700

ENT.HealthVal 				= 100000
ENT.MaxHealth  				= ENT.HealthVal
ENT.SPAWNNUMBER				= 1
ENT.SPAWNDELAY				= 3

ENT.SHIPSPAWNPOS 			= {forward = 0, right = 0, up = -1000}
ENT.ENABLETURRETS 			= false
ENT.SHOOTEFFECT 			= "lvs_capital_red_laser"
ENT.SHOOTSOUND				= Sound("weapons/9799_fire.mp3")

ENT.PRIMARYDAMAGE			= 80
ENT.SHOOTDELAY1 			= 2
ENT.SEARCHSIZE				= 40000
ENT.LOSE_DIST 				= 31000
ENT.TURRETFORWARDSEARCH 	= 30600

ENT.EXPLOSION_SCALE_MIN		= 4
ENT.EXPLOSION_SCALE_MAX		= 8

ENT.TURRETS = 
{
	[1] = Vector(0,0,820),
}

ENT.TURRETANGLES = 
{
	[1] = Angle(0,180,0),
}

ENT.BOMBS = 
{
	{forward = 0, right = 0, up = 0},
	{forward = 700, right = 0, up = 0},
	{forward = 0, right = 0, up = 0},
	{forward = -800, right = 0, up = 400},
}
--PATH lua/entities/aura_lvs_cargo8/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "NEU (team 0) | Cargo 8"
ENT.Category = "Aura's LVS Big Ships"

DEFINE_BASECLASS( "aura_lvs_capital_ship_base_mk2" )

ENT.Spawnable = true
ENT.AdminSpawnable = true
ENT.Editable = true

ENT.Model 					= "models/props/agro/agro.mdl"
ENT.AITEAM 					= 0

ENT.Mass 					= 700

ENT.HealthVal 				= 125000
ENT.MaxHealth  				= ENT.HealthVal
ENT.SPAWNNUMBER				= 1
ENT.SPAWNDELAY				= 3

ENT.SHIPSPAWNPOS 			= {forward = 0, right = 0, up = -1000}
ENT.ENABLETURRETS 			= false
ENT.SHOOTEFFECT 			= "lvs_capital_red_laser"
ENT.SHOOTSOUND				= Sound("weapons/9799_fire.mp3")

ENT.PRIMARYDAMAGE			= 60
ENT.SHOOTDELAY1 			= 0.6
ENT.SEARCHSIZE				= 30000
ENT.LOSE_DIST 				= 31000
ENT.TURRETFORWARDSEARCH 	= 30600

ENT.EXPLOSION_SCALE_MIN		= 4
ENT.EXPLOSION_SCALE_MAX		= 8

ENT.TURRETS = 
{

}

ENT.TURRETANGLES = 
{

}

ENT.BOMBS = 
{
	{forward = -5000, right = 0, up = 1800},
	{forward = -5000, right = -1000, up = 1800},
	{forward = -5000, right = 1000, up = 1800},
	{forward = -4000, right = -1000, up = 1800},
	{forward = -4000, right = 1000, up = 800},
	{forward = -2000, right = -1000, up = 1600},
	{forward = -2000, right = 1000, up = 600},
	{forward = 0, right = -1000, up = 1800},
	{forward = 0, right = 1000, up = 1800},
	{forward = 2000, right = -1000, up = 1600},
	{forward = 2000, right = 1000, up = 600},
	{forward = 4000, right = -1000, up = 1400},
	{forward = 4000, right = 1000, up = 400},
	{forward = 5000, right = -1000, up = 1800},
	{forward = 5000, right = 1000, up = 800},
	{forward = -4000, right = 1000, up = 1800},
	{forward = -5000, right = 1000, up = 1800},
}
--PATH lua/entities/aura_lvs_cr90_neu/cl_init.lua:
return gluapack()()
--PATH lua/entities/aura_lvs_cr90_neu/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "NEU | CR90"
ENT.Category = "Aura's LVS Big Ships"

DEFINE_BASECLASS( "aura_lvs_capital_ship_base_mk2" )

ENT.Spawnable = true
ENT.AdminSpawnable = true
ENT.Editable = true

ENT.Model 					= "models/squadrons/cr90.mdl"
ENT.AITEAM 					= 0

ENT.Mass 					= 700

ENT.HealthVal 				= 60000
ENT.MaxHealth  				= ENT.HealthVal
ENT.SPAWNNUMBER				= 1
ENT.SPAWNDELAY				= 3

ENT.SHIPSPAWNPOS 			= {forward = 0, right = 0, up = -1000}
ENT.ENABLETURRETS 			= false
ENT.SHOOTEFFECT 			= "lvs_capital_red_laser"
ENT.SHOOTSOUND				= Sound("weapons/corvette_fire.mp3")

ENT.PRIMARYDAMAGE			= 60
ENT.SHOOTDELAY1 			= 3
ENT.SEARCHSIZE				= 30000
ENT.LOSE_DIST 				= 31000
ENT.TURRETFORWARDSEARCH 	= 30600

ENT.EXPLOSION_SCALE_MIN		= 4
ENT.EXPLOSION_SCALE_MAX		= 8

ENT.TURRETS = 
{
	[1] = Vector(-610,0,185),
	[2] = Vector(-610,0,-169),
}

ENT.TURRETANGLES = 
{
	[1] = Angle(0,0,0),
	[2] = Angle(0,0,-180),
}

ENT.BOMBS = 
{
	{forward = 0, right = 0, up = 0},
	{forward = 700, right = 0, up = 0},
	{forward = 0, right = 0, up = 0},
	{forward = -300, right = 0, up = 0},
}
--PATH lua/entities/aura_lvs_dh_omni/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "CSI | DH-OMNI"
ENT.Category = "Aura's LVS Big Ships"

DEFINE_BASECLASS( "aura_lvs_capital_ship_base_mk2" )

ENT.Spawnable = true
ENT.AdminSpawnable = true
ENT.Editable = true

ENT.Model 					= "models/salty/cis-supplyship.mdl"
ENT.AITEAM 					= 1

ENT.Mass 					= 700

ENT.HealthVal 				= 1000000
ENT.MaxHealth  				= ENT.HealthVal
ENT.SPAWNNUMBER				= 1
ENT.SPAWNDELAY				= 3
ENT.SHIPSPAWNPOS 			= {forward = 2000, right = 0, up = 2800}
ENT.ENABLETURRETS 			= false
ENT.SHOOTEFFECT 			= "lvs_capital_red_laser"
ENT.SHOOTSOUND				= Sound("weapons/9799_fire.mp3")

ENT.PRIMARYDAMAGE			= 30
ENT.SHOOTDELAY1 			= 1
ENT.SEARCHSIZE				= 30000
ENT.LOSE_DIST 				= 31000
ENT.TURRETFORWARDSEARCH 	= 600

ENT.EXPLOSION_SCALE_MIN		= 4
ENT.EXPLOSION_SCALE_MAX		= 7


ENT.TURRETS = 
{
	[1] = Vector(2450,-1350,2200),
	[2] = Vector(2450,1350,2200),
	[3] = Vector(-650,0,3200),
}

ENT.TURRETANGLES = 
{
	[1] = Angle(360,180,90),
	[2] = Angle(360,180,-90),
	[3] = Angle(90,180,0),
}

ENT.BOMBS = 
{
	{forward = 0, right = 0, up = 2800},
	{forward = 1000, right = -3000, up = 2600},
	{forward = 2000, right = 0, up = 2400},
	{forward = 0, right = 0, up = 2800},
	{forward = 1000, right = -3000, up = 2600},
	{forward = 2000, right = 0, up = 2400},
	{forward = 3000, right = 2000, up = 2800},
	{forward = -1000, right = 0, up = 2600},
	{forward = 0, right = 0, up = 2800},
	{forward = 1000, right = 0, up = 2600},
	{forward = 2000, right = 0, up = 2400},
	{forward = 3000, right = -2000, up = 2800},
	{forward = -2500, right = 3000, up = 2800},
}
--PATH lua/entities/aura_lvs_display_panel/cl_init.lua:
return gluapack()()
--PATH lua/entities/aura_lvs_satellite_rep_2/cl_init.lua:
return gluapack()()
--PATH lua/entities/aura_lvs_venator_mk2/shared.lua:
return gluapack()()
--PATH lua/entities/base_streamradio_gui.lua:
AddCSLuaFile()
DEFINE_BASECLASS("base_streamradio")

local StreamRadioLib = StreamRadioLib

local LIBModel = StreamRadioLib.Model
local LIBSkin = StreamRadioLib.Skin
local LIBWire = StreamRadioLib.Wire
local LIBUtil = StreamRadioLib.Util

ENT.RenderGroup = RENDERGROUP_BOTH
ENT.Spawnable = false
ENT.AdminOnly = false

local ang_zero = Angle( )
local vec_zero = Vector( )

local g_isLoaded = StreamRadioLib and StreamRadioLib.Loaded
local g_isWiremodLoaded = g_isLoaded and LIBWire.HasWiremod()

local g_displayBuildTimer = 0

function ENT:SetScale(scale)
	self.Scale = scale or 0
end

function ENT:IsSeen()
	return SERVER or self.isseen
end

function ENT:GetScale()
	return self.Scale or 0
end

function ENT:SetDisplayPosAngOffset(pos, ang)
	self.DisplayPosOffset = pos
	self.DisplayPosAngles = ang
end

function ENT:GetDisplayPosAngOffset()
	return self.DisplayPosOffset, self.DisplayPosAngles
end

function ENT:CalcDisplayPosAngWorld()
	if self.DisplayLess then return end

	local pos = self:GetPos()
	local ang = self:GetAngles()

	local dpos, dang = LocalToWorld(self.DisplayPosOffset or vec_zero, self.DisplayPosAngles or ang_zero, pos, ang)

	self.DisplayPos = dpos
	self.DisplayAng = dang

	return dpos, dang
end

function ENT:CanControlInternal(ply, userEntity)
	if self.DisplayLess then return false end
	if self:GetDisableInput() then return false end

	local GUI = self.GUI

	if not IsValid(GUI) then
		return false
	end

	if not GUI:IsReady() then
		return false
	end

	-- Check the player for +use permission
	if not StreamRadioLib.CheckPropProtectionAgainstUse(self, ply) then
		return false
	end

	if userEntity:IsPlayer() then
		if not userEntity:Alive() then
			return false
		end

		if StreamRadioLib.IsGUIHidden(userEntity) then
			return false
		end

		if not self:OnGUIShowCheck(userEntity) then
			return false
		end
	end

	local scale = self:GetScale()
	if scale <= 0 then return false end

	local pos = self.DisplayPos
	if not pos then return false end

	local ang = self.DisplayAng
	if not ang then return false end

	local controlpos = StreamRadioLib.GetControlPosDir(userEntity)
	if not controlpos then return false end

	-- Return false if from the backside
	local a = controlpos - pos
	local b = ang:Up():Dot( a ) / a:Length()

	local displayVisAng = math.acos( b ) / math.pi * 180
	return displayVisAng < 90
end

function ENT:CanControl(ply, userEntity)
	if not g_isLoaded then return false end

	if not IsValid(ply) then return false end
	if not ply:IsPlayer() then return false end

	if not IsValid(userEntity) then
		userEntity = ply
	end

	local cacheId = tostring(ply) .. "_" .. tostring(userEntity)
	local now = RealTime()

	-- cache the check result for a short time to avoid running expensive functions every tick
	if self._canControlCacheExpire and self._canControlCacheExpire <= now then
		self._canControlCache = nil
		self._canControlCacheExpire = nil
	end

	if self._canControlCache and self._canControlCache[cacheId] ~= nil then
		return self._canControlCache[cacheId]
	end

	if not self._canControlCache then
		self._canControlCache = {}
		self._canControlCacheExpire = now + 0.25
	end

	local result = self:CanControlInternal(ply, userEntity)

	self._canControlCache[cacheId] = result
	return result
end

function ENT:CursorInGUI(cx, cy)
	if not IsValid(self.GUI) then return false end

	local px, py = self.GUI:GetAbsolutePos()
	return self.GUI:IsInBounds(cx - px, cy - py)
end

function ENT:GetCursor( ply, trace, userEntity )
	if not g_isLoaded then return false end

	if not IsValid(ply) then return false end
	if not ply:IsPlayer() then return false end

	if not IsValid(userEntity) then
		userEntity = ply
	end

	if not self:CanControl(ply, userEntity) then
		return false
	end

	if not trace then
		trace = StreamRadioLib.Trace(userEntity)
		if not trace or not trace.Hit then
			return false
		end
	end

	if not self:OnGUIInteractionCheck(ply, trace, userEntity) then
		return false
	end

	-- Ignore distances when we are using via an entity that is not a player
	if userEntity:IsPlayer() and not self:CheckDistanceToEntity(userEntity, self.MaxCursorTraceDist, trace.HitPos) then
		return false
	end

	local Cursor = trace.Entity == self

	if not Cursor then
		return false
	end

	local scale = self:GetScale()
	if scale <= 0 then return false end

	local pos = self.DisplayPos
	if not pos then return false end

	local ang = self.DisplayAng
	if not ang then return false end

	local TraceHitPos = util.IntersectRayWithPlane( trace.StartPos, trace.Normal, pos, ang:Up( ) )

	if not TraceHitPos then
		return false
	end

	local HitPos = WorldToLocal( TraceHitPos, ang_zero, pos, ang )
	local CursorX = math.Round( HitPos.x / scale )
	local CursorY = math.Round( -HitPos.y / scale )

	Cursor = self:CursorInGUI(CursorX, CursorY)

	if not Cursor then
		return false
	end

	return Cursor, CursorX, CursorY
end

function ENT:HasModelFunction(index)
	if not index then return false end

	local modalData = self.ModelData
	if not modalData then return false end

	local func = modalData[index]
	if not isfunction(func) then return false end

	return true
end

function ENT:GetModelFunction(index)
	if not index then return end

	local modalData = self.ModelData
	if not modalData then return end

	local func = modalData[index]
	if not isfunction(func) then return end

	return func
end

function ENT:CallModelFunction(index, ...)
	if not index then return end

	local modalData = self.ModelData
	if not modalData then return end

	local func = modalData[index]
	if not isfunction(func) then return end

	return func(modalData, self, ...)
end

function ENT:SetUpModel()
	if not g_isLoaded then return end
	if not IsValid(self.StreamObj) then return end
	if self._badModel then return end

	local model = self:GetModel()
	if not StreamRadioLib.Util.IsValidModel(model) then
		self._badModel = true
		return
	end

	self.ModelData = LIBModel.GetModelSettings(model) or {}
	local MD = self.ModelData

	self:CallModelFunction("Initialize", model)

	self:SetDisplayPosAngOffset(MD.DisplayOffset, MD.DisplayAngles)
	self:SetScale(MD.DisplayScale or 1)

	self.NoDisplay = MD.NoDisplay or false
	self.MaxCursorTraceDist = MD.MaxCursorTraceDist or 100

	if MD.Sounds then
		self.Sounds_Tune = MD.Sounds.Tune or self.Sounds_Tune
		self.Sounds_Noise = MD.Sounds.Noise or self.Sounds_Noise
		self.Sounds_Use = MD.Sounds.Use or self.Sounds_Use
	end

	self:SetSoundPosAngOffset(MD.SoundPosOffset, MD.SoundAngOffset)

	if self.OnModelSetup then
		self:OnModelSetup()
	end
end

function ENT:RemoveGui()
	local tmpGui = self.GUI
	local tmpGuiMain = self.GUI_Main

	local hasGui = IsValid(tmpGui)
	local hasGuiMain = IsValid(tmpGuiMain)

	if (hasGui or hasGuiMain) and self.OnGUIRemove then
		self:OnGUIRemove(tmpGui, tmpGuiMain)
	end

	self.GUI = nil
	self.GUI_Main = nil

	if hasGui then
		tmpGui.OnLoadDone = nil
		tmpGui.OnReady = nil
		tmpGui:Remove()
		tmpGui = nil
	end

	if hasGuiMain then
		tmpGuiMain:Remove()
		tmpGuiMain = nil
	end
end

function ENT:SetupGui(callback)
	if not IsValid(self.GUI) then
		self.GUI = StreamRadioLib.CreateOBJ("gui_controller")
	end

	local GUI = self.GUI

	GUI:SetName("gui")
	GUI:SetNWName("g")
	GUI:SetEntity(self)
	GUI:ActivateNetworkedMode()

	if SERVER and LIBUtil.IsDebug() then
		self:SetEnableDebug(true)
	end

	GUI:SetDebug(self:GetEnableDebug())

	if not IsValid(self.GUI_Main) then
		self.GUI_Main = GUI:AddPanelByClassname("radio/gui_main")
	end

	local GUI_Main = self.GUI_Main

	GUI_Main:SetPos(0, 0)
	GUI_Main:SetName("main")
	GUI_Main:SetNWName("m")
	GUI_Main:SetSkinIdentifyer("main")
	GUI_Main:SetStream(self.StreamObj)
	GUI_Main:SetHasPlaylist(self:GetHasPlaylist())

	GUI_Main.OnToolButtonClick = function(this)
		if not IsValid(self) then return end
		self:OnToolButtonClick()
	end

	GUI_Main.OnWireButtonClick = function(this)
		if not IsValid(self) then return end
		self:OnWireButtonClick()
	end

	GUI_Main.OnPlayerClosed = function(this)
		if not IsValid(self) then return end
		self:OnPlayerClosed()
	end

	GUI_Main.OnPlayerShown = function(this)
		if not IsValid(self) then return end
		self:OnPlayerShown()
	end

	GUI_Main.OnPlaylistClose = function(this)
		if not IsValid(self) then return end
		self:ClearPlaylist()
	end

	if SERVER then
		GUI_Main.OnPlaylistBack = function(this)
			if not IsValid(self) then return end
			self:PlayPreviousPlaylistItem()
		end

		GUI_Main.OnPlaylistForward = function(this)
			if not IsValid(self) then return end
			self:PlayNextPlaylistItem()
		end

		GUI_Main.OnPlaylistStartBuild = function(this)
			if not IsValid(self) then return end

			if self._dupePlaylistData then
				self:ReapplyPlaylistFromDupe()
				return
			end

			self:ClearPlaylist()
		end

		GUI_Main.OnPlaylistEndBuild = function(this, playlistItems)
			if not IsValid(self) then return end

			if self._dupePlaylistData then
				self:ReapplyPlaylistFromDupe()
				return
			end

			if not playlistItems then
				self:ClearPlaylist()
				return
			end

			self:SetPlaylist(playlistItems, 1)
		end

		GUI_Main.OnStop = function(this)
			if not IsValid(self) then return end

			self:StopStreamInternal()
		end

		GUI_Main.OnPlayItem = function(this, item)
			if not IsValid(self) then return end

			self:PlayFromPlaylistItem(item)
		end
	end

	local model = self:GetModel()
	self:CallModelFunction("InitializeFonts", model)
	self:CallModelFunction("SetupGUI", GUI, GUI_Main)

	GUI:SetSkin(LIBSkin.GetDefaultSkin())
	GUI:PerformRerender(true)

	GUI.OnReady = function()
		GUI.OnReady = nil

		local THIS_GUI = self.GUI
		local THIS_GUI_Main = self.GUI_Main

		if not IsValid(self) then
			return
		end

		if not IsValid(THIS_GUI) then
			return
		end

		if not IsValid(THIS_GUI_Main) then
			return
		end

		self:AddObjToNwRegister(THIS_GUI)
		self:CallModelFunction("OnGUIReady", GUI, GUI_Main)

		if self.OnGUIReady then
			self:OnGUIReady(THIS_GUI, THIS_GUI_Main)
		end
	end

	if self.OnGUISetup then
		self:OnGUISetup(GUI, GUI_Main)
	end
end

function ENT:StreamOnConnect(stream, channel, metadata)
	BaseClass.StreamOnConnect(self, stream, channel, metadata)
	self:CallModelFunction("OnPlay", stream)
	return true
end

function ENT:StreamOnSearch(stream)
	BaseClass.StreamOnSearch(self, stream)
	self:CallModelFunction("OnSearch", stream)
	return true
end

function ENT:StreamOnError(stream, err)
	BaseClass.StreamOnError(self, stream, err)
	self:CallModelFunction("OnError", stream, err)
end

function ENT:StreamOnClose(stream)
	BaseClass.StreamOnClose(self, stream)
	self:CallModelFunction("OnStop", stream)
end

function ENT:StreamOnTrackEnd(stream)
	self:CallModelFunction("OnTrackEnd", stream)
end

function ENT:HasGUI()
	if not IsValid(self.GUI) then
		return false
	end

	return true
end

function ENT:GetGUI()
	return self.GUI
end

function ENT:GetGUIMain()
	return self.GUI_Main
end

function ENT:PollGuiSetup()
	if self.DisplayLess then
		return
	end

	if self.GUI then
		return
	end

	-- delay the GUI rebuild in case many newly spawned radios are seen at once
	if SysTime() > g_displayBuildTimer then
		self:SetupGui()

		g_displayBuildTimer = SysTime() + 0.2
	end
end

function ENT:InternalThink()
	BaseClass.InternalThink(self)

	self.isseen = false
	self.DisplayLess = self.NoDisplay or self:GetDisableDisplay()

	if SERVER then
		self:PollGuiSetup()
	end
end

function ENT:InternalSlowThink()
	BaseClass.InternalSlowThink(self)

	self:PlaylistThink()
end

function ENT:NonDormantThink()
	BaseClass.NonDormantThink(self)

	if self:IsSeen() then
		self:ControlThink(self:GetLastUser(), self:GetLastUsingEntity())
	end
end

function ENT:ControlThink(ply, userEntity)
	local GUI = self.GUI

	if not IsValid(GUI) then
		return
	end

	local pos, ang = self:CalcDisplayPosAngWorld()

	if CLIENT and self:ShowDebug() then
		debugoverlay.Axis(pos, ang, 5, 0.05, color_white)
		debugoverlay.EntityTextAtPosition(pos, 1, "Display pos", 0.05, color_white)
	end

	if not IsValid(ply) then
		return
	end

	local Cursor, CursorX, CursorY = self:GetCursor(ply, nil, userEntity)

	if not Cursor then
		if GUI:GetCursor() ~= -1 then
			GUI:Click(false)
			GUI:SetCursor(-1, -1)
		end

		return
	end

	GUI:SetCursor(CursorX or -1, CursorY or -1)
end

function ENT:Control(ply, trace, pressed, userEntity)
	local GUI = self.GUI

	if not IsValid(GUI) then return end
	if not IsValid(ply) then return end

	if pressed then
		if not self:CanControl(ply, userEntity) then
			return
		end

		-- anti click spam
		local now = RealTime()

		if (now - (self._oldusetime or 0)) < 0.1 then
			return
		end

		self._oldusetime = now
	end

	local Cursor, CursorX, CursorY = self:GetCursor(ply, trace, userEntity)
	if not Cursor then
		if GUI:GetCursor() ~= -1 then
			GUI:Click(false)
			GUI:SetCursor(-1, -1)
		end

		return
	end

	GUI:SetCursor(CursorX or -1, CursorY or -1)
	GUI:Click(pressed)

	if SERVER and pressed then
		self:EmitSoundIfExist(self.Sounds_Use, 50, 100, 0.40, CHAN_ITEM)

		self:SetLastUser(ply)
		self:SetLastUsingEntity(userEntity)
	end
end

function ENT:SetupDataTables()
	if not g_isLoaded then return end
	BaseClass.SetupDataTables(self)

	self:AddDTNetworkVar( "Bool", "HasPlaylist" )

	self:AddDTNetworkVar( "Bool", "DisableDisplay", {
		KeyName = "DisableDisplay",
		Edit = {
			category = "GUI",
			title = "Disable display",
			type = "Boolean",
			order = 10
		}
	})

	self:AddDTNetworkVar( "Bool", "DisableInput", {
		KeyName = "DisableInput",
		Edit = {
			category = "GUI",
			title = "Disable user input",
			type = "Boolean",
			order = 11
		}
	})

	self:AddDTNetworkVar( "Bool", "DisableSpectrum", {
		KeyName = "DisableSpectrum",
		Edit = {
			category = "GUI",
			title = "Disable spectrum",
			type = "Boolean",
			order = 12
		}
	})

	self:AddDTNetworkVar( "Bool", "EnableDebug", {
		KeyName = "EnableDebug",
		Edit = {
			category = "GUI",
			title = "Show debug panel",
			type = "Boolean",
			order = 13
		}
	})

	self:SetDTVarCallback("EnableDebug", function(this, name, oldv, newv)
		if not IsValid(self.GUI) then return end
		self.GUI:SetDebug(newv)
	end)

	self:SetDTVarCallback("HasPlaylist", function(this, name, oldv, newv)
		if not IsValid(self.GUI_Main) then return end
		self.GUI_Main:SetHasPlaylist(newv)
	end)

	if CLIENT then
		self:SetDTVarCallback("DisableDisplay", function(this, name, oldv, newv)
			if newv then
				self:RemoveGui()
			end
		end)
	end
end

function ENT:AddItemToPlaylist(newItem)
	if CLIENT then return end

	local url = string.Trim(
		tostring(
			newItem.url or
			newItem.uri or
			newItem.link or
			newItem.source or
			newItem.path or ""
		)
	)

	local name = string.Trim(
		tostring(
			newItem.name or
			newItem.title or ""
		)
	)

	if url == "" then
		return
	end

	if name == "" then
		name = url
	end

	local playlistObj = self.PlaylistData
	local data = playlistObj.data

	local index = #data + 1

	local entry = {
		name = name,
		url = url,
		index = index,
	}

	data[index] = entry

	self._updatedPlaylist = true
	self._nextPlaylistSwitch = nil

	if index > 1 then
		self:SetHasPlaylist(true)
	end
end

function ENT:AddItemsToPlaylist(newItems)
	if CLIENT then return end

	for i, newItem in ipairs(newItems) do
		self:AddItemToPlaylist(newItem)
	end
end

function ENT:SetPlaylist(playlist, pos)
	if CLIENT then return end

	if not pos then
		pos = 1
	end

	self:ClearPlaylist()
	self:AddItemsToPlaylist(playlist)

	local playlistObj = self.PlaylistData
	playlistObj.pos = math.Clamp(pos or 1, 1, #playlistObj.data)
end

function ENT:ClearPlaylist()
	if CLIENT then return end

	local playlistObj = self.PlaylistData

	StreamRadioLib.Util.EmptyTableSafe(playlistObj.data)
	playlistObj.pos = 0

	self._updatedPlaylist = true
	self._nextPlaylistSwitch = nil

	self:SetHasPlaylist(false)
end

function ENT:HasPlaylistInternal()
	if CLIENT then
		return false
	end

	local playlistObj = self.PlaylistData
	local data = playlistObj.data

	if #data <= 1 then
		return false
	end

	return true
end

function ENT:PlayPreviousPlaylistItem()
	if CLIENT then return end

	local playlistObj = self.PlaylistData
	local data = playlistObj.data

	local len = #data
	if len <= 1 then return end

	local index = playlistObj.pos - 1
	if index <= 0 then
		index = len
	end

	index = math.Clamp(index, 1, len)

	local playlistItem = data[index]
	self:PlayFromPlaylistItem(playlistItem)
end

function ENT:PlayNextPlaylistItem()
	if CLIENT then return end

	local playlistObj = self.PlaylistData
	local data = playlistObj.data

	local len = #data
	if len <= 1 then return end

	local index = playlistObj.pos + 1
	if index > len then
		index = 1
	end

	index = math.Clamp(index, 1, len)

	local playlistItem = data[index]
	self:PlayFromPlaylistItem(playlistItem)
end

function ENT:PlayFromPlaylistItemByIndex(index)
	if CLIENT then return end

	local playlistObj = self.PlaylistData
	local data = playlistObj.data

	index = math.Clamp(index or 1, 1, #data)

	local playlistItem = data[index]
	if not playlistItem then return end

	self:PlayFromPlaylistItem(playlistItem)
end

function ENT:PlayFromCurrentPlaylistItem()
	if CLIENT then return end

	local playlistObj = self.PlaylistData
	self:PlayFromPlaylistItemByIndex(playlistObj.pos or 1)
end

function ENT:PlayFromPlaylistItem(playlistItem)
	if CLIENT then return end
	if not playlistItem then return end

	local now = RealTime()
	if self._nextPlaylistSwitch and self._nextPlaylistSwitch > now then
		-- Prevent playlist abuse/spam
		return
	end

	local url = playlistItem.url
	local name = playlistItem.name

	local playlistObj = self.PlaylistData
	local data = playlistObj.data

	playlistObj.pos = math.Clamp(playlistItem.index or 1, 1, #data)
	self:PlayStreamInternal(url, name)

	self._nextPlaylistSwitch = now + 0.25
end

function ENT:GetPlaylist()
	if CLIENT then return end

	local playlistObj = self.PlaylistData
	local data = playlistObj.data

	return data
end

function ENT:GetPlaylistPos()
	if CLIENT then return end

	local playlistObj = self.PlaylistData
	local pos = playlistObj.pos or 1

	return pos
end

function ENT:PlaylistThink()
	if CLIENT then return end

	if not self._updatedPlaylist then return end
	self._updatedPlaylist = nil

	self:SetHasPlaylist(self:HasPlaylistInternal())

	self:OnPlaylistChanged()
end

function ENT:Initialize()
	BaseClass.Initialize(self)

	if SERVER then
		self.PlaylistData = {
			data = {},
			pos = 0,
		}

		self:ClearPlaylist()
	end

	self:SetUpModel()
end

function ENT:OnRemove()
	self:CallModelFunction("OnRemove", model)
	self:RemoveGui()
	self:ClearPlaylist()

	BaseClass.OnRemove(self)
end

function ENT:OnToolButtonClick()
	-- Override me
end

function ENT:OnWireButtonClick()
	-- Override me
end

function ENT:OnPlaylistChanged()
	-- Override me
end

function ENT:OnPlayerClosed()
	-- Override me
end

function ENT:OnPlayerShown()
	-- Override me
end

function ENT:OnModelSetup()
	-- Override me
end

function ENT:OnGUIReady()
	if CLIENT then return end

	if self._postClasssystemPasteLoadDupeOnGUIReady then
		self:ReapplyClasssystemPaste()
	end

	if self._dupePlaylistData then
		self:ReapplyPlaylistFromDupe()
	end
end

function ENT:OnGUISetup(GUI, GUI_Main)
	-- Override me
end

function ENT:OnGUIRemove()
	-- Override me
end

function ENT:OnGUIShowCheck(ply)
	-- Override me
	return true
end

function ENT:OnGUIInteractionCheck(ply, trace, userEntity)
	-- Override me
	return true
end

if CLIENT then
	function ENT:CanSeeDisplay()
		if not g_isLoaded then return false end

		if self._cacheCanSeeDisplay ~= nil then
			return self._cacheCanSeeDisplay
		end

		self._cacheCanSeeDisplay = false

		if self.DisplayLess then return false end

		local ply = LocalPlayer()
		if StreamRadioLib.IsGUIHidden(ply) then return false end
		if not self:OnGUIShowCheck(ply) then return false end
		local scale = self:GetScale()
		if scale <= 0 then return false end

		local pos = self.DisplayPos
		if not pos then return false end

		local ang = self.DisplayAng
		if not ang then return false end

		local campos = StreamRadioLib.GetCameraViewPos(ply)
		if not campos then return false end

		-- Return false if from the backside
		local a = campos - pos
		local b = ang:Up():Dot( a ) / a:Length()

		local displayVisAng = math.acos( b ) / math.pi * 180
		local isSeen = displayVisAng < 90

		if not isSeen then return false end

		self._cacheCanSeeDisplay = true
		return true
	end

	function ENT:GetCursorFromLastUser()
		if not g_isLoaded then return false end

		local lastUser = self:GetLastUser()
		local userEntity = self:GetLastUsingEntity()

		if not IsValid(lastUser) then
			lastUser = LocalPlayer()
		end

		if not IsValid(userEntity) then
			userEntity = lastUser
		end

		return self:GetCursor(lastUser, nil, userEntity)
	end

	function ENT:ShouldRemoveGUI()
		if self.DisplayLess then
			return true
		end

		local ply = LocalPlayer()
		if StreamRadioLib.IsGUIHidden(ply) then
			return true
		end

		return false
	end

	function ENT:DrawGUI()
		if not g_isLoaded then return end

		self._cacheCanSeeDisplay = nil
		self._cacheCanDrawSpectrum = nil

		if self:ShouldRemoveGUI() then
			if self.GUI then
				self:RemoveGui()
			end

			return
		end

		local ply = LocalPlayer()
		if not self:CheckDistanceToEntity(ply, StreamRadioLib.GetDrawDistance(), nil, StreamRadioLib.GetCameraViewPos(ply)) then
			return
		end

		self:PollGuiSetup()

		local GUI = self.GUI

		if not IsValid(GUI) then
			return
		end

		local pos, ang = self:CalcDisplayPosAngWorld()
		if not pos then
			return
		end

		if not ang then
			return
		end

		if not self:CanSeeDisplay() then
			return
		end

		local lastUser = self:GetLastUsingEntity()
		local scale = self:GetScale()

		local Cursor, CursorX, CursorY = self:GetCursorFromLastUser()

		local col = self:GetColor()
		GUI:SetAllowCursor(StreamRadioLib.IsCursorEnabled())
		GUI:SetDrawAlpha(col.a / 255)

		if Cursor or not IsValid(lastUser) then
			GUI:SetCursor(CursorX or -1, CursorY or -1)
		end

		cam.Start3D2D( pos, ang, scale )
			GUI:RenderSystem()
		cam.End3D2D( )
	end

	function ENT:DrawTranslucent(...)
		BaseClass.DrawTranslucent(self, ...)
		self.isseen = true
		self:DrawGUI()
	end

	function ENT:CanDrawSpectrum()
		if not g_isLoaded then return false end

		if self._cacheCanDrawSpectrum ~= nil then
			return self._cacheCanDrawSpectrum
		end

		self._cacheCanDrawSpectrum = false

		if not IsValid(self.GUI) then return false end

		if StreamRadioLib.IsSpectrumHidden() then return false end
		if self:GetDisableSpectrum() then return false end

		if not self:CanSeeDisplay() then return false end

		local ply = LocalPlayer()
		if not self:CheckDistanceToEntity(ply, StreamRadioLib.GetSpectrumDistance(), nil, StreamRadioLib.GetCameraViewPos(ply)) then return false end

		self._cacheCanDrawSpectrum = true
		return true
	end
else
	function ENT:Use(activator, ...)
		if not g_isWiremodLoaded then return false end

		local GUI = self.GUI

		if not IsValid(GUI) then
			return false
		end

		if not GUI:IsReady() then
			return false
		end

		if not IsValid(activator) then
			return false
		end

		if not activator:IsPlayer() then
			return false
		end

		local data = LIBWire.FindCallingWireUserEntityData()
		if not data then
			return false
		end

		local now = RealTime()

		if (now - (self._oldwireusetime or 0)) < 0.1 then
			return false
		end

		self._oldwireusetime = now

		StreamRadioLib.TabControl(activator, data.trace, data.userEntity)
		return true
	end

	function ENT:ReapplyPlaylistFromDupe()
		-- Reapply the duped playlist data once.
		-- This is needed, because gui would override it on creation, which is not wanted.

		local timerId = "KillDupePlaylist_" .. tostring(self)
		StreamRadioLib.Timer.Remove(timerId)

		if self.DisplayLess then
			self._dupePlaylistData = nil
			return
		end

		local playlist = self._dupePlaylistData
		if not playlist then
			return
		end

		StreamRadioLib.Timer.Once(timerId, 1, function()
			if not IsValid(self) then
				return
			end

			-- Remove the list data late to avoid any race conditions
			self._dupePlaylistData = nil
		end)

		local data = playlist.data
		if not data then return end

		local pos = playlist.pos or 1

		self:SetPlaylist(data, pos)
	end

	function ENT:OnSetupCopyData(data)
		BaseClass.OnPreEntityCopy(self, data)

		data.GUI = nil
		data.GUI_Main = nil
		data.PlaylistData = nil
	end

	function ENT:OnPreEntityCopy()
		BaseClass.OnPreEntityCopy(self)

		self:SetDupeData("PlaylistData", self.PlaylistData)
	end

	function ENT:DupeDataApply(key, value)
		BaseClass.DupeDataApply(self, key, value)

		if key ~= "PlaylistData" then return end

		local data = value.data
		if not data then return end

		local pos = value.pos or 1

		self:SetPlaylist(data, pos)

		if self.DisplayLess then
			self._dupePlaylistData = nil
			return
		end

		self._dupePlaylistData = value
	end

	function ENT:PostClasssystemPaste(data)
		if not IsValid(self.StreamObj) then
			return
		end

		if not self._postClasssystemPasteBaseCalled then
			BaseClass.PostClasssystemPaste(self, data)
			self._postClasssystemPasteBaseCalled = true
		end

		if self.DisplayLess then
			return
		end

		if not IsValid(self.GUI) then
			self._postClasssystemPasteLoadDupeOnGUIReady = true
			return
		end

		if self.GUI:IsLoading() then
			self._postClasssystemPasteLoadDupeOnGUIReady = true
			return
		end

		self._postClasssystemPasteLoadDupeOnGUIReady = nil
		self.GUI:LoadFromDupe(data)
	end

	function ENT:PreClasssystemCopy(data)
		BaseClass.PreClasssystemCopy(self, data)

		if IsValid(self.GUI) then
			self.GUI:LoadToDupe(data)
		end
	end
end

--PATH addons/[misc] bodygroupr/lua/entities/bodyman_closet/shared.lua:
ENT.Type = "anim"

ENT.PrintName = "Closet"
ENT.Purpose = "Opens the bodyGroupr menu"

ENT.Spawnable			= true
ENT.AdminSpawnable		= true

ENT.Category = "bodyGroupr"

ENT.WorldModel = "models/props_wasteland/controlroom_storagecloset001a.mdl"

function ENT:Initialize()

	self:SetModel( self.WorldModel )
	self:SetMoveType( MOVETYPE_VPHYSICS )   
	self:SetSolid( SOLID_VPHYSICS )         
 	
	if ( SERVER ) then self:PhysicsInit( SOLID_VPHYSICS ) end

    local phys = self:GetPhysicsObject()
	if (phys:IsValid()) then
		phys:Wake()
		phys:SetMass( 50 )
	end

	if SERVER then
		self:SetUseType( SIMPLE_USE )
		self.health = BODYMAN.ClosetHealth or 100
	end

end
--PATH addons/[technik] darkrp-city-worker/lua/entities/cityworker_hydrant/cl_init.lua:
include( "shared.lua" )

function ENT:Initialize()
    self.emitter = ParticleEmitter( self:GetPos() )

    self.nextEmit = 0

    self.sound = CreateSound( self, "ambient/water/water_flow_loop1.wav" )
    self.sound:SetSoundLevel( 60 )
    --self.sound:Play()
end

function ENT:OnRemove()
    if IsValid( self.sound ) then
        self.sound:Stop()
    end
end

function ENT:Think()
    if self:GetLeaking() then
        if not self.sound:IsPlaying() then
            self.sound:Play()
        end

        if LocalPlayer():GetPos():Distance( self:GetPos() ) <= 2048 then
            if CurTime() > self.nextEmit then
                local v = Vector( 0, 70, 550 )
                v:Rotate( self:GetAngles() )

                -- 2 ^ math.random( 0, 2 ) because we want only 1, 2, and 4 lmao
                local water = self.emitter:Add( "effects/splash"..2 ^ math.random( 0, 2 ), self:LocalToWorld( Vector( 0, 0, 35 ) ) )
                water:SetVelocity( v )
                water:SetDieTime( 2 )
                water:SetStartAlpha( 200 )
                water:SetEndAlpha( 50 )
                water:SetAngles( AngleRand() )
                water:SetStartSize( 10 )
                water:SetEndSize( 50 )
                water:SetGravity( Vector( 0, 0, -600 ) )
                water:SetColor( 255, 255, 255 )
                water:SetAirResistance( 0 )

                self.nextEmit = CurTime() + 0.02
            end
        end
    else
        if self.sound:IsPlaying() then
            self.sound:Stop()
        end
    end

    self:DrawModel()
end
--PATH addons/!jobs/lua/entities/custom_moneyprinter/shared.lua:
--[[---------------------------------------------------------------------------
This is an example of a custom entity.
---------------------------------------------------------------------------]]
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
ENT.PrintName = "Money Printer"
ENT.Author = "DarkRP Developers and <enter name here>"
ENT.Spawnable = false
ENT.AdminSpawnable = false

function ENT:SetupDataTables()
    self:NetworkVar("Int", 0, "price")
    self:NetworkVar("Entity", 0, "owning_ent")
end

--PATH gamemodes/starwarsrp/entities/entities/darkrp_laws/shared.lua:
return gluapack()()
--PATH lua/entities/dc17m_at_rocket2/cl_init.lua:
return gluapack()()
--PATH lua/entities/decs_loader/cl_init.lua:
include("shared.lua")

function ENT:Initialize()
end

ENT.EnginePos = {
	[1] = Vector(-135.68,48.29,17.38),
	[2] = Vector(-134.04,-48.59,17.03),
}


ENT.EngineColor = Color( 55, 55, 255, 255)
ENT.EngineGlow = Material( "sprites/light_glow02_add" )

local spotlight = Material( "effects/lvs/laat_spotlight" )
local glow_spotlight = Material( "sprites/light_glow02_add" )

function ENT:PostDrawTranslucent()
	if not self:GetEngineActive() then return end

	local Size = 30 + ((self:GetVelocity():Length() + math.random(0.5,0.8)) / 1000) * 40 * 2

	render.SetMaterial( self.EngineGlow )

	for _, pos in pairs( self.EnginePos ) do
		render.DrawSprite(  self:LocalToWorld( pos ), Size, Size, self.EngineColor )
	end
end

function ENT:CalcViewDriver( ply, pos, angles, fov, pod )
    local view = {}
    view.origin = pos
    view.fov = fov
    view.drawviewer = true
    view.angles = ply:EyeAngles()

    if pod:GetThirdPersonMode() then


        local radius = 550
        local radius = radius + radius * pod:GetCameraDistance()

        local TargetOrigin = view.origin - view.angles:Forward() * radius  + view.angles:Up() * (radius * 0.2 + radius * pod:GetCameraHeight())
        local WallOffset = 4

        local tr = util.TraceHull( {
            start = view.origin,
            endpos = TargetOrigin,
            filter = function( e )
                local c = e:GetClass()
                local collide = not c:StartWith( "prop_physics" ) and not c:StartWith( "prop_dynamic" ) and not c:StartWith( "prop_ragdoll" ) and not e:IsVehicle() and not c:StartWith( "gmod_" ) and not c:StartWith( "lvs_" ) and not c:StartWith( "player" ) and not e.LVS

                return collide
            end,
            mins = Vector( -WallOffset, -WallOffset, -WallOffset ),
            maxs = Vector( WallOffset, WallOffset, WallOffset ),
        } )

        if not pod:GetThirdPersonMode() then
            view.origin = self:LocalToWorld( Vector(-145, -25, 100) )
            view.drawviewer = false
        end

        view.origin = tr.HitPos

        if tr.Hit and not tr.StartSolid then
            view.origin = view.origin + tr.HitNormal * WallOffset
        end

        return view
    end

    if not pod:GetThirdPersonMode() then

        view.drawviewer = false

        local Driver = self:GetDriver()

        if ply == Driver then
            view.origin = self:LocalToWorld( Vector(-161.05,-22.29,91) )
        end
     
        return view
    end
end

function ENT:LVSCalcView( ply, pos, angles, fov, pod )
	if self:GetDriver() == ply then
		return self:CalcViewDriver( ply, pos, angles, fov, pod )
	end
end

function ENT:Draw()
	self:DrawModel()

	if not self:GetLightsOn() then 
		self:RemoveLight()
		return 
	else
		if not IsValid( self.projector ) then
			local thelamp = ProjectedTexture()
			thelamp:SetBrightness( 20 ) 
			thelamp:SetTexture( "effects/flashlight/soft" )
			thelamp:SetColor( Color(255,255,255) ) 
			thelamp:SetEnableShadows( false ) 
			thelamp:SetFarZ( 1000 ) 
			thelamp:SetNearZ( 75 ) 
			thelamp:SetFOV( 50 )
			self.projector = thelamp

			local thelamp = ProjectedTexture()
			thelamp:SetBrightness( 20 ) 
			thelamp:SetTexture( "effects/flashlight/soft" )
			thelamp:SetColor( Color(255,255,255) ) 
			thelamp:SetEnableShadows( false ) 
			thelamp:SetFarZ( 1000 ) 
			thelamp:SetNearZ( 75 ) 
			thelamp:SetFOV( 50 )
			self.projector2 = thelamp
		end

		local StartPos = self:LocalToWorld( Vector(136.11,48.26,16.58) )
		local StartPos2 = self:LocalToWorld( Vector(135.62,-49.17,17.32) )

		local Dir = self:GetForward()

		render.SetMaterial( glow_spotlight )
		render.DrawSprite( StartPos , 120, 120, Color( 255, 255, 255, 255) )
		render.SetMaterial( spotlight )
		render.DrawBeam(  StartPos ,  StartPos + Dir * 800, 250, 0, 0.99, Color( 255, 255, 255, 10) )

		render.SetMaterial( glow_spotlight )
		render.DrawSprite( StartPos2 , 120, 120, Color( 255, 255, 255, 255) )
		render.SetMaterial( spotlight )
		render.DrawBeam(  StartPos2 ,  StartPos2 + Dir * 800, 250, 0, 0.99, Color( 255, 255, 255, 10) )


		
		if IsValid( self.projector ) then
			self.projector:SetPos( StartPos )
			self.projector:SetAngles( Dir:Angle() )
			self.projector:Update()
			self.projector2:SetPos( StartPos2 )
			self.projector2:SetAngles( Dir:Angle() )
			self.projector2:Update()
		end
	end
end


function ENT:RemoveLight()
	if IsValid( self.projector ) then
		self.projector:Remove()
		self.projector = nil
		self.projector2:Remove()
		self.projector2 = nil
	end
end

function ENT:OnRemove()	
	self:RemoveLight()
end
--PATH gamemodes/starwarsrp/entities/entities/drug_lab/shared.lua:
return gluapack()()
--PATH lua/entities/e60r_rocket2/cl_init.lua:
 include('shared.lua')     
 //[[---------------------------------------------------------     
 //Name: Draw     Purpose: Draw the model in-game.     
 //Remember, the things you render first will be underneath!  
 //-------------------------------------------------------]]  
 function ENT:Draw()      
 // self.BaseClass.Draw(self)  
 -- We want to override rendering, so don't call baseclass.                                   
 // Use this when you need to add to the rendering.        
 self.Entity:DrawModel()       // Draw the model.   
 end
 
   function ENT:Initialize()
	pos = self:GetPos()
	self.emitter = ParticleEmitter( pos )
 end
 
 function ENT:Think()
	
	pos = self:GetPos()
		for i=0, (10) do
			local particle = self.emitter:Add( "particle/smokesprites_000"..math.random(1,9), pos + (self:GetForward() * -100 * i))
			if (particle) then
				particle:SetVelocity((self:GetForward() * -2000) )
				particle:SetDieTime( math.Rand( 1.5, 3 ) )
				particle:SetStartAlpha( math.Rand( 5, 8 ) )
				particle:SetEndAlpha( 0 )
				particle:SetStartSize( math.Rand( 40, 50 ) )
				particle:SetEndSize( math.Rand( 130, 150 ) )
				particle:SetRoll( math.Rand(0, 360) )
				particle:SetRollDelta( math.Rand(-1, 1) )
				particle:SetColor( 200 , 200 , 200 ) 
 				particle:SetAirResistance( 200 ) 
 				particle:SetGravity( Vector( 100, 0, 0 ) ) 	
			end
		
		end
end

--PATH addons/[miecze] moce i hilty/lua/entities/ent_holocron.lua:
return gluapack()()
--PATH lua/entities/eta2.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/entities/entities/fadmin_motd/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
ENT.PrintName = "fadmin MOTD"
ENT.Information = "Place this MOTD somewhere, freeze it and it will be saved automatically"
ENT.Author = "FPtje"
ENT.Spawnable = false

function ENT:CanTool(ply, trace, tool)
    if ply:IsAdmin() and tool == "remover" then
        self.CanRemove = true
        if SERVER then FAdmin.MOTD.RemoveMOTD(self, ply) end
        return true
    end
    return false
end

local PickupPos = Vector(1.8079, -0.6743, -62.3193)
function ENT:PhysgunPickup(ply)
    if ply:IsAdmin() and PickupPos:DistToSqr(self:WorldToLocal(ply:GetEyeTrace().HitPos)) < 49 then return true end
    return false
end

--PATH lua/entities/fighter_base.lua:
ENT.RenderGroup = RENDERGROUP_OPAQUE
ENT.Base = "base_anim"
ENT.Type = "vehicle"
ENT.AutomaticFrameAdvance = true;

ENT.IsSWVehicle = true;
ENT._IsFlyingVehicle = true;

if SERVER then
    
    
function CreateBulletStructure(dmg,color,nosplashdamage)
	if(color == "blue" and dmg/2 > 30) then
		dmg = 30;
	elseif(color == "blue" and dmg/2 <= 30) then
		dmg = dmg/2;
	end
    
    local noion = false;
    if(color == "blue_noion") then
        color = "blue";
        noion = true;
    end

	local bullet = {
		Spread		= Vector(0.001,0.001,0),
		Damage		= dmg*1.25,
		Force		= dmg,
		TracerName	= color .. "_tracer_fx",
		Callback = function(p,tr,damage)
			local self = damage:GetInflictor():GetParent();
			
			util.Decal( "fadingscorch", tr.HitPos + tr.HitNormal, tr.HitPos - tr.HitNormal );
			local fx = EffectData()
				fx:SetOrigin(tr.HitPos);
				fx:SetNormal(tr.HitNormal);
			util.Effect( "StunstickImpact", fx, true )
			
			if(Should_HeliDamage) then
				local e = tr.Entity;
				if(e:GetClass() == "npc_helicopter" or e:GetClass() == "npc_combinegunship") then
					local health = e:Health();
					local new_health = health - dmg;
					if(new_health <= 0) then
						e:Input("SelfDestruct")
					else
						e:SetHealth(health - dmg);
					end
				end
			end		
			if(IsValid(self) and self != tr.Entity) then
				if(!nosplashdamage) then
					util.BlastDamage( self, self.Pilot or self, tr.HitPos, dmg*1.5, dmg*0.66)
				end
				
				
				if(color == "blue" and !noion) then
					if(tr.Entity.IsSWVehicle) then
						tr.Entity.IonShots = tr.Entity.IonShots + 1;
					end
				end
			end
		end	
	}	
	return bullet;
end

local Should_Collisions = true;
local Should_LockOn = true;
local Should_HeliDamage = true;
local Should_AlwaysCorrect = false;
function ENT:SW_LoadConfig()
	local Config_Exists = file.Exists( "swv/general.txt", "DATA" );
	if(Config_Exists) then	
		local s = file.Read("swv/general.txt","DATA");
		local Configs = string.Split( s, ";" );
		local n = table.Count(Configs);
		for i=1,n do
			local c = string.Split(Configs[i], ":");
			if(c[1] == "CollisionDamage") then
				if(c[2] == "yes") then
					Should_Collisions = true;
				else
					Should_Collisions = false;
				end
			elseif(c[1] == "LockOn") then
				if(c[2] == "yes") then
					Should_LockOn = true;
				else
					Should_LockOn = false;
				end
			elseif(c[1] == "HeliDamage") then
				if(c[2] == "yes") then
					Should_HeliDamage = true;
				else
					Should_HeliDamage = false;
				end
			elseif(c[1] == "ForceAssist") then
				if(c[2] == "yes") then
					Should_AlwaysCorrect = true;
				else
					Should_AlwaysCorrect = false;
				end
			elseif(c[1] == "CollideTimer") then
				self.CollideTimer = tonumber(c[2]);
			elseif(c[1] == "CollisionMultiplier") then
				self.CollisionDamageMulti = tonumber(c[2]);
			end
		end
	
	end
end

ENT.NextUse = {Wings = CurTime(),Use = CurTime(),Fire = CurTime(),FireMode = CurTime(),FireBlast=CurTime(),DockCheck=CurTime(),Lock=CurTime(),AutoCorrect=CurTime(),LightSpeed=CurTime(),Switch=CurTime(),};
ENT.DeactivateInWater = true;
   
AddCSLuaFile();

function ENT:Initialize()
        
        
	self:SetModel(self.EntModel);
	self:PhysicsInit(SOLID_VPHYSICS);
	self:SetMoveType(MOVETYPE_VPHYSICS);
	self:SetSolid(SOLID_VPHYSICS);
	self:StartMotionController();
	self:SetUseType(SIMPLE_USE);
	self:SetRenderMode(RENDERMODE_TRANSALPHA);
	self.PlayerActiveWeapon = "";
	if(!self.Weapons) then
		self:SpawnWeapons();
	end
	self.VehicleHealth = self.StartHealth;
	self.IonShots = 0;
	self.Overheat = 0;
	self.Overheated = false;
	self.Cooldown = 2;
	self.Acceleration = 1;
	self.PlayerArmor = 0;
	self.OverheatAmount = self.OverheatAmount or 50;
	self:SetNWInt("OverheatAmount",self.OverheatAmount);
	self:SetNWBool("Critical",self.CriticalDamage or false);
        
    if(!self.IsCapitalShip) then
       self.CanEject = true;     
    end
    
	self.WarpDestination = Vector(0,0,0);
    if(self.HasLightspeed) then
        self:InitLightspeed();
    end
	
	if(not self.Bullet) then
		self.Bullet = CreateBulletStructure(75,"red");
	end

	
	self.Accel={
		FWD=0,
		RIGHT=0,
		UP=0,
	};
	self.Throttle = {
		FWD = 0,
		RIGHT = 0,
		UP = 0,
	};
	
	self.ShouldLock = true;
	self:SetNWBool("ShouldLock",self.ShouldLock);
	self:SetNWString("Allegiance",self.Allegiance);
	
	self.LastCollide = CurTime();
	self.CollideTimer = 1;
	self.CollisionDamageMulti = 1;
	
	if(self.LandDistance) then
		self:SetNWInt("LandDistance",self.LandDistance);
	end
	
	self.OGBoost = self.BoostSpeed;
	self.OGForward = self.ForwardSpeed;
	self.OGUp = self.UpSpeed;
        
	self.TakeOff = true;
	self:SetNWBool("TakeOff",self.TakeOff);
	
	if(self.CanStandby) then
		self.ShouldStandby = true;
	end
	
	self:SetNWInt("Health",self.StartHealth);
	self:SetNWInt("StartHealth",self.StartHealth);
	local mb, mb2 = self:GetModelBounds();
	self.Mass = (mb - mb2):Length()*10;
	self.ShipLength = (mb2.x - mb.x)/2;
	local phys = self:GetPhysicsObject();
        
    self.MaxAcceleration = math.floor((100 - math.ceil((mb-mb2):Length()/100))/10)*2;

	if(phys:IsValid()) then
		phys:Wake()
		phys:SetMass(self.Mass or 10000)
	end
      /* 
    if(self.HasLookaround) then
        self:SetNWBool("HasLookaround",true);
    else
        self:SetNWBool("HasLookaround",false);
	end*/
        
	self:SW_LoadConfig();
	self:ConfigVars();
        
    if(self.HasSeats) then
        self:SpawnSeats();
    end
        
    if(!self.PilotOffset) then
       self.PilotOffset = Vector(0,0,0);     
    end
	
	if(!Should_LockOn) then
		self.ShouldLock = false;
		self:SetNWBool("ShouldLock",false);
	end

end
    
function ENT:InitLightspeed()
    if(WireLib) then
        Wire_CreateInputs(self, { "Destination [VECTOR]", })
    else
        self.DistanceMode = true;
    end     
end

hook.Add("PlayerSpawnedSENT","ServerSpawnedSENT",function(p,e)
    if(e.IsSWVehicle and e._IsFlyingVehicle) then
        e.VehicleOwner = p;  
        e.TransponderCode = e:GenerateTransponder();
        e:SetNWString("TransponderCode", e.TransponderCode);
    end
end);

function ENT:GenerateTransponder()

    local steamid = self.VehicleOwner:SteamID();
    if(steamid == "STEAM_ID_PENDING") then
       steamid = "STEAM_0:0:00000"     
    end
    local code = string.upper(string.sub(string.gsub(string.gsub(self.PrintName," ",""),"-",""),0,3));
    steamid = string.sub(string.Split(steamid,":")[3],1,4);
    return code .. " " .. steamid .. self:CountPlayerOwnedSENTs(self:GetClass(),self.VehicleOwner);
        
end
    
function ENT:CountPlayerOwnedSENTs(class,p)
    local count = 0;
    for k,v in pairs(ents.FindByClass(class)) do
        if(v.VehicleOwner == p) then
            count = count + 1;
        end
    end
    return count;
end

function ENT:ConfigVars()
	local path = "swv/".. self:GetClass() ..".txt";
	local Config_Exists = file.Exists( path, "DATA" );
	if(Config_Exists) then
		local s = file.Read(path,"DATA");
		local Settings = string.Split(s,";");
		local n = table.Count(Settings);
		for i=1,n do
			if(Settings[i] != nil and Settings[i] != "") then
				local Key = string.gsub(string.Split(Settings[i],"=")[1],"%s", ""):upper();
				local Value = string.gsub(string.Split(Settings[i],"=")[2],"%s",""):upper();
			
				if(Key != nil and Key != "") then
					if(Key == "HEALTH") then
						self.VehicleHealth = tonumber(Value);
						self.StartHealth = tonumber(Value);
						self:SetNWInt("StartHealth",tonumber(Value));
						self:SetNWInt("Health",tonumber(Value));
					elseif(Key == "WEAPONDAMAGE") then
						self.Bullet = CreateBulletStructure(tonumber(Value),string.Split(self.Bullet.TracerName,"_")[1]);
					elseif(Key == "FORWARDSPEED") then
						self.ForwardSpeed = tonumber(Value);
						self.OGForward = self.ForwardSpeed;
					elseif(Key == "BOOSTSPEED") then
						self.BoostSpeed = tonumber(Value);
						self.OGBoost = self.BoostSpeed;
					elseif(Key == "ACCELSPEED") then
						self.AccelSpeed = tonumber(Value);
					elseif(Key == "SPLASHDAMAGE") then
						local b = true;
						if(Value == "false") then
							b = false;
						end
						self.Bullet = CreateBulletStructure(self.Bullet.Damage,string.Split(self.Bullet.TracerName,"_")[1],b);
					elseif(Key == "COLLISIONMULTIPLIER") then
						self.CollisionDamageMulti = tonumber(Value);
					end
				end
			end
		end
	end
end


function ENT:SpawnWeapons()
	self.Weapons = {};
	for k,v in pairs(self.WeaponLocations) do
		local e = ents.Create("prop_physics");
		e:SetModel("models/props_junk/PopCan01a.mdl");
		e:SetPos(v);
		e:Spawn();
		e:Activate();
		e:SetRenderMode(RENDERMODE_TRANSALPHA);
		e:GetPhysicsObject():EnableCollisions(false);
		e:GetPhysicsObject():EnableMotion(false);
		e:SetSolid(SOLID_NONE);
		e:AddFlags(FL_DONTTOUCH);
		e:SetColor(Color(255,255,255,0));
		e:SetParent(self);
		self.Weapons[k] = e;
	end

end

function ENT:OnRemove(p)

	if(self.Inflight and not self.Done) then
		self:Exit(); -- Let the player out
	end
end

function ENT:Enter(p)

	if(!self.Inflight and !self.Done) then
		p:SetNetworkedEntity(self.Vehicle,self); --Set a networked entity as the name of the vehicle
		p:SetNetworkedBool("Flying"..self.Vehicle,true); --Set a bool on the player
		p:Spectate(OBS_MODE_CHASE); --Spectate the vehicle
		p:DrawWorldModel(false);
		p:DrawViewModel(false);
		p:SetRenderMode(RENDERMODE_TRANSALPHA);
		p:SetColor(Color(255,255,255,0));
		p:SetMoveType(MOVETYPE_NOCLIP);		
		p:SetCollisionGroup(COLLISION_GROUP_IN_VEHICLE);
		for k,v in pairs(p:GetWeapons()) do
			table.insert(self.WeaponsTable, v:GetClass());
		end
		if(IsValid(p:GetActiveWeapon())) then
			self.PlayerActiveWeapon = p:GetActiveWeapon():GetClass();
		end
		
		self.WeaponAmmo = {}
		
		for k,v in pairs(p:GetWeapons()) do
			local tbl = {
				v:GetPrimaryAmmoType(),
				p:GetAmmoCount(v:GetPrimaryAmmoType()),
			};
			self.WeaponAmmo[k] = tbl;
		end
		
		p:StripWeapons();
		self.PlayerHealth=p:Health();
		if(p:FlashlightIsOn()) then
			p:Flashlight(false); --Turn the player's flashlight off when Flying
		end
		self:SetNWBool("Flying" .. self.Vehicle,true);
		self:SetNWInt("SW_MaxSpeed",self:GetTopSpeed());
        self:SetNWBool("HasLookaround", self.HasLookaround != nil and self.HasLookaround != false)
		p:SetViewEntity(self)
		self:GetPhysicsObject():Wake();
		self:GetPhysicsObject():EnableMotion(true); --UnFreeze us
		self:StartMotionController()

		self:Rotorwash(true);
		self.PlayerArmor = p:Armor();
		self.Inflight = true;
		self.Pilot = p;
		self.NextUse.Use = CurTime()+1;
		
		self.StartPos = self:GetPos();
		self.LandPos = self:GetPos()+Vector(0,0,10);
		
		self.Accel.FWD = 0;
		self.Accel.RIGHT = 0;
		self.Accel.UP = 0;
		
		self:SetNWBool("Speed",self.Accel.FWD);
		
		p:SetNWInt("SW_Health",self.VehicleHealth);
		p:SetNWInt("SW_Overheat",self.Overheat);
		p:SetNWBool("SW_Overheated",self.Overheated);	
		p:SetNWBool("SW_Critical",self.CriticalDamage or false);	
		p:SetNWBool("SW_ShouldLock",self.ShouldLock);
		p:SetNWBool("SW_Speed",self.Accel.FWD);
		p:SetNWInt("SW_MaxSpeed",self:GetTopSpeed());
		p:SetNWBool("SW_Wings",self.Wings);

		
		p:SetEyeAngles(self.EnterAngles or self:GetAngles());
		
		if(self.PilotVisible and self.PilotPosition) then
			local pos = self:GetPos() + self:GetRight() * self.PilotPosition.x + self:GetForward() * self.PilotPosition.y + self:GetUp() * self.PilotPosition.z;
			self:SpawnPilot(pos);
		end
	end
end

function ENT:SpawnPilot(pos)

	if(IsValid(self.Pilot)) then
		local e = ents.Create("prop_physics");
		e:SetModel(self.Pilot:GetModel());
		e:SetPos(pos)
		local ang = self:GetAngles();
		if(self.PilotAngle) then
			ang = self:GetAngles() + self.PilotAngle;
		end
		e:SetAngles(ang)
		e:SetParent(self);
		e:Spawn();
		e:Activate();
		
		local anim = "sit_rollercoaster";
		if(self.PilotAnim) then	
			anim = self.PilotAnim;
		end
		e:SetSequence(e:LookupSequence(anim));
		
		self.PilotAvatar = e;
		self:SetNWEntity("PilotAvatar",e);
	end
end

function ENT:GetTopSpeed()
	if(self.OGForward > self.OGBoost) then
		return self.OGForward;
	end
	return self.OGBoost;
end

function ENT:Exit(kill) --####### Get out @RononDex
    self.Inflight = false;
	if (IsValid(self.Pilot)) then
		self.Pilot:UnSpectate();
		self.Pilot:DrawViewModel(true);
		self.Pilot:DrawWorldModel(true);
		self.Pilot:Spawn();
		self.Pilot:SetNWEntity(self.Vehicle,NULL)
		self.Pilot:SetNWBool("Flying"..self.Vehicle,false);
		
		if(self.ExitModifier) then
			self.ExitPos = self:GetPos() + (self:GetRight() * self.ExitModifier.x) + (self:GetForward() * self.ExitModifier.y) + (self:GetUp()* self.ExitModifier.z);
        else
            self.ExitPos = self:GetPos()+self:GetUp()*105+self:GetRight()*100+self:GetForward()*-80;
		end
		self.Pilot:SetPos(self.ExitPos);
		
		self.Pilot:SetMoveType(MOVETYPE_WALK);
		self.Pilot:SetCollisionGroup(COLLISION_GROUP_PLAYER);
		self.Pilot:SetViewEntity( NULL )
		self.Pilot:SetHealth(self.PlayerHealth);
		self.Pilot:SetArmor(self.PlayerArmor);
		for k,v in pairs(self.WeaponsTable) do
			if(!self.Pilot:HasWeapon(tostring(v))) then
				self.Pilot:Give(tostring(v));
			end
		end
		if(self.PlayerActiveWeapon != "") then
			self.Pilot:SelectWeapon(self.PlayerActiveWeapon);
		end
		
		self.Pilot:StripAmmo();
		
		for k,v in pairs(self.WeaponAmmo) do
			self.Pilot:SetAmmo(v[2],v[1]);
		end
		
		self.Pilot:SetRenderMode(RENDERMODE_NORMAL);
		self.Pilot:SetColor(Color(255,255,255,255));		
		if (kill and self.Pilot:Alive() and !self.Pilot:HasGodMode()) then 
			self.Pilot:Kill();
		end
	end
	if(self.Wings) then
		self:ToggleWings();
	end
	self:ResetThrottle();
	self:Rotorwash(false);
	self:SetNWEntity(self.Vehicle,nil);
	self:SetNWBool("Flying" .. self.Vehicle,false);
	
	self.Pilot:SetVelocity(self:GetVelocity());

	self.Accel.FWD = 0;
	self.Accel.RIGHT = 0;
	self.Accel.UP = 0;
	if(self.TakeOff or self.Land) then
		self.Acceleration = 1;
	end
	
	table.Empty(self.WeaponsTable); 
	table.Empty(self.WeaponAmmo); 

	self.NextUse.Use = CurTime() + 1;
	self.Pilot:SetRenderMode(RENDERMODE_NORMAL);
	self.Pilot:SetColor(Color(255,255,255,255));
	
	local p = self.Pilot;
	p:SetNWInt("SW_Health",nil);
	p:SetNWInt("SW_Overheat",nil);
	p:SetNWBool("SW_Overheated",nil);	
	p:SetNWBool("SW_Critical",nil);	
	p:SetNWBool("SW_ShouldLock",nil);
	p:SetNWBool("SW_Speed",nil);
	p:SetNWInt("SW_MaxSpeed",nil);
	self.Pilot:SetNWBool("SW_Wings",nil);
	
	self.Pilot = NULL;
	
	if(IsValid(self.PilotAvatar)) then
		self.PilotAvatar:Remove();
		self:SetNWEntity("PilotAvatar",NULL);
	end
end

local al = 1;
function ENT:FireWeapons()
	
	if(self.NextUse.Fire < CurTime()) then
		for k,v in pairs(self.Weapons) do
            if(!IsValid(v)) then return end;
			local tr = util.TraceLine({
				start = self:GetPos(),
				endpos = self:GetPos()+self:GetForward()*10000,
				filter = {self},
			})
			
			local angPos = (tr.HitPos - v:GetPos())
			
			if(self.ShouldLock) then
				local e = self:FindTarget();
				if(IsValid(e)) then
					local tr = util.TraceLine( {
						start = v:GetPos(),
						endpos = e:GetPos(),
						filter = {self},
					} )
					if(!tr.HitWorld) then
						angPos = (e:GetPos() + e:GetUp()*(e:GetModelRadius()/3) + (self.LockOnOverride or Vector(0,0,0))) - v:GetPos();
					end

				end
			end
			
			self.Bullet.Attacker = self.Pilot or self;
			self.Bullet.Src		= v:GetPos();
            local spread = self.Accel.FWD/1000;
            self.Bullet.Spread = Vector(spread,spread,spread);
			
			self.Bullet.Dir = angPos

            if(!self.Disabled) then
                if(self.AlternateFire) then
                    if(al == 1 and (k == self.FireGroup[1] or k == self.FireGroup[3])) then
                        v:FireBullets(self.Bullet)
                    elseif(al == 2 and (k == self.FireGroup[2] or k == self.FireGroup[4])) then
                        v:FireBullets(self.Bullet)
                    end
                else
                    v:FireBullets(self.Bullet)
                end
            end
		end
		al = al + 1;
		if(al == 3) then
			al = 1;
		end
		self:EmitSound(self.FireSound,100,math.random(90,110));
		self.NextUse.Fire = CurTime() + (self.FireDelay or 0.2)*0.8;
	end
end
    
function ENT:SpawnSeats()
    if(!self.SeatPos) then 
        print("Unable to Spawn Passengers! No Positions Set")
        return;
    end
	self.Seats = {};
	for k,v in pairs(self.SeatPos) do
		local e = ents.Create(self.SeatClass or "prop_vehicle_prisoner_pod");
		e:SetPos(v[1] or self:GetPos());
		e:SetAngles(v[2] or self:GetAngles());
		e:SetParent(self);		
		e:SetModel("models/nova/airboat_seat.mdl");
		e:SetRenderMode(RENDERMODE_TRANSALPHA);
        e:SetColor(Color(255,255,255,0));
		e:Spawn();
		e:Activate();
		e:SetUseType(USE_OFF);
		e:GetPhysicsObject():EnableMotion(false);
		e:GetPhysicsObject():EnableCollisions(false);
        e:SetCollisionGroup(COLLISION_GROUP_WEAPON);
		e["Is" .. self.Vehicle .. "Seat"] = true;
		e[self.Vehicle] = self;
        e._ExitPos = v[3] or Vector(0,0,0);
		self.Seats[k] = e;
        if(self.DisableThirdpersonSeats) then
            e:SetNWBool("NoFirstPerson",true);
        end
	end

end

function ENT:Passenger(p)
    if(self.Pilot == p) then return end;
	if(self.NextUse.Use > CurTime()) then return end;
	for k,v in pairs(self.Seats) do
		if(v:GetPassenger(1) == NULL) then
			p:EnterVehicle(v);
			return;			
		end
	end
end
    
hook.Add("PlayerEnteredVehicle","SWVehicleSeatEnter", function(p,v)
	if(IsValid(v) and IsValid(p)) then
        local e = v:GetParent();
        if(e.IsSWVehicle) then
            if(v["Is" .. e.Vehicle .. "Seat"]) then
                p:SetNetworkedEntity(e.Vehicle .. "Seat",v);
                p:SetNetworkedEntity(e.Vehicle,v:GetParent());
                p:SetNetworkedBool(e.Vehicle .. "Passenger",true);
            end
		end
	end
end);
    
hook.Add("PlayerLeaveVehicle", "SWVehicleSeatExit", function(p,v)
	if(IsValid(p) and IsValid(v)) then
        local e = v:GetParent();
        if(e.IsSWVehicle) then
            v:SetThirdPersonMode(false);
            if(v["Is" .. e.Vehicle .. "Seat"]) then
                p:SetNetworkedEntity(e.Vehicle .. "Seat",NULL);
                p:SetNetworkedEntity(e.Vehicle,NULL);
                p:SetNetworkedBool(e.Vehicle .. "Passenger",false);
                local pos = e:LocalToWorld(v._ExitPos or Vector(0,0,0));
                p:SetPos(pos);
            end
        end
	end
end);

function ENT:FindTarget()
	local corner1, corner2 = self:GetModelBounds();
	corner1 = self:LocalToWorld(corner1);
	corner2 = self:LocalToWorld(corner2) + self:GetForward()*10000;
	for k,v in pairs(ents.FindInBox(corner1,corner2)) do
		if(v.IsSWVehicle and !v.DontLock and v != self and v.Allegiance != self.Allegiance) then
			return v;
		end
	end
	return NULL;

end

function ENT:ChangeAllegiance(al)
    self.Allegiance = al;
	self:SetNWString("Allegiance",al);
end

ENT.Flashlight = {};
function ENT:CreateFlashlight()

    local i = 1;
    for k,v in pairs(self.Flashlights) do
        self.Flashlight[i] = ents.Create( "env_projectedtexture" )
        self.Flashlight[i]:SetParent(self)

        self.Flashlight[i]:SetLocalPos(v[1])
        self.Flashlight[i]:SetLocalAngles(v[2])

        self.Flashlight[i]:SetKeyValue( "enableshadows", 1 )
        self.Flashlight[i]:SetKeyValue( "farz", self.FlashlightDistance or 3000 )
        self.Flashlight[i]:SetKeyValue( "nearz", 6 )
        self.Flashlight[i]:SetKeyValue( "lightfov", 80 )

        local c = Color(255,255,255);
        local b = 1;
        self.Flashlight[i]:SetKeyValue( "lightcolor", Format( "%i %i %i 255", c.r * b, c.g * b, c.b * b ) )
        self.Flashlight[i]:Spawn()
        self.Flashlight[i]:Input( "SpotlightTexture", NULL, NULL, "effects/flashlight001" )
        i = i+1;
    end
    self.FlashlightOn = true;
end
    
function ENT:RemoveFlashlight()
        
   if(IsValid(self.Flashlight[1])) then
        for k,v in pairs(self.Flashlight) do
            v:Remove(); 
            
        end
        table.Empty(self.Flashlight);
    end
    self.FlashlightOn = false;
end

hook.Add("PlayerSwitchFlashlight","SWVehicleSwitchFlashlight",function(p,e)
    local self = p:GetViewEntity();     
    if(self.IsSWVehicle and self.Inflight and self.HasFlashlight) then
        if(self.FlashlightOn) then
            self:RemoveFlashlight();
        else
            self:CreateFlashlight();
        end
        return false;
    end
end)    

function ENT:Think()
	


	if(self.Inflight) then
        if CAF and CAF.GetAddon("Spacebuild") then
            if(IsValid(self.Pilot) and self.Pilot.LsResetSuit) then
                self.Pilot:LsResetSuit()
            end
        end
        
        
        self.ForwardSpeed = self.OGForward;
        self.BoostSpeed = self.OGBoost;
        for k,v in pairs(ents.FindInSphere(self:GetPos(),1500)) do
            if(v:GetName() == "ship_speed") then
                local n = self:GetTopSpeed() * 0.2;
                self.ForwardSpeed = math.Clamp(n,0,self.OGForward);
                self.BoostSpeed = math.Clamp(n,0,self.OGBoost);
            end
        end

	
		if(IsValid(self.Pilot) and !self.Pilot:Alive()) then
			self:Bang();
		end

	
		if(self.IonShots >= (self.MaxIonShots or 20)) then
			self.CriticalDamage = true;
			self:SetNWBool("Critical",self.CriticalDamage);
			//self.Accel.FWD = 0;
			self:ResetThrottle();
			timer.Create(self.Vehicle .. "IonShotTimer" .. self:EntIndex() * math.random(1,1000), 10, 1, function()
				if(IsValid(self)) then
					self.CriticalDamage = false;
					self.IonShots = 0;		
					self:SetNWBool("Critical",self.CriticalDamage);
					if(IsValid(self.Pilot)) then
						self.Pilot:SetNWBool("SW_Critical",self.CriticalDamage);
					end
				end
			end);
		end
		
		if(!self.TakeOff and !self.Land) then
			local a = math.Clamp(20 - self.Mass/1000,4,self.MaxAcceleration);
			if(self.AccelSpeed <= 10 and self.AccelSpeed > a) then
				a = self.AccelSpeed;
			end
			self.Acceleration = math.Approach(self.Acceleration,a,(a*0.03));
		end
		
		if(IsValid(self.Pilot)) then

            if(self.HasLightspeed) then
                if((self.HasWings and self.Wings) or (!self.HasWings)) then
                    if(self.Pilot:KeyDown(IN_SPEED)  and self.Pilot:KeyDown(IN_JUMP) and self.NextUse.LightSpeed < CurTime()) then
                        if(!self.LightSpeed and !self.HyperdriveDisabled) then
                            self.LightSpeed = true;
                            self.LightSpeedTimer = CurTime() + (self.LightSpeedChargeTime or 3);
                            self.NextUse.LightSpeed = CurTime() + (self.LightspeedDelay or 20);

                        end
                    end
                end

                if(WireLib) then
                    if(self.Pilot:KeyDown(IN_RELOAD) and self.Pilot:KeyDown(IN_SPEED) and self.NextUse.Switch < CurTime()) then
                        if(!self.DistanceMode) then
                            self.DistanceMode = true;
                            self.Pilot:ChatPrint("LightSpeed Mode: Distance");
                        else
                            self.DistanceMode = false;
                            self.Pilot:ChatPrint("LightSpeed Mode: Destination");
                        end
                        self.NextUse.Switch = CurTime() + 1;
                    end
                end

                if(self.LightSpeed) then
                    if(self.DistanceMode) then
                        self:PunchingIt(self:GetPos()+self:GetForward()*20000);
                    else
                        self:PunchingIt(self.WarpDestination);
                    end
                end
            end

			if(self.Pilot:KeyDown(IN_USE)) then
				if(self.NextUse.Use < CurTime()) then
                    if(self.Pilot:KeyDown(IN_JUMP) and self.CanEject) then
                        self:Eject();
                    else
				        self:Exit(false);
                    end
				end
			end
			
			if(IsValid(self.Pilot) and self.Pilot:KeyDown(IN_DUCK) and self.Pilot:KeyDown(IN_RELOAD)) then
				self:ToggleAssist();
			end

			if(self.HasWings) then
				if(IsValid(self.Pilot)) then
					if(self.Pilot:KeyDown(IN_SPEED) and (!self.Pilot:KeyDown(IN_JUMP) or !self.HasLightspeed) and !self.LightSpeed and self.NextUse.Wings < CurTime()) then
						self:ToggleWings();
					end
				end
			end
			
			if(self.CanShoot and !self.WeaponsDisabled) then
				if(IsValid(self.Pilot)) then // I don't know why I need this here for a second check but when I don't it causes an error

					if(self.Pilot:KeyDown(IN_ATTACK) and self.Pilot:KeyDown(IN_RELOAD) and Should_LockOn) then
						self:ToggleLock();			
					elseif(self.Pilot:KeyDown(IN_ATTACK) and self.NextUse.Fire < CurTime()) then
						if(((not self.Overheated and self.Overheat < (self.OverheatAmount or 50)) or self.DontOverheat) and !self.CriticalDamage) then
							self:FireWeapons();
							self.Overheat = self.Overheat + 2;
							self.Cooldown = 2;
						elseif(self.Overheated) then
							self.Overheat = self.Overheat - self.Cooldown;
							self.Cooldown = math.Approach(self.Cooldown,4,0.25);
						end
						self:Network_Overheating();
					else
						if(self.NextUse.Fire < CurTime()) then
							if(self.Overheat > 0) then
								self.Overheat = self.Overheat - self.Cooldown;
								self.Cooldown = math.Approach(self.Cooldown,4,0.25);
								self:Network_Overheating();
							end
						end
					end
				end
				
				if(self.Overheat >= (self.OverheatAmount or 50)) then
					self.Overheated = true;
					self:Network_Overheating();					
				elseif(self.Overheat <= 0) then
					self.Overheated = false;
					self:Network_Overheating();
				end
			end
			

		end
            
        if(IsValid(self.Pilot) and self.Inflight and !self.Pilot:KeyDown(IN_USE)) then
            self.Pilot:SetPos(self:GetPos()+(self:GetRight()*self.PilotOffset.x)+(self:GetForward()*self.PilotOffset.y)+(self:GetUp()*self.PilotOffset.z));
        end
		
        if(!self.DeactivateInWater) then
            if(self:WaterLevel() >= 1) then
                self.BoostSpeed = self.OGBoost/2;
                self.ForwardSpeed = self.OGForward/2;
            else
                self.BoostSpeed = self.OGBoost;
                self.ForwardSpeed = self.OGForward;
            end
        end
	else
		if(self.TakeOff) then
			self:Heal();
		end
		
		if(self.Docked and !self.TakeOff) then
			if(self.NextUse.DockCheck < CurTime()) then
				self.Docked = false;
				local phys = self:GetPhysicsObject();
				if(IsValid(phys)) then
					phys:SetMass(self.Mass);
				end
				self.NextUse.DockCheck = CurTime() + 10;
			end
		end
		
	end

end
    
function ENT:PunchingIt(Dest)
	if(!self.PunchIt) then
		if(self.LightSpeedTimer > CurTime()) then
			self.ForwardSpeed = 0;
			self.BoostSpeed = 0;
			self.UpSpeed = 0;
			self.Accel.FWD = 0;
			self:SetNWInt("LightSpeed",1);
			if(!self.PlayedSound) then
				self:EmitSound(self.HyperDriveSound or Sound("vehicles/hyperdrive.mp3"),100);
				self.PlayedSound = true;
			end
			//util.ScreenShake(self:GetPos()+self:GetForward()*-730+self:GetUp()*195+self:GetRight()*3,5,5,10,5000)
		else
			self.Accel.FWD = 4000;
			self.LightSpeedWarp = CurTime()+0.5;
			self.PunchIt = true;
			self:SetNWInt("LightSpeed",2);
		end
	
	else
		if(self.LightSpeedWarp < CurTime()) then
			
			self.LightSpeed = false;
			self.PunchIt = false;
			self.ForwardSpeed = self.OGForward;
			self.BoostSpeed = self.OGBoost;
			self.UpSpeed = self.OGUp;
			self:SetNWInt("LightSpeed",0);
			local fx = EffectData()
				fx:SetOrigin(self:GetPos())
				fx:SetEntity(self)
			util.Effect("propspawn",fx)
			self:EmitSound("ambient/levels/citadel/weapon_disintegrate2.wav", 500)
			self:SetPos(Dest);
			self.PlayedSound = false;
		end
	end
end

function ENT:TriggerInput(k,v)
	if(k == "Destination") then
		self.WarpDestination = v;
	end
end


function ENT:ToggleAssist()
	if(self.NextUse.AutoCorrect < CurTime()) then
		if(self.AutoCorrect) then
			self.AutoCorrect = false;
			self.Pilot:ChatPrint("Pilot-Assist: Disabled");
		else
			self.AutoCorrect = true;
			self.Pilot:ChatPrint("Pilot-Assist: Enabled");
		end
		self.NextUse.AutoCorrect = CurTime() + 1;
	end
end

function ENT:ToggleLock()
	if(!Should_LockOn) then return end;
	if(self.NextUse.Lock < CurTime()) then
		if(self.ShouldLock) then
			self.ShouldLock = false;
			self.Pilot:ChatPrint("Weapons Lock: Disabled");
		else
			self.ShouldLock = true;
			self.Pilot:ChatPrint("Weapons Lock: Enabled");
		end
		self.NextUse.Lock = CurTime() + 1;
		self:SetNWBool("ShouldLock",self.ShouldLock);
		if(IsValid(self.Pilot)) then
			self.Pilot:SetNWBool("SW_ShouldLock",self.ShouldLock);
		end
	end			
end

function ENT:Heal()
	local Health = self.VehicleHealth or self:GetNWInt("Health");
	local inc = self.StartHealth / 1000 * 0.5;
	if(Health < self.StartHealth) then
		if(self.StartHealth - Health < inc) then
			self:SetNWInt("Health",self.StartHealth);
			self.VehicleHealth = self.StartHealth;
		else
			self:SetNWInt("Health",Health+inc);
			self.VehicleHealth = Health + inc;
		end
	end
end
    
function ENT:Eject()
    if(IsValid(self.Pilot) and self.CanEject and !self.TakingOff and !self.Land) then     
        local p = self.Pilot;
        self:Exit(false);
        p:SetVelocity(self:GetUp()*1500);
    else
        self:Exit(false);
    end
end

function ENT:Network_Overheating()

	self:SetNWInt("Overheat",self.Overheat);
	self:SetNWBool("Overheated",self.Overheated);
	if(IsValid(self.Pilot)) then
		self.Pilot:SetNWInt("SW_Overheat",self.Overheat);
		self.Pilot:SetNWBool("SW_Overheated",self.Overheated);
	end
	
end

function ENT:OnTakeDamage(dmg)

	if(dmg:GetInflictor():GetParent() == self) then return end;

	self.VehicleHealth = math.floor(self.VehicleHealth-(dmg:GetDamage()/2));
	
	self:SetNWInt("Health",self.VehicleHealth);
	if(IsValid(self.Pilot)) then
		self.Pilot:SetNWInt("SW_Health",self.VehicleHealth);
	end

	if(self.VehicleHealth<=(self.StartHealth*0.33)) then
		self.HyperdriveDisabled = true;
	end
	
	if(self.VehicleHealth<(self.StartHealth*0.2)) then
		self.WeaponsDisabled = true;
	end
	
	if(self.VehicleHealth<(self.StartHealth*0.1)) then
		self.CriticalDamage = true;
		if(IsValid(self.Pilot)) then
			self.Pilot:SetNWBool("SW_Critical",self.CriticalDamage);
		end
	end
	
	
	if((self.VehicleHealth)<=0 and !self.Done) then
		self:Bang() -- Go boom
	end
end


function ENT:ToggleWings()
	if(self.NextUse.Wings < CurTime()) then
		if(self.Wings) then
			self.Sequence = self:LookupSequence("idle");
			self.Wings = false;
		else
			self.Wings = true;
			self.Sequence = self:LookupSequence("attack");
		end
		self:ResetSequence(self.Sequence);
		//self:SetPlaybackRate(0.01);
		self:SetNWBool("Wings",self.Wings);
		if(IsValid(self.Pilot)) then
			self.Pilot:SetNWBool("SW_Wings",self.Wings);
		end
		self.NextUse.Wings = CurTime() + 1;
	end
end


function ENT:Use(p)
    if(!p:KeyDown(IN_WALK)) then
        if(!self.Inflight and (self.NextUse.Use < CurTime())) then
            self:Enter(p);
        elseif(self.Inflight and self.HasSeats) then
            self:Passenger(p);
        end
    else
        if(self.HasSeats) then
            self:Passenger(p);
        end
    end
end

function ENT:TestLoc(pos)
    //For testing positions (Mainly for effects and weapons)
	local e = ents.Create("prop_physics");
	e:SetPos(pos);
	e:SetModel("models/props_junk/PopCan01a.mdl");
	e:Spawn();
	e:Activate();
	e:SetParent(self);
	
end

function ENT:FireBlast(pos,gravity,vel,dmg,white,size,snd)
	if(self.NextUse.FireBlast < CurTime()) then
		local e = ents.Create("cannon_blast");
		
		e.Damage = dmg or 600;
		e.IsWhite = white or false;
		e.StartSize = size or 20;
		e.EndSize = e.StartSize*0.75 or 15;
		
		
		local sound = snd or Sound("weapons/n1_cannon.wav");
		
		e:SetPos(pos);
		e:Spawn();
		e:Activate();
		e:Prepare(self,sound,gravity,vel);
		e:SetColor(Color(255,255,255,1));
		
		self.NextUse.FireBlast = CurTime() + 3;
		
		self:SetNWInt("FireBlast",self.NextUse.FireBlast)
	end
	
end

function ENT:FireTorpedo(pos,target,vel,dmg,c,size,ion,snd)

	local e = ents.Create("torpedo_blast");
	
	e.Damage = dmg or 600;
	e.SpriteColour = c or Color(255,255,255,255);
	e.StartSize = size or 20;
	e.EndSize = e.StartSize*0.75 or 15;
	e.Ion = ion or false;
	
	local sound = snd or Sound("weapons/n1_cannon.wav");
	e:SetPos(pos);
	e:SetAngles(self:GetAngles())
	e:SetCollisionGroup(COLLISION_GROUP_PROJECTILE);

	e:PrepareTorpedo(self,sound,vel);
	e:SetColor(Color(255,255,255,1));
	e.Ang = self:GetAngles();
	
	if(IsValid(target)) then
		e.Target = target;
		e.Targetting = true;
	end
	e:Spawn();
	e:Activate();
    constraint.NoCollide(self,e,0,0)
end


function ENT:ResetThrottle()
	
	for k,v in pairs(self.Throttle) do
		self.Throttle[k] = 0;
	end
	
	for k,v in pairs(self.Accel) do
		self.Accel[k] = 0;
	end

	self.Acceleration = 1;
end

function ENT:Handbrake()
	
	for k,v in pairs(self.Throttle) do
		self.Throttle[k] = 0;
	end
	self.Accel.FWD = math.Approach(self.Accel.FWD,0,self.AccelSpeed*4)
	self.Handbraking = true;
end

local FlightPhys = {
	secondstoarrive	= 1;
	maxangular		= 5000;
	maxangulardamp	= 10000;
	maxspeed			= 1000000;
	maxspeeddamp		= 500000;
	dampfactor		= 0.8;
	teleportdistance	= 5000;
};
local ZAxis = Vector(0,0,1);
ENT.Roll = 0;
function ENT:PhysicsSimulate( phys, deltatime )
	local FWD = self.ForwardDir or self.Entity:GetForward();
	local UP = self:GetUp() or ZAxis;
	local RIGHT = FWD:Cross(UP):GetNormalized();
	if(!self.Done and !self.Tractored and (!self.DeactivateInWater or (self.DeactivateInWater and self:WaterLevel() < 3))) then
        if(self.Inflight and IsValid(self.Pilot)) then

            local pos = self:GetPos();

            if(!self.TakeOff and !self.Land) then
                self.Handbraking = false;
                if(!self.CriticalDamage) then
                    if(self.Pilot:KeyDown(IN_RELOAD) and self.Pilot:KeyDown(IN_JUMP)) then
                        self:Handbrake();
                    else
                        if(self.Pilot:KeyDown(IN_FORWARD)) then
                            self.Throttle.FWD = self.Throttle.FWD + self.Acceleration;
                        elseif(self.Pilot:KeyDown(IN_BACK)) then
                            self.Throttle.FWD = self.Throttle.FWD - self.Acceleration;
                        end
                    end
                        
                    local min,max;
                    if(self.CanBack) then
                        min = (self.ForwardSpeed*0.66)*-1;
                    else
                        min = 0;
                    end

                    if(self.Wings and self.HasWings or !self.HasWings) then
                        max = self.BoostSpeed;
                    else
                        max = self.ForwardSpeed;
                    end
                    if(!self.Handbraking) then
                        self.Throttle.FWD = math.Clamp(self.Throttle.FWD,min,max);
                        self.Accel.FWD = math.Approach(self.Accel.FWD,self.Throttle.FWD,self.Acceleration);
                    end

                    if(self.CanRoll) then
                        if(self.Pilot:KeyDown(IN_MOVERIGHT)) then
                            self.Roll = self.Roll + 3;
                            self.Throttle.RIGHT = self.UpSpeed / 1.5;
                        elseif(self.Pilot:KeyDown(IN_MOVELEFT)) then
                            self.Roll = self.Roll - 3;
                            self.Throttle.RIGHT = (self.UpSpeed / 1.5)*-1;
                        elseif(self.Pilot:KeyDown(IN_RELOAD)) then
                            self.Roll = 0;
                        else
                            self.Throttle.RIGHT = 0;
                        end
                    elseif(self.CanStrafe) then
                        if(self.Pilot:KeyDown(IN_MOVERIGHT)) then
                            self.Throttle.RIGHT = self.UpSpeed / 1.2;
                            self.Roll = 20;
                        elseif(self.Pilot:KeyDown(IN_MOVELEFT)) then
                            self.Throttle.RIGHT = (self.UpSpeed / 1.2)*-1;
                            self.Roll = -20;
                        else
                            self.Throttle.RIGHT = 0;
                            self.Roll = 0;
                        end
                        self.Accel.RIGHT = math.Approach(self.Accel.RIGHT,self.Throttle.RIGHT,self.Acceleration);
                    end


                    if(self.Pilot:KeyDown(IN_JUMP) and !self.Pilot:KeyDown(IN_RELOAD)) then
                        self.Throttle.UP = self.UpSpeed;
                    elseif(self.Pilot:KeyDown(IN_DUCK) and !self.Pilot:KeyDown(IN_RELOAD)) then
                        self.Throttle.UP = -self.UpSpeed;
                    else
                        self.Throttle.UP = 0;
                    end
                    self.Accel.UP = math.Approach(self.Accel.UP,self.Throttle.UP,self.Acceleration*0.9);

                end

                local velocity = self:GetVelocity();
                local aim = self.Pilot:GetAimVector();
                local ang = aim:Angle();
                local weight_roll = (phys:GetMass()/100)/1.5

                local ExtraRoll = math.Clamp(math.deg(math.asin(self:WorldToLocal(pos + aim).y)),-25-weight_roll,25+weight_roll); -- Extra-roll - When you move into curves, make the shuttle do little curves too according to aerodynamic effects
                local mul = math.Clamp((velocity:Length()/1700),0,1); -- More roll, if faster.
                local oldRoll = ang.Roll;
                ang.Roll = (ang.Roll + self.Roll - ExtraRoll*mul) % 360;
                if (ang.Roll!=ang.Roll) then ang.Roll = oldRoll; end -- fix for nan values that cause despawing/crash.

                if(self.Pilot:KeyDown(IN_JUMP) and self.Pilot:KeyDown(IN_DUCK) and !self.PreventLand) then
                    local tr = util.TraceLine({
                        start = self.LandTracePos or self:GetPos(),
                        endpos = self:GetPos()+self:GetUp()*-(self.LandDistance or 300),
                        filter = self:GetChildEntities(),
                    })

                    if(tr.HitWorld or (IsValid(tr.Entity) and tr.Entity:GetClass() == "prop_physics")) then
                        self.Land = true;
                        self.LandPos = tr.HitPos + (self.LandOffset or Vector(0,0,0));
                        self:SetNWBool("Land",self.Land);
                        if(IsValid(self.Pilot)) then
                            self.Pilot:SetNWBool("SW_Land",self.Land);
                        end
                        self:ResetThrottle();
                    end
                end

                if(self.HasLookaround) then
                    if(self.Pilot:KeyPressed(IN_SCORE) or self.Pilot:KeyReleased(IN_SCORE)) then
                        self.Pilot:SetEyeAngles(self:GetAngles());
                    end

                    if(!self.Pilot:KeyDown(IN_SCORE)) then
                        FlightPhys.angle = ang;
                    end
                else
                    FlightPhys.angle = ang;
                end

                FlightPhys.deltatime = deltatime;

                local newZ;
                if(self.AutoCorrect or Should_AlwaysCorrect) then
                    local heightTrace = util.TraceLine({
                        start = self:GetPos(),
                        endpos = self:GetPos()+Vector(0,0,-100),
                        filter = self:GetChildEntities(),
                    })
                    if(heightTrace.Hit) then
                        local nextPos = self:GetPos()+(FWD*self.Accel.FWD)+(UP*self.Accel.UP)+(RIGHT*self.Accel.RIGHT);
                        if(nextPos.z <= heightTrace.HitPos.z + 100) then
                            newZ = heightTrace.HitPos.z + 100;
                            self.Accel.FWD = math.Clamp(self.Accel.FWD,0,1000);
                        end
                    end

                    local forwardTrace = util.TraceLine({
                        start = self:GetPos(),
                        endpos = self:GetPos()+self:GetForward()*(self.ShipLength+100),
                        filter = self:GetChildEntities(),
                    })

                    if(forwardTrace.Hit) then
                        self.Accel.FWD = 0;
                    end

                end

                local fPos = pos+(FWD*self.Accel.FWD)+(UP*self.Accel.UP);
                if(self.CanStrafe) then
                    fPos = fPos+(RIGHT*self.Accel.RIGHT);
                end

                if(newZ) then
                    FlightPhys.pos = Vector(fPos.x,fPos.y,newZ);
                else
                    FlightPhys.pos = fPos;
                end

                if(!self.CriticalDamage and !self.BeingWarped) then
                    phys:ComputeShadowControl(FlightPhys);
                end
            elseif(self.TakeOff) then
                if(self.Pilot:KeyDown(IN_JUMP)) then
                    self.NewPos = self.StartPos + (self.TakeOffVector or Vector(0,0,100));
                    self.TakingOff = true;
                end
                if(self.TakingOff) then
                    FlightPhys.pos = self.NewPos;
                else
                    FlightPhys.pos = self.LandPos;
                end
                FlightPhys.angle = self:GetAngles(); --+ Vector(90 0, 0)
                FlightPhys.deltatime = deltatime;
                phys:ComputeShadowControl(FlightPhys);

                local pos = self:GetPos();
                local takeOff = 90;
                if(self.TakeOffVector) then
                    takeOff = self.TakeOffVector.z*0.9;
                end
                if(pos.z >= self.StartPos.z + takeOff) then
                    self.TakeOff = false;
                    self:SetNWBool("TakeOff",self.TakeOff);
                    if(IsValid(self.Pilot)) then
                        self.Pilot:SetNWBool("SW_TakeOff",self.TakeOff);
                    end
                    self.TakingOff = false;
                    self.NewPos = nil;
                end
                self.Accel.FWD = 0;
            elseif(self.Land) then
                if(self.Wings) then
                    self:ToggleWings();
                end
                FlightPhys.angle = self.LandAngles or Angle(0,self:GetAngles().y,0); --+ Vector(90 0, 0)
                FlightPhys.deltatime = deltatime;
                FlightPhys.pos = self.LandPos;
                phys:ComputeShadowControl(FlightPhys);
                local pos = self:GetPos();
                if(pos.z <= self.LandPos.z + 5) then
                    self.Land = false;
                    self:SetNWBool("Land",self.Land);
                    if(IsValid(self.Pilot)) then
                        self.Pilot:SetNWBool("SW_Land",self.Land);
                    end
                    self.StartPos = self.LandPos;
                    self.TakeOff = true;
                    self:SetNWBool("TakeOff",self.TakeOff);
                    if(IsValid(self.Pilot)) then
                        self.Pilot:SetNWBool("SW_TakeOff",self.TakeOff);
                    end
                end
                self.Accel.FWD = 0;
            end
            phys:Wake();
            self:SetNWInt("Speed",self.Accel.FWD);
            if(IsValid(self.Pilot)) then
                self.Pilot:SetNWInt("SW_Speed",self.Accel.FWD);
            end
        else
            if(self.ShouldStandby and (self.TakeOff or self.Docked) and self.CanStandby) then
                FlightPhys.angle = self.StandbyAngles or Angle(0,self:GetAngles().y,0);
                FlightPhys.deltatime = deltatime;
                FlightPhys.pos = self:GetPos()+UP;
                phys:ComputeShadowControl(FlightPhys);
            end
        end
	end
end
    

function SWVehStandbyPickup(p,e)
	if(IsValid(e) and e.IsSWVehicle) then
		if(e.CanStandby) then
			e.ShouldStandby = false;
		end
	end
end
hook.Add( "PhysgunPickup", "SWVehStandbyPickup", SWVehStandbyPickup )

function SWVehStandbyDrop(p,e)
	if(IsValid(e) and e.IsSWVehicle) then
		if(e.CanStandby) then
			e.ShouldStandby = true;
		end
	end
end
hook.Add("PhysgunDrop", "SWVehStandbyDrop", SWVehStandbyDrop);

function ENT:PhysicsCollide(cdat, phys)

	if(self.LastCollide < CurTime() and !self.Land and !self.TakeOff and Should_Collisions) then
		local mass = (cdat.HitEntity:GetClass() == "worldspawn") and 1000 or cdat.HitObject:GetMass() --if it's worldspawn use 1000 (worldspawns physobj only has mass 1), else normal mass
		
		local s = cdat.TheirOldVelocity:Length();
		if(s < 0) then
			s = s * -1;
		elseif(s == 0) then
			s = 1;
		end
		local dmg = (cdat.OurOldVelocity:Length()*s*math.Clamp(mass, 0, 1000))/3500;
		
		dmg = dmg * self.CollisionDamageMulti;
		
		self.Accel.FWD = math.Clamp(self.Accel.FWD - dmg,0, self.Accel.FWD);
		self.Throttle.FWD = math.Clamp(self.Throttle.FWD - dmg,0, self.Throttle.FWD);
		self:TakeDamage(dmg)
		self.LastCollide = CurTime() + self.CollideTimer;
		
	end
end
 
function ENT:Rotorwash(b)

	if(b) then
		local e = ents.Create("env_rotorwash_emitter");
		e:SetPos(self:GetPos());
		e:SetParent(self);
		e:Spawn();
		e:Activate();
		self.RotorWash = e;
	else
		if(IsValid(self.RotorWash)) then
			self.RotorWash:Remove();
		end
	end
end

function ENT:Bang()

	if(self.Done) then return end;

	self:EmitSound(Sound("Explosion.mp3"),100,math.random(80,100));
	local fx = EffectData();
		fx:SetOrigin(self:GetPos());
		fx:SetMagnitude(math.Round(self.Mass/10000))
	util.Effect("SWExplosion",fx,true,true);
	

	if(self.Inflight) then
		self:Exit(true); --Let the player out...
	end
        
    if(self.Seats) then
        for k,v in pairs(self.Seats) do
            local p = v:GetPassenger(1);
            if(IsValid(p)) then
                p:ExitVehicle(v);
                p:Kill();
            end
        end
    end

	for k,v in pairs(ents.FindInSphere(self:GetPos(),300)) do
		if(IsValid(v) and v != self) then
			if(v:IsPlayer() and v:Alive()) then
                if(!v:HasGodMode()) then
				    v:Kill();
                end
			else
				if((v.IsSWVehicle and !v.Done) or (!v.IsSWVehicle and v:GetParent() != self)) then
					local dist = (self:GetPos() - v:GetPos()):Length();
					v:TakeDamage(math.Clamp(500 - dist,100,500));
				end
			end
		end
	end
	
	self.Done = true;
	self:SetColor(Color(0,0,0,255));
	self:Ignite(10,50);
	
	timer.Simple(10, function()
		if(IsValid(self)) then
			self:Remove();
		end
	end);
end

end

function ENT:GetChildEntities()
	local filter = {};
	
	local i = 1;
	for k,v in pairs(ents.GetAll()) do
		if(v:GetParent() == self) then
			filter[i] = v;
			i = i+1;
		end
	end
	filter[i] = self;
	
	local p;
	if CLIENT then
		p = LocalPlayer();
	elseif SERVER then
		if(IsValid(self.Pilot)) then
			p = self.Pilot;
		end
	end
	if(IsValid(p)) then
		filter[i+1] = p;
	end
	return filter;
end

if CLIENT then

	function ENT:Draw() 
		self:DrawModel()
	end
	
	local ShipName = "";
	local ShouldFPV;
	function ENT:Initialize()	
		ShipName = self.Vehicle;
		self.FXEmitter = ParticleEmitter(self:GetPos())
		self.SoundsOn = {}
		if (self.Sounds and self.Sounds.Engine) then
			self.EngineSound = self.EngineSound or CreateSound(self.Entity,self.Sounds.Engine);
		end
		FPV = false;
        self.HasLookaround = self:GetNWBool("HasLookaround");
		surface.CreateFont( "HUD_Health", {
			font = "Arial",
			size = ScrH()/60,
			weight = 1000,
			blursize = 0,
			scanlines = 0,
			antialias = false,
			underline = false,
			italic = false,
			strikeout = false,
			symbol = true,
			rotary = false,
			shadow = false,
			additive = true,
			//outline = true,
			outline = false,
		} )
		
		surface.CreateFont( "HUD_Altimeter", {
			font = "Arial",
			size = ScrH()/60,
			weight = 1000,
			blursize = 0,
			scanlines = 0,
			antialias = false,
			underline = false,
			italic = false,
			strikeout = false,
			symbol = false,
			rotary = false,
			shadow = true,
			additive = false,
			outline = false,
		} )
        
		surface.CreateFont( "HUD_Transponder", {
			font = "Arial",
			size = ScrH()/65,
			weight = 1000,
			blursize = 0,
			scanlines = 0,
			antialias = false,
			underline = false,
			italic = false,
			strikeout = false,
			symbol = false,
			rotary = false,
			shadow = true,
			additive = false,
			outline = false,
		} )
		ShouldFPV = self.CanFPV;
		if(FPV and !self.IsFPV) then	
			FPV = false;
		end
		
		LocalPlayer().SW_ViewDistance = LocalPlayer().SW_ViewDistance or 0;
		self.Filter = self:GetChildEntities();
	end

	
	local Health = 1000;
	local Overheat = 0;
	local Overheated = false;
	local FPV = false;
	local Critical = false;
	local ShouldLock = true;
	local OverheatAmount = 50;
	local Wings = false;
	local Land = false;
	local TakeOff = false;
	ENT.NextView = CurTime();
	ENT.NextHide = CurTime();
	function ENT:Think()
	
		local p = LocalPlayer();
		local Flying = self:GetNWBool("Flying".. self.Vehicle);
		local IsFlying = p:GetNWBool("Flying"..self.Vehicle);
		//local Wings = self:GetNWBool("Wings");

		
		local IsDriver = p:GetNWEntity(self.Vehicle) == self.Entity;
		if(Flying) then
			local avatar = self:GetNWEntity("PilotAvatar");
			if(IsValid(avatar))  then
                if(IsFlying and (SW_GetFPV() or self:GetFPV()) and IsDriver) then
                    avatar:SetNoDraw(true);
                else
                    avatar:DrawModel();
                    avatar:SetNoDraw(false);
                end
				local count = table.Count(self.Filter);
				if(!IsValid(self.Filter[count+1])) then
					self.Filter[count+1] = avatar;
				end
			end
			p.IsFlying = true;
			-- Normal behaviour for Pilot or people who stand outside
			self:StartClientsideSound("Engine");
			--#########  Now add Pitch etc
			local velo = self.Entity:GetVelocity();
			local pitch = self.Entity:GetVelocity():Length();
			local doppler = 0;
			-- For the Doppler-Effect!
			if(not IsDriver) then
				-- Is the vehicle flying towards the player or away from him?
				local dir = (p:GetPos() - self.Entity:GetPos());
				doppler = velo:Dot(dir)/(150*dir:Length());
			end
			if(self.SoundsOn.Engine) then
				self.EngineSound:ChangePitch(math.Clamp(60 + pitch/25,75,100) + doppler,0);
			end
			if(self.CanFPV) then
				if(p:KeyDown(IN_WALK)) then
					if(self.NextView < CurTime()) then
						if(self.IsFPV) then
							FPV = false;
							self.IsFPV = false;
						else
							FPV = true;
							self.IsFPV = true;
						end
						
						self.NextView = CurTime() + 1;
					end
				end
			end
			
			if(ShouldFPV != self.CanFPV) then
				ShouldFPV = self.CanFPV;
			end

			
			Overheat = p:GetNWInt("SW_Overheat") or self:GetNWInt("Overheat");
			Overheated = p:GetNWBool("SW_Overheated") or self:GetNWBool("Overheated");
			Critical = p:GetNWBool("SW_Critical") or self:GetNWBool("Critical");
			ShouldLock = p:GetNWBool("SW_ShouldLock") or self:GetNWBool("ShouldLock");
			OverheatAmount = self:GetNWInt("OverheatAmount");
			
			if(!p.SW_HideHud) then
				Health = p:GetNWInt("SW_Health") or self:GetNWInt("Health");
				Speed = p:GetNWInt("SW_Speed") or self:GetNWInt("Speed");
				MaxSpeed = p:GetNWInt("SW_MaxSpeed") or self:GetNWInt("MaxSpeed");
				Wings = p:GetNWBool("SW_Wings") or self:GetNWBool("Wings");
				LandDistance = self:GetNWInt("LandDistance");
                self.Lightspeed = self:GetNWInt("Lightspeed");
			end
			
			if(input.IsMouseDown(MOUSE_MIDDLE)) then
				p.SW_ViewDistance = 0;
			elseif(input.IsKeyDown(KEY_H) and self.NextHide < CurTime() and !p.SWVehicles_IsChatting) then
				if(p.SW_HideHud) then
					p.SW_HideHud = false;
				else
					p.SW_HideHud = true;
				end
				self.NextHide = CurTime() + 1;
			end
			Land = p:GetNWBool("SW_Land") or self:GetNWBool("Land");
			TakeOff = p:GetNWBool("SW_TakeOff") or self:GetNWBool("TakeOff");
			
			if(self.EnginePos and self.EnginePos[1]) then
				if(Health <= self.StartHealth * 0.4) then
					local pos = self.EnginePos[1];
					self:Smoke(true,pos);
				end
			end
		else
			self:StopClientsideSound("Engine");
			p.IsFlying = false;
		end
		

		self.Allegiance = self:GetNWString("Allegiance");
	end
	
	function ENT:Smoke(b,pos)

		local p = LocalPlayer();
		local v = p:GetNetworkedEntity(self.Vehicle,NULL);

		if(b) and (IsValid(v) and v==self) then
			local fwd = self:GetForward()
			local vel = self:GetVelocity()
			local roll = math.Rand(-90,90)

			local particle = self.FXEmitter:Add("effects/blood2",pos)
			particle:SetVelocity(vel - 500*fwd)
			particle:SetDieTime(0.75)
			particle:SetStartAlpha(200)
			particle:SetEndAlpha(0)
			particle:SetStartSize(14)
			particle:SetEndSize(20)
			particle:SetColor(40,40,40)
			particle:SetRoll(roll)

			--self.Emitter:Finish()
		end
	end
	
	
	function ENT:EngineEffects(sprite,color)
	
		local normal = (self:GetForward() * -1):GetNormalized()
		local roll = math.Rand(-90,90)
		local id = self:EntIndex();

		for k,v in pairs(self.EnginePos) do
			local red = self.FXEmitter:Add(sprite,v)
			red:SetVelocity(normal)
			red:SetDieTime(FrameTime()*1.25)
			red:SetStartAlpha(color.a)
			red:SetEndAlpha(color.a)
			red:SetStartSize(14)
			red:SetEndSize(10)
			red:SetRoll(roll)
			red:SetColor(color.r,color.g,color.b)
		
			local dynlight = DynamicLight((id + 4096) * k);
			dynlight.Pos = v;
			dynlight.Brightness = 5;
			dynlight.Size = 200;
			dynlight.Decay = 1024;
			dynlight.R = color.r;
			dynlight.G = color.g;
			dynlight.B = color.b;
			dynlight.DieTime = CurTime()+1;
		end
	end
	
	hook.Add("StartChat","SW_StartChat",function()
		LocalPlayer().SWVehicles_IsChatting = true;	
	end)
	
	hook.Add("FinishChat","SW_FinishChat",function()
		LocalPlayer().SWVehicles_IsChatting = false;	
	end)
	
	hook.Add("PlayerBindPress","SWMouseWheel", function( p, bind, pressed )
		
		if(p.IsFlying) then
			if(bind == "invnext") then
				p.SW_ViewDistance = p.SW_ViewDistance + 5;
			elseif(bind == "invprev") then
				p.SW_ViewDistance = p.SW_ViewDistance - 5;
			end
			p.SW_ViewDistance = math.Clamp(p.SW_ViewDistance,-500,500)
		end
		
	end);
	

	function ENT:OnRemove()	
		if (self.EngineSound) then
			self.EngineSound:Stop();
		end
		FPV = false;
		if(IsValid(self.FXEmitter)) then
			self.FXEmitter:Finish();
		end
	end
	
	function ENT:StartClientsideSound(mode)
		if(not self.SoundsOn[mode]) then
			if(mode == "Engine" and self.EngineSound) then
				self.EngineSound:Stop();
				self.EngineSound:SetSoundLevel(100);
				self.EngineSound:PlayEx(100,100);
			end
			self.SoundsOn[mode] = true;
		end
	end

	--################# Stops a sound clientside @aVoN
	function ENT:StopClientsideSound(mode)
		if(self.SoundsOn[mode]) then
			if(mode == "Engine" and self.EngineSound) then
				self.EngineSound:FadeOut(2);
			end
			self.SoundsOn[mode] = nil;
		end
	end

	function SWVehicleView(self,dist,udist,fpv_pos,lookaround)
		local p = LocalPlayer();
		local pos,face;
		local View = {};
		if(IsValid(self)) then
			if(self.IsFPV and ShouldFPV) then
				pos = fpv_pos;
				face = self:GetAngles();
				if(lookaround and p:KeyPressed(IN_SCORE)) then
					p:SetEyeAngles(Angle(0,0,0))
				end
				if(lookaround and p:KeyDown(IN_SCORE) and !p:KeyPressed(IN_SCORE)) then
					local eAngles = p:EyeAngles();
					local newAng = self:GetAngles()+eAngles;
					face = Angle(newAng.p,math.Clamp(newAng.y,self:GetAngles().y-90,self:GetAngles().y+90),newAng.r);
				end
			else
                if(self.Lightspeed != 2) then
                    local aim = LocalPlayer():GetAimVector();
                    local tpos = self:GetPos()+self:GetUp()*udist+aim:GetNormal()*-(dist+p.SW_ViewDistance);
                    local tr = util.TraceLine({
                        start = self:GetPos(),
                        endpos = tpos,
                        filter = self.Filter,
                    })
                    pos = tr.HitPos or tpos;   
                    face = ((self:GetPos() + Vector(0,0,100))- pos):Angle();
                    self._LastViewPos = pos;
                    self._LastViewAng = face;
                else
                    pos = self._LastViewPos;
                    face = self._LastViewAng;
                end
                
			end
			View.origin = pos;
			View.angles = face;
			return View;
		end
		
	end
    
	
	hook.Add("CalcView", "SWVehicleView", function(p)
        local View = {};
		local Piloting = p:GetViewEntity() != p and p:GetViewEntity().IsSWVehicle;
        local IsPassenger  = IsValid(p:GetVehicle()) and IsValid(p:GetVehicle():GetParent()) and p:GetVehicle():GetParent().IsSWVehicle;
		local pos, face, self;		
		if(Piloting) then
            self = p:GetViewEntity();
			if(IsValid(self) and !self.HasCustomCalcView) then				
				local pos = self:LocalToWorld(self.FPVPos or Vector(0,0,0));
				View = SWVehicleView(self,self.ViewDistance or 800,self.ViewHeight or 250,pos,self:GetNWBool("HasLookaround"))
				return View;
			end
		elseif(IsPassenger) then
			self = p:GetVehicle():GetParent();
            local v = p:GetVehicle();
            local NoFirstPerson = v:GetNWBool("NoFirstPerson");
			if(IsValid(v) and IsValid(self) and !self.HasCustomCalcView) then
				if(v:GetThirdPersonMode() or NoFirstPerson) then
					View = SWVehicleView(self,self.ViewDistance or 800,self.ViewHeight or 250)
					return View;
				end
			end
		end
	end)
    
    hook.Add( "ShouldDrawLocalPlayer", "SWVehiclesDrawPlayerModel", function( p )
		local IsPassenger  = IsValid(p:GetVehicle()) and IsValid(p:GetVehicle():GetParent()) and p:GetVehicle():GetParent().IsSWVehicle;
		if(IsPassenger) then
            local seat = p:GetVehicle();
			if(IsValid(seat)) then
				if(seat:GetThirdPersonMode()) then
					return true;
				end
			end
		end
	end);
    
    hook.Add("ScoreboardShow","SWVehicleLookaroundScoreDisable", function()
		local p = LocalPlayer();	
		local Piloting = p:GetViewEntity() != p and p:GetViewEntity().IsSWVehicle;
		if(Piloting and p:GetViewEntity():GetNWBool("HasLookaround")) then
			return false;
		end
	end);
	
	function SW_WeaponReticles(self)
	
		local tr = util.TraceLine( {
			start = self:GetPos(),
			endpos = self:GetPos() + self:GetForward()*10000,
			filter = {self},
		} )

		surface.SetTextColor( 255, 255, 255, 255 );
		
		local vpos = tr.HitPos;
		local material = "hud/reticle.png"
		surface.SetMaterial( Material( material, "noclamp" ) )
		if(ShouldLock) then
			local Lock = SW_ReticleLock(self);
			if(Lock) then 
				vpos = Lock
				material = "hud/reticle_lock.png"
				
			end;
		end

		local x,y = SW_XYIn3D(vpos);
		
					
		//surface.SetTextPos( x, y );
		//surface.DrawText( "+" );
		local w = ScrW()/100*2;
		local h = w;
		surface.SetDrawColor( color_white )
		surface.SetMaterial( Material( material, "noclamp" ) )
		surface.DrawTexturedRectUV( x - w/2 , y - h/2, w, h, 0, 0, 1, 1 )
	end
	
	function SW_BlastIcon(self,delay)

		local time = self:GetNWInt("FireBlast");
		if(time - CurTime() > 0) then
			surface.SetDrawColor( color_white )
			if(!delay) then
				delay = 3;
			end
			
			local w = ScrW()/100*3.5;
			local h = ScrH()/100*1.75;
			//surface.SetDrawColor(color_white);
			local tr = util.TraceLine({
				start = self:GetPos(),
				endpos = self:GetPos() + self:GetForward()*10000,
				filter = {self},
			})

			surface.SetTextColor( 255, 255, 255, 255 );
			
			local vpos = tr.HitPos;
			if(ShouldLock) then
				local Lock = SW_ReticleLock(self);
				if(Lock) then 
					vpos = Lock				
				end;
			end
			local x,y = SW_XYIn3D(vpos);

			local per = (time-CurTime())/delay;
			
			surface.SetMaterial( Material( "hud/missile_outline.png", "noclamp" ) )
			surface.DrawTexturedRectUV( x - w/2, y - ScrW()/100*2, w, h, 0, 0, 1, 1 )
			
			surface.SetMaterial( Material( "hud/missile_icon.png", "noclamp" ) )
			surface.DrawTexturedRectUV( x - w/2, y - ScrW()/100*2, w*per, h, 0, 0, per, 1 )
		end
	
	end
	
	function SW_ReticleLock(self)
		if(!ShouldLock) then return false end;
		local bounds1,bounds2 = self:GetModelBounds();
		for l,w in pairs(ents.FindInBox(self:LocalToWorld(bounds1),self:LocalToWorld(bounds2)+self:GetForward()*10000)) do
			if(w.IsSWVehicle and !w.DontLock and w != self and w:GetNWString("Allegiance") != self.Allegiance) then
				tr = util.TraceLine({
					start = self:GetPos(),
					endpos = w:GetPos(),
					filter = self,
				})
				if(!tr.HitWorld) then
					local vpos = w:GetPos()+w:GetUp()*(w:GetModelRadius()/3);
					return vpos;
					
				end						
			end
		end
		return false;
	end
	
	function SW_HUD_DrawHull(StartHealth)
	
		if(LocalPlayer().SW_HideHud) then return end;
		
		surface.SetFont("HUD_Health");
		local w = ScrW()/100*20;
		local h = w / 4;
		
		local x = ScrW() - w - w/8;
		local y = ScrH() / 4*3.4;
		
		local per = ((Health/StartHealth)*100)/100;

		surface.SetDrawColor( color_white )
		surface.SetMaterial( Material( "hud/hull/hp_frame_under.png", "noclamp" ) )
		
		surface.DrawTexturedRectUV( x, y, w, h, 0, 0, 1, 1 )
		
		if(Critical) then
			if(Health > StartHealth * 0.1) then
				surface.SetDrawColor(Color(50,120,255,255));
			else
				surface.SetDrawColor(Color(255,35,35,255));
			end
		end
		
		local barX = x + w * 0.02832;
		local barY = y + h * 0.27343;
		local barW = w * 0.90625;
		local barH = h * 0.4;
		surface.SetMaterial( Material( "hud/hull/hp_bar.png", "noclamp" ) )
		surface.DrawTexturedRectUV( barX, barY, barW*per, barH, 0, 0, per, 1 )
		
		surface.SetMaterial( Material( "hud/hull/hp_frame_over.png", "noclamp" ) )
		surface.SetDrawColor( color_white )
		surface.DrawTexturedRectUV( x, y, w, h, 0, 0, 1, 1 )
		
		health = math.Round(Health/StartHealth*100);
		health = health .. "%";
		local tW, tH = surface.GetTextSize(health);
		

		surface.SetTextColor(Color(255,255,255,255));
		x = x + w * 0.35 - tW/2;
		y = y - tH / 2 + h * 0.06
		
		surface.SetTextPos(x,y + tH/2);
		surface.DrawText(health)
        
	end
	
	function SW_HUD_DrawSpeedometer()
		
		if(LocalPlayer().SW_HideHud) then return end;
		
		local n = Speed;
		local c = color_white;
		if(n < 0) then
			c = Color(255,50,50,255);
			n = n * -1;
		end
		
		
		local w = ScrW()/100*20;
		local h = w / 4;
		
		local x = ScrW() - w - w/8;
		local y = ScrH() / 4*3.4 + h/2*1.5;
		
		local per = math.Clamp(((n/MaxSpeed)*100)/100,0,1);
		
		surface.SetDrawColor(color_white)
		surface.SetMaterial( Material( "hud/speedo/speed_frame_under.png", "noclamp" ) )
		surface.DrawTexturedRectUV( x, y, w, h, 0, 0, 1, 1 )
		
		local barX = x + w * 0.01953125;
		local barY = y + h * 0.234375;
		local barW = w * 0.9541015625;
		local barH = h * 0.53515625;
		surface.SetDrawColor(c)
		surface.SetMaterial( Material( "hud/speedo/speed_bar.png", "noclamp" ) )
		surface.DrawTexturedRectUV( barX, barY, barW*per, barH, 0, 0, per, 1 )
		
		surface.SetDrawColor(color_white)
		surface.SetMaterial( Material( "hud/speedo/speed_frame_over.png", "noclamp" ) )
		surface.DrawTexturedRectUV( x, y, w, h, 0, 0, 1, 1 )
	end

	function SW_HUD_DrawOverheating(self)
		
		//surface.SetFont("HUD_Overheat");
		if(Overheated) then
			surface.SetDrawColor(255,0,0,255);
		else
			if(Overheat > 0 and Overheat <= 16) then
				surface.SetDrawColor(128,255,0,255);
			elseif(Overheat > 16 and Overheat <= 32) then
				surface.SetDrawColor(255,255,0,255);
			else
				surface.SetDrawColor(255,128,0,255);
			end
		end

		local w = ScrW()/100*3.5;
		local h = ScrH()/100*0.5;
		//surface.SetDrawColor(color_white);
		local tr = util.TraceLine( {
			start = self:GetPos(),
			endpos = self:GetPos() + self:GetForward()*10000,
			filter = {self},
		} )

		//surface.SetTextColor( 255, 255, 255, 255 );
		
		local vpos = tr.HitPos;
		if(ShouldLock) then
			local Lock = SW_ReticleLock(self);
			if(Lock) then 
				vpos = Lock				
			end;
		end
		local x,y = SW_XYIn3D(vpos);

		
		local o = (Overheat/50)*100;
		local per = o/100;
		
		//surface.SetMaterial( Material( "hud/overheat_bar.png", "noclamp" ) )
		//surface.DrawTexturedRectUV( x - w/2, y + ScrW()/100*2 - h/2, w, h, 0, 0, per, 1 )
		w = w*per;
		surface.DrawRect(x - w/2,y+ScrW()/100*1.5,w,h)
		
	end
	
	local Glass = surface.GetTextureID("models/props_c17/frostedglass_01a_dx60");
	function SW_HUD_FPV(HUD)
		surface.SetTexture(Glass);
		surface.SetDrawColor(255,255,255,50);
		surface.DrawTexturedRect(0,0,ScrW()*10,ScrH());
		
		surface.SetTexture(HUD) -- Print the texture to the screen
		surface.SetDrawColor(255,255,255,255) -- Colour of the HUD
		surface.DrawTexturedRect(0,0,ScrW(),ScrH()) -- Position, Size
	
	end
	
	local compassBack = surface.GetTextureID("hud/sw_shipcompass_BG");
	local compassDisk = surface.GetTextureID("hud/sw_shipcompass_disk");
	local locator = surface.GetTextureID("hud/sw_shipcompass_locator");
	function SW_HUD_Compass(self,fpvX,fpvY)
	
		if(LocalPlayer().SW_HideHud) then return end;
	
		local p = LocalPlayer();
	
		local size = ScrW()/10;

		local x,y;
		if(self:GetFPV()) then
			x = ScrW()/2;
			y = ScrH()/4*3.1;
			if(fpvX) then
				x = fpvX;
			end
			if(fpvY) then
				y = fpvY;
			end
		else
			x = size*0.65;
			y = x;
		end
		
		surface.SetTexture(compassBack);
		surface.SetDrawColor(255,255,255,255);
		surface.DrawTexturedRectRotated( x,y, size, size, 0);
		
		local rotate = (self:GetAngles().y - 90)*-1;

		local al = SW_LightOrDark(self.Allegiance);
		local maxDist = 5000;
		local ships = ents.FindInSphere(self:GetPos(),maxDist);
		for k,v in pairs(ships) do
			if(IsValid(v) and v.IsSWVehicle and v != self and !v.IsCapitalShip) then
			
				local alleg = SW_LightOrDark(v.Allegiance);
				if(al != alleg) then
					
					local dist = (self:GetPos() - v:GetPos()):Length() / maxDist;
					local a = 1 - dist;
					
					surface.SetDrawColor(255,255,255,255*a) -- Colour of the HUD
					local r = (((self:GetPos() - v:GetPos()):Angle().y)-90) + rotate - 180;
					surface.SetTexture(locator) -- Print the texture to the screen
					surface.DrawTexturedRectRotated( x,y, size, size, r)
				end
			end
		end
		
		surface.SetDrawColor(255,255,255,255) -- Colour of the HUD
		surface.SetTexture(compassDisk) -- Print the texture to the screen
		surface.DrawTexturedRectRotated( x,y, size, size, rotate)
		
		
		// Altimeter
		local max_ld = 500;
		local ld = 300;
		if(LandDistance > 0) then
			ld = LandDistance;
		end	

		if(ld > 500) then
			max_ld = 1000;
		elseif(ld > 1000) then
			max_ld = 1500;
		end
		
		local tr = util.TraceLine({
			start = self:GetPos(),
			endpos = self:GetPos()+Vector(0,0,-max_ld*2),
			filter = {self},
		});
		
		local a = p.SW_Alt_Alpha or 255;
		tMod = "";
		if(tr.Hit and tr.HitWorld) then
			
			p.SW_Alt_Alpha = math.Clamp(a + 4,130,255);
		else
			tMod = "+"
			p.SW_Alt_Alpha = math.Clamp(a - 4,130,255);
		end
		surface.SetTextColor(Color(255,255,255,a));
		surface.SetDrawColor(Color(255,255,255,a));
		local dist = math.Clamp(math.Round(self:GetPos().z - tr.HitPos.z),0,max_ld*2);
		local t = dist;
		
		local w = size;
		local h = size / 2;
		
		x = x-w/2
		y = y+size/2*1.1;	

		
		surface.SetFont("HUD_Altimeter");

		surface.SetMaterial( Material( "hud/altimeter/altimeter_frame.png", "noclamp" ) )
		surface.DrawTexturedRectUV( x, y, w, h, 0, 0, 1, 1 )
		
		surface.SetTextPos(x+w*0.45,y+h*0.125);
		if(TakeOff) then
			t = "N/A";
		end
		surface.DrawText(t .. tMod);
		
					
		if(dist <= ld) then
			surface.SetMaterial( Material( "hud/altimeter/altimeter_light1.png", "noclamp" ) )
			surface.DrawTexturedRectUV( x, y, w, h, 0, 0, 1, 1 )		
			if(TakeOff) then
				surface.SetMaterial( Material( "hud/altimeter/altimeter_light2.png", "noclamp" ) )
				surface.DrawTexturedRectUV( x, y, w, h, 0, 0, 1, 1 )				
			end
		end
        
        //Transponder Code
        local Transponder = self:GetNWString("TransponderCode");
        surface.SetMaterial( Material( "hud/clearance_code.png", "noclamp" ) )
        w = size;
        h = size / 3.08;
        x = ScrW() - w/2 - size * 0.65;
        y = ScrW() / 100;
        surface.SetFont("HUD_Transponder")
        surface.SetDrawColor(255,255,255,255)
        surface.DrawTexturedRectUV( x, y, w, h, 0, 0, 1, 1 )	
        surface.SetTextPos(x+w*0.32,y+h*0.45);
        surface.DrawText(Transponder);
        
        if(self.Lightspeed == 2) then
            DrawMotionBlur( 0.4, 20, 0.01 );
        end
	end
	
	function SW_LightOrDark(allegiance)
	
		if(allegiance == "CIS" or allegiance == "Empire" or allegiance == "First Order" or allegiance == "Mandalorian") then
			return "Dark";
		elseif(allegiance == "Republic" or allegiance == "Rebels") then
			return "Light";
		end
		return "Neutral";
	end
	
	function SW_XYIn3D(pos)
		local screen = pos:ToScreen();
		local x,y;
		for k,v in pairs(screen) do
			if k=="x" then
				x = v;
			elseif k=="y" then
				y = v;
			end
		end
		return x,y;
	end
	
	function SW_HUD_WingsIndicator(class)
		if(LocalPlayer().SW_HideHud) then return end;
		local path = "hud/wings/wings_" .. class .. "_up.png";
		if(Wings) then
			path = "hud/wings/wings_" .. class .. "_down.png";
		end
		
		local w = ScrW()/10;
		local h = w;
		
		local oldW = ScrW()/100*20;
		local oldH = oldW / 4;
		
		local x = ScrW() - oldW - oldW/6 - w;
		local y = ScrH() / 4*3.4	
		
		surface.SetDrawColor(255,255,255,255) -- Colour of the HUD
		surface.SetMaterial( Material( "hud/wings/wings_frame.png", "noclamp" ) )
		surface.DrawTexturedRectUV( x, y, w, h, 0, 0, 1, 1)
		
		surface.SetDrawColor(255,255,255,255) -- Colour of the HUD
		surface.SetMaterial( Material( path, "noclamp" ) )
		surface.DrawTexturedRectUV( x, y, w, h, 0, 0, 1, 1)
	end
    


	
	function ENT:GetFPV()
		return self.IsFPV;
	end
	
	function SW_GetFPV()
		return FPV;
	end
end

--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/entities/fire_spawned2/shared.lua:
return gluapack()()
--PATH lua/entities/flame.lua:

AddCSLuaFile()

ENT.Type 			= "anim"
ENT.Base 			= "base_anim"
ENT.PrintName		= "Flame"
ENT.Author			= "FiLzO"
ENT.Purpose			= "Can you feel Air Exchange?"
ENT.Category		= "Combine Units +PLUS+"

ENT.Spawnable		= false
ENT.AdminOnly		= false

local COLLISION_RADIUS = 3
local LIFE_TIME = 0.35
local sndEngulf = Sound( "Fire.Engulf" )

if SERVER then

function ENT:Initialize()	
	self:SetModel( "models/Combine_Helicopter/helicopter_bomb01.mdl" )
	self:SetNoDraw( true )
	self:DrawShadow( false )
	self:PhysicsInitSphere( COLLISION_RADIUS )
	self:SetCollisionBounds( Vector( -COLLISION_RADIUS, -COLLISION_RADIUS, -COLLISION_RADIUS ), Vector( COLLISION_RADIUS, COLLISION_RADIUS, COLLISION_RADIUS ) )
	self:SetNotSolid( true )
	self:SetTrigger( true )
	self:SetMoveType( MOVETYPE_FLY )
	self:SetMoveCollide( MOVECOLLIDE_FLY_SLIDE )
	self.Owner = self:GetOwner() or self
	if not self.Owner:IsValid() then self.Owner = self end
	
	self.Weapon = self.Owner:GetActiveWeapon()
	if not self.Weapon:IsValid() then self.Weapon = self end
	self.DamageModifier = 1
	self.BaseDamage = 1
	self.NextTouch = CurTime()
	self:Fire( "kill", "", LIFE_TIME )
	self.KillTime = CurTime() + LIFE_TIME
	
end


function ENT:SetDamage( mindmg, maxdmg )

	self.DamageModifier = ( maxdmg - mindmg ) / LIFE_TIME
	self.BaseDamage = mindmg

end


function ENT:Touch( ent )

	-- ent == self.Owner or ent:IsWorld() then return end
	
	--if ent:GetClass()=="cup_fuel_tank" and ent:GetClass()=="npc_stalker" or ent:GetClass()=="npc_combine_s" or ent:GetClass()=="npc_metropolice" or ent:GetClass()=="npc_cscanner" or ent:GetClass()=="npc_manhack" or ent:GetClass()=="npc_strider" or ent:GetClass()=="npc_hunter" or ent:GetClass()=="npc_rollermine" or ent:GetClass()=="npc_clawscanner" or ent:GetClass()=="npc_turret_floor" or ent:GetClass()=="npc_turret_ceiling" or ent:GetClass()=="npc_combine_camera" or ent:GetClass()=="npc_combinedropship" or ent:GetClass()=="npc_combinegunship" or ent:GetClass()=="npc_helicopter" or ent:GetClass()=="npc_turret_ground" or ent:GetClass()=="npc_apcdriver" then return end
	
	if ent.wearsuit == true then return end
	
	if self.NextTouch > CurTime() then return end
	self.NextTouch = CurTime() + 0.05
	
	-- Die under water
	--if self:WaterLevel() >= 1 then
	--	self:Remove()
	--	return
	--end
	
	-- Stop moving since we hit something
	self:SetMoveType( MOVETYPE_NONE )

	-- Make sure the owner and weapon are still around, otherwise we would error out
	if not self.Owner:IsValid() then self.Owner = self end
	if not self.Weapon:IsValid() then self.Weapon = self end
	
	-- Apply damage based on how long the projectile has been alive
	local dmg = ( self.KillTime - CurTime() ) * self.DamageModifier + self.BaseDamage
	if dmg < 0 then dmg = 0 end
	ent:TakeDamage( dmg, self.Owner, self.Weapon )
	
	-- Play that cool igniting sound if this entity is being ignited for the first time
	if not ent:IsOnFire() then
		ent:EmitSound( sndEngulf )
	end
	
	-- Ignite the entity
	--if ent:IsPlayer() then
		ent:Ignite( math.random( 5, 6 ), 0 ) -- Go easier on players
	--else
	--	ent:Fire( "IgniteLifeTime", math.random( 10, 12 ), 0 ) -- garry done broke ent:Ignite(), so we have to use this
	--end

end

end

--PATH lua/entities/force_shield.lua:
AddCSLuaFile()

util.PrecacheModel( "models/ovr_load/force_shield.mdl" )

if CLIENT then
surface.CreateFont("OvR_Load_HUD_Holo_1" , {
    font = "Kenney Future Square", --name of font
    size = 60,
    weight = 500,
    blursize = 2;
    scanlines = 2,
    antialias = true,
    underline = false,
    italic = false,
    strikeout = false,
    symbol = false,
    rotary = false,
    shadow = true,
    additive = true,
    outline = false
})
end

ENT.Type = "anim"
ENT.Base = "base_gmodentity"
ENT.Author = "Trench"
ENT.Purpose = "deployable force shield for blocking income small arms fire- has hp and then is destroyed"
ENT.RenderGroup = RENDERGROUP_TRANSLUCENT
ENT.spawnTime = 0
ENT.totalLifeTime = 30
ENT.hp = 800
ENT.mmRHAe = 10000 --Controls penetration resistance for ArcCW weapons, high number means no bullets from this pack will penetrate

local forceShieldImpactSounds = {
    [1] = "weapons/physcannon/superphys_small_zap1.wav",
    [2] = "weapons/physcannon/superphys_small_zap2.wav",
    [3] = "weapons/physcannon/superphys_small_zap3.wav",
    [4] = "weapons/physcannon/superphys_small_zap4.wav"
}

local HPColorValues = {
    [40] = Color(0, 80, 255),
    [39] = Color(0, 65, 255),
    [38] = Color(0, 50, 255),
    [37] = Color(0, 35, 255),
    [36] = Color(0, 20, 255),
    [35] = Color(0, 5, 255),
    [34] = Color(10, 0, 255),
    [33] = Color(25, 3, 255),
    [32] = Color(40, 0, 255),
    [31] = Color(55, 0, 255),
    [30] = Color(70, 0, 255),
    [29] = Color(85, 0, 255),
    [28] = Color(100, 0, 255),
    [27] = Color(115, 0, 255),
    [26] = Color(130, 0, 255),
    [25] = Color(145, 0, 255),
    [24] = Color(160, 0, 255),
    [23] = Color(175, 0, 255),
    [22] = Color(190, 0, 255),
    [21] = Color(205, 0, 255),
    [20] = Color(220, 0, 255),
    [19] = Color(235, 0, 255),
    [18] = Color(250, 0, 255),
    [17] = Color(255, 0, 245),
    [16] = Color(255, 0, 230),
    [15] = Color(255, 0, 215),
    [14] = Color(255, 0, 200),
    [13] = Color(255, 0, 185),
    [12] = Color(255, 0, 170),
    [11] = Color(255, 0, 155),
    [10] = Color(255, 0, 140),
    [9]  = Color(255, 0, 125),
    [8]  = Color(255, 0, 110),
    [7]  = Color(255, 0, 95),
    [6]  = Color(255, 0, 80),
    [5]  = Color(255, 0, 65),
    [4]  = Color(255, 0, 50),
    [3]  = Color(255, 0, 35),
    [2]  = Color(255, 0, 20),
    [1]  = Color(255, 0, 5),
    [0]  = Color(255, 0, 0),
}

PrecacheParticleSystem( "vortigaunt_hand_glow" )
util.PrecacheSound("ambient/machines/combine_shield_touch_loop1.wav")
util.PrecacheSound("ambient/levels/labs/electric_explosion5.wav")
util.PrecacheSound("weapons/stunstick/alyx_stunner1.wav")

for impactSound in ipairs(forceShieldImpactSounds) do
    util.PrecacheSound(forceShieldImpactSounds[impactSound])
end

    -- To get a read off the table above we only look at first two numbers of HP, since we never go over 999
    -- we can do this by dividing by 10 and flooring the result with math.floor  
    function ENT:Flicker()
        timer.Create( "shield_flicker_timer" .. tostring(self), .02, 24, function() 
            if !IsValid(self) then return end
            local color = self:GetColor()
            
            if(self.colorModulate == false)then
                color.a = math.abs(math.sin(CurTime()) * 100)
                self:SetColor(color)
            else 
                color.a = 255
                self:SetColor(color)
            end
            self.colorModulate = !self.colorModulate
        end)
    end

    function ENT:bulletImpactEffect(impactPoint, impactNormal)
        local effectdata = EffectData()
        effectdata:SetNormal(impactNormal)
        effectdata:SetOrigin(impactPoint)
        util.Effect( "AR2Impact", effectdata) 
        util.Effect( "selection_ring", effectdata)
    end
    
    function ENT:OnTakeDamage( dmginfo )
        local damage = dmginfo:GetDamage() 
        local HPColorValueIndex = math.floor((self.hp/2)/10)
        
        self:EmitSound(forceShieldImpactSounds[math.random(1,4)], 85)
        self:bulletImpactEffect(dmginfo:GetDamagePosition(), self:GetRight())
        self.hp = self.hp - damage 
        
        self:SetModelScale(.995, .05)
        timer.Simple(.05, function() 
            if (IsValid(self)) then 
                self:SetModelScale(1,.05) 
            end 
        end)

        if(self.hp <= 0) then
            self:Flicker()
            self:EmitSound("ambient/levels/labs/electric_explosion5.wav", 100)
            self:StopSound("ambient/machines/combine_shield_touch_loop1.wav")
            timer.Simple(.48,function()
                if(IsValid(self)) then self:Remove() end
            end)
        end
        -- At the point the ENT:Flicker function is called, the shield's HP will be 0. 
        -- So if we don't cancel the coloring code if shield HP is below 0 the shield will be white since 
        -- the shield's color lookup table doesn't index below 0, which is where we retrieve color values 
        -- indexed for HP values(Less memory efficient, more performance efficient)
        if(HPColorValueIndex <= 0) then return end -- This line blocks the call to set color if shield HP is below 0
        self:SetColor(HPColorValues[HPColorValueIndex])
    end

    function ENT:SetupDataTables()
        self:NetworkVar( "Float", 0, "spawnTime" )

        if SERVER then
            self:SetspawnTime( CurTime() )
        end
    end

    function ENT:Draw()
        self:DrawModel()

        local shieldPos = self:GetPos()
        shieldPos.z = shieldPos.z + 96
        local shieldAngle = self:GetAngles()
        shieldAngle = Angle(0, shieldAngle.y, 90)
        
        local timeRemaining = math.Round(self.totalLifeTime - (CurTime() - self:GetCreationTime()))

        cam.Start3D2D( shieldPos, shieldAngle, .225 )
            draw.SimpleText( timeRemaining, "OvR_Load_HUD_Holo_1", 0, 0, Color(130,248,181, 200), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
        cam.End3D2D()
    end

if SERVER then
    function ENT:Initialize()
        self:SetModel( "models/ovr_load/force_shield.mdl" )
        self:SetRenderMode(RENDERMODE_TRANSCOLOR)
        self:SetMoveType( MOVETYPE_NOCLIP )
        self:SetSolid( SOLID_VPHYSICS )
        self:SetCollisionGroup( COLLISION_GROUP_WORLD ) 
        self.spawnTime = CurTime()
        --Effects 
        self:SetColor(Color(0, 80, 255))
        self:EmitSound("ambient/machines/combine_shield_touch_loop1.wav", 55)
        self:EmitSound("weapons/stunstick/alyx_stunner1.wav",100)
        ParticleEffectAttach( "vortigaunt_hand_glow", PATTACH_ABSORIGIN_FOLLOW, self, 1)
        self.colorModulate = false
        self:Flicker()
        -- Put default setModelScale in timer too because even though physics are initialized before SetModelScale is called,
        -- SetModelScale finishes its job first, so this will result in it spawning a tiny model collision. 
        timer.Simple( 0, function() self:SetModelScale( 0, 0 ) end) --default of size 0
        timer.Simple( 0, function() self:SetModelScale( 1, .1 ) end ) --grows to size 1
        --Code that defines behavior when entity's lifetime runs out
        timer.Simple(self.totalLifeTime,function()
            if(!IsValid(self)) then return end
            self:EmitSound("ambient/levels/labs/electric_explosion5.wav", 100)
            self:StopSound("ambient/machines/combine_shield_touch_loop1.wav")
            self:Flicker()
            timer.Simple(.48,function()
                if(IsValid(self)) then self:Remove() end
            end)
        end)
    end
end    


--PATH lua/entities/gb_rp_sign_wire/cl_init.lua:
return gluapack()()
--PATH lua/entities/headhunter.lua:
return gluapack()()
--PATH lua/entities/heart_turbolaser/cl_init.lua:
return gluapack()()
--PATH lua/entities/heart_turbolaser_spawner/shared.lua:
return gluapack()()
--PATH lua/entities/heart_turbolaser_spawner/shared.lua:
ENT.Type = "point";
ENT.Base = "base_gmodentity";
ENT.Author = "drunken hearted";

ENT.Spawnable = false;
--PATH lua/entities/intercom/shared.lua:
AddCSLuaFile()

if SERVER then
    include("server.lua")
    AddCSLuaFile("client.lua")
else
    include("client.lua")
end

ENT.Base = "base_gmodentity"
ENT.Type = "anim"
ENT.PrintName = "Intercom"
ENT.Category = "[RDV] Intercom"
ENT.Author = ""
ENT.Spawnable = true
ENT.RenderGroup = RENDERGROUP_BOTH

function ENT:SetupDataTables()
    self:NetworkVar("Entity", 1, "IntercomUser")
    self:NetworkVar("Bool", 1, "IntercomUsing")
end
--PATH lua/entities/jetpack_base.lua:
return gluapack()()
--PATH lua/entities/jetpack_base.lua:
AddCSLuaFile()

--[[
	An entity base that allows you to create entity that can be equipped by the player as if they were weapons or powerups, but that can still
	function when not picked up by a player

	For instance you could make a jetpack that flies off when the equipping player dies, or you can make a controllable plane but still allow
	full movement on the player

	This file is licensed under the MIT license, so go nuts.
]]

DEFINE_BASECLASS( "base_entity" )

ENT.UseNWVars = false

ENT.Spawnable = false
ENT.IsPredictedEnt = true
ENT.AttachesToPlayer = true	--whether this entity attaches to the player or not, when true this removes physics and draws the entity on the player

ENT.SaveButtonToCvar = false

if SERVER then
	ENT.DropOnDeath = false
	ENT.ShowPickupNotice = true	--plays the pickup sound and shows the pickup message on the hud
	ENT.DontTransmitToOthers = false --when true, don't transmit to anyone except the owner, this MIGHT conflict with addons that make use of SetPreventTransmit, so mind that!
	ENT.ShouldLagCompensate = true 	--automatically enables/disables lag compensation when physics are created and destroyed, might be annoying for some so disable this if you want
else
	ENT.RenderGroup = RENDERGROUP_OPAQUE
end

ENT.Editable = false

ENT.KeyAllowedKeyboard = 2 ^ 0
ENT.KeyAllowedMouse = 2 ^ 1
ENT.KeyAllowedJoystick = 2 ^ 2

ENT.KeyAllowedAll = bit.bor( ENT.KeyAllowedKeyboard , ENT.KeyAllowedMouse , ENT.KeyAllowedJoystick )

ENT.KeyAllowedFlags = ENT.KeyAllowedAll	--bitflag of the key types you want to use

ENT.HookAlways = 1 --hooks in here always run
ENT.HookEquipped = 2 --hooks in here are only added when the entity is equipped by user, and removed when unequipped
ENT.HookEquippedPrediction = 3 --like above, but on the client, only for the LocalPlayer() equipping this
ENT.HookCallback = 4 --these are callbacks handled with AddCallback, unfortunately we have no way to fully handle these

--example attachment info table, only used if AttachesToPlayer is true
--[[
ENT.AttachmentInfo = {
	BoneName = "ValveBiped.Bip01_Spine2",
	OffsetVec = Vector( 3 , -5.6 , 0 ),
	OffsetAng = Angle( 180 , 90 , -90 ),
}
]]

--[[
	This is a wrapper for NetworkVars/DTVars (same thing) so we can handle their slots properly for child classes instead
	of having to modify them manually everytime something changes in order

	This could be switched to NWVars2 (vinh vars) but then I would have to hack in support for right-click editing, since that's
	based on NetworkVars and some other getters
]]
function ENT:DefineNWVar( dttype , dtname , editable , beautifulname , minval , maxval , customelement , filt )

	if not self.DefinedDTVars[dttype] then
		Error( "Wrong NWVar type " .. ( dttype or "nil" ) )
		return
	end

	local index = -1

	--only do this check for limited dtvars, once we switch to NWVars in :NetworkVar this check will go away
	if not self.UseNWVars then
		local maxindex = self.DefinedDTVars[dttype].Max

		for i = 0 , maxindex - 1 do
			--we either didn't find anything in this slot or we found the requested one again
			--in which case just override it again, someone might want to inherit and add an edit table or something
			if not self.DefinedDTVars[dttype][i] or self.DefinedDTVars[dttype][i] == dtname then
				index = i
				break
			end
		end

		if index == -1 then
			Error( "Not enough slots on "..dttype .. ",	could not add ".. dtname )
			return
		end
	else
		index = dtname:lower()
	end

	self.DefinedDTVars[dttype][index] = dtname

	local edit = nil

	--this used to check if we could actually add the edit table, so we default it to nil to override it again
	--in case of a child class

	if editable then
		edit = {
			KeyName = dtname:lower(),
			Edit = {
				title = beautifulname or dtname,	--doesn't it do this internally already?
				min = minval,
				max = maxval,
				type = customelement or self.DefinedDTVars[dttype].EditableElement,
			}
		}
	end

	self:NetworkVar( dttype , index , dtname , edit )
end

function ENT:SetupDataTables()

	--if the user is in the branch that has the NWVars change then automatically switch to this
	if self.CallNetworkProxies then
		self.UseNWVars = true
	end

	--eventually I'll create more editable elements based on garry's system

	self.DefinedDTVars = {
		Entity = {
			Max = GMOD_MAXDTVARS,
		},
		Float = {
			Max = GMOD_MAXDTVARS,
			EditableElement = "Float",
		},
		Int = {
			Max = GMOD_MAXDTVARS,
			EditableElement = "Int",
		},
		Bool = {
			Max = GMOD_MAXDTVARS,
			EditableElement = "Boolean",
		},
		Vector = {
			Max = GMOD_MAXDTVARS,
		},
		Angle = {
			Max = GMOD_MAXDTVARS,
		},
		String = {
			Max = 4,
			EditableElement = "Generic",
		},
	}

	self:DefineNWVar( "Entity" , "ControllingPlayer" )
	self:DefineNWVar( "Bool" , "BeingHeld" )
	self:DefineNWVar( "String" , "SlotName" )
	self:DefineNWVar( "Float" , "NextFire" ) --similar to primaryattack on a weapon

	--only allow the user to modify the button if the coder wants this entity to have an usable key

	self:DefineNWVar( "Int" , "Key" , true , "Button" , BUTTON_CODE_NONE + 1 , BUTTON_CODE_LAST , "EditKey" )
	self:DefineNWVar( "Bool" , "KeyPressed" )
end

function ENT:Initialize()

	self.HandledHooks = {
		[self.HookAlways] = {},
		[self.HookEquipped] = {},
		[self.HookEquippedPrediction] = {},
		[self.HookCallback] = {}
	}

	self.HookConditions = {
		[self.HookAlways] = function( ent )
			return true
		end,
		[self.HookEquipped] = function( ent )
			return ent:IsCarried()
		end,
		[self.HookEquippedPrediction] = function( ent )
			if SERVER then
				return ent:IsCarried() --self.HookConditions[self.HookEquipped]( self )
			else
				return ent:IsCarriedByLocalPlayer()
			end
		end,
		[self.HookCallback] = function( self )
			return nil --nil means don't handle me
		end,
	}

	--predicted hooks hooking with hookers and futurama memes
	self:InstallHook( "StartCommand" , self.HandlePredictedStartCommand , self.HookEquippedPrediction )
	self:InstallHook( "SetupMove" , self.HandlePredictedSetupMove , self.HookEquippedPrediction )
	self:InstallHook( "Move" , self.HandlePredictedMove , self.HookEquippedPrediction )
	self:InstallHook( "PlayerTick" , self.HandlePredictedThink , self.HookEquippedPrediction )
	self:InstallHook( "FinishMove" , self.HandlePredictedFinishMove , self.HookEquippedPrediction )
	self:InstallHook( "OnPlayerHitGround" , self.HandlePredictedHitGround , self.HookEquippedPrediction )
	self:InstallHook( "PlayerButtonDown" , self.HandlePlayerButtonDown , self.HookEquippedPrediction )
	self:InstallHook( "PlayerButtonUp" , self.HandlePlayerButtonUp , self.HookEquippedPrediction )


	self:InstallHook( "CalcMainActivity" , self.HandleCalcMainActivity , self.HookEquipped )
	self:InstallHook( "UpdateAnimation" , self.HandleUpdateAnimation , self.HookEquipped )
	self:InstallHook( "DoAnimationEvent" , self.HandleAnimationEvent , self.HookEquipped )


	if SERVER then
		self:InstallHook( "SetupPlayerVisibility" , self.HandleEntityVisibility , self.HookAlways )
		self:InstallHook( "EntityRemoved" , self.OnControllerRemoved , self.HookAlways )
		self:InstallHook( "PostPlayerDeath" , self.OnControllerDeath , self.HookAlways )	--using PostPlayerDeath as it's called on all kind of player deaths, even :KillSilent()
		self:InstallHook( "CanEditVariable" , self.HandleCanEditVariable , self.HookAlways )

		--just in case it has been spawned manually and the coder forgot
		if self:GetSlotName() == "" then
			ErrorNoHalt( self:GetClass() .. " was spawned without a slotname!!!!. Defaulting to classname\n" )
			self:SetSlotName( self:GetClass() )
		end

		self:SetUseType( SIMPLE_USE )
		self:SetKey( BUTTON_CODE_NONE )
	else
		self:InstallHook( "PreDrawEffects" , self.DrawFirstPersonInternal , self.HookEquipped )
		self:InstallHook( "PostDrawViewModel" , self.DrawViewModelInternal , self.HookEquipped )
		self:InstallHook( "PostPlayerDraw" , self.DrawOnPlayer , self.HookEquipped )

		self:InstallHook( "NotifyShouldTransmit" , self.HandleFullPacketUpdate , self.HookAlways )

		language.Add( self:GetClass() , self.PrintName )
		language.Add( "dropped_"..self:GetClass() , "Dropped "..self.PrintName )
	end
end

--This is needed mostly for clientside hooks, since IsValid might return false when we're out of PVS with some bad lag
--and when hook.Call tries to call on an invalid entity it removes the hook, so we need to reinstall them when that happens and the entity gets back in the PVS
--prediction and other shit like drawing on a player might fuck up since the hooks got removed
--Now this also works for adding a callback

function ENT:InstallHook( hookname , handler , hooktype )

	if self.HandledHooks[hooktype] == nil then
		hooktype = self.HookAlways
	end

	self.HandledHooks[hooktype][hookname] = handler

	if hooktype == self.HookCallback then
		self:AddCallback( hookname , handler )
	end

end

function ENT:HandleHooks( cleanup )

	--this is direct access to the hook table, but it's not slow at all
	--or at least, it shouldn't be as long as you don't have any ulib shit or some other hook overrides
	local hooktable = hook.GetTable()



	for hookindex , handledshooktab in pairs( self.HandledHooks ) do
		local condition = self.HookConditions[hookindex]( self )

		if condition ~= nil then
			for i , v in pairs( handledshooktab ) do
				if condition and not cleanup then
					if not hooktable[i] or not hooktable[i][self] then
						hook.Add( i , self , v )
					end
				else
					if hooktable[i] and hooktable[i][self] then
						hook.Remove( i , self )
					end
				end
			end
		end
	end

end

function ENT:Think()

	self:HandleHooks()

	if SERVER then

		--check if this guy is still my parent and owner, maybe something is forcibly unparenting us from him, if so, drop
		if self.AttachesToPlayer and self:IsCarried() then
			if not self:IsAttached() then
				self:Remove( true )
			end
		end

		--we have to network this ourselves since it's based on the physics object ( which is mainly serverside )
		--the reason I'm networking this is that due to the gravity gun enabling prediction, it would screw with the manual
		--predictable logic of this entity, so when we try to activate prediction, we check if we're being carried by the gravity gun
		--to prevent disabling it

		--NOTE: this is not as expensive as it looks, it just checks for the FVPHYSICS_PLAYER_HELD flag on our physobj
		self:SetBeingHeld( self:IsPlayerHolding() )
	else
		--calling this in a non-predicted hook is perfectly fine, since we need the entity to enable prediction on its own
		--even when controlling players change

		--Ideally this would be handled on the callback of SetControllingPlayer clientside, but we don't have that yet
		self:HandlePrediction()
		self:HandleButtonBind()
		self:HandleContextMenuButton()
		self:InternalHandleLoopingSounds()
	end

	--set our think rate to be in line with the server tickrate
	--this may also affect animations clientside if they're ran in this hook, considering that also happens in normal source
	--I'd say that's an accurate replication of the issue

	--default behaviour for scripted entities is to think every 200 milliseconds
	--I suppose this should be configurable by child entities

	self:NextThink( CurTime() + engine.TickInterval() )
	return true
end

if SERVER then

	--for map inputs mostly, but other addons may also be using these inputs trough ent:Input or ent:Fire
	--more inputs might come in the future
	--of course child entities are free to call the baseclass function after their own to chain stuff

	function ENT:AcceptInput( inputName, activator, called, data )

		if inputName == "Drop" then
			self:Drop( true )
			return true
		end

		if inputName == "SetSlotName" then
			if self:IsCarried() or not data or #data <= 1 or data == self:GetSlotName() then
				return false
			end

			self:SetSlotName( data )
			return true
		end

	end

	--although we should probably do validity checks on them first, but considering this would *probably* be called from maps it should be ok
	--copied from env_skypaint, allows to have the DT vars set as if they were key values

	function ENT:KeyValue( key, value )

		if self:SetNetworkKeyValue( key, value ) then
			return
		end

	end

	function ENT:ChangeSlot( newslotname )
		local oldslotname = self:GetSlotName()

		if newslotname == oldslotname then
			return false
		end

		local ply = self:GetControllingPlayer()

		--if we have a controlling player and he has an entity in the new slot, abort
		if IsValid( ply ) and IsValid( self.GetOnPlayer( ply , newslotname ) ) then
			--this slot is already occupied!!!
			return false
		end

		if IsValid( ply ) then
			self.SetOnPlayer( ply , oldslotname , NULL )
			self.SetOnPlayer( ply , newslotname , self )
		end

		self:SetSlotName( newslotname )

		return true
	end

	--useful for swapping out two slots at the same time and knowing the other entity,
	--usually in an inventory system
	function ENT:SwapSlotWith( predent )
		local ply = self:GetControllingPlayer()

		if not self:IsCarriedBy( ply ) or not IsValid( predent ) or not predent.IsPredictedEnt
		or not predent:IsCarriedBy( ply ) then
			return false
		end

		local myslot = self:GetSlotName()
		local otherslot = predent:GetSlotName()

		self.SetOnPlayer( ply , otherslot , self )
		self.SetOnPlayer( ply , myslot , predent )

		self:SetSlotName( otherslot )
		predent:SetSlotName( myslot )

		return true
	end

	--override this if you want your equip logic to be different
	function ENT:Use( activator, caller, useType, value )
		if not self:Attach( activator ) then
			self:EmitPESound( "HL2Player.UseDeny" , 150 , nil , 1 , nil , nil , activator )
		end
	end

	function ENT:InitPhysics()
		--don't actually initialize the physics if we're getting removed anyway
		if self:IsEFlagSet( EFL_KILLME ) then
			return
		end


		if self.ShouldLagCompensate then
			self:SetLagCompensated( true )
		end

		self:DoInitPhysics()
		self:OnInitPhysics( self:GetPhysicsObject() )
	end

	function ENT:DoInitPhysics()
		self:PhysicsInit( SOLID_VPHYSICS )
		self:SetMoveType( MOVETYPE_VPHYSICS )
		self:SetSolid( SOLID_VPHYSICS )
		self:PhysWake()
	end

	function ENT:RemovePhysics()

		if self.AttachesToPlayer and self.ShouldLagCompensate then
			self:SetLagCompensated( false )	--entities that are attached to players will be moved back when the player is, so don't make them lag compensate on their own
		end

		self:OnRemovePhysics( self:GetPhysicsObject() )
		self:DoRemovePhysics()
	end

	function ENT:DoRemovePhysics()
		self:PhysicsDestroy()
		self:SetMoveType( MOVETYPE_NONE )
		self:SetSolid( SOLID_NONE )
	end

	function ENT:OnAttach( ply , forced )
		--override me
	end

	function ENT:CanAttach( ply )
		--override me
	end

	function ENT:OnDrop( ply , forced )
		--override me
	end

	function ENT:CanDrop( ply )
		--override me
	end

	--these two are not necessarely duplicates of the functions above because we may want to modify the mass
	--as soon as the physobj gets created, and that also happens in initialize

	function ENT:OnInitPhysics( physobj )
		--override me
	end

	function ENT:OnRemovePhysics( physobj )
		--override me
	end

	--being attached forcibly is usually something that happens when you want to spawn the player with this item, and you
	--don't want gamemode logic to interfere with it
	function ENT:Attach( activator , forced )

		--we were forced to attach to this player, so drop first to clear out some values
		if forced then
			self:Remove( forced )
		end

		if not IsValid( activator ) or not activator:IsPlayer() then
			return false
		end

		--we're carried in general OR that guy's using that slot already
		if self:IsCarried() or IsValid( self.GetOnPlayer( activator , self:GetSlotName() ) ) then
			return false
		end

		--we can allow the coder or gamemode to only stop the pickup if it's not forced
		if not forced then
			--simulate ourselves being a normal item pickup
			--the reason we're asking this first, is that first we want to make sure the gamemode is OK with us being able to pickup this entity
			local canattach = hook.Run( "PlayerCanPickupItem" , activator , self )

			--THEN we ask the coder if he really wants us to pickup his entity, in case it's out of "ammo", or some other restrictions
			local mycanattach = self:CanAttach( activator )
			if mycanattach == false then
				canattach = mycanattach
			end

			if canattach == false then
				return canattach
			end
		end

		if self.AttachesToPlayer then
			self:RemovePhysics()
			self:SetParent( activator )
			self:SetOwner( activator )
			self:SetTransmitWithParent( true )

			--[[
			if self.DontTransmitToOthers then
				--force a recheck of the transmission, so UpdateTransmitState() is called right away
				self:AddEFlags( EFL_FORCE_CHECK_TRANSMIT )
			else
				self:SetTransmitWithParent( true )
			end
			]]

			self:SetNoDraw( true )
			self:AddEFlags( EFL_NO_PHYSCANNON_INTERACTION )
		end

		self:SendItemMessage( activator , false )

		self.SetOnPlayer( activator , self:GetSlotName() , self )
		self:SetControllingPlayer( activator )

		--if the player has a customized key for this entity, use that instead
		--we do this here so that OnAttach can make use of it

		--this also allows us to prevent the key from another user to be written clientside and override ours
		if self.SaveButtonToCvar then
			local plykey = self:GetControllingPlayerConVarKey()

			if self:IsKeyAllowed( plykey ) and plykey ~= self:GetKey() then
				self:SetKey( plykey )
			end
		end

		--THIS IS VERY SUBJECTIVE
		self:SetKeyPressed( false ) --only reset the button press state when equipped

		self:OnAttach( activator , forced )
		return true
	end

	function ENT:Drop( forced )

		--we can allow the coder to only stop the drop if it's not forced
		if not forced then
			local candrop = self:CanDrop( self:GetControllingPlayer() )

			if candrop == false then
				return candrop
			end
		end

		if self.AttachesToPlayer then
			self:SetParent( NULL )
			self:SetOwner( NULL )
			self:InitPhysics()
			self:SetTransmitWithParent( false )

			--[[
			if self.DontTransmitToOthers then
				--force a recheck during a drop
				self:AddEFlags( EFL_FORCE_CHECK_TRANSMIT )
			else
				self:SetTransmitWithParent( false )
			end
			]]

			self:SetNoDraw( false )
			self:RemoveEFlags( EFL_NO_PHYSCANNON_INTERACTION )
		end

		if not forced and self:IsCarried() then
			self:SendItemMessage( self:GetControllingPlayer() , true )
		end

		--only call OnDrop if we had a player controlling us, don't do it if we were just sweeping up some unclean values
		if self:IsCarried() then
			self:OnDrop( self:GetControllingPlayer() , forced )
			self.SetOnPlayer( self:GetControllingPlayer() , self:GetSlotName() , NULL )
		end

		self:SetControllingPlayer( NULL )
		return true
	end

	function ENT:SendItemMessage( activator , dropped )
		if dropped == nil then
			dropped = false
		end
		--GetShouldPlayPickupSound is actually a Lua table value that is then checked in c++, so it starts out as nil, wow garry
		if self.ShowPickupNotice and ( self:GetShouldPlayPickupSound() == nil or self:GetShouldPlayPickupSound() ) then

			if not dropped then
				self:EmitSound( "HL2Player.PickupWeapon" )
			else
				self:EmitSound( "Weapon_Crowbar.Single" )
			end

			if not activator:IsPlayer() or not activator:IsBot() then
				net.Start( "pe_pickup" )
					net.WriteString( self:GetClass() )
					net.WriteBit( dropped )
				net.Send( activator )
			end
		end
	end

	--we want to get properly dropped when the player entity gets removed ( aka after a disconnect )
	--why not use the disconnect hook? no.

	function ENT:OnControllerRemoved( ent )
		if self:IsCarriedBy( ent ) then
			self:Remove( true )
		end
	end

	function ENT:OnControllerDeath( ply )
		if self.DropOnDeath and self:IsCarriedBy( ply ) then
			self:Remove( true )
		end
	end

	--we're redoing this even though it's hooked up in sandbox because someone might want to use this in another gamemode ( such as ttt or whatever )
	function ENT:HandleCanEditVariable( ent , ply , key , val , editor )
		if ent == self then
			local allow = self:CanPlayerEditVariable( ply , key , val , editor )

			if key == "Key" then
				local btn = tonumber( val )
				if btn and not self:IsKeyAllowed( btn ) then
					allow = false
				end
			end

			--call the editkey hook only if the other one didn't say anything in the matter for this
			if key == "Key" and allow == nil then
				allow = self:CanEditKey( ply , val , editor )
			end

			--we'll only override all the hooks if the answer is yes or no, nil keeps the default behaviour
			if allow ~= nil then
				return allow
			end
		end
	end

	--our key can only be modified by the carrying player or by anyone if it's not carried at all
	function ENT:CanEditKey( ply , val , editor )
		--you could override me if you want to, you could leave your friends behind
		return self:IsCarriedBy( ply ) or not self:IsCarried()
	end

	function ENT:CanPlayerEditVariable( ply , key , val , editor )
		--override me
	end

	--we add this entity's position to the visibility position, but only if it doesn't attach to the player
	function ENT:HandleEntityVisibility( ply , viewent )
		if self:IsCarriedBy( ply ) and not self.AttachesToPlayer and self ~= viewent then --viewents already add themselves to the pvs
			AddOriginToPVS( self:GetPos() )
		end

		--HOW CONVENIENT!!! this hook is called before the client computes what he can see
		--so we can simply use this before this entity gets recomputed for transmission

		--TODO: This will be removed and the ENT:UpdateTransmitState() below will be enabled once Willox is done with TRANSMIT_OWNERONLY
		if self.DontTransmitToOthers and not game.SinglePlayer() then

			local shouldpreventtransmit = false

			if self:IsCarried() then
				shouldpreventtransmit = not self:IsCarriedBy( ply , true )
			end

			self:SetPreventTransmit( ply , shouldpreventtransmit )
		end
	end

	--[[
	function ENT:UpdateTransmitState()


		if self.DontTransmitToOthers and self:IsCarried() then
			return TRANSMIT_OWNERONLY
		end


		--don't return anything, default behaviour
	end
	]]

else

	function ENT:GetConVar()

		--the slotname changed, so we forget this cvar to let another one with the same slot use it
		--and we let the code below create/get one with our slotname
		if self.ConfigurableConVar and self.ConfigurableConVar:GetName() ~= self:GetConVarName() then
			self.ConfigurableConVar = nil
		end

		if not self.ConfigurableConVar then
			--internally this returns the original convar if it was already created, so it's not that big of a deal, this could be done in a better way however
			self.ConfigurableConVar = CreateConVar( self:GetConVarName() , self:GetKey() , FCVAR_ARCHIVE + FCVAR_USERINFO , "Configures the key for "..self:GetSlotName().. " , created by "..self:GetClass() )
		end

		return self.ConfigurableConVar
	end

	function ENT:InternalHandleLoopingSounds( calledinprediction )
		--the calledinprediction variable makes it so HandleLoopingSounds is called from ENT:Think instead
		--and yes, this will never be set at all during singleplayer because there's no prediction

		--if this is set then there's no need to call iscarried checks below, we're always called when that happens
		if calledinprediction and not IsFirstTimePredicted() then
			return
		end

		if game.SinglePlayer() or not self:IsCarried() or not self:IsCarriedByLocalPlayer() or ( self:IsCarriedByLocalPlayer() and calledinprediction ) then
			self:HandleLoopingSounds()
		end
	end

	function ENT:HandleLoopingSounds()
		--override me
	end

	function ENT:IsCarriedByLocalPlayer( checkspectator )
		return self:IsCarriedBy( LocalPlayer() , checkspectator )
	end

	function ENT:ShouldDrawLocalPlayer( checkspectator )
		if checkspectator then
			if LocalPlayer():GetObserverMode() == OBS_MODE_IN_EYE and IsValid( LocalPlayer():GetObserverTarget() ) then
				if LocalPlayer():GetObserverTarget():IsPlayer() then
					return LocalPlayer():GetObserverTarget():ShouldDrawLocalPlayer() --assuming this even works, otherwise just return false
				end
				return false
			end
		end
		return LocalPlayer():ShouldDrawLocalPlayer()
	end

	--immediately make this entity predicted again, if it's equipped by this localplayer
	function ENT:HandleFullPacketUpdate( ent , shouldtransmit )
		if ent == self and shouldtransmit then
			self:HandlePrediction()
		end
	end

	function ENT:HandlePrediction()

		local carried = self:IsCarriedByLocalPlayer()

		--either the gravity gun or some other stuff is carrying me, don't do anything on prediction
		--because they might enable it to carry us around smoothly
		--also don't enable prediction in singleplayer

		if self:GetBeingHeld() or game.SinglePlayer() then
			return
		end

		if self:GetPredictable() ~= carried then
			self:SetPredictable( carried )
		end
	end

	function ENT:HandleButtonBind()
		--did not disable the function call from Think as someone might want to override this

		if self.SaveButtonToCvar then
			--this is a one way server to client saving, the reason I do this is because the user should usually change the value from
			--client to server with the edit system, it still goes to the server, but not to the cvar first, so we save it from the client to the cvar

			--basically we just use the cvar as a way to save the button, but it does come at the cost of not being able to update the cvar and have it update on the
			--entity, this will probably change in the future
			local mykey = self:GetKey()

			--can't use GetControllingPlayerConVarKey as I also need to SetInt on it
			local cv = self:GetConVar()

			if cv then
				if ( mykey ~= cv:GetInt() and self:IsKeyAllowed( mykey ) ) --[[or not self:IsKeyAllowed( cv:GetInt() )]] then
					cv:SetInt( mykey )
				end
			end
		end
	end



	function ENT:CreateContextMenuButton( iconlayout )
		local button = iconlayout:Add( "DPredEnt" )
		button:SetSize( 80 , 80 )
		button:SetClassName( self.PrintName , self:GetSlotName() )
		button:SetMaterial( self.Folder .. ".png" )
		button:SetPredEnt( self )
		--SetClassName
	end

	function ENT:GetContextMenuButton( iconlayout )
		local contextbutton = nil

		for i = 0 , iconlayout:ChildCount() do

			local child = iconlayout:GetChild( i )

			if IsValid( child ) and child:GetName() == "DPredEnt" and child:GetSpawnName() == self:GetSlotName() and child:GetPredEnt() == self then
				contextbutton = child
				break
			end

		end

		return contextbutton
	end

	--forcefully removes it in case it fucks up
	function ENT:RemoveContextMenuButton( iconlayout , buttonpanel )
		if IsValid( buttonpanel ) then
			buttonpanel:Remove()
		end
	end

	function ENT:GetContextMenuLayout()
		if not IsValid( g_ContextMenu ) then
			return
		end

		local iconlayout = nil

		for i = 0 , g_ContextMenu:ChildCount() do

			local child = g_ContextMenu:GetChild( i )

			if IsValid( child ) and child:GetName() == "DIconLayout" then
				iconlayout = child
				break
			end

		end

		return iconlayout
	end

	function ENT:HandleContextMenuButton( docleanup )

		local iconlayout = self:GetContextMenuLayout()

		if not IsValid( iconlayout ) then
			return
		end

		local buttonpanel = self:GetContextMenuButton( iconlayout )

		if IsValid( buttonpanel ) and ( not self:IsCarriedByLocalPlayer() or docleanup )then
			self:RemoveContextMenuButton( iconlayout , buttonpanel )
			iconlayout:InvalidateLayout()
		end

		if not IsValid( buttonpanel ) and self:IsCarriedByLocalPlayer() then
			self:CreateContextMenuButton( iconlayout )
			iconlayout:InvalidateLayout()
		end

	end



	function ENT:DrawFirstPersonInternal()
		if self.AttachesToPlayer and self:IsCarriedByLocalPlayer( true ) and not self:ShouldDrawLocalPlayer( true ) then
			local fov = nil	--TODO: allow changing the FOV
			cam.Start3D( nil , nil , fov , nil , nil , nil , nil , 1 , -1 )	--znear is 1 and zfar is -1
				render.DepthRange( 0 , 0.1 )	--same depth hack valve uses in source!
					self:DrawFirstPerson( self:GetControllingPlayer() )
				render.DepthRange( 0 , 1 )		--they don't even set these back to the original values
			cam.End3D()
		end
	end

	--viewmodels don't draw without an associated weapon ( this is due to garryness, they always do in source )
	function ENT:DrawViewModelInternal( vm , ply , wpn )
		if self.AttachesToPlayer and self:IsCarriedBy( ply , true ) then
			self:DrawOnViewModel( ply , vm , ply:GetHands() ) --this will stay here
		end
	end

	function ENT:DrawFirstPerson( ply )
		--override me
	end

	--mainly used to draw stuff like shields, gloves or whatever on the viewmodel hands

	function ENT:DrawOnViewModel( ply , vm , hands )
		--override me
	end

	--the flags aren't passed yet, maybe in a future update

	function ENT:DrawOnPlayer( ply , flags )
		self:DrawModel( flags )

	end

	function ENT:Draw( flags )
		local pos , ang = self:GetCustomParentOrigin()
		--even though the calcabsoluteposition hook should already prevent this, it doesn't on other players
		--might as well not give it the benefit of the doubt in the first place
		if pos and ang then
			self:SetPos( pos )
			self:SetAngles( ang )
			self:SetupBones()
		end

		self:DrawModel( flags )
	end

end

--these are here to "unify" our two calls to SetNWEntity and GetNWEntity
--these might be called from pe_drop and some other stuff, so we can't rely on the entity itself being present, as lame as that is
--the alternative would be to have these as global, which would be lamer
function ENT.SetOnPlayer( ply , slot , ent )
	ply:SetNW2Entity( slot , ent )
end

function ENT.GetOnPlayer( ply , slot )
	return ply:GetNW2Entity( slot )
end

function ENT:IsAttached()
	local ply = self:GetControllingPlayer()
	return self:GetOwner() == ply and self:GetParent() == ply
end

--LOOK I DON'T CARE, this check is lame as shit but I can't be arsed to add duplicated code
function ENT:IsCarried()
	return self:IsCarriedBy( self:GetControllingPlayer() )
end

function ENT:IsCarriedBy( ply , checkspectator )

	if checkspectator and ply:GetObserverMode() ~= OBS_MODE_NONE then
		return self:IsCarriedBy( ply:GetObserverTarget() )
	end

	return IsValid( ply ) and ply == self:GetControllingPlayer() and self.GetOnPlayer( self:GetControllingPlayer() , self:GetSlotName() ) == self
end

function ENT:IsKeyDown()
	return self:GetKeyPressed()
end

--these functions should totally not be tied to this SENT, but I don't want to go out of my way to add them to an util file
function ENT:IsValidButton( btn )
	return btn > BUTTON_CODE_NONE and btn < BUTTON_CODE_COUNT
end

function ENT:IsKeyboardButton( btn )
	return btn > KEY_FIRST and btn < KEY_COUNT
end

function ENT:IsMouseButton( btn )
	return btn >= MOUSE_FIRST and btn < MOUSE_LAST
end

function ENT:IsJoystickButton( btn )
	return btn >= JOYSTICK_FIRST and btn < JOYSTICK_LAST
end

function ENT:IsKeyAllowed( btn )
	if bit.band( self.KeyAllowedFlags , self.KeyAllowedKeyboard ) == 0 and self:IsKeyboardButton( btn ) then
		return false
	end

	if bit.band( self.KeyAllowedFlags , self.KeyAllowedMouse ) == 0 and self:IsMouseButton( btn ) then
		return false
	end

	if bit.band( self.KeyAllowedFlags , self.KeyAllowedJoystick ) == 0 and self:IsJoystickButton( btn ) then
		return false
	end

	return self:IsValidButton( btn )
end

function ENT:GetConVarName()
	return "prdent_key_"..self:GetSlotName()
end

function ENT:GetControllingPlayerConVarKey()
	local defaultkey = BUTTON_CODE_NONE

	if self:IsCarried() then
		if SERVER then
			return self:GetControllingPlayer():GetInfoNum( self:GetConVarName() , defaultkey )
		else
			--the clientside implementation of GetInfoNum makes a GetConVar lookup everytime, so use the cached one instead
			local cv = self:GetConVar()

			if cv then
				return cv:GetInt()
			end
		end
	end

	return defaultkey
end

function ENT:HandleCalcMainActivity( ply , velocity )
	if self:IsCarriedBy( ply ) then
		local calcideal , calcseqovr = self:HandleMainActivityOverride( ply , velocity )
		if calcideal and calcseqovr then
			return calcideal , calcseqovr
		end
	end
end

function ENT:HandleUpdateAnimation( ply, velocity, maxseqgroundspeed )
	if self:IsCarriedBy( ply ) then
		if self:HandleUpdateAnimationOverride( ply , velocity , maxseqgroundspeed ) then
			return true
		end
	end
end

function ENT:HandleAnimationEvent( ply, event, data )
	if self:IsCarriedBy( ply ) then
		if self:HandleAnimationEventOverride( ply , event , data ) then
			return ACT_INVALID
		end
	end
end

function ENT:HandleMainActivityOverride( ply , velocity )
	--override me
end

function ENT:HandleUpdateAnimationOverride( ply , velocity , maxseqgroundspeed )
	--override me
end

function ENT:HandleAnimationEventOverride( ply , event , data )
	--override me
end

function ENT:HandlePredictedStartCommand( ply , cmd )
	if self:IsCarriedBy( ply ) then
		self:PredictedStartCommand( ply , cmd )
	end
end

function ENT:HandlePlayerButtonDown( ply , btn )
	if self:IsCarriedBy( ply ) then
		self:HandlePlayerButtonInternal( ply , btn , true )
	end
end

function ENT:HandlePlayerButtonUp( ply , btn )
	if self:IsCarriedBy( ply ) then
		self:HandlePlayerButtonInternal( ply , btn , false )
	end
end

function ENT:HandlePlayerButtonInternal( ply , btn , pressed )
	local mykey = self:GetKey()
	if self:IsKeyAllowed( mykey ) and btn == mykey then
		self:SetKeyPressed( pressed )
	end

	self:PredictedPlayerButtonPress( ply , btn , pressed )
end

function ENT:HandlePredictedSetupMove( ply , mv , cmd )
	if self:IsCarriedBy( ply ) then
		if self:PredictedSetupMove( ply , mv , cmd ) then
			return true
		end
	end
end

function ENT:HandlePredictedMove( ply , mv )
	if self:IsCarriedBy( ply ) then
		if self:PredictedMove( ply , mv ) then
			return true
		end
	end
end

function ENT:HandlePredictedThink( ply , mv )
	if self:IsCarriedBy( ply ) then
		if CLIENT then
			self:InternalHandleLoopingSounds( true )
		end
		self:PredictedThink( ply , mv )
	end
end

function ENT:HandlePredictedFinishMove( ply , mv )
	if self:IsCarriedBy( ply ) then
		if self:PredictedFinishMove( ply , mv ) then
			return true
		end
	end
end

function ENT:HandlePredictedHitGround( ply , inwater , onfloater , speed )
	if self:IsCarriedBy( ply ) then
		if self:PredictedHitGround( ply , inwater , onfloater , speed ) then
			return true
		end
	end
end

function ENT:PredictedStartCommand( ply , cmd )
	--override me
end

function ENT:PredictedPlayerButtonPress( ply , btn , pressed )
	--override me
end

function ENT:PredictedSetupMove( ply , mv , cmd )
	--override me
end

function ENT:PredictedMove( ply , mv )
	--override me
end

function ENT:PredictedThink( ply , mv )
	--override me
end

function ENT:PredictedFinishMove( ply , mv )
	--override me
end

function ENT:PredictedHitGround( ply , inwater , onfloater , speed )
	--override me
end

--Allows for predicted movement simulation on non player entities, without disrupting the player movement itself
--FinishMove should be the best place for this, since even in case of fuckups, the rest of the movement should be fine

--[[
	function ENT:PredictedFinishMove( ply , mv )

		local sv = self:BackupMoveData( mv )

		--set the data you want on the movedata, such as the entity origin, speed, angles and stuff

		--run the entity traces

		--set the final position of the entity here with the same way garry does ( see drive.End or whatever it's called )

		--restore the movedata on the player as if nothing happened

		self:RestoreMoveData( mv , sv )


	end
]]


local movedatameta = FindMetaTable( "CMoveData" )

local emptyvalues = {
	[TYPE_VECTOR] = vector_origin * 1,
	[TYPE_ANGLE] = angle_zero * 1,
	[TYPE_NUMBER] = 0,
	[TYPE_ENTITY] = NULL,
}

local methods = {}

--cache the methods we can actually use
for i , v in pairs( movedatameta ) do
	--see if this function has a pattern like "Get*" or whatever
	--then strip out "Get" and add it here
	local functionname = i
	if functionname:find( "^Get" ) then
		local functionnamestripped = functionname:gsub( "^Get" , "" )

		local setter = movedatameta["Set"..functionnamestripped]

		if setter then
			--add the stripped method to the table to reuse later
			methods[#methods + 1] = functionnamestripped
		end
	end
end

function ENT:BackupMoveData( mv )

	if not mv or not movedatameta then
		return
	end

	local sv = {}
	--save the movedata by name on the table, then go trough the metatable to get the setters and set values to empty ones

	for i , v in pairs( methods ) do
		--see if this function has a pattern like "Get*" or whatever
		--then strip out "Get" and add it here

		--we could've cached the functions as well, but just in case someone wants us to use the modified ones
		local getter = movedata["Get"..v]
		local setter = movedata["Set"..v]

		local backupvalue = getter( mv )

		sv[v] = backupvalue

		if emptyvalues[TypeID( backupvalue )] ~= nil then
			setter( mv , emptyvalues[TypeID( backupvalue )] )
		end
	end

	return sv
end

function ENT:RestoreMoveData( mv , sv )
	if not mv or not sv or not movedatameta then
		return
	end

	--restore the values from the table, prevents duplicated code by using the setters from the metatable directly
	for i , v in pairs( sv ) do
		local setter = movedatameta["Set"..i]
		if setter then
			setter( mv , v )
		end
	end
end

--attaches the entity to the player depending on the attachmentinfo table
--you can override this safely as long as you keep the part with ply:SetupBones()
--although you generally should just use the attachment info table instead

function ENT:GetCustomParentOrigin()

	if not self.AttachmentInfo then
		return
	end

	local ply = self:GetControllingPlayer()

	--duplicated check, but people might call this manually in the entity draw hook, so gotta do this
	if not self:IsCarriedBy( ply ) then
		return
	end

	--I put this here because since the entity moves to the player bone matrix, it'll only be updated on the client
	--when the player is actally drawn, or his bones are setup again ( which happens before a draw anyway )
	--this also fixes sounds on the client playing at the last location the LocalPlayer() was drawn

	if CLIENT and self:IsCarriedByLocalPlayer( true ) and not self:ShouldDrawLocalPlayer( true ) then
		ply:SetupBones()
	end

	local boneid = ply:LookupBone( self.AttachmentInfo.BoneName )

	if not boneid then
		return
	end

	local matrix = ply:GetBoneMatrix( boneid )

	if not matrix then
		return
	end

	return LocalToWorld( self.AttachmentInfo.OffsetVec , self.AttachmentInfo.OffsetAng , matrix:GetTranslation() , matrix:GetAngles() )
end

--if we're attached to a player, use custom origin from the function above
--this is called shared, yes it's more expensive than source's normal parenting but it's worth it

function ENT:CalcAbsolutePosition( pos , ang )
	if self.AttachesToPlayer and self:IsCarried() then
		return self:GetCustomParentOrigin()
	end
end

function ENT:EmitPESound( soundname , level , pitch , volume , chan , predicted , activator , worldpos )

	--must've been called manually by some ent:Fire or ent:Input functions
	if IsValid( activator ) and not activator:IsPlayer() then
		activator = NULL
	end

	if not level then
		level = 75
	end

	if not pitch then
		pitch = 100
	end

	if not volume then
		volume = 1
	end

	if not chan then
		chan = CHAN_AUTO
	end

	if game.SinglePlayer() then
		predicted = false
	end

	if not worldpos then
		worldpos = vector_origin
	end

	if SERVER then

		local plys = RecipientFilter()

		if IsValid( activator ) and not predicted and not activator:IsBot() then
			plys:AddPlayer( activator )
		else

			plys:AddPVS( self:GetPos() )

			if predicted and IsValid( self:GetControllingPlayer() ) then
				plys:RemovePlayer( self:GetControllingPlayer() )
			end

		end

		if plys:GetCount() == 0 then
			return
		end

		net.Start( "pe_playsound" )
			net.WriteEntity( self )
			net.WriteString( soundname )
			net.WriteFloat( level )
			net.WriteFloat( pitch )
			net.WriteFloat( volume )
			net.WriteUInt( chan , 8 )
			net.WriteVector( worldpos )
		net.Send( plys )

	else
		if ( predicted and IsFirstTimePredicted() ) or not predicted then
			if worldpos and worldpos ~= vector_origin then
				sound.Play( soundname, worldpos, level, pitch , volume )
			else
				self:EmitSound( soundname , level , pitch , volume , chan )
			end
		end
	end
end

function ENT:OnRemove()
	--if we're being forcibly removed, make sure we're also dropped properly, in case the entity needs to do
	--some stuff on the player before it expires
	if SERVER and self:IsCarried() then
		self:Remove( true )
	end

	if CLIENT then
		self:HandleContextMenuButton( true )
	end

	self:HandleHooks( true ) --remove the hooks immediately instead of relying on garry's "remove if called again"


end

--stuff that should be in an autorun file but that I can't be arsed to split up to

if SERVER then

	util.AddNetworkString( "pe_pickup" )
	util.AddNetworkString( "pe_playsound" )

	--save the function before ENT gets removed during registration
	local GetPredictedEntityOnPlayer = ENT.GetOnPlayer

	concommand.Add( "pe_drop" , function( ply , cmd , args , fullstr )

		if not IsValid( ply ) then
			return
		end

		local nwslot = args[1]

		if not nwslot then
			return
		end

		local slotent = GetPredictedEntityOnPlayer( ply , nwslot )--ply:GetNWEntity( nwslot )

		--user tried to drop an invalid or an entity which is not a predicted entity, or doesn't have a slot assigned

		if not IsValid( slotent ) or not slotent.IsPredictedEnt or slotent:GetSlotName() == "" then
			return
		end

		slotent:Remove( false )

	end)

else

	--tells the hud to show the player the entity pickup
	language.Add( "invalid_entity" , "Invalid Entity" )
	language.Add( "dropped_invalid_entity" , "Dropped Invalid Entity" )

	net.Receive( "pe_pickup" , function( len )
		local str = net.ReadString() or "invalid_entity"
		local dropped = tobool( net.ReadBit() )

		if dropped then
			str = "dropped_" .. str
		end

		gamemode.Call( "HUDItemPickedUp" , str )
	end)

	net.Receive( "pe_playsound" , function( len )
		local ent = net.ReadEntity()

		if not IsValid( ent ) or not ent.EmitPESound then
			return
		end

		local soundname = net.ReadString() --yes I know that I can do util.addnetworkstring to cache it but I cba

		local level = net.ReadFloat()
		local pitch = net.ReadFloat()
		local volume = net.ReadFloat()
		local chan = net.ReadUInt( 8 )
		local pos = net.ReadVector()

		ent:EmitPESound( soundname , level , pitch , volume , chan , false , NULL , pos )
	end)

	--[[
		A DProperty that allows the user to set a preferred key using the same DBinder used in sandbox's tools
	]]

	local DBinderProperty = {}

	function DBinderProperty:Init()
	end

	function DBinderProperty:Setup( vars )

		self:Clear()

		local ctrl = self:Add( "DBinder" )
		ctrl:Dock( FILL )

		self.IsEditing = function( self )
			return ctrl.Trapping
		end

		self.SetValue = function ( self , val )
			ctrl:SetSelected( tonumber( val ) )	--use this instead of setValue to possibly avoid feedback loops
		end

		--DBinder doesn't have an onchange callback, so we must do this little hack to add it
		--[[
		ctrl.SetValue = function( ctrl , val )
			ctrl:SetSelected( val )
			self:ValueChanged( val )
		end
		]]

		ctrl.OnChange = function( ctrl , val )
			self:ValueChanged( val )
		end


	end

	derma.DefineControl( "DProperty_EditKey" , "" , DBinderProperty , "DProperty_Generic" )

	local DPredEnt = {
		matOverlay_Normal = Material( "gui/ContentIcon-normal.png" ),
		matOverlay_Hovered = Material( "gui/ContentIcon-hovered.png" )
	}

	AccessorFunc( DPredEnt, "m_MaxBorder", "MaxBorder" )
	AccessorFunc( DPredEnt, "m_MaterialName", "MaterialName" )
	AccessorFunc( DPredEnt, "m_PredEnt", "PredEnt" )
	AccessorFunc( DPredEnt, "m_Border", "Border" )
	AccessorFunc( DPredEnt, "m_Color", "Color" )
	AccessorFunc( DPredEnt, "m_Type", "ContentType" )
	AccessorFunc( DPredEnt, "m_SpawnName", "SpawnName" )
	AccessorFunc( DPredEnt, "m_NPCWeapon", "NPCWeapon" )
	AccessorFunc( DPredEnt, "m_Image", "Image" )
	AccessorFunc( DPredEnt, "m_Label", "Label" )

	function DPredEnt:Init()

		local w , h = 128, 128
		self:SetSize( w , h )

		self:SetPaintBackground( false )

		self:SetText( "" )
		self:SetDoubleClickingEnabled( false )

		self:SetImage( self:Add( "DImage" ) )
		self:GetImage():SetVisible( false )

		self:SetLabel( self:Add( "DLabel" ) )
		self:GetLabel():Dock( BOTTOM )

		self:GetLabel():SetContentAlignment( 5 )

		self:GetLabel():SetTextColor( Color( 255, 255, 255, 255 ) )
		self:GetLabel():SetExpensiveShadow( 1, Color( 0, 0, 0, 200 ) )

		self:SetBorder( 0 )



	end



	function DPredEnt:PerformLayout( w , h )
		self:SetMaxBorder( w / 16 )
		self:GetImage():SetPos( w / 32 , w / 32 )
		self:GetImage():SetSize( w - w / 16 , h - w / 16 )
		self:GetLabel():SetTall( math.Round( w / 7 ) )
		self:GetLabel():DockMargin( math.Round( w / 32 ) , 0 , math.Round( w / 32 ) , math.Round( w / 21 ) )
	end


	function DPredEnt:SetClassName( name , class )

		self:SetTooltip( name )
		self:GetLabel():SetText( name )
		self:SetSpawnName( class )
	end

	function DPredEnt:SetMaterial( name )

		self:SetMaterialName( name )

		local mat = Material( name )

		-- Look for the old style material
		if not mat or mat:IsError() then

			name = name:Replace( "entities/", "VGUI/entities/" )
			name = name:Replace( ".png", "" )
			mat = Material( name )

		end

		-- Couldn't find any material.. just return
		if not mat or mat:IsError() then
			return
		end

		self:GetImage():SetMaterial( mat )

	end

	function DPredEnt:Think()
		if not IsValid( self:GetPredEnt() ) or not self:GetPredEnt().IsPredictedEnt  then
			self:Remove()
		end
	end

	function DPredEnt:DoRightClick()
		self:OpenMenu()
	end

	function DPredEnt:DoClick()
		RunConsoleCommand( "pe_drop" , self:GetSpawnName() or ""  )
	end

	function DPredEnt:OpenMenu()
		if IsValid( self:GetPredEnt() ) then
			properties.OpenEntityMenu( self:GetPredEnt() )
		end
	end

	function DPredEnt:OnDepressionChanged( b )
	end

	function DPredEnt:Paint( w, h )

		if self.Depressed and not self.Dragging then
			if self:GetBorder() ~= self:GetMaxBorder() then
				self:SetBorder( self:GetMaxBorder() )
				self:OnDepressionChanged( true )
			end
		else
			if self:GetBorder() ~= 0 then
				self:SetBorder( 0 )
				self:OnDepressionChanged( false )
			end
		end

		render.PushFilterMag( TEXFILTER.ANISOTROPIC )
		render.PushFilterMin( TEXFILTER.ANISOTROPIC )

		local bx , by , bw , bh = self:GetBorder(), self:GetBorder(), w - self:GetBorder() * 2 , h - self:GetBorder() * 2


		self:GetImage():PaintAt( bx + self:GetMaxBorder() / 2 , by + self:GetMaxBorder() / 2 , bw - self:GetMaxBorder() , bh - self:GetMaxBorder() )



		render.PopFilterMin()
		render.PopFilterMag()

		surface.SetDrawColor( 255, 255, 255, 255 )

		if not dragndrop.IsDragging() and ( self:IsHovered() or self.Depressed or self:IsChildHovered() ) then

			surface.SetMaterial( self.matOverlay_Hovered )
			self:GetLabel():Hide()

		else

			surface.SetMaterial( self.matOverlay_Normal )
			self:GetLabel():Show()

		end

		surface.DrawTexturedRect( bx , by , bw , bh )

	end

	derma.DefineControl( "DPredEnt" , "ContentIcon for Predicted entities in the context menu" , DPredEnt , "DButton" )

end

--PATH lua/entities/laat_detonator/cl_init.lua:
include("shared.lua")

function ENT:Draw()
	self:DrawModel() 
end
--PATH lua/entities/laat_hatch/shared.lua:
ENT.Base            = "base_entity"
ENT.Type            = "anim"

ENT.PrintName       = "Hatch"
ENT.Author          = "!Ben"
ENT.Information     = ""
ENT.Category        = "[LFS] - Star Wars Pack"

ENT.Spawnable		= false
ENT.AdminSpawnable	= false

ENT.RenderGroup = RENDERGROUP_BOTH

ENT.AutomaticFrameAdvance = true
--PATH addons/[miecze] moce i hilty/lua/entities/lscs_crystal_base.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/entities/lscs_projectile.lua:
return gluapack()()
--PATH lua/entities/lvs_armor_bounce.lua:
return gluapack()()
--PATH lua/entities/lvs_av7/cl_init.lua:
return gluapack()()
--PATH lua/entities/lvs_base/shared.lua:
ENT.Type            = "anim"

ENT.PrintName = "LBaseEntity"
ENT.Author = "Luna"
ENT.Information = "Luna's Vehicle Script"
ENT.Category = "[LVS]"

ENT.Spawnable			= false
ENT.AdminSpawnable		= false

ENT.AutomaticFrameAdvance = true
ENT.RenderGroup = RENDERGROUP_BOTH 

ENT.Editable = true

ENT.LVS = true

ENT.MDL = "models/props_c17/trappropeller_engine.mdl"

ENT.AITEAM = 0

ENT.MaxHealth = 100
ENT.MaxShield = 0

ENT.SpawnNormalOffset = 15
ENT.HitGroundLength = 10

ENT.lvsDisableZoom = true

function ENT:AddDT( type, name, data )
	if not self.DTlist then self.DTlist = {} end

	if self.DTlist[ type ] then
		self.DTlist[ type ] = self.DTlist[ type ] + 1
	else
		self.DTlist[ type ] = 0
	end

	self:NetworkVar( type, self.DTlist[ type ], name, data )
end

function ENT:CreateBaseDT()
	local InitWeaponsSuccess, ErrorMsg = pcall( function() self:InitWeapons() end )

	if not InitWeaponsSuccess then
		ErrorNoHalt( "\n[ERROR] "..ErrorMsg.."\n\n" )
	end

	self:AddDT( "Entity", "Driver" )
	self:AddDT( "Entity", "DriverSeat" )

	self:AddDT( "Bool", "Active" )
	self:AddDT( "Bool", "EngineActive" )
	self:AddDT( "Bool", "AI",	{ KeyName = "aicontrolled",	Edit = { type = "Boolean",	order = 1,	category = "AI"} } )

	local ShowAIGunnerInMenu = false

	if istable( self.WEAPONS ) then
		for id, _ in pairs( self.WEAPONS ) do
			if id == 1 then continue end

			ShowAIGunnerInMenu = true

			break
		end
	end

	if ShowAIGunnerInMenu then
		self:AddDT( "Bool", "AIGunners",	{ KeyName = "aigunners",	Edit = { type = "Boolean",	order = 2,	category = "AI"} } )
	else
		self:AddDT( "Bool", "AIGunners" )
	end

	self:AddDT( "Bool", "lvsLockedStatus" )
	self:AddDT( "Bool", "lvsReady" )
	self:AddDT( "Bool", "NWOverheated" )

	self:AddDT( "Int", "AITEAM", { KeyName = "aiteam", Edit = { type = "Int", order = 2,min = 0, max = 3, category = "AI"} } )
	self:AddDT( "Int", "SelectedWeapon" )
	self:AddDT( "Int", "NWAmmo" )

	self:AddDT( "Float", "HP", { KeyName = "health", Edit = { type = "Float", order = 2,min = 0, max = self.MaxHealth, category = "Misc"} } )
	self:AddDT( "Float", "Shield" )
	self:AddDT( "Float", "NWHeat" )

	self:OnSetupDataTables()

	if SERVER then
		self:NetworkVarNotify( "AI", self.OnToggleAI )
		self:NetworkVarNotify( "HP", self.PDSHealthValueChanged )
		self:NetworkVarNotify( "SelectedWeapon", self.OnWeaponChanged )

		self:SetAITEAM( self.AITEAM )
		self:SetHP( self.MaxHealth )
		self:SetShield( self.MaxShield )
		self:SetSelectedWeapon( 1 )
	end
end

function ENT:SetupDataTables()
	self:CreateBaseDT()
end

function ENT:OnSetupDataTables()
end

function ENT:CalcMainActivity( ply )
end

function ENT:GetPlayerBoneManipulation( ply, PodID )
	return self.PlayerBoneManipulate[ PodID ] or {}
end

function ENT:UpdateAnimation( ply, velocity, maxseqgroundspeed )
	ply:SetPlaybackRate( 1 )

	if CLIENT then
		GAMEMODE:GrabEarAnimation( ply )
		GAMEMODE:MouthMoveAnimation( ply )
	end

	return false
end

function ENT:StartCommand( ply, cmd )
end

function ENT:HitGround()
	local trace = util.TraceLine( {
		start = self:LocalToWorld( self:OBBCenter() ),
		endpos = self:LocalToWorld( Vector(0,0,self:OBBMins().z - self.HitGroundLength) ),
		filter = self:GetCrosshairFilterEnts()
	} )
	
	return trace.Hit 
end

function ENT:Sign( n )
	if n > 0 then return 1 end

	if n < 0 then return -1 end

	return 0
end

function ENT:VectorSubtractNormal( Normal, Velocity )
	local VelForward = Velocity:GetNormalized()

	local Ax = math.acos( math.Clamp( Normal:Dot( VelForward ) ,-1,1) )

	local Fx = math.cos( Ax ) * Velocity:Length()

	local NewVelocity = Velocity - Normal * math.abs( Fx )

	return NewVelocity
end

function ENT:VectorSplitNormal( Normal, Velocity )
	return math.cos( math.acos( math.Clamp( Normal:Dot( Velocity:GetNormalized() ) ,-1,1) ) ) * Velocity:Length()
end

function ENT:AngleBetweenNormal( Dir1, Dir2 )
	return math.deg( math.acos( math.Clamp( Dir1:Dot( Dir2 ) ,-1,1) ) )
end

function ENT:GetMaxShield()
	return self.MaxShield
end

function ENT:GetShieldPercent()
	return self:GetShield() / self:GetMaxShield()
end

function ENT:GetMaxHP()
	return self.MaxHealth
end

function ENT:IsInitialized()
	if not self.GetlvsReady then return false end -- in case this is called BEFORE setupdatatables

	return self:GetlvsReady()
end

function ENT:GetWeaponHandler( num )
	if num == 1 then return self end

	local pod = self:GetPassengerSeat( num )

	if not IsValid( pod ) then return NULL end

	return pod:lvsGetWeapon()
end

function ENT:GetPassengerSeat( num )
	if num == 1 then
		return self:GetDriverSeat()
	else
		for _, Pod in pairs( self:GetPassengerSeats() ) do

			if not IsValid( Pod ) then continue end

			local id = Pod:lvsGetPodIndex()

			if id == -1 then continue end

			if id == num then
				return Pod
			end
		end

		return NULL
	end
end

function ENT:GetPassengerSeats()
	if not self:IsInitialized() then return {} end

	if not istable( self.pSeats ) then
		self.pSeats = {}

		local DriverSeat = self:GetDriverSeat()

		for _, v in pairs( self:GetChildren() ) do
			if v ~= DriverSeat and v:GetClass():lower() == "prop_vehicle_prisoner_pod" then
				table.insert( self.pSeats, v )
			end
		end
	end

	return self.pSeats
end

function ENT:HasActiveSoundEmitters()
	local active = false

	for _, emitter in ipairs( self:GetChildren() ) do
		if emitter:GetClass() ~= "lvs_soundemitter" then continue end

		if not IsValid( emitter ) or not emitter.GetActive or not emitter.GetActiveVisible then continue end

		if emitter:GetActive() and emitter:GetActiveVisible() then
			active = true

			break
		end
	end

	return active
end

function ENT:GetPassenger( num )
	if num == 1 then
		return self:GetDriver()
	else
		for _, Pod in pairs( self:GetPassengerSeats() ) do

			if not IsValid( Pod ) then
				return NULL
			end

			local id = Pod:lvsGetPodIndex()

			if id == -1 then continue end

			if id == num then
				return Pod:GetDriver()
			end
		end

		return NULL
	end
end

function ENT:GetEveryone()
	local plys = {}

	local Pilot = self:GetDriver()
	if IsValid( Pilot ) then
		table.insert( plys, Pilot )
	end

	for _, Pod in pairs( self:GetPassengerSeats() ) do
		if not IsValid( Pod ) then continue end

		local ply = Pod:GetDriver()

		if not IsValid( ply ) then continue end

		table.insert( plys, ply )
	end

	return plys
end

function ENT:GetPodIndex()
	return 1
end

function ENT:PlayAnimation( animation, playbackrate )
	playbackrate = playbackrate or 1

	local sequence = self:LookupSequence( animation )

	self:ResetSequence( sequence )
	self:SetPlaybackRate( playbackrate )
	self:SetSequence( sequence )
end

function ENT:GetVehicle()
	return self
end

function ENT:GetVehicleType()
	return "LBaseEntity"
end

function ENT:GetBoneInfo( BoneName )
	local BoneID = self:LookupBone( BoneName )
	local numHitBoxSets = self:GetHitboxSetCount()

	if not BoneID then
		goto SkipLoop
	end

	for hboxset = 0, numHitBoxSets - 1 do
		local numHitBoxes = self:GetHitBoxCount( hboxset )

		for hitbox=0, numHitBoxes - 1 do
			local bone = self:GetHitBoxBone( hitbox, hboxset )
			local name = self:GetBoneName( bone )

			if BoneName ~= name then continue end

			local mins, maxs = self:GetHitBoxBounds( hitbox, hboxset )
			local pos, ang = self:GetBonePosition( BoneID )

			return self:WorldToLocal( pos ), self:WorldToLocalAngles( ang ), mins, maxs
		end
	end

	:: SkipLoop ::

	return vector_origin, angle_zero, vector_origin, vector_origin
end
--PATH lua/entities/lvs_base/cl_hud.lua:
return gluapack()()
--PATH lua/entities/lvs_base/cl_seatswitcher.lua:

ENT.IconVehicleLocked = Material( "lvs/locked.png" )

LVS:AddHudEditor( "SeatSwitcher", ScrW() - 360, 10,  350, 60, 350, 60, "SEAT SWITCHER", 
	function( self, vehicle, X, Y, W, H, ScrX, ScrY, ply )
		if not vehicle.LVSHudPaintSeatSwitcher then return end

		vehicle:LVSHudPaintSeatSwitcher( X, Y, W, 30, ScrX, ScrY, ply )
	end
)

function ENT:LVSHudPaintSeatSwitcher( X, Y, w, h, ScrX, ScrY, ply )
	local pSeats = table.Copy( self:GetPassengerSeats() )
	local SeatCount = table.Count( pSeats ) 

	if SeatCount <= 0 then return end

	pSeats[0] = self:GetDriverSeat()

	draw.NoTexture() 

	local HasAI = self:GetAI()
	local HasAIGunners = self:GetAIGunners()

	local MySeat = ply:GetVehicle():lvsGetPodIndex()

	local Passengers = {}
	for _, player in pairs( player.GetAll() ) do
		if player:lvsGetVehicle() == self then
			local Pod = player:GetVehicle()
			Passengers[ Pod:lvsGetPodIndex() ] = player:GetName()
		end
	end

	if HasAI then
		Passengers[1] = "[AI] "..self.PrintName
	end

	if HasAIGunners then
		for _, Pod in pairs( self:GetPassengerSeats() ) do
			if IsValid( Pod:GetDriver() ) then continue end
	
			local weapon = Pod:lvsGetWeapon()

			if not IsValid( weapon ) then continue end

			Passengers[ weapon:GetPodIndex() ] = "[AI] Gunner"
		end
	end

	ply.SwitcherTime = ply.SwitcherTime or 0
	ply._lvsoldPassengers = ply._lvsoldPassengers or {}

	local Time = CurTime()
	for k, v in pairs( Passengers ) do
		if ply._lvsoldPassengers[k] ~= v then
			ply._lvsoldPassengers[k] = v
			ply.SwitcherTime = Time + 2
		end
	end
	for k, v in pairs( ply._lvsoldPassengers ) do
		if not Passengers[k] then
			ply._lvsoldPassengers[k] = nil
			ply.SwitcherTime = Time + 2
		end
	end
	for _, v in pairs( LVS.pSwitchKeysInv ) do
		if input.IsKeyDown(v) then
			ply.SwitcherTime = Time + 2
		end
	end

	local Hide = ply.SwitcherTime > Time

	ply.smHider = ply.smHider and (ply.smHider + ((Hide and 1 or 0) - ply.smHider) * RealFrameTime() * 15) or 0

	local Alpha1 = 135 + 110 * ply.smHider 
	local HiderOffset = 270 * ply.smHider
	local xPos = w - 35
	local yPos = Y - (SeatCount + 1) * 30 + h + 5

	local SwapY = false
	local SwapX = false

	local xHider = HiderOffset

	if X < (ScrX * 0.5 - w * 0.5) then
		SwapX = true
		xPos = 0
		xHider = 0
	end

	if Y < (ScrY * 0.5 - h * 0.5) then
		SwapY = true
		yPos = Y - h
	end

	for _, Pod in pairs( pSeats ) do
		if not IsValid( Pod ) then continue end

		local I = Pod:lvsGetPodIndex()

		if I <= 0 then continue end

		if I == MySeat then
			draw.RoundedBox(5, X + xPos - xHider, yPos + I * 30, 35 + HiderOffset, 25, Color(LVS.ThemeColor.r, LVS.ThemeColor.g, LVS.ThemeColor.b,100 + 50 * ply.smHider) )
		else
			draw.RoundedBox(5, X + xPos - xHider, yPos + I * 30, 35 + HiderOffset, 25, Color(0,0,0,100 + 50 * ply.smHider) )
		end

		if Hide then
			if Passengers[I] then
				draw.DrawText( Passengers[I], "LVS_FONT_SWITCHER", X + 40 + xPos - xHider, yPos + I * 30 + 2.5, Color( 255, 255, 255,  Alpha1 ), TEXT_ALIGN_LEFT )
			else
				draw.DrawText( "-", "LVS_FONT_SWITCHER", X + 40 + xPos - xHider, yPos + I * 30 + 2.5, Color( 255, 255, 255,  Alpha1 ), TEXT_ALIGN_LEFT )
			end
			
			draw.DrawText( "["..I.."]", "LVS_FONT_SWITCHER", X + 17 + xPos - xHider, yPos + I * 30 + 2.5, Color( 255, 255, 255, Alpha1 ), TEXT_ALIGN_CENTER )
		else
			if Passengers[I] then
				draw.DrawText( "[^"..I.."]", "LVS_FONT_SWITCHER", X + 17 + xPos - xHider, yPos + I * 30 + 2.5, Color( 255, 255, 255, Alpha1 ), TEXT_ALIGN_CENTER )
			else
				draw.DrawText( "["..I.."]", "LVS_FONT_SWITCHER", X + 17 + xPos - xHider, yPos + I * 30 + 2.5, Color( 255, 255, 255, Alpha1 ), TEXT_ALIGN_CENTER )
			end
		end

		if not self:GetlvsLockedStatus() then continue end

		local xLocker = SwapX and 35 + HiderOffset or -25 - HiderOffset

		if SwapY then
			if I == 1 then
				surface.SetDrawColor( 255, 255, 255, 255 )
				surface.SetMaterial( self.IconVehicleLocked  )
				surface.DrawTexturedRect( X + xPos + xLocker, yPos + I * 30, 25, 25 )
			end
		else
			if I == SeatCount then
				surface.SetDrawColor( 255, 255, 255, 255 )
				surface.SetMaterial( self.IconVehicleLocked  )
				surface.DrawTexturedRect( X + xPos + xLocker, yPos + I * 30, 25, 25 )
			end
		end
	end
end

--PATH lua/entities/lvs_base_fakehover/sh_camera_eyetrace.lua:
return gluapack()()
--PATH lua/entities/lvs_base_gunner/shared.lua:
return gluapack()()
--PATH lua/entities/lvs_base_starfighter/cl_flyby.lua:

ENT.FlyByAdvance = 0

function ENT:FlyByThink()
	local ply = LocalPlayer()

	if not IsValid( ply ) then return end

	local EntTable = self:GetTable()

	if ply:lvsGetVehicle() == self then self.OldApproaching = false return end

	local ViewEnt = ply:GetViewEntity()

	if not IsValid( ViewEnt ) then return end

	local Time = CurTime()

	if (EntTable._nextflyby or 0) > Time then return end

	EntTable._nextflyby = Time + 0.1

	local Vel = self:GetVelocity()

	if self:GetThrottle() <= 0.75 or Vel:Length() <= EntTable.MaxVelocity * 0.75 then return end

	local Sub = ViewEnt:GetPos() - self:GetPos() - Vel * EntTable.FlyByAdvance
	local ToPlayer = Sub:GetNormalized()
	local VelDir = Vel:GetNormalized()

	local ApproachAngle = math.deg( math.acos( math.Clamp( ToPlayer:Dot( VelDir ) ,-1,1) ) )

	local Approaching = ApproachAngle < 80

	if Approaching ~= EntTable.OldApproaching then
		EntTable.OldApproaching = Approaching

		if Approaching then
			self:StopFlyBy()
		else
			self:OnFlyBy( 60 + 80 * math.min(ApproachAngle / 140,1) )
		end
	end
end

function ENT:OnFlyBy( Pitch )
	if not self.FlyBySound then return end

	local EntTable = self:GetTable()

	EntTable.flybysnd = CreateSound( self, EntTable.FlyBySound )
	EntTable.flybysnd:SetSoundLevel( 95 )
	EntTable.flybysnd:PlayEx( 1, Pitch )
end

function ENT:StopFlyBy()
	local EntTable = self:GetTable()

	if not EntTable.flybysnd then return end

	EntTable.flybysnd:Stop()
	EntTable.flybysnd = nil
end
--PATH lua/entities/lvs_base_turret/cl_hud.lua:
return gluapack()()
--PATH lua/entities/lvs_base_turret/cl_hud.lua:
ENT.IconEngine = Material( "lvs/engine.png" )

function ENT:LVSHudPaintInfoText( X, Y, W, H, ScrX, ScrY, ply )
	local kmh = math.Round(self:GetVelocity():Length() * 0.09144,0)
	draw.DrawText( "km/h ", "LVS_FONT", X + 72, Y + 35, color_white, TEXT_ALIGN_RIGHT )
	draw.DrawText( kmh, "LVS_FONT_HUD_LARGE", X + 72, Y + 20, color_white, TEXT_ALIGN_LEFT )

	if ply ~= self:GetDriver() then return end

	--[[local Throttle = self:GetThrottle()
	local Col = Throttle <= 1 and color_white or Color(0,0,0,255)
	local hX = X + W - H * 0.5
	local hY = Y + H * 0.25 + H * 0.25

	surface.SetMaterial( self.IconEngine )
	surface.SetDrawColor( 0, 0, 0, 200 )
	surface.DrawTexturedRectRotated( hX + 4, hY + 1, H * 0.5, H * 0.5, 0 )
	surface.SetDrawColor( color_white )
	surface.DrawTexturedRectRotated( hX + 2, hY - 1, H * 0.5, H * 0.5, 0 )

	if not self:GetEngineActive() then
		draw.SimpleText( "X" , "LVS_FONT",  hX, hY, Color(0,0,0,255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end

	self:LVSDrawCircle( hX, hY, H * 0.35, math.min( Throttle, 1 ) )

	if Throttle > 1 then
		draw.SimpleText( "+"..math.Round((Throttle - 1) * 100,0).."%" , "LVS_FONT",  hX, hY, Col, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end]]
end

function ENT:LVSPreHudPaint( X, Y, ply )
	return true
end

function ENT:LVSHudPaint( X, Y, ply )
	if not self:LVSPreHudPaint( X, Y, ply ) then return end

	if ply ~= self:GetDriver() then return end

	local HitPlane = self:GetEyeTrace( true ).HitPos:ToScreen()
	local HitPilot = self:GetEyeTrace().HitPos:ToScreen()

	self:PaintCrosshairCenter( HitPlane )
	self:PaintCrosshairOuter( HitPilot )

	if ply:lvsMouseAim() and not ply:lvsKeyDown( "FREELOOK" ) then
		self:LVSHudPaintMouseAim( HitPlane, HitPilot )
	end

	self:LVSPaintHitMarker( HitPlane )
end

function ENT:LVSHudPaintDirectInput( Pos2D )
	self:PaintCrosshairCenter( Pos2D )
	self:PaintCrosshairOuter( Pos2D )
end

function ENT:LVSHudPaintMouseAim( HitPlane, HitPilot )
	local Sub = Vector(HitPilot.x,HitPilot.y,0) - Vector(HitPlane.x,HitPlane.y,0)
	local Len = Sub:Length()
	local Dir = Sub:GetNormalized()

	surface.SetDrawColor( 255, 255, 255, 100 )
	if Len > 20 then
		surface.DrawLine( HitPlane.x + Dir.x * 5, HitPlane.y + Dir.y * 5, HitPilot.x - Dir.x * 20, HitPilot.y- Dir.y * 20 )

		-- shadow
		surface.SetDrawColor( 0, 0, 0, 50 )
		surface.DrawLine( HitPlane.x + Dir.x * 5 + 1, HitPlane.y + Dir.y * 5 + 1, HitPilot.x - Dir.x * 20+ 1, HitPilot.y- Dir.y * 20 + 1 )
	end
end

--PATH addons/[tfres] lego vechicles/lua/entities/lvs_eta_advanced_lego/cl_init.lua:
return gluapack()()
--PATH addons/[tfres] lego vechicles/lua/entities/lvs_eta_advanced_lego/shared.lua:
return gluapack()()
--PATH lua/entities/lvs_fakehover_barc_medical/cl_init.lua:
include("shared.lua")


function ENT:DamageFX()
	self.nextDFX = self.nextDFX or 0

	if self.nextDFX < CurTime() then
		self.nextDFX = CurTime() + 0.05

		local HP = self:GetHP()
		local MaxHP = self:GetMaxHP()

		if HP > MaxHP * 0.5 then return end

		local effectdata = EffectData()
			effectdata:SetOrigin( self:LocalToWorld( Vector(-30,0,43) ) )
			effectdata:SetEntity( self )
		util.Effect( "lvs_engine_blacksmoke", effectdata )

		if HP <= MaxHP * 0.25 then
			local effectdata = EffectData()
				effectdata:SetOrigin( self:LocalToWorld( Vector(-25,32.5,20) ) )
				effectdata:SetNormal( self:GetUp() )
				effectdata:SetMagnitude( math.Rand(0.5,1.5) )
				effectdata:SetEntity( self )
			util.Effect( "lvs_exhaust_fire", effectdata )

			local effectdata = EffectData()
				effectdata:SetOrigin( self:LocalToWorld( Vector(-42.5,-32.5,20) ) )
				effectdata:SetNormal( self:GetUp() )
				effectdata:SetMagnitude( math.Rand(0.5,1.5) )
				effectdata:SetEntity( self )
			util.Effect( "lvs_exhaust_fire", effectdata )
		end
	end
end

function ENT:OnFrame()
	self:BTLProjector()
	self:DamageFX()
end

function ENT:BTLProjector()
	local Fire = self:GetBTLFire()

	if Fire == self.OldFireBTL then return end

	self.OldFireBTL = Fire
	
	if Fire then
		local effectdata = EffectData()
		effectdata:SetEntity( self )
		util.Effect( "lvs_muzzle_colorable", effectdata )
	end
end

function ENT:CalcViewOverride( ply, pos, angles, fov, pod )
	if ply == self:GetDriver() and not pod:GetThirdPersonMode() then
		return pos + self:GetForward() * 5 - self:GetUp() * -5, angles, fov
	end

	local GunnerPod = self:GetGunnerSeat()

	if pod == GunnerPod and pod:GetThirdPersonMode() then
		return GunnerPod:LocalToWorld( Vector(0,0,60) ), angles + Angle(6,0,0), fov
	end

	return pos, angles, fov
end

function ENT:RemoveLight()
	if IsValid( self.projector ) then
		self.projector:Remove()
		self.projector = nil
	end
end

function ENT:OnRemoved()
	self:RemoveLight()
end

function ENT:PreDraw()
	self:DrawDriverBTL()

	return true
end

ENT.LightMaterial = Material( "effects/lvs/laat_spotlight" )
ENT.GlowMaterial = Material( "sprites/light_glow02_add" )

function ENT:PreDrawTranslucent()
	if self:GetBodygroup( 2 ) ~= 1 then 
		self:RemoveLight()
		return false
	end

	if not IsValid( self.projector ) then
		local thelamp = ProjectedTexture()
		thelamp:SetBrightness( 10 ) 
		thelamp:SetTexture( "effects/flashlight/soft" )
		thelamp:SetColor( Color(255,255,255) ) 
		thelamp:SetEnableShadows( true ) 
		thelamp:SetFarZ( 2500 ) 
		thelamp:SetNearZ( 75 ) 
		thelamp:SetFOV( 60 )
		self.projector = thelamp
	end

	local Start1 = self:LocalToWorld( Vector(64,6,10.5) )
	local Start2 = self:LocalToWorld( Vector(64,-6,10.5) )

	local Dir1 = self:LocalToWorldAngles( Angle(0,5,0) ):Forward()
	local Dir2 = self:LocalToWorldAngles( Angle(0,-5,0) ):Forward()

	render.SetMaterial( self.GlowMaterial )
	render.DrawSprite( Start1, 32, 32, Color( 100, 100, 100, 255) )
	render.DrawSprite( Start2, 32, 32, Color( 100, 100, 100, 255) )

	render.SetMaterial( self.LightMaterial )
	render.DrawBeam( Start1,  Start1 + Dir1 * 400, 150, 0, 0.99, Color( 100, 100, 100, 5) ) 
	render.DrawBeam( Start2,  Start2 + Dir2 * 400, 150, 0, 0.99, Color( 100, 100, 100, 5) ) 

	if IsValid( self.projector ) then
		self.projector:SetPos( self:LocalToWorld( Vector(60,0,10.5) ) )
		self.projector:SetAngles( self:LocalToWorldAngles( Angle(15,0,0) ) )
		self.projector:Update()
	end

	return false
end

local COLOR_RED = Color(255,0,0,255)
local COLOR_WHITE = Color(255,255,255,255)

function ENT:LVSPreHudPaint( X, Y, ply )
	if self:GetIsCarried() then return false end

	if ply == self:GetDriver() then
		local Col = self:WeaponsInRange() and COLOR_WHITE or COLOR_RED

		local Pos2D = self:GetEyeTrace().HitPos:ToScreen() 

		self:PaintCrosshairCenter( Pos2D, Col )
		self:PaintCrosshairOuter( Pos2D, Col )
		self:LVSPaintHitMarker( Pos2D )
	end

	return true
end

function ENT:DrawDriverBTL()
	local pod = self:GetGunnerSeat()

	if not IsValid( pod ) then return end

	local plyL = LocalPlayer()
	local ply = pod:GetDriver()

	if not IsValid( ply ) or (ply == plyL and plyL:GetViewEntity() == plyL and not pod:GetThirdPersonMode()) then return end

	if self:GetBodygroup(1) == 2 then
		ply:SetSequence( "drive_airboat" )
		ply:SetRenderAngles( self:GetAngles() )
		ply:DrawModel()

		return
	end

	local ID = self:LookupAttachment( "lvs_muzzle_colorable" )
	local Muzzle = self:GetAttachment( ID )

	if not Muzzle then return end

	local _,Ang = LocalToWorld( Vector(0,0,0), Angle(-90,0,-90), Muzzle.Pos, Muzzle.Ang )

	local LAng = self:WorldToLocalAngles( Ang )
	LAng.p = 0
	LAng.r = 0

	ply:SetSequence( "drive_airboat" )
	ply:SetRenderAngles( self:LocalToWorldAngles( LAng ) )
	ply:DrawModel()
end


--PATH lua/entities/lvs_fakehover_barc_medical/shared.lua:
ENT.Type = "anim"
DEFINE_BASECLASS( "lunasflightschool_basescript_gunship" )
ENT.Base = "lvs_base_fakehover"

ENT.PrintName = "Republic BARC Stretcher"
ENT.Author = "Codexx"
ENT.Information = "BARC brr "
ENT.Category = "[LVS] Republic Vehicle"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/barc/barc.mdl"
ENT.GibModels = {
	"models/gibs/helicopter_brokenpiece_01.mdl",
	"models/gibs/helicopter_brokenpiece_02.mdl",
	"models/gibs/helicopter_brokenpiece_03.mdl",
	"models/combine_apc_destroyed_gib02.mdl",
	"models/combine_apc_destroyed_gib04.mdl",
	"models/combine_apc_destroyed_gib05.mdl",
	"models/props_c17/trappropeller_engine.mdl",
	"models/gibs/airboat_broken_engine.mdl",
}

ENT.AITEAM = 2

ENT.MaxHealth = 2700

ENT.ForceAngleMultiplier = 2
ENT.ForceAngleDampingMultiplier = 1

ENT.ForceLinearMultiplier = 1
ENT.ForceLinearRate = 0.25

ENT.MaxVelocityX = 950
ENT.MaxVelocityY = 950

ENT.MaxTurnRate = 0.8

ENT.BoostAddVelocityX = 260
ENT.BoostAddVelocityY = 260

ENT.GroundTraceHitWater = true
ENT.GroundTraceLength = 50
ENT.GroundTraceHull = 100

ENT.LAATC_PICKUPABLE = true
ENT.LAATC_DROP_IN_AIR = true
ENT.LAATC_PICKUP_POS = Vector(-200,0,25)
ENT.LAATC_PICKUP_Angle = Angle(0,0,0)


function ENT:OnSetupDataTables()
	self:AddDT( "Bool", "BTLFire" )
	self:AddDT( "Bool", "IsCarried" )
	self:AddDT( "Entity", "GunnerSeat" )

	if SERVER then
		self:NetworkVarNotify( "IsCarried", self.OnIsCarried )
	end
end

function ENT:GetAimAngles()
	local trace = self:GetEyeTrace()

	local AimAnglesR = self:WorldToLocalAngles( (trace.HitPos - self:LocalToWorld( Vector(-60,-51,43) ) ):GetNormalized():Angle() )
	local AimAnglesL = self:WorldToLocalAngles( (trace.HitPos - self:LocalToWorld( Vector(-60,51,43) ) ):GetNormalized():Angle() )

	return AimAnglesR, AimAnglesL
end

function ENT:WeaponsInRange()
	if self:GetIsCarried() then return false end

	local AimAnglesR, AimAnglesL = self:GetAimAngles()

	return not ((AimAnglesR.p >= 10 and AimAnglesL.p >= 10) or (AimAnglesR.p <= -25 and AimAnglesL.p <= -25) or (math.abs(AimAnglesL.y) + math.abs(AimAnglesL.y)) >= 30)
end

function ENT:InitWeapons()
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/dual_mg.png")
	weapon.Ammo = 400
	weapon.Delay = 0.25
	weapon.HeatRateUp = 0.5
	weapon.HeatRateDown = 1
	weapon.Attack = function( ent )
		local bullet = {}
		bullet.Dir 	= ent:GetForward()
		bullet.Spread 	= Vector( 0.015,  0.015, 0 )
		bullet.TracerName = "lvs_laser_blue_short"
		bullet.Force	= 10
		bullet.HullSize 	= 25
		bullet.Damage	= 40
		bullet.Velocity = 60000
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(50,50,255) ) 
				effectdata:SetOrigin( tr.HitPos )
				effectdata:SetNormal( tr.HitNormal )
			util.Effect( "lvs_laser_impact", effectdata )
		end

		for i = -1,1,2 do
			bullet.Src 	= ent:LocalToWorld( Vector(95,-15 * i,4) )
			
			local effectdata = EffectData()
			effectdata:SetStart( Vector(50,50,255) )
			effectdata:SetOrigin( bullet.Src )
			effectdata:SetNormal( ent:GetForward() )
			effectdata:SetEntity( ent )
			util.Effect( "lvs_muzzle_colorable", effectdata )

			ent:LVSFireBullet( bullet )

		end

		ent:TakeAmmo()

		ent.PrimarySND:PlayOnce( 100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav") end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	self:AddWeapon( weapon )

	

end

ENT.EngineSounds = {
	{
		sound = "lvs/vehicles/barc/loop.wav",
		Pitch = 70,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 30,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
		SoundLevel = 205,
	},
	{
		sound = "lvs/vehicles/barc/loop.wav",
		Pitch = 70,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 30,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
		SoundLevel = 85,
	},
	{
		sound = "lvs/vehicles/barc/loop.wav",
		Pitch = 70,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 30,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		SoundLevel = 90,
	},
}

--PATH lua/entities/lvs_fakehover_iftx/cl_prediction.lua:

function ENT:PredictPoseParamaters()
	local pod = self:GetGunnerSeat()

	if not IsValid( pod ) then return end

	local plyL = LocalPlayer()
	local ply = pod:GetDriver()

	if ply ~= plyL then return end

	self:SetPoseParameterBTL( pod:lvsGetWeapon() )

	self:InvalidateBoneCache()
end
--PATH lua/entities/lvs_fakehover_wheel.lua:
AddCSLuaFile()

ENT.Type            = "anim"

ENT.Spawnable       = false
ENT.AdminSpawnable  = false
ENT.DoNotDuplicate = true

function ENT:SetupDataTables()
	self:NetworkVar( "Entity",0, "Base" )
end

if SERVER then
	function ENT:Initialize()	
		self:SetModel( "models/props_vehicles/tire001c_car.mdl" )
		self:PhysicsInit( SOLID_VPHYSICS )
		self:SetMoveType( MOVETYPE_VPHYSICS )
		self:SetSolid( SOLID_VPHYSICS )
		self:DrawShadow( false )

		self:AddEFlags( EFL_NO_PHYSCANNON_INTERACTION )

		-- this is so vj npcs can still see us
		self:AddEFlags( EFL_DONTBLOCKLOS )

		self:SetCollisionGroup( COLLISION_GROUP_PASSABLE_DOOR )
	end

	function ENT:Define( data )
		self:PhysicsInitSphere( data.radius, "gmod_silent" )

		local VectorNull = Vector(0,0,0)

		self:SetCollisionBounds( VectorNull, VectorNull )

		local PhysObj = self:GetPhysicsObject()

		if IsValid( PhysObj ) then
			PhysObj:EnableDrag( false )
			PhysObj:EnableMotion( false )
			PhysObj:SetMass( data.mass )
			PhysObj:SetBuoyancyRatio( data.buoyancyratio )
		end
	end

	function ENT:SetPhysics( enable )
		if enable then
			if self.PhysicsEnabled then return end

			self:GetPhysicsObject():SetMaterial("jeeptire")
			self.PhysicsEnabled = true
		else
			if self.PhysicsEnabled == false then return end

			self:GetPhysicsObject():SetMaterial("friction_00")
			self.PhysicsEnabled = false
		end
	end

	function ENT:CheckPhysics()
		local base = self:GetBase()

		if not IsValid( base ) then return end

		if not base:GetEngineActive() then
			self:SetPhysics( true )

			self:NextThink( CurTime() + 0.25 )

			return
		end

		self:NextThink( CurTime() + 0.1 )

		local Ang = base:GetAngles()
		local steer = math.abs( base:WorldToLocalAngles( Angle(Ang.p,base:GetSteerTo(),Ang.r) ).y )
		local move = base:GetMove()
		local speed = base:GetVelocity():LengthSqr()

		local enable = (math.abs( move.x ) + math.abs( move.y )) < 0.001 and steer < 3 and speed < 600

		self:SetPhysics( enable )
	end

	function ENT:Think()
		self:CheckPhysics()

		return true
	end

	function ENT:OnTakeDamage( dmginfo )
		if dmginfo:IsDamageType( DMG_BLAST ) then return end

		local base = self:GetBase()

		if not IsValid( base ) then return end

		base:TakeDamageInfo( dmginfo )
	end

	return
end

function ENT:Initialize()
end

function ENT:Think()
	local T = CurTime()

	if (self._nextFX or 0) > T then return end

	self._nextFX = T + 0.02

	local base = self:GetBase()

	if not IsValid( base ) then return end

	if base:GetVelocity():Length() < 50 then return end

	local data = {
		start = self:LocalToWorld( self:OBBCenter() ),
		endpos = self:LocalToWorld( Vector(0,0,self:OBBMins().z - 10 ) ),
		filter = base:GetCrosshairFilterEnts(),
		mask = MASK_WATER
	}

	local traceWater = util.TraceLine( data )

	if not traceWater.Hit then
		return
	end

	local effectdata = EffectData()
		effectdata:SetOrigin( traceWater.HitPos )
		effectdata:SetEntity( base )
		effectdata:SetMagnitude( self:BoundingRadius() )
	util.Effect( "lvs_hover_water", effectdata )
end

function ENT:Draw()
end

function ENT:OnRemove()
end

--PATH lua/entities/lvs_laatle_patrolgunship_rep/cl_init.lua:
include("shared.lua")


ENT.LightGlow = Material( "sprites/light_glow02_add" )
ENT.LightMaterial = Material( "effects/lvs/laat_spotlight" )

function ENT:OnSpawn()
end

function ENT:OnFrame()
	self:AnimFins()
end

function ENT:StartWindSounds()
    self:StopWindSounds()

    if LocalPlayer():lvsGetVehicle() ~= self then return end

    self._WaterSFX = CreateSound( self, "LVS.Physics.Water" )
    self._WaterSFX:PlayEx(0,100)
end

function ENT:AnimFins()
end

function ENT:RemoveLight()
	if IsValid( self.projector ) then
		self.projector:Remove()
		self.projector = nil
	end
end

function ENT:OnRemoved()
	self:RemoveLight()
end

function ENT:PreDrawTranslucent()
	if self:GetSpotlightToggle() == false then 
		self:RemoveLight()
		return false
	end

	if not IsValid( self.projector ) then
		local thelamp = ProjectedTexture()
		thelamp:SetBrightness( 10 ) 
		thelamp:SetTexture( "effects/flashlight/soft" )
		thelamp:SetColor( Color(255,255,255) ) 
		thelamp:SetEnableShadows( false ) 
		thelamp:SetFarZ( 5000 ) 
		thelamp:SetNearZ( 75 ) 
		thelamp:SetFOV( 40 )
		self.projector = thelamp
	end

	local attachment = {
		Pos = Vector(170,0,30),
		Ang = Angle(135, 0, 0)
	}

	if attachment then
		local StartPos = self:LocalToWorld(attachment.Pos)
		local Dir = self:LocalToWorldAngles(attachment.Ang):Up()

		render.SetMaterial( self.LightGlow )
		render.DrawSprite( StartPos + Dir * 20, 200, 200, Color( 255, 255, 255, 255) )

		render.SetMaterial( self.LightMaterial )
		render.DrawBeam(  StartPos - Dir * 10,  StartPos + Dir * 1500, 350, 0, 0.99, Color( 255, 255, 255, 10) ) 
		
		if IsValid( self.projector ) then
			self.projector:SetPos( StartPos )
			self.projector:SetAngles( Dir:Angle() )
			self.projector:Update()
		end
	end

	return false
end

function ENT:CalcViewOverride(ply, pos, angles, fov, pod)

	if pod ~= self:GetDriverSeat() and pod ~= self:GetGunnerSeat() and not pod:GetThirdPersonMode() then
		return pod:LocalToWorld(Vector(0, 0, 68)), angles, fov
	end

	return pos, angles, fov
end 

function ENT:EngineEffects()
	if not self:GetEngineActive() then return end

	local T = CurTime()

	if (self.nextEFX or 0) > T then return end

	self.nextEFX = T + 0.01

	local THR = self:GetThrottle()

	local emitter = self:GetParticleEmitter( self:GetPos() )

	if not IsValid( emitter ) then return end

	for _, pos in pairs( self.EnginePos ) do
		local vOffset = self:LocalToWorld( pos )
		local vNormal = -self:GetForward()

		vOffset = vOffset + vNormal * 5

		local particle = emitter:Add( "effects/muzzleflash2", vOffset )

		if not particle then continue end

		particle:SetVelocity( vNormal * (math.Rand(500,1000) + self:GetBoost() * 10) + self:GetVelocity() )
		particle:SetLifeTime( 0 )
		particle:SetDieTime( 0.1 )
		particle:SetStartAlpha( 255 )
		particle:SetEndAlpha( 0 )
		particle:SetStartSize( math.Rand(15,25) )
		particle:SetEndSize( math.Rand(0,10) )
		particle:SetRoll( math.Rand(-1,1) * 100 )
		particle:SetColor( 0, 80, 255 )
	end
end

function ENT:OnStartBoost()
	self:EmitSound( "^lvs/vehicles/laat/boost_"..math.random(1,2)..".wav", 85 )
end

function ENT:OnStopBoost()
end
--PATH lua/entities/lvs_laatle_patrolgunship_rep/shared.lua:
return gluapack()()
--PATH lua/entities/lvs_pro/shared.lua:
ENT.Type = "anim"
ENT.Base = "lvs_base_fakehover"

ENT.PrintName = "J-1 Proton Cannon"
ENT.Author = "Dec"
ENT.Information = ""
ENT.Category = "[LVS] SW-Vehicles"

ENT.Spawnable		= true
ENT.AdminSpawnable	= false

ENT.RotorPos = Vector( 338, 0, 214 )

ENT.MDL = "models/jr/proton_cannon.mdl"
ENT.GibModels = {
	"models/gibs/helicopter_brokenpiece_01.mdl",
	"models/gibs/helicopter_brokenpiece_02.mdl",
	"models/gibs/helicopter_brokenpiece_03.mdl",
	"models/combine_apc_destroyed_gib02.mdl",
	"models/combine_apc_destroyed_gib04.mdl",
	"models/combine_apc_destroyed_gib05.mdl",
	"models/props_c17/trappropeller_engine.mdl",
	"models/gibs/airboat_broken_engine.mdl",
}


ENT.AITEAM = 1

ENT.MaxVelocityY = 0
ENT.BoostAddVelocityY = 0

ENT.ForceAngleMultiplier = 4
ENT.ForceAngleDampingMultiplier = 4

ENT.ForceLinearMultiplier = 0
ENT.ForceLinearRate = 0

ENT.MaxVelocityZ = 0
ENT.BoostAddVelocityZ = 0

ENT.MaxHealth = 2500
ENT.MaxShield = 0
ENT.MaxVelocityX = 0
ENT.BoostAddVelocitX = 0
ENT.IgnoreWater = false

ENT.MaxTurnRate = 1

ENT.GroundTraceLength = 50
ENT.GroundTraceHull = 100


function ENT:InitWeapons()

	self.perst = 0

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/missile.png")
	weapon.Ammo = 45
	weapon.Delay = 1.2
	weapon.HeatRateUp = 0.8
	weapon.HeatRateDown = 0.3
	weapon.Attack = function( ent )

		if self:GetBodygroup(1) == 1 then return end

		local veh = ent:GetVehicle()
		local Driver = ent:GetDriver()
		local pod = ent:GetDriverSeat()

		if not IsValid( pod ) then return end

		for i = 1, 1 do
			timer.Simple( (i / 2) * 0.2, function()
				if not IsValid( ent ) then return end
				
				if ent:GetAmmo() <= 0 then ent:SetHeat( 1 ) return end
	
				ent:TakeAmmo()

				local ID_1 = self:LookupAttachment( "muzzle" )
				local Muzzle1 = self:GetAttachment( ID_1 )
				
				local Pos = Muzzle1.Pos				
				local Dir =  (Muzzle1.Ang):Up()
				
				print(Dir)

				local trace = ent:GetEyeTrace()

				local projectile = ents.Create( "lvs_fall_missel_cis" )
				projectile:SetPos(Pos)
				projectile:SetAngles(Dir:Angle())
				projectile:SetParent()
				projectile:Spawn()
				projectile:Activate()
				projectile.GetTarget = function( missile ) return missile end
				projectile.GetTargetPos = function( missile )
					return missile:LocalToWorld( Vector(150,0,0) + VectorRand() * math.random(-10,10) )
				end
				projectile:SetAttacker( IsValid( Driver ) and Driver or self )
				projectile:SetEntityFilter( ent:GetCrosshairFilterEnts() )
				projectile:Enable()
				projectile:EmitSound( "vehicle/starwars/av7/av7fire.wav" )

				util.ScreenShake(self:GetPos(), 50, 50, 0.8, 2000, true )
				for i=1,10 do
					local effectdata = EffectData()
					effectdata:SetOrigin( self:GetPos() )
					effectdata:SetRadius(500 * 500)
					effectdata:SetScale(24 * 20)
					util.Effect( "ThumperDust", effectdata, true, true )
				end
				self:SetPos(self:GetPos() - self:GetForward() * 1.5)
				timer.Simple(1.5, function()
					if IsValid(self) then
						self:SetPos(self:GetPos() + self:GetForward() * 1.5)
					end
				end)
			end)
		end
	end
	weapon.OnThink = function( ent, active )
		self.perst = self.perst + 1

		if self.perst == 4 then
			self.perst = 0
		end

		if self.perst == 0 then
			local Driver = self:GetDriver()

			if self:GetAI() or IsValid( Driver ) then		
				
				local EyeAngles = Driver:EyeAngles()
			
				local Pitch =  EyeAngles.x
			
				if Pitch > 10 then 
					Pitch = 10
				end

				if Pitch < -35 then 
					Pitch = -35
				end
			
				local Pitch =  Pitch
			
				self:ManipulateBoneAngles(self:LookupBone("gun"), Angle(0, 0, Pitch))
			end
		end
	end
	weapon.HudPaint = function( ent, X, Y, ply )
		local Col = (ent:AngleBetweenNormal( ent:GetAimVector(), ent:GetForward() ) > 30) and COLOR_RED or COLOR_WHITE

		local Pos2D = ent:GetEyeTrace().HitPos:ToScreen() 

		local base = ent:GetVehicle()
		base:PaintCrosshairCenter( Pos2D, Col )
		base:PaintCrosshairOuter( Pos2D, Col )
		base:LVSPaintHitMarker( Pos2D )
	end
	weapon.OnSelect = function( ent )
		ent:EmitSound("weapons/shotgun/shotgun_cock.wav")
	end
	self:AddWeapon( weapon )

	
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/missile.png")
	weapon.Ammo = 25
	weapon.Delay = 0.8
	weapon.HeatRateUp = 0.8
	weapon.HeatRateDown = 0.5
	weapon.Attack = function( ent )

		if self:GetBodygroup(1) == 1 then return end


		local veh = ent:GetVehicle()
		local Driver = ent:GetDriver()

		local pod = ent:GetDriverSeat()

		if not IsValid( pod ) then return end

		for i = 1, 1 do
			timer.Simple( (i / 2) * 0.2, function()
				if not IsValid( ent ) then return end

				if ent:GetAmmo() <= 0 then ent:SetHeat( 1 ) return end
	
				ent:TakeAmmo()
				local ID_1 = self:LookupAttachment( "muzzle" )
				local Muzzle1 = self:GetAttachment( ID_1 )
				
				local Pos = Muzzle1.Pos
				local Dir =  (Muzzle1.Ang):Up()
			
				local projectile = ents.Create( "lvs_concussionmissile" )
				projectile:SetPos(Pos)
				projectile:SetAngles( Dir:Angle())
				projectile:SetParent()
				projectile:Spawn()
				projectile:Activate()
				projectile:SetDamage( 550 )
				projectile:SetRadius( 350 )
				projectile.GetTarget = function( missile ) return missile end
				projectile.GetTargetPos = function( missile )
					return missile:LocalToWorld( Vector(150,0,0) + VectorRand() * math.random(-1,1) )
				end
				projectile:SetAttacker( IsValid( Driver ) and Driver or self )
				projectile:SetEntityFilter( ent:GetCrosshairFilterEnts() )
				projectile:Enable()
				projectile:EmitSound( "vehicle/starwars/av7/av7fire.wav" )

				util.ScreenShake(self:GetPos(), 50, 50, 0.3, 2000, true )
				for i=1,10 do
					local effectdata = EffectData()
					effectdata:SetOrigin( self:GetPos() )
					effectdata:SetRadius(500 * 500)
					effectdata:SetScale(24 * 20)
					util.Effect( "ThumperDust", effectdata, true, true )
				end
				self:SetPos(self:GetPos() - self:GetForward() * 1.5)
				timer.Simple(1.5, function()
					if IsValid(self) then
						self:SetPos(self:GetPos() + self:GetForward() * 1.5)
					end
				end)
			end)
		end
	end
	weapon.HudPaint = function( ent, X, Y, ply )
		local Col = (ent:AngleBetweenNormal( ent:GetAimVector(), ent:GetForward() ) > 30) and COLOR_RED or COLOR_WHITE

		local Pos2D = ent:GetEyeTrace().HitPos:ToScreen() 

		local base = ent:GetVehicle()
		base:PaintCrosshairCenter( Pos2D, Col )
		base:PaintCrosshairOuter( Pos2D, Col )
		base:LVSPaintHitMarker( Pos2D )
	end
	weapon.OnThink = function( ent, active )
		--[[local Driver = self:GetDriver()
		
		if not IsValid( Driver ) then return end
	
		local EyeAngles = Driver:EyeAngles()
	
		local Pitch =  EyeAngles.x
	
		if Pitch > 20 then 
			Pitch = 20
		end
	
		local Pitch =  -Pitch
	
		self:ManipulateBoneAngles(self:LookupBone("gun"), Angle(0, Pitch, 0))]]--
	end
	weapon.OnSelect = function( ent )
		ent:EmitSound("weapons/shotgun/shotgun_cock.wav")
	end
	self:AddWeapon( weapon )

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/gunship_reardoor.png")
	weapon.Ammo = -1
	weapon.Delay = 0
	weapon.HeatRateUp = 0
	weapon.HeatRateDown = 0
	weapon.StartAttack = function( ent )
		if self:GetAI() == true then return end 
		if (self.gateDown) then
			self.gateDown = false
			self:SetBodygroup(1, 0)
			ent.MaxVelocityY = 0
			ent.BoostAddVelocityY = 0
			ent.MaxVelocityX = 0
			ent.BoostAddVelocitX = 0
			ent.ForceLinearMultiplier = 0
			ent.ForceLinearRate = 0
		else
			self:SetBodygroup(1, 1)
			self.gateDown = true
			ent.MaxVelocityY = 100
			ent.BoostAddVelocityY = 150
			ent.MaxVelocityX = 200
			ent.BoostAddVelocitX = 300	
			ent.ForceLinearMultiplier = 2
			ent.ForceLinearRate = 0.8
		end

		self:EmitSound("lvs/vehicles/laat/door_large_open.wav")
	end
	self:AddWeapon( weapon )
end

ENT.EngineSounds = {
	{
		sound = "lvs/vehicles/iftx/loop.wav",
		Pitch = 70,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 30,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
		SoundLevel = 85,
	},
	{
		sound = "lvs/vehicles/iftx/loop_hi.wav",
		Pitch = 70,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 30,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
		SoundLevel = 85,
	},
	{
		sound = "lvs/vehicles/iftx/dist.wav",
		Pitch = 70,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 30,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		SoundLevel = 90,
	},
}


--PATH lua/entities/lvs_repulsorlift_gunship/sh_mainweapons.lua:
function ENT:InitWeaponDriver()
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/dual_mg.png")
	weapon.Ammo = 600
	weapon.Delay = 0.25
	weapon.HeatRateUp = 0
	weapon.HeatRateDown = 1
	weapon.Attack = function( ent )
		if math.abs( ent.frontgunYaw ) > 100 then return end

		local ID_L = self:LookupAttachment( "muzzle_frontgun_left" )
		local ID_R = self:LookupAttachment( "muzzle_frontgun_right" )
		local Muzzle = {
			[1] = self:GetAttachment( ID_L ),
			[2] = self:GetAttachment( ID_R ),
		}

		local NewHeat = ent:GetHeat()

		for id = 1, 2 do
			if id == 1 and ent.frontgunYaw > 5 then continue end
			if id == 2 and ent.frontgunYaw < -5 then continue end

			local att = Muzzle[ id ]

			local bullet = {}
			bullet.Src 	= att.Pos
			bullet.Dir 	= att.Ang:Up()
			bullet.Spread 	= Vector( 0.015,  0.015, 0 )
			bullet.TracerName = "lvs_laser_green"
			bullet.Force	= 10
			bullet.HullSize 	= 25
			bullet.Damage	= 40
			bullet.Velocity = 60000
			bullet.Attacker 	= ent:GetDriver()
			bullet.Callback = function(att, tr, dmginfo)
				local effectdata = EffectData()
					effectdata:SetStart( Vector(50,255,50) ) 
					effectdata:SetOrigin( tr.HitPos )
					effectdata:SetNormal( tr.HitNormal )
				util.Effect( "lvs_laser_impact", effectdata )
			end

			ent:LVSFireBullet( bullet )
			ent:TakeAmmo()

			NewHeat = NewHeat + 0.075
		end

		ent:SetHeat( NewHeat )

		if NewHeat >= 1 then
			ent:SetOverheated( true )
		end

		ent.PrimarySND:PlayOnce( 100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav") end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	weapon.OnThink = function( ent, active )
		local trace = ent:GetEyeTrace()

		local AimAngles = ent:WorldToLocalAngles( (trace.HitPos - self:LocalToWorld(  Vector(256,0,36) ) ):GetNormalized():Angle() )

		ent.frontgunYaw = -AimAngles.y

		if math.abs( ent.frontgunYaw ) > 100 then
			ent:SetPoseParameter("frontgun_pitch", 0 )
			ent:SetPoseParameter("frontgun_yaw", 0 )

			return
		end

		ent:SetPoseParameter("frontgun_pitch", -AimAngles.p )
		ent:SetPoseParameter("frontgun_yaw", -AimAngles.y )
	end
	self:AddWeapon( weapon )



	local weapon = {}
	weapon.Icon = Material("lvs/weapons/protontorpedo.png")
	weapon.Ammo = 26
	weapon.Delay = 0 -- this will turn weapon.Attack to a somewhat think function
	weapon.HeatRateUp = -0.5 -- cool down when attack key is held. This system fires on key-release.
	weapon.HeatRateDown = 0.25
	weapon.Attack = function( ent )
		local T = CurTime()

		if IsValid( ent._ProtonTorpedo ) then
			if (ent._nextMissleTracking or 0) > T then return end

			ent._nextMissleTracking = T + 0.1 -- 0.1 second interval because those find functions can be expensive

			ent._ProtonTorpedo:FindTarget( ent:GetPos(), ent:GetForward(), 30, 7500 )

			if IsValid( ent._ProtonTorpedo:GetTarget() ) then
				ent:SetBodygroup( 1, 1 )
			end

			return
		end

		local T = CurTime()

		if (ent._nextMissle or 0) > T then return end

		ent._nextMissle = T + 0.5

		ent._swapMissile = not ent._swapMissile

		local TypeA = self:GetBodygroup( 3 ) == 0
		local Pos = Vector( (TypeA and -20 or 206.07), (ent._swapMissile and -59 or 59), 286.88 )

		local Driver = self:GetDriver()

		local projectile = ents.Create( TypeA and "lvs_protontorpedo" or "lvs_concussionmissile" )
		projectile:SetPos( ent:LocalToWorld( Pos ) )
		projectile:SetAngles( ent:GetAngles() )
		projectile:SetParent( ent )
		projectile:Spawn()
		projectile:Activate()
		projectile:SetAttacker( IsValid( Driver ) and Driver or self )
		projectile:SetEntityFilter( ent:GetCrosshairFilterEnts() )

		ent._ProtonTorpedo = projectile
		ent._TypeA = TypeA

		ent:SetNextAttack( CurTime() + 0.1 ) -- wait 0.1 second before starting to track
	end
	weapon.FinishAttack = function( ent )
		ent:SetBodygroup( 1, 0 )

		if not IsValid( ent._ProtonTorpedo ) then return end

		local projectile = ent._ProtonTorpedo

		projectile:Enable()
		projectile:EmitSound( self._TypeA and "lvs/vehicles/naboo_n1_starfighter/proton_fire.mp3" or "lvs/vehicles/vulturedroid/fire_missile.mp3", 125 )
		ent:TakeAmmo()

		ent._ProtonTorpedo = nil

		local NewHeat = ent:GetHeat() + 0.33

		ent:SetHeat( NewHeat )
		if NewHeat >= 1 then
			ent:SetOverheated( true )
		end
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav") end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	self:AddWeapon( weapon )



	local weapon = {}
	weapon.Icon = Material("lvs/weapons/gunship_sidedoor.png")
	weapon.Ammo = -1
	weapon.Delay = 0
	weapon.HeatRateUp = 0
	weapon.HeatRateDown = 0
	weapon.StartAttack = function( ent )
		local T = CurTime()

		if (ent.NextDoor or 0) > T then return end

		if ent:GetBodygroup( 2 ) == 0 then
			local DoorMode = ent:GetDoorMode() + 1

			ent:SetDoorMode( DoorMode )
			
			if DoorMode == 1 then
				ent:EmitSound( "lvs/vehicles/laat/door_open.wav" )
			end
			
			if DoorMode == 2 then
				ent.NextDoor = T + 1

				ent:PlayAnimation( "doors_open" )
				ent:EmitSound( "lvs/vehicles/laat/door_large_open.wav" )
			end
			
			if DoorMode == 3 then
				ent:PlayAnimation( "doors_close" )
				ent:EmitSound( "lvs/vehicles/laat/door_large_close.wav" )
			end
			
			if DoorMode >= 4 then
				ent:SetDoorMode( 0 )
				ent:EmitSound( "lvs/vehicles/laat/door_close.wav" )

				ent.NextDoor = T + 1
			end
		else
			ent.NextDoor = T + 1

			local DoorMode = ent:GetDoorMode() + 1

			ent:SetDoorMode( DoorMode )

			if DoorMode == 1 then
				ent:PlayAnimation( "doors_open" )
				ent:EmitSound( "lvs/vehicles/laat/door_large_open.wav" )
			end
			
			if DoorMode >= 2 then
				ent:PlayAnimation( "doors_close" )
				ent:EmitSound( "lvs/vehicles/laat/door_large_close.wav" )
				ent:SetDoorMode( 0 )
			end
		end

		ent:OnDoorsChanged()
	end
	self:AddWeapon( weapon )


	local weapon = {}
	weapon.Icon = Material("lvs/weapons/gunship_reardoor.png")
	weapon.Ammo = -1
	weapon.Delay = 0
	weapon.HeatRateUp = 0
	weapon.HeatRateDown = 0
	weapon.StartAttack = function( ent )
		local T = CurTime()

		if (ent.NextDoor or 0) > T then return end

		ent.NextDoor = T + 1

		local ToggleHatch = not ent:GetRearHatch()

		ent:SetRearHatch( ToggleHatch )
		
		if ToggleHatch then
			ent:EmitSound( "lvs/vehicles/laat/door_open.wav" )
		else
			ent:EmitSound( "lvs/vehicles/laat/door_close.wav" )
		end

		ent:OnDoorsChanged()
	end
	self:AddWeapon( weapon )
end
--PATH lua/entities/lvs_space_laat/shared.lua:

ENT.Base = "lvs_base_repulsorlift"

ENT.PrintName = "LAAT-I Space"
ENT.Author = "Dec"
ENT.Information = "Spaace version of the LAAT"
ENT.Category = "[LVS] SW-Vehicles"

ENT.VehicleCategory = "Star Wars"
ENT.VehicleSubCategory = "Starfighters"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/fisher/laat/laatspace.mdl"
ENT.GibModels = {
	"models/gibs/helicopter_brokenpiece_01.mdl",
	"models/gibs/helicopter_brokenpiece_02.mdl",
	"models/gibs/helicopter_brokenpiece_03.mdl",
	"models/combine_apc_destroyed_gib02.mdl",
	"models/combine_apc_destroyed_gib04.mdl",
	"models/combine_apc_destroyed_gib05.mdl",
	"models/props_c17/trappropeller_engine.mdl",
	"models/gibs/airboat_broken_engine.mdl",
}

ENT.DamageSounds = {
	"physics/metal/metal_sheet_impact_bullet2.wav",
	"physics/metal/metal_sheet_impact_hard2.wav",
	"physics/metal/metal_sheet_impact_hard6.wav",
}

ENT.AITEAM = 2

ENT.MaxVelocity = 2650
ENT.MaxThrust = 2650

ENT.ThrustVtol = 55
ENT.ThrustRateVtol = 3

ENT.TurnRatePitch = 1
ENT.TurnRateYaw = 1
ENT.TurnRateRoll = 1.25

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1
ENT.ForceAngleDampingMultiplier = 1

ENT.MaxHealth = 6000
ENT.MaxShield = 0

function ENT:OnSetupDataTables()
	self:AddDT( "Bool", "WingTurretFire" )
	self:AddDT( "Vector", "WingTurretTarget" )
	self:NetworkVar( "Int", 23, "LampMode" )
	self:AddDT( "Float", "Activetime" )
	self:AddDT( "Bool", "Foils" )
	self:AddDT( "Entity", "GunnerSeat" )
	self:AddDT( "Entity", "SecondGunnerSeat" )
	self:NetworkVar( "Bool", 24, "SpotlightOn" )
	self:AddDT( "Bool", "SpotlightToggle" )
end

ENT.FlyByAdvance = 0.5
ENT.FlyBySound = "laat_bf2/laat_takeoff.wav" 
ENT.DeathSound = "lvs/vehicles/generic_starfighter/crash.wav"

function ENT:CalcMainActivity( ply )
	local Pod = ply:GetVehicle()

	if Pod == self:GetDriverSeat() or Pod == self:GetGunnerSeat() then return end

	ply.CalcIdeal = ACT_STAND
	ply.CalcSeqOverride = ply:LookupSequence( "idle_all_02" )

	if ply:GetAllowWeaponsInVehicle() and IsValid( ply:GetActiveWeapon() ) then

		local holdtype = ply:GetActiveWeapon():GetHoldType()

		if holdtype == "smg" then 
			holdtype = "smg1"
		end

		local seqid = ply:LookupSequence( "idle_" .. holdtype )

		if seqid ~= -1 then
			ply.CalcSeqOverride = seqid
		end
	end

	return ply.CalcIdeal, ply.CalcSeqOverride
end

ENT.EngineSounds = {
	{
		sound = "laat_bf2/engine_loop.mp3",
		Pitch = 90,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 30,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		SoundLevel = 85,
	},
	{
		sound = "laat_bf2/laat_loop.wav",
		Pitch = 70,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 30,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
		SoundLevel = 75,
	},
}

sound.Add( {
	name = "LAAT_FIREMISSILE",
	channel = CHAN_WEAPON,
	volume = 1.0,
	level = 125,
	pitch = {95, 105},
	sound = "laat_bf2/rocket_shot.mp3"
} )


function ENT:SetNextRearGunFire( delay )
	self._NextRGFire = CurTime() + delay
end

function ENT:CanFireRearGun()
	return (self._NextRGFire or 0) < CurTime()
end

function ENT:GetRearGunInRange( ent )
	return ent:AngleBetweenNormal( ent:GetAimVector(), -ent:GetForward() ) < 35
end

function ENT:HandleRearGun( ent, ShouldFire )

	local trace = ent:GetEyeTrace()

	local Pos,Ang = WorldToLocal( Vector(100,0,0), (trace.HitPos - self:LocalToWorld( Vector(-400,0,158.5)) ):GetNormalized():Angle(), Vector(0,0,0), self:LocalToWorldAngles( Angle(0,180,0) ) )

	if not self:GetRearGunInRange( ent ) then 
		self:SetPoseParameter("back_turret_y", 0 )

		return false
	end

	self:SetPoseParameter("back_turret_z", Ang.p )
	self:SetPoseParameter("back_turret_y", -Ang.y )

	if not ShouldFire or not self:CanFireRearGun() then self:GetRearGunInRange( ent ) return end

	local startpos = self:GetBonePosition(self:LookupBone("Rear_Gun_End"))

	self:SetNextRearGunFire( 0.2 )

	local bullet = {}
	bullet.Src 	= ent:LocalToWorld( Vector(-500,0 ,-20) )
	bullet.Dir 	= (trace.HitPos - bullet.Src):GetNormalized()
	bullet.Spread 	= Vector( 0.03,  0.03, 0.03 )
	bullet.TracerName = "lvs_laser_green_short"
	bullet.Force	= 10
	bullet.HullSize 	= 25
	bullet.Damage	= 65
	bullet.Velocity = 20000
	bullet.Attacker 	= ent:GetDriver()
	bullet.Callback = function(att, tr, dmginfo)
		local effectdata = EffectData()
			effectdata:SetStart( Vector(50,255,50) ) 
			effectdata:SetOrigin( tr.HitPos )
			effectdata:SetNormal( tr.HitNormal )
		util.Effect( "lvs_laser_impact", effectdata )
	end
	ent:LVSFireBullet( bullet )

	local NewHeat = ent:GetHeat() + 0.2


	ent:SetHeat( NewHeat )
	if NewHeat >= 1 then
		ent:SetOverheated( true )
	end

	if not IsValid( self.SNDTail ) then return end

	self.SNDTail:PlayOnce( 100 + math.Rand(-3,3), 1 )
end

function ENT:GetEyeTrace()
	local startpos = self:GetPos()

	local pod = self:GetDriverSeat()

	if IsValid( pod ) then
		startpos = pod:LocalToWorld( Vector(100,0,103) )
	end

	local trace = util.TraceLine( {
		start = startpos,
		endpos = (startpos + self:GetAimVector() * 50000),
		filter = self:GetCrosshairFilterEnts()
	} )

	return trace
end

function ENT:InitWeapons()
	local COLOR_RED = Color(255,0,0,255)
	local COLOR_WHITE = Color(255,255,255,255)
	local MaxRange = 60
	local MaxTailRange = 35

	self.lor = 1

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/dual_mg.png")
	weapon.Ammo = 600
	weapon.Delay = 0.18
	weapon.HeatRateUp = 0.1
	weapon.HeatRateDown = 0.1
	weapon.Attack = function( ent )
		local pod = ent:GetDriverSeat()

		if not IsValid( pod ) then return end

		if ent:AngleBetweenNormal( ent:GetAimVector(), ent:GetForward() ) >= 20 then return true end

		local startpos = pod:LocalToWorld( pod:OBBCenter() )
		local trace = ent:GetEyeTrace()

		local bullet = {}
		bullet.Spread 	= Vector( 0.02,  0.02, 0.02 )
		bullet.TracerName = "lvs_laser_green"
		bullet.Force	= 10
		bullet.HullSize 	= 25
		bullet.Damage	= 60
		bullet.SplashDamage = 200
		bullet.SplashDamageRadius = 200
		bullet.Velocity = 28000
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(50,255,50) ) 
				effectdata:SetOrigin( tr.HitPos )
				effectdata:SetNormal( tr.HitNormal )
			util.Effect( "lvs_laser_impact", effectdata )
		end
	
		for i = -1,1,2 do
			bullet.Src 	= ent:LocalToWorld( Vector(320,32 * i,37) )
			bullet.Dir 	= (trace.HitPos - bullet.Src):GetNormalized()
			local effectdata = EffectData()
			effectdata:SetStart( Vector(50,255,50) )
			effectdata:SetOrigin( bullet.Src )
			effectdata:SetNormal( ent:GetForward() )
			effectdata:SetEntity( ent )
				
			ent:LVSFireBullet( bullet )
		end

		ent:TakeAmmo()

		ent.PrimarySND:PlayOnce( 100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav") end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	weapon.OnThink = function( ent, active )
		local trace = ent:GetEyeTrace()

		local AimAngles = ent:WorldToLocalAngles( (trace.HitPos - self:LocalToWorld(  Vector(256,0,36) ) ):GetNormalized():Angle() )

		ent.frontgunYaw = -AimAngles.y

		if math.abs( ent.frontgunYaw ) > 100 then
			ent:SetPoseParameter("Front_Turret_Z", 0 )
			ent:SetPoseParameter("Front_Turret_Y", 0 )

			return
		end

		ent:SetPoseParameter("Front_Turret_Z", AimAngles.p )
		ent:SetPoseParameter("Front_Turret_Y", -AimAngles.y )
	end
	self:AddWeapon( weapon )

	self:AddWeapon( LVS:GetWeaponPreset( "TURBO" ) )

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/laserbeam.png")
	weapon.Ammo = -1
	weapon.Delay = 0
	weapon.HeatRateUp = 0.4
	weapon.HeatRateDown = 0
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	weapon.StartAttack = function( ent )
		ent.ShouldFire = true
	end
	weapon.FinishAttack = function( ent )
		ent.ShouldFire = false

		local base = ent:GetVehicle()

		local snd = {
			[-1] = base.WingLeftSND,
			[1] = base.WingRightSND,
		}

		for _, sound in pairs( snd ) do
			if not IsValid( sound ) then continue end

			sound:Stop()
		end
	end
	weapon.OnThink = function( ent, active )
		local base = ent:GetVehicle()

		local ShouldFire = (ent.ShouldFire == true) and ent:AngleBetweenNormal( ent:GetAimVector(), ent:GetForward() ) < MaxRange
	
		if base:HandleRearGun( ent, ent.ShouldFire ) then
			ShouldFire = false
		end

		if base:SetWingTurretFire() ~= ShouldFire then
			base:SetWingTurretFire( ShouldFire ) 
		end

		local snd = {
			[-1] = base.WingLeftSND,
			[1] = base.WingRightSND,
		}

		if ent._oldShouldFire ~= ShouldFire then
			ent._oldShouldFire = ShouldFire
			if ShouldFire then
				for _, sound in pairs( snd ) do
					if not IsValid( sound ) then continue end

					sound:EmitSound( "lvs/vehicles/laat/ballturret_fire.mp3", 110 )
				end
			end
		end

		if not ShouldFire then
			for _, sound in pairs( snd ) do
				if not IsValid( sound ) then continue end
				sound:Stop()
			end

			ent:SetHeat( ent:GetHeat() - FrameTime() )

			return
		end
	
		if not active then
			return
		end

		local trace = ent:GetEyeTrace()
		local DesEndPos = trace.HitPos

		base:SetWingTurretTarget( DesEndPos )

		if not base:GetWingTurretFire() then return end
		
		local DesStartPos --= Vector(-55, 350, 90)

		if base:WorldToLocal( DesEndPos ).z < 0 then
			DesStartPos = Vector(-55, 350, 90)
		else
			DesStartPos = Vector(-55, 370, 125)
		end

		local NewHeat = ent:GetHeat()

		for i = -1,1,2 do
			local StartPos = self:LocalToWorld( DesStartPos * Vector(1,i,1)  )
			local beam = util.TraceLine( { start = StartPos, endpos = DesEndPos} )

			self:BallturretDamage( beam.Entity, ent:GetDriver(), trace.HitPos, (trace.HitPos - StartPos):GetNormalized() )

			if not IsValid( snd[i] ) then continue end

			if beam.Entity ~= base then
				snd[i]:Play()
				NewHeat = NewHeat + FrameTime() * 0.25
			else
				snd[i]:Stop()
			end
		end

		ent:SetHeat( NewHeat )
		if NewHeat >= 1 then
			ent:SetOverheated( true )
		end
	end
	weapon.CalcView = function( ent, ply, pos, angles, fov, pod )
		local base = ent:GetVehicle()

		local view = {}
		view.origin = pos
		view.angles = angles
		view.fov = fov
		view.drawviewer = false

		if not IsValid( base ) then return view end

		local radius = 800
		radius = radius + radius * pod:GetCameraDistance()

		local clamped_angles = pod:WorldToLocalAngles( angles )
		clamped_angles.p = math.max( clamped_angles.p, -20 )
		clamped_angles = pod:LocalToWorldAngles( clamped_angles )

		local StartPos = base:LocalToWorld( base:OBBCenter() ) + clamped_angles :Up() * (350 + radius * pod:GetCameraHeight())
		local EndPos = StartPos - clamped_angles:Forward() * radius

		local WallOffset = 4

		local tr = util.TraceHull( {
			start = StartPos,
			endpos = EndPos,
			filter = function( e )
				local c = e:GetClass()
				local collide = not c:StartWith( "prop_physics" ) and not c:StartWith( "prop_dynamic" ) and not c:StartWith( "prop_ragdoll" ) and not e:IsVehicle() and not c:StartWith( "gmod_" ) and not c:StartWith( "player" ) and not e.LVS
				
				return collide
			end,
			mins = Vector( -WallOffset, -WallOffset, -WallOffset ),
			maxs = Vector( WallOffset, WallOffset, WallOffset ),
		} )

		view.drawviewer = true
		view.origin = tr.HitPos

		if tr.Hit and not tr.StartSolid then
			view.origin = view.origin + tr.HitNormal * WallOffset
		end

		return view
	end
	weapon.HudPaint = function( ent, X, Y, ply )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		local WingInRange = ent:AngleBetweenNormal( ent:GetAimVector(), ent:GetForward() ) >= MaxRange
		local RearGunInRange = not base:GetRearGunInRange( ent )

		local Col = (WingInRange and RearGunInRange) and COLOR_RED or COLOR_WHITE

		local Pos2D = ent:GetEyeTrace().HitPos:ToScreen() 

		base:PaintCrosshairCenter( Pos2D, Col )
		base:PaintCrosshairOuter( Pos2D, Col )
		base:LVSPaintHitMarker( Pos2D )
	end
	self:AddWeapon( weapon, 2 )

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/protontorpedo.png")
	weapon.Ammo = 10
	weapon.Delay = 0 
	weapon.HeatRateUp = 1
	weapon.HeatRateDown = 0.25
	weapon.Attack = function( ent )

		local T = CurTime()
		local pos = 0
		if IsValid( ent._ProtonTorpedo ) then
			if (ent._nextMissleTracking or 0) > T then return end

			ent._nextMissleTracking = T + 0.1 -- 0.1 second interval because those find functions can be expensive

			ent._ProtonTorpedo:FindTarget( ent:GetPos(), ent:GetForward(), 30, 7500 )

			return
		end

		local T = CurTime()

		if self.lor == 1 then
			pos = Vector(-63.81,-263.11,132.86)
			self.lor = 2
		else
			pos = Vector(-65.8,271.86,131.86)
			self.lor = 1
		end

		if (ent._nextMissle or 0) > T then return end

		ent._nextMissle = T + 0.5

		local Driver = self:GetDriver()

		local projectile = ents.Create( "lvs_concussionmissile" )
		projectile:SetPos( self:LocalToWorld( pos ) )
		projectile:SetAngles( ent:GetAngles() )
		projectile:SetParent( ent )
		projectile:Spawn()
		projectile:Activate()
		projectile:SetDamage( 1250 )
		projectile:SetRadius( 350 )
		projectile:SetAttacker( IsValid( Driver ) and Driver or self )
		projectile:SetEntityFilter( ent:GetCrosshairFilterEnts() )

		ent._ProtonTorpedo = projectile

		ent:SetNextAttack( CurTime() + 0.2 )
	end
	weapon.FinishAttack = function( ent )
		if not IsValid( ent._ProtonTorpedo ) then return end

		local projectile = ent._ProtonTorpedo

		projectile:Enable()
		projectile:EmitSound( "lvs/vehicles/vulturedroid/fire_missile.mp3", 125 )
		ent:TakeAmmo()

		ent._ProtonTorpedo = nil

		local NewHeat = ent:GetHeat() + 0.75

		ent:SetHeat( NewHeat )
		if NewHeat >= 1 then
			ent:SetOverheated( true )
		end
	end
	weapon.HudPaint = function( ent, X, Y, ply )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		local WingInRange = ent:AngleBetweenNormal( ent:GetAimVector(), ent:GetForward() ) >= MaxRange
		local RearGunInRange = not base:GetRearGunInRange( ent )

		local Col = (WingInRange and RearGunInRange) and COLOR_RED or COLOR_WHITE

		local Pos2D = ent:GetEyeTrace().HitPos:ToScreen() 

		base:PaintCrosshairCenter( Pos2D, Col )
		base:PaintCrosshairOuter( Pos2D, Col )
		base:LVSPaintHitMarker( Pos2D )
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav") end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	self:AddWeapon( weapon )

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/protontorpedo.png")
	weapon.Ammo = 40
	weapon.Delay = 2
	weapon.HeatRateUp = 1 
	weapon.HeatRateDown = 0.08
	weapon.Attack = function( ent )


		--if not ent:WeaponsInRange() then return true end
		local veh = ent:GetVehicle()
		local Driver = ent:GetDriver()

		local pod = ent:GetDriverSeat()

		if not IsValid( pod ) then return end

		local dir = ent:GetAimVector()

		if ent:AngleBetweenNormal( dir, ent:GetForward() ) > 100 then return true end

		for i = 1, 2 do
			timer.Simple( (i / 7) * 0.1, function()
				if not IsValid( ent ) then return end


				if self.lor == 1 then
					pos = Vector(99.71,69.93,276.31)
					self.lor = 2
				else
					pos = Vector(88.08,-69.92,276.24)
					self.lor = 1
				end

				if ent:GetAmmo() <= 0 then ent:SetHeat( 1 ) return end
	
				ent:TakeAmmo()

				local trace = ent:GetEyeTrace()
				local Start = pos
				local Dir = (ent:GetEyeTrace().HitPos - veh:LocalToWorld(Start)):GetNormalized()
				local projectile = ents.Create( "lvs_protontorpedo" )
				projectile:SetPos(veh:LocalToWorld(Start))
				projectile:SetAngles( ent:GetAngles() )
				projectile:SetParent( )
				projectile:Spawn()
				projectile:Activate()
				projectile.GetTarget = function( missile ) return missile end
				projectile.GetTargetPos = function( missile )
					return missile:LocalToWorld( Vector(150,0,0) + VectorRand() * math.random(-5,5) )
				end
				projectile:SetAttacker( IsValid( Driver ) and Driver or self )
				projectile:SetEntityFilter( ent:GetCrosshairFilterEnts() )
				projectile:SetDamage( 1250 )
				projectile:SetRadius( 550 )
				projectile:Enable()
				projectile:EmitSound("LAAT_FIREMISSILE" )
			end)
			self.RocketsModel:ResetSequence("Load_Missile")

		end
	end
	weapon.FinishAttack = function( ent )
	end
	weapon.HudPaint = function( ent, X, Y, ply )
		local base = ent:GetVehicle()
	
		if not IsValid( base ) then return end
	
		local WingInRange = ent:AngleBetweenNormal( ent:GetAimVector(), ent:GetForward() ) >= MaxRange
		local RearGunInRange = not base:GetRearGunInRange( ent )
	
		local Col = (WingInRange and RearGunInRange) and COLOR_RED or COLOR_WHITE
	
		local Pos2D = ent:GetEyeTrace().HitPos:ToScreen() 
	
		base:PaintCrosshairCenter( Pos2D, Col )
		base:PaintCrosshairOuter( Pos2D, Col )
		base:LVSPaintHitMarker( Pos2D )
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav") end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	self:AddWeapon( weapon, 2 )


	local weapon = {}
	weapon.Icon = Material("lvs/weapons/spotlight.png")
	weapon.Ammo = -1
	weapon.Delay = 1.5
	weapon.HeatRateUp = 1
	weapon.HeatRateDown = 0.1
	weapon.StartAttack = function( ent )
		if (self.gateDown) then
			self.gateDown = false
			self:SetBodygroup(7, 0)
		else
			self:SetBodygroup(7, 1)
			self.gateDown = true
		end
	end
	self:AddWeapon( weapon, 2 )

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/spotlight.png")
	weapon.Ammo = -1
	weapon.Delay = 1.5
	weapon.HeatRateUp = 1
	weapon.HeatRateDown = 0.1
	weapon.StartAttack = function( ent )
		if (self.gateDown) then
			self.gateDown = false
			self:SetSpotlightOn(false)
			self:EmitSound( "buttons/lightswitch2.wav", 75, 105 )
		else
			self:SetSpotlightOn(true)
			self:EmitSound( "buttons/lightswitch2.wav", 75, 105 )
			self.gateDown = true
		end
	end
	self:AddWeapon( weapon, 2 )

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/gunship_reardoor.png")
	weapon.Ammo = -1
	weapon.Delay = 1.5
	weapon.HeatRateUp = 1
	weapon.HeatRateDown = 0.3
	weapon.StartAttack = function( ent )
		if self:GetAI() == true then return end
		self:ToggleHatch()
	end
	self:AddWeapon( weapon, 3 )

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/dropship_grabber.png")
	weapon.Ammo = -1
	weapon.Delay = 1.5
	weapon.HeatRateUp = 1
	weapon.HeatRateDown = 0.1
	weapon.StartAttack = function( ent )
		if self:GetAI() == true then return end
		if (self.gateDown) then
			self.gateDown = false
			self:DropHeldEntity()
		else
			self:GrabEntity()
			self.gateDown = true
		end
	end
	self:AddWeapon( weapon, 3 )

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/gunship_sidedoor.png")
	weapon.Ammo = -1
	weapon.Delay = 1.5
	weapon.HeatRateUp = 1
	weapon.HeatRateDown = 0.3
	weapon.StartAttack = function( ent )
		if self:GetAI() == true then return end
		self:DoorOC()
	end
	self:AddWeapon( weapon )

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/spotlight.png")
	weapon.Ammo = -1
	weapon.Delay = 0.1
	weapon.HeatRateUp = 0
	weapon.HeatRateDown = 1
	weapon.StartAttack = function( ent )
		if self:GetSpotlightToggle() == true then
			self:SetSpotlightToggle(false)
			self:EmitSound( "buttons/lightswitch2.wav", 75, 105 )
		else
			self:SetSpotlightToggle(true)
			self:EmitSound( "buttons/lightswitch2.wav", 75, 105 )
		end
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav") end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	self:AddWeapon( weapon )
end

function ENT:IsSpotlightMounted()
	return self:GetBodygroup(7) == 1
end

--PATH addons/[tfres] lego vechicles/lua/entities/lvs_space_laat_lego/shared.lua:
return gluapack()()
--PATH lua/entities/lvs_starfighter_arc170/cl_init.lua:
include("shared.lua")

ENT.EngineColor = Color( 255, 50, 0, 255)
ENT.EngineGlow = Material( "sprites/light_glow02_add" )
ENT.EnginePos = {
	Vector(-163.81,64.51,8.36),
	Vector(-163.81,-64.51,8.36),
}

function ENT:OnSpawn()
	self:RegisterTrail( Vector(-34,326,-13), 0, 20, 2, 1000, 150 )
	self:RegisterTrail( Vector(-34,-326,-13), 0, 20, 2, 1000, 150 )
end

function ENT:OnFrame()
	self:EngineEffects()
	self:AnimAstromech()
	self:AnimWings()
	self:AnimGunner()
end

function ENT:EngineEffects()
	if not self:GetEngineActive() then return end

	local T = CurTime()

	if (self.nextEFX or 0) > T then return end

	self.nextEFX = T + 0.01

	local THR = self:GetThrottle()

	local emitter = self:GetParticleEmitter( self:GetPos() )

	if not IsValid( emitter ) then return end

	for _, pos in pairs( self.EnginePos ) do
		local vOffset = self:LocalToWorld( pos )
		local vNormal = -self:GetForward()

		vOffset = vOffset + vNormal * 5

		local particle = emitter:Add( "effects/muzzleflash2", vOffset )

		if not particle then continue end

		particle:SetVelocity( vNormal * (math.Rand(500,1000) + self:GetBoost() * 10) + self:GetVelocity() )
		particle:SetLifeTime( 0 )
		particle:SetDieTime( 0.1 )
		particle:SetStartAlpha( 255 )
		particle:SetEndAlpha( 0 )
		particle:SetStartSize( math.Rand(15,25) )
		particle:SetEndSize( math.Rand(0,10) )
		particle:SetRoll( math.Rand(-1,1) * 100 )
		particle:SetColor( 255, 50, 200 )
	end
end

function ENT:AnimGunner()
	local Pod = self:GetTailGunnerSeat()

	if not IsValid( Pod ) then return end

	local weapon = Pod:lvsGetWeapon()

	if not IsValid( weapon ) then return end

	local EyeAngles = self:WorldToLocalAngles( weapon:GetAimVector():Angle() )
	EyeAngles:RotateAroundAxis( EyeAngles:Up(), 180 )

	local Yaw = math.Clamp( EyeAngles.y,-60,60)
	local Pitch = math.Clamp( EyeAngles.p,-60,60 )

	self:ManipulateBoneAngles( 5, Angle(Yaw,0,0) )
	self:ManipulateBoneAngles( 6, Angle(0,0, math.max( Pitch, -25 ) ) )

	self:ManipulateBoneAngles( 2, Angle( math.Clamp( Yaw, -30, 30 ),0,0) )
	self:ManipulateBoneAngles( 3, Angle(0,0, math.Clamp( Pitch, -60, 12 ) ) )
end

function ENT:AnimAstromech()
	local T = CurTime()

	if (self.nextAstro or 0) < T then
		self.nextAstro = T + math.Rand(0.5,2)
		self.AstroAng = math.Rand(-180,180)

		local HasShield = self:GetShield() > 0

		if self.OldShield == true and not HasShield then
			self:EmitSound( "lvs/vehicles/naboo_n1_starfighter/astromech/shieldsdown"..math.random(1,2)..".ogg",100 )
		else
			if math.random(0,4) == 3 then
				self:EmitSound( "lvs/vehicles/naboo_n1_starfighter/astromech/"..math.random(1,11)..".ogg", 70 )
			end
		end
		
		self.OldShield = HasShield
	end

	self.smastro = self.smastro and (self.smastro + ((self.AstroAng or 0) - self.smastro) * RealFrameTime() * 10) or 0

	self:ManipulateBoneAngles( 1, Angle(self.smastro,0,0) )
end

function ENT:AnimWings()
	self._sm_wing = self._sm_wing or 1

	local target_wing = self:GetFoils() and 0 or 1
	local RFT = RealFrameTime() * (0.5 + math.abs( math.sin( self._sm_wing * math.pi ) ) * 0.5)

	local Rate = RFT * 0.5

	self._sm_wing = self._sm_wing + math.Clamp(target_wing - self._sm_wing,-Rate,Rate)

	local DoneMoving = self._sm_wing == 1 or self._sm_wing == 0

	if self._oldDoneMoving ~= DoneMoving then
		self._oldDoneMoving = DoneMoving
		if not DoneMoving then
			self:EmitSound("lvs/vehicles/arc170/sfoils.wav")
		end
	end

	local Ang = (1 - self._sm_wing) * 20

	self:ManipulateBoneAngles( 8, Angle(0,-Ang,0) )
	self:ManipulateBoneAngles( 9, Angle(0,Ang,0) )
	
	self:ManipulateBoneAngles( 10, Angle(0,Ang,0) )
	self:ManipulateBoneAngles( 11, Angle(0,-Ang,0) )

	self:InvalidateBoneCache()
end

function ENT:PostDrawTranslucent()
	if not self:GetEngineActive() then return end

	local Size = 80 + self:GetThrottle() * 120 + self:GetBoost() * 2

	render.SetMaterial( self.EngineGlow )

	for _, pos in pairs( self.EnginePos ) do
		render.DrawSprite(  self:LocalToWorld( pos ), Size, Size, self.EngineColor )
	end
end

function ENT:OnStartBoost()
	self:EmitSound( "lvs/vehicles/arc170/boost.wav", 85 )
end

function ENT:OnStopBoost()
	self:EmitSound( "lvs/vehicles/arc170/brake.wav", 85 )
end

--PATH lua/entities/lvs_starfighter_droidtrifighter/cl_init.lua:
return gluapack()()
--PATH lua/entities/lvs_starfighter_vulturedroid/shared.lua:

ENT.Base = "lvs_base_starfighter"

ENT.PrintName = "Vulture Droid"
ENT.Author = "Luna"
ENT.Information = "Droid Starfighter of the Trade Federation"
ENT.Category = "[LVS] - Star Wars"

ENT.VehicleCategory = "Star Wars"
ENT.VehicleSubCategory = "Starfighters"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/salza/vulture_droid.mdl"
ENT.GibModels = {
	"models/salza/vd_gib1.mdl",
	"models/salza/vd_gib2.mdl",
	"models/salza/vd_gib3.mdl",
	"models/salza/vd_gib4.mdl",
	"models/salza/vd_gib5.mdl",
}

ENT.AITEAM = 1

ENT.MaxVelocity = 2150
ENT.MaxThrust = 2150

ENT.ThrustVtol = 55
ENT.ThrustRateVtol = 3

ENT.TurnRatePitch = 1
ENT.TurnRateYaw = 1
ENT.TurnRateRoll = 1.25

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1
ENT.ForceAngleDampingMultiplier = 1

ENT.MaxHealth = 250

function ENT:InitWeapons()
	self.FirePositions = {
		Vector(56.82,105.6,4),
		Vector(56.82,-105.6,-4),
		Vector(56.82,105.6,-4),
		Vector(56.82,-105.6,4)
	}

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/mg.png")
	weapon.Ammo = 1200
	weapon.Delay = 0.1
	weapon.HeatRateUp = 0.25
	weapon.HeatRateDown = 1
	weapon.Attack = function( ent )
		ent.NumPrim = ent.NumPrim and ent.NumPrim + 1 or 1
		if ent.NumPrim > #ent.FirePositions then ent.NumPrim = 1 end

		local pod = ent:GetDriverSeat()

		if not IsValid( pod ) then return end

		local startpos = pod:LocalToWorld( pod:OBBCenter() )
		local trace = util.TraceHull( {
			start = startpos,
			endpos = (startpos + ent:GetForward() * 50000),
			mins = Vector( -10, -10, -10 ),
			maxs = Vector( 10, 10, 10 ),
			filter = ent:GetCrosshairFilterEnts()
		} )

		local bullet = {}
		bullet.Src 	= ent:LocalToWorld( ent.FirePositions[ent.NumPrim] )
		bullet.Dir 	= (trace.HitPos - bullet.Src):GetNormalized()
		bullet.Spread 	= Vector( 0.02,  0.02, 0 )
		bullet.TracerName = "lvs_laser_red"
		bullet.Force	= 10
		bullet.HullSize 	= 40
		bullet.Damage	= 10
		bullet.Velocity = 60000
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(255,50,50) ) 
				effectdata:SetOrigin( tr.HitPos )
				effectdata:SetNormal( tr.HitNormal )
			util.Effect( "lvs_laser_impact", effectdata )
		end
		ent:LVSFireBullet( bullet )

		local effectdata = EffectData()
		effectdata:SetStart( Vector(255,50,50) )
		effectdata:SetOrigin( bullet.Src )
		effectdata:SetNormal( ent:GetForward() )
		effectdata:SetEntity( ent )
		util.Effect( "lvs_muzzle_colorable", effectdata )

		ent:TakeAmmo()

		ent.PrimarySND:PlayOnce( 100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav") end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	self:AddWeapon( weapon )



	local weapon = {}
	weapon.Icon = Material("lvs/weapons/protontorpedo.png")
	weapon.Ammo = 4
	weapon.Delay = 0 -- this will turn weapon.Attack to a somewhat think function
	weapon.HeatRateUp = -0.5 -- cool down when attack key is held. This system fires on key-release.
	weapon.HeatRateDown = 0.25
	weapon.Attack = function( ent )
		local T = CurTime()

		if IsValid( ent._ProtonTorpedo ) then
			if (ent._nextMissleTracking or 0) > T then return end

			ent._nextMissleTracking = T + 0.1 -- 0.1 second interval because those find functions can be expensive

			ent._ProtonTorpedo:FindTarget( ent:GetPos(), ent:GetForward(), 30, 7500 )

			return
		end

		local T = CurTime()

		if (ent._nextMissle or 0) > T then return end

		ent._nextMissle = T + 0.5

		ent._swapMissile = not ent._swapMissile

		local Pos = Vector( 56.82, (ent._swapMissile and -105.6 or 105.6), 0 )

		local Driver = self:GetDriver()

		local projectile = ents.Create( "lvs_concussionmissile" )
		projectile:SetPos( ent:LocalToWorld( Pos ) )
		projectile:SetAngles( ent:GetAngles() )
		projectile:SetParent( ent )
		projectile:Spawn()
		projectile:Activate()
		projectile:SetAttacker( IsValid( Driver ) and Driver or self )
		projectile:SetEntityFilter( ent:GetCrosshairFilterEnts() )

		ent._ProtonTorpedo = projectile

		ent:SetNextAttack( CurTime() + 0.1 ) -- wait 0.1 second before starting to track
	end
	weapon.FinishAttack = function( ent )
		if not IsValid( ent._ProtonTorpedo ) then return end

		local projectile = ent._ProtonTorpedo

		projectile:Enable()
		projectile:EmitSound( "lvs/vehicles/vulturedroid/fire_missile.mp3", 125 )
		ent:TakeAmmo()

		ent._ProtonTorpedo = nil

		local NewHeat = ent:GetHeat() + 0.75

		ent:SetHeat( NewHeat )
		if NewHeat >= 1 then
			ent:SetOverheated( true )
		end
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav") end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	self:AddWeapon( weapon )



	local weapon = {}
	weapon.Icon = Material("lvs/weapons/dual_mg.png")
	weapon.Ammo = 400
	weapon.Delay = 0.15
	weapon.HeatRateUp = 0.5
	weapon.HeatRateDown = 1
	weapon.Attack = function( ent )
		local bullet = {}
		bullet.Dir 	= ent:GetForward()
		bullet.Spread 	= Vector( 0.015,  0.015, 0 )
		bullet.TracerName = "lvs_laser_red"
		bullet.Force	= 10
		bullet.HullSize 	= 25
		bullet.Damage	= 20
		bullet.Velocity = 60000
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(255,50,50) ) 
				effectdata:SetOrigin( tr.HitPos )
				effectdata:SetNormal( tr.HitNormal )
			util.Effect( "lvs_laser_impact", effectdata )
		end

		for i = -1,1,2 do
			bullet.Src 	= ent:LocalToWorld( Vector(30,15.2 * i,6.5) )

			local effectdata = EffectData()
			effectdata:SetStart( Vector(255,50,50) )
			effectdata:SetOrigin( bullet.Src )
			effectdata:SetNormal( ent:GetForward() )
			effectdata:SetEntity( ent )
			util.Effect( "lvs_muzzle_colorable", effectdata )

			ent:LVSFireBullet( bullet )
		end

		ent:TakeAmmo()

		ent.SecondarySND:PlayOnce( 100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav") end
	weapon.OnOverheat = function( ent ) end
	self:AddWeapon( weapon )
end

sound.Add( {
	name = "LVS.VULTURE.FLYBY",
	sound = {"lvs/vehicles/vulturedroid/flyby.wav","lvs/vehicles/vulturedroid/flyby_a.wav","lvs/vehicles/vulturedroid/flyby_b.wav","lvs/vehicles/vulturedroid/flyby_c.wav"}
} )

ENT.FlyByAdvance = 0
ENT.FlyBySound = "LVS.VULTURE.FLYBY" 
ENT.DeathSound = "lvs/vehicles/generic_starfighter/crash.wav"

ENT.EngineSounds = {
	{
		sound = "lvs/vehicles/vulturedroid/loop.wav",
		Pitch = 80,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 40,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
	},
	{
		sound = "^lvs/vehicles/vulturedroid/dist.wav",
		Pitch = 80,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 40,
		FadeIn = 0.35,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
		VolumeMin = 0,
		VolumeMax = 1,
		SoundLevel = 100,
	},
}
--PATH lua/entities/lvs_vehicle_air_refil.lua:
return gluapack()()
--PATH lua/entities/lvs_walker_atrt_rotary/cl_legs.lua:

function ENT:OnFrame()
	--self:PredictPoseParamaters()
	self:DamageFX()

	if self:GetIsRagdoll() then 
		self:LegClearAll()

		return
	end

	local Up = self:GetUp()
	local Forward = self:GetForward()
	local Vel = self:GetVelocity()
	
	local Stride = 33
	local Lift = 10
	
	local FT = math.min(FrameTime(),0.08) -- if fps lower than 12, clamp the frametime to avoid spazzing.

	local Rate = FT * 20

	if Vel:Length() < 50 then -- sync with server animation when not moving
		self.Move = self:GetMove()
	else
		self.Move = self.Move and self.Move + self:WorldToLocal( self:GetPos() + Vel ).x * FT * 2.8 or 0
	end
	
	local Cycl1 = self.Move
	local Cycl2 = self.Move + 180
	
	local IsMoving = self:GetIsMoving()
	
	if self:GetIsCarried() then
		self.TRACEPOS1 = self:LocalToWorld( Vector(200,70,180) )
		self.TRACEPOS2 = self:LocalToWorld( Vector(200,-70,180) )
		Cycl1 = 0
		Cycl2 = 0
		IsMoving = true
	end

	local MoveRoll = math.cos( math.rad(self:GetMove()) ) * 2

	-- FRONT LEFT
	local X = 40 + math.cos( math.rad(Cycl1) ) * Stride
	local Z = math.max( math.sin( math.rad(-Cycl1) ), 0) * Lift
	local STARTPOS = self:LocalToWorld( Vector(-22,18,64) )
	self.TRACEPOS1 = self.TRACEPOS1 and self.TRACEPOS1 or STARTPOS
	if Z > 0 or not IsMoving then 
		self.TRACEPOS1 = self.TRACEPOS1 + (STARTPOS + Forward * X - self.TRACEPOS1) * Rate
		self.FSOG1 = false
	else
		self.FSOG1 = true
	end
	--local ENDPOS = util.TraceLine( { start = self.TRACEPOS1 - Up * 50, endpos = self.TRACEPOS1 - Up * 160, filter = function( ent ) if ent == self or ent == self:GetRearEntity() or self.HoverCollisionFilter[ ent:GetCollisionGroup() ] then return false end return true end,} ).HitPos + Up * (45+Z)
	local ENDPOS = util.TraceLine( { start = self.TRACEPOS1 - Up * 50, endpos = self.TRACEPOS1 - Up * 160, filter = function( ent ) if ent == self or self.HoverCollisionFilter[ ent:GetCollisionGroup() ] then return false end return true end,} ).HitPos + Up * (-30+Z)
    
	if self.FSOG1 ~= self.oldFSOG1 then
		self.oldFSOG1 = self.FSOG1
		if self.FSOG1 then
			sound.Play( Sound( "atrt/walk.mp3" ), ENDPOS, SNDLVL_70dB)
			local effectdata = EffectData()
				effectdata:SetOrigin( ENDPOS - Vector(0,0,45) )
			util.Effect( "lvs_walker_stomp", effectdata )
		elseif Vel:Length() < 150 then
			sound.Play( Sound( "atrt/hydraulic"..math.random(1,3)..".mp3" ), ENDPOS, SNDLVL_70dB)
		end
	end
	
	local ATTACHMENTS = {
		Leg1 = {MDL = "models/astartes/atrt/leg3.mdl", Ang = Angle(140,0,0), Pos = Vector(1,-27,4)},
		Leg2 = {MDL = "models/astartes/atrt/leg2.mdl", Ang = Angle(145,0,0), Pos = Vector(2,-33,-1)},
		Foot = {MDL = "models/astartes/atrt/leg0.mdl", Ang = Angle(0,-90,-MoveRoll), Pos = Vector(12,10,-10)}
	}
	self:GetLegEnts( 1, 50, 65, self:LocalToWorldAngles( Angle(90,-10,0) ), STARTPOS, ENDPOS, ATTACHMENTS )
	
	
	-- FRONT RIGHT
	local STARTPOS = self:LocalToWorld( Vector(-22, -18,64) )
	local X = 10 + math.cos( math.rad(Cycl2) ) * Stride
	local Z = math.max( math.sin( math.rad(-Cycl2) ), 0) * Lift
	self.TRACEPOS2 = self.TRACEPOS2 and self.TRACEPOS2 or STARTPOS
	if Z > 0 or not IsMoving then 
		self.TRACEPOS2 = self.TRACEPOS2 + (STARTPOS + Forward * X - self.TRACEPOS2) * Rate
		self.FSOG2 = false
	else
		self.FSOG2 = true
	end
	--local ENDPOS = util.TraceLine( { start = self.TRACEPOS2 - Up * 50, endpos = self.TRACEPOS2 - Up * 160, filter = function( ent ) if ent == self or ent == self:GetRearEntity() or self.HoverCollisionFilter[ ent:GetCollisionGroup() ] then return false end return true end, } ).HitPos + Up * (45+Z)
	local ENDPOS = util.TraceLine( { start = self.TRACEPOS2 - Up * 50, endpos = self.TRACEPOS2 - Up * 160, filter = function( ent ) if ent == self or self.HoverCollisionFilter[ ent:GetCollisionGroup() ] then return false end return true end,} ).HitPos + Up * (-30+Z)
	
	if self.FSOG2 ~= self.oldFSOG2 then
		self.oldFSOG2 = self.FSOG2
		if self.FSOG2 then
			sound.Play( Sound( "atrt/walk.mp3" ), ENDPOS, SNDLVL_70dB)
			local effectdata = EffectData()
				effectdata:SetOrigin( ENDPOS - Vector(0,0,45) )
			util.Effect( "lvs_walker_stomp", effectdata )
		elseif Vel:Length() < 150 then
			sound.Play( Sound( "atrt/hydraulic"..math.random(1,3)..".mp3" ), ENDPOS, SNDLVL_70dB)
		end
	end
	
	local ATTACHMENTS = {
		Leg1 = {MDL = "models/astartes/atrt/leg3.mdl", Ang = Angle(140,0,0), Pos = Vector(1,-27,4)},
		Leg2 = {MDL = "models/astartes/atrt/leg2.mdl", Ang = Angle(145,0,0), Pos = Vector(2,-33,-1)},
		Foot = {MDL = "models/astartes/atrt/leg0.mdl", Ang = Angle(0,-90,-MoveRoll), Pos = Vector(12,10,-10)}
	}
	
	self:GetLegEnts( 2, 50, 65, self:LocalToWorldAngles( Angle(90,10,0) ), STARTPOS, ENDPOS, ATTACHMENTS )
	
end
--PATH lua/entities/lvs_walker_atte/cl_init.lua:
include("shared.lua")
include( "cl_ikfunctions.lua" )
include( "cl_camera.lua" )
include( "cl_legs.lua" )
include( "cl_prediction.lua" )
include("sh_turret.lua")
include("sh_gunner.lua")

function ENT:DamageFX()
	self.nextDFX = self.nextDFX or 0

	if self.nextDFX < CurTime() then
		self.nextDFX = CurTime() + 0.05

		if self:GetIsRagdoll() then
			if math.random(0,45) < 3 then
				if math.random(1,2) == 1 then
					local Pos = self:LocalToWorld( Vector(0,0,70) + VectorRand() * 80 )
					local effectdata = EffectData()
						effectdata:SetOrigin( Pos )
					util.Effect( "cball_explode", effectdata, true, true )
					
					sound.Play( "lvs/vehicles/atte/spark"..math.random(1,4)..".ogg", Pos, 75 )
				end
			end
		end

		local HP = self:GetHP()
		local MaxHP = self:GetMaxHP()

		if HP > MaxHP * 0.5 then return end

		local effectdata = EffectData()
			effectdata:SetOrigin( self:LocalToWorld( Vector(0,0,160) ) )
			effectdata:SetEntity( self )
		util.Effect( "lvs_engine_blacksmoke", effectdata )

		if HP <= MaxHP * 0.25 then
			local effectdata = EffectData()
				effectdata:SetOrigin( self:LocalToWorld( Vector(0,20,180) ) )
				effectdata:SetNormal( self:GetUp() )
				effectdata:SetMagnitude( math.Rand(1,3) )
				effectdata:SetEntity( self )
			util.Effect( "lvs_exhaust_fire", effectdata )

			local effectdata = EffectData()
				effectdata:SetOrigin( self:LocalToWorld( Vector(0,-20,180) ) )
				effectdata:SetNormal( self:GetUp() )
				effectdata:SetMagnitude( math.Rand(1,3) )
				effectdata:SetEntity( self )
			util.Effect( "lvs_exhaust_fire", effectdata )
		end
	end
end

function ENT:PreDraw()
	self:DrawTurretDriver()

	return true
end

function ENT:DrawTurretDriver()
	local pod = self:GetTurretSeat()

	if not IsValid( pod ) then return end

	local plyL = LocalPlayer()
	local ply = pod:GetDriver()

	if not IsValid( ply ) or (ply == plyL and plyL:GetViewEntity() == plyL and not pod:GetThirdPersonMode()) then return end

	local ID = self:LookupAttachment( "driver_turret" )
	local Att = self:GetAttachment( ID )

	if not Att then return end

	local _,Ang = LocalToWorld( Vector(0,0,0), Angle(-110,-90,0), Att.Pos, Att.Ang )

	ply:SetSequence( "drive_jeep" )
	ply:SetRenderAngles( Ang )
	ply:DrawModel()
end

local zoom = 0
local zoom_mat = Material( "vgui/zoom" )

local white = Color(255,255,255,255)
local red = Color(255,0,0,255)

function ENT:PaintZoom( X, Y, ply )
	local TargetZoom = ply:lvsKeyDown( "ZOOM" ) and 1 or 0

	zoom = zoom + (TargetZoom - zoom) * RealFrameTime() * 10

	X = X * 0.5
	Y = Y * 0.5

	surface.SetDrawColor( Color(255,255,255,255 * zoom) )
	surface.SetMaterial(zoom_mat ) 
	surface.DrawTexturedRectRotated( X + X * 0.5, Y * 0.5, X, Y, 0 )
	surface.DrawTexturedRectRotated( X + X * 0.5, Y + Y * 0.5, Y, X, 270 )
	surface.DrawTexturedRectRotated( X * 0.5, Y * 0.5, Y, X, 90 )
	surface.DrawTexturedRectRotated( X * 0.5, Y + Y * 0.5, X, Y, 180 )
end

function ENT:LVSHudPaint( X, Y, ply )
	if self:GetIsCarried() then return end

	if ply ~= self:GetDriver() then
		local pod = ply:GetVehicle()

		if pod == self:GetTurretSeat() or pod == self:GetGunnerSeat() then
			self:PaintZoom( X, Y, ply )
		end

		return
	end

	local Pos2D = self:GetEyeTrace().HitPos:ToScreen()

	local _,_, InRange = self:GetAimAngles()

	local Col = InRange and white or red

	self:PaintCrosshairCenter( Pos2D, Col )
	self:PaintCrosshairOuter( Pos2D, Col )
	self:LVSPaintHitMarker( Pos2D )

	self:PaintZoom( X, Y, ply )
end

ENT.IconEngine = Material( "lvs/engine.png" )

function ENT:LVSHudPaintInfoText( X, Y, W, H, ScrX, ScrY, ply )
	local Vel = self:GetVelocity():Length()
	local kmh = math.Round(Vel * 0.09144,0)

	draw.DrawText( "km/h ", "LVS_FONT", X + 72, Y + 35, color_white, TEXT_ALIGN_RIGHT )
	draw.DrawText( kmh, "LVS_FONT_HUD_LARGE", X + 72, Y + 20, color_white, TEXT_ALIGN_LEFT )

	if ply ~= self:GetDriver() then return end

	local hX = X + W - H * 0.5
	local hY = Y + H * 0.25 + H * 0.25

	surface.SetMaterial( self.IconEngine )
	surface.SetDrawColor( 0, 0, 0, 200 )
	surface.DrawTexturedRectRotated( hX + 4, hY + 1, H * 0.5, H * 0.5, 0 )
	surface.SetDrawColor( color_white )
	surface.DrawTexturedRectRotated( hX + 2, hY - 1, H * 0.5, H * 0.5, 0 )

	if self:GetIsCarried() then
		draw.SimpleText( "X" , "LVS_FONT",  hX, hY, Color(0,0,0,255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	else
		local Throttle = Vel / 150
		self:LVSDrawCircle( hX, hY, H * 0.35, math.min( Throttle, 1 ) )
	end
end

--PATH lua/entities/lvs_walker_atte/shared.lua:
return gluapack()()
--PATH lua/entities/lvs_walker_atte_component.lua:
AddCSLuaFile()

ENT.Type            = "anim"

ENT.AutomaticFrameAdvance = true
ENT.DoNotDuplicate = true

function ENT:SetupDataTables()
	self:NetworkVar( "Entity",0, "Base" )
end

if SERVER then
	function ENT:Initialize()	
		self:PhysicsInit( SOLID_VPHYSICS )
		self:SetMoveType( MOVETYPE_VPHYSICS )
		self:SetSolid( SOLID_VPHYSICS )
	end

	function ENT:Think()
		return false
	end

	function ENT:OnTakeDamage( dmginfo )
		local base = self:GetBase()

		if not IsValid( base ) then return end

		base:OnTakeDamage( dmginfo )
	end

	function ENT:PhysicsCollide( data, phys )
		local base = self:GetBase()

		if not IsValid( base ) then return end

		base:PhysicsCollide( data, phys )
	end

	function ENT:Use( ply )
		if (ply._lvsNextUse or 0) > CurTime() then return end

		local base = self:GetBase()

		if not IsValid( base ) then return end

		base:Use( ply )
	end

	function ENT:UpdateTransmitState() 
		return TRANSMIT_ALWAYS
	end

	return
end

function ENT:Draw()
	self:DrawModel()
end

function ENT:Think()
end

function ENT:OnRemove()
end
--PATH lua/entities/lvs_walker_atte_rear.lua:
AddCSLuaFile()

ENT.Base = "lvs_walker_atte_component"

if SERVER then
	function ENT:Initialize()	
		self:SetModel( "models/blu/atte_rear.mdl" )
		self:PhysicsInit( SOLID_VPHYSICS )
		self:SetMoveType( MOVETYPE_VPHYSICS )
		self:SetSolid( SOLID_VPHYSICS )
		self:SetUseType( SIMPLE_USE )

		-- this is so vj npcs can still see us
		self:AddEFlags( EFL_DONTBLOCKLOS )

		-- this is for our npc relationship system to work
		self:AddFlags( FL_OBJECT )
	end

	function ENT:Think()
		self:NextThink( CurTime() )
		return true
	end

	return
end

include("entities/lvs_walker_atte/cl_ikfunctions.lua")

function ENT:OnRemove()
	self:OnRemoved()
end
--PATH lua/entities/lvs_walker_atte/cl_ikfunctions.lua:
return gluapack()()
--PATH lua/entities/lvs_walker_atte/cl_ikfunctions.lua:
return gluapack()()
--PATH lua/entities/mediaplayer_base/cl_init.lua:
return gluapack()()
--PATH lua/entities/mediaplayer_base/cl_init.lua:
include "shared.lua"

--PATH lua/entities/mediaplayer_tv/shared.lua:
AddCSLuaFile()

if SERVER then
	resource.AddFile( "models/gmod_tower/suitetv_large.mdl" )
	resource.AddFile( "materials/models/gmod_tower/suitetv_large.vmt" )
	resource.AddSingleFile( "materials/entities/mediaplayer_tv.png" )
end

DEFINE_BASECLASS( "mediaplayer_base" )

ENT.PrintName 		= "Big Screen TV"
ENT.Author 			= "Samuel Maddock"
ENT.Instructions 	= "Right click on the TV to see available Media Player options. Alternatively, press E on the TV to turn it on."
ENT.Category 		= "Media Player"

ENT.Type = "anim"
ENT.Base = "mediaplayer_base"

ENT.Spawnable = true

ENT.Model = Model( "models/gmod_tower/suitetv_large.mdl" )

list.Set( "MediaPlayerModelConfigs", ENT.Model, {
	angle = Angle(-90, 90, 0),
	offset = Vector(6, 59.49, 103.65),
	width = 119,
	height = 69
} )

function ENT:SetupDataTables()
	BaseClass.SetupDataTables( self )

	self:NetworkVar( "String", 1, "MediaThumbnail" )
end

if SERVER then

	function ENT:SetupMediaPlayer( mp )
		mp:on("mediaChanged", function(media) self:OnMediaChanged(media) end)
	end

	function ENT:OnMediaChanged( media )
		self:SetMediaThumbnail( media and media:Thumbnail() or "" )
	end

else -- CLIENT

	local draw = draw
	local surface = surface
	local Start3D2D = cam.Start3D2D
	local End3D2D = cam.End3D2D
	local DrawHTMLMaterial = DrawHTMLMaterial

	local TEXT_ALIGN_CENTER = TEXT_ALIGN_CENTER
	local color_white = color_white

	local StaticMaterial = Material( "theater/STATIC" )
	local TextScale = 700

	function ENT:Draw()
		self:DrawModel()

		local mp = self:GetMediaPlayer()

		if not mp then
			self:DrawMediaPlayerOff()
		end
	end

	local HTMLMAT_STYLE_ARTWORK_BLUR = 'htmlmat.style.artwork_blur'
	AddHTMLMaterialStyle( HTMLMAT_STYLE_ARTWORK_BLUR, {
		width = 720,
		height = 480
	}, HTMLMAT_STYLE_BLUR )

	local DrawThumbnailsCvar = MediaPlayer.Cvars.DrawThumbnails

	function ENT:DrawMediaPlayerOff()
		local w, h, pos, ang = self:GetMediaPlayerPosition()
		local thumbnail = self:GetMediaThumbnail()

		Start3D2D( pos, ang, 1 )
			if DrawThumbnailsCvar:GetBool() and thumbnail != "" then
				DrawHTMLMaterial( thumbnail, HTMLMAT_STYLE_ARTWORK_BLUR, w, h )
			else
				surface.SetDrawColor( color_white )
				surface.SetMaterial( StaticMaterial )
				surface.DrawTexturedRect( 0, 0, w, h )
			end
		End3D2D()


		local scale = w / TextScale
		Start3D2D( pos, ang, scale )
			local tw, th = w / scale, h / scale
			draw.SimpleText( "Press E to begin watching", "MediaTitle",
				tw/2, th/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		End3D2D()
	end

end

--PATH gamemodes/starwarsrp/entities/entities/microwave/shared.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/entities/nade_k_thrown_molotov/shared.lua:
-- Made by Matsilagi

AddCSLuaFile()

ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.Spawnable = false

if CLIENT then
    killicon.Add( "arc9_gsr_thrownmolotov", "vgui/killicons/csgo_molotov", Color(251, 85, 25, 255))
end

function ENT:Draw()
	self:DrawModel()
end

function ENT:Initialize()
	if SERVER then
		self:SetModel( "models/weapons/w_eq_molotov_thrown.mdl" )
		self:SetMoveType( MOVETYPE_VPHYSICS )
		self:SetSolid( SOLID_VPHYSICS )
		self:PhysicsInit( SOLID_VPHYSICS )
		self:SetCollisionGroup( COLLISION_GROUP_NONE )
		self:DrawShadow( false )
	end
	--self:EmitSound( "weapons/csgo/molotov/grenade_throw.wav", 75, 100, 1, CHAN_AUTO )
	--self:EmitSound( "weapons/csgo/molotov/molotov_detonate_1.wav", 75, 100, 1, CHAN_AUTO )
	self.ActiveTimer = CurTime() + 1.5
	self.IgniteEnd = 0
	self.IgniteEndTimer = CurTime()
	self.IgniteStage = 0
	self.IgniteStageTimer = CurTime()
	ParticleEffectAttach("weapon_molotov_thrown",PATTACH_POINT_FOLLOW,self,1)
	self:PhysicsInitSphere( 8 )
end

function ENT:PhysicsCollide( data,phys )
	if SERVER and self.ActiveTimer > CurTime() || data.Speed >= 150 then
		self:EmitSound(Sound("GlassBottle.ImpactHard"))
	end
	local ang = data.HitNormal:Angle()
	ang.p = math.abs( ang.p )
	ang.y = math.abs( ang.y )
	ang.r = math.abs( ang.r )
	
	if ang.p > 90 or ang.p < 60 then
		self:EmitSound(Sound("GlassBottle.ImpactHard"))

		local impulse = (data.OurOldVelocity - 2 * data.OurOldVelocity:Dot(data.HitNormal) * data.HitNormal)*0.25
		phys:ApplyForceCenter(impulse)
	else
		if SERVER then
			local molotovfire = ents.Create( "arc9_gsr_fire_2" )
			molotovfire:SetPos( self:GetPos() )
			molotovfire:SetOwner( self.Owner )
			molotovfire:Spawn()
			SafeRemoveEntityDelayed(molotovfire, 8)
			
			local molotovfire = ents.Create( "arc9_gsr_fire_1" )
			local pos = self:GetPos()
			molotovfire:SetPos( self:GetPos() )
			molotovfire:SetOwner( self.Owner )
			molotovfire:SetCreator( self )
			molotovfire:Spawn()
			SafeRemoveEntityDelayed(molotovfire, 8)
			
			self:SetMoveType( MOVETYPE_NONE )
			self:SetSolid( SOLID_NONE )
			self:PhysicsInit( SOLID_NONE )
			self:SetCollisionGroup( COLLISION_GROUP_NONE )
			self:SetRenderMode( RENDERMODE_TRANSALPHA )
			self:SetColor( Color( 255, 255, 255, 0 ) )
			self:DrawShadow( false )
			self:StopParticles()
		end
		self:EmitSound("CSGO.Molotov.Explode")
		self:EmitSound( "weapons/csgo/molotov/fire_ignite_1.wav", 75, 100, 1, CHAN_AUTO )
		self.IgniteEnd = 1
		self.IgniteEndTimer = CurTime() + 7
		self.IgniteStage = 1
		self.IgniteStageTimer = CurTime() + 0.1
	end
	SafeRemoveEntityDelayed(self, 8)
end
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/entities/nade_k_thrown_sequencecharger/shared.lua:
return gluapack()()
--PATH lua/entities/nmg_ewhb-12_heavy_repeating_blaster/shared.lua:
return gluapack()()
--PATH lua/entities/nmg_ewhb-12_heavy_repeating_blaster/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.Category = "[Nexus Modding Group] E-Web"
ENT.PrintName = "EWHB-12 Heavy Repeating Blaster"
ENT.Author = "R4V3NGaming"
ENT.Spawnable = true
ENT.AdminSpawnable = false
ENT.TurretFloatHeight = 0
ENT.TurretModelOffset = Vector(0, -50, 50)
ENT.TurretTurnMax = 0.7
ENT.LastShot = 0
ENT.ShotInterval = 0.15
ENT.RenderGroup = RENDERGROUP_BOTH

function ENT:SetupDataTables()
	self:NetworkVar("Entity", 0, "Shooter")
	self:NetworkVar("Entity", 1, "ShootPos")
	self:NetworkVar("Entity", 2, "TurretBase")
	self:NetworkVar("Int", 0, "TAmmo")
end

function ENT:GetShooter(plr)
	if SERVER then
		return self:GetShooter()
	elseif CLIENT then
		return self:GetShooter()
	end
end

function ENT:Use(plr)
	if not self:ShooterStillValid() then
		self:SetShooter(plr)
		self:StartShooting()
		self.ShooterLast = plr
	else
		if plr == self:GetShooter() then
			self:SetShooter(nil)
			self:FinishShooting()
		end
	end
end

function ENT:ShooterStillValid()
	local shooter = nil
	if SERVER then
		shooter = self:GetShooter()
	elseif CLIENT then
		shooter = self:GetShooter()
	end
	return IsValid(shooter) and shooter:Alive() and (self:GetPos():DistToSqr(shooter:GetPos()) <= 7000)
end

function ENT:GetCrosshairFilterEnts()
	return {self, self.turretBase, self.shootPos}
end

function ENT:LVSFireBullet(data)
	data.Entity = self
	data.Velocity = data.Velocity + self:GetVelocity():Length()
	data.SrcEntity = self:WorldToLocal(data.Src)
	LVS:FireBullet(data)
end

function ENT:DoShot()
	if self.LastShot + self.ShotInterval < CurTime() then
		if SERVER then
			if self:GetTAmmo() > 0 then
				local effectPosAng = self:GetAttachment(self.MuzzleAttachment)
				local vPoint = effectPosAng.Pos

				local muzzleEffectData = EffectData()
				muzzleEffectData:SetStart(Vector(50, 50, 255))
				muzzleEffectData:SetOrigin(vPoint)
				muzzleEffectData:SetNormal(self.shootPos:GetAngles():Forward() * 100)
				muzzleEffectData:SetAngles(effectPosAng.Ang)
				muzzleEffectData:SetEntity(self)
				muzzleEffectData:SetScale(100)
				util.Effect("lvs_muzzle_colorable", muzzleEffectData)
				self:EmitSound(self.ShotSound, 50, 100)

				if IsValid(self.shootPos) and SERVER then
					self.shootPos:FireBullets({
						Num = 1,
						Src = self.shootPos:GetPos() + self.shootPos:GetAngles():Forward() * 40,
						Dir = self.shootPos:GetAngles():Forward() * 1,
						Spread = Vector(0.02, 0.02, 0),
						HullSize = 30,
						Force = 2,
						Damage = 50,
						Attacker = self.Shooter,
						Callback = function(attacker, trace, dmginfo)
							local hitEffectData = EffectData()
							hitEffectData:SetStart(Vector(50, 50, 255))
							hitEffectData:SetOrigin(trace.HitPos)
							util.Effect("lvs_laser_explosion", hitEffectData)

							local tracerEffect = EffectData()
							tracerEffect:SetStart(self.shootPos:GetPos())
							tracerEffect:SetOrigin(trace.HitPos)
							util.Effect("blue_tracer", tracerEffect)
						end
					})
					self:TakeAmmo()
					self:GetPhysicsObject():ApplyForceCenter(self:GetRight() * -500)
				end
			else
				self:EmitSound(self.EmptySound, 50, 100)
			end
		end
		self.LastShot = CurTime()
	end
end

function ENT:Think()
	if not IsValid(self.turretBase) and SERVER then
		SafeRemoveEntity(self)
	else
		if IsValid(self) then
			if SERVER then
				self.BasePos = self.turretBase:GetPos()
				self.OffsetPos = self.turretBase:GetAngles():Up() * 1

				if self.MagazineCollider then
					self.MagazineCollider:SetPos(self.turretBase:GetPos() + self.turretBase:GetUp() * 5 + self.turretBase:GetForward() * 10 + self.turretBase:GetRight() * -80)
					self.MagazineCollider:SetAngles(self.turretBase:GetAngles() + Angle(0, 90, 0))
				end
			end

			if self:ShooterStillValid() then
				if SERVER then
					local offsetAng = (self:GetAttachment(self.MuzzleAttachment).Pos - self:GetDesiredShootPos()):GetNormal()
					local offsetAngNew = offsetAng:Angle()
					offsetAngNew:RotateAroundAxis(offsetAngNew:Up(), -90)

					self.OffsetAng = offsetAngNew
					local Vertical = math.Clamp(self.OffsetAng.z, -31, 30)
					self:ManipulateBoneAngles(1, Angle(0, Vertical, 0))
				end

				local pressKey = IN_BULLRUSH
				if CLIENT and game.SinglePlayer() then
					pressKey = IN_ATTACK
				end

				self.Firing = self:GetShooter():KeyDown(pressKey)
			else
				self.Firing = false
				if SERVER then
					self:SetShooter(nil)
					self:FinishShooting()
				end
			end

			if self.Firing then
				self:DoShot()
			end

			self:NextThink(CurTime())
			return true
		end
	end
end
--PATH lua/entities/npc_vj_battle_droid_swrc/shared.lua:
ENT.Base 			= "npc_vj_creature_base" -- List of all base types: https://github.com/DrVrej/VJ-Base/wiki/Base-Types
ENT.Type 			= "ai"
ENT.PrintName 		= "Стервятник"
ENT.Author 			= "Orion, Sirius, Zmaj"
ENT.Contact 		= "http://steamcommunity.com/groups/vrejgaming"
ENT.Purpose 		= "NPC/SNPC Battles or any other things"
ENT.Instructions 	= "Click on the spawnicon to spawn it."
ENT.Category		= "[HC] NPC's"

if (CLIENT) then
	local Name = "Стервятник"
	local LangName = "npc_vj_vulture"
	language.Add(LangName, Name)
	killicon.Add(LangName,"",Color(255,0,0,0))
	language.Add("#"..LangName, Name)
	killicon.Add("#"..LangName,"",Color(255,0,0,0))
end
--PATH lua/entities/npc_vj_tridroidgunfixnew_f/shared.lua:
return gluapack()()
--PATH lua/entities/obj_vj_crossbowbolt.lua:
return gluapack()()
--PATH lua/entities/obj_vj_empty/shared.lua:
ENT.Type 			= "anim"
ENT.Base 			= "obj_vj_projectile_base"
ENT.PrintName		= "Dante"
ENT.Author 			= "DrVrej"
ENT.Contact 		= "http://steamcommunity.com/groups/vrejgaming"
ENT.Information		= "Projectiles for my addons"
ENT.Category		= "Projectiles"

if (CLIENT) then
	local Name = "Dante"
	local LangName = "obj_vj_dantethrow"
	language.Add(LangName, Name)
	killicon.Add(LangName,"HUD/killicons/default",Color(255,80,0,255))
	language.Add("#"..LangName, Name)
	killicon.Add("#"..LangName,"HUD/killicons/default",Color(255,80,0,255))
	function ENT:Draw()
		self:DrawModel()
	end
end
--PATH lua/entities/obj_vj_flareround.lua:
return gluapack()()
--PATH lua/entities/obj_vj_rcgg_rocket_swrc/shared.lua:
return gluapack()()
--PATH lua/entities/obj_vj_sbdshoot1.lua:
return gluapack()()
--PATH addons/[ekonomia] pcasino/lua/entities/pcasino_mystery_wheel/cl_init.lua:
return gluapack()()
--PATH addons/[ekonomia] pcasino/lua/entities/pcasino_npc/shared.lua:
ENT.Type = "ai"
ENT.Base = "base_ai"
ENT.PrintName = "NPC"
ENT.Author = "Owain Owjo & The One Free-Man"
ENT.Category = "pCasino"
ENT.Spawnable = false
ENT.AdminSpawnable = false

PerfectCasino.Core.RegisterEntity("pcasino_npc", {
	text = {
		overhead = {d = "Dealer", t = "string"},
		chat = {d = "Interested in playing a round?", t = "string"},
	},
},
"models/freeman/pcasino/owain_croupier_female01.mdl")
--PATH addons/[ekonomia] pcasino/lua/entities/pcasino_sign_interior_wall/cl_init.lua:
return gluapack()()
--PATH addons/[ekonomia] pcasino/lua/entities/pcasino_sign_stand/cl_init.lua:
return gluapack()()
--PATH addons/[ekonomia] pcasino/lua/entities/pcasino_wheel_slot_machine/cl_init.lua:
return gluapack()()
--PATH lua/entities/pfx1_00.lua:
return gluapack()()
--PATH lua/entities/pfx1_03.lua:
return gluapack()()
--PATH lua/entities/pfx1_03~.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Ember field"
ENT.Category         = "PPE: Fire & Smoke"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[1]embers_~"
--PATH lua/entities/pfx1_04.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Fire Trail"
ENT.Category         = "PPE: Fire & Smoke"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[1]flametrail"
--PATH lua/entities/pfx1_06~.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Flamethrower 1 [Large]"
ENT.Category         = "PPE: Fire & Smoke"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[1]flamethrower_large"
--PATH lua/entities/pfx1_07.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Black Smoke Cloud"
ENT.Category         = "PPE: Fire & Smoke"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[1]big_smoke"
--PATH lua/entities/pfx1_08.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Fire [Green]"
ENT.Category         = "PPE: Fire & Smoke"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[1]_campfire_green"
--PATH lua/entities/pfx1_08_~.lua:
return gluapack()()
--PATH lua/entities/pfx1_0a.lua:
return gluapack()()
--PATH lua/entities/pfx1_0b.lua:
return gluapack()()
--PATH lua/entities/pfx1_0d.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Lifting Smoke [Small]"
ENT.Category         = "PPE: Fire & Smoke"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[1]smoke_lifting_01"
--PATH lua/entities/pfx1_0e.lua:
return gluapack()()
--PATH lua/entities/pfx2_00.lua:
return gluapack()()
--PATH lua/entities/pfx2_02_a_s.lua:
return gluapack()()
--PATH lua/entities/pfx4_00_s~.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Smaller Basic Jet [Smokeless]"
ENT.Category         = "PPE: Tech"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[4]jet_f_s*"
--PATH lua/entities/pfx4_00~.lua:
return gluapack()()
--PATH lua/entities/pfx4_02_s.lua:
return gluapack()()
--PATH lua/entities/pfx4_03~.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Green Jet [Smokeless]"
ENT.Category         = "PPE: Tech"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[4]jet_g*"
--PATH lua/entities/pfx4_05.lua:
return gluapack()()
--PATH lua/entities/pfx4_06_1.lua:
return gluapack()()
--PATH lua/entities/pfx4_07.lua:
return gluapack()()
--PATH lua/entities/pfx5_00.lua:
return gluapack()()
--PATH lua/entities/pfx5_00_alt.lua:
return gluapack()()
--PATH lua/entities/pfx6_01.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "AR2 Gunfire"
ENT.Category         = "PPE: Weapons"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[6]gunfire_ar2"
--PATH lua/entities/pfx6_02b.lua:
return gluapack()()
--PATH lua/entities/pfx8_00.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Magic Flame 1"
ENT.Category         = "PPE: Magic"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[8]magic_1"
--PATH lua/entities/pfx8_03_alt.lua:
return gluapack()()
--PATH lua/entities/pfx8_07.lua:
return gluapack()()
--PATH lua/entities/pfx_test.lua:
return gluapack()()
--PATH lua/entities/pfxa_00.lua:
return gluapack()()
--PATH lua/entities/portals_base.lua:
return gluapack()()
--PATH lua/entities/prop_vj_flag.lua:
/*--------------------------------------------------
	*** Copyright (c) 2012-2023 by DrVrej, All rights reserved. ***
	No parts of this code or any of its contents may be reproduced, copied, modified or adapted,
	without the prior written consent of the author, unless otherwise indicated for stand-alone materials.
--------------------------------------------------*/
AddCSLuaFile()
if (!file.Exists("autorun/vj_base_autorun.lua","LUA")) then return end

ENT.Base 			= "prop_vj_animatable"
ENT.Type 			= "anim"
ENT.PrintName 		= "Flag"
ENT.Author 			= "DrVrej"
ENT.Contact 		= "http://steamcommunity.com/groups/vrejgaming"
ENT.Purpose 		= "Used for flags."
ENT.Instructions 	= "Don't change anything."
ENT.Category		= "VJ Base"
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
if !SERVER then return end

function ENT:CustomOnInitialize()
	self:SetModel("models/vj_props/armenian_flag01.mdl")
	self:PhysicsInit(SOLID_VPHYSICS)
	self:SetMoveType(MOVETYPE_VPHYSICS)
	self:ResetSequence("Idle")
	
	self.WaveSound = VJ_CreateSound(self, "vj_misc/flag_loop.wav", 60)
end
---------------------------------------------------------------------------------------------------------------------------------------------
function ENT:OnRemove()
	VJ_STOPSOUND(self.WaveSound)
end

--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/entities/rocket_heat.lua:
ENT.Type 				= "anim"
ENT.Base 				= "base_entity"
ENT.PrintName 			= "HEAT Round"
ENT.Author 				= ""
ENT.Information 		= ""

ENT.Spawnable 			= false


AddCSLuaFile()

ENT.Model = "models/items/ar2_grenade.mdl"
ENT.Ticks = 0
ENT.FuseTime = 4.5

if SERVER then

function ENT:Initialize()
    local pb_vert = 1
    local pb_hor = 1
    self:SetModel(self.Model)
    self:PhysicsInitBox( Vector(-pb_vert,-pb_hor,-pb_hor), Vector(pb_vert,pb_hor,pb_hor) )

    local phys = self:GetPhysicsObject()
    if phys:IsValid() then
        phys:Wake()
        phys:EnableGravity(false)
    end

    self.SpawnTime = CurTime()
    self.motorsound = CreateSound( self, "weapons/rpg/rocket1.wav")
    self.motorsound:Play()

    timer.Simple(0.1, function()
        if !IsValid(self) then return end
        self:SetCollisionGroup(COLLISION_GROUP_PROJECTILE)
    end)
end

function ENT:Think()
    if SERVER and CurTime() - self.SpawnTime >= self.FuseTime then
        self:Detonate()
    end
end

function ENT:OnRemove()
    self.motorsound:Stop()
end

end

function ENT:Think()
    if SERVER then
        local phys = self:GetPhysicsObject()
        phys:ApplyForceCenter( self:GetAngles():Forward() * 500 )

        if self.SpawnTime + self.FuseTime <= CurTime() then
            self:Detonate()
        end
    else
        if self.Ticks % 5 == 0 then
            local emitter = ParticleEmitter(self:GetPos())

            if !self:IsValid() or self:WaterLevel() > 2 then return end
            if !IsValid(emitter) then return end

            local smoke = emitter:Add("particle/particle_smokegrenade", self:GetPos())
            smoke:SetVelocity( VectorRand() * 25 )
            smoke:SetGravity( Vector(math.Rand(-5, 5), math.Rand(-5, 5), math.Rand(-20, -25)) )
            smoke:SetDieTime( math.Rand(1.5, 2.0) )
            smoke:SetStartAlpha( 255 )
            smoke:SetEndAlpha( 0 )
            smoke:SetStartSize( 0 )
            smoke:SetEndSize( 100 )
            smoke:SetRoll( math.Rand(-180, 180) )
            smoke:SetRollDelta( math.Rand(-0.2,0.2) )
            smoke:SetColor( 20, 20, 20 )
            smoke:SetAirResistance( 5 )
            smoke:SetPos( self:GetPos() )
            smoke:SetLighting( false )
            emitter:Finish()
        end

        self.Ticks = self.Ticks + 1
    end
end

function ENT:Detonate()
    if !self:IsValid() then return end
    local effectdata = EffectData()
        effectdata:SetOrigin( self:GetPos() )

    if self:WaterLevel() >= 1 then
        util.Effect( "WaterSurfaceExplosion", effectdata )
        self:EmitSound("weapons/underwater_explode3.wav", 125, 100, 1, CHAN_AUTO)
    else
        util.Effect( "Explosion", effectdata)
        self:EmitSound("phx/kaboom.wav", 125, 100, 1, CHAN_AUTO)
    end

    local attacker = self

    if self.Owner:IsValid() then
        attacker = self.Owner
    end

    util.BlastDamage(self, attacker, self:GetPos(), 32, 500)
    util.BlastDamage(self, attacker, self:GetPos(), 300, 110)

    self:FireBullets({
        Attacker = attacker,
        Damage = 0,
        Tracer = 0,
        Distance = 20000,
        Dir = self:GetVelocity(),
        Src = self:GetPos(),
        Callback = function(att, tr, dmg)
            util.Decal("Scorch", tr.StartPos, tr.HitPos - (tr.HitNormal * 16), self)
        end
    })

    for k, v in pairs(ents.FindInSphere(self:GetPos(), 32)) do
        if IsValid(v) and (v.LFS or v.LVS) then
            if v.LFS then
                v:StopEngine()
                v:SetShield(0)
                v:SetHP( v:GetHP()/ 65 )
            end
            if v.LVS then
                v:StopEngine()
                v:SetShield(0)
                v:SetHP( v:GetHP()/ 65 )
            end
        end
    end

    self:Remove()
end

function ENT:PhysicsCollide(colData, collider)
    self:Detonate()
end

function ENT:Draw()
    cam.Start3D() -- Start the 3D function so we can draw onto the screen.
        render.SetMaterial( Material("effects/blueflare1") ) -- Tell render what material we want, in this case the flash from the gravgun
        render.DrawSprite( self:GetPos(), math.random(100, 200), math.random(100, 200), Color(255, 225, 175) ) -- Draw the sprite in the middle of the map, at 16x16 in it's original colour with full alpha.
    cam.End3D()
end
--PATH lua/entities/rw_sw_dispencer/cl_init.lua:
return gluapack()()
--PATH lua/entities/rw_sw_dispencer/cl_init.lua:
include('shared.lua')

function ENT:Draw()
	self:DrawModel()
end
--PATH lua/entities/rw_sw_dispencer_armor/shared.lua:
return gluapack()()
--PATH lua/entities/sent_swrc_hoth/shared.lua:
return gluapack()()
--PATH lua/entities/sent_swrc_hoth/shared.lua:
AddCSLuaFile( )
DEFINE_BASECLASS( "base_anim" )

ENT.IsDODSTNT = true
ENT.TotalExplosions = 1
ENT.AutomaticFrameAdvance = true

util.PrecacheModel( "models/props/starwars/weapons/hoth_bomb.mdl" )
util.PrecacheSound( "buttons/spark6.wav" )
util.PrecacheSound( "ambient/fire/mtov_flame2.wav" )

if CLIENT then
	ENT.Mat = Material( "sprites/redglow1" )
	ENT.Mat2 = Material( "cable/redlaser" )
	
	ENT.LP = Vector( -.5, 1, 2 )
end

function ENT:SetupDataTables( )
	self:NetworkVar( "Float", 0, "Defuse" )
	self:NetworkVar( "Float", 1, "Fuse" )
	
	self:NetworkVar( "Int", 0, "BurnAdjust" )
	
	self:NetworkVar( "Bool", 0, "Live" )
end

function ENT:Draw( )

	
	local bone, n, light
	
	bone = self:GetAttachment( self:LookupAttachment( "wick" ) )
	
	if not bone then
		return
	end
	
	self:DrawModel( )
	
	if self:GetDefuse( ) < 1 then
		
		--if self.BurnSound then
			--self.BurnSound:PlayEx( .5, 170 )
		--end
	else
		if self.BurnSound then
			self.BurnSound:Stop( )
		end
	end
end

function ENT:OnRemove( )
	if self.BurnSound then
		self.BurnSound:Stop( )
	end
end

function ENT:Use(activator, caller)
	self.Entity:ActivateX(1)
end

function ENT:ActivateX( scale )
	if not self:GetLive( ) then
		self:SetLive( true )
		self:SetBurnAdjust( scale or 1 )
		
		seq = self:LookupSequence( "w_tnt_wick" )
		self:ResetSequence( seq )
		self:SetPlaybackRate( 1 / self:GetBurnAdjust( ) )
		
		if not self.BurnSound then
			self.BurnSound = CreateSound( self, Sound( "weapons/sw_detonator.wav" ) )
		end
		self.BurnSound:Play( )
	end
end

function ENT:OnTakeDamage( info )
	self:TakePhysicsDamage( info )
	if info and self:IsValid( ) and not self.Refuse then
		if info:IsExplosionDamage( ) then
			self:Explode( )
		end
	end
end

function ENT:Initialize( )
	self:SetModel( "models/props/starwars/weapons/hoth_bomb.mdl" )
	
	if SERVER then
		self:SetDefuse( 0 )
		self:SetFuse( 0 )
		
		self:PhysicsInit( SOLID_VPHYSICS )
		self:SetMoveType( MOVETYPE_VPHYSICS )
		self:SetSolid( SOLID_VPHYSICS )
		
		self:PhysWake( )
	end
end

function ENT:Think( )
	local now, delta
	
	
	if CLIENT then
		return
	end
	
	now = CurTime( )
	
	delta = now - ( self.LastThink or now )
	
	self.LastThink = now
	
	if self:GetLive( ) then
		if not self.Used then
			self:SetDefuse( math.Clamp( self:GetDefuse( ) - delta * .5, 0, 1 ) )
		end
	end
	
	if self:GetDefuse( ) >= 1 and self:GetLive( ) then
		self:SetLive( false )
		
		self:EmitSound( "buttons/spark6.wav", 100, 63 )
		self:SetPlaybackRate( 0 )
	end
	
	if self:GetLive( ) then
		self:SetFuse( math.Clamp( self:GetFuse( ) + delta / ( self:GetBurnAdjust( ) * 19 ), 0, 1 ) )
		
		if self:GetFuse( ) >= 0.20 and SERVER then
			self:SetLive( false )
			self:Explode( )
		end
	end
	
	if self:GetLive( ) and self:WaterLevel( ) > 0 then
		self:SetLive( false )
		self:SetDefuse( 1 )
	end
	
	self.Used = false
end

local function Spin( vector, up, right, forward )
	local ang
	
	ang = ( vector * 1 ):Angle( )
	
	ang:RotateAroundAxis( ang:Up( ), math.random( -up / 2 , up / 2 ) )
	ang:RotateAroundAxis( ang:Right( ), math.random( -right / 2 , right / 2 ) )
	ang:RotateAroundAxis( ang:Forward( ), math.random( -forward / 2 , forward / 2 ) )
	
	return ang:Forward( )
end

function ENT:Explode( )
	if self.Refuse then
		return
	end
	
	self.Refuse = true
	
	for k, v in pairs (ents.FindInSphere(self.Entity:GetPos(), 250)) do
		v:Fire("EnableMotion", "", math.random(0, 0.5))
	end
	
	local explode = ents.Create( "env_explosion" )
	explode:SetPos( self:GetPos() )
	explode:SetKeyValue( "iMagnitude", "250" )
	explode:EmitSound( "weapon_AWP.Single", 100, 100 )
	explode:Spawn()
	explode:Activate()
	explode:Fire( "Explode", "", 0 )
	
	self:Remove()
end
--PATH lua/entities/sent_vj_board.lua:
/*--------------------------------------------------
	*** Copyright (c) 2012-2023 by DrVrej, All rights reserved. ***
	No parts of this code or any of its contents may be reproduced, copied, modified or adapted,
	without the prior written consent of the author, unless otherwise indicated for stand-alone materials.
--------------------------------------------------*/
AddCSLuaFile()
if (!file.Exists("autorun/vj_base_autorun.lua","LUA")) then return end

ENT.Base 			= "base_gmodentity"
ENT.Type 			= "anim"
ENT.PrintName 		= "Wooden Board"
ENT.Author 			= "DrVrej"
ENT.Contact 		= "http://steamcommunity.com/groups/vrejgaming"
ENT.Purpose 		= "Used for defending a certain area from enemies, SNPCs will attack it when close."
ENT.Instructions 	= "Don't change anything."
ENT.Category		= "VJ Base"

ENT.Spawnable = true
ENT.AdminOnly = false

ENT.VJ_AddEntityToSNPCAttackList = true
---------------------------------------------------------------------------------------------------------------------------------------------
if CLIENT then
	function ENT:Draw()
		self:DrawModel()
	end
end
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
if !SERVER then return end

ENT.Model = {"models/props_debris/wood_board05a.mdl"}
ENT.StartHealth = 50
---------------------------------------------------------------------------------------------------------------------------------------------
function ENT:Initialize()
	if self:GetModel() == "models/error.mdl" then
	self:SetModel(Model(VJ_PICK(self.Model))) end
	self:PhysicsInit(SOLID_VPHYSICS)
	self:SetMoveType(MOVETYPE_VPHYSICS)
	self:SetSolid(SOLID_VPHYSICS)
	//self:SetCollisionGroup(COLLISION_GROUP_NONE)
	self:SetUseType(SIMPLE_USE)
	self:SetMaxHealth(self.StartHealth)
	self:SetHealth(self.StartHealth)
	
	local phys = self:GetPhysicsObject()
	if phys and IsValid(phys) then
		phys:Wake()
	end
end
---------------------------------------------------------------------------------------------------------------------------------------------
function ENT:PhysicsCollide(data, physobj)
	//self:EmitSound("physics/cardboard/cardboard_box_impact_soft"..math.random(1,5)..".wav")
end
---------------------------------------------------------------------------------------------------------------------------------------------
function ENT:Use(activator, caller)
	if IsValid(activator) && activator:IsPlayer() then
		activator:PickupObject(self)
	end
end
---------------------------------------------------------------------------------------------------------------------------------------------
function ENT:OnTakeDamage(dmginfo)
	self:GetPhysicsObject():AddVelocity(dmginfo:GetDamageForce() * 0.05)
	self:SetHealth(self:Health() - dmginfo:GetDamage())
	if self:Health() <= 0 then self:DoDeath() end
end
---------------------------------------------------------------------------------------------------------------------------------------------
function ENT:DoDeath()
	local effectData = EffectData()
	effectData:SetOrigin(self:GetPos())
	util.Effect("VJ_Small_Dust1", effectData)
	self:Remove()
end
--PATH gamemodes/starwarsrp/entities/entities/spawned_ammo/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
ENT.PrintName = "Spawned Ammo"
ENT.Author = "FPtje"
ENT.Spawnable = false
ENT.IsSpawnedAmmo = true

--PATH gamemodes/starwarsrp/entities/entities/spawned_weapon/cl_init.lua:
return gluapack()()
--PATH lua/entities/speeder_bike.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/entities/tfa_battlefront_ent_nade_heal.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/entities/tfa_battlefront_ent_nade_heal.lua:
ENT.Type = "anim"
ENT.Base = "arccw_thr"
ENT.PrintName = "explosive Grenade"
ENT.Author = ""
ENT.Information = ""
ENT.Spawnable = false
ENT.AdminSpawnable = false 

ENT.BounceSound = Sound("TFA_CSGO_SmokeGrenade.Bounce")
ENT.ExplodeSound = Sound("weapons/tfa_starwars/Smoke_Explosive_Puff_01.wav")

AddCSLuaFile()

function ENT:Initialize()
	if SERVER then
		self:SetModel("models/forrezzur/bactagrenade.mdl") 
		self:PhysicsInit(SOLID_VPHYSICS)
		self:SetMoveType(MOVETYPE_VPHYSICS)
		self:SetSolid(SOLID_VPHYSICS)
		self:SetCollisionGroup(COLLISION_GROUP_DEBRIS)
		
		local phys = self:GetPhysicsObject()
		if phys:IsValid() then
			phys:Wake()
			phys:SetBuoyancyRatio(1)
		end
		
		self.Delay = CurTime() + 2
		self.NextParticle = 0
		self.ParticleCount = 0
		self.First = true
		self.IsDetonated = false
	end
	self:EmitSound("TFA_CSGO_SmokeGrenade.Throw")
end

function ENT:PhysicsCollide(data, physobj)
	if SERVER then
		self.HitP = data.HitPos
		self.HitN = data.HitNormal

		if self:GetVelocity():Length() > 30 then
			self:EmitSound(self.BounceSound)
		end
		
		if self:GetVelocity():Length() < 5 then
			self:SetMoveType(MOVETYPE_NONE)
		end
		
	end
end

function ENT:Think()
    if SERVER then    
        if CurTime() > self.Delay then
            if self.IsDetonated == false then
                self:Detonate(self,self:GetPos())
                self.IsDetonated = true
            end
        end
    end
    if self.IsDetonated == true then
        for k, v in pairs( ents.FindInSphere( self:GetPos(), 216 ) ) do
        if v:IsPlayer() then
            if v:Health() < v:GetMaxHealth() and v:Alive() then
				v:SetHealth( math.Clamp( v:Health() + math.random( 2, 4 ), 0, v:GetMaxHealth() ) )
                    end
                end
            end
        end
    self:NextThink( CurTime() + 0.75 )
    return true
end
	
function ENT:Detonate(self,pos)
	self.ParticleCreated = false
	self.ExtinguishParticleCreated = false
	if SERVER then
		if not self:IsValid() then return end
		self:SetNWBool("IsDetonated",true)
		self:EmitSound(self.ExplodeSound)
		local gas = EffectData()
		gas:SetOrigin(pos)
		gas:SetEntity(self.Owner)
		util.Effect("tfa_csgo_healnade", gas)
	end
	
	self:SetMoveType( MOVETYPE_NONE )
	
	if SERVER then
		SafeRemoveEntityDelayed(self,15)
	end
	
end

function ENT:Draw()
	if CLIENT then
		self:DrawModel()
	end
end
--PATH addons/[bronie] republic-essentials-v2d/lua/entities/tfa_battlefront_ent_nade_thermal.lua:
AddCSLuaFile()
ENT.Type = "anim"
ENT.Base = "arccw_thr"
ENT.Spawnable = false

function ENT:Draw()
	self:DrawModel()
end

function ENT:Initialize()
	if SERVER then
		self:SetModel( "models/weapons/tfa_starwars/w_thermal.mdl" )
		self:SetMoveType( MOVETYPE_VPHYSICS )
		self:SetSolid( SOLID_VPHYSICS )
		self:PhysicsInit( SOLID_VPHYSICS )
		self:SetCollisionGroup( COLLISION_GROUP_WEAPON )
		self:DrawShadow( true )
	end
	self:EmitSound("weapons/tfa_starwars/ThermalDetonator_Beeps_01.wav")
	self.ExplodeTimer = CurTime() + 2.5
end

function ENT:Think()
	if SERVER and self.ExplodeTimer <= CurTime() then
		self:Explode()
		self:Remove()
	end
end

function ENT:PhysicsCollide( data )
	if SERVER and data.Speed > 150 then
	self:EmitSound( "TFA_CSGO_HEGrenade.Bounce" )
	end
end

function ENT:OnRemove()
end

function ENT:Explode()
	local effectdata = EffectData()
    effectdata:SetOrigin( self:GetPos() )
    util.Effect("Explosion", effectdata)
	util.BlastDamage( self, self.Owner, self:GetPos(), 350, 150 )
	local spos = self:GetPos()
	local trs = util.TraceLine({start=spos + Vector(0,0,64), endpos=spos + Vector(0,0,-32), filter=self})
	util.Decal("Scorch", trs.HitPos + trs.HitNormal, trs.HitPos - trs.HitNormal)    
end
--PATH lua/entities/tfa_csgo_fire_1/shared.lua:
return gluapack()()
--PATH addons/[tfres] datapad/lua/entities/tfres_arrests/cl_init.lua:
return gluapack()()
--PATH addons/[tfres] datapad/lua/entities/tfres_arrests/cl_init.lua:
include('shared.lua')

--PATH lua/entities/tie_advanced.lua:

ENT.RenderGroup = RENDERGROUP_OPAQUE
ENT.Base = "fighter_base"
ENT.Type = "vehicle"

ENT.PrintName = "TIE Advanced"
ENT.Author = "Liam0102"
ENT.Category = "Star Wars Vehicles: Empire"
ENT.AutomaticFrameAdvance = true
ENT.Spawnable = false;
ENT.AdminSpawnable = false;

ENT.EntModel = "models/tiead/tiead1.mdl"
ENT.Vehicle = "TieAdvanced"
ENT.StartHealth = 3000;
ENT.Allegiance = "Empire";
list.Set("SWVehicles", ENT.PrintName, ENT);
if SERVER then

ENT.FireSound = Sound("weapons/tie_shoot.wav");
ENT.NextUse = {Wings = CurTime(),Use = CurTime(),Fire = CurTime(),};


AddCSLuaFile();
function ENT:SpawnFunction(pl, tr)
	local e = ents.Create("tie_advanced");
	e:SetPos(tr.HitPos + Vector(0,0,20));
	e:SetAngles(Angle(0,pl:GetAimVector():Angle().Yaw,0));
	e:Spawn();
	e:Activate();
	return e;
end

function ENT:Initialize()


	self:SetNWInt("Health",self.StartHealth);
	
	self.WeaponLocations = {
		Right = self:GetPos()+self:GetForward()*80+self:GetUp()*40+self:GetRight()*15,
		Left = self:GetPos()+self:GetForward()*80+self:GetUp()*40+self:GetRight()*-15,
	}
	
	self.WeaponsTable = {};
	self.BoostSpeed = 2000;
	self.ForwardSpeed = 1000;
	self.UpSpeed = 500;
	self.AccelSpeed = 8;
	self.CanBack = true;
	self.CanRoll = true;
	
	self.Cooldown = 2;
	self.Overheat = 0;
	self.Overheated = false;
	
	self.CanShoot = true;
	self.ExitModifier = {x=0,y=140,z=40};
	
	self.Bullet = CreateBulletStructure(100,"green");

	self.BaseClass.Initialize(self);
end


end

if CLIENT then

	function ENT:Draw() self:DrawModel() end
	
	ENT.EnginePos = {}
	ENT.Sounds={
		//Engine=Sound("ambient/atmosphere/ambience_base.wav"),
		Engine=Sound("vehicles/tie/tie_engine.wav"),
	}

	ENT.CanFPV = true;
	local Health = 100;
	function ENT:Think()
		
		local p = LocalPlayer();
		local Flying = p:GetNWBool("Flying"..self.Vehicle);
		if(Flying) then
			Health = self:GetNWInt("Health");
		end
		self.BaseClass.Think(self);
	end
    
    ENT.ViewDistance = 700;
    ENT.ViewHeight = 300;
    ENT.FPVPos = Vector(40,0,85);

	local HUD = surface.GetTextureID("vgui/tie_cockpit");
	local Glass = surface.GetTextureID("models/props_c17/frostedglass_01a_dx60");
	function TieAdvancedReticle()
		
		local p = LocalPlayer();
		local Flying = p:GetNWBool("FlyingTieAdvanced");
		local self = p:GetNWEntity("TieAdvanced");
		if(Flying and IsValid(self)) then
			local WeaponsPos = {
				self:GetPos()+self:GetForward()*80+self:GetUp()*40+self:GetRight()*15,
				self:GetPos()+self:GetForward()*80+self:GetUp()*40+self:GetRight()*-15,
			}
			
			local FPV = self:GetFPV();
			
			if(FPV) then
				SW_HUD_FPV(HUD);
			end
			SW_HUD_DrawHull(3000);
			SW_WeaponReticles(self);
			SW_HUD_DrawOverheating(self);
			
			local x = ScrW()/4*0.6;
			local y = ScrH()/4*0.825;
			SW_HUD_Compass(self,x,y);
			SW_HUD_DrawSpeedometer();
		end
	end
	hook.Add("HUDPaint", "TieAdvancedReticle", TieAdvancedReticle)

end
--PATH lua/entities/turbolaser2/cl_init.lua:
return gluapack()()
--PATH lua/entities/tx-ex/cl_init.lua:
include("shared.lua")

function ENT:Initialize()
end

function ENT:OnFrame()
	self:AnimCabin()
end

function ENT:AnimCabin()
	local Fire = self:GetBTLFire()
	if Fire ~= self.OldFireBTL then
		self.OldFireBTL = Fire
		
		if Fire then			
			local effectdata = EffectData()
			effectdata:SetEntity( self )
			util.Effect( "tx_130_projector", effectdata )
		end
	end
	
	local bOn = self:GetActive()
	
	local TVal = bOn and 0 or 1
	
	local Speed = FrameTime() * 4
	
	self.SMcOpen = self.SMcOpen and self.SMcOpen + math.Clamp(TVal - self.SMcOpen,-Speed,Speed) or 0
	
	self:ManipulateBoneAngles( 20, Angle(0,0,self.SMcOpen * -95) ) 
	
end

function ENT:OnRemove()
	self:SoundStop()
end

function ENT:SoundStop()
	if self.DIST then
		self.DIST:Stop()
	end
	
	if self.ENG then
		self.ENG:Stop()
	end
end

function ENT:LVSCalcView( ply, pos, angles, fov, pod )
	local view = {}
	view.origin = pos
	view.fov = fov
	view.drawviewer = true
	view.angles = ply:EyeAngles()
	local gunners = self:GetGunnerSeat()
	local gunner = gunners:GetDriver()
	local Driver = self:GetDriver()
	if pod:GetThirdPersonMode() then
		if ply == Driver then
			local Pod = ply:GetVehicle()
			
				local radius = 400
				radius = radius + radius * Pod:GetCameraDistance()
				
				local StartPos = self:LocalToWorld( Vector(0,0,50) ) + view.angles:Up() * 100
				local EndPos = StartPos - view.angles:Forward() * radius
				
				local WallOffset = 4
		
				local tr = util.TraceHull( {
					start = StartPos,
					endpos = EndPos,
					filter = function( e )
						local c = e:GetClass()
						local collide = not c:StartWith( "prop_physics" ) and not c:StartWith( "prop_dynamic" ) and not c:StartWith( "prop_ragdoll" ) and not e:IsVehicle() and not c:StartWith( "gmod_" ) and not c:StartWith( "player" ) and not e.LFS
						
						return collide
					end,
					mins = Vector( -WallOffset, -WallOffset, -WallOffset ),
					maxs = Vector( WallOffset, WallOffset, WallOffset ),
				} )
				
				view.drawviewer = true
				view.origin = tr.HitPos
				
				if tr.Hit and not tr.StartSolid then
					view.origin = view.origin + tr.HitNormal * WallOffset
				end
			return view
		else
			local Pod = ply:GetVehicle()
			
			local radius = 400
			radius = radius + radius * Pod:GetCameraDistance()
			
			local StartPos = self:LocalToWorld( Vector(0,0,50) ) + view.angles:Up() * 100
			local EndPos = StartPos - view.angles:Forward() * radius
			
			local WallOffset = 4
	
			local tr = util.TraceHull( {
				start = StartPos,
				endpos = EndPos,
				filter = function( e )
					local c = e:GetClass()
					local collide = not c:StartWith( "prop_physics" ) and not c:StartWith( "prop_dynamic" ) and not c:StartWith( "prop_ragdoll" ) and not e:IsVehicle() and not c:StartWith( "gmod_" ) and not c:StartWith( "player" ) and not e.LFS
					
					return collide
				end,
				mins = Vector( -WallOffset, -WallOffset, -WallOffset ),
				maxs = Vector( WallOffset, WallOffset, WallOffset ),
			} )
			
			view.drawviewer = true
			view.origin = tr.HitPos
			
			if tr.Hit and not tr.StartSolid then
				view.origin = view.origin + tr.HitNormal * WallOffset
			end
			return view
		end
	end
	if not pod:GetThirdPersonMode() then

		view.drawviewer = false

		local gunners = self:GetGunnerSeat()
		
		local Driver = self:GetDriver()
		local Gunner = gunners:GetDriver()

		if ply == Driver then
			view.origin = self:LocalToWorld( Vector(-65,25,55) )
		elseif ply == Gunner then
			view.origin = self:LocalToWorld( Vector(-100,0,95) )
		else
			view.origin = self:LocalToWorld( Vector(-65,-25,55) )
		end
		
	return view
	end

	return view
end

function ENT:RemoveLight()
	if IsValid( self.projector ) then
		self.projector:Remove()
		self.projector = nil
	end
end

function ENT:OnRemove()
	self:SoundStop()
	
	self:RemoveLight()
end


local spotlight = Material( "effects/lfs_base/spotlight_projectorbeam" )
local glow_spotlight = Material( "sprites/light_glow02_add" )

function ENT:Draw()
	self:DrawModel()

	if self:GetBodygroup( 9 ) ~= 1 then 
		self:RemoveLight()

		return
	end

	if not IsValid( self.projector ) then
		local thelamp = ProjectedTexture()
		thelamp:SetBrightness( 20 ) 
		thelamp:SetTexture( "effects/flashlight/soft" )
		thelamp:SetColor( Color(255,255,255) ) 
		thelamp:SetEnableShadows( false ) 
		thelamp:SetFarZ( 2500 ) 
		thelamp:SetNearZ( 75 ) 
		thelamp:SetFOV( 80 )
		self.projector = thelamp
	end

	local StartPos = self:LocalToWorld( Vector(60,0,10.5) )
	local Dir = self:GetForward()

	render.SetMaterial( glow_spotlight )
	render.DrawSprite( StartPos + Dir * -10 , 220, 120, Color( 255, 255, 255, 255) )


	render.SetMaterial( spotlight )
	render.DrawBeam(  StartPos - Dir * 10,  StartPos + Dir * 800, 250, 0, 0.99, Color( 255, 255, 255, 10) ) 
	
	if IsValid( self.projector ) then
		self.projector:SetPos( StartPos )
		self.projector:SetAngles( Dir:Angle() )
		self.projector:Update()
	end
end


--PATH lua/entities/unity_smoke.lua:
AddCSLuaFile()

ENT.Type = "anim"
ENT.Base = "base_gmodentity"
ENT.PrintName = "Smoke"
ENT.Author = "DolUnity"

ENT.Spawnable = false

if CLIENT then return end

function ENT:Initialize()
    self:SetModel("models/items/grenadeammo.mdl")
    self:PhysicsInit(SOLID_VPHYSICS)
    self:SetMoveType(MOVETYPE_VPHYSICS)
    self:SetSolid(SOLID_VPHYSICS)

    local phys = self:GetPhysicsObject()
    if IsValid(phys) then
        phys:Wake()
        phys:EnableGravity(true)
    end
    self:SetTrigger(true)
end

function ENT:Think()
    if (bit.band(util.PointContents(self:GetPos()), CONTENTS_WATER) == CONTENTS_WATER) then
        self:Remove()
    end
end

ENT.EntsFilter = {}

function ENT:SetEntityFilter(filter)
    if not istable(filter) then return end

    self.EntsFilter = {}

    for _, ent in pairs(filter) do
        self.EntsFilter[ent] = true
    end
end

function ENT:StartTouch(entity)
    if self.EntsFilter[entity] then return end
end

function ENT:PhysicsCollide(data, entity)
    local collider = data.HitEntity
    if entity:GetEntity() == data.HitEntity or self.EntsFilter[collider] or (IsValid(collider) and collider:GetClass() == "trigger_teleport") then return end

    self:SpawnSmoke()
end

function ENT:SpawnSmoke()
    self:GetPhysicsObject():EnableMotion(false)
    self:GetPhysicsObject():Wake()

    local smoke = ents.Create("env_smoketrail")
    smoke:SetPos(self:GetPos() + Vector(0,0,120))
    smoke:SetKeyValue("angles", tostring( Angle(0,0,0) ))
    smoke:SetKeyValue("emittime", "16384")
    smoke:SetKeyValue("startcolor", "255 255 255")
    smoke:SetKeyValue("endcolor", "255 255 255")
    smoke:SetKeyValue("opacity", "0.9")
    smoke:SetKeyValue("spawnradius", "5")
    smoke:SetKeyValue("lifetime", "5")
    smoke:SetKeyValue("startsize", "128")
    smoke:SetKeyValue("endsize", "128")
    smoke:SetKeyValue("minspeed", "42")
    smoke:SetKeyValue("maxspeed", "64")
    smoke:SetKeyValue("mindirectedspeed", "42")
    smoke:SetKeyValue("maxdirectedspeed", "64")
    smoke:SetKeyValue("spawnrate", "16")
    smoke:Spawn()
    smoke:Activate()

    self.ParticleEffect = smoke

    timer.Simple(30, function ()
        if (IsValid(self)) then
            self:Remove()
        end
        if (IsValid(smoke)) then
            smoke:Remove()
        end
    end)
end

function ENT:OnRemove()
    if (self.ParticleEffect) then
        self.ParticleEffect:Remove()
    end
end

--PATH lua/entities/unitys-lvs-tx-2112/shared.lua:
ENT.Base = "lvs_base_fakehover"

ENT.PrintName = "TX-2112"
ENT.Author = "DolUnity & Yeetcat"
ENT.Information = "IFV of the Galactic Republic"
ENT.Category = "[LVS][Unity] - Star Wars"

ENT.VehicleCategory = "Star Wars"
ENT.VehicleSubCategory = "Hover Tanks"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/yeetcat/vehicles/bmp.mdl"
ENT.GibModels = {
    "models/gibs/helicopter_brokenpiece_01.mdl",
    "models/gibs/helicopter_brokenpiece_02.mdl",
    "models/gibs/helicopter_brokenpiece_03.mdl",
    "models/combine_apc_destroyed_gib02.mdl",
    "models/combine_apc_destroyed_gib04.mdl",
    "models/combine_apc_destroyed_gib05.mdl",
    "models/props_c17/trappropeller_engine.mdl",
    "models/gibs/airboat_broken_engine.mdl",
}

ENT.AITEAM = 2

ENT.MaxHealth = 2000 * 2 -- Half the health => unusable

ENT.ForceAngleMultiplier = 2
ENT.ForceAngleDampingMultiplier = 1

ENT.ForceLinearMultiplier = 1
ENT.ForceLinearRate = 0.25

ENT.MaxVelocityX = 180
ENT.MaxVelocityY = 180

ENT.MaxTurnRate = 0.5

ENT.BoostAddVelocityX = 120 * 4
ENT.BoostAddVelocityY = 120

ENT.GroundTraceHitWater = true
ENT.GroundTraceLength = 75
ENT.GroundTraceHull = 100

ENT.TurretTurnRate = 75
ENT.TurretElevationRate = 40

ENT.LAATC_PICKUPABLE = true
ENT.LAATC_DROP_IN_AIR = true
ENT.LAATC_PICKUP_POS = Vector(-200,0,25)
ENT.LAATC_PICKUP_Angle = Angle(0,0,0)


function ENT:OnSetupDataTables()
    self:AddDT("Bool", "IsCarried")
    self:AddDT("Bool", "LightsActive")
    self:AddDT("Entity", "GunnerSeat")

    if SERVER then
        self:NetworkVarNotify("IsCarried", self.OnIsCarried)
    end
    self:NetworkVarNotify("lvsLockedStatus", self.OnLockChanged)
end

function ENT:GetAimAngles(ent)
    local trace = self:GetGunnerEyeTrace(ent)
    local barrelPos = self:GetBonePosition(self:LookupBone("barrel"))

    if not trace then return end

    return self:WorldToLocalAngles((trace.HitPos - barrelPos):GetNormalized():Angle())
end

function ENT:OnLockChanged()
    self.StartTime = CurTime()
end

function ENT:GetGunnerEyeTrace(ent, muzzle)
    local muzzle = self:GetAttachment(self:LookupAttachment(muzzle or "muzzle"))

    if not IsValid(ent) then return end

    local trace = util.TraceLine({
        start = muzzle.Pos,
        endpos = (muzzle.Pos + ent:GetAimVector() * 50000),
        filter = self:GetCrosshairFilterEnts()
    })

    return trace
end

function ENT:GetKornetTarget(ent)
    return (self:GetGunnerEyeTrace(ent, "kornet_muzzle") or { HitPos = Vector()}).HitPos
end

function ENT:GetBarrelTrace(muzzle)
    local muzzle = self:GetAttachment(self:LookupAttachment(muzzle or "muzzle"))

    local trace = util.TraceLine({
        start = muzzle.Pos,
        endpos = (muzzle.Pos + muzzle.Ang:Up() * -1 * 50000),
        filter = self:GetCrosshairFilterEnts()
    })

    return trace
end

function ENT:WeaponsInRange(ent)
    if self:GetIsCarried() then return false end

    local AimAngles = self:GetAimAngles(ent)

    if not AimAngles then return false end

    return AimAngles.p <= 45 and AimAngles.p >= -10
end

function ENT:SetPoseParameterTurret(weapon, enableElevation)
    if self:GetDisabled() then return end

    if not self.TurretId then
        self.TurretId = self:LookupBone("turret")
    end
    if not self.BarrelId then
        self.BarrelId = self:LookupBone("barrel")
    end

    if self:GetIsCarried() then
        self:ManipulateBoneAngles(self.BarrelId, Angle(0,0,0))
        self:ManipulateBoneAngles(self.TurretId, Angle(0,0,0))
        return
    end

    if not IsValid(weapon:GetDriver()) and not weapon:GetAI() then return end

    local AimAngles = weapon:WorldToLocal(weapon:GetPos() + weapon:GetDriver():GetAimVector()):Angle()
    AimAngles:Normalize()

    if enableElevation then
        self.Elevation = math.Clamp(math.ApproachAngle(self.Elevation or 0, -AimAngles.p, self.TurretElevationRate * FrameTime()), -5, 45)
        self:ManipulateBoneAngles(self.BarrelId, Angle(0,0,self.Elevation))
    end

    self.Rotation = math.ApproachAngle(self.Rotation or 0, AimAngles.y, self.TurretTurnRate * FrameTime())
    self:ManipulateBoneAngles(self.TurretId, Angle(self.Rotation))
end

function ENT:InitWeapons()
    -- Main Gun
    local weapon = {}
    weapon.Icon = Material("lvs/weapons/hmg.png")
    weapon.Ammo = 600
    weapon.Delay = 0.2
    weapon.HeatRateUp = 0.25
    weapon.HeatRateDown = 0.25
    weapon.Elevation = true
    weapon.Attack = function(ent)
        if self:GetDisabled() then return end

        local base = ent:GetVehicle()

        if not IsValid(base) then return end

        if not base:WeaponsInRange(ent) then return true end

        local muzzle = base:GetAttachment(base:LookupAttachment("muzzle"))

        if not muzzle then return end

        local Pos = muzzle.Pos
        local Dir = muzzle.Ang:Up() * -1

        local bullet = {}
        bullet.Src 	= Pos
        bullet.Dir 	= Dir
        bullet.Spread = Vector(0.01,  0.01, 0)
        bullet.TracerName = "lvs_laser_blue_long"
        bullet.Force = 10000
        bullet.HullSize = 1
        bullet.Damage = 50
        bullet.Velocity = 40000
        bullet.Attacker = ent:GetDriver()
        bullet.Callback = function(att, tr, dmginfo)
            local effectdata = EffectData()
            effectdata:SetStart(Vector(50,50,255))
            effectdata:SetOrigin(tr.HitPos)
            effectdata:SetNormal(tr.HitNormal)
            util.Effect("lvs_laser_impact", effectdata)
        end
        ent:LVSFireBullet(bullet)

        local effectdata = EffectData()
        effectdata:SetStart(Vector(50,50,255))
        effectdata:SetOrigin(bullet.Src)
        effectdata:SetNormal(Dir)
        effectdata:SetEntity(ent)
        util.Effect("lvs_muzzle_colorable", effectdata)

        ent:TakeAmmo()

        if not IsValid(base.soundGun) then return end

        base.soundGun:PlayOnce(100 + math.sin(CurTime() + ent:EntIndex() * 1337) * 5 + math.Rand(-1,1), 1)
    end
    weapon.OnSelect = function(ent)
        ent:EmitSound("physics/metal/weapon_impact_soft3.wav")
    end
    weapon.OnOverheat = function(ent) ent:EmitSound("lvs/overheat.wav") end
    weapon.OnThink = function(ent, active)
        self:SetPoseParameterTurret(ent, active)
    end
    weapon.HudPaint = function(ent, X, Y, ply)
        local base = ent:GetVehicle()

        if not IsValid(base) then return end

        if base:GetIsCarried() then return end

        local Pos2D = base:GetGunnerEyeTrace(ent).HitPos:ToScreen()
        local ActualPos2D = base:GetBarrelTrace().HitPos:ToScreen()

        base:PaintCrosshairCenter(ActualPos2D, color_white)
        base:PaintCrosshairOuter(Pos2D, color_white)
        base:LVSPaintHitMarker(Pos2D)

        base:DrawGunnerOverlay()
    end
    self:AddWeapon(weapon, 2)

    -- Missile
    weapon = {}
    weapon.Icon = Material("lvs/weapons/missile.png")
    weapon.Ammo = 2
    weapon.Delay = 1
    weapon.HeatRateUp = 1
    weapon.HeatRateDown = 0.1
    weapon.Attack = function(ent)
        if self:GetDisabled() then return end

        local base = ent:GetVehicle()

        if not IsValid(base) then return end

        if not base:WeaponsInRange(ent) then return true end

        local muzzle = base:GetAttachment(base:LookupAttachment("kornet_muzzle"))

        if not muzzle then return end

        local Pos = muzzle.Pos + muzzle.Ang:Up() * -100
        local Dir = muzzle.Ang:Up() * -1

        local projectile = ents.Create("lvs_protontorpedo")
        projectile:SetPos(Pos)
        projectile:SetAngles(Dir:Angle())
        projectile:SetParent(ent)
        projectile.GetTarget = function(missile) return missile end
        projectile.GetTargetPos = function(missile)
            if not IsValid(self) then return missile:LocalToWorld( Vector(150,0,0) + VectorRand() * math.random(-10,10) ) end

            return self:GetKornetTarget(ent) or missile:LocalToWorld( Vector(150,0,0) + VectorRand() * math.random(-10,10) )
        end
        projectile:Spawn()
        projectile:Activate()
        projectile:SetAttacker( IsValid( Driver ) and Driver or self )
        projectile:SetEntityFilter(ent:GetCrosshairFilterEnts())
        projectile:SetDamage( 1500 )
        projectile:SetRadius( 300 )
        projectile:Enable()
        projectile:EmitSound( "LVS.IFTX.FIRE_MISSILE" )

        ent:TakeAmmo()
        ent:SetHeat( 1 )
        ent:SetOverheated( true )
    end
    weapon.OnSelect = function(ent)
        ent:EmitSound("weapons/shotgun/shotgun_cock.wav")
    end
    weapon.OnOverheat = function(ent) ent:EmitSound("lvs/overheat.wav") end
    weapon.OnThink = function(ent, active)
        self:SetPoseParameterTurret(ent, active)
    end
    weapon.HudPaint = function(ent, X, Y, ply)
        local base = ent:GetVehicle()

        if not IsValid(base) then return end

        if base:GetIsCarried() then return end

        local Pos2D = base:GetGunnerEyeTrace(ent).HitPos:ToScreen()
        local ActualPos2D = base:GetBarrelTrace("kornet_muzzle").HitPos:ToScreen()

        base:PaintCrosshairCenter(ActualPos2D, color_white)
        base:PaintCrosshairOuter(Pos2D, color_white)
        base:LVSPaintHitMarker(Pos2D)

        base:DrawGunnerOverlay()
    end
    self:AddWeapon(weapon, 2)

    -- Rear Door Control
    weapon = {}
    weapon.Icon = Material("lvs/weapons/gunship_reardoor.png")
    weapon.Ammo = 0
    weapon.Delay = 2
    weapon.HeatRateUp = 0
    weapon.HeatRateDown = 0
    weapon.UseableByAI = false
    weapon.Attack = function(ent)
        if self:GetIsCarried() or self:GetAI() then return end

        if self:GetlvsLockedStatus() then
            self:UnLock()
            return
        end
        self:Lock()
    end
    weapon.OnSelect = function(ent)
        ent:EmitSound("physics/metal/weapon_impact_soft3.wav")
    end
    weapon.OnThink = function(ent, active)
        if self:GetDisabled() then return end

        if self:GetIsCarried() then
            self:SetPoseParameter("door_go", 0)
            ent.IsRampOpen = false
            return
        end

        if not ent.StartTime then return end

        local rampOpen = not self:GetlvsLockedStatus()
        self:SetPoseParameter("door_go", Lerp((CurTime() - ent.StartTime) / 2, rampOpen and 0 or 1, rampOpen and 1 or 0))
    end
    self.StartTime = CurTime()
    self:AddWeapon(weapon)
end

function ENT:ModifySmokes(weapon)
    weapon.HudPaint = function(ent, X, Y, ply)
        local base = ent:GetVehicle()

        if not IsValid(base) then return end

        base:DrawGunnerOverlay()
    end
end

ENT.EngineSounds = {
    {
        sound = "lvs/vehicles/iftx/loop.wav",
        Pitch = 70,
        PitchMin = 0,
        PitchMax = 255,
        PitchMul = 30,
        FadeIn = 0,
        FadeOut = 1,
        FadeSpeed = 1.5,
        UseDoppler = true,
        SoundLevel = 85,
    },
    {
        sound = "lvs/vehicles/iftx/loop_hi.wav",
        Pitch = 70,
        PitchMin = 0,
        PitchMax = 255,
        PitchMul = 30,
        FadeIn = 0,
        FadeOut = 1,
        FadeSpeed = 1.5,
        UseDoppler = true,
        SoundLevel = 85,
    },
    {
        sound = "^lvs/vehicles/iftx/dist.wav",
        Pitch = 70,
        PitchMin = 0,
        PitchMax = 255,
        PitchMul = 30,
        FadeIn = 0,
        FadeOut = 1,
        FadeSpeed = 1.5,
        SoundLevel = 90,
    },
}

sound.Add({
    name = "LVS.IFTX.FIRE_MISSILE",
    channel = CHAN_WEAPON,
    volume = 1.0,
    level = 125,
    pitch = {95, 105},
    sound = "lvs/vehicles/iftx/fire_missile.mp3"
})

--PATH lua/entities/vox_e60r_rocket/cl_init.lua:
return gluapack()()
--PATH lua/entities/vox_e60r_rocket/shared.lua:
 ENT.Type 			= "anim"  
 ENT.PrintName			= "High Explosive Anti-Tank RPG"  
 ENT.Author			= ""  
 ENT.Contact			= ""  
 ENT.Purpose			= ""  
 ENT.Instructions			= ""  
 
ENT.Spawnable			= false
ENT.AdminSpawnable		= false


--PATH lua/entities/vulture.lua:
return gluapack()()
--PATH lua/entities/x-wing.lua:

ENT.RenderGroup = RENDERGROUP_OPAQUE
ENT.Type = "vehicle"
ENT.Base = "fighter_base"

ENT.PrintName = "X-Wing"
ENT.Author = "Liam0102"
ENT.Category = "Star Wars Vehicles: Rebels"
ENT.AutomaticFrameAdvance = true


ENT.EntModel = "models/xwing/xwingtwo1.mdl"
ENT.Vehicle = "XWing"
ENT.StartHealth = 2000;
ENT.Allegiance = "Rebels";
list.Set("SWVehicles", ENT.PrintName, ENT);
util.PrecacheModel("models/xwing/xwingtwo1.mdl")

if SERVER then

ENT.FireSound = Sound("weapons/xwing_shoot.wav");
ENT.NextUse = {Wings = CurTime(),Use = CurTime(),Fire = CurTime(),FireMode = CurTime(),Torpedos = CurTime(),};


AddCSLuaFile();
function ENT:SpawnFunction(pl, tr, ClassName)
	local e = ents.Create(ClassName);
	e:SetPos(tr.HitPos + Vector(0,0,20));
	e:SetAngles(Angle(0,pl:GetAimVector():Angle().Yaw,0));
	e:Spawn();
	e:Activate();
	return e;
end

function ENT:Initialize()
	
	self:SetNWInt("Health",self.StartHealth);
	self.CanRoll = true;
	self.WeaponLocations = {
		TopRight = self:GetPos()+self:GetUp()*117+self:GetRight()*187.5+self:GetForward()*167.5,
		BottomRight = self:GetPos()+self:GetRight()*187+self:GetForward()*167+self:GetUp()*-10,
		TopLeft = self:GetPos()+self:GetUp()*117+self:GetRight()*-187.5+self:GetForward()*167.5,
		BottomLeft = self:GetPos()+self:GetRight()*-187+self:GetForward()*167+self:GetUp()*-10,
	}
	self.WeaponsTable = {};

	self.BoostSpeed = 1250;
	self.ForwardSpeed = 2250;
	self.UpSpeed = 500;
	self.AccelSpeed = 8;
	self.CanStandby = false;
	self.Cooldown = 2;
	self.Overheat = 0;
	self.Overheated = false;
	self.CanShoot = true;
	self.CanRoll = true;
	self.AlternateFire = true;
	self.FireGroup = {"BottomLeft","BottomRight","TopRight","TopLeft"}
	self.HasWings = true;
	self.ExitModifier = {x = 100, y = -80, z = 115};
	self.FireDelay = 0.15;

	self.LandOffset = Vector(0,0,20);
	self.NextUse.Torpedos = CurTime();

	self.Bullet = CreateBulletStructure(80,"red");

	self.BaseClass.Initialize(self)
	self:SpawnLandingGear();


end

local fire = 1;
function ENT:ProtonTorpedos()

	if(self.NextUse.Torpedos < CurTime()) then
		local pos;
		if(fire == 1) then
			pos = self:GetPos()+self:GetUp()*45+self:GetForward()*300+self:GetRight()*-25;
			self.NextUse.Torpedos = CurTime()+0.25;
		elseif(fire == 2) then
			pos = self:GetPos()+self:GetUp()*45+self:GetForward()*300+self:GetRight()*25;
			
		end
		local e = self:FindTarget();
		self:FireTorpedo(pos,e,1500,200,Color(255,50,50,255),15);
		fire = fire + 1;
		if(fire > 2) then
			fire = 1;
			self.NextUse.Torpedos = CurTime()+30;
			self:SetNWInt("FireBlast",self.NextUse.Torpedos)
		else
			self:ProtonTorpedos();
		end

	end
end

function ENT:Think()
	

	if(self.Inflight) then
		if(!self.Wings) then
			self.CanShoot = false;
		else
			self.CanShoot = true;
		end
		
		if(IsValid(self.Pilot)) then
			if(self.Pilot:KeyDown(IN_ATTACK2)) then
				self:ProtonTorpedos();
			end
		end
		
	end
	self.BaseClass.Think(self);
end

function ENT:Enter(p)
	self:RemoveLandingGear();
	self.BaseClass.Enter(self,p);
end

function ENT:Exit(kill)
	self.BaseClass.Exit(self,kill);
	if(self.TakeOff or self.Land or self.Docked) then
		self:SpawnLandingGear();
	end
end

function ENT:SpawnLandingGear()

	local e = ents.Create("prop_physics");
	e:SetModel("models/xwingt70/landgear.mdl")
	e:SetPos(self:GetPos()+self:GetUp()*-2.5);
	e:SetAngles(self:GetAngles());
	e:Spawn();
	e:Activate();
	
	local phys = e:GetPhysicsObject();
	phys:EnableGravity(false);
	phys:EnableDrag(false);
	phys:SetMass(self.Mass);
	constraint.Weld(self,e,0,0,0,true);
	self.LandingGear = e;

end

function ENT:RemoveLandingGear()
	
	if(IsValid(self.LandingGear)) then
		self.LandingGear:Remove();
	end

end

function ENT:OnRemove()
	
	self.BaseClass.OnRemove(self);
	if(IsValid(self.LandingGear)) then
		self.LandingGear:Remove();
	end

end
end

if CLIENT then
	ENT.EnginePos = {}
	ENT.Sounds={
		Engine=Sound("vehicles/xwing/xwing_fly2.wav"),
	}

	local Health = 0;
	local Overheat = 0;
	local Overheated = false;
	local FPV = false;
	local TakeOff;
	local Land;
	ENT.NextView = CurTime();
	function ENT:Think()
		
		local Flying = self:GetNWBool("Flying".. self.Vehicle);
		local Wings = self:GetNWBool("Wings");
		TakeOff = self:GetNWBool("TakeOff");
		Land = self:GetNWBool("Land");

        if(Flying and !TakeOff and !Land) then
            if(Wings) then
                self.EnginePos = {
                    self:GetPos()+self:GetForward()*-160+self:GetUp()*95.5+self:GetRight()*47.5,
                    self:GetPos()+self:GetForward()*-160+self:GetUp()*14.5+self:GetRight()*47.5,
                    self:GetPos()+self:GetForward()*-160+self:GetUp()*95.5+self:GetRight()*-47.5,
                    self:GetPos()+self:GetForward()*-160+self:GetUp()*14.5+self:GetRight()*-47.5,
                }
            else
                self.EnginePos = {
                    self:GetPos()+self:GetForward()*-160+self:GetUp()*86.5+self:GetRight()*56,
                    self:GetPos()+self:GetForward()*-160+self:GetUp()*21.5+self:GetRight()*56,
                    self:GetPos()+self:GetForward()*-160+self:GetUp()*86.5+self:GetRight()*-56,
                    self:GetPos()+self:GetForward()*-160+self:GetUp()*21.5+self:GetRight()*-56,
                }

            end


            //local s = "sprites/orangecore1";
            //local c = Color(255,100,100,255);
            self:FlightEffects();
        end

		self.BaseClass.Think(self);
		
	end
	
	local matPlasma	= Material( "sprites/tfaenginered" )
	function ENT:Draw() 
		self:DrawModel()
		local Flying = self:GetNWBool("Flying".. self.Vehicle);
		local TakeOff = self:GetNWBool("TakeOff");
		local Land = self:GetNWBool("Land");
        if(Flying and !TakeOff and !Land) then
            local vel = self:GetVelocity():Length();
            for i=1,4 do
                local vOffset = self.EnginePos[i] 
                local scroll = CurTime() * -20

                render.SetMaterial( matPlasma )
                scroll = scroll * 0.9

                local middleVel = math.Clamp((vel/50)/2,0,5);
                local lastVel = math.Clamp(vel/50,0,45);

                render.StartBeam( 3 )
                    render.AddBeam( vOffset, 32, scroll, Color( 0, 255, 255, 255) )
                    render.AddBeam( vOffset + self:GetForward()*-middleVel, 24, scroll + 0.01, Color( 255, 255, 255, 255) )
                    render.AddBeam( vOffset + self:GetForward()*-lastVel, 16, scroll + 0.02, Color( 0, 255, 255, 0) )
                render.EndBeam()

                scroll = scroll * 0.9

                render.StartBeam( 3 )
                    render.AddBeam( vOffset, 32, scroll, Color( 0, 255, 255, 255) )
                    render.AddBeam( vOffset + self:GetForward()*-middleVel, 24, scroll + 0.01, Color( 255, 255, 255, 255) )
                    render.AddBeam( vOffset + self:GetForward()*-lastVel, 16, scroll + 0.02, Color( 0, 255, 255, 0) )
                render.EndBeam()

                scroll = scroll * 0.9

                render.StartBeam( 3 )
                    render.AddBeam( vOffset, 32, scroll, Color( 0, 255, 255, 255) )
                    render.AddBeam( vOffset + self:GetForward()*-middleVel, 24, scroll + 0.01, Color( 255, 255, 255, 255) )
                    render.AddBeam( vOffset + self:GetForward()*-lastVel, 16, scroll + 0.02, Color( 0, 255, 255, 0) )
                render.EndBeam()
            end
        end
	end

    ENT.ViewDistance = 700;
    ENT.ViewHeight = 200;
    ENT.FPVPos = Vector(70,0,92);

	
	local HUD = surface.GetTextureID("vgui/xwing2_cockpit")
	local Glass = surface.GetTextureID("models/props_c17/frostedglass_01a_dx60")
	ENT.CanFPV = true;
	function XWingReticle()
		
		local p = LocalPlayer();
		local Flying = p:GetNWBool("FlyingXWing");
		local self = p:GetNWEntity("XWing");
		

		if(Flying and IsValid(self)) then
			local x = ScrW()/4*0.1;
			local y = ScrH()/4*2.5;
			if(self:GetFPV()) then
				SW_HUD_FPV(HUD);				
				SW_HUD_WingsIndicator("xwing",x,y);
			end

			SW_HUD_DrawHull(2000);
			SW_WeaponReticles(self);
			SW_HUD_DrawOverheating(self);
			SW_HUD_Compass(self);
			SW_HUD_DrawSpeedometer();
			SW_BlastIcon(self,30);

		end
	end
	hook.Add("HUDPaint", "XWingReticle", XWingReticle)

	
	function ENT:FlightEffects()
		local normal = (self:GetForward() * -1):GetNormalized()
		local roll = math.Rand(-90,90)	
		local FWD = self:GetForward();
		local id = self:EntIndex();
		for k,v in pairs(self.EnginePos) do
            local red = self.FXEmitter:Add("sprites/orangecore1",v)
            red:SetVelocity(normal)
            red:SetDieTime(FrameTime()*1.25)
            red:SetStartAlpha(255)
            red:SetEndAlpha(255)
            red:SetStartSize(14)
            red:SetEndSize(10)
            red:SetRoll(roll)
            red:SetColor(255,100,100)

            local white = self.FXEmitter:Add("sprites/white_blast",v)
            white:SetVelocity(normal)
            white:SetDieTime(FrameTime()*1.25)
            white:SetStartAlpha(150)
            white:SetEndAlpha(150)
            white:SetStartSize(7)
            white:SetEndSize(5)
            white:SetRoll(roll)
            white:SetColor(255,255,255)

            local dynlight = DynamicLight(id + 4096 * k);
            dynlight.Pos = v+FWD*5;
            dynlight.Brightness = 5;
            dynlight.Size = 150;
            dynlight.Decay = 1024;
            dynlight.R = 255;
            dynlight.G = 100;
            dynlight.B = 100;
            dynlight.DieTime = CurTime()+1;
		end
		
        /*
		local pos = self:GetPos()+self:GetForward()*-205+self:GetUp()*60+self:GetRight()*0;			
		
		local dynlight = DynamicLight(id + 4096);
		dynlight.Pos = pos;
		dynlight.Brightness = 5;
		dynlight.Size = 200;
		dynlight.Decay = 1024;
		dynlight.R = 255;
		dynlight.G = 100;
		dynlight.B = 100;
		dynlight.DieTime = CurTime()+1;
            */
	end
	
end
--PATH lua/entities/y-wing.lua:


ENT.RenderGroup = RENDERGROUP_OPAQUE
ENT.Type = "vehicle"
ENT.Base = "fighter_base"

ENT.PrintName = "Y-Wing"
ENT.Author = "Liam0102"
ENT.Category = "Star Wars Vehicles: Rebels"
ENT.AutomaticFrameAdvance = true
ENT.Spawnable = false;
ENT.AdminSpawnable = false;

ENT.EntModel = "models/ywing/ywing.mdl"
ENT.FlyModel = "models/ywing/ywing1.mdl"
ENT.Vehicle = "YWing"
ENT.StartHealth = 1500;
ENT.Allegiance = "Rebels";
list.Set("SWVehicles", ENT.PrintName, ENT);
util.PrecacheModel("models/ywing/ywing1.mdl")

if SERVER then

ENT.FireSound = Sound("weapons/xwing_shoot.wav");
ENT.NextUse = {Wings = CurTime(),Use = CurTime(),Fire = CurTime(),FireMode = CurTime(),};


AddCSLuaFile();
function ENT:SpawnFunction(pl, tr)
	local e = ents.Create("y-wing");
	e:SetPos(tr.HitPos + Vector(0,0,5));
	e:SetAngles(Angle(0,pl:GetAimVector():Angle().Yaw,0));
	e:Spawn();
	e:Activate();
	return e;
end

function ENT:Initialize()
	
	self:SetNWInt("Health",self.StartHealth);
	self.CanRoll = true;
	self.WeaponLocations = {
		Left = self:GetPos()+self:GetForward()*80+self:GetUp()*100+self:GetRight()*-3,
		Right = self:GetPos()+self:GetForward()*80+self:GetUp()*100+self:GetRight()*4,
	}
	self.WeaponsTable = {};
	//self:SpawnWeapons();
	self.BoostSpeed = 2100;
	self.ForwardSpeed = 1250;
	self.UpSpeed = 500;
	self.AccelSpeed = 7;
	
	self.CanShoot = true;
	self.AlternateFire = true;
	self.FireGroup = {"Left","Right"};
	
	self.Cooldown = 2;
	self.Overheat = 0;
	self.Overheated = false;
	self.Bullet = CreateBulletStructure(85,"red");

	self.BaseClass.Initialize(self)
end


function ENT:Enter(p)
	
	if(not self.Inflight) then		
		self:SetModel(self.FlyModel);
	end
	self.BaseClass.Enter(self,p)
end

function ENT:Exit(kill)	
	if(self.Inflight and self.TakeOff) then
		self:SetModel(self.EntModel);
	end
	self.BaseClass.Exit(self,kill);
end

function ENT:Think()
	self.BaseClass.Think(self);
	if(self.Inflight) then
		if(IsValid(self.Pilot)) then
			
			if(IsValid(self.Pilot) and self.Pilot:KeyDown(IN_ATTACK2)) then
				self:FireBlast(self:GetPos()+self:GetForward()*-220,true,0.5,600,false,20);
			end
		end
	end

end

end

if CLIENT then

	function ENT:Draw() self:DrawModel() end
	
	ENT.EnginePos = {}
	ENT.Sounds={
		Engine=Sound("vehicles/xwing/xwing_fly2.wav"),
	}
	function ENT:Initialize()	
		self.BaseClass.Initialize(self);
	end
	
	function ENT:FlightEffects()
		local normal = (self:GetForward() * -1):GetNormalized()
		local roll = math.Rand(-90,90)
		local p = LocalPlayer()		
		local FWD = self:GetForward();
		local id = self:EntIndex();

		for k,v in pairs(self.EnginePos) do
			local red = self.FXEmitter:Add("sprites/orangecore1",v)
			red:SetVelocity(normal)
			red:SetDieTime(0.08)
			red:SetStartAlpha(255)
			red:SetEndAlpha(255)
			red:SetStartSize(15)
			red:SetEndSize(13.5)
			red:SetRoll(roll)
			red:SetColor(255,100,100)
			
			
			
			local heat = self.FXEmitter:Add("sprites/heatwave",v)
			heat:SetVelocity(normal)
			heat:SetDieTime(0.08)
			heat:SetStartAlpha(255)
			heat:SetEndAlpha(255)
			heat:SetStartSize(15)
			heat:SetEndSize(13.5)
			heat:SetRoll(roll)
			heat:SetColor(255,100,100)
			
			local dynlight = DynamicLight(id + 4096*k);
			dynlight.Pos = v+FWD*-25;
			dynlight.Brightness = 5;
			dynlight.Size = 100;
			dynlight.Decay = 1024;
			dynlight.R = 255;
			dynlight.G = 100;
			dynlight.B = 100;
			dynlight.DieTime = CurTime()+1;

		end
	
	end
	
	ENT.CanFPV = true;
	
	local Health = 0;
	function ENT:Think()
		self.BaseClass.Think(self);
		
		local p = LocalPlayer();
		local Flying = self:GetNWBool("Flying".. self.Vehicle);
		local TakeOff = self:GetNWBool("TakeOff");
		local Land = self:GetNWBool("Land");
		if(Flying) then
			self.EnginePos = {
				self:GetPos()+self:GetUp()*53+self:GetRight()*122+self:GetForward()*-270,
				self:GetPos()+self:GetUp()*53+self:GetRight()*-122+self:GetForward()*-270,
			}
			if(!TakeOff and !Land) then
				self:FlightEffects();
			end
			Health = self:GetNWInt("Health");
		end
		
		
	end
	
    ENT.ViewDistance = 700;
    ENT.ViewHeight = 200;
    ENT.FPVPos = Vector(95,0,88);
	
	local HUD = surface.GetTextureID("vgui/ywing_cockpit");
	function YWingReticle()
		
		local p = LocalPlayer();
		local Flying = p:GetNWBool("FlyingYWing");
		local self = p:GetNWEntity("YWing");
		

		if(Flying and IsValid(self)) then

			local FPV = self:GetFPV();
			if(FPV) then
				SW_HUD_FPV(HUD);
			end
			
			SW_HUD_DrawHull(1500);
			SW_WeaponReticles(self);
			SW_HUD_DrawOverheating(self);
			SW_BlastIcon(self);
			local x = ScrW()/4*1;
			local y = ScrH()/4*3.3;
			SW_HUD_Compass(self,x,y);
			SW_HUD_DrawSpeedometer();
		end
	end
	hook.Add("HUDPaint", "YWingReticle", YWingReticle)

end
--PATH lua/effects/arc9_aftershoteffect.lua:
function EFFECT:Init(data)
	local wpn = data:GetEntity()

	if !IsValid(wpn) then self:Remove() return end

	local smoke = wpn:GetProcessedValue("AfterShotParticle", true)

	local att = data:GetAttachment() or 1

	local vm = LocalPlayer():GetViewModel()

	local wm = false

	if (LocalPlayer():ShouldDrawLocalPlayer() or wpn.Owner != LocalPlayer()) then
		wm = true
		att = 1
	end

	local parent = wpn

	if !wm then
		parent = vm
	else
		parent = (wpn.WModel or {})[1] or wpn
	end

	local muz = wpn:GetMuzzleDevice(wm)

	if !IsValid(muz) then
		muz = wpn
	end

	if !IsValid(muz) then
		self:Remove()
		return
	end

	-- if !IsValid(parent) then return end

	if smoke then
		if IsValid(wpn.ActiveAfterShotPCF) then
			wpn.ActiveAfterShotPCF:StopEmission()
		end

		local pcf = CreateParticleSystem(muz or parent, smoke, PATTACH_POINT_FOLLOW, att)

		if IsValid(pcf) then
			pcf:StartEmission()

			wpn.ActiveAfterShotPCF = pcf
			if (muz or parent) != vm then
				pcf:SetShouldDraw(false)
				table.insert(wpn.PCFs, pcf)
			end
		end
	end
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end
--PATH lua/effects/arccw_incendiaryround.lua:
return gluapack()()
--PATH lua/effects/fxbase.lua:
return gluapack()()
--PATH lua/effects/fxbase.lua:
return gluapack()()
--PATH lua/effects/astw2_muzzleflash_swrc_blue/init.lua:
local AddVel = Vector()

function EFFECT:Init(data)
    local quality = GetConVar("astw2_quality"):GetInt()
    if GetConVar("astw2_force_effect_minlevel_1"):GetBool() and quality == 0 then
        quality = 1
    end

    if quality == 0 then return end

    self.WeaponEnt = data:GetEntity()
    if !IsValid(self.WeaponEnt) then return end
    self.Owner = self.WeaponEnt:GetOwner()
    if !IsValid(self.Owner) then return end
    local dir = data:GetNormal()
    local scale = self.WeaponEnt.Primary.Damage * self.WeaponEnt.Primary.Num
    scale = scale * 0.025

    self.vOffset = self.WeaponEnt:GetBorePos()

    AddVel = self.WeaponEnt.Owner:GetVelocity()

    local emitter = ParticleEmitter(self.vOffset)

    if !self.WeaponEnt.Suppressed then
        local particle = emitter:Add("effects/swrc/a_FLASHBLUE", self.vOffset)

        if (particle) then
            particle:SetVelocity(AddVel)
            particle:SetLifeTime(0)
            particle:SetDieTime(math.Rand(0.07 ,0.1))
            particle:SetStartAlpha(155)
            particle:SetEndAlpha(0)
            particle:SetStartSize(math.Rand(5, 10))
            particle:SetEndSize(scale * math.Rand(40, 60))
            particle:SetLighting(false)
            particle:SetRoll(math.random(0, 0))
            particle:SetColor(255, 255, 255)
        end
	local particle2 = emitter:Add("effects/swrc/energyBall_A", self.vOffset)

        if (particle2) then
            particle2:SetVelocity(AddVel)
            particle2:SetLifeTime(0)
            particle2:SetDieTime(math.Rand(0.1 ,0.15))
            particle2:SetStartAlpha(255)
            particle2:SetEndAlpha(0)
            particle2:SetStartSize(math.Rand(2, 5))
            particle2:SetEndSize(scale * math.Rand(20, 30))
            particle2:SetLighting(false)
            particle2:SetRoll(math.random(-5, 5))
            particle2:SetColor(200, 200, 255)
        end
		

    end

       
    local particlecount = quality * 2


    if quality >= 3 then
        local particle = emitter:Add("sprites/heatwave", self.vOffset)

        if (particle) then
            particle:SetVelocity((dir * 25) + 1.05 * AddVel)
            particle:SetLifeTime(0)
            particle:SetDieTime(0.1)
            particle:SetStartAlpha(255)
            particle:SetEndAlpha(0)
            particle:SetStartSize(math.Rand(80, 100))
            particle:SetEndSize(0)
            particle:SetRoll(math.Rand(0, 360))
            particle:SetRollDelta(math.Rand(-2, 2))
            particle:SetAirResistance(5)
            particle:SetGravity(Vector(0, 0, 40))
            particle:SetColor(255, 255, 255)
        end
    end

    emitter:Finish()
end

function EFFECT:Think()
    return false
end

function EFFECT:Render()
end
--PATH lua/effects/astw2_swrc_explosion_thermal_detonator/init.lua:

function EFFECT:Init(data)
    self.Origin = data:GetOrigin()
    local emitter = ParticleEmitter( self.Origin + Vector( 0, 0, 16 ) )
local light = DynamicLight(self:EntIndex())
        if (light) then
            light.Pos = self:GetPos()
            light.r = 255
            light.g = 100
            light.b = 100
            light.Brightness = 5
            light.Decay = 10
            light.Size = 256
            light.DieTime = CurTime() + 0.3
        end
    local particle = emitter:Add("effects/swbf/explosion", self.Origin)

    particle:SetVelocity( 25 * VectorRand() )
    particle:SetDieTime( 0.7 )
    particle:SetStartAlpha( 255 )
    particle:SetEndAlpha( 0 )
    particle:SetStartSize( math.Rand(50,75) )
    particle:SetEndSize( math.Rand(100,175) )
    particle:SetRoll( math.Rand(0,360) )
    particle:SetRollDelta( math.Rand(-3,3) )
    particle:SetColor( 255, 200, 200 )
    particle:SetAirResistance( 55 )
    particle:SetLighting( false )
    particle:SetCollide( false )

    for i = 0,5 do
        particle = emitter:Add( "effects/swbf/explosion" , self.Origin )

        particle:SetVelocity( 750 * VectorRand() )
        particle:SetDieTime( math.Rand(0.5, 1.5) )
        particle:SetStartAlpha( 200 )
        particle:SetEndAlpha( 0 )
        particle:SetStartSize( math.Rand(75,100) )
        particle:SetEndSize( math.Rand(150,175) )
        particle:SetRoll( math.Rand(0,360) )
        particle:SetRollDelta( math.Rand(-1,1) )
        particle:SetColor( 200,255,150 )
        particle:SetAirResistance( 200 )
        particle:SetGravity( Vector( 0, 0, math.Rand(10,40) ) )
        particle:SetLighting( true )
        particle:SetCollide( true )
        particle:SetBounce( 0.5 )
    end

    particle = emitter:Add( "sprites/heatwave", self.Origin )
        particle:SetAirResistance( 0 )
        particle:SetDieTime( 1.5 )
        particle:SetStartAlpha( 255 )
        particle:SetEndAlpha( 255 )
        particle:SetStartSize( 250 ) 
        particle:SetEndSize( 0 )
        particle:SetRoll( math.Rand(180,480) )
        particle:SetRollDelta( math.Rand(-5,5) )
        particle:SetColor( 255, 255, 255 )

    emitter:Finish()

end

function EFFECT:Think()
    return false
end

function EFFECT:Render()
end
--PATH lua/effects/bliz_tracer.lua:
AddCSLuaFile()
AddCSLuaFile( "effects/fxbase.lua" )
include( "effects/fxbase.lua" )

EFFECT.Speed	= 13000
EFFECT.Length	= 64
EFFECT.Trace	= Material( "effects/bliz_needlez" )
EFFECT.Halo		= Material( "effects/blueflare1" )
EFFECT.FlyBy	= "npc/manhack/mh_blade_snick1.wav"

function EFFECT:Init( data )

	self.StartPos = self:GetTracerOrigin( data )
	self.EndPos = data:GetOrigin()
	self.Parent = data:GetEntity()
	
	self.Entity:SetRenderBoundsWS( self.StartPos, self.EndPos )

	local diff = ( self.EndPos - self.StartPos )
	
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	self.LifeTime = ( diff:Length() + self.Length ) / self.Speed
	
	if ( IsValid( self.Parent ) and ( !self.Parent:IsWeapon() or !self.Parent:IsCarriedByLocalPlayer() ) ) then

		local dist, pos, time = util.DistanceToLine( self.StartPos, self.EndPos, EyePos() )
		if( dist <= 100 ) then
			EmitSound( self.FlyBy, pos, self.Parent:EntIndex(), CHAN_STATIC, 1, 100, 0, math.random( 80, 120 ) )
		end

	end

end

function EFFECT:Render()

	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	
	startDistance = math.max( 0, startDistance )
	endDistance = math.max( 0, endDistance )
	
	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance * 2
	
--	render.SetMaterial( self.Halo )
--	render.DrawSprite( startPos, 32, 32, Color( 255, 255, 255, 10 ) )

	render.SetMaterial( self.Trace )
	render.DrawBeam( startPos, endPos, 8, 0, 1, Color( 255, 255, 255, 255 ) )
	
	local dlight = DynamicLight( -1 )
	if ( dlight ) then
		dlight.pos = endPos
		dlight.r = 210
		dlight.g = 205
		dlight.b = 255
		dlight.brightness = 2
		dlight.Decay = 2048
		dlight.Size = 128
		dlight.DieTime = CurTime() + 1
	end

end
--PATH lua/effects/blue_tracer_fx.lua:

TRACER_FLAG_USEATTACHMENT	= 0x0002;
SOUND_FROM_WORLD			= 0;
CHAN_STATIC					= 6;

EFFECT.Speed				= 6500;
EFFECT.Length				= 64;
//EFFECT.WhizSound			= Sound( "nomad/whiz.wav" );		-- by Robinhood76 (http:--www.freesound.org/people/Robinhood76/sounds/96556/)
EFFECT.WhizDistance			= 72;

local MaterialMain			= Material( "effects/sw_laser_blue_main" );
local MaterialFront			= Material( "effects/sw_laser_blue_front" );

function EFFECT:GetTracerOrigin( data )

	-- this is almost a direct port of GetTracerOrigin in fx_tracer.cpp
	local start = data:GetStart();
	
	-- use attachment?
	if( bit.band( data:GetFlags(), TRACER_FLAG_USEATTACHMENT ) == TRACER_FLAG_USEATTACHMENT ) then

		local entity = data:GetEntity();
		
		if( not IsValid( entity ) ) then return start; end
		if( not game.SinglePlayer() and entity:IsEFlagSet( EFL_DORMANT ) ) then return start; end
		
		if( entity:IsWeapon() and entity:IsCarriedByLocalPlayer() ) then
			-- can't be done, can't call the real function
			-- local origin = weapon:GetTracerOrigin();
			-- if( origin ) then
			-- 	return origin, angle, entity;
			-- end
			
			-- use the view model
			local pl = entity:GetOwner();
			if( IsValid( pl ) ) then
				local vm = pl:GetViewModel();
				if( IsValid( vm ) and not LocalPlayer():ShouldDrawLocalPlayer() ) then
					entity = vm;
				else
					-- HACK: fix the model in multiplayer
					if( entity.WorldModel ) then
						entity:SetModel( entity.WorldModel );
					end
				end
			end
		end

		local attachment = entity:GetAttachment( data:GetAttachment() );
		if( attachment ) then
			start = attachment.Pos;
		end

	end
	
	return start;

end


function EFFECT:Init( data )

	self.StartPos = self:GetTracerOrigin( data );
	self.EndPos = data:GetOrigin();
	
	self.Entity:SetRenderBoundsWS( self.StartPos, self.EndPos );

	local diff = ( self.EndPos - self.StartPos );
	
	self.Normal = diff:GetNormal();
	self.StartTime = 0;
	self.LifeTime = ( diff:Length() + self.Length ) / self.Speed;
	
	-- whiz by sound
	local weapon = data:GetEntity();
	if( IsValid( weapon ) and ( not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer() ) ) then

		local dist, pos, time = util.DistanceToLine( self.StartPos, self.EndPos, EyePos() );
	end

end


function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime();
	self.StartTime = self.StartTime + FrameTime(); 

	return self.LifeTime > 0;

end


function EFFECT:Render()

	local endDistance = self.Speed * self.StartTime;
	local startDistance = endDistance - self.Length;
	
	startDistance = math.max( 0, startDistance );
	endDistance = math.max( 0, endDistance );

	local startPos = self.StartPos + self.Normal * startDistance;
	local endPos = self.StartPos + self.Normal * (endDistance*1.2);
	
	render.SetMaterial( MaterialFront );
	render.DrawSprite( endPos, 32, 24, color_white );

	render.SetMaterial( MaterialMain );
	render.DrawBeam( startPos, endPos, 20, 0, 1, color_white );
	
end

--PATH lua/effects/celest_blighten.lua:
return gluapack()()
--PATH lua/effects/celest_dissolve_wrath.lua:
local mat_glow = Material( "models/elemental/celest_dissolve" )

local cmd_sunbeams = GetConVar( "sfw_fx_individualsunbeams" )

EFFECT.Origin = Vector( 0, 0, 0 )
EFFECT.Edge = Vector( 0, 0, 0 )
EFFECT.Direction = false
EFFECT.DirectionSet = false

function EFFECT:Init( data )

	self.Time = 2.2
	self.LifeTime = CurTime() + self.Time
	
	local ent = data:GetEntity()
	
	if ( !IsValid( ent ) ) then return end
	if ( !ent:GetModel() ) then return end
	
	self.ParentEntity = ent
	
	self:SetModel( ent:GetModel() )	
	self:SetPos( ent:GetPos() )
	self:SetAngles( ent:GetAngles() )
	self:SetParent( ent )
	self.Flags = data:GetFlags()
	
	self.ParentEntity.RenderOverride = self.RenderParent
	self.ParentEntity.SpawnEffect = self
	
	self.Origin = data:GetOrigin() || self:GetPos()

end

function EFFECT:Think( )

	if ( !IsValid( self.ParentEntity ) ) then return false end
	
	local PPos = self.ParentEntity:GetPos()
	self:SetPos( PPos + (EyePos() - PPos):GetNormal() )
	
	if ( self.LifeTime > CurTime() ) then
		return true
	end
	
	self.ParentEntity.RenderOverride = nil
	self.ParentEntity.SpawnEffect = nil
			
	return false
	
end

function EFFECT:Render()

	if ( self.Flags == 8 ) then
		self:RenderOverlay( self.ParentEntity )
	end

end

function EFFECT:RenderOverlay( entity )
		
	local Fraction = ( self.LifeTime - CurTime() ) / self.Time
	local ColFrac = ( Fraction - 0.5 ) * 2
	
	Fraction = math.Clamp( Fraction, 0, 1 )
	ColFrac =  math.Clamp( ColFrac, 0, 1 )

	local EyeNormal = entity:GetPos() - EyePos()
	local Distance = EyeNormal:Length()
	EyeNormal:Normalize()
	
	local Pos = EyePos() + EyeNormal * Distance * 0.01
	local bClipping = self:StartClip( entity, 1 )

	local amount = math.Clamp( -0.2 + Fraction, 0, 1 )
	render.SetColorModulation( amount, amount, amount )
	
	cam.Start3D( Pos, EyeAngles() )
		render.MaterialOverride()
		entity:DrawModel()
	cam.End3D()

	render.PopCustomClipPlane()
	render.EnableClipping( bClipping )
	
	local bSunBeams = cmd_sunbeams:GetBool()
	if ( !bSunBeams ) then return bEnabled end 
	
	local screen = self.Edge
	local vNormal = screen - EyePos()
	
	local dot = ( vNormal:Dot( EyeVector() ) - 0.8 ) * 5
	if ( dot <= 0 ) then return bEnabled end

	screen = screen + ( vNormal * 16384 )
	screen = screen:ToScreen()
	
	local glowSize = math.max( 0.05 * Fraction, 0.001 ) -- math.max( mn:Length() * 0.0005, 0.01 )
	
	local w, h = ScrW(), ScrH()

	local glowX, glowY = screen.x, screen.y
	DrawSunbeams( 0.85, 0.25 * ( 1 - Fraction ), glowSize, glowX / w, glowY / h )

end

function EFFECT:RenderParent()

	local bClipping = self.SpawnEffect:StartClip( self, 0.7 )
	
	render.SetColorModulation( 16, 0.12, 0.1 )
	render.MaterialOverride( mat_glow )
	
	self:DrawModel()
	
	render.PopCustomClipPlane()
	render.EnableClipping( bClipping )
	
	self.SpawnEffect:RenderOverlay( self )

end

function EFFECT:StartClip( model, spd )

	local mn, mx = model:GetRenderBounds()
	local me = model:EyePos()
	local mc = model:OBBCenter()

	local Top, Bottom, Up
	
	if ( !self.DirectionSet ) then
		self.Direction = ( self.Origin:Dot( mc ) > 0 )
		self.DirectionSet = true
	end
	
	if ( self.Direction ) then
		Top = me + mx
		Bottom = me + mn
		Up = (mn-mx):GetNormal()
	else
		Top = me + mn
		Bottom = me + mx
		Up = (mx-mn):GetNormal()
	end

	local Fraction = ( self.LifeTime - CurTime() ) / self.Time
	Fraction = math.Clamp( Fraction / spd, 0, 1 )
	
	local Lerped = LerpVector( Fraction, Bottom, Top )
	
	local normal = ( Bottom - Top ):GetNormal() -- Up 
	local distance = normal:Dot( Lerped )
	local bEnabled = render.EnableClipping( true )
	render.PushCustomClipPlane( normal, distance )
	
	local mLight = DynamicLight( -1 )
	if ( mLight ) then
		mLight.pos = Lerped
		mLight.r = 255
		mLight.g = 20
		mLight.b = 0
		mLight.brightness = 2 * Fraction
		mLight.Size = 180 + 300 * Fraction
		mLight.Decay = 1024
		mLight.Style = 1
		mLight.DieTime = CurTime() + 1
	end
	
	self.Edge = Lerped

	return bEnabled
	
end
--PATH lua/effects/cod2019_grenade_explosion.lua:
return gluapack()()
--PATH lua/effects/crsv_dissolve.lua:
local mat_glow = Material( "models/elemental/burned_glow" )

function EFFECT:Init( data )

	self.Time = 2.2
	self.LifeTime = CurTime() + self.Time
	
	local ent = data:GetEntity()
	
	if ( !IsValid( ent ) ) then return end
	if ( !ent:GetModel() ) then return end
	
	self.ParentEntity = ent
	self:SetModel( ent:GetModel() )	
	self:SetPos( ent:GetPos() )
	self:SetAngles( ent:GetAngles() )
	self:SetParent( ent )
	self.Flags = data:GetFlags()
	
	self.ParentEntity.RenderOverride = self.RenderParent
	self.ParentEntity.SpawnEffect = self

end

function EFFECT:Think( )

	if ( !IsValid( self.ParentEntity ) ) then return false end
	
	local PPos = self.ParentEntity:GetPos()
	self:SetPos( PPos + (EyePos() - PPos):GetNormal() )
	
	if ( self.LifeTime > CurTime() ) then
		return true
	end
	
	self.ParentEntity.RenderOverride = nil
	self.ParentEntity.SpawnEffect = nil
			
	return false
	
end

function EFFECT:Render()

	if ( self.Flags == 8 ) then
		self:RenderOverlay( self.ParentEntity )
	end

end

function EFFECT:RenderOverlay( entity )
	
	local Fraction = ( self.LifeTime - CurTime() ) / self.Time
	local ColFrac = ( Fraction - 0.5 ) * 2
	
	Fraction = math.Clamp( Fraction, 0, 1 )
	ColFrac =  math.Clamp( ColFrac, 0, 1 )

	local EyeNormal = entity:GetPos() - EyePos()
	local Distance = EyeNormal:Length()
	EyeNormal:Normalize()
	
	local Pos = EyePos() + EyeNormal * Distance * 0.01
	local bClipping = self:StartClip( entity, 0.5 )
	
	local amount = math.Clamp( 1 - Fraction, 0, 0.5 )
	render.SetColorModulation( 1 - amount, 1.1 - amount, 1 - amount )
	
	cam.Start3D( Pos, EyeAngles() )
		render.MaterialOverride()
		entity:DrawModel()
	cam.End3D()
	
	render.PopCustomClipPlane()
	render.EnableClipping( bClipping )

end

function EFFECT:RenderParent()

	local bones = self:GetBoneCount()
	for bone = 1, bones-1 do
		local scale = self:GetManipulateBoneScale( bone )
		self:ManipulateBoneScale( bone, scale * 0.996 )
	end	
	
	local bClipping = self.SpawnEffect:StartClip( self, 0.4 )
	
	render.SetColorModulation( 0.72, 4, 0.2 )
	render.MaterialOverride( mat_glow )
	
	self:DrawModel()
	
	render.PopCustomClipPlane()
	render.EnableClipping( bClipping )
	
	self.SpawnEffect:RenderOverlay( self )
	
end

function EFFECT:StartClip( model, spd )

	local mn, mx = model:GetRenderBounds()
	local Up = (mx-mn):GetNormal()
	local Bottom =  model:EyePos() + mn
	local Top = model:EyePos() + mx
	
	local Fraction = ( self.LifeTime - CurTime() ) / self.Time
	Fraction = math.Clamp( Fraction / spd, 0, 1 )
	
	local Lerped = LerpVector( Fraction, Top, Bottom )

	local normal = Up 
	local distance = normal:Dot( Lerped )
	local bEnabled = render.EnableClipping( true )
	render.PushCustomClipPlane( normal, distance )

	return bEnabled
	
end

--PATH lua/effects/csgo_muzzle_assaultrifle/init.lua:
return gluapack()()
--PATH lua/effects/csgo_muzzle_autoshotgun/init.lua:
local ang

EFFECT.WeaponEnt = nil

local lighconvar = GetConVar("arc9_muzzle_light")
local otherconvar = GetConVar("arc9_muzzle_others")

EFFECT.ParticleName = "weapon_muzzle_flash_autoshotgun"

function EFFECT:Init(data)
	self.WeaponEnt = data:GetEntity()
	if not IsValid(self.WeaponEnt) then return end

    if !otherconvar:GetBool() and LocalPlayer() != self.WeaponEnt:GetOwner() then
        self:Remove()
        return
    end	

	self.Attachment = data:GetAttachment()
	self.Position = self:GetTracerShootPos(data:GetOrigin(), self.WeaponEnt, self.Attachment)

	if IsValid(self.WeaponEnt.Owner) then
		if self.WeaponEnt.Owner == LocalPlayer() then
			if not self.WeaponEnt:IsFirstPerson() then
				ang = self.WeaponEnt.Owner:EyeAngles()
				ang:Normalize()
				--ang.p = math.max(math.min(ang.p,55),-55)
				self.Forward = ang:Forward()
			else
				self.WeaponEnt = self.WeaponEnt.Owner:GetViewModel()
			end
			--ang.p = math.max(math.min(ang.p,55),-55)
		else
			ang = self.WeaponEnt.Owner:EyeAngles()
			ang:Normalize()
			self.Forward = ang:Forward()
		end
	end

	self.Forward = self.Forward or data:GetNormal()
	self.Angle = self.Forward:Angle()
	
	if !self.WeaponEnt:GetProcessedValue("Silencer") and !self.WeaponEnt:GetProcessedValue("NoFlash", true) and lighconvar:GetBool() then
		local dlight = DynamicLight(self.WeaponEnt:EntIndex())
		if (dlight) then
			dlight.pos = self.Position + self.Angle:Up() * 3 + self.Angle:Right() * -2
			dlight.r = 255
			dlight.g = 192
			dlight.b = 64
			dlight.brightness = 5
			dlight.Size = math.Rand(32, 64)
			dlight.Decay = math.Rand(32, 64) / 0.05
			dlight.DieTime = CurTime() + 0.05
		end
	end

	local pcf = CreateParticleSystem(self.WeaponEnt, self.ParticleName, PATTACH_POINT_FOLLOW, self.Attachment)
	if IsValid(pcf) then
		pcf:StartEmission()
	end
	timer.Simple(3.0, function()
		if IsValid(pcf) then
			pcf:StopEmissionAndDestroyImmediately()
		end
	end)
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end
--PATH lua/effects/csgo_muzzle_he/init.lua:
return gluapack()()
--PATH lua/effects/csgo_muzzle_pistol_silenced/init.lua:
local ang

EFFECT.WeaponEnt = nil

local otherconvar = GetConVar("arc9_muzzle_others")

EFFECT.ParticleName = "weapon_muzzle_flash_pistol_silenced"

function EFFECT:Init(data)
	self.WeaponEnt = data:GetEntity()
	if not IsValid(self.WeaponEnt) then return end
	
    if !otherconvar:GetBool() and LocalPlayer() != self.WeaponEnt:GetOwner() then
        self:Remove()
        return
    end	

	self.Attachment = data:GetAttachment()
	self.Position = self:GetTracerShootPos(data:GetOrigin(), self.WeaponEnt, self.Attachment)

	if IsValid(self.WeaponEnt.Owner) then
		if self.WeaponEnt.Owner == LocalPlayer() then
			if not self.WeaponEnt:IsFirstPerson() then
				ang = self.WeaponEnt.Owner:EyeAngles()
				ang:Normalize()
				--ang.p = math.max(math.min(ang.p,55),-55)
				self.Forward = ang:Forward()
			else
				self.WeaponEnt = self.WeaponEnt.Owner:GetViewModel()
			end
			--ang.p = math.max(math.min(ang.p,55),-55)
		else
			ang = self.WeaponEnt.Owner:EyeAngles()
			ang:Normalize()
			self.Forward = ang:Forward()
		end
	end

	self.Forward = self.Forward or data:GetNormal()
	self.Angle = self.Forward:Angle()

	local pcf = CreateParticleSystem(self.WeaponEnt, self.ParticleName, PATTACH_POINT_FOLLOW, self.Attachment)
	if IsValid(pcf) then
		pcf:StartEmission()
	end
	timer.Simple(3.0, function()
		if IsValid(pcf) then
			pcf:StopEmissionAndDestroyImmediately()
		end
	end)
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end
--PATH lua/effects/csgo_muzzle_trail_long/init.lua:
local ang

EFFECT.ParticleName = "weapon_muzzle_trail_long"

function EFFECT:Init(data)
	self.WeaponEnt = data:GetEntity()
	if not IsValid(self.WeaponEnt) then return end
	self.Attachment = data:GetAttachment()
	self.Position = self:GetTracerShootPos(data:GetOrigin(), self.WeaponEnt, self.Attachment)

	if IsValid(self.WeaponEnt.Owner) then
		if self.WeaponEnt.Owner == LocalPlayer() then
			if not self.WeaponEnt:IsFirstPerson() then
				ang = self.WeaponEnt.Owner:EyeAngles()
				ang:Normalize()
				--ang.p = math.max(math.min(ang.p,55),-55)
				self.Forward = ang:Forward()
			else
				self.WeaponEnt = self.WeaponEnt.Owner:GetViewModel()
			end
			--ang.p = math.max(math.min(ang.p,55),-55)
		else
			ang = self.WeaponEnt.Owner:EyeAngles()
			ang:Normalize()
			self.Forward = ang:Forward()
		end
	end

	self.Forward = self.Forward or data:GetNormal()
	self.Angle = self.Forward:Angle()
	self.Right = self.Angle:Right()
	self.vOffset = self.Position
	dir = self.Forward

	ParticleEffectAttach( self.ParticleName, PATTACH_POINT_FOLLOW, self.WeaponEnt, self.Attachment)
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end

--PATH lua/effects/effect_astw2_swrc_impact/init.lua:
EFFECT.Duration			= 0.25;
EFFECT.Size				= 32;

local MaterialGlow		= Material( "effects/swbf/sparks" );

function EFFECT:Init( data )

	self.Position = data:GetOrigin();
	self.Normal = data:GetNormal();
	self.LifeTime = self.Duration;

	-- particles
	local emitter = ParticleEmitter( self.Position );
	if( emitter ) then
		
		for i = 1, 1 do

			local particle = emitter:Add( "effects/swbf/sparks", self.Position + self.Normal * 2 );
			particle:SetVelocity( ( self.Normal + VectorRand() * 0.75 ):GetNormal() * math.Rand( 75, 125 ) );
			particle:SetDieTime( math.Rand( 0.05, 0.5 ) );
			particle:SetStartAlpha( 255 );
			particle:SetEndAlpha( 0 );
			particle:SetStartSize( math.Rand( 25, 30 ) );
			particle:SetEndSize( 20 );
			particle:SetRoll( 0 );
			particle:SetGravity( Vector( 0, 0, 0 ) );
			particle:SetCollide( true );
			particle:SetBounce( 0 );
			particle:SetAirResistance( 500 );

		end
		emitter:Finish();
	end
	local emitter_s = ParticleEmitter( self.Position );
	if( emitter_s ) then
		for i = 1, 8 do
			local smokeTexture	= "effects/swbf/thicksmoke"
			
			local particle_s = emitter_s:Add(smokeTexture, self.Position+self.Normal*2);
			particle_s:SetVelocity((self.Normal+VectorRand()*0.10):GetNormal()*math.Rand(250, 2500));
			particle_s:SetDieTime(math.Rand(2, 5));
			particle_s:SetStartAlpha(50);
			particle_s:SetEndAlpha(0);
			particle_s:SetStartSize(math.Rand(10, 20));
			particle_s:SetEndSize(math.Rand(20, 40));
			particle_s:SetGravity(Vector(math.Rand(0, 500), math.Rand(250, 1000), math.Rand(-250, 250)));
			particle_s:SetRoll(math.Rand(0, 360));
			particle_s:SetRollDelta(math.Rand(-0.5, 0.5));
			local colour = math.Rand(50, 150);
			particle_s:SetColor(colour, colour, colour, 100);
			particle_s:SetCollide(false);
			particle_s:SetAirResistance(2000);
		end
		emitter_s:Finish();
	end
end


function EFFECT:Think()

	self.LifeTime = self.LifeTime - FrameTime();
	return self.LifeTime > 0;

end


function EFFECT:Render()

	local frac = math.max( 0, self.LifeTime / self.Duration );
	local rgb = 255 * frac;
	local color = Color( rgb, rgb, rgb, 255 );

	render.SetMaterial( MaterialGlow );
	render.DrawQuadEasy( self.Position + self.Normal, self.Normal, self.Size, self.Size, color );

end

--PATH lua/effects/effect_astw2_swrc_impact_trandoshan/init.lua:
EFFECT.Duration			= 0.25;
EFFECT.Size				= 32;

local MaterialGlow		= Material( "effects/swbf/sparks" );

function EFFECT:Init( data )

	self.Position = data:GetOrigin();
	self.Normal = data:GetNormal();
	self.LifeTime = self.Duration;

	-- particles
	local emitter = ParticleEmitter( self.Position );
	if( emitter ) then
		
		for i = 1, 1 do

			local particle = emitter:Add( "effects/swrc/smg_impacts", self.Position + self.Normal * 2 );
			particle:SetVelocity( ( self.Normal + VectorRand() * 0.75 ):GetNormal() * math.Rand( 75, 125 ) );
			particle:SetDieTime( math.Rand( 0.05, 0.2 ) );
			particle:SetStartAlpha( 255 );
			particle:SetEndAlpha( 0 );
			particle:SetStartSize( math.Rand( 3, 5 ) );
			particle:SetEndSize( 10 );
			particle:SetRoll( 0 );
			particle:SetGravity( Vector( 0, 0, 0 ) );
			particle:SetCollide( true );
			particle:SetBounce( 0 );
			particle:SetAirResistance( 500 );

		end
		emitter:Finish();
	end
	local emitter_s = ParticleEmitter( self.Position );
	if( emitter_s ) then
		for i = 1, 8 do
			local smokeTexture	= "effects/swbf/thicksmoke"
			
			local particle_s = emitter_s:Add(smokeTexture, self.Position+self.Normal*2);
			particle_s:SetVelocity((self.Normal+VectorRand()*0.10):GetNormal()*math.Rand(250, 2500));
			particle_s:SetDieTime(math.Rand(2, 5));
			particle_s:SetStartAlpha(50);
			particle_s:SetEndAlpha(0);
			particle_s:SetStartSize(math.Rand(10, 20));
			particle_s:SetEndSize(math.Rand(20, 40));
			particle_s:SetGravity(Vector(math.Rand(0, 500), math.Rand(250, 1000), math.Rand(-250, 250)));
			particle_s:SetRoll(math.Rand(0, 360));
			particle_s:SetRollDelta(math.Rand(-0.5, 0.5));
			local colour = math.Rand(50, 150);
			particle_s:SetColor(colour, colour, colour, 100);
			particle_s:SetCollide(false);
			particle_s:SetAirResistance(2000);
		end
		emitter_s:Finish();
	end
end


function EFFECT:Think()

	self.LifeTime = self.LifeTime - FrameTime();
	return self.LifeTime > 0;

end


function EFFECT:Render()

	local frac = math.max( 0, self.LifeTime / self.Duration );
	local rgb = 255 * frac;
	local color = Color( rgb, rgb, rgb, 255 );

	render.SetMaterial( MaterialGlow );
	render.DrawQuadEasy( self.Position + self.Normal, self.Normal, self.Size, self.Size, color );

end

--PATH lua/effects/effect_astw2_swrc_laser_blue/init.lua:
return gluapack()()
--PATH lua/effects/effect_astw2_swrc_laser_blue/init.lua:

TRACER_FLAG_USEATTACHMENT	= 0x0002;
SOUND_FROM_WORLD			= 0;
CHAN_STATIC					= 6;

EFFECT.Speed				= 4000;
EFFECT.Length				= 64;
//EFFECT.WhizSound			= Sound( "nomad/whiz.wav" );		-- by Robinhood76 (http:--www.freesound.org/people/Robinhood76/sounds/96556/)
EFFECT.WhizDistance			= 72;

local MaterialMain			= Material( "effects/swrc/blaster_bolt" );
local MaterialFront			= Material( "effects/swrc/a_FLASHBLUE" );

function EFFECT:GetTracerOrigin( data )

	-- this is almost a direct port of GetTracerOrigin in fx_tracer.cpp
	local start = data:GetStart();
	
	-- use attachment?
	if( bit.band( data:GetFlags(), TRACER_FLAG_USEATTACHMENT ) == TRACER_FLAG_USEATTACHMENT ) then

		local entity = data:GetEntity();
		
		if( not IsValid( entity ) ) then return start; end
		if( not game.SinglePlayer() and entity:IsEFlagSet( EFL_DORMANT ) ) then return start; end
		
		if( entity:IsWeapon() and entity:IsCarriedByLocalPlayer() ) then
			-- can't be done, can't call the real function
			-- local origin = weapon:GetTracerOrigin();
			-- if( origin ) then
			-- 	return origin, angle, entity;
			-- end
			
			-- use the view model
			local pl = entity:GetOwner();
			if( IsValid( pl ) ) then
				local vm = pl:GetViewModel();
				if( IsValid( vm ) and not LocalPlayer():ShouldDrawLocalPlayer() ) then
					entity = vm;
				else
					-- HACK: fix the model in multiplayer
					if( entity.WorldModel ) then
						entity:SetModel( entity.WorldModel );
					end
				end
			end
		end

		local attachment = entity:GetAttachment( data:GetAttachment() );
		if( attachment ) then
			start = attachment.Pos;
		end

	end
	
	return start;

end


function EFFECT:Init( data )

	self.StartPos = self:GetTracerOrigin( data );
	self.EndPos = data:GetOrigin();
	
	self.Entity:SetRenderBoundsWS( self.StartPos, self.EndPos );

	local diff = ( self.EndPos - self.StartPos );
	
	self.Normal = diff:GetNormal();
	self.StartTime = 0;
	self.LifeTime = ( diff:Length() + self.Length ) / self.Speed;
	
	-- whiz by sound
	local weapon = data:GetEntity();
	if( IsValid( weapon ) and ( not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer() ) ) then

		local dist, pos, time = util.DistanceToLine( self.StartPos, self.EndPos, EyePos() );
	end
end


function EFFECT:Think()

	self.LifeTime = self.LifeTime - FrameTime();
	self.StartTime = self.StartTime + FrameTime(); 

	return self.LifeTime > 0;

end


function EFFECT:Render()

	local endDistance = self.Speed * self.StartTime;
	local startDistance = endDistance - self.Length;
	
	startDistance = math.max( 0, startDistance );
	endDistance = math.max( 0, endDistance );

	local startPos = self.StartPos + self.Normal * startDistance;
	local endPos = self.StartPos + self.Normal * endDistance;
	
	render.SetMaterial( MaterialFront );
	render.DrawSprite( endPos, 0, 0, color_white );

	render.SetMaterial( MaterialMain );
	render.DrawBeam( startPos, endPos, 10, 0, 1, color_white );
	
end

--PATH lua/effects/effect_magicheal/init.lua:
return gluapack()()
--PATH lua/effects/effect_smokenade_smoke/init.lua:
return gluapack()()
--PATH lua/effects/effect_sw_impact/init.lua:
return gluapack()()
--PATH lua/effects/effect_sw_laser_blue/init.lua:
TRACER_FLAG_USEATTACHMENT 	= 0x0002
SOUND_FROM_WORLD 			= 0
CHAN_STATIC 				= 6
EFFECT.Speed 				= 6500
EFFECT.Length 				= 64
--EFFECT.WhizSound			= Sound( "nomad/whiz.wav" )		-- by Robinhood76 (http:--www.freesound.org/people/Robinhood76/sounds/96556/)
EFFECT.WhizDistance 		= 72
local MaterialMain 			= Material("effects/sw_laser_blue_main")
local MaterialFront 		= Material("effects/sw_laser_blue_front")
local DynamicTracer 		= GetConVar("cl_dynamic_tracer")

function EFFECT:GetTracerOrigin(data)
	-- this is almost a direct port of GetTracerOrigin in fx_tracer.cpp
	local start = data:GetStart()

	-- use attachment?
	if (bit.band(data:GetFlags(), TRACER_FLAG_USEATTACHMENT) == TRACER_FLAG_USEATTACHMENT) then
		local entity = data:GetEntity()
		if (not IsValid(entity)) then return start end
		if (not game.SinglePlayer() and entity:IsEFlagSet(EFL_DORMANT)) then return start end

		if (entity:IsWeapon() and entity:IsCarriedByLocalPlayer()) then
			-- can't be done, can't call the real function
			-- local origin = weapon:GetTracerOrigin()
			-- if( origin ) then
			-- 	return origin, angle, entity
			-- end
			-- use the view model
			local pl = entity:GetOwner()

			if (IsValid(pl)) then
				local vm = pl:GetViewModel()

				if (IsValid(vm) and not LocalPlayer():ShouldDrawLocalPlayer()) then
					entity = vm
					-- HACK: fix the model in multiplayer
				else
					if (entity.WorldModel) then
						entity:SetModel(entity.WorldModel)
					end
				end
			end
		end

		local attachment = entity:GetAttachment(data:GetAttachment())

		if (attachment) then
			start = attachment.Pos
		end
	end

	return start
end

function EFFECT:Init(data)
	self.StartPos = self:GetTracerOrigin(data)
	self.EndPos = data:GetOrigin()
	self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)
	local diff = self.EndPos - self.StartPos
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	self.LifeTime = (diff:Length() + self.Length) / self.Speed
	-- whiz by sound
	local weapon = data:GetEntity()

	if (IsValid(weapon) and (not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer())) then
		local dist, pos, time = util.DistanceToLine(self.StartPos, self.EndPos, EyePos())
	end
end

--concommand.Add("sv_dlight")
function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()

	if DynamicTracer:GetBool() then
		local spawn = util.CRC(tostring(self:GetPos()))
		local dlight = DynamicLight(self:EntIndex() + spawn)
		local endDistance = self.Speed * self.StartTime
		local endPos = self.StartPos + self.Normal * endDistance

		if (dlight) then
			dlight.pos = endPos
			dlight.r = 0
			dlight.g = 0
			dlight.b = 153
			dlight.brightness = 3
			dlight.Decay = 1000
			dlight.Size = 300
			dlight.DieTime = CurTime() + 3
		end
	end

	return self.LifeTime > 0
end

function EFFECT:Render()
	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	startDistance = math.max(0, startDistance)
	endDistance = math.max(0, endDistance)
	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	render.SetMaterial(MaterialFront)
	render.DrawSprite(endPos, 8, 8, color_white)
	render.SetMaterial(MaterialMain)
	render.DrawBeam(startPos, endPos, 10, 0, 1, color_white)
end
--PATH lua/effects/effect_sw_laser_blue_akimbo_pu/init.lua:
TRACER_FLAG_USEATTACHMENT = 0x0002
SOUND_FROM_WORLD = 0
CHAN_STATIC = 6
EFFECT.Life = 1
EFFECT.Speed = 6500
EFFECT.Length = 64
--EFFECT.WhizSound			= Sound( "nomad/whiz.wav" );		-- by Robinhood76 (http:--www.freesound.org/people/Robinhood76/sounds/96556/)
EFFECT.WhizDistance = 72
local MaterialMain = Material("effects/sw_laser_blue_main")
local MaterialFront = Material("effects/sw_laser_blue_front")

function EFFECT:Init(data)
	self.Position = data:GetStart()
	self.WeaponEnt = data:GetEntity()
	self.WeaponEntOG = data:GetEntity()
	self.Attachment = data:GetAttachment()
	local owent

	if IsValid(self.WeaponEnt) then
		owent = self.WeaponEnt.Owner or self.WeaponEnt:GetOwner()

		if not IsValid(owent) then
			owent = self.WeaponEnt:GetParent()
		end
	end

	if IsValid(owent) and owent:IsPlayer() then
		if owent ~= LocalPlayer() or owent:ShouldDrawLocalPlayer() then
			self.WeaponEnt = owent:GetActiveWeapon()
			if not IsValid(self.WeaponEnt) then return end
		else
			self.WeaponEnt = owent:GetViewModel()
			local theirweapon = owent:GetActiveWeapon()

			if IsValid(theirweapon) and theirweapon.ViewModelFlip or theirweapon.ViewModelFlipped then
				self.Flipped = true
			end

			if not IsValid(self.WeaponEnt) then return end
		end
	end

	if IsValid(self.WeaponEntOG) and self.WeaponEntOG.MuzzleAttachment then
		self.Attachment = self.WeaponEnt:LookupAttachment(self.WeaponEntOG.MuzzleAttachment)

		if not self.Attachment or self.Attachment <= 0 then
			self.Attachment = 1
		end

		if self.WeaponEntOG.Akimbo then
			if game.SinglePlayer() then
				self.WeaponEntOG.AnimCycle = self.WeaponEntOG:GetNW2Int("AnimCycle") or 0
			end
			self.Attachment = 1 + self.WeaponEntOG.AnimCycle
		end
	end

	local angpos

	if IsValid(self.WeaponEnt) then
		angpos = self.WeaponEnt:GetAttachment(self.Attachment)
	end

	if not angpos or not angpos.Pos then
		angpos = {
			Pos = bvec,
			Ang = uAng
		}
	end

	if self.Flipped then
		local tmpang = (self.Dir or angpos.Ang:Forward()):Angle()
		local localang = self.WeaponEnt:WorldToLocalAngles(tmpang)
		localang.y = localang.y + 180
		localang = self.WeaponEnt:LocalToWorldAngles(localang)
		--localang:RotateAroundAxis(localang:Up(),180)
		--tmpang:RotateAroundAxis(tmpang:Up(),180)
		self.Dir = localang:Forward()
	end

	-- Keep the start and end Pos - we're going to interpolate between them
	if IsValid(owent) and self.Position:Distance(owent:GetShootPos()) > 72 then
		self.WeaponEnt = nil
	end

	self.StartPos = self:GetTracerShootPos(self.WeaponEnt and angpos.Pos or self.Position, self.WeaponEnt, self.Attachment)
	self.EndPos = data:GetOrigin()
	self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)
	self.Normal = (self.EndPos - self.StartPos):GetNormalized()
	self.StartTime = 0
	self.LifeTime = self.Life
	self.data = data
	self.rot = nil
	weapon = data:GetEntity()

	if (IsValid(weapon) and (not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer())) then
		local dist, pos, time = util.DistanceToLine(self.StartPos, self.EndPos, EyePos())
	end
end

function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()

	return self.LifeTime > 0
end

function EFFECT:Render()
	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	startDistance = math.max(0, startDistance)
	endDistance = math.max(0, endDistance)
	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	render.SetMaterial(MaterialFront)
	render.DrawSprite(endPos, 8, 8, color_white)
	render.SetMaterial(MaterialMain)
	render.DrawBeam(startPos, endPos, 10, 0, 1, color_white)
end
--PATH addons/[bronie] republic-essentials-v2d/lua/effects/effect_sw_laser_blue_stun/init.lua:

TRACER_FLAG_USEATTACHMENT	= 0x0002;
SOUND_FROM_WORLD			= 0;
CHAN_STATIC					= 6;

EFFECT.Speed				= 6500;
EFFECT.Length				= 64;
--EFFECT.WhizSound			= Sound( "nomad/whiz.wav" );		-- by Robinhood76 (http:--www.freesound.org/people/Robinhood76/sounds/96556/)
EFFECT.WhizDistance			= 72;

local MaterialMain			= Material( "star/effects/blue_shockwave" );
local MaterialFront			= Material( "star/effects/blue_shockwave" );

function EFFECT:GetTracerOrigin(data)
	-- this is almost a direct port of GetTracerOrigin in fx_tracer.cpp
	local start = data:GetStart()

	-- use attachment?
	if (bit.band(data:GetFlags(), TRACER_FLAG_USEATTACHMENT) == TRACER_FLAG_USEATTACHMENT) then
		local entity = data:GetEntity()
		if (not IsValid(entity)) then return start end
		if (not game.SinglePlayer() and entity:IsEFlagSet(EFL_DORMANT)) then return start end

		if (entity:IsWeapon() and entity:IsCarriedByLocalPlayer()) then
			-- can't be done, can't call the real function
			-- local origin = weapon:GetTracerOrigin();
			-- if( origin ) then
			-- 	return origin, angle, entity;
			-- end
			-- use the view model
			local pl = entity:GetOwner()

			if (IsValid(pl)) then
				local vm = pl:GetViewModel()

				if (IsValid(vm) and not LocalPlayer():ShouldDrawLocalPlayer()) then
					entity = vm
					-- HACK: fix the model in multiplayer
				else
					if (entity.WorldModel) then
						entity:SetModel(entity.WorldModel)
					end
				end
			end
		end

		local attachment = entity:GetAttachment(data:GetAttachment())

		if (attachment) then
			start = attachment.Pos
		end
	end

	return start
end

function EFFECT:Init(data)
	self.StartPos = self:GetTracerOrigin(data)
	self.EndPos = data:GetOrigin()
	self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)
	local diff = (self.EndPos - self.StartPos)
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	self.LifeTime = (diff:Length() + self.Length) / self.Speed
	-- whiz by sound
	local weapon = data:GetEntity()

	if (IsValid(weapon) and (not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer())) then
		local dist, pos, time = util.DistanceToLine(self.StartPos, self.EndPos, EyePos())
	end
end

function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()

	return self.LifeTime > 0
end

function EFFECT:Render()
	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	startDistance = math.max(0, startDistance)
	endDistance = math.max(0, endDistance)
	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	render.SetMaterial(MaterialFront)
	render.DrawSprite(endPos, 35, 35, color_white)
	render.SetMaterial(MaterialMain)
	render.DrawBeam(startPos, endPos, 10, 0, 1, color_white)
end

--PATH lua/effects/effect_sw_laser_red_akimbo_pu/init.lua:
return gluapack()()
--PATH lua/effects/effect_sw_laser_white_akimbo_pu/init.lua:
TRACER_FLAG_USEATTACHMENT = 0x0002
SOUND_FROM_WORLD = 0
CHAN_STATIC = 6
EFFECT.Life = 1
EFFECT.Speed = 6500
EFFECT.Length = 64
--EFFECT.WhizSound			= Sound( "nomad/whiz.wav" );		-- by Robinhood76 (http:--www.freesound.org/people/Robinhood76/sounds/96556/)
EFFECT.WhizDistance = 72
local MaterialMain = Material("effects/sw_laser_white_main")
local MaterialFront = Material("effects/sw_laser_white_front")

function EFFECT:Init(data)
	self.Position = data:GetStart()
	self.WeaponEnt = data:GetEntity()
	self.WeaponEntOG = data:GetEntity()
	self.Attachment = data:GetAttachment()
	local owent

	if IsValid(self.WeaponEnt) then
		owent = self.WeaponEnt.Owner or self.WeaponEnt:GetOwner()

		if not IsValid(owent) then
			owent = self.WeaponEnt:GetParent()
		end
	end

	if IsValid(owent) and owent:IsPlayer() then
		if owent ~= LocalPlayer() or owent:ShouldDrawLocalPlayer() then
			self.WeaponEnt = owent:GetActiveWeapon()
			if not IsValid(self.WeaponEnt) then return end
		else
			self.WeaponEnt = owent:GetViewModel()
			local theirweapon = owent:GetActiveWeapon()

			if IsValid(theirweapon) and theirweapon.ViewModelFlip or theirweapon.ViewModelFlipped then
				self.Flipped = true
			end

			if not IsValid(self.WeaponEnt) then return end
		end
	end

	if IsValid(self.WeaponEntOG) and self.WeaponEntOG.MuzzleAttachment then
		self.Attachment = self.WeaponEnt:LookupAttachment(self.WeaponEntOG.MuzzleAttachment)

		if not self.Attachment or self.Attachment <= 0 then
			self.Attachment = 1
		end

		if self.WeaponEntOG.Akimbo then
			if game.SinglePlayer() then
				self.WeaponEntOG.AnimCycle = self.WeaponEntOG:GetNW2Int("AnimCycle") or 0
			end
			self.Attachment = 1 + self.WeaponEntOG.AnimCycle
		end
	end

	local angpos

	if IsValid(self.WeaponEnt) then
		angpos = self.WeaponEnt:GetAttachment(self.Attachment)
	end

	if not angpos or not angpos.Pos then
		angpos = {
			Pos = bvec,
			Ang = uAng
		}
	end

	if self.Flipped then
		local tmpang = (self.Dir or angpos.Ang:Forward()):Angle()
		local localang = self.WeaponEnt:WorldToLocalAngles(tmpang)
		localang.y = localang.y + 180
		localang = self.WeaponEnt:LocalToWorldAngles(localang)
		--localang:RotateAroundAxis(localang:Up(),180)
		--tmpang:RotateAroundAxis(tmpang:Up(),180)
		self.Dir = localang:Forward()
	end

	-- Keep the start and end Pos - we're going to interpolate between them
	if IsValid(owent) and self.Position:Distance(owent:GetShootPos()) > 72 then
		self.WeaponEnt = nil
	end

	self.StartPos = self:GetTracerShootPos(self.WeaponEnt and angpos.Pos or self.Position, self.WeaponEnt, self.Attachment)
	self.EndPos = data:GetOrigin()
	self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)
	self.Normal = (self.EndPos - self.StartPos):GetNormalized()
	self.StartTime = 0
	self.LifeTime = self.Life
	self.data = data
	self.rot = nil
	weapon = data:GetEntity()

	if (IsValid(weapon) and (not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer())) then
		local dist, pos, time = util.DistanceToLine(self.StartPos, self.EndPos, EyePos())
	end
end

function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()

	return self.LifeTime > 0
end

function EFFECT:Render()
	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	startDistance = math.max(0, startDistance)
	endDistance = math.max(0, endDistance)
	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	render.SetMaterial(MaterialFront)
	render.DrawSprite(endPos, 8, 8, color_white)
	render.SetMaterial(MaterialMain)
	render.DrawBeam(startPos, endPos, 10, 0, 1, color_white)
end
--PATH lua/effects/effect_sw_laser_white_old/init.lua:
return gluapack()()
--PATH lua/effects/effect_sw_laser_yellow/init.lua:

TRACER_FLAG_USEATTACHMENT	= 0x0002
SOUND_FROM_WORLD			= 0
CHAN_STATIC					= 6

EFFECT.Speed				= 6500
EFFECT.Length				= 64
--EFFECT.WhizSound			= Sound( "nomad/whiz.wav" );		-- by Robinhood76 (http:--www.freesound.org/people/Robinhood76/sounds/96556/)
EFFECT.WhizDistance			= 72

local MaterialMain			= Material( "effects/sw_laser_yellow_main" )
local MaterialFront			= Material( "effects/sw_laser_yellow_front" )
local DynamicTracer 		= GetConVar("cl_dynamic_tracer")

function EFFECT:GetTracerOrigin(data)
	-- this is almost a direct port of GetTracerOrigin in fx_tracer.cpp
	local start = data:GetStart()

	-- use attachment?
	if (bit.band(data:GetFlags(), TRACER_FLAG_USEATTACHMENT) == TRACER_FLAG_USEATTACHMENT) then
		local entity = data:GetEntity()
		if (not IsValid(entity)) then return start end
		if (not game.SinglePlayer() and entity:IsEFlagSet(EFL_DORMANT)) then return start end

		if (entity:IsWeapon() and entity:IsCarriedByLocalPlayer()) then
			-- can't be done, can't call the real function
			-- local origin = weapon:GetTracerOrigin();
			-- if( origin ) then
			-- 	return origin, angle, entity;
			-- end
			-- use the view model
			local pl = entity:GetOwner()

			if (IsValid(pl)) then
				local vm = pl:GetViewModel()

				if (IsValid(vm) and not LocalPlayer():ShouldDrawLocalPlayer()) then
					entity = vm
					-- HACK: fix the model in multiplayer
				else
					if (entity.WorldModel) then
						entity:SetModel(entity.WorldModel)
					end
				end
			end
		end

		local attachment = entity:GetAttachment(data:GetAttachment())

		if (attachment) then
			start = attachment.Pos
		end
	end

	return start
end

function EFFECT:Init(data)
	self.StartPos = self:GetTracerOrigin(data)
	self.EndPos = data:GetOrigin()
	self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)
	local diff = self.EndPos - self.StartPos
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	self.LifeTime = (diff:Length() + self.Length) / self.Speed
	-- whiz by sound
	local weapon = data:GetEntity()

	if (IsValid(weapon) and (not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer())) then
		local dist, pos, time = util.DistanceToLine(self.StartPos, self.EndPos, EyePos())
	end
end

function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()

	if DynamicTracer:GetBool() then
		local spawn = util.CRC(tostring(self:GetPos()))
		local dlight = DynamicLight(self:EntIndex() + spawn)
		local endDistance = self.Speed * self.StartTime
		local endPos = self.StartPos + self.Normal * endDistance

		if (dlight) then
			dlight.pos = endPos
			dlight.r = 255
			dlight.g = 255
			dlight.b = 0
			dlight.brightness = 3
			dlight.Decay = 1000
			dlight.Size = 300
			dlight.DieTime = CurTime() + 3
		end
	end

	return self.LifeTime > 0
end

function EFFECT:Render()
	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	startDistance = math.max(0, startDistance)
	endDistance = math.max(0, endDistance)
	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	render.SetMaterial(MaterialFront)
	render.DrawSprite(endPos, 8, 8, color_white)
	render.SetMaterial(MaterialMain)
	render.DrawBeam(startPos, endPos, 10, 0, 1, color_white)
end
--PATH addons/[miecze] moce i hilty/lua/effects/force_block.lua:
--DO NOT EDIT OR REUPLOAD THIS FILE

function EFFECT:Init( data )
	self.Ent = data:GetEntity()
	self.Pos = data:GetOrigin()
	
	self.mat = Material( "effects/select_ring" )
	
	self.LifeTime = 0.6
	self.DieTime = CurTime() + self.LifeTime

	if not IsValid( self.Ent ) then return end

	self.Model = ClientsideModel( self.Ent:GetModel(), RENDERGROUP_TRANSLUCENT )
	self.Model:SetMaterial("models/alyx/emptool_glow")
	self.Model:SetColor( Color(0,70,150,255) )
	self.Model:SetParent( self.Ent, 0 )
	self.Model:SetMoveType( MOVETYPE_NONE )
	self.Model:SetLocalPos( Vector( 0, 0, 0 ) )
	self.Model:SetLocalAngles( Angle( 0, 0, 0 ) )
	self.Model:AddEffects( EF_BONEMERGE )

	for i = 0,self.Ent:GetBoneCount() do
		self.Model:ManipulateBoneScale( i, Vector(1,1,1) * 1.1 )
	end

	for i = 0, self.Ent:GetNumBodyGroups() do
		self.Model:SetBodygroup(i, self.Ent:GetBodygroup(i))
	end
end

function EFFECT:Think()
	if self.DieTime < CurTime() or not IsValid( self.Ent ) or not self.Ent:Alive() then 
		if IsValid( self.Model ) then
			self.Model:Remove()
		end

		return false
	end
	
	return true
end

function EFFECT:Render()
end

--PATH addons/[miecze] moce i hilty/lua/effects/force_cleave.lua:
function EFFECT:Init( data )
	self.Pos = data:GetOrigin()
	self.Col = data:GetStart() or Vector(255,100,0)
	
	self.LifeTime = 0.5
	self.DieTime = CurTime() + self.LifeTime

	local Col = self.Col
	local Pos = self.Pos
	local Dir = data:GetNormal()
	
	local emitter = ParticleEmitter( Pos, false )
	
	for i = 0, 10 do
		local particle = emitter:Add( "decals/splash1", Pos )
		
		local vel = VectorRand() * 100 + Dir * 100
		
		if particle then
			particle:SetVelocity( vel )
			particle:SetAngles( vel:Angle() + Angle(0,90,0) )
			particle:SetDieTime( 0.5 )
			particle:SetStartAlpha( 100 )
			particle:SetEndAlpha( 0 )
			particle:SetStartSize( 30 )
			particle:SetEndSize( 2 )
			particle:SetRoll( math.Rand(-100,100) )
			particle:SetRollDelta( math.Rand(-100,100) )
			particle:SetCollide( true )
			particle:SetBounce( 0.5 )
			particle:SetAirResistance( 0 )
			particle:SetColor( 110, 0, 0 )
			particle:SetGravity( Vector(0,0,0) )
		end
	end

	emitter:Finish()
end

function EFFECT:Think()
	if self.DieTime < CurTime() then 
		return false
	end

	return true
end

local mat = Material( "decals/splash1" )
function EFFECT:Render()
	local Scale = (self.DieTime - CurTime()) / self.LifeTime
	render.SetMaterial( mat )
	render.DrawSprite( self.Pos, 200, 5, Color( 0 * Scale, 0 * Scale, 0 * Scale, 255 * Scale) ) 
end
--PATH addons/[miecze] moce i hilty/lua/effects/force_cleave_sparkle.lua:
function EFFECT:Init( data )
	self.Pos = data:GetOrigin()
	self.Col = data:GetStart() or Vector(255,100,0)
	
	self.LifeTime = 0.2
	self.DieTime = CurTime() + self.LifeTime

	local Col = self.Col
	local Pos = self.Pos
	local Dir = data:GetNormal()

	local emitter = ParticleEmitter( Pos, false )

	local particle = emitter:Add( "effects/muzzleflashx", Pos )
		
	if particle then
		particle:SetDieTime( 1 )
		particle:SetStartAlpha( math.Rand( 200, 255 ) )
		particle:SetEndAlpha( 0 )
		particle:SetStartSize( 5 )
		particle:SetEndSize( 0.5 )
		particle:SetRoll( math.Rand(-100,100) )
		particle:SetCollide( true )
		particle:SetBounce( 0.5 )
		particle:SetAirResistance( 0 )
		particle:SetColor( math.Rand( 100, 255 ), math.Rand( 100, 255 ), math.Rand( 100, 255 ) )
		particle:SetGravity( Vector(0,0,0) )
	end

	emitter:Finish()
end

function EFFECT:Think()
	if self.DieTime < CurTime() then 
		return false
	end

	return true
end

local mat = Material( "effects/muzzleflashx" )
function EFFECT:Render()
	local Scale = (self.DieTime - CurTime()) / self.LifeTime
	render.SetMaterial( mat )
	render.DrawSprite( self.Pos, 12, 12, Color( 150 * Scale, 200 * Scale, 255 * Scale, 255) ) 
end
--PATH addons/[miecze] moce i hilty/lua/effects/force_heal.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/effects/force_judgementiii_hit.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/effects/force_lightningiii.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/effects/force_purify.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/effects/force_purify.lua:
function EFFECT:Init(data)
    self.Ent = data:GetEntity()

    self.LifeTime = 0.2
    self.DieTime = CurTime() + self.LifeTime

    if IsValid(self.Ent) then
        local Dir = self.Ent:GetAimVector()
        local StartPos = self.Ent:GetShootPos() - Dir * 25
        local EndPos = StartPos + Dir * 625
        self:SetRenderBoundsWS(StartPos, EndPos)
    end
end

function EFFECT:Think()
    return self.DieTime >= CurTime() and IsValid(self.Ent)
end

local BeamMat = Material("trails/electric")  -- Original material
local SpriteMat = Material("sprites/light_glow02_add")  -- Original material

function EFFECT:Render()
    if not IsValid(self.Ent) then return end

    local boneID = self.Ent:LookupBone("ValveBiped.Bip01_L_Hand")
    if not boneID then return end

    local T = CurTime() * 10
    local X, Y = math.cos(T) * math.cos(T * 10) * 4, math.sin(T) * math.cos(T * 10) * 4
    local pos, ang = self.Ent:GetBonePosition(boneID)
    local StartPos = pos + ang:Up() * 2 + ang:Forward() * 5 + ang:Right() * 2

    if not self.TargetPos then
        self.TargetPos = self.Ent:GetEyeTrace().HitPos
        local dlight = DynamicLight(self.Ent:EntIndex() + math.random(0, 99))
        if dlight then
            dlight.pos = StartPos
            dlight.r, dlight.g, dlight.b = 0, 255, 255  -- Light blue for healing
            dlight.brightness = 3
            dlight.Decay = 2000
            dlight.Size = 150
            dlight.DieTime = CurTime() + 0.1
        end
    end

    local Dir = ((self.TargetPos - StartPos):Angle() + Angle(X, Y, 0)):Forward()
    local EndPos = StartPos + Dir * math.random(200, 600)
    local trace = util.TraceLine({start = StartPos, endpos = EndPos, filter = self.Ent})

    if (self.HitFX or 0) < CurTime() then
        self.HitFX = CurTime() + 0.01
        if trace.Hit then
            local effectdata = EffectData()
            effectdata:SetOrigin(trace.HitPos + trace.HitNormal)
            effectdata:SetNormal(-trace.HitNormal)
            util.Effect("force_judgementiii_hit", effectdata)

            if math.random(1, 3) == 3 then
                local dlight = DynamicLight(self.Ent:EntIndex() + math.random(100, 9999))
                if dlight then
                    dlight.pos = trace.HitPos + trace.HitNormal
                    dlight.r, dlight.g, dlight.b = 0, 255, 255  -- Light blue for healing
                    dlight.brightness = 3
                    dlight.Decay = 2000
                    dlight.Size = 100
                    dlight.DieTime = CurTime() + 0.01
                end

                self:EmitSound("ambient/levels/labs/electric_explosion1.wav")  -- Soothing sound effect
            end
        end
    end

    render.SetMaterial(SpriteMat)
    render.DrawSprite(StartPos, 64, 64, Color(0, 255, 255)) -- Light blue healing sprite
    render.DrawSprite(StartPos, 16, 16, Color(0, 255, 255, 255)) -- Smaller light blue healing sprite

    local BeamStart = StartPos
    local BeamPrevious = BeamStart
    local BeamEnd = trace.HitPos
    local BeamSub = BeamEnd - BeamStart
    local BeamDir = BeamSub:GetNormalized()
    local BeamDistance = BeamSub:Length()
    local SegmentLength = 50

    render.SetMaterial(BeamMat)

    render.DrawBeam(BeamStart, BeamEnd, 18, 0, 1, Color(0, 255, 255)) -- Light blue healing beam

    for SegmentStart = 0, BeamDistance, SegmentLength do
        local SegmentEnd = BeamPrevious + (BeamDir:Angle() + Angle(math.Rand(-8, 8), math.Rand(-8, 8), 0)):Forward() * SegmentLength

        local Width = (SegmentStart / BeamDistance)
        if SegmentStart + SegmentLength >= BeamDistance then
            SegmentEnd = BeamEnd
        end

        render.DrawBeam(BeamPrevious, SegmentEnd, 16 * (1 - Width), Width, Width + 0.15, Color(0, 255, 255)) -- Healing beam segments

        local BranchEnd1 = SegmentEnd + (BeamDir:Angle() + Angle(math.Rand(-20, 20), math.Rand(-20, 20), 0)):Forward() * SegmentLength * 0.5

        render.DrawBeam(SegmentEnd, BranchEnd1, math.Rand(8, 16) * (1 - Width), 0, 0.2, Color(0, 255, 255, 255)) -- Branch segments
        render.DrawBeam(BranchEnd1, BranchEnd1 + (BeamDir:Angle() + Angle(math.Rand(-6, 6), math.Rand(-6, 6), 0)):Forward() * SegmentLength * 1.5, math.Rand(4, 8) * (1 - Width), 0, 1.5, Color(0, 255, 255)) -- Further branches

        BeamPrevious = SegmentEnd
    end
end

--PATH lua/effects/hmp_concussion_explosion.lua:
return gluapack()()
--PATH lua/effects/lfs_blacksmoke.lua:
--DO NOT EDIT OR REUPLOAD THIS FILE

local Materials = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

function EFFECT:Init( data )
	local Pos = data:GetOrigin() + VectorRand() * 50
	
	local emitter = ParticleEmitter( Pos, false )

	if emitter then
		local particle = emitter:Add( Materials[math.Round(math.Rand(1,table.Count( Materials )),0)], Pos )
		
		if particle then
			particle:SetVelocity( VectorRand() * 100 )
			particle:SetDieTime( 1.5 )
			particle:SetAirResistance( 600 ) 
			particle:SetStartAlpha( 50 )
			particle:SetStartSize( 80 )
			particle:SetEndSize( math.Rand(250,300) )
			particle:SetRoll( math.Rand(-1,1) * 100 )
			particle:SetColor( 70,70,70 )
			particle:SetGravity( Vector( 0, 0, 500 ) )
			particle:SetCollide( false )
		end
		
		emitter:Finish()
	end
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end

--PATH lua/effects/lvs_bomb_cisexplosion.lua:

local GlowMat = Material( "sprites/light_glow02_add" )
local Materials = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

function EFFECT:Init( data )
	self.Pos = data:GetOrigin()

	self.LifeTime = 0.4
	self.DieTime = CurTime() + self.LifeTime

	local emitter = ParticleEmitter( self.Pos, false )

	if not IsValid( emitter ) then return end

	for i = 0,30 do
		local particle = emitter:Add(  Materials[ math.random(1, #Materials ) ], self.Pos )
		
		if particle then
			particle:SetVelocity( VectorRand(-1,1) * 800 )
			particle:SetDieTime( math.Rand(4,6) )
			particle:SetAirResistance( math.Rand(200,600) ) 
			particle:SetStartAlpha( 100 )
			particle:SetStartSize( math.Rand(300,600) )
			particle:SetEndSize( math.Rand(100,150) )
			particle:SetRoll( math.Rand(-1,1) )
			particle:SetColor( 50,50,50 )
			particle:SetGravity( Vector( 0, 0, 100 ) )
			particle:SetCollide( false )
		end
	end

	for i = 0, 20 do
		local particle = emitter:Add( "sprites/light_glow02_add", self.Pos )
		
		local vel = VectorRand() * 400
		
		if particle then
			particle:SetVelocity( vel )
			particle:SetAngles( vel:Angle() + Angle(0,90,0) )
			particle:SetDieTime( math.Rand(0.4,0.8) )
			particle:SetStartAlpha( 255 )
			particle:SetEndAlpha( 0 )
			particle:SetStartSize( math.Rand(240,480) )
			particle:SetEndSize( 0 )
			particle:SetRoll( math.Rand(-100,100) )
			particle:SetRollDelta( math.Rand(-100,100) )
			particle:SetColor( 255, 40, 100, 255 )
			particle:SetGravity( Vector(0,0,-600) )

			particle:SetAirResistance( 0 )
			
			particle:SetCollide( true )
			particle:SetBounce( 0.5 )
		end
	end
	
	for i = 0, 40 do
		local particle = emitter:Add( "sprites/flamelet"..math.random(1,5), self.Pos )
		
		if particle then
			particle:SetVelocity( VectorRand(-1,1) * 500 )
			particle:SetDieTime( 0.14 )
			particle:SetStartAlpha( 255 )
			particle:SetStartSize( 50 )
			particle:SetEndSize( math.Rand(200,400) )
			particle:SetEndAlpha( 100 )
			particle:SetRoll( math.Rand( -1, 1 ) )
			particle:SetColor( 255, 40, 100, 255 )
			particle:SetCollide( false )
		end
	end

	emitter:Finish()

	local Pos = self.Pos
	local ply = LocalPlayer():GetViewEntity()
	if IsValid( ply ) then
		local delay = (Pos - ply:GetPos()):Length() / 13503.9
		if delay <= 0.11 then
			sound.Play( "ambient/explosions/explode_9.wav", Pos, 85, 100, 1 - delay * 8 )
		end

		timer.Simple( delay, function()
			sound.Play( "LVS.MISSILE_EXPLOSION", Pos )
		end )
	else
		sound.Play( "LVS.MISSILE_EXPLOSION", Pos )
	end
end

function EFFECT:Think()
	if self.DieTime < CurTime() then return false end

	return true
end

function EFFECT:Render()
	local Scale = (self.DieTime - CurTime()) / self.LifeTime
	render.SetMaterial( GlowMat )
	render.DrawSprite( self.Pos, 400 * Scale, 400 * Scale, Color( 0, 127, 255, 255) )
	render.DrawSprite( self.Pos, 100 * Scale, 100 * Scale, Color( 255, 255, 255, 255) )
end

--PATH lua/effects/lvs_capital_blue_laser.lua:
return gluapack()()
--PATH lua/effects/lvs_concussion_trail.lua:
return gluapack()()
--PATH lua/effects/lvs_laat_left_projector.lua:
return gluapack()()
--PATH lua/effects/lvs_laat_wing_projector.lua:
EFFECT.Mat = Material( "effects/lvs/ballturret_projectorbeam" )
EFFECT.HitMat = Material( "sprites/light_glow02_add" )

function EFFECT:Init( data )
	self.Entity = data:GetEntity()

	self.StartPos = Vector(-172.97,334.04,93.25)
	self.EndPos = self.Entity:GetWingTurretTarget()
end

function EFFECT:Think()
	if not IsValid( self.Entity ) or not self.Entity:GetWingTurretFire() then
		return false
	end

	self.EndPosDesired = self.Entity:GetWingTurretTarget() 
	self:SetRenderBoundsWS( self.Entity:GetPos(), self.EndPosDesired )

	return true

end

function EFFECT:Render()
	if not self.EndPosDesired then return end

	self.EndPos = self.EndPos + (self.EndPosDesired - self.EndPos) * FrameTime() * 10

	for i = -1,1,2 do
		local StartPos = self.Entity:LocalToWorld( self.StartPos * Vector(1,i,1) )

		local Trace = util.TraceLine( { start = StartPos, endpos = self.EndPos} )
		local EndPos = Trace.HitPos

		if self.Entity:WorldToLocal( EndPos ).z < 0 then
			self.StartPos = Vector(-172.97,334.04,93.25)
		else
			self.StartPos = Vector(-174.79,350.05,125.98)
		end

		if Trace.Entity == self.Entity then continue end

		render.SetMaterial( self.Mat )
		render.DrawBeam( StartPos, EndPos, 14 + math.random(0,4), 1, 0, Color(0,255,0,255) )
		render.DrawBeam( StartPos, EndPos, 3 + math.random(0,4), 1, 0, Color(255,255,255,255) )

		render.SetMaterial( self.HitMat )
		local A = 150 + math.random(0,20)
		local B = 70 + math.random(0,20)
		render.DrawSprite( StartPos, A, A, Color(0,255,0,255) )
		render.DrawSprite( StartPos, B, B, Color(255,255,255,255) )

		render.DrawSprite( EndPos, A, A, Color(0,255,0,255) )
		render.DrawSprite( EndPos + VectorRand() * 10, B, B, Color(255,255,255,255) )

		if math.random(0,5) == 1 then
			local emitter = ParticleEmitter( EndPos, false )
			local dir = (self.Entity:GetPos() - EndPos):GetNormalized()

			for i = 0, 10 do
				local particle = emitter:Add( "sprites/rico1", EndPos )

				local vel = VectorRand()  * 100 + dir * 40

				if not particle then continue end

				particle:SetVelocity( vel )
				particle:SetAngles( vel:Angle() + Angle(0,90,0) )
				particle:SetDieTime( math.Rand(0.1,0.3) * 0.5 )
				particle:SetStartAlpha( math.Rand( 200, 255 ) )
				particle:SetEndAlpha( 0 )
				particle:SetStartSize( math.Rand(1,30) )
				particle:SetEndSize( 0 )
				particle:SetRoll( math.Rand(-100,100) )
				particle:SetRollDelta( math.Rand(-100,100) )

				particle:SetAirResistance( 0 )
			end

			emitter:Finish()
		end
	end
end

--PATH lua/effects/lvs_laser_explosion.lua:
return gluapack()()
--PATH lua/effects/lvs_laser_explosion_aat.lua:
return gluapack()()
--PATH lua/effects/lvs_laser_green.lua:

EFFECT.MatBeam = Material( "effects/spark" )
EFFECT.MatSprite = Material( "sprites/light_glow02_add" )

function EFFECT:Init( data )
	local pos  = data:GetOrigin()
	local dir = data:GetNormal()

	self.ID = data:GetMaterialIndex()

	self:SetRenderBoundsWS( pos, pos + dir * 50000 )
end

function EFFECT:Think()
	if not LVS:GetBullet( self.ID ) then return false end

	return true
end

function EFFECT:Render()
	local bullet = LVS:GetBullet( self.ID )

	local endpos = bullet:GetPos()
	local dir = bullet:GetDir()

	local len = 1000 * bullet:GetLength()

	render.SetMaterial( self.MatSprite ) 
	render.DrawBeam( endpos - dir * len * 4, endpos + dir * len * 4, 200, 1, 0, Color( 0, 255, 0, 255 ) )

	render.SetMaterial( self.MatBeam )
	render.DrawBeam( endpos - dir * len, endpos + dir * len, 45, 1, 0, Color( 0, 255, 0, 255 ) )
	render.DrawBeam( endpos - dir * len, endpos + dir * len, 15, 1, 0, Color( 255, 255, 255, 255 ) )
end

--PATH lua/effects/lvs_physics_scrape.lua:

local Materials = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

function EFFECT:Init( data )
	if not LVS.ShowPhysicsEffects then
		self.LifeTime = 0
		self.DieTime = 0

		return
	end

	self.Pos = data:GetOrigin()

	self.mat = Material( "sprites/light_glow02_add" )

	self.LifeTime = 0.2
	self.DieTime = CurTime() + self.LifeTime

	local Col = self.Col
	local Pos = self.Pos
	local Dir = data:GetNormal()
	local Strength = data:GetMagnitude()

	local emitter = ParticleEmitter( Pos, false )

	for i = 0,1 do
		local particle = emitter:Add( Materials[ math.random(1, #Materials ) ], Pos )
		
		local vel = VectorRand() * 100 + Dir * 40
		
		if particle then			
			particle:SetVelocity( vel )
			particle:SetDieTime( 1 )
			particle:SetAirResistance( 1000 ) 
			particle:SetStartAlpha( 10 )
			particle:SetStartSize( 2 )
			particle:SetEndSize( 12 )
			particle:SetRoll( math.Rand(-1,1) )
			particle:SetColor( 40, 30, 20 )
			particle:SetGravity( Dir * 50 )
			particle:SetCollide( false )
		end
	end

	for i = 0, 3 do
		local particle = emitter:Add( "effects/spark", Pos )
		
		local vel = VectorRand() * 25 * (1 - Strength) + (VectorRand() * 100 + Dir * 150) * Strength
		
		if particle then
			particle:SetVelocity( vel )
			particle:SetAngles( vel:Angle() + Angle(0,90,0) )
			particle:SetDieTime( 2 )
			particle:SetStartAlpha( math.Rand( 200, 255 ) )
			particle:SetEndAlpha( 0 )

			particle:SetStartLength( 4 )
			particle:SetEndLength(0)

			particle:SetStartSize( 2 )
			particle:SetEndSize( 0 )

			particle:SetRoll( math.Rand(-100,100) )
			particle:SetRollDelta( math.Rand(-100,100) )
			particle:SetCollide( true )
			particle:SetBounce( 0.5 )
			particle:SetAirResistance( 0 )
			particle:SetColor( 255, 200, 50 )
			particle:SetGravity( Vector(0,0,-600) )
		end
	end

	emitter:Finish()
end

function EFFECT:Think()
	if self.DieTime < CurTime() then
		return false
	end

	return true
end

local mat = Material( "sprites/light_glow02_add" )
function EFFECT:Render()
	if not LVS.ShowPhysicsEffects then return end

	local Scale = (self.DieTime - CurTime()) / self.LifeTime
	render.SetMaterial( mat )
	render.DrawSprite( self.Pos, 32, 32, Color( 255 * Scale, 175 * Scale, 80 * Scale, 255) ) 
end


--PATH lua/effects/lvs_tracer_missile.lua:
return gluapack()()
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/effects/masita_dioxis/init.lua:
return gluapack()()
--PATH lua/effects/nio_tracer_legacy.lua:
return gluapack()()
--PATH lua/effects/fxbase.lua:
return gluapack()()
--PATH lua/effects/pulsar_tracer.lua:
AddCSLuaFile()
AddCSLuaFile( "effects/fxbase.lua" )
include( "effects/fxbase.lua" )

function EFFECT:Think()

	util.ParticleTracerEx( 
		"pulsar_beam_red", 	--particle system
		self.StartPos, 	--startpos
		self.EndPos, 	--endpos
		true, 			--do whiz effect
		-1, 			--entity index
		-1  			--attachment
	)
	
	return false
	
end

--PATH addons/[miecze] moce i hilty/lua/effects/repulse.lua:
return gluapack()()
--PATH lua/effects/rw_rocket_explosion.lua:
return gluapack()()
--PATH lua/effects/rw_sw_dual_laser_grey.lua:
TRACER_FLAG_USEATTACHMENT 	= 0x0002
SOUND_FROM_WORLD			= 0
CHAN_STATIC 				= 6

EFFECT.Speed 				= 16384
EFFECT.Length 				= 95

local MaterialMain 			= Material("cs574/tracers/rw_sw_laser_m_grey")
local MaterialFront 		= Material("cs574/tracers/rw_sw_laser_f_grey")
local DynamicTracer 		= GetConVar("cl_dynamic_tracer")

function EFFECT:Init(data)
	self.Position = data:GetStart()
	self.WeaponEnt = data:GetEntity()
	self.WeaponEntOG = data:GetEntity()
	self.Attachment = data:GetAttachment()
	local owent
	if IsValid(self.WeaponEnt) then
		owent = self.WeaponEnt.Owner or self.WeaponEnt:GetOwner()
		if not IsValid(owent) then
			owent = self.WeaponEnt:GetParent()
		end
	end
	if IsValid(owent) and owent:IsPlayer() then
		if owent ~= LocalPlayer() or owent:ShouldDrawLocalPlayer() then
			self.WeaponEnt = owent:GetActiveWeapon()
			if not IsValid(self.WeaponEnt) then return end
		else
			self.WeaponEnt = owent:GetViewModel()
			local theirweapon = owent:GetActiveWeapon()
			if IsValid(theirweapon) and theirweapon.ViewModelFlip or theirweapon.ViewModelFlipped then
				self.Flipped = true
			end
			if not IsValid(self.WeaponEnt) then return end
		end
	end
	if IsValid(self.WeaponEntOG) and self.WeaponEntOG.MuzzleAttachment then
		self.Attachment = self.WeaponEnt:LookupAttachment(self.WeaponEntOG.MuzzleAttachment)
		if not self.Attachment or self.Attachment <= 0 then
			self.Attachment = 1
		end
		if self.WeaponEntOG.Akimbo then
			if game.SinglePlayer() then
				self.WeaponEntOG.AnimCycle = self.WeaponEntOG:GetNW2Int("AnimCycle") or 0
			end
			self.Attachment = 1 + self.WeaponEntOG.AnimCycle
		end
	end
	local angpos
	if IsValid(self.WeaponEnt) then
		angpos = self.WeaponEnt:GetAttachment(self.Attachment)
	end
	if not angpos or not angpos.Pos then
		angpos = {
			Pos = bvec,
			Ang = uAng
		}
	end
	if self.Flipped then
		local tmpang = (self.Dir or angpos.Ang:Forward()):Angle()
		local localang = self.WeaponEnt:WorldToLocalAngles(tmpang)
		localang.y = localang.y + 180
		localang = self.WeaponEnt:LocalToWorldAngles(localang)
		self.Dir = localang:Forward()
	end
	if IsValid(owent) and self.Position:Distance(owent:GetShootPos()) > 72 then
		self.WeaponEnt = nil
	end
	
	self.StartPos = self:GetTracerShootPos(self.WeaponEnt and angpos.Pos or self.Position, self.WeaponEnt, self.Attachment)
	self.EndPos = data:GetOrigin()
	self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)
	self.Normal = (self.EndPos - self.StartPos):GetNormalized()
	self.StartTime = 0
	local diff = self.EndPos - self.StartPos
	self.LifeTime = (diff:Length() - self.Length/2 ) / self.Speed
	self.data = data
	self.rot = nil
	weapon = data:GetEntity()
	if (IsValid(weapon) and (not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer())) then
		local dist, pos, time = util.DistanceToLine(self.StartPos, self.EndPos, EyePos())
	end
end

function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()
	if DynamicTracer:GetBool() then
		local spawn = util.CRC(tostring(self:GetPos()))
		local dlight = DynamicLight(self:EntIndex() + spawn)
		local endDistance = self.Speed * self.StartTime
		local endPos = self.StartPos + self.Normal * endDistance
		if (dlight) then
			dlight.pos = endPos
			dlight.r = 130
			dlight.g = 150
			dlight.b = 180
			dlight.brightness = 3
			dlight.Decay = 1500
			dlight.Size = 300
			dlight.nomodel = 1
			dlight.style = 6
			dlight.DieTime = CurTime() + 3
		end
	end
	return self.LifeTime > 0
end

function EFFECT:Render()
	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	startDistance = math.max(0, startDistance)
	endDistance = math.max(0, endDistance)
	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	render.SetMaterial(MaterialFront)
	render.DrawSprite(endPos, 9, 9, color_white)
	render.SetMaterial(MaterialMain)
	render.DrawBeam(startPos, endPos, 7, 0, 0, color_white)
end
--PATH lua/effects/rw_sw_dual_laser_white.lua:
return gluapack()()
--PATH lua/effects/rw_sw_impact_aqua.lua:
return gluapack()()
--PATH lua/effects/rw_sw_impact_blue.lua:
return gluapack()()
--PATH lua/effects/rw_sw_impact_grey.lua:
local MaterialGlow		= Material( "cs574/impacts/sw_laser_bit_grey" );
function EFFECT:Init( data )
	local bit_amount = GetConVar("rw_sw_bit_amount"):GetInt()
	local smoke_amount = GetConVar("rw_sw_smoke_amount"):GetInt()
	local duration = GetConVar("rw_sw_impact_duration"):GetInt()
	self.Position = data:GetOrigin();
	self.Normal = data:GetNormal();
	self.LifeTime = duration;
	local emitter = ParticleEmitter( self.Position );
	if( emitter ) then
		for i = 1, bit_amount do
			local particle = emitter:Add( MaterialGlow, self.Position + self.Normal * 2 );
			particle:SetVelocity( ( self.Normal + VectorRand() * 0.75 ):GetNormal() * math.Rand( 75, 125 ) );
			particle:SetDieTime( math.Rand( 0.5, 1.25 ) );
			particle:SetStartAlpha( 255 );
			particle:SetEndAlpha( 0 );
			particle:SetStartSize( math.Rand( 4, 8 ) );
			particle:SetEndSize( 0 );
			particle:SetRoll( 0 );
			particle:SetGravity( Vector( 0, 0, -250 ) );
			particle:SetCollide( true );
			particle:SetBounce( 0.3 );
			particle:SetAirResistance( 5 );
		end
		emitter:Finish();
	end
	local emitter_s = ParticleEmitter( self.Position );
	if( emitter_s ) then
		for i = 1, smoke_amount do
			local smokeTexture	= "effects/smoke"
			local particle_s = emitter_s:Add(smokeTexture, self.Position+self.Normal*2);
			particle_s:SetVelocity((self.Normal+VectorRand()*0.10):GetNormal()*math.Rand(50, 250));
			particle_s:SetDieTime(math.Rand(1, 2));
			particle_s:SetStartAlpha(50);
			particle_s:SetEndAlpha(1);
			particle_s:SetStartSize(math.Rand(12, 16));
			particle_s:SetEndSize(math.Rand(0, 0));
			particle_s:SetGravity(Vector(math.Rand(-500, 500), math.Rand(-500, 500), math.Rand(-500, 500)));
			particle_s:SetRoll(math.Rand(0, 360));
			particle_s:SetRollDelta(math.Rand(-0.5, 0.5));
			local colour = math.Rand(60, 90);
			particle_s:SetColor(colour, colour, colour, 255);
			particle_s:SetCollide(true);
			particle_s:SetAirResistance(1500);
		end
		emitter_s:Finish();
	end
end
function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime();
	return self.LifeTime > 0;
end
function EFFECT:Render()
	local size = GetConVar("rw_sw_impact_size"):GetInt()
	local duration = GetConVar("rw_sw_impact_duration"):GetInt()
	local frac = math.max( 0, self.LifeTime / duration);
	local rgb = 255 * frac;
	local color = Color( rgb, rgb, rgb, 255 );
	render.SetMaterial( MaterialGlow );
	render.DrawQuadEasy( self.Position + self.Normal, self.Normal, size, size, color );
end
--PATH lua/effects/rw_sw_impact_lightblue.lua:
return gluapack()()
--PATH lua/effects/rw_sw_laser_grey.lua:

TRACER_FLAG_USEATTACHMENT 	= 0x0002
SOUND_FROM_WORLD 			= 0
CHAN_STATIC 				= 6

EFFECT.Speed 				= 16384
EFFECT.Length 				= 95

local MaterialMain 			= Material("cs574/tracers/rw_sw_laser_m_grey")
local MaterialFront 		= Material("cs574/tracers/rw_sw_laser_f_grey")
local DynamicTracer 		= GetConVar("cl_dynamic_tracer")

function EFFECT:GetTracerOrigin(data)
	local start = data:GetStart()
	if (bit.band(data:GetFlags(), TRACER_FLAG_USEATTACHMENT) == TRACER_FLAG_USEATTACHMENT) then
		local entity = data:GetEntity()
		if (not IsValid(entity)) then return start end
		if (not game.SinglePlayer() and entity:IsEFlagSet(EFL_DORMANT)) then return start end
		if (entity:IsWeapon() and entity:IsCarriedByLocalPlayer()) then
			local pl = entity:GetOwner()
			if (IsValid(pl)) then
				local vm = pl:GetViewModel()
				if (IsValid(vm) and not LocalPlayer():ShouldDrawLocalPlayer()) then
					entity = vm
				else
					if (entity.WorldModel) then
						entity:SetModel(entity.WorldModel)
					end
				end
			end
		end
		local attachment = entity:GetAttachment(data:GetAttachment())
		if (attachment) then
			start = attachment.Pos
		end
	end
	return start
end

function EFFECT:Init(data)
	self.StartPos = self:GetTracerOrigin(data)
	self.EndPos = data:GetOrigin()
	self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)
	local diff = self.EndPos - self.StartPos
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	self.LifeTime = (diff:Length() - self.Length/2 ) / self.Speed 	--self.LifeTime = (diff:Length() - (self.Length/2) ) / self.Speed
	local weapon = data:GetEntity()
	if (IsValid(weapon) and (not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer())) then
		local dist, pos, time = util.DistanceToLine(self.StartPos, self.EndPos, EyePos())
	end
end

function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()
	if DynamicTracer:GetBool() then
		local spawn = util.CRC(tostring(self:GetPos()))
		local dlight = DynamicLight(self:EntIndex() + spawn)
		local endDistance = self.Speed * self.StartTime
		local endPos = self.StartPos + self.Normal * endDistance
		if (dlight) then
			dlight.pos = endPos
			dlight.r = 130
			dlight.g = 150
			dlight.b = 180
			dlight.brightness = 2
			dlight.Decay = 1500
			dlight.Size = 300
			dlight.nomodel = 1
			dlight.style = 6
			dlight.DieTime = CurTime() + 3
		end
	end
	return self.LifeTime > 0
end

function EFFECT:Render()
	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	startDistance = math.max(0, startDistance)
	endDistance = math.max(0, endDistance)
	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	render.SetMaterial(MaterialFront)
	render.DrawSprite(endPos, 9, 9, color_white)
	render.SetMaterial(MaterialMain)
	render.DrawBeam(startPos, endPos, 7, 0, 0, color_white)
end
--PATH lua/effects/rw_sw_muzzleflash_black.lua:
EFFECT.Life = 0.12
EFFECT.XFlashSize = 0.55
EFFECT.FlashSize = 0.5
EFFECT.SmokeSize = 0
EFFECT.SparkSize = 1.25
EFFECT.HeatSize = 2.5
EFFECT.Color = Color(0,0,0)
EFFECT.ColorSprites = true

local AddVel = Vector()
local ang

function EFFECT:Init(data)
	self.WeaponEnt = data:GetEntity()
	if not IsValid(self.WeaponEnt) then return end
	self.Attachment = data:GetAttachment()
	self.Position = self:GetTracerShootPos(data:GetOrigin(), self.WeaponEnt, self.Attachment)

	if IsValid(self.WeaponEnt:GetOwner()) then
		if self.WeaponEnt:GetOwner() == LocalPlayer() then
			if self.WeaponEnt:GetOwner():ShouldDrawLocalPlayer() then
				ang = self.WeaponEnt:GetOwner():EyeAngles()
				ang:Normalize()
				--ang.p = math.max(math.min(ang.p,55),-55)
				self.Forward = ang:Forward()
			else
				self.WeaponEnt = self.WeaponEnt:GetOwner():GetViewModel()
			end
			--ang.p = math.max(math.min(ang.p,55),-55)
		else
			ang = self.WeaponEnt:GetOwner():EyeAngles()
			ang:Normalize()
			self.Forward = ang:Forward()
		end
	end

	self.Forward = self.Forward or data:GetNormal()
	self.Angle = self.Forward:Angle()
	self.Right = self.Angle:Right()
	self.vOffset = self.Position
	local dir = self.Forward
	local ownerent = self.WeaponEnt:GetOwner()

	if not IsValid(ownerent) then
		ownerent = LocalPlayer()
	end

	AddVel = ownerent:GetVelocity()
	self.vOffset = self.Position
	AddVel = AddVel * 0.05
	local dot = dir:GetNormalized():Dot(GetViewEntity():EyeAngles():Forward())
	local halofac = math.abs(dot)
	local epos = ownerent:GetShootPos()
	local dlight = DynamicLight(ownerent:EntIndex())

	if (dlight) then
		dlight.pos = epos + ownerent:EyeAngles():Forward() * self.vOffset:Distance(epos) --self.vOffset - ownerent:EyeAngles():Right() * 5 + 1.05 * ownerent:GetVelocity() * FrameTime()
		dlight.r = self.Color.r
		dlight.g = self.Color.g
		dlight.b = self.Color.b
		dlight.brightness = 4.5
		dlight.decay = 200 / self.Life
		dlight.size = self.FlashSize * 150
		dlight.dietime = CurTime() + self.Life
	end

	self.Dist = self.vOffset:Distance(epos)
	self.DLight = dlight
	self.DieTime = CurTime() + self.Life
	self.OwnerEnt = ownerent
	local emitter = ParticleEmitter(self.vOffset)
	local sval = 1 - math.random(0, 1) * 2

	if self.WeaponEnt.XTick == nil then
		self.WeaponEnt.XTick = 0
	end

	self.WeaponEnt.XTick = 1 - self.WeaponEnt.XTick

	if self.WeaponEnt.XTick == 1 and self.XFlashSize > 0 then
		local particle = emitter:Add(self.ColorSprites and "effects/muzzleflashx_nemole_w" or "effects/muzzleflashx_nemole", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 4 * self.XFlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life / 2)
			particle:SetStartAlpha(math.Rand(200, 255))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 8 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(3 * (halofac * 0.8 + 0.2) * self.XFlashSize)
			particle:SetEndSize(15 * (halofac * 0.8 + 0.2) * self.XFlashSize)
			local r = math.Rand(-10, 10) * 3.14 / 180
			particle:SetRoll(r)
			particle:SetRollDelta(r / 5)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
			particle:SetPos(vector_origin)
		end
		--particle:SetStartSize( 8 * (halofac*0.8+0.2), 0, 1)
		--particle:SetEndSize( 0 )
	elseif self.XFlashSize > 0 then
		local particle = emitter:Add(self.ColorSprites and "effects/muzzleflashx_nemole_w" or "effects/muzzleflashx_nemole", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 4 * self.FlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life / 2)
			particle:SetStartAlpha(math.Rand(200, 255))
			particle:SetEndAlpha(0)
			particle:SetStartSize(2 * (halofac * 0.8 + 0.2) * 0.3 * self.FlashSize)
			particle:SetEndSize(6 * (halofac * 0.8 + 0.2) * 0.3 * self.FlashSize)
			local r = math.Rand(-10, 10) * 3.14 / 180
			particle:SetRoll(r)
			particle:SetRollDelta(r / 5)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
			particle:SetPos(vector_origin)
		end
	end

	local flashCount = math.Round(self.FlashSize * 8)

	for i = 1, flashCount do
		local particle = emitter:Add(self.ColorSprites and "effects/scotchmuzzleflashw" or "effects/scotchmuzzleflash4", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 300 * (0.2 + (i / flashCount) * 0.8) * self.FlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 0.75)
			particle:SetStartAlpha(math.Rand(128, 255))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			local szsc = 1 + (flashCount - i) * math.pow(1 / flashCount * 0.9,0.8)
			particle:SetStartSize(1.25 * math.Rand(1, 1.5) * szsc * self.FlashSize)
			particle:SetEndSize(6 * math.Rand(0.75, 1) * szsc * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(15, 30)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	for _ = 1, flashCount do
		local particle = emitter:Add("effects/scotchmuzzleflash1", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 6 * self.FlashSize + 1.05 * AddVel)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 1)
			particle:SetStartAlpha(math.Rand(40, 140))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(2 * math.Rand(1, 1.5) * self.FlashSize)
			particle:SetEndSize(20 * math.Rand(0.5, 1) * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(30, 60)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			--TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	local glowCount = math.ceil(self.FlashSize * 3)

	for i = 1, glowCount do
		local particle = emitter:Add("effects/scotchmuzzleflash1", self.vOffset + dir * 0.9 * i)

		if (particle) then
			--particle:SetVelocity(dir * 32 )
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 0.75)
			particle:SetStartAlpha(255 * (1 - halofac))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(math.max(12 - 12 / glowCount * i * 0.5, 1) * 0.2 * self.FlashSize)
			particle:SetEndSize(math.max(12 - 12 / glowCount * i * 0.5, 1) * 0.6 * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(15, 30)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	local smokeCount = math.ceil(self.SmokeSize * 6)

	for _ = 0, smokeCount do
		local particle = emitter:Add("particles/smokey", self.vOffset + dir * math.Rand(3, 14))

		if (particle) then
			particle:SetVelocity(VectorRand() * 10 * self.SmokeSize + dir * math.Rand(35, 50) * self.SmokeSize + 1.05 * AddVel)
			particle:SetDieTime(math.Rand(0.6, 1) * self.Life * 6)
			particle:SetStartAlpha(math.Rand(12, 24))
			particle:SetEndAlpha(0)
			particle:SetStartSize(math.Rand(5, 7) * self.SmokeSize)
			particle:SetEndSize(math.Rand(15, 20) * self.SmokeSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.Rand(-0.8, 0.8))
			particle:SetLighting(true)
			particle:SetAirResistance(20)
			particle:SetGravity(Vector(0, 0, 60))
			particle:SetColor(255, 255, 255)
		end
	end

	local sparkcount = math.Round(math.random(8, 12) * self.SparkSize)

	for _ = 0, sparkcount do
		local particle = emitter:Add("effects/yellowflare", self.Position)

		if (particle) then
			particle:SetVelocity( VectorRand() * 30 * self.SparkSize)
			particle:SetVelocity(particle:GetVelocity() + 1.15 * AddVel )
			particle:SetVelocity( particle:GetVelocity() + dir * math.Rand(80, 100) * (1-math.abs(math.max(particle:GetVelocity():GetNormalized():Dot(-dir),0))) * self.SparkSize )
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * math.Rand(0.9,1.1))
			particle:SetStartAlpha(255)
			particle:SetEndAlpha(0)
			particle:SetStartSize(0.6)
			particle:SetEndSize(1)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetGravity(vector_origin)
			particle:SetAirResistance(1)
			particle:SetStartLength(0.1)
			particle:SetEndLength(0.05)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, math.random(192, 225), math.random(140, 192))
			end

			particle:SetVelocityScale(true)
			local sl = self.SparkSize

			particle:SetThinkFunction(function(pa)
				math.randomseed(SysTime())
				local spd = pa:GetVelocity():Length()*12
				pa.ranvel = pa.ranvel or VectorRand() * spd
				pa.ranvel:Add(VectorRand() * spd * math.sqrt(FrameTime()))
				pa:SetVelocity(pa:GetVelocity() + pa.ranvel * sl * FrameTime() )
				pa:SetNextThink(CurTime())
			end)

			particle:SetNextThink(CurTime() + 0.01)
		end
	end

	if TFA.GetGasEnabled() then
		local particle = emitter:Add("sprites/heatwave", self.vOffset + dir*2)

		if (particle) then
			particle:SetVelocity(dir * 25 * self.HeatSize + 1.05 * AddVel)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life)
			particle:SetStartAlpha(math.Rand(200, 225))
			particle:SetEndAlpha(0)
			particle:SetStartSize(math.Rand(3, 5) * self.HeatSize)
			particle:SetEndSize(math.Rand(8, 12) * self.HeatSize)
			particle:SetRoll(math.Rand(0, 360))
			particle:SetRollDelta(math.Rand(-2, 2))
			particle:SetAirResistance(5)
			particle:SetGravity(Vector(0, 0, 40))
			particle:SetColor(255, 255, 255)
		end
	end

	emitter:Finish()
end

function EFFECT:Think()
	if CurTime() > self.DieTime then
		return false
	elseif self.DLight and IsValid(self.OwnerEnt) then
			self.DLight.pos = self.OwnerEnt:GetShootPos() + self.OwnerEnt:EyeAngles():Forward() * self.Dist
	end

	return true
end

function EFFECT:Render()
end
--PATH lua/effects/rw_sw_muzzleflash_green.lua:
EFFECT.Life = 0.12
EFFECT.XFlashSize = 0.55
EFFECT.FlashSize = 0.5
EFFECT.SmokeSize = 0
EFFECT.SparkSize = 1.25
EFFECT.HeatSize = 2.5
EFFECT.Color = Color(0,255,0)
EFFECT.ColorSprites = true

local AddVel = Vector()
local ang

function EFFECT:Init(data)
	self.WeaponEnt = data:GetEntity()
	if not IsValid(self.WeaponEnt) then return end
	self.Attachment = data:GetAttachment()
	self.Position = self:GetTracerShootPos(data:GetOrigin(), self.WeaponEnt, self.Attachment)

	if IsValid(self.WeaponEnt:GetOwner()) then
		if self.WeaponEnt:GetOwner() == LocalPlayer() then
			if self.WeaponEnt:GetOwner():ShouldDrawLocalPlayer() then
				ang = self.WeaponEnt:GetOwner():EyeAngles()
				ang:Normalize()
				--ang.p = math.max(math.min(ang.p,55),-55)
				self.Forward = ang:Forward()
			else
				self.WeaponEnt = self.WeaponEnt:GetOwner():GetViewModel()
			end
			--ang.p = math.max(math.min(ang.p,55),-55)
		else
			ang = self.WeaponEnt:GetOwner():EyeAngles()
			ang:Normalize()
			self.Forward = ang:Forward()
		end
	end

	self.Forward = self.Forward or data:GetNormal()
	self.Angle = self.Forward:Angle()
	self.Right = self.Angle:Right()
	self.vOffset = self.Position
	local dir = self.Forward
	local ownerent = self.WeaponEnt:GetOwner()

	if not IsValid(ownerent) then
		ownerent = LocalPlayer()
	end

	AddVel = ownerent:GetVelocity()
	self.vOffset = self.Position
	AddVel = AddVel * 0.05
	local dot = dir:GetNormalized():Dot(GetViewEntity():EyeAngles():Forward())
	local halofac = math.abs(dot)
	local epos = ownerent:GetShootPos()
	local dlight = DynamicLight(ownerent:EntIndex())

	if (dlight) then
		dlight.pos = epos + ownerent:EyeAngles():Forward() * self.vOffset:Distance(epos) --self.vOffset - ownerent:EyeAngles():Right() * 5 + 1.05 * ownerent:GetVelocity() * FrameTime()
		dlight.r = self.Color.r
		dlight.g = self.Color.g
		dlight.b = self.Color.b
		dlight.brightness = 4.5
		dlight.decay = 200 / self.Life
		dlight.size = self.FlashSize * 150
		dlight.dietime = CurTime() + self.Life
	end

	self.Dist = self.vOffset:Distance(epos)
	self.DLight = dlight
	self.DieTime = CurTime() + self.Life
	self.OwnerEnt = ownerent
	local emitter = ParticleEmitter(self.vOffset)
	local sval = 1 - math.random(0, 1) * 2

	if self.WeaponEnt.XTick == nil then
		self.WeaponEnt.XTick = 0
	end

	self.WeaponEnt.XTick = 1 - self.WeaponEnt.XTick

	if self.WeaponEnt.XTick == 1 and self.XFlashSize > 0 then
		local particle = emitter:Add(self.ColorSprites and "effects/muzzleflashx_nemole_w" or "effects/muzzleflashx_nemole", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 4 * self.XFlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life / 2)
			particle:SetStartAlpha(math.Rand(200, 255))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 8 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(3 * (halofac * 0.8 + 0.2) * self.XFlashSize)
			particle:SetEndSize(15 * (halofac * 0.8 + 0.2) * self.XFlashSize)
			local r = math.Rand(-10, 10) * 3.14 / 180
			particle:SetRoll(r)
			particle:SetRollDelta(r / 5)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
			particle:SetPos(vector_origin)
		end
		--particle:SetStartSize( 8 * (halofac*0.8+0.2), 0, 1)
		--particle:SetEndSize( 0 )
	elseif self.XFlashSize > 0 then
		local particle = emitter:Add(self.ColorSprites and "effects/muzzleflashx_nemole_w" or "effects/muzzleflashx_nemole", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 4 * self.FlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life / 2)
			particle:SetStartAlpha(math.Rand(200, 255))
			particle:SetEndAlpha(0)
			particle:SetStartSize(2 * (halofac * 0.8 + 0.2) * 0.3 * self.FlashSize)
			particle:SetEndSize(6 * (halofac * 0.8 + 0.2) * 0.3 * self.FlashSize)
			local r = math.Rand(-10, 10) * 3.14 / 180
			particle:SetRoll(r)
			particle:SetRollDelta(r / 5)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
			particle:SetPos(vector_origin)
		end
	end

	local flashCount = math.Round(self.FlashSize * 8)

	for i = 1, flashCount do
		local particle = emitter:Add(self.ColorSprites and "effects/scotchmuzzleflashw" or "effects/scotchmuzzleflash4", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 300 * (0.2 + (i / flashCount) * 0.8) * self.FlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 0.75)
			particle:SetStartAlpha(math.Rand(128, 255))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			local szsc = 1 + (flashCount - i) * math.pow(1 / flashCount * 0.9,0.8)
			particle:SetStartSize(1.25 * math.Rand(1, 1.5) * szsc * self.FlashSize)
			particle:SetEndSize(6 * math.Rand(0.75, 1) * szsc * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(15, 30)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	for _ = 1, flashCount do
		local particle = emitter:Add("effects/scotchmuzzleflash1", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 6 * self.FlashSize + 1.05 * AddVel)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 1)
			particle:SetStartAlpha(math.Rand(40, 140))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(2 * math.Rand(1, 1.5) * self.FlashSize)
			particle:SetEndSize(20 * math.Rand(0.5, 1) * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(30, 60)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			--TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	local glowCount = math.ceil(self.FlashSize * 3)

	for i = 1, glowCount do
		local particle = emitter:Add("effects/scotchmuzzleflash1", self.vOffset + dir * 0.9 * i)

		if (particle) then
			--particle:SetVelocity(dir * 32 )
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 0.75)
			particle:SetStartAlpha(255 * (1 - halofac))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(math.max(12 - 12 / glowCount * i * 0.5, 1) * 0.2 * self.FlashSize)
			particle:SetEndSize(math.max(12 - 12 / glowCount * i * 0.5, 1) * 0.6 * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(15, 30)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	local smokeCount = math.ceil(self.SmokeSize * 6)

	for _ = 0, smokeCount do
		local particle = emitter:Add("particles/smokey", self.vOffset + dir * math.Rand(3, 14))

		if (particle) then
			particle:SetVelocity(VectorRand() * 10 * self.SmokeSize + dir * math.Rand(35, 50) * self.SmokeSize + 1.05 * AddVel)
			particle:SetDieTime(math.Rand(0.6, 1) * self.Life * 6)
			particle:SetStartAlpha(math.Rand(12, 24))
			particle:SetEndAlpha(0)
			particle:SetStartSize(math.Rand(5, 7) * self.SmokeSize)
			particle:SetEndSize(math.Rand(15, 20) * self.SmokeSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.Rand(-0.8, 0.8))
			particle:SetLighting(true)
			particle:SetAirResistance(20)
			particle:SetGravity(Vector(0, 0, 60))
			particle:SetColor(255, 255, 255)
		end
	end

	local sparkcount = math.Round(math.random(8, 12) * self.SparkSize)

	for _ = 0, sparkcount do
		local particle = emitter:Add("effects/yellowflare", self.Position)

		if (particle) then
			particle:SetVelocity( VectorRand() * 30 * self.SparkSize)
			particle:SetVelocity(particle:GetVelocity() + 1.15 * AddVel )
			particle:SetVelocity( particle:GetVelocity() + dir * math.Rand(80, 100) * (1-math.abs(math.max(particle:GetVelocity():GetNormalized():Dot(-dir),0))) * self.SparkSize )
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * math.Rand(0.9,1.1))
			particle:SetStartAlpha(255)
			particle:SetEndAlpha(0)
			particle:SetStartSize(0.6)
			particle:SetEndSize(1)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetGravity(vector_origin)
			particle:SetAirResistance(1)
			particle:SetStartLength(0.1)
			particle:SetEndLength(0.05)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, math.random(192, 225), math.random(140, 192))
			end

			particle:SetVelocityScale(true)
			local sl = self.SparkSize

			particle:SetThinkFunction(function(pa)
				math.randomseed(SysTime())
				local spd = pa:GetVelocity():Length()*12
				pa.ranvel = pa.ranvel or VectorRand() * spd
				pa.ranvel:Add(VectorRand() * spd * math.sqrt(FrameTime()))
				pa:SetVelocity(pa:GetVelocity() + pa.ranvel * sl * FrameTime() )
				pa:SetNextThink(CurTime())
			end)

			particle:SetNextThink(CurTime() + 0.01)
		end
	end

	if TFA.GetGasEnabled() then
		local particle = emitter:Add("sprites/heatwave", self.vOffset + dir*2)

		if (particle) then
			particle:SetVelocity(dir * 25 * self.HeatSize + 1.05 * AddVel)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life)
			particle:SetStartAlpha(math.Rand(200, 225))
			particle:SetEndAlpha(0)
			particle:SetStartSize(math.Rand(3, 5) * self.HeatSize)
			particle:SetEndSize(math.Rand(8, 12) * self.HeatSize)
			particle:SetRoll(math.Rand(0, 360))
			particle:SetRollDelta(math.Rand(-2, 2))
			particle:SetAirResistance(5)
			particle:SetGravity(Vector(0, 0, 40))
			particle:SetColor(255, 255, 255)
		end
	end

	emitter:Finish()
end

function EFFECT:Think()
	if CurTime() > self.DieTime then
		return false
	elseif self.DLight and IsValid(self.OwnerEnt) then
			self.DLight.pos = self.OwnerEnt:GetShootPos() + self.OwnerEnt:EyeAngles():Forward() * self.Dist
	end

	return true
end

function EFFECT:Render()
end
--PATH lua/effects/rw_sw_muzzleflash_purple.lua:
EFFECT.Life = 0.12
EFFECT.XFlashSize = 0.55
EFFECT.FlashSize = 0.5
EFFECT.SmokeSize = 0
EFFECT.SparkSize = 1.25
EFFECT.HeatSize = 2.5
EFFECT.Color = Color(155,0,255)
EFFECT.ColorSprites = true

local AddVel = Vector()
local ang

function EFFECT:Init(data)
	self.WeaponEnt = data:GetEntity()
	if not IsValid(self.WeaponEnt) then return end
	self.Attachment = data:GetAttachment()
	self.Position = self:GetTracerShootPos(data:GetOrigin(), self.WeaponEnt, self.Attachment)

	if IsValid(self.WeaponEnt:GetOwner()) then
		if self.WeaponEnt:GetOwner() == LocalPlayer() then
			if self.WeaponEnt:GetOwner():ShouldDrawLocalPlayer() then
				ang = self.WeaponEnt:GetOwner():EyeAngles()
				ang:Normalize()
				--ang.p = math.max(math.min(ang.p,55),-55)
				self.Forward = ang:Forward()
			else
				self.WeaponEnt = self.WeaponEnt:GetOwner():GetViewModel()
			end
			--ang.p = math.max(math.min(ang.p,55),-55)
		else
			ang = self.WeaponEnt:GetOwner():EyeAngles()
			ang:Normalize()
			self.Forward = ang:Forward()
		end
	end

	self.Forward = self.Forward or data:GetNormal()
	self.Angle = self.Forward:Angle()
	self.Right = self.Angle:Right()
	self.vOffset = self.Position
	local dir = self.Forward
	local ownerent = self.WeaponEnt:GetOwner()

	if not IsValid(ownerent) then
		ownerent = LocalPlayer()
	end

	AddVel = ownerent:GetVelocity()
	self.vOffset = self.Position
	AddVel = AddVel * 0.05
	local dot = dir:GetNormalized():Dot(GetViewEntity():EyeAngles():Forward())
	local halofac = math.abs(dot)
	local epos = ownerent:GetShootPos()
	local dlight = DynamicLight(ownerent:EntIndex())

	if (dlight) then
		dlight.pos = epos + ownerent:EyeAngles():Forward() * self.vOffset:Distance(epos) --self.vOffset - ownerent:EyeAngles():Right() * 5 + 1.05 * ownerent:GetVelocity() * FrameTime()
		dlight.r = self.Color.r
		dlight.g = self.Color.g
		dlight.b = self.Color.b
		dlight.brightness = 4.5
		dlight.decay = 200 / self.Life
		dlight.size = self.FlashSize * 150
		dlight.dietime = CurTime() + self.Life
	end

	self.Dist = self.vOffset:Distance(epos)
	self.DLight = dlight
	self.DieTime = CurTime() + self.Life
	self.OwnerEnt = ownerent
	local emitter = ParticleEmitter(self.vOffset)
	local sval = 1 - math.random(0, 1) * 2

	if self.WeaponEnt.XTick == nil then
		self.WeaponEnt.XTick = 0
	end

	self.WeaponEnt.XTick = 1 - self.WeaponEnt.XTick

	if self.WeaponEnt.XTick == 1 and self.XFlashSize > 0 then
		local particle = emitter:Add(self.ColorSprites and "effects/muzzleflashx_nemole_w" or "effects/muzzleflashx_nemole", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 4 * self.XFlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life / 2)
			particle:SetStartAlpha(math.Rand(200, 255))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 8 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(3 * (halofac * 0.8 + 0.2) * self.XFlashSize)
			particle:SetEndSize(15 * (halofac * 0.8 + 0.2) * self.XFlashSize)
			local r = math.Rand(-10, 10) * 3.14 / 180
			particle:SetRoll(r)
			particle:SetRollDelta(r / 5)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
			particle:SetPos(vector_origin)
		end
		--particle:SetStartSize( 8 * (halofac*0.8+0.2), 0, 1)
		--particle:SetEndSize( 0 )
	elseif self.XFlashSize > 0 then
		local particle = emitter:Add(self.ColorSprites and "effects/muzzleflashx_nemole_w" or "effects/muzzleflashx_nemole", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 4 * self.FlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life / 2)
			particle:SetStartAlpha(math.Rand(200, 255))
			particle:SetEndAlpha(0)
			particle:SetStartSize(2 * (halofac * 0.8 + 0.2) * 0.3 * self.FlashSize)
			particle:SetEndSize(6 * (halofac * 0.8 + 0.2) * 0.3 * self.FlashSize)
			local r = math.Rand(-10, 10) * 3.14 / 180
			particle:SetRoll(r)
			particle:SetRollDelta(r / 5)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
			particle:SetPos(vector_origin)
		end
	end

	local flashCount = math.Round(self.FlashSize * 8)

	for i = 1, flashCount do
		local particle = emitter:Add(self.ColorSprites and "effects/scotchmuzzleflashw" or "effects/scotchmuzzleflash4", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 300 * (0.2 + (i / flashCount) * 0.8) * self.FlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 0.75)
			particle:SetStartAlpha(math.Rand(128, 255))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			local szsc = 1 + (flashCount - i) * math.pow(1 / flashCount * 0.9,0.8)
			particle:SetStartSize(1.25 * math.Rand(1, 1.5) * szsc * self.FlashSize)
			particle:SetEndSize(6 * math.Rand(0.75, 1) * szsc * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(15, 30)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	for _ = 1, flashCount do
		local particle = emitter:Add("effects/scotchmuzzleflash1", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 6 * self.FlashSize + 1.05 * AddVel)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 1)
			particle:SetStartAlpha(math.Rand(40, 140))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(2 * math.Rand(1, 1.5) * self.FlashSize)
			particle:SetEndSize(20 * math.Rand(0.5, 1) * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(30, 60)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			--TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	local glowCount = math.ceil(self.FlashSize * 3)

	for i = 1, glowCount do
		local particle = emitter:Add("effects/scotchmuzzleflash1", self.vOffset + dir * 0.9 * i)

		if (particle) then
			--particle:SetVelocity(dir * 32 )
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 0.75)
			particle:SetStartAlpha(255 * (1 - halofac))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(math.max(12 - 12 / glowCount * i * 0.5, 1) * 0.2 * self.FlashSize)
			particle:SetEndSize(math.max(12 - 12 / glowCount * i * 0.5, 1) * 0.6 * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(15, 30)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	local smokeCount = math.ceil(self.SmokeSize * 6)

	for _ = 0, smokeCount do
		local particle = emitter:Add("particles/smokey", self.vOffset + dir * math.Rand(3, 14))

		if (particle) then
			particle:SetVelocity(VectorRand() * 10 * self.SmokeSize + dir * math.Rand(35, 50) * self.SmokeSize + 1.05 * AddVel)
			particle:SetDieTime(math.Rand(0.6, 1) * self.Life * 6)
			particle:SetStartAlpha(math.Rand(12, 24))
			particle:SetEndAlpha(0)
			particle:SetStartSize(math.Rand(5, 7) * self.SmokeSize)
			particle:SetEndSize(math.Rand(15, 20) * self.SmokeSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.Rand(-0.8, 0.8))
			particle:SetLighting(true)
			particle:SetAirResistance(20)
			particle:SetGravity(Vector(0, 0, 60))
			particle:SetColor(255, 255, 255)
		end
	end

	local sparkcount = math.Round(math.random(8, 12) * self.SparkSize)

	for _ = 0, sparkcount do
		local particle = emitter:Add("effects/yellowflare", self.Position)

		if (particle) then
			particle:SetVelocity( VectorRand() * 30 * self.SparkSize)
			particle:SetVelocity(particle:GetVelocity() + 1.15 * AddVel )
			particle:SetVelocity( particle:GetVelocity() + dir * math.Rand(80, 100) * (1-math.abs(math.max(particle:GetVelocity():GetNormalized():Dot(-dir),0))) * self.SparkSize )
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * math.Rand(0.9,1.1))
			particle:SetStartAlpha(255)
			particle:SetEndAlpha(0)
			particle:SetStartSize(0.6)
			particle:SetEndSize(1)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetGravity(vector_origin)
			particle:SetAirResistance(1)
			particle:SetStartLength(0.1)
			particle:SetEndLength(0.05)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, math.random(192, 225), math.random(140, 192))
			end

			particle:SetVelocityScale(true)
			local sl = self.SparkSize

			particle:SetThinkFunction(function(pa)
				math.randomseed(SysTime())
				local spd = pa:GetVelocity():Length()*12
				pa.ranvel = pa.ranvel or VectorRand() * spd
				pa.ranvel:Add(VectorRand() * spd * math.sqrt(FrameTime()))
				pa:SetVelocity(pa:GetVelocity() + pa.ranvel * sl * FrameTime() )
				pa:SetNextThink(CurTime())
			end)

			particle:SetNextThink(CurTime() + 0.01)
		end
	end

	if TFA.GetGasEnabled() then
		local particle = emitter:Add("sprites/heatwave", self.vOffset + dir*2)

		if (particle) then
			particle:SetVelocity(dir * 25 * self.HeatSize + 1.05 * AddVel)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life)
			particle:SetStartAlpha(math.Rand(200, 225))
			particle:SetEndAlpha(0)
			particle:SetStartSize(math.Rand(3, 5) * self.HeatSize)
			particle:SetEndSize(math.Rand(8, 12) * self.HeatSize)
			particle:SetRoll(math.Rand(0, 360))
			particle:SetRollDelta(math.Rand(-2, 2))
			particle:SetAirResistance(5)
			particle:SetGravity(Vector(0, 0, 40))
			particle:SetColor(255, 255, 255)
		end
	end

	emitter:Finish()
end

function EFFECT:Think()
	if CurTime() > self.DieTime then
		return false
	elseif self.DLight and IsValid(self.OwnerEnt) then
			self.DLight.pos = self.OwnerEnt:GetShootPos() + self.OwnerEnt:EyeAngles():Forward() * self.Dist
	end

	return true
end

function EFFECT:Render()
end
--PATH lua/effects/serv_passive_heal.lua:
return gluapack()()
--PATH lua/effects/serv_passive_poison.lua:
EFFECT.Mat1 = Material( "particle/particle_ring_wave_8" )

function EFFECT:Init( data )
	self.StartPos = data:GetOrigin()
	self.Entity = data:GetEntity()
	self.FollowPlayer = self.Entity:GetPos()

	self.Duration = data:GetScale()*6
	self.HPMax = math.max( math.Round( data:GetMagnitude() ),0)
	self.HealingAm = 0

	self.Life = 0

	self.Color = Color(91, 47, 82, 255)
end

function EFFECT:Think()
	if !self.Entity:IsValid() then return end

	self.HealingAm = math.Clamp((self.Entity:GetMaxHealth()-self.Entity:Health())/2, 0, 10)

	self.FollowPlayer = self.Entity:GetPos()

	self.Life = self.Life + FrameTime() * 6

	return ( self.Life < self.Duration )
end

function EFFECT:Render()
	-- Particles
	local emitter = ParticleEmitter( self.FollowPlayer, false )
	local particle = emitter:Add( self.Mat1, (self.FollowPlayer+Vector(0,0,20))+(VectorRand()*15) )
	if (particle) then
		particle:SetLifeTime(0) 
		particle:SetDieTime(1) 
		particle:SetStartAlpha( 80+(self.HealingAm*5) )
		particle:SetEndAlpha(0)
		particle:SetStartSize(30) 
		particle:SetEndSize(70)
		particle:SetAngles( Angle(math.random( 0, 360 ),math.random( 0, 360 ),math.random( 0, 360 )) )
		particle:SetAngleVelocity( Angle(math.random( 0, 1 ),math.random( 0, 1 ),math.random( 0, 1 )) ) 
		particle:SetRoll(math.random( 0, 360 ))
		particle:SetColor( self.Color["r"], self.Color["g"], self.Color["b"] )
		particle:SetGravity( Vector(0, 0, 0 ) ) 
		particle:SetVelocity( Vector(math.random( -30, 30 ), math.random( -30, 30 ), math.random( 50, 75 ) ) ) 
		particle:SetAirResistance(50)  
		particle:SetCollide(true)
		particle:SetBounce(0)
	end
	emitter:Finish()
end
--PATH lua/effects/servius_stun/init.lua:
return gluapack()()
--PATH lua/effects/sfw_muzzle_generic.lua:
return gluapack()()
--PATH lua/effects/spr_tracer_noattach.lua:
AddCSLuaFile()
AddCSLuaFile( "effects/fxbase.lua" )
include( "effects/fxbase.lua" )

EFFECT.Speed	= 6500 --16000
EFFECT.Length	= 64

function EFFECT:Init( data )

	self.StartPos = data:GetStart() --self:GetTracerOrigin( data )
	self.EndPos = data:GetOrigin()
	self.Parent = data:GetEntity()
	
	self.Entity:SetRenderBoundsWS( self.StartPos, self.EndPos )

	local diff = ( self.EndPos - self.StartPos )
	
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	
	if ( !self.LifeTime ) then
		self.LifeTime = ( diff:Length() + self.Length ) / self.Speed
	else
		self.LifeTime = CurTime() + self.LifeTime
	end
	
end

function EFFECT:Think()

	util.ParticleTracerEx( 
		"spr_tracer", 	--particle system
		self.StartPos, 	--startpos
		self.EndPos, 	--endpos
		true, 			--do whiz effect
		-1, 			--entity index
		-1  			--attachment
	)
	
	return false
	
end

--PATH lua/effects/swep_flamethrower_explosion/init.lua:
return gluapack()()
--PATH lua/effects/fxbase.lua:
return gluapack()()
--PATH lua/effects/fxbase.lua:
-- based on nomad's tracer by Chad Barrett --
-- edited for the use with SciFiWeapons by Darken217 --

AddCSLuaFile()
if ( CLIENT ) then
TRACER_FLAG_USEATTACHMENT	= 0x0002
end
EFFECT.Speed	= 6500
EFFECT.Length	= 64
EFFECT.Normal 	= Vector( 0, 0, 0 )

function EFFECT:GetTracerOrigin( data )
	if ( CLIENT ) then
		local vOrigin = data:GetStart()

		if ( bit.band( data:GetFlags(), TRACER_FLAG_USEATTACHMENT ) == TRACER_FLAG_USEATTACHMENT ) then
			local entParent = data:GetEntity()
			
			if ( !IsValid( entParent ) ) then 
				return vOrigin 
			end
			
			if ( !game.SinglePlayer() && entParent:IsEFlagSet( EFL_DORMANT ) ) then 
				return vOrigin 
			end
			
			if( entParent:IsWeapon() && entParent:IsCarriedByLocalPlayer() ) then
				local entPlayer = entParent:GetOwner()
				if ( IsValid( entPlayer ) ) then
					local entViewModel = entPlayer:GetViewModel()
					if ( IsValid( entViewModel ) && !LocalPlayer():ShouldDrawLocalPlayer() ) then
						entParent = entViewModel
					else 					
						if ( entParent.WorldModel ) then
							entParent:SetModel( entParent.WorldModel )
						end
					end
				end
			end

			local attachment = entParent:GetAttachment( data:GetAttachment() )
			if ( attachment ) then
				vOrigin = attachment.Pos
			end

		end
		
		return vOrigin
	end
end

function EFFECT:Init( data )

	self.StartPos = self:GetTracerOrigin( data )
	self.EndPos = data:GetOrigin()
	self.Parent = data:GetEntity()
	
--	self.Entity:SetRenderBoundsWS( self.StartPos, self.EndPos )

	local diff = ( self.EndPos - self.StartPos )
	
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	
	if ( !self.LifeTime ) then
		self.LifeTime = ( diff:Length() + self.Length ) / self.Speed
	else
		self.LifeTime = CurTime() + self.LifeTime
	end
	
end

function EFFECT:Think()

	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()
	
	return self.LifeTime > 0

end

function EFFECT:Render()

	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	
	startDistance = math.max( 0, startDistance )
	endDistance = math.max( 0, endDistance )

	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	
end
--PATH lua/effects/tfa_csgo_poisonade/init.lua:
return gluapack()()
--PATH lua/effects/tfa_dust_impact/init.lua:
function EFFECT:Init(data)
	local ply = data:GetEntity()
	local ent

	if IsValid(ply) and ply:IsPlayer() then
		ent = ply:GetActiveWeapon()
	end

	local sfac = (IsValid(ent) and ent.Primary and ent.Primary.Damage) and math.sqrt(ent.Primary.Damage / 30) or 1
	local sfac_sqrt = math.sqrt(sfac)
	local posoffset = data:GetOrigin()
	local forward = data:GetNormal()
	local emitter = ParticleEmitter(posoffset)

	for i = 0, math.Round(8 * sfac) do
		local p = emitter:Add("particle/particle_smokegrenade", posoffset)
		p:SetVelocity(90 * math.sqrt(i) * forward)
		p:SetAirResistance(400)
		p:SetStartAlpha(math.Rand(255, 255))
		p:SetEndAlpha(0)
		p:SetDieTime(math.Rand(0.75, 1) * (1 + math.sqrt(i) / 3))
		local iclamped = math.Clamp(i, 1, 8)
		local iclamped_sqrt = math.sqrt(iclamped / 8) * 8
		p:SetStartSize(math.Rand(1, 1) * sfac_sqrt * iclamped_sqrt)
		p:SetEndSize(math.Rand(1.5, 1.75) * sfac_sqrt * iclamped)
		p:SetRoll(math.Rand(-25, 25))
		p:SetRollDelta(math.Rand(-0.05, 0.05))
		p:SetColor(255, 255, 255)
		p:SetLighting(true)
	end

	emitter:Finish()
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
return false
end
--PATH lua/tfa/muzzleflash_base.lua:
return gluapack()()
--PATH lua/effects/tfa_muzzleflash_generic/init.lua:
include("tfa/muzzleflash_base.lua")

EFFECT.Life = 0.075
EFFECT.XFlashSize = 0.5
EFFECT.FlashSize = 0.8
EFFECT.SmokeSize = 1
EFFECT.SparkSize = 1
EFFECT.HeatSize = 1
EFFECT.Color = Color(255, 225, 128)
EFFECT.ColorSprites = false

--PATH lua/tfa/muzzleflash_base.lua:
local vector_origin = Vector()

EFFECT.Life = 0.1
EFFECT.XFlashSize = 1
EFFECT.FlashSize = 1
EFFECT.SmokeSize = 1
EFFECT.SparkSize = 1
EFFECT.HeatSize = 1
EFFECT.Color = Color(255, 192, 64)
EFFECT.ColorSprites = false
EFFECT.UseDynamicLight = true

local AddVel = Vector()
local ang

function EFFECT:Init(data)
	self.WeaponEnt = data:GetEntity()
	if not IsValid(self.WeaponEnt) then return end
	self.Attachment = data:GetAttachment()
	self.Position = self:GetTracerShootPos(data:GetOrigin(), self.WeaponEnt, self.Attachment)

	if IsValid(self.WeaponEnt:GetOwner()) then
		if self.WeaponEnt:GetOwner() == LocalPlayer() then
			if self.WeaponEnt:GetOwner():ShouldDrawLocalPlayer() then
				ang = self.WeaponEnt:GetOwner():EyeAngles()
				ang:Normalize()
				--ang.p = math.max(math.min(ang.p,55),-55)
				self.Forward = ang:Forward()
			else
				self.WeaponEnt = self.WeaponEnt.OwnerViewModel
			end
			--ang.p = math.max(math.min(ang.p,55),-55)
		else
			ang = self.WeaponEnt:GetOwner():EyeAngles()
			ang:Normalize()
			self.Forward = ang:Forward()
		end
	end

	self.Forward = self.Forward or data:GetNormal()
	self.Angle = self.Forward:Angle()
	self.Right = self.Angle:Right()
	self.vOffset = self.Position
	local dir = self.Forward
	local ownerent = self.WeaponEnt:GetOwner()

	if not IsValid(ownerent) then
		ownerent = LocalPlayer()
	end

	AddVel = ownerent:GetVelocity()
	self.vOffset = self.Position
	AddVel = AddVel * 0.05
	local dot = dir:GetNormalized():Dot(GetViewEntity():EyeAngles():Forward())
	local halofac = math.abs(dot)
	local epos = ownerent:EyePos()

	local dlight
	if self.UseDynamicLight then
		dlight = DynamicLight(ownerent:EntIndex())

		if (dlight) then
			dlight.pos = epos + ownerent:EyeAngles():Forward() * self.vOffset:Distance(epos) --self.vOffset - ownerent:EyeAngles():Right() * 5 + 1.05 * ownerent:GetVelocity() * FrameTime()
			dlight.r = self.Color.r
			dlight.g = self.Color.g
			dlight.b = self.Color.b
			dlight.brightness = 4.5
			dlight.decay = 200 / self.Life
			dlight.size = self.FlashSize * 96
			dlight.dietime = CurTime() + self.Life
		end
	end

	self.Dist = self.vOffset:Distance(epos)
	self.DLight = dlight
	self.DieTime = CurTime() + self.Life
	self.OwnerEnt = ownerent
	local emitter = ParticleEmitter(self.vOffset)
	local sval = 1 - math.random(0, 1) * 2

	if self.WeaponEnt.XTick == nil then
		self.WeaponEnt.XTick = 0
	end

	self.WeaponEnt.XTick = 1 - self.WeaponEnt.XTick

	if self.WeaponEnt.XTick == 1 and self.XFlashSize > 0 then
		local particle = emitter:Add(self.ColorSprites and "effects/muzzleflashx_nemole_w" or "effects/muzzleflashx_nemole", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 4 * self.XFlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life / 2)
			particle:SetStartAlpha(math.Rand(200, 255))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 8 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(3 * (halofac * 0.8 + 0.2) * self.XFlashSize)
			particle:SetEndSize(15 * (halofac * 0.8 + 0.2) * self.XFlashSize)
			local r = math.Rand(-10, 10) * 3.14 / 180
			particle:SetRoll(r)
			particle:SetRollDelta(r / 5)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
			particle:SetPos(vector_origin)
		end
		--particle:SetStartSize( 8 * (halofac*0.8+0.2), 0, 1)
		--particle:SetEndSize( 0 )
	elseif self.XFlashSize > 0 then
		local particle = emitter:Add(self.ColorSprites and "effects/muzzleflashx_nemole_w" or "effects/muzzleflashx_nemole", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 4 * self.FlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life / 2)
			particle:SetStartAlpha(math.Rand(200, 255))
			particle:SetEndAlpha(0)
			particle:SetStartSize(2 * (halofac * 0.8 + 0.2) * 0.3 * self.FlashSize)
			particle:SetEndSize(6 * (halofac * 0.8 + 0.2) * 0.3 * self.FlashSize)
			local r = math.Rand(-10, 10) * 3.14 / 180
			particle:SetRoll(r)
			particle:SetRollDelta(r / 5)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
			particle:SetPos(vector_origin)
		end
	end

	local flashCount = math.Round(self.FlashSize * 8)

	for i = 1, flashCount do
		local particle = emitter:Add(self.ColorSprites and "effects/scotchmuzzleflashw" or "effects/scotchmuzzleflash4", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 300 * (0.2 + (i / flashCount) * 0.8) * self.FlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 0.75)
			particle:SetStartAlpha(math.Rand(128, 255))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			local szsc = 1 + (flashCount - i) * math.pow(1 / flashCount * 0.9,0.8)
			particle:SetStartSize(1.25 * math.Rand(1, 1.5) * szsc * self.FlashSize)
			particle:SetEndSize(6 * math.Rand(0.75, 1) * szsc * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(15, 30)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	for _ = 1, flashCount do
		local particle = emitter:Add("effects/scotchmuzzleflash1", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 6 * self.FlashSize + 1.05 * AddVel)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 1)
			particle:SetStartAlpha(math.Rand(40, 140))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(2 * math.Rand(1, 1.5) * self.FlashSize)
			particle:SetEndSize(20 * math.Rand(0.5, 1) * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(30, 60)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			--TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	local glowCount = math.ceil(self.FlashSize * 3)

	for i = 1, glowCount do
		local particle = emitter:Add("effects/scotchmuzzleflash1", self.vOffset + dir * 0.9 * i)

		if (particle) then
			--particle:SetVelocity(dir * 32 )
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 0.75)
			particle:SetStartAlpha(255 * (1 - halofac))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(math.max(12 - 12 / glowCount * i * 0.5, 1) * 0.2 * self.FlashSize)
			particle:SetEndSize(math.max(12 - 12 / glowCount * i * 0.5, 1) * 0.6 * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(15, 30)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	if TFA.GetMZFSmokeEnabled() then
		local smokeCount = math.ceil(self.SmokeSize * 6)

		for _ = 0, smokeCount do
			local particle = emitter:Add("particles/smokey", self.vOffset + dir * math.Rand(3, 14))

			if (particle) then
				particle:SetVelocity(VectorRand() * 10 * self.SmokeSize + dir * math.Rand(35, 50) * self.SmokeSize + 1.05 * AddVel)
				particle:SetDieTime(math.Rand(0.6, 1) * self.Life * 6)
				particle:SetStartAlpha(math.Rand(12, 24))
				particle:SetEndAlpha(0)
				particle:SetStartSize(math.Rand(5, 7) * self.SmokeSize)
				particle:SetEndSize(math.Rand(15, 20) * self.SmokeSize)
				particle:SetRoll(math.rad(math.Rand(0, 360)))
				particle:SetRollDelta(math.Rand(-0.8, 0.8))
				particle:SetLighting(true)
				particle:SetAirResistance(20)
				particle:SetGravity(Vector(0, 0, 60))
				particle:SetColor(255, 255, 255)
			end
		end
	end

	local sparkcount = math.Round(math.random(8, 12) * self.SparkSize)

	for _ = 0, sparkcount do
		local particle = emitter:Add("effects/yellowflare", self.Position)

		if (particle) then
			particle:SetVelocity( VectorRand() * 30 * self.SparkSize)
			particle:SetVelocity(particle:GetVelocity() + 1.15 * AddVel )
			particle:SetVelocity( particle:GetVelocity() + dir * math.Rand(80, 100) * (1-math.abs(math.max(particle:GetVelocity():GetNormalized():Dot(-dir),0))) * self.SparkSize )
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * math.Rand(0.9,1.1))
			particle:SetStartAlpha(255)
			particle:SetEndAlpha(0)
			particle:SetStartSize(0.6)
			particle:SetEndSize(1)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetGravity(vector_origin)
			particle:SetAirResistance(1)
			particle:SetStartLength(0.1)
			particle:SetEndLength(0.05)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, math.random(192, 225), math.random(140, 192))
			end

			particle:SetVelocityScale(true)
			local sl = self.SparkSize

			particle:SetThinkFunction(function(pa)
				math.randomseed(SysTime())
				local spd = pa:GetVelocity():Length()*12
				pa.ranvel = pa.ranvel or VectorRand() * spd
				pa.ranvel:Add(VectorRand() * spd * math.sqrt(FrameTime()))
				pa:SetVelocity(pa:GetVelocity() + pa.ranvel * sl * FrameTime() )
				pa:SetNextThink(CurTime())
			end)

			particle:SetNextThink(CurTime() + 0.01)
		end
	end

	if TFA.GetGasEnabled() then
		local particle = emitter:Add("sprites/heatwave", self.vOffset + dir*2)

		if (particle) then
			particle:SetVelocity(dir * 25 * self.HeatSize + 1.05 * AddVel)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life)
			particle:SetStartAlpha(math.Rand(200, 225))
			particle:SetEndAlpha(0)
			particle:SetStartSize(math.Rand(3, 5) * self.HeatSize)
			particle:SetEndSize(math.Rand(8, 12) * self.HeatSize)
			particle:SetRoll(math.Rand(0, 360))
			particle:SetRollDelta(math.Rand(-2, 2))
			particle:SetAirResistance(5)
			particle:SetGravity(Vector(0, 0, 40))
			particle:SetColor(255, 255, 255)
		end
	end

	emitter:Finish()
end

function EFFECT:Think()
	if CurTime() > (self.DieTime or 0) then
		return false
	elseif self.DLight and IsValid(self.OwnerEnt) then
		self.DLight.pos = self.OwnerEnt:EyePos() + self.OwnerEnt:EyeAngles():Forward() * self.Dist
	end

	return true
end

function EFFECT:Render()
end
--PATH lua/tfa/muzzleflash_base.lua:
return gluapack()()
--PATH lua/tfa/muzzleflash_base.lua:
return gluapack()()
--PATH lua/tfa/muzzleflash_base.lua:
return gluapack()()
--PATH lua/tfa/muzzleflash_base.lua:
local vector_origin = Vector()

EFFECT.Life = 0.1
EFFECT.XFlashSize = 1
EFFECT.FlashSize = 1
EFFECT.SmokeSize = 1
EFFECT.SparkSize = 1
EFFECT.HeatSize = 1
EFFECT.Color = Color(255, 192, 64)
EFFECT.ColorSprites = false
EFFECT.UseDynamicLight = true

local AddVel = Vector()
local ang

function EFFECT:Init(data)
	self.WeaponEnt = data:GetEntity()
	if not IsValid(self.WeaponEnt) then return end
	self.Attachment = data:GetAttachment()
	self.Position = self:GetTracerShootPos(data:GetOrigin(), self.WeaponEnt, self.Attachment)

	if IsValid(self.WeaponEnt:GetOwner()) then
		if self.WeaponEnt:GetOwner() == LocalPlayer() then
			if self.WeaponEnt:GetOwner():ShouldDrawLocalPlayer() then
				ang = self.WeaponEnt:GetOwner():EyeAngles()
				ang:Normalize()
				--ang.p = math.max(math.min(ang.p,55),-55)
				self.Forward = ang:Forward()
			else
				self.WeaponEnt = self.WeaponEnt.OwnerViewModel
			end
			--ang.p = math.max(math.min(ang.p,55),-55)
		else
			ang = self.WeaponEnt:GetOwner():EyeAngles()
			ang:Normalize()
			self.Forward = ang:Forward()
		end
	end

	self.Forward = self.Forward or data:GetNormal()
	self.Angle = self.Forward:Angle()
	self.Right = self.Angle:Right()
	self.vOffset = self.Position
	local dir = self.Forward
	local ownerent = self.WeaponEnt:GetOwner()

	if not IsValid(ownerent) then
		ownerent = LocalPlayer()
	end

	AddVel = ownerent:GetVelocity()
	self.vOffset = self.Position
	AddVel = AddVel * 0.05
	local dot = dir:GetNormalized():Dot(GetViewEntity():EyeAngles():Forward())
	local halofac = math.abs(dot)
	local epos = ownerent:EyePos()

	local dlight
	if self.UseDynamicLight then
		dlight = DynamicLight(ownerent:EntIndex())

		if (dlight) then
			dlight.pos = epos + ownerent:EyeAngles():Forward() * self.vOffset:Distance(epos) --self.vOffset - ownerent:EyeAngles():Right() * 5 + 1.05 * ownerent:GetVelocity() * FrameTime()
			dlight.r = self.Color.r
			dlight.g = self.Color.g
			dlight.b = self.Color.b
			dlight.brightness = 4.5
			dlight.decay = 200 / self.Life
			dlight.size = self.FlashSize * 96
			dlight.dietime = CurTime() + self.Life
		end
	end

	self.Dist = self.vOffset:Distance(epos)
	self.DLight = dlight
	self.DieTime = CurTime() + self.Life
	self.OwnerEnt = ownerent
	local emitter = ParticleEmitter(self.vOffset)
	local sval = 1 - math.random(0, 1) * 2

	if self.WeaponEnt.XTick == nil then
		self.WeaponEnt.XTick = 0
	end

	self.WeaponEnt.XTick = 1 - self.WeaponEnt.XTick

	if self.WeaponEnt.XTick == 1 and self.XFlashSize > 0 then
		local particle = emitter:Add(self.ColorSprites and "effects/muzzleflashx_nemole_w" or "effects/muzzleflashx_nemole", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 4 * self.XFlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life / 2)
			particle:SetStartAlpha(math.Rand(200, 255))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 8 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(3 * (halofac * 0.8 + 0.2) * self.XFlashSize)
			particle:SetEndSize(15 * (halofac * 0.8 + 0.2) * self.XFlashSize)
			local r = math.Rand(-10, 10) * 3.14 / 180
			particle:SetRoll(r)
			particle:SetRollDelta(r / 5)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
			particle:SetPos(vector_origin)
		end
		--particle:SetStartSize( 8 * (halofac*0.8+0.2), 0, 1)
		--particle:SetEndSize( 0 )
	elseif self.XFlashSize > 0 then
		local particle = emitter:Add(self.ColorSprites and "effects/muzzleflashx_nemole_w" or "effects/muzzleflashx_nemole", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 4 * self.FlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life / 2)
			particle:SetStartAlpha(math.Rand(200, 255))
			particle:SetEndAlpha(0)
			particle:SetStartSize(2 * (halofac * 0.8 + 0.2) * 0.3 * self.FlashSize)
			particle:SetEndSize(6 * (halofac * 0.8 + 0.2) * 0.3 * self.FlashSize)
			local r = math.Rand(-10, 10) * 3.14 / 180
			particle:SetRoll(r)
			particle:SetRollDelta(r / 5)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
			particle:SetPos(vector_origin)
		end
	end

	local flashCount = math.Round(self.FlashSize * 8)

	for i = 1, flashCount do
		local particle = emitter:Add(self.ColorSprites and "effects/scotchmuzzleflashw" or "effects/scotchmuzzleflash4", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 300 * (0.2 + (i / flashCount) * 0.8) * self.FlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 0.75)
			particle:SetStartAlpha(math.Rand(128, 255))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			local szsc = 1 + (flashCount - i) * math.pow(1 / flashCount * 0.9,0.8)
			particle:SetStartSize(1.25 * math.Rand(1, 1.5) * szsc * self.FlashSize)
			particle:SetEndSize(6 * math.Rand(0.75, 1) * szsc * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(15, 30)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	for _ = 1, flashCount do
		local particle = emitter:Add("effects/scotchmuzzleflash1", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 6 * self.FlashSize + 1.05 * AddVel)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 1)
			particle:SetStartAlpha(math.Rand(40, 140))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(2 * math.Rand(1, 1.5) * self.FlashSize)
			particle:SetEndSize(20 * math.Rand(0.5, 1) * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(30, 60)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			--TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	local glowCount = math.ceil(self.FlashSize * 3)

	for i = 1, glowCount do
		local particle = emitter:Add("effects/scotchmuzzleflash1", self.vOffset + dir * 0.9 * i)

		if (particle) then
			--particle:SetVelocity(dir * 32 )
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 0.75)
			particle:SetStartAlpha(255 * (1 - halofac))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(math.max(12 - 12 / glowCount * i * 0.5, 1) * 0.2 * self.FlashSize)
			particle:SetEndSize(math.max(12 - 12 / glowCount * i * 0.5, 1) * 0.6 * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(15, 30)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	if TFA.GetMZFSmokeEnabled() then
		local smokeCount = math.ceil(self.SmokeSize * 6)

		for _ = 0, smokeCount do
			local particle = emitter:Add("particles/smokey", self.vOffset + dir * math.Rand(3, 14))

			if (particle) then
				particle:SetVelocity(VectorRand() * 10 * self.SmokeSize + dir * math.Rand(35, 50) * self.SmokeSize + 1.05 * AddVel)
				particle:SetDieTime(math.Rand(0.6, 1) * self.Life * 6)
				particle:SetStartAlpha(math.Rand(12, 24))
				particle:SetEndAlpha(0)
				particle:SetStartSize(math.Rand(5, 7) * self.SmokeSize)
				particle:SetEndSize(math.Rand(15, 20) * self.SmokeSize)
				particle:SetRoll(math.rad(math.Rand(0, 360)))
				particle:SetRollDelta(math.Rand(-0.8, 0.8))
				particle:SetLighting(true)
				particle:SetAirResistance(20)
				particle:SetGravity(Vector(0, 0, 60))
				particle:SetColor(255, 255, 255)
			end
		end
	end

	local sparkcount = math.Round(math.random(8, 12) * self.SparkSize)

	for _ = 0, sparkcount do
		local particle = emitter:Add("effects/yellowflare", self.Position)

		if (particle) then
			particle:SetVelocity( VectorRand() * 30 * self.SparkSize)
			particle:SetVelocity(particle:GetVelocity() + 1.15 * AddVel )
			particle:SetVelocity( particle:GetVelocity() + dir * math.Rand(80, 100) * (1-math.abs(math.max(particle:GetVelocity():GetNormalized():Dot(-dir),0))) * self.SparkSize )
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * math.Rand(0.9,1.1))
			particle:SetStartAlpha(255)
			particle:SetEndAlpha(0)
			particle:SetStartSize(0.6)
			particle:SetEndSize(1)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetGravity(vector_origin)
			particle:SetAirResistance(1)
			particle:SetStartLength(0.1)
			particle:SetEndLength(0.05)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, math.random(192, 225), math.random(140, 192))
			end

			particle:SetVelocityScale(true)
			local sl = self.SparkSize

			particle:SetThinkFunction(function(pa)
				math.randomseed(SysTime())
				local spd = pa:GetVelocity():Length()*12
				pa.ranvel = pa.ranvel or VectorRand() * spd
				pa.ranvel:Add(VectorRand() * spd * math.sqrt(FrameTime()))
				pa:SetVelocity(pa:GetVelocity() + pa.ranvel * sl * FrameTime() )
				pa:SetNextThink(CurTime())
			end)

			particle:SetNextThink(CurTime() + 0.01)
		end
	end

	if TFA.GetGasEnabled() then
		local particle = emitter:Add("sprites/heatwave", self.vOffset + dir*2)

		if (particle) then
			particle:SetVelocity(dir * 25 * self.HeatSize + 1.05 * AddVel)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life)
			particle:SetStartAlpha(math.Rand(200, 225))
			particle:SetEndAlpha(0)
			particle:SetStartSize(math.Rand(3, 5) * self.HeatSize)
			particle:SetEndSize(math.Rand(8, 12) * self.HeatSize)
			particle:SetRoll(math.Rand(0, 360))
			particle:SetRollDelta(math.Rand(-2, 2))
			particle:SetAirResistance(5)
			particle:SetGravity(Vector(0, 0, 40))
			particle:SetColor(255, 255, 255)
		end
	end

	emitter:Finish()
end

function EFFECT:Think()
	if CurTime() > (self.DieTime or 0) then
		return false
	elseif self.DLight and IsValid(self.OwnerEnt) then
		self.DLight.pos = self.OwnerEnt:EyePos() + self.OwnerEnt:EyeAngles():Forward() * self.Dist
	end

	return true
end

function EFFECT:Render()
end
--PATH lua/effects/tfa_shell_legacy/init.lua:
local vector_origin = Vector()

function EFFECT:Init(data)
	self.WeaponEnt = data:GetEntity()
	if not IsValid(self.WeaponEnt) then return end
	self.WeaponEntOG = self.WeaponEnt
	self.Attachment = data:GetAttachment()
	self.Dir = data:GetNormal()
	local owent = self.WeaponEnt:GetOwner()

	if not IsValid(owent) then
		owent = self.WeaponEnt:GetParent()
	end

	if IsValid(owent) and owent:IsPlayer() then
		if owent ~= LocalPlayer() or owent:ShouldDrawLocalPlayer() then
			self.WeaponEnt = owent:GetActiveWeapon()
			if not IsValid(self.WeaponEnt) then return end
		else
			local theirweapon = self.WeaponEnt
			self.WeaponEnt = self.WeaponEnt.OwnerViewModel

			if IsValid(theirweapon) and theirweapon.ViewModelFlip or theirweapon.ViewModelFlipped then
				self.Flipped = true
			end

			if not IsValid(self.WeaponEnt) then return end
		end
	end

	if IsValid(self.WeaponEntOG) and self.WeaponEntOG.ShellAttachment then
		self.Attachment = self.WeaponEnt:LookupAttachment(self.WeaponEntOG.ShellAttachment)

		if not self.Attachment or self.Attachment <= 0 then
			self.Attachment = 2
		end

		if self.WeaponEntOG:GetStatL("IsAkimbo") then
			self.Attachment = 4 - self.WeaponEntOG:GetAnimCycle()
		end

		if self.WeaponEntOG.ShellAttachmentRaw then
			self.Attachment = self.WeaponEntOG.ShellAttachmentRaw
		end
	end

	local angpos = self.WeaponEnt:GetAttachment(self.Attachment)

	if not angpos or not angpos.Pos then
		angpos = {
			Pos = vector_origin,
			Ang = angle_zero
		}
	end

	if self.Flipped then
		local tmpang = (self.Dir or angpos.Ang:Forward()):Angle()
		local localang = self.WeaponEnt:WorldToLocalAngles(tmpang)
		localang.y = localang.y + 180
		localang = self.WeaponEnt:LocalToWorldAngles(localang)
		--localang:RotateAroundAxis(localang:Up(),180)
		--tmpang:RotateAroundAxis(tmpang:Up(),180)
		self.Dir = localang:Forward()
	end

	-- Keep the start and end Pos - we're going to interpolate between them
	self.Pos = self:GetTracerShootPos(angpos.Pos, self.WeaponEnt, self.Attachment)
	self.Norm = angpos.Ang:Forward() --angpos.Ang:Forward()
	--print(self.Norm)
	self.Magnitude = data:GetMagnitude()
	self.Scale = data:GetScale()
	local fx = EffectData()
	fx:SetOrigin(self.Pos)
	fx:SetStart(self.Pos)
	fx:SetEntity(self.WeaponEnt)
	fx:SetAttachment(self.Attachment)
	fx:SetNormal(self.Norm)
	fx:SetAngles(self.Norm:Angle())
	fx:SetScale(self.Scale)
	fx:SetMagnitude(self.Magnitude)
	local se = (self.WeaponEntOG.LuaShellEffect or self.WeaponEntOG.Blowback_Shell_Effect) or "ShellEject"
	util.Effect(se, fx)
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end
--PATH lua/effects/tfa_shelleject_smoke/init.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/effects/tfa_tracer_blue/init.lua:
-- Credits: Meeks, Xan, Matsil
EFFECT.Mat = Material("effects/laser_tracer")
EFFECT.Speed = 1024 * 15
EFFECT.TracerLength = 5

local Materials = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

function EFFECT:Init( data )
	self.Position = data:GetStart()
	self.WeaponEnt = data:GetEntity()
	self.Attachment = data:GetAttachment()

	if IsValid(self.WeaponEnt) and self.WeaponEnt.GetMuzzleAttachment then
		self.Attachment = self.WeaponEnt:GetMuzzleAttachment()
	end

	-- Keep the start and end pos - we're going to interpolate between them
    self.StartPos = self:GetTracerShootPos(self.Position, self.WeaponEnt, self.Attachment)
    self.EndPos = data:GetOrigin()

	self.Dir = self.EndPos - self.StartPos

	self:SetRenderBoundsWS( self.StartPos, self.EndPos )

    self.StartTime = 0
	self.TracerTime = math.min( 1, self.StartPos:Distance( self.EndPos ) / 7000 ) * 1
	self.Length = 0.33

	-- Die when it reaches its target
	self.DieTime = CurTime() + self.TracerTime

	local Dir = self.Dir:GetNormalized()

	local emitter = ParticleEmitter( self.StartPos, false )

	for i = 0, 5 do
		local particle = emitter:Add( Materials[math.random(1,table.Count( Materials ))], self.StartPos )

		local rCol = 255

		if particle then
			particle:SetVelocity( Dir * math.Rand(100,500) + VectorRand() * math.Rand(0,10) )
			particle:SetDieTime( math.Rand(0.05,0.2) )
			particle:SetAirResistance( math.Rand(50,100) )
			particle:SetStartAlpha( 5 )
			particle:SetStartSize( 2 )
			particle:SetEndSize( math.Rand(5,10) )
			particle:SetRoll( math.Rand(-1,1) )
			particle:SetColor( rCol, rCol, rCol )
			particle:SetGravity( VectorRand() * 200 + Vector(0,0, -500) )
			particle:SetCollide( false )
		end
	end

	emitter:Finish()
end

local hitColor = Vector(0, 0, 255)

function EFFECT:Think()
    self.StartTime = self.StartTime + FrameTime()

	if CurTime() > self.DieTime then
		local effectdata = EffectData()
			effectdata:SetStart( hitColor )
			effectdata:SetOrigin( self.EndPos )
			effectdata:SetNormal( self.Dir:GetNormalized() )
		util.Effect( "laser_hit", effectdata )

		return false
	end

	return true
end

local mainColor = Color(0, 50, 255)
local innerColor = Color(192, 192, 192)

function EFFECT:Render()
	local fDelta = ( self.DieTime - CurTime() ) / self.TracerTime
	fDelta = math.Clamp( fDelta, 0, 1 ) ^ 2

	local sinWave = math.sin( fDelta * math.pi )

	local Pos1 = self.EndPos - self.Dir * ( fDelta - sinWave * self.Length )

	render.SetMaterial( self.Mat )
	render.DrawBeam( Pos1,
		self.EndPos - self.Dir * ( fDelta + sinWave * self.Length ),
        8, 5, 0, mainColor
    )

	render.DrawBeam( Pos1,
		self.EndPos - self.Dir * ( fDelta + sinWave * self.Length ),
        2, 5, 0, innerColor
    )

    if --[[DynamicTracer:GetBool()]] true then
    local spawn = util.CRC(tostring(self:GetPos()))
    local dlight = DynamicLight(self:EntIndex() + spawn)
    local endDistance = self.Speed * self.StartTime
    local endPos = self.StartPos + self.Dir:GetNormalized() * endDistance

    if (dlight) then
        dlight.pos = endPos
        dlight.r = 0
        dlight.g = 102
        dlight.b = 255
        dlight.brightness = 3
        dlight.Decay = 1000
        dlight.Size = 200
        dlight.DieTime = CurTime() + 3
    end
end
end
--PATH lua/effects/tfa_tracer_fubar/init.lua:
TRACER_FLAG_USEATTACHMENT       = 0x0002;
SOUND_FROM_WORLD                        = 0;
CHAN_STATIC                                     = 6;

EFFECT.InValid = false;

function EFFECT:Init( data )	

		self.Position = data:GetStart()
		self.WeaponEnt = data:GetEntity()
		self.Attachment = data:GetAttachment()
		
		-- Keep the start and end pos - we're going to interpolate between them
		self.StartPos = self:GetTracerShootPos( self.Position, self.WeaponEnt, self.Attachment )
		
        self.EndPos = data:GetOrigin()
		
        util.ParticleTracerEx("weapon_fubar_trail", self.StartPos, self.EndPos, false, self:EntIndex(), self.Attachment)

end

function EFFECT:Think()
 
        return false
 
end

function EFFECT:Render()
		
		if self.InValid then return false end
		
end
--PATH lua/effects/tfa_tracer_fubar_light/init.lua:
TRACER_FLAG_USEATTACHMENT       = 0x0002;
SOUND_FROM_WORLD                        = 0;
CHAN_STATIC                                     = 6;

EFFECT.InValid = false;

function EFFECT:Init( data )	

		self.Position = data:GetStart()
		self.WeaponEnt = data:GetEntity()
		self.Attachment = data:GetAttachment()
		
		-- Keep the start and end pos - we're going to interpolate between them
		self.StartPos = self:GetTracerShootPos( self.Position, self.WeaponEnt, self.Attachment )
		
        self.EndPos = data:GetOrigin()
		
        util.ParticleTracerEx("weapon_fubar_beam", self.StartPos, self.EndPos, false, self:EntIndex(), self.Attachment)

end

function EFFECT:Think()
 
        return false
 
end

function EFFECT:Render()
		
		if self.InValid then return false end
		
end
--PATH addons/[bronie] republic-essentials-v2d/lua/effects/tfa_tracer_green/init.lua:
-- Credits: Meeks, Xan, Matsil
EFFECT.Mat = Material("effects/laser_tracer")
EFFECT.Speed = 1024 * 15
EFFECT.TracerLength = 5

local Materials = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

function EFFECT:Init( data )
	self.Position = data:GetStart()
	self.WeaponEnt = data:GetEntity()
	self.Attachment = data:GetAttachment()

	if IsValid(self.WeaponEnt) and self.WeaponEnt.GetMuzzleAttachment then
		self.Attachment = self.WeaponEnt:GetMuzzleAttachment()
	end

	-- Keep the start and end pos - we're going to interpolate between them
    self.StartPos = self:GetTracerShootPos(self.Position, self.WeaponEnt, self.Attachment)
    self.EndPos = data:GetOrigin()

	self.Dir = self.EndPos - self.StartPos

	self:SetRenderBoundsWS( self.StartPos, self.EndPos )

    self.StartTime = 0
	self.TracerTime = math.min( 1, self.StartPos:Distance( self.EndPos ) / 7000 ) * 1
	self.Length = 0.33

	-- Die when it reaches its target
	self.DieTime = CurTime() + self.TracerTime

	local Dir = self.Dir:GetNormalized()

	local emitter = ParticleEmitter( self.StartPos, false )

	for i = 0, 5 do
		local particle = emitter:Add( Materials[math.random(1,table.Count( Materials ))], self.StartPos )

		local rCol = 255

		if particle then
			particle:SetVelocity( Dir * math.Rand(100,500) + VectorRand() * math.Rand(0,10) )
			particle:SetDieTime( math.Rand(0.05,0.2) )
			particle:SetAirResistance( math.Rand(50,100) )
			particle:SetStartAlpha( 5 )
			particle:SetStartSize( 2 )
			particle:SetEndSize( math.Rand(5,10) )
			particle:SetRoll( math.Rand(-1,1) )
			particle:SetColor( rCol, rCol, rCol )
			particle:SetGravity( VectorRand() * 200 + Vector(0,0, -500) )
			particle:SetCollide( false )
		end
	end

	emitter:Finish()
end

local hitColor = Vector(0, 255, 0)

function EFFECT:Think()
    self.StartTime = self.StartTime + FrameTime()

	if CurTime() > self.DieTime then
		local effectdata = EffectData()
			effectdata:SetStart( hitColor )
			effectdata:SetOrigin( self.EndPos )
			effectdata:SetNormal( self.Dir:GetNormalized() )
		util.Effect( "laser_hit", effectdata )

		return false
	end

	return true
end

local mainColor = Color(0, 255, 40)
local innerColor = Color(192, 192, 192)

function EFFECT:Render()
	local fDelta = ( self.DieTime - CurTime() ) / self.TracerTime
	fDelta = math.Clamp( fDelta, 0, 1 ) ^ 2

	local sinWave = math.sin( fDelta * math.pi )

	local Pos1 = self.EndPos - self.Dir * ( fDelta - sinWave * self.Length )

	render.SetMaterial( self.Mat )
	render.DrawBeam( Pos1,
		self.EndPos - self.Dir * ( fDelta + sinWave * self.Length ),
        8, 5, 0, mainColor
    )

	render.DrawBeam( Pos1,
		self.EndPos - self.Dir * ( fDelta + sinWave * self.Length ),
        2, 5, 0, innerColor
    )

    if --[[DynamicTracer:GetBool()]] true then
    local spawn = util.CRC(tostring(self:GetPos()))
    local dlight = DynamicLight(self:EntIndex() + spawn)
    local endDistance = self.Speed * self.StartTime
    local endPos = self.StartPos + self.Dir:GetNormalized() * endDistance

    if (dlight) then
        dlight.pos = endPos
        dlight.r = 0
        dlight.g = 255
        dlight.b = 0
        dlight.brightness = 3
        dlight.Decay = 1000
        dlight.Size = 200
        dlight.DieTime = CurTime() + 3
    end
end
end
--PATH addons/[bronie] republic-essentials-v2d/lua/effects/tfa_tracer_orange/init.lua:
EFFECT.Mat = Material("effects/laser_tracer")
EFFECT.Speed = 1024 * 15
EFFECT.TracerLength = 5

local Materials = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

function EFFECT:Init( data )
	self.Position = data:GetStart()
	self.WeaponEnt = data:GetEntity()
	self.Attachment = data:GetAttachment()

	if IsValid(self.WeaponEnt) and self.WeaponEnt.GetMuzzleAttachment then
		self.Attachment = self.WeaponEnt:GetMuzzleAttachment()
	end

	-- Keep the start and end pos - we're going to interpolate between them
    self.StartPos = self:GetTracerShootPos(self.Position, self.WeaponEnt, self.Attachment)
    self.EndPos = data:GetOrigin()

	self.Dir = self.EndPos - self.StartPos

	self:SetRenderBoundsWS( self.StartPos, self.EndPos )

    self.StartTime = 0
	self.TracerTime = math.min( 1, self.StartPos:Distance( self.EndPos ) / 7000 ) * 1
	self.Length = 0.33

	-- Die when it reaches its target
	self.DieTime = CurTime() + self.TracerTime

	local Dir = self.Dir:GetNormalized()

	local emitter = ParticleEmitter( self.StartPos, false )

	for i = 0, 5 do
		local particle = emitter:Add( Materials[math.random(1,table.Count( Materials ))], self.StartPos )

		local rCol = 255

		if particle then
			particle:SetVelocity( Dir * math.Rand(100,500) + VectorRand() * math.Rand(0,10) )
			particle:SetDieTime( math.Rand(0.05,0.2) )
			particle:SetAirResistance( math.Rand(50,100) )
			particle:SetStartAlpha( 5 )
			particle:SetStartSize( 2 )
			particle:SetEndSize( math.Rand(5,10) )
			particle:SetRoll( math.Rand(-1,1) )
			particle:SetColor( rCol, rCol, rCol )
			particle:SetGravity( VectorRand() * 200 + Vector(0,0, -500) )
			particle:SetCollide( false )
		end
	end

	emitter:Finish()
end

local hitColor = Vector(255, 140, 0)

function EFFECT:Think()
    self.StartTime = self.StartTime + FrameTime()

	if CurTime() > self.DieTime then
		local effectdata = EffectData()
			effectdata:SetStart( hitColor )
			effectdata:SetOrigin( self.EndPos )
			effectdata:SetNormal( self.Dir:GetNormalized() )
		util.Effect( "laser_hit", effectdata )

		return false
	end

	return true
end

local mainColor = Color(255, 120, 0)
local innerColor = Color(192, 192, 192)

function EFFECT:Render()
	local fDelta = ( self.DieTime - CurTime() ) / self.TracerTime
	fDelta = math.Clamp( fDelta, 0, 1 ) ^ 2

	local sinWave = math.sin( fDelta * math.pi )

	local Pos1 = self.EndPos - self.Dir * ( fDelta - sinWave * self.Length )

	render.SetMaterial( self.Mat )
	render.DrawBeam( Pos1,
		self.EndPos - self.Dir * ( fDelta + sinWave * self.Length ),
        8, 5, 0, mainColor
    )

	render.DrawBeam( Pos1,
		self.EndPos - self.Dir * ( fDelta + sinWave * self.Length ),
        2, 5, 0, innerColor
    )

    if --[[DynamicTracer:GetBool()]] true then
    local spawn = util.CRC(tostring(self:GetPos()))
    local dlight = DynamicLight(self:EntIndex() + spawn)
    local endDistance = self.Speed * self.StartTime
    local endPos = self.StartPos + self.Dir:GetNormalized() * endDistance

    if (dlight) then
        dlight.pos = endPos
        dlight.r = 255
        dlight.g = 165
        dlight.b = 0
        dlight.brightness = 3
        dlight.Decay = 1000
        dlight.Size = 300
        dlight.DieTime = CurTime() + 3
    end
end
end
--PATH addons/[bronie] republic-essentials-v2d/lua/effects/tracer_green/init.lua:
-- Credits: Meeks, Xan, Matsil
EFFECT.Mat = Material("effects/laser_tracer")
EFFECT.Speed = 1024 * 15
EFFECT.TracerLength = 5

local Materials = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

function EFFECT:Init( data )
	self.Position = data:GetStart()
	self.WeaponEnt = data:GetEntity()
	self.Attachment = data:GetAttachment()

	if IsValid(self.WeaponEnt) and self.WeaponEnt.GetMuzzleAttachment then
		self.Attachment = self.WeaponEnt:GetMuzzleAttachment()
	end

	-- Keep the start and end pos - we're going to interpolate between them
    self.StartPos = self:GetTracerShootPos(self.Position, self.WeaponEnt, self.Attachment)
    self.EndPos = data:GetOrigin()

	self.Dir = self.EndPos - self.StartPos

	self:SetRenderBoundsWS( self.StartPos, self.EndPos )

    self.StartTime = 0
	self.TracerTime = math.min( 1, self.StartPos:Distance( self.EndPos ) / 7000 ) * 1
	self.Length = 0.33

	-- Die when it reaches its target
	self.DieTime = CurTime() + self.TracerTime

	local Dir = self.Dir:GetNormalized()

	local emitter = ParticleEmitter( self.StartPos, false )

	for i = 0, 5 do
		local particle = emitter:Add( Materials[math.random(1,table.Count( Materials ))], self.StartPos )

		local rCol = 255

		if particle then
			particle:SetVelocity( Dir * math.Rand(100,500) + VectorRand() * math.Rand(0,10) )
			particle:SetDieTime( math.Rand(0.05,0.2) )
			particle:SetAirResistance( math.Rand(50,100) )
			particle:SetStartAlpha( 5 )
			particle:SetStartSize( 2 )
			particle:SetEndSize( math.Rand(5,10) )
			particle:SetRoll( math.Rand(-1,1) )
			particle:SetColor( rCol, rCol, rCol )
			particle:SetGravity( VectorRand() * 200 + Vector(0,0, -500) )
			particle:SetCollide( false )
		end
	end

	emitter:Finish()
end

local hitColor = Vector(0, 255, 0)

function EFFECT:Think()
    self.StartTime = self.StartTime + FrameTime()

	if CurTime() > self.DieTime then
		local effectdata = EffectData()
			effectdata:SetStart( hitColor )
			effectdata:SetOrigin( self.EndPos )
			effectdata:SetNormal( self.Dir:GetNormalized() )
		util.Effect( "laser_hit", effectdata )

		return false
	end

	return true
end

local mainColor = Color(0, 255, 40)
local innerColor = Color(192, 192, 192)

function EFFECT:Render()
	local fDelta = ( self.DieTime - CurTime() ) / self.TracerTime
	fDelta = math.Clamp( fDelta, 0, 1 ) ^ 2

	local sinWave = math.sin( fDelta * math.pi )

	local Pos1 = self.EndPos - self.Dir * ( fDelta - sinWave * self.Length )

	render.SetMaterial( self.Mat )
	render.DrawBeam( Pos1,
		self.EndPos - self.Dir * ( fDelta + sinWave * self.Length ),
        8, 5, 0, mainColor
    )

	render.DrawBeam( Pos1,
		self.EndPos - self.Dir * ( fDelta + sinWave * self.Length ),
        2, 5, 0, innerColor
    )

    if --[[DynamicTracer:GetBool()]] true then
    local spawn = util.CRC(tostring(self:GetPos()))
    local dlight = DynamicLight(self:EntIndex() + spawn)
    local endDistance = self.Speed * self.StartTime
    local endPos = self.StartPos + self.Dir:GetNormalized() * endDistance

    if (dlight) then
        dlight.pos = endPos
        dlight.r = 0
        dlight.g = 255
        dlight.b = 0
        dlight.brightness = 7
        dlight.Decay = 1000
        dlight.Size = 500
        dlight.DieTime = CurTime() + 3
    end
end
end
--PATH addons/[bronie] republic-essentials-v2d/lua/effects/tracer_orange/init.lua:
EFFECT.Mat = Material("effects/laser_tracer")
EFFECT.Speed = 1024 * 15
EFFECT.TracerLength = 5

local Materials = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

function EFFECT:Init( data )
	self.Position = data:GetStart()
	self.WeaponEnt = data:GetEntity()
	self.Attachment = data:GetAttachment()

	if IsValid(self.WeaponEnt) and self.WeaponEnt.GetMuzzleAttachment then
		self.Attachment = self.WeaponEnt:GetMuzzleAttachment()
	end

	-- Keep the start and end pos - we're going to interpolate between them
    self.StartPos = self:GetTracerShootPos(self.Position, self.WeaponEnt, self.Attachment)
    self.EndPos = data:GetOrigin()

	self.Dir = self.EndPos - self.StartPos

	self:SetRenderBoundsWS( self.StartPos, self.EndPos )

    self.StartTime = 0
	self.TracerTime = math.min( 1, self.StartPos:Distance( self.EndPos ) / 7000 ) * 1
	self.Length = 0.33

	-- Die when it reaches its target
	self.DieTime = CurTime() + self.TracerTime

	local Dir = self.Dir:GetNormalized()

	local emitter = ParticleEmitter( self.StartPos, false )

	for i = 0, 5 do
		local particle = emitter:Add( Materials[math.random(1,table.Count( Materials ))], self.StartPos )

		local rCol = 255

		if particle then
			particle:SetVelocity( Dir * math.Rand(100,500) + VectorRand() * math.Rand(0,10) )
			particle:SetDieTime( math.Rand(0.05,0.2) )
			particle:SetAirResistance( math.Rand(50,100) )
			particle:SetStartAlpha( 5 )
			particle:SetStartSize( 2 )
			particle:SetEndSize( math.Rand(5,10) )
			particle:SetRoll( math.Rand(-1,1) )
			particle:SetColor( rCol, rCol, rCol )
			particle:SetGravity( VectorRand() * 200 + Vector(0,0, -500) )
			particle:SetCollide( false )
		end
	end

	emitter:Finish()
end

local hitColor = Vector(255, 140, 0)

function EFFECT:Think()
    self.StartTime = self.StartTime + FrameTime()

	if CurTime() > self.DieTime then
		local effectdata = EffectData()
			effectdata:SetStart( hitColor )
			effectdata:SetOrigin( self.EndPos )
			effectdata:SetNormal( self.Dir:GetNormalized() )
		util.Effect( "laser_hit", effectdata )

		return false
	end

	return true
end

local mainColor = Color(255, 120, 0)
local innerColor = Color(192, 192, 192)

function EFFECT:Render()
	local fDelta = ( self.DieTime - CurTime() ) / self.TracerTime
	fDelta = math.Clamp( fDelta, 0, 1 ) ^ 2

	local sinWave = math.sin( fDelta * math.pi )

	local Pos1 = self.EndPos - self.Dir * ( fDelta - sinWave * self.Length )

	render.SetMaterial( self.Mat )
	render.DrawBeam( Pos1,
		self.EndPos - self.Dir * ( fDelta + sinWave * self.Length ),
        8, 5, 0, mainColor
    )

	render.DrawBeam( Pos1,
		self.EndPos - self.Dir * ( fDelta + sinWave * self.Length ),
        2, 5, 0, innerColor
    )

    if --[[DynamicTracer:GetBool()]] true then
    local spawn = util.CRC(tostring(self:GetPos()))
    local dlight = DynamicLight(self:EntIndex() + spawn)
    local endDistance = self.Speed * self.StartTime
    local endPos = self.StartPos + self.Dir:GetNormalized() * endDistance

    if (dlight) then
        dlight.pos = endPos
        dlight.r = 255
        dlight.g = 165
        dlight.b = 0
        dlight.brightness = 7
        dlight.Decay = 1000
        dlight.Size = 500
        dlight.DieTime = CurTime() + 3
    end
end
end
--PATH lua/effects/train_light.lua:
return gluapack()()
--PATH lua/effects/fxbase.lua:
-- based on nomad's tracer by Chad Barrett --
-- edited for the use with SciFiWeapons by Darken217 --

AddCSLuaFile()
if ( CLIENT ) then
TRACER_FLAG_USEATTACHMENT	= 0x0002
end
EFFECT.Speed	= 6500
EFFECT.Length	= 64
EFFECT.Normal 	= Vector( 0, 0, 0 )

function EFFECT:GetTracerOrigin( data )
	if ( CLIENT ) then
		local vOrigin = data:GetStart()

		if ( bit.band( data:GetFlags(), TRACER_FLAG_USEATTACHMENT ) == TRACER_FLAG_USEATTACHMENT ) then
			local entParent = data:GetEntity()
			
			if ( !IsValid( entParent ) ) then 
				return vOrigin 
			end
			
			if ( !game.SinglePlayer() && entParent:IsEFlagSet( EFL_DORMANT ) ) then 
				return vOrigin 
			end
			
			if( entParent:IsWeapon() && entParent:IsCarriedByLocalPlayer() ) then
				local entPlayer = entParent:GetOwner()
				if ( IsValid( entPlayer ) ) then
					local entViewModel = entPlayer:GetViewModel()
					if ( IsValid( entViewModel ) && !LocalPlayer():ShouldDrawLocalPlayer() ) then
						entParent = entViewModel
					else 					
						if ( entParent.WorldModel ) then
							entParent:SetModel( entParent.WorldModel )
						end
					end
				end
			end

			local attachment = entParent:GetAttachment( data:GetAttachment() )
			if ( attachment ) then
				vOrigin = attachment.Pos
			end

		end
		
		return vOrigin
	end
end

function EFFECT:Init( data )

	self.StartPos = self:GetTracerOrigin( data )
	self.EndPos = data:GetOrigin()
	self.Parent = data:GetEntity()
	
--	self.Entity:SetRenderBoundsWS( self.StartPos, self.EndPos )

	local diff = ( self.EndPos - self.StartPos )
	
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	
	if ( !self.LifeTime ) then
		self.LifeTime = ( diff:Length() + self.Length ) / self.Speed
	else
		self.LifeTime = CurTime() + self.LifeTime
	end
	
end

function EFFECT:Think()

	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()
	
	return self.LifeTime > 0

end

function EFFECT:Render()

	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	
	startDistance = math.max( 0, startDistance )
	endDistance = math.max( 0, endDistance )

	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	
end
--PATH lua/effects/vj_small_explosion1/init.lua:
return gluapack()()
--PATH lua/effects/vj_small_explosion1/init.lua:
if (!file.Exists("autorun/vj_base_autorun.lua","LUA")) then return end
/*--------------------------------------------------
	*** Copyright (c) 2012-2023 by DrVrej, All rights reserved. ***
	No parts of this code or any of its contents may be reproduced, copied, modified or adapted,
	without the prior written consent of the author, unless otherwise indicated for stand-alone materials.
--------------------------------------------------*/
function EFFECT:Init(data)
	self.Pos = data:GetOrigin()
	local Emitter = ParticleEmitter(self.Pos)
	if Emitter == nil then return end
	
	-- Fire
	for _ = 1, 3 do
		local EffectCode = Emitter:Add("particles/flamelet1",self.Pos)
		EffectCode:SetVelocity(Vector(math.random(-30,30),math.random(-30,30),math.random(30,40)))
		EffectCode:SetDieTime(math.Rand(0.4,0.6)) -- How much time until it dies
		EffectCode:SetStartAlpha(math.Rand(90,100)) -- Transparency
		EffectCode:SetStartSize(math.Rand(60,80)) -- Size of the effect
		EffectCode:SetEndSize(math.Rand(100,100)) -- Size of the effect at the end (The effect slowly trasnsforms to this size)
		EffectCode:SetRoll(math.Rand(480,540))
		EffectCode:SetRollDelta(math.Rand(0,0)) -- How fast it rolls
		EffectCode:SetColor(255,255,255) -- The color of the effect
		EffectCode:SetGravity(Vector(0,0,math.random(-30,-10))) -- The Gravity
	end

	-- Smoke screen
	for _ = 1, 5 do
		local EffectCode = Emitter:Add("particles/smokey",self.Pos)
		EffectCode:SetVelocity(Vector(math.random(-40,40),math.random(-40,40),math.random(5,15)))
		EffectCode:SetDieTime(math.Rand(7,9)) -- How much time until it dies
		EffectCode:SetStartAlpha(math.Rand(200,230)) -- Transparency
		EffectCode:SetStartSize(math.Rand(80,100)) -- Size of the effect
		EffectCode:SetEndSize(math.Rand(130,150)) -- Size of the effect at the end (The effect slowly trasnsforms to this size)
		EffectCode:SetRoll(math.Rand(480,540))
		EffectCode:SetRollDelta(math.Rand(-0.2,0.2)) -- How fast it rolls
		EffectCode:SetColor(50,50,50) -- The color of the effect
		EffectCode:SetGravity(Vector(0, 0, 0)) -- The Gravity
		EffectCode:SetAirResistance(15)
	end

	-- Cloud of smoke that goes up
	for _ = 1, 5 do
		local EffectCode = Emitter:Add("particles/smokey",self.Pos)
		EffectCode:SetVelocity(Vector(math.random(-60,70),math.random(-60,70),math.random(70,100)))
		EffectCode:SetDieTime(math.Rand(3,4)) -- How much time until it dies
		EffectCode:SetStartAlpha(math.Rand(150,190)) -- Transparency
		EffectCode:SetStartSize(math.Rand(80,100)) -- Size of the effect
		EffectCode:SetEndSize(math.Rand(130,150)) -- Size of the effect at the end (The effect slowly trasnsforms to this size)
		EffectCode:SetRoll(math.Rand(480,540))
		EffectCode:SetRollDelta(math.Rand(-1,1)) -- How fast it rolls
		EffectCode:SetColor(50,50,50) -- The color of the effect
		EffectCode:SetGravity(Vector(0,0,math.random(-30,-10))) -- The Gravity
	end
	Emitter:Finish()
end
---------------------------------------------------------------------------------------------------------------------------------------------
function EFFECT:Think()
	return false
end
---------------------------------------------------------------------------------------------------------------------------------------------
function EFFECT:Render()
end
--PATH lua/effects/vj_weapon_playermuzzle/init.lua:
return gluapack()()
--PATH lua/effects/vj_weapon_playermuzzle/init.lua:
if (!file.Exists("autorun/vj_base_autorun.lua","LUA")) then return end
/*--------------------------------------------------
	*** Copyright (c) 2012-2023 by DrVrej, All rights reserved. ***
	No parts of this code or any of its contents may be reproduced, copied, modified or adapted,
	without the prior written consent of the author, unless otherwise indicated for stand-alone materials.
--------------------------------------------------*/
function EFFECT:Init(data)
	local ent = data:GetEntity()
	if !IsValid(ent) then return end
	local owner = ent:GetOwner()
	if !IsValid(owner) then return end
	local muzEnt = ((owner != LocalPlayer()) or owner:ShouldDrawLocalPlayer()) && ent or owner:GetViewModel()
			--  (if the owner isn't the local player OR the owner is in third person, then use world model) OR (Use the owner's viewmodel)
	ParticleEffectAttach(VJ_PICK(ent.PrimaryEffects_MuzzleParticles), PATTACH_POINT, muzEnt, data:GetAttachment())

	-- Muzzle Flash
/*
	self.Pos = self:GetTracerShootPos(data:GetOrigin(),data:GetEntity(),data:GetAttachment())
	local Emitter = ParticleEmitter(self.Pos)
	if Emitter == nil then return end
	
	local LocalPlayerMagnitude = 0
	if IsValid(data:GetEntity()) && IsValid(data:GetEntity():GetOwner()) && data:GetEntity():GetOwner():IsPlayer() && data:GetEntity().Owner == LocalPlayer() then
		LocalPlayerMagnitude = data:GetMagnitude() else
		LocalPlayerMagnitude = 0
	end
	
	if GetConVarNumber("vj_wep_nomuszzleflash") == 0 && IsValid(data:GetEntity()) then
	for i = 1,3 do //4
		local EffectCode = Emitter:Add("effects/muzzleflash"..math.random(1,4),self.Pos + LocalPlayerMagnitude * data:GetNormal())
		EffectCode:SetVelocity(data:GetNormal() + 1.1 * data:GetEntity():GetOwner():GetVelocity())
		//EffectCode:SetAirResistance(200)
		EffectCode:SetDieTime(math.Rand(0.05,0.05)) -- How much time until it dies
		EffectCode:SetStartAlpha(math.Rand(200,255)) -- Transparency
		EffectCode:SetStartSize(math.Rand(5,6)) -- Size of the effect
		EffectCode:SetEndSize(math.Rand(16,20)) -- Size of the effect at the end (The effect slowly trasnsforms to this size)
		EffectCode:SetRoll(math.Rand(480,540))
		EffectCode:SetRollDelta(math.Rand(-1,1)) -- How fast it rolls
		EffectCode:SetColor(255,255,255) -- The color of the effect
		//EffectCode:SetGravity(Vector(0,0,100)) -- The Gravity
		end
		local EffectCode = Emitter:Add("effects/yellowflare", self.Pos)
		EffectCode:SetVelocity(data:GetNormal() + 1.1 * data:GetEntity():GetOwner():GetVelocity())
		EffectCode:SetAirResistance(160)
		EffectCode:SetDieTime(0.05)
		EffectCode:SetStartAlpha(255)
		EffectCode:SetEndAlpha(0)
		EffectCode:SetStartSize(.5)
		EffectCode:SetEndSize(15)
		EffectCode:SetRoll(math.Rand(180, 480))
		EffectCode:SetRollDelta(math.Rand(-1, 1))
		EffectCode:SetColor(255, 255, 255)
	end

	-- Heat wave
	if GetConVarNumber("vj_wep_nomuzzleheatwave") == 0 && IsValid(data:GetEntity()) then
		local EffectCode = Emitter:Add("sprites/heatwave",self.Pos + LocalPlayerMagnitude * data:GetNormal())
		EffectCode:SetVelocity(data:GetNormal() + 1.1 * data:GetEntity():GetOwner():GetVelocity())
		EffectCode:SetDieTime(math.Rand(0.15,0.2)) -- How much time until it dies
		//EffectCode:SetStartAlpha(math.Rand(90,100)) -- Transparency
		EffectCode:SetStartSize(math.Rand(7,9)) -- Size of the effect
		EffectCode:SetEndSize(math.Rand(4,6)) -- Size of the effect at the end (The effect slowly trasnsforms to this size)
		EffectCode:SetRoll(math.Rand(480,540))
		EffectCode:SetRollDelta(math.Rand(-1,1)) -- How fast it rolls
		//EffectCode:SetColor(255,255,255) -- The color of the effect
		//EffectCode:SetGravity(Vector(0,0,100)) -- The Gravity
	end

	-- Smoke
	if GetConVarNumber("vj_wep_nomuszzlesmoke") == 0 && IsValid(data:GetEntity()) then
	local smokeinum = 2
	if IsValid(data:GetEntity():GetOwner()) then
		if data:GetEntity():GetOwner():IsNPC() then smokeinum = 1 else smokeinum = 2 end
	end
	local smokediet = 0.5,0.5
	if IsValid(data:GetEntity():GetOwner()) then
		if data:GetEntity():GetOwner():IsNPC() then smokediet = 0.2,0.2 else smokediet = 0.4,0.4 end
	end
	for i = 1,smokeinum do //4
		local EffectCode = Emitter:Add("particles/smokey",self.Pos + LocalPlayerMagnitude * data:GetNormal())
		EffectCode:SetVelocity(data:GetNormal() + Vector(math.random(-30,30),math.random(-30,30),math.random(-30,30)))
		EffectCode:SetDieTime(math.Rand(smokediet,smokediet)) -- How much time until it dies
		EffectCode:SetStartAlpha(math.Rand(40,60)) -- Transparency
		EffectCode:SetEndAlpha(0) -- Transparency
		EffectCode:SetStartSize(math.Rand(2,3)) -- Size of the effect
		EffectCode:SetEndSize(math.Rand(13,15)) -- Size of the effect at the end (The effect slowly trasnsforms to this size)
		EffectCode:SetRoll(math.Rand(480,540))
		EffectCode:SetRollDelta(math.Rand(-1,1)) -- How fast it rolls
		EffectCode:SetColor(150,150,150) -- The color of the effect
		//EffectCode:SetGravity(Vector(0,0,math.random(-30,-10))) -- The Gravity
		EffectCode:SetAirResistance(300)
		end
	end

	if GetConVarNumber("vj_wep_nomuszzleflash") == 0 && IsValid(data:GetEntity()) then
  	if IsValid(data:GetEntity():GetOwner()) then
	 if data:GetEntity():GetOwner():IsPlayer() then
	  for i = 1,4 do
		local EffectCode = Emitter:Add("effects/yellowflare",self.Pos)
		EffectCode:SetVelocity((data:GetNormal() + VectorRand() * 0.5) * math.Rand(150, 200))
		EffectCode:SetDieTime(math.Rand(0.5, 0.8))
		EffectCode:SetStartAlpha(255)
		EffectCode:SetStartSize(.5)
		EffectCode:SetEndSize(2)
		EffectCode:SetRoll(0)
		EffectCode:SetGravity(Vector(0, 0, -1))
		EffectCode:SetBounce(.8)
		EffectCode:SetAirResistance(400)
		EffectCode:SetStartLength(0.01)
		EffectCode:SetEndLength(0)
		EffectCode:SetVelocityScale(true)
		EffectCode:SetCollide(false)
		end
	 end
	end
  end
Emitter:Finish()*/

	-- Small Smoke
	/*for i = 1,4 do
		local EffectCode = Emitter:Add("particle/particle_smokegrenade",self.Pos)
		EffectCode:SetVelocity(Vector(math.random(-30,30),math.random(-30,30),math.random(20,30)))
		EffectCode:SetAirResistance(200)
		EffectCode:SetDieTime(math.Rand(0.5,1)) -- How much time until it dies
		EffectCode:SetStartAlpha(math.Rand(100,150)) -- Transparency
		EffectCode:SetStartSize(math.Rand(3,4)) -- Size of the effect
		EffectCode:SetEndSize(math.Rand(6,8)) -- Size of the effect at the end (The effect slowly trasnsforms to this size)
		EffectCode:SetRoll(math.Rand(480,540))
		EffectCode:SetRollDelta(math.Rand(-1,1)) -- How fast it rolls
		EffectCode:SetColor(255,255,255) -- The color of the effect
		//EffectCode:SetGravity(Vector(0,0,100)) -- The Gravity
	end*/
		//local EffectCode = Emitter:Add("effects/muzzleflash"..math.random(1,4),self.Pos + LocalPlayerMagnitude * data:GetNormal())
		//EffectCode:SetVelocity(data:GetNormal() + 1.1 * data:GetEntity():GetOwner():GetVelocity())
		
  /*
    		local EffectCode = Emitter:Add("effects/muzzleflare_01",self.Pos + LocalPlayerMagnitude * data:GetNormal())
		EffectCode:SetVelocity(data:GetNormal() + 1.1 * data:GetEntity():GetOwner():GetVelocity())
		//EffectCode:SetAirResistance(200)
		EffectCode:SetDieTime(math.Rand(0.05,0.05)) -- How much time until it dies
		EffectCode:SetStartAlpha(math.Rand(200,255)) -- Transparency
		EffectCode:SetStartSize(math.Rand(5,6)) -- Size of the effect
		EffectCode:SetEndSize(math.Rand(16,20)) -- Size of the effect at the end (The effect slowly trasnsforms to this size)
		EffectCode:SetRoll(math.Rand(480,540))
		EffectCode:SetRollDelta(math.Rand(-1,1)) -- How fast it rolls
		EffectCode:SetColor(245,164,53) -- The color of the effect
		//EffectCode:SetGravity(Vector(0,0,100)) -- The Gravity

 		local EffectCode = Emitter:Add("effects/muzzlestarlarge_01",self.Pos + LocalPlayerMagnitude * data:GetNormal())
		EffectCode:SetVelocity(data:GetNormal() + 1.1 * data:GetEntity():GetOwner():GetVelocity())
		//EffectCode:SetAirResistance(200)
		EffectCode:SetDieTime(math.Rand(0.05,0.05)) -- How much time until it dies
		EffectCode:SetStartAlpha(math.Rand(200,255)) -- Transparency
		EffectCode:SetStartSize(math.Rand(5,6)) -- Size of the effect
		EffectCode:SetEndSize(math.Rand(16,20)) -- Size of the effect at the end (The effect slowly trasnsforms to this size)
		EffectCode:SetRoll(math.Rand(480,540))
		EffectCode:SetRollDelta(math.Rand(-1,1)) -- How fast it rolls
		EffectCode:SetColor(248,241,200) -- The color of the effect
		//EffectCode:SetGravity(Vector(0,0,100)) -- The Gravity

		local EffectCode = Emitter:Add("particle/bm_whispysmoke_001",self.Pos + LocalPlayerMagnitude * data:GetNormal())
		EffectCode:SetVelocity(data:GetNormal() + Vector(math.random(-30,30),math.random(-30,30),math.random(-30,30)))
		EffectCode:SetDieTime(math.Rand(0.5,0.5)) -- How much time until it dies
		EffectCode:SetStartAlpha(math.Rand(40,60)) -- Transparency
		EffectCode:SetEndAlpha(0) -- Transparency
		EffectCode:SetStartSize(math.Rand(2,3)) -- Size of the effect
		EffectCode:SetEndSize(math.Rand(13,15)) -- Size of the effect at the end (The effect slowly trasnsforms to this size)
		EffectCode:SetRoll(math.Rand(480,540))
		EffectCode:SetRollDelta(math.Rand(-1,1)) -- How fast it rolls
		EffectCode:SetColor(255,255,255) -- The color of the effect
		//EffectCode:SetGravity(Vector(0,0,math.random(-30,-10))) -- The Gravity
		EffectCode:SetAirResistance(300)
  */
end
---------------------------------------------------------------------------------------------------------------------------------------------
function EFFECT:Think()
	return false
end
---------------------------------------------------------------------------------------------------------------------------------------------
function EFFECT:Render()
end

--PATH lua/effects/vp_dissolve.lua:
return gluapack()()
--PATH lua/effects/fxbase.lua:
return gluapack()()
--PATH lua/effects/fxbase.lua:
-- based on nomad's tracer by Chad Barrett --
-- edited for the use with SciFiWeapons by Darken217 --

AddCSLuaFile()
if ( CLIENT ) then
TRACER_FLAG_USEATTACHMENT	= 0x0002
end
EFFECT.Speed	= 6500
EFFECT.Length	= 64
EFFECT.Normal 	= Vector( 0, 0, 0 )

function EFFECT:GetTracerOrigin( data )
	if ( CLIENT ) then
		local vOrigin = data:GetStart()

		if ( bit.band( data:GetFlags(), TRACER_FLAG_USEATTACHMENT ) == TRACER_FLAG_USEATTACHMENT ) then
			local entParent = data:GetEntity()
			
			if ( !IsValid( entParent ) ) then 
				return vOrigin 
			end
			
			if ( !game.SinglePlayer() && entParent:IsEFlagSet( EFL_DORMANT ) ) then 
				return vOrigin 
			end
			
			if( entParent:IsWeapon() && entParent:IsCarriedByLocalPlayer() ) then
				local entPlayer = entParent:GetOwner()
				if ( IsValid( entPlayer ) ) then
					local entViewModel = entPlayer:GetViewModel()
					if ( IsValid( entViewModel ) && !LocalPlayer():ShouldDrawLocalPlayer() ) then
						entParent = entViewModel
					else 					
						if ( entParent.WorldModel ) then
							entParent:SetModel( entParent.WorldModel )
						end
					end
				end
			end

			local attachment = entParent:GetAttachment( data:GetAttachment() )
			if ( attachment ) then
				vOrigin = attachment.Pos
			end

		end
		
		return vOrigin
	end
end

function EFFECT:Init( data )

	self.StartPos = self:GetTracerOrigin( data )
	self.EndPos = data:GetOrigin()
	self.Parent = data:GetEntity()
	
--	self.Entity:SetRenderBoundsWS( self.StartPos, self.EndPos )

	local diff = ( self.EndPos - self.StartPos )
	
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	
	if ( !self.LifeTime ) then
		self.LifeTime = ( diff:Length() + self.Length ) / self.Speed
	else
		self.LifeTime = CurTime() + self.LifeTime
	end
	
end

function EFFECT:Think()

	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()
	
	return self.LifeTime > 0

end

function EFFECT:Render()

	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	
	startDistance = math.max( 0, startDistance )
	endDistance = math.max( 0, endDistance )

	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	
end
--PATH addons/[tfres] frest_levels/lua/fstands2/levels/cl_lvl.lua:
local w,h = ScrW(),ScrH()
local x,y = w/2,h
local sizex,sizey = w*0.4,h*0.06
local barx,bary = x - sizex/2, y - sizey/2
local barx2,bary2 = x - sizex/2, y - sizey/2 - h*0.1
freslevelup = freslevelup or nil
local lastlvl = 0
local bpanim = false

if !DarkRP then return end

local function wykr(y)
    local x = fstands.Config.Levels.hard or 1
    local val = (x)*(y^2) + 50
    val = val - (val % 5)
    return val
end

local ply = FindMetaTable("Player")


fstands.Config.Levels.Types = {}

for k,v in pairs(fstands.Config.Levels.Type) do

    if istable(v) and v["Sort Order"] ~= nil then
        table.insert(fstands.Config.Levels.Types,tonumber(v["Sort Order"]),k)
    else
        table.insert(fstands.Config.Levels.Types,k)
    end
    
end

function ply:GetLevel(typ)
    typ = typ or self:getJobTable().lvl
    if typ == "ALL" then
        if self:getDarkRPVar("ALL_levels") ~= nil then
            return self:getDarkRPVar("ALL_levels")
        elseif self.alllevels ~= nil then
            return self.alllevels
        else
            local all = 0
            for k,v in pairs(fstands.Config.Levels.Type) do
                all = all + (self:getDarkRPVar(k.."_lvl") or 0)
            end
            self.alllevels = all
            return self.alllevels
        end
        
    end
    if typ == nil then return 0 end
    return self:getDarkRPVar(typ.."_lvl") or 0
end

function ply:GetExp(typ)
    typ = typ or self:getJobTable().lvl
    if typ == nil then return 0 end
    return self:getDarkRPVar(typ.."_xp") or 0
end

function ply:GetLevelType()
    return self:getJobTable().lvl or (fstands.Config.Levels.Types and fstands.Config.Levels.Types[1]) or "global"
end

function ply:nextlevel(typ,lvl)
    typ = typ or self:GetLevelType()
    if typ == nil then
        return 0
    end
    local l = lvl or self:GetLevel(typ)
    return wykr(l + 1)
end

if IsValid(freslevelup) then freslevelup:Remove() end

local function progbar()
    ply = LocalPlayer()
    if ply.GetLevel == nil or fstands.Config.Levels.Types == nil then return end
    if IsValid(freslevelup) then freslevelup:Remove() end
    local frame = vgui.Create("FFrame")
    freslevelup = frame
    frame:SetSize(sizex,sizey)
    frame:SetPos(barx,h + sizey)
    local a = (ScrH()+1) - bary2
    function frame:Hide()
        if self.CO == true then return end
        self.m_AnimList = nil
        local b = ((ScrH()+1) - self:GetY()) 
        local c = b/a

        self:MoveTo(barx,ScrH()+1,c*0.5,0,-0.5,function()
        end)
    end
    function frame:Show()
        if self.CO == true then return end
        self.m_AnimList = nil
        local b = (self:GetY() - (bary2))
        local c = b/a

        self:SlideIn(barx,bary2,c*0.5,0,0.5)
    end
    frame.Paint = function(self,w,h)
        draw.RoundedBox(20,0,0,w,h,Color(0,0,0))
    end
    frame.levels = fstands.Config.Levels.Type
    frame.levelssort = fstands.Config.Levels.Types
    frame.levelsn = #frame.levelssort
    frame.typ = ply:GetLevelType()
    frame.lastlvl = {}
    for k,v in pairs(frame.levels) do
        frame.lastlvl[k] = {ply:GetLevel(k),ply:GetExp(k)}
    end
    

    local info = vgui.Create("DLabel",frame)
    info:SetContentAlignment(5)
    info:SetText("For all levels hold C")
    info:Dock(BOTTOM)

    function frame:Open()
        frame.CO = true
        self.alllevel(self.typ)
        info:SetText("Release C to close")
        --self:SizeTo(sizex,sizey + (self.levelsn * sizey) *0.61,2,0,0.5)
        local noanim = info:NewAnimation(2,0,0.5)
        local a,b = self:GetWide(),self:GetTall()
        noanim.Think = function(anim,pnl,fraction)
            local x = Lerp(fraction,a,sizex)
            local y = Lerp(fraction,b,sizey + (frame.levelsn * sizey) *0.61)
            frame:SetSize(x,y)
        end
        self:MoveTo(barx,bary2 + (-self.levelsn * sizey)*0.61,2,0,0.5)
    end

    function frame:OHide()
        
        self.m_AnimList = nil
        self:SizeTo(sizex,sizey,2,0,0.5,function()
            frame.level(ply:GetLevelType())
            frame.CO = nil
        end)
        local noanim = info:NewAnimation(2,0,0.5)
        local a,b = self:GetWide(),self:GetTall()
        noanim.Think = function(anim,pnl,fraction)
            local x = Lerp(fraction,a,sizex)
            local y = Lerp(fraction,b,sizey)
            frame:SetSize(x,y)
        end
        timer.Simple(2,function()
            if IsValid(self) and self.CO == nil then
            self.level(ply:GetLevelType())
            self:SetSize(sizex,sizey)
            end
        end)
        --self:MoveTo(barx,bary2,2,0,0.5)
    end

    function frame:ShowC()

        local b = (self:GetY() - (bary2))
        local c = b/a
        if c < 0 then
            c = -c
        end
        info:SetText("CLICK HERE TO OPEN")
        self.m_AnimList = nil
        self:SlideIn(barx,bary2,c*0.5,0,0.5)
        local button = vgui.Create("DButton",self)
        self.c = button
        button:SetSize(self:GetWide(),self:GetTall())
        button:SetAlpha(0)
        function button:DoClick()
            frame:Open()
        end
        self:MakePopup()
    end
    function frame:HideC()
        self.m_AnimList = nil
        local b = ((ScrH()+1) - self:GetY()) 
        local c = b/a
        if IsValid(self.c) then
            self.c:Remove()
            self:OHide()
        end
        self:SetMouseInputEnabled(false)
        self:SetKeyboardInputEnabled(false)
        self:KillFocus()
        info:SetText("For all levels hold C")
        self:MoveTo(barx,ScrH()+1,c*0.5,0,-0.5,function()
        end)
    end

    local bot = vgui.Create("DPanel",frame)
    bot:Dock(FILL)
    bot.Paint = nil

    local lvlup = vgui.Create("DPanel",frame)
    lvlup:SetSize(frame:GetWide(),frame:GetTall())
    lvlup:SetPos(0,0)
    lvlup:SetAlpha(0)
    lvlup.Paint = function(self,w,h)
        draw.RoundedBox(20,0,0,w,h,Color(138,138,138))
    end
    local function alllevel(typ2)
        frame.typ = typ2
        bot:Clear()
            local function make(k)
                local pnl = vgui.Create("DPanel",bot)
                pnl:Dock(TOP)
                pnl.Paint = nil
                pnl:SetSize(sizex,sizey*0.7)
                local typ = k
                pnl.xp = frame.lastlvl[typ][2]
                pnl.lvl = frame.lastlvl[typ][1]
                pnl.xpnext = ply:nextlevel(typ,pnl.lvl)
                
                pnl.name = istable(frame.levels[typ]) and frame.levels[typ]["Print Name"] or typ 

                local top = vgui.Create("DLabel",pnl)
                top:Dock(TOP)
                top:SetContentAlignment(5)
                top:SetFont("CreditsText")
                top:SetText(pnl.name)

                local left = vgui.Create("DPanel",pnl)
                left.Paint = nil
                left:Dock(LEFT)
                left:SetSize(sizex *0.05)
                local right = vgui.Create("DPanel",pnl)
                right:Dock(RIGHT)
                right.Paint = nil
                right:SetSize(sizex *0.05)

                local ll = vgui.Create("DLabel",left)
                pnl.ll = ll
                ll:SetText(pnl.lvl)
                ll:SetContentAlignment(5)
                ll:SetFont("CreditsText")
                ll:Dock(FILL)
                local lr = vgui.Create("DLabel",right)
                pnl.lr = lr
                lr:SetText(pnl.lvl + 1)
                lr:SetContentAlignment(5)
                lr:SetFont("CreditsText")
                lr:Dock(FILL)

                local prog = vgui.Create("DProgress",pnl)
                prog:Dock(FILL)
                prog:SetFraction(pnl.xp/pnl.xpnext)
                prog.color = istable(frame.levels[typ]) and frame.levels[typ]["Color"] or ply:getJobTable().color or Color(255,255,255)
                prog.Paint = function(self, w, h)

                    draw.RoundedBox(20, 0, 0, w, h, Color(75, 75, 75))

                    render.SetScissorRect(0, 0, ScrW()/2 - (-(w) * self:GetFraction()) - w/2, ScrH(), true)
                        
                    draw.RoundedBox(20, 0, 0, w, h, self.color)

                    render.SetScissorRect(0, 0, 0, 0, false)

                end
                local exp = vgui.Create("DLabel",pnl)
                exp:Dock(FILL)
                exp:SetFont("CreditsText")
                exp:SetContentAlignment(5)
                exp:SetText(pnl.xp.."/"..pnl.xpnext)

                pnl.lvlup = vgui.Create("DPanel",pnl)
                local lvlup = pnl.lvlup
                lvlup:SetSize(pnl:GetWide(),pnl:GetTall())
                lvlup:SetPos(0,0)
                lvlup:SetAlpha(0)
                lvlup.Paint = function(self,w,h)
                    draw.RoundedBox(20,0,0,w,h,Color(138,138,138))
                end

                local function update(val,typ)
                    
                    function pnl:doAnim()
                        local anim = self:NewAnimation( 3, 0, 0.4, function(anim,pnl)
                            frame.lastlvl[typ] = {ply:GetLevel(typ),ply:GetExp(typ)}
                            pnl.xp = frame.lastlvl[typ][1]
                            pnl.lvl = frame.lastlvl[typ][2]
                            pnl.xpnext = ply:nextlevel(typ,pnl.lvl)
                            
                        end)
                        timer.Simple(3,function()
                            if IsValid(frame) then
                                frame.lastlvl[typ] = {ply:GetLevel(typ),ply:GetExp(typ)}
                                if !IsValid(self) then return end
                                self.xp = frame.lastlvl[typ][1]
                                self.lvl = frame.lastlvl[typ][2]
                                self.xpnext = ply:nextlevel(typ,self.lvl)
                            end
                        end)
                        local w = self.xp
                        local w2 = self.xpnext
                        anim.Think = function( anim, pnl, fraction )
                            local a = Lerp(fraction,w,val)
                            prog:SetFraction(a/w2)
                            a = math.Round(a)
                            exp:SetText(a.."/"..w2)
                        end
                    end
                    if ply:GetLevel(typ) ~= frame.lastlvl[typ][1] then
                        
                        pnl.lvlup:AlphaTo(255,0.8,1,function(a,pnl2)
                            
                            frame.lastlvl[typ] = {ply:GetLevel(typ),ply:GetExp(typ)}
                            pnl2:GetParent().xp = frame.lastlvl[typ][2]
                            pnl2:GetParent().lvl = frame.lastlvl[typ][1]
                            pnl2:GetParent().xpnext = ply:nextlevel(typ,pnl2:GetParent().lvl)
                            pnl2:GetParent().ll:SetText(pnl2:GetParent().lvl)
                            pnl2:GetParent().lr:SetText(pnl2:GetParent().lvl +1)


                            
                            LocalPlayer():EmitSound("fstands/done/1.mp3")
                            lvlup:AlphaTo(0,0.8,0)
                        end)
                    end
                    pnl:doAnim()

                end   
                if frame.lastlvl[typ][2] ~= ply:GetExp(typ) or frame.lastlvl[typ][1] ~= ply:GetLevel(typ) then
                    update(ply:GetExp(typ),typ)
                end             
            end
            make(frame.typ)
            for k,v in ipairs(frame.levelssort) do
                if frame.typ == v then continue end
                make(v)
            end
            frame.update = frame.alllevel
    end
    frame.alllevel = alllevel
    local function level(typ)
        frame.typ = typ
        bot:Clear()
        local xp = frame.lastlvl[typ][2]
        local lvl = frame.lastlvl[typ][1]
        local xpnext = ply:nextlevel(typ,lvl)
        
        local name = istable(frame.levels[typ]) and frame.levels[typ]["Print Name"] or typ 

        local top = vgui.Create("DLabel",bot)
        top:Dock(TOP)
        top:SetContentAlignment(5)
        top:SetFont("CreditsText")
        top:SetText(name)

        local left = vgui.Create("DPanel",bot)
        left.Paint = nil
        left:Dock(LEFT)
        left:SetSize(sizex *0.05)
        local right = vgui.Create("DPanel",bot)
        right:Dock(RIGHT)
        right.Paint = nil
        right:SetSize(sizex *0.05)

        local ll = vgui.Create("DLabel",left)
        ll:SetText(lvl)
        ll:SetContentAlignment(5)
        ll:SetFont("CreditsText")
        ll:Dock(FILL)
        local lr = vgui.Create("DLabel",right)
        lr:SetText(lvl + 1)
        lr:SetContentAlignment(5)
        lr:SetFont("CreditsText")
        lr:Dock(FILL)

        local prog = vgui.Create("DProgress",bot)
        prog:Dock(FILL)
        prog:SetFraction(xp/xpnext)
        prog.color = istable(frame.levels[typ]) and frame.levels[typ]["Color"] or ply:getJobTable().color or Color(255,255,255)
        prog.Paint = function(self, w, h)

            draw.RoundedBox(20, 0, 0, w, h, Color(75, 75, 75))

            render.SetScissorRect(0, 0, ScrW()/2 - (-(w) * self:GetFraction()) - w/2, ScrH(), true)
                
            draw.RoundedBox(20, 0, 0, w, h, self.color)

            render.SetScissorRect(0, 0, 0, 0, false)

        end
        local exp = vgui.Create("DLabel",prog)
        exp:Dock(FILL)
        exp:SetFont("CreditsText")
        exp:SetContentAlignment(5)
        exp:SetText(xp.."/"..xpnext)
        local function update(val)
            frame:Show()
            bot.m_AnimList = nil
            function bot:doAnim()
                local anim = self:NewAnimation( 3, 0, 0.4, function(anim,pnl)
                    frame.lastlvl[typ] = {ply:GetLevel(typ),ply:GetExp(typ)}
                    xp = frame.lastlvl[typ][2]
                    lvl = frame.lastlvl[typ][1]
                    xpnext = ply:nextlevel(typ,lvl)
                    
                    if banim == false then
                        frame:Hide()
                    end
                end)
                timer.Simple(3,function()
                    if IsValid(frame) then
                        frame.lastlvl[typ] = {ply:GetLevel(typ),ply:GetExp(typ)}
                        xp = frame.lastlvl[typ][2]
                        lvl = frame.lastlvl[typ][1]
                        xpnext = ply:nextlevel(typ,lvl)
                        
                    end
                end)
                local w = xp
                local w2 = xpnext
                anim.Think = function( anim, pnl, fraction )
                    if !IsValid(prog) then return end
                    local a = Lerp(fraction,w,val)
                    prog:SetFraction(a/w2)
                    a = math.Round(a)
                    exp:SetText(a.."/"..w2)
                end
            end
            if ply:GetLevel(typ) ~= frame.lastlvl[typ][1] then
                lvlup:AlphaTo(255,0.8,1,function()
                    frame.lastlvl[typ] = {ply:GetLevel(typ),ply:GetExp(typ)}
                    xp = frame.lastlvl[typ][2]
                    lvl = frame.lastlvl[typ][1]
                    xpnext = ply:nextlevel(typ,lvl)
                        if !IsValid(ll) then return end
                    ll:SetText(lvl)
                    lr:SetText(lvl +1)
                    LocalPlayer():EmitSound("fstands/done/1.mp3")
                    lvlup:AlphaTo(0,0.8,0)
                end)
            end
            bot:doAnim()

        end
        if frame.lastlvl[typ][2] ~= ply:GetExp(typ) or ply:GetLevel(typ) ~= frame.lastlvl[typ][1] then
            update(ply:GetExp(typ))
        end
        frame.update = level
        
    end
    frame.level = level
    level(ply:GetLevelType()) 



end

net.Receive("fres_loaded",function()
    progbar()
end)

net.Receive("fres_newlvl",function()
    local typ = net.ReadString()
    local xp = net.ReadDouble()
    local lvl = net.ReadDouble()
    if typ ~= nil then
        if lvl ~= nil then
            --LocalPlayer():setDarkRPVar(typ.."_lvl",lvl)
        end
    
        if xp ~= nil then
            --LocalPlayer():setDarkRPVar(typ.."_xp",xp)
        end
    end
    if !IsValid(freslevelup) then
        progbar()
    end
    freslevelup.update(typ)
end)

--DarkRP.registerDarkRPVar("ALL_levels",net.WriteDouble, net.ReadDouble)
hook.Add("InitPostEntity","onprogbar",function()
    timer.Create("WHYFUNCTIONNOTVALID",1,0,function()
        if LocalPlayer().GetLevel ~= nil then
      
            timer.Remove("WHYFUNCTIONNOTVALID")
            for k,v in pairs(fstands.Config.Levels.Type) do
                --DarkRP.registerDarkRPVar(k.."_lvl",net.WriteDouble, net.ReadDouble)
                --DarkRP.registerDarkRPVar(k.."_xp", net.WriteDouble, net.ReadDouble)
            end
            --DarkRP.registerDarkRPVar("ALL_levels",net.WriteDouble, net.ReadDouble)
        end
    end)
    
end)

hook.Add("OnContextMenuOpen","fres_lvl",function()
    if !IsValid(freslevelup) then
        progbar()
    end
    freslevelup:ShowC()
end)
hook.Add("OnContextMenuClose","fres_lvl",function()
    if IsValid(freslevelup) then
        freslevelup:HideC()
    end
end)

hook.Add( "PlayerChangedTeam", "fres_lvl", function( ply, oldTeam, newTeam )
    if ply == LocalPlayer() then
       	progbar()
        freslevelup.update(ply:GetLevelType())
    end
end )
hook.Add( "PlayerSpawn", "fres_lvl", function( ply,done )

    if ply == LocalPlayer() then
            progbar()
        if IsValid(freslevelup) and freslevelup.typ ~= ply:GetLevelType() then
            freslevelup.update(ply:GetLevelType())

        end
    end
end )

hook.Add( "ScoreboardHide", "Scoreboard_Close", function()
    if IsValid(freslevelup) then
        freslevelup:Hide()
        banim = false
    end

end)

hook.Add( "ScoreboardShow", "Scoreboard_Open", function()
    if !IsValid(freslevelup) then
        progbar()
    end
    banim = true
    freslevelup:Show()
end)


net.Receive("flvlt",function()
    local json = net.ReadString()

    fstands.Config.Levels = util.JSONToTable(json)

    for k,v in pairs(fstands.Config.Levels.Type) do
        DarkRP.registerDarkRPVar(k.."_lvl",net.WriteDouble, net.ReadDouble)
        DarkRP.registerDarkRPVar(k.."_xp", net.WriteDouble, net.ReadDouble)
    end
    DarkRP.registerDarkRPVar("ALL_levels",net.WriteDouble, net.ReadDouble)
    fstands.Config.Levels.Types = {}
    for k,v in pairs(fstands.Config.Levels.Type) do
        if istable(v) and v["Sort Order"] ~= nil then
            table.insert(fstands.Config.Levels.Types,tonumber(v["Sort Order"]),k)
        else
            table.insert(fstands.Config.Levels.Types,k)
        end
    end
    timer.Simple(1,function()
        progbar()
    end)
    
end)

net.Receive("flvlj",function()
    local tbl = util.JSONToTable(net.ReadString())
    for k,v in pairs(tbl) do
        for i,p in pairs(v) do
            RPExtraTeams[k][i] = p
        end
    end
    if IsValid(DarkRP.getF4MenuPanel()) then
        DarkRP.getF4MenuPanel():Remove()
    end
end)
--PATH lua/prone/class_prone_statedata.lua:
return gluapack()()
--PATH lua/prone/class_prone_statedata.lua:
-- The prone.PlayerStateData class simply stores some data about the given player's current prone state.
prone.PlayerStateDatas = prone.PlayerStateDatas or {}	-- Stores state data objects for players.

-- The class itself.
prone.PlayerStateData = {
	Player = 0,
	PlayerSteamID = "",
	OriginalViewOffset = Vector(0, 0, 64),
	OriginalViewOffsetDucked = Vector(0, 0, 28),
	StartTime = 0,
	GetDownTime = 0,
	EndTime = 0,
	GetUpTime = 0,
	EnterProneAnimLength = 0,
	EndProneAnimLength = 0
}

-- Generate simple getters and setters:
local preSettersGettersAdded = table.Copy(prone.PlayerStateData)
for k, v in pairs(preSettersGettersAdded) do
	prone.PlayerStateData["Get"..k] = function(self)
		return self[k]
	end
	prone.PlayerStateData["Set"..k] = function(self, newVal)
		self[k] = newVal
	end
end

function prone.PlayerStateData:__tostring()
	return "Prone state data for player '".. (IsValid(self.Player) and self.Player:Nick() or "INVALID PLAYER'")
end

------------------------------------------------
-- prone.PlayerStateData:UpdateDataOnProneEnter
------------------------------------------------
-- Desc:		Updates prone state data of a given player when they go to enter prone.
function prone.PlayerStateData:UpdateDataOnProneEnter()
	self.PlayerSteamID = self.Player:SteamID()
	self.OriginalViewOffset = self.Player:GetViewOffset()
	self.OriginalViewOffsetDucked = self.Player:GetViewOffsetDucked()
	self.StartTime = CurTime()

	local seq = prone.Animations.gettingdown

	self.EnterProneAnimLength = self.Player:SequenceDuration(self.Player:LookupSequence(seq))
	self.GetDownTime = self.EnterProneAnimLength + self.StartTime
end


------------------------------------------
-- prone.PlayerStateData:UpdateOnProneEnd
------------------------------------------
-- Desc:		Updates prone state data of a given player when they go to end prone.
-- Arg One:		Player.
function prone.PlayerStateData:UpdateOnProneEnd(ply)
	self.EndTime = CurTime()

	local seq = prone.Animations.gettingup

	self.EndProneAnimLength = self.Player:SequenceDuration(self.Player:LookupSequence(seq))
	self.GetUpTime = self.EndProneAnimLength + self.EndTime
end

-----------------------------
-- prone.PlayerStateData:New
-----------------------------
-- Desc:		Creates and returns a new prone.PlayerStateData object.
-- Arg One:		Player entity, whose state data this is.
-- Returns:		prone.PlayerStateData object.
function prone.PlayerStateData:New(ply)
	data = {Player = ply}
	setmetatable(data, self)
	self.__index = self
	return data
end
--PATH lua/prone/config.lua:
return gluapack()()
--PATH lua/tfres/library/sh_core_lib.lua:
return gluapack()()
--PATH lua/tfres/library/sh_core_lib.lua:

local global = tfres.Global

if SERVER then
    util.AddNetworkString("tfres::Networking")
end

function hex2rgb(hex)
    hex = hex:gsub("#","")
    return Color(tonumber("0x"..hex:sub(1,2)), tonumber("0x"..hex:sub(3,4)), tonumber("0x"..hex:sub(5,6)))
end

function global:SaveData(addon,name,data)
    if !isstring(data) and istable(data) then
        data = util.TableToJSON(data)
    end
    file.CreateDir("tfres/" .. addon)
    file.Write("tfres/" .. addon .. "/" .. name .. ".json",data)
end

function global:LoadData(addon,name)
    local data = file.Read("tfres/" .. addon .. "/" .. name .. ".json","DATA")
    if !data then
        return
    end
    data = util.JSONToTable(data) or data
    return data
end

function global:SQL(query)
    sql.Query(query)
end

local function compressdata(data)
    data = util.TableToJSON(data)
    local compressed_message = util.Compress( data )
	local bytes_amount = #compressed_message
    return compressed_message,bytes_amount
end

function global:NetSend(name,info,ply)
    local data, bytes = compressdata(info)
    net.Start("tfres::Networking")
        net.WriteString(name)
        net.WriteUInt( bytes, 16 )
        net.WriteData( data, bytes )
    net.Send(ply)
end

function global:NetBroadcast(name,info,ply)
    local data, bytes = compressdata(info)
    net.Start("tfres::Networking")
        net.WriteString(name)
        net.WriteUInt( bytes, 16 )
        net.WriteData( data, bytes )
    net.Broadcast()
end


function global:NetServer(name,info)
    local data, bytes = compressdata(info)
    net.Start("tfres::Networking")
        net.WriteString(name)
        net.WriteUInt( bytes, 16 )
        net.WriteData( data, bytes )
    net.SendToServer()
end

global.Networks = global.Networks or {}
global.NetworksBypass = global.NetworksBypass or {}

function global:RegisterNetwork(name,func,bypass)  
    global.Networks[name] = func
    if bypass then
        global.NetworksBypass[name] = true 
    end
end


function global:GetNet(name)
    return global.Networks[name] ~= nil
end

function global:Log(addon, ...)
    print("[tfres]",addon, ...)
end

function global:Error(addon, ...)
    local traceback = debug.traceback()
    print("[tfres]",addon, ... , traceback)
end

net.Receive("tfres::Networking",function(len,ply)
    local name = net.ReadString()
    if SERVER then
        if !global.NetworksBypass[name] then
            if !ply then return end
            if ply.tfres_net and ply.tfres_net > CurTime() then return end
            ply.tfres_net = CurTime() + 0.1
        else
        end
    end
    
    if !global:GetNet(name) then global:Error("Networking","No network name:" .. name .. " in realm: " .. (SERVER and "SERVER" or "CLIENT")) return end
    local bytes = net.ReadUInt(16)
    local compress = net.ReadData(bytes)
    local data = util.Decompress(compress)
    local tbl = util.JSONToTable(data)
    global.Networks[name](tbl,ply)
end)
--PATH lua/tfres/library/sh_core_lib.lua:
return gluapack()()
--PATH lua/vmanip/anims/vmanip_baseanims.lua:
return gluapack()()
--PATH RunString(Ex):
surface.PlaySound( "garrysmod/ui_click.wav" )