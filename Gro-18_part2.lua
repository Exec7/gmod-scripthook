--Stealed clientside server code by exechack.cc
--Hostname: Große Armee der Republik ★EGM★ [57 / 100] [v4.0.11] - Part 2/5 - 06/04/2025


--addons/bkeypads/lua/bkeypads/cl_fonts.lua:
local FONT_CIRCULAR = "Circular Std Medium"
local FONT_RUBIK = "Rubik"
local FONT_ROBOTO = "Roboto"

local FONT_16 = 16

local dyslexia = bKeypads.Settings:Get("dyslexia")
local dyslexia_weight
if dyslexia then
	FONT_CIRCULAR = "Comic Sans MS"
	FONT_RUBIK = "Comic Sans MS"
	FONT_ROBOTO = "Comic Sans MS"

	FONT_16 = 19

	dyslexia_weight = 700
end

surface.CreateFont("bKeypads.DermaDefaultDyslexia", {
	font = "Comic Sans MS",
	size = 19,
	weight = 700
})

surface.CreateFont("bKeypads.Tutorial.Caption", {
	font = FONT_CIRCULAR,
	size = 32,
	weight = dyslexia_weight,
	shadow = true
})

surface.CreateFont("bKeypads.Keycards.3D2D.Level", {
	font = "Consolas",
	weight = 700,
	shadow = true,
	size = 64
})

surface.CreateFont("bKeypads.Keycards.3D2D.Team", {
	font = "Consolas",
	shadow = true,
	size = 32
})

local levelBoxSize = 43
local levelBoxFontSize1 = levelBoxSize * (38 / 45)
local levelBoxFontSize2 = levelBoxFontSize1 * (28 / 38)
surface.CreateFont("bKeypads.Keycards.3D2D.Levels.1", {
	font = "Consolas",
	shadow = true,
	size = levelBoxFontSize1
})
surface.CreateFont("bKeypads.Keycards.3D2D.Levels.2", {
	font = "Consolas",
	shadow = true,
	size = levelBoxFontSize2
})

surface.CreateFont("bKeypads.ToolScreenNoPermission", {
	font = "Verdana",
	shadow = true,
	size = 24
})

surface.CreateFont("bKeypads.PicURLFont", {
	font = "Roboto Mono",
	size = 14
})

surface.CreateFont("bKeypads.LevelSelect.Shadow", {
	font = "Roboto Mono",
	size = 14,
	weight = 700,
	shadow = true
})

surface.CreateFont("bKeypads.LevelSelect", {
	font = "Roboto Mono",
	size = 14,
	weight = 700
})

surface.CreateFont("bKeypads.PINBtn", {
	size = 64,
	font = "Roboto Mono",
	weight = 700
})

surface.CreateFont("bKeypads.PINAsterisk", {
	size = 28,
	font = "Roboto Mono"
})

surface.CreateFont("bKeypads.PaymentFont", {
	size = 56,
	font = FONT_ROBOTO,
	weight = dyslexia_weight,
})

surface.CreateFont("bKeypads.SlideTextFont", {
	size = 255,
	font = "Uni Sans Heavy CAPS"
})

surface.CreateFont("bKeypads.OwnedByFont.1", {
	font = FONT_RUBIK,
	weight = 700,
	shadow = true,
	size = FONT_16
})

surface.CreateFont("bKeypads.OwnedByFont.2", {
	font = FONT_RUBIK,
	weight = 700,
	shadow = true,
	size = FONT_16
})

surface.CreateFont("bKeypads.KeypadLabelFont", {
	font = FONT_CIRCULAR,
	size = 50,
	weight = dyslexia_weight
})

surface.CreateFont("bKeypads.TutorialFont", {
	font = FONT_CIRCULAR,
	size = FONT_16,
	weight = dyslexia_weight
})

if bKeypads.CreateTooltipFont then
	bKeypads:CreateTooltipFont()
end
--addons/bkeypads/lua/bkeypads/sh_economy.lua:
bKeypads.Economy = {}

local plyMeta = FindMetaTable("Player")
function bKeypads.Economy:HasCashSystem()
	return bKeypads.Config.Payments.Economy.CustomEconomy or (DarkRP and (CLIENT or plyMeta.addMoney) and plyMeta.canAfford and true) or false
end

function bKeypads.Economy:addMoney(ply, amount)
	assert(IsValid(ply), "Tried to use a NULL player!")
	if bKeypads.Config.Payments.Economy.CustomEconomy then
		return bKeypads.Config.Payments.Economy.addMoney(ply, amount)
	elseif DarkRP and ply.addMoney then
		return ply:addMoney(amount)
	end
end

function bKeypads.Economy:canAfford(ply, amount)
	assert(IsValid(ply), "Tried to use a NULL player!")
	if bKeypads.Config.Payments.Economy.CustomEconomy then
		return bKeypads.Config.Payments.Economy.canAfford(ply, amount)
	elseif DarkRP and ply.canAfford then
		return ply:canAfford(amount)
	end
end

function bKeypads.Economy:formatMoney(amount)
	if bKeypads.Config.Payments.Economy.CustomEconomy then
		return bKeypads.Config.Payments.Economy.formatMoney(amount)
	elseif DarkRP and DarkRP.formatMoney then
		return DarkRP.formatMoney(amount)
	end
end

game.AddParticles("particles/bkeypads_cash.pcf")
PrecacheParticleSystem("bkeypads_cash")
function bKeypads.Economy:CashEffect(keypad)
	ParticleEffect("bkeypads_cash", keypad:LocalToWorld(keypad:OBBCenter()), angle_zero, keypad)
end

if SERVER then
	util.AddNetworkString("bKeypads.Economy.RequiresPayment")

	local requiresPaymentQueue = {}
	local function PlayerTick(ply)
		if requiresPaymentQueue[ply] then
			local EyePos, AimVector = ply:EyePos(), ply:GetAimVector()
			for keypad in pairs(requiresPaymentQueue[ply]) do
				if not IsValid(keypad) then continue end
				
				local keypadCenter = keypad:WorldSpaceCenter()

				local intersect = util.IntersectRayWithPlane(EyePos, AimVector, keypadCenter, (EyePos - keypadCenter):Angle():Forward())
				if not intersect then return end

				local dist = intersect:Distance(keypadCenter)

				local maxs, mins = keypad:OBBMaxs(), keypad:OBBMins()
				local tolerance = math.max(maxs.x - mins.x, maxs.y - mins.y, maxs.z - mins.z) * 2

				if dist > tolerance then continue end

				net.Start("bKeypads.Economy.RequiresPayment")
					net.WriteEntity(keypad)
					net.WriteBool(keypad:PlayerRequiresPayment(ply))
				net.Send(ply)
			end
			requiresPaymentQueue[ply] = nil
			
			if table.IsEmpty(requiresPaymentQueue) then
				hook.Remove("PlayerTick", "bKeypads.Economy.RequiresPayment")
			end
		end
	end

	local antispam = {}
	net.Receive("bKeypads.Economy.RequiresPayment", function(_, ply)
		local keypad = net.ReadEntity()

		if antispam[ply] and antispam[ply] > SysTime() then return end

		if not IsValid(keypad) or keypad:GetPaymentAmount() == 0 or not keypad:GetChargeUnauthorized() then return end
		
		antispam[ply] = SysTime() + 1

		requiresPaymentQueue[ply] = requiresPaymentQueue[ply] or {}
		requiresPaymentQueue[ply][keypad] = true

		hook.Add("PlayerTick", "bKeypads.Economy.RequiresPayment", PlayerTick) -- the lengths I go to to oppress skids
	end)
else
	local requiresPayment = {}
	net.Receive("bKeypads.Economy.RequiresPayment", function()
		requiresPayment[net.ReadEntity()] = net.ReadBool()
	end)

	function bKeypads.Economy:RequiresPayment(keypad, transmit)
		if keypad:GetKeypadOwner() == LocalPlayer() then return false end
		if not keypad:GetChargeUnauthorized() then return true end

		if transmit and keypad:GetChargeUnauthorized() then
			net.Start("bKeypads.Economy.RequiresPayment")
				net.WriteEntity(keypad)
			net.SendToServer()
		end

		if IsValid(keypad) and requiresPayment[keypad] ~= nil then
			return requiresPayment[keypad]
		else
			return true
		end
	end
end

-- Linus says: 1 SEK = 0.088 GBP
--addons/bkeypads/lua/bkeypads/sh_access_logs.lua:
local L = bKeypads.L

bKeypads.AccessLogs = {}
bKeypads.AccessLogs.Keypads = {}

if CLIENT then
	local accessLogsCallbacks = {}
	local callbackId = 0
	function bKeypads.AccessLogs:GetPage(keypad, fromIndex, callback)
		accessLogsCallbacks[keypad] = callback
		callbackId = callbackId + 1

		net.Start("bKeypads.AccessLogs.GetPage")
			net.WriteEntity(keypad)
			if fromIndex == -1 then
				net.WriteBool(true)
			else
				net.WriteBool(false)
				net.WriteUInt(fromIndex, 16)
			end
			net.WriteUInt(callbackId, 16)
		net.SendToServer()
	end

	net.Receive("bKeypads.AccessLogs.GetPage", function()
		local keypad = net.ReadEntity()
		local _callbackId = net.ReadUInt(16)
		if callbackId ~= _callbackId or not IsValid(keypad) or not accessLogsCallbacks[keypad] then return end
		
		local totalLogs = net.ReadUInt(32)

		local accessLogs = {}
		while (net.ReadBool()) do
			table.insert(accessLogs, {
				index = net.ReadUInt(32),
				ply = net.ReadString(),
				authMode = net.ReadUInt(2),
				granted = net.ReadBool(), 
				charge = net.ReadUInt(32),
				time = net.ReadUInt(32),
				hacked = net.ReadBool()
			})
		end

		accessLogsCallbacks[keypad](totalLogs, accessLogs)
		accessLogsCallbacks[keypad] = nil
	end)
end

if CLIENT then
	local function PaginationPerformLayout(self, w, h)
		self.Left:CenterHorizontal(0.4)
		self.Page:CenterHorizontal(0.5)
		self.Right:CenterHorizontal(0.6)

		self.Left:CenterVertical()
		self.Page:CenterVertical()
		self.Right:CenterVertical()
	end

	local function PageAllowInput(self, c)
		return not c:match("%d")
	end

	local function PageOnChange(self)
		local UI = self:GetParent():GetParent()
		local val = tonumber(self:GetValue())
		if self.Value == -1 then
			bKeypads.AccessLogs:GetPage(UI.Keypad, -1, UI.ReceiveData)
		else
			local index = self.MaxIndex - (val - 1) * 30
			if val and val > 0 and index > 0 and index < (2^32)-1 then
				if self:GetText() ~= tostring(val) then self:SetText(val) end
				self.Value = val
				self:SetText(val)

				self:GetParent().Left:SetDisabled(val <= 1)
				self:GetParent().Right:SetDisabled(index - 30 <= 1)

				UI.List:Clear()
				UI.List:AddLine(L"LoadingEllipsis")
				bKeypads.AccessLogs:GetPage(UI.Keypad, index, UI.ReceiveData)
			else
				self:SetText(self.Value)
			end
		end
	end

	local function PrevPage(self)
		self:GetParent().Page:SetText(self:GetParent().Page.Value - 1)
		PageOnChange(self:GetParent().Page)
	end

	local function NextPage(self)
		self:GetParent().Page:SetText(self:GetParent().Page.Value + 1)
		PageOnChange(self:GetParent().Page)
	end

	local function ListOnRowSelected(self, index, line)
		if line.SteamID64 then
			surface.PlaySound("garrysmod/ui_return.wav")
			
			local menu = DermaMenu()
			
			local name, sid64, sid32 = line.plyName, line.SteamID64, util.SteamIDFrom64(line.SteamID64)

			line.DMenuNameOption = menu:AddOption(name, function(self)
				SetClipboardText(self.UpdatedName or (IsValid(line) and line.plyName or name))
				surface.PlaySound("garrysmod/content_downloaded.wav")
				notification.AddLegacy(L"CopiedExclamation", NOTIFY_CLEANUP, 2)
			end)
			line.DMenuNameOption:SetIcon("icon16/box.png")
			line.DMenuNameOption.m_Image.AvatarImage = vgui.Create("AvatarImage", line.DMenuNameOption.m_Image)
			line.DMenuNameOption.m_Image.AvatarImage:Dock(FILL)
			line.DMenuNameOption.m_Image.AvatarImage:SetSteamID(sid64, 32)

			menu:AddOption(sid32, function()
				SetClipboardText(sid32)
				surface.PlaySound("garrysmod/content_downloaded.wav")
				notification.AddLegacy(L"CopiedExclamation", NOTIFY_CLEANUP, 2)
			end):SetIcon("icon16/user.png")

			menu:AddOption(sid64, function()
				SetClipboardText(sid64)
				surface.PlaySound("garrysmod/content_downloaded.wav")
				notification.AddLegacy(L"CopiedExclamation", NOTIFY_CLEANUP, 2)
			end):SetIcon("icon16/user_gray.png")

			menu:Open()
		end
	end

	function bKeypads.AccessLogs:OpenUI(keypad, animate, UI, wep)
		local AuthModeStrs = {
			[bKeypads.AUTH_MODE.PIN] = L"PIN",
			[bKeypads.AUTH_MODE.FACEID] = L"FaceID",
			[bKeypads.AUTH_MODE.KEYCARD] = L"Keycard"
		}
		
		if not UI then
			UI = UI or vgui.Create("DFrame")
			--UI:SetSkin("bKeypads_Dark")
			UI:SetTitle(L"KeypadAccessLogs")
			UI:SetIcon("icon16/calculator.png")
			UI:SetSize(450, 500)
			UI:MakePopup()
			if wep then
				UI.OnClose = function()
					if IsValid(wep) and LocalPlayer():GetActiveWeapon() == wep then
						net.Start("bKeypads.AccessLogs.Closed")
							net.WriteEntity(keypad)
						net.SendToServer()
					end
				end
			end

			if animate then
				UI:SetPos((ScrW() - UI:GetWide()) / 2, ScrH())

				local y = (ScrH() + UI:GetTall()) / 2
				UI:NewAnimation(1, 0, .5).Think = function(_, pnl, f)
					local f = bKeypads.ease.OutBack(f)

					local x = pnl:GetPos()
					pnl:SetPos(x, ScrH() - (y * f))

					pnl:SetAlpha(f * 255)
				end
			else
				UI:Center()
			end
		end
		UI.Keypad = keypad

		UI.List = vgui.Create("DListView", UI)
		UI.List:SetMultiSelect(false)
		UI.List:Dock(FILL)
		UI.List:AddColumn(L"When")
		UI.List:AddColumn(L"Mode")
		UI.List:AddColumn(L"Who")
		UI.List:AddColumn(L"Access")
		if bKeypads.Economy:HasCashSystem() then UI.List:AddColumn(L"Charge") end
		UI.List:AddLine(L"LoadingEllipsis")
		UI.List.OnRowSelected = ListOnRowSelected

		UI.Pagination = vgui.Create("DPanel", UI)
		UI.Pagination:Dock(TOP)
		UI.Pagination:DockPadding(10, 10, 10, 10)
		UI.Pagination:SetTall(25 + 20)
		UI.Pagination.PerformLayout = PaginationPerformLayout			
		UI.Pagination.Paint = nil

		UI.Pagination.Left = vgui.Create("DButton", UI.Pagination)
		UI.Pagination.Left:SetText("<")
		UI.Pagination.Left:SetSize(25, 25)
		UI.Pagination.Left:SetDisabled(true)
		UI.Pagination.Left.DoClick = PrevPage

		UI.Pagination.Page = vgui.Create("DTextEntry", UI.Pagination)
		UI.Pagination.Page:SetText("1")
		UI.Pagination.Page:SetSize(50, 25)
		UI.Pagination.Page:SetDisabled(true)
		UI.Pagination.Page.Value = -1
		UI.Pagination.Page.AllowInput = PageAllowInput
		UI.Pagination.Page.OnEnter = PageOnChange
		UI.Pagination.Page.OnFocusChanged = function(self, focused) if not focused and self:GetText() ~= tostring(self.Value) then PageOnChange(self) end end

		UI.Pagination.Right = vgui.Create("DButton", UI.Pagination)
		UI.Pagination.Right:SetText(">")
		UI.Pagination.Right:SetSize(25, 25)
		UI.Pagination.Right:SetDisabled(true)
		UI.Pagination.Right.DoClick = NextPage

		UI.ReceiveData = function(totalLogs, accessLogs)
			if UI.Pagination.Page.Value == -1 then
				UI.Pagination.Page.Value = 1
				if totalLogs > 30 then
					UI.Pagination.Right:SetDisabled(false)
				end
			end
			UI.Pagination.Page.MaxIndex = totalLogs
			UI.Pagination.Page:SetDisabled(false)

			UI.List:Clear()
			if #accessLogs > 0 then
				for _, log in ipairs(accessLogs) do
					local plyName, steamWorksRequest
					if log.ply ~= "" and log.ply:match("^7656119%d+$") then
						plyName = util.SteamIDFrom64(log.ply)
						local ply = bKeypads.player.GetBySteamID64(log.ply)
						if IsValid(ply) then
							plyName = ply:Nick()
						else
							local steamName = steamworks.GetPlayerName(log.ply)
							if #steamName > 0 then
								plyName = steamName
							else
								steamWorksRequest = log.ply
							end
						end
					else
						plyName = L"Unknown"
					end

					local line = UI.List:AddLine(
						bKeypads:FormatTimeDelta(os.time(), log.time),
						AuthModeStrs[log.authMode] or L"Unknown",
						log.hacked and L"KeypadHackedAdminHidden" or plyName,
						log.granted == true and ((log.hacked or log.ply == "") and "=̨̘͎͖̈̋̋̏́̌̀͜͠=̣̖̦̗̜͌̓͌̆̊̀͋̍͜ͅ=̷̢̱̤̪̘̩̠̆̇̂̎̇͠͝=̴̡̢̟̙̲̙̠̰̟͐̊͂͊͐̍̚͢≠̛̛͎̮̜͚͕̊̽̓̂͊̽͟͜͞=͕̹̻̝̥̤͚͛̋̈̌͆̋͒" or L"Granted") or L"Denied",
						bKeypads.Economy:HasCashSystem() and (log.charge == 0 and "" or bKeypads.Economy:formatMoney(log.charge)) or nil
					)
					line.SteamID64 = log.ply ~= "" and log.ply
					line.plyName = plyName
					
					if steamWorksRequest then
						steamworks.RequestPlayerInfo(steamWorksRequest, function(name)
							if #name == 0 then return end
							line:SetColumnText(3, name)
							line.plyName = name
							if IsValid(line.DMenuNameOption) then
								line.DMenuNameOption:SetText(name)
								line.DMenuNameOption:InvalidateParent()
							end
						end)
					end
				end
			else
				UI.List:AddLine(L"NoData")
			end
		end

		PageOnChange(UI.Pagination.Page)
	end

	net.Receive("bKeypads.AccessLogs", function()
		bKeypads.AccessLogs:OpenUI(net.ReadEntity(), true, nil, net.ReadEntity())
	end)
end
--addons/bkeypads/lua/bkeypads/sh_notifications.lua:
bKeypads.Notifications = {}

bKeypads.Notifications.ACCESS_GRANTED      = 0
bKeypads.Notifications.ACCESS_DENIED       = 1
bKeypads.Notifications.PAYMENT_TAKEN       = 2
bKeypads.Notifications.PAYMENT_RECEIVED    = 3
bKeypads.Notifications.PAYMENT_CANT_AFFORD = 4

bKeypads.Notifications.MoneyTypes = {
	[bKeypads.Notifications.PAYMENT_TAKEN] = true,
	[bKeypads.Notifications.PAYMENT_RECEIVED] = true,
	[bKeypads.Notifications.PAYMENT_CANT_AFFORD] = true,
}
bKeypads.Notifications.AccessTypes = {
	[bKeypads.Notifications.ACCESS_GRANTED] = true,
	[bKeypads.Notifications.ACCESS_DENIED] = true
}
bKeypads.Notifications.PlayerTypes = {
	[bKeypads.Notifications.ACCESS_GRANTED] = true,
	[bKeypads.Notifications.ACCESS_DENIED] = true,
	[bKeypads.Notifications.PAYMENT_RECEIVED] = true,
}
bKeypads.Notifications.KeypadTypes = {
	[bKeypads.Notifications.ACCESS_GRANTED] = true,
	[bKeypads.Notifications.ACCESS_DENIED] = true,
	[bKeypads.Notifications.PAYMENT_RECEIVED] = true,
	[bKeypads.Notifications.PAYMENT_CANT_AFFORD] = true,
}

if CLIENT then
	function bKeypads.Notifications:GetText(type, keypad, ply)
		if (
			not IsValid(keypad) or
			(bKeypads.Notifications.PlayerTypes[type] and not IsValid(ply))
		) then return end

		local moneyText, plyText, keypadText

		if bKeypads.Notifications.PlayerTypes[type] then plyText = "<color=" .. bKeypads.markup.Color(team.GetColor(ply:Team())) .. ">" .. bKeypads.markup.Escape(ply:Nick()) .. "</color>" end
		if bKeypads.Notifications.MoneyTypes[type] then moneyText = "<color=0,200,0>" .. bKeypads.markup.Escape(bKeypads.Economy:formatMoney(keypad:GetPaymentAmount())) .. "</color>" end
		if bKeypads.Notifications.KeypadTypes[type] and keypad:GetKeypadName() ~= "" then keypadText = ("<color=" .. bKeypads.markup.Color(bKeypads:IntToColor(keypad:GetBackgroundColor())) .. ">" .. bKeypads.markup.Escape(keypad:GetKeypadName()) .. "</color>") end

		local keypadTextLangAppend = keypadText and "_Named" or ""

		if type == bKeypads.Notifications.PAYMENT_TAKEN then
			return bKeypads.L("Notification_PaymentTaken" .. keypadTextLangAppend):format(moneyText, keypadText)
		elseif type == bKeypads.Notifications.ACCESS_GRANTED then
			return bKeypads.L("Notification_Access" .. keypadTextLangAppend):format("<color=0,200,0>" .. bKeypads.L("Notification_GRANTED") .. "</color>", plyText, keypadText)
		elseif type == bKeypads.Notifications.ACCESS_DENIED then
			return bKeypads.L("Notification_Access" .. keypadTextLangAppend):format("<color=200,0,0>" .. bKeypads.L("Notification_DENIED") .. "</color>", plyText, keypadText)
		elseif type == bKeypads.Notifications.PAYMENT_RECEIVED then
			return bKeypads.L("Notification_PaymentReceived" .. keypadTextLangAppend):format(moneyText, plyText, keypadText)
		elseif type == bKeypads.Notifications.PAYMENT_CANT_AFFORD then
			return bKeypads.L("Notification_PaymentCantAfford" .. keypadTextLangAppend):format(moneyText, keypadText)
		else return	end
	end

	bKeypads_Notifications_Stack = bKeypads_Notifications_Stack or {}
	for _, notif in ipairs(bKeypads_Notifications_Stack) do notif:Remove() end
	bKeypads_Notifications_Stack = {}
	bKeypads.Notifications.Stack = bKeypads_Notifications_Stack

	function bKeypads.Notifications:Show(type, keypad, ply)
		local text = bKeypads.Notifications:GetText(type, keypad, ply)
		if not text then return end

		if bKeypads.Config.Notifications.UseChat then
			
			local args = {bKeypads.COLOR.PINK, "[bKeypads] "}
			for _, block in ipairs(markup.Parse(text).blocks) do
				table.insert(args, Color(block.colour.r, block.colour.g, block.colour.b))
				table.insert(args, block.text)
			end

			chat.AddText(unpack(args))

		else
			
			local notif = vgui.Create("bKeypads.Notification")
			notif:SetExpire(bKeypads.Settings:Get("notification_time"))
			notif:SetIcon(type, keypad)
			notif:SetText(text)
			table.insert(bKeypads.Notifications.Stack, notif)

			bKeypads.Notifications:Shuffle()

		end
	end

	net.Receive("bKeypads.Notification", function()
		bKeypads.Notifications:Show(net.ReadUInt(3), net.ReadEntity(), net.ReadEntity())
	end)

	--## Notification Panel ##--

	function bKeypads.Notifications:CreateFont()
		surface.CreateFont("bKeypads.NotificationText", {
			font = "Circular Std Medium",
			size = bKeypads.Settings:Get("notification_text_size")
		})

		for _, notif in ipairs(bKeypads.Notifications.Stack) do
			notif:SetText(notif.m_Text)
		end

		bKeypads.Notifications:Shuffle()
	end

	bKeypads_Notifications_ID = bKeypads_Notifications_ID or 0

	local PANEL = {}

	local BGColor = Color(41, 47, 79)
	local BGColorDark = Color(32, 38, 70)
	local IconContainerBG = Color(37, 42, 71, 255)
	local SoftGreen, SoftRed = Color(0, 200, 0), Color(255, 0, 0)

	local padding = 15
	local progressHeight = 3

	local animInDuration = .5
	local animOutDuration = .25
	
	do
		local function ShuffleAnim(anim, pnl, f)
			pnl:SetPos(anim.TargetX, anim.StartY + (anim.TargetY - anim.StartY) * bKeypads.ease.OutBack(f))
		end
		function bKeypads.Notifications:Shuffle()
			local y = 0
			local stackSize = #bKeypads.Notifications.Stack
			for i = stackSize, 1, -1 do
				local notif = bKeypads.Notifications.Stack[i]
				if not IsValid(notif) then ErrorNoHalt("Tried to remove a NULL notification\n") continue end
				
				if ((stackSize - (i - 1)) > bKeypads.Settings:Get("notification_max")) then
					notif:Expire()
				end

				y = y + notif:GetTall() + 20
				
				notif:Stop()

				local anim = notif:NewAnimation(animInDuration, 0, 1)
				anim.Think = ShuffleAnim
				anim.TargetX, anim.StartY = notif:GetPos()
				anim.TargetY = ScrH() - y
			end
		end
	end

	local matPIN     = Material("bkeypads/notification_pin.png", "smooth")
	local matKeycard = Material("bkeypads/keycard.png", "smooth")
	local matSmile   = Material("bkeypads/face_id.png", "smooth")
	local matSad     = Material("bkeypads/face_id_sad.png", "smooth")
	local matDollar  = Material("bkeypads/dollar.png", "smooth")

	function PANEL:Init()
		self:SetMouseInputEnabled(false)
		self:SetKeyboardInputEnabled(false)
		self:SetDrawOnTop(true)
		self:MoveToFront()

		self:SetSize(ScrW() * .25, 45)
		self:SetPos(self:CenterHorizontal(), ScrH())
	end

	function PANEL:CenterHorizontal()
		local x = ScrW() * .375
		self:AlignLeft(x)
		return x
	end

	function PANEL:SetText(text)
		self.m_Text = text
		self.m_Markup = markup.Parse("<font=bKeypads.NotificationText>" .. text .. "</font>", self:GetWide() - self:GetIconPadding() - self:GetIconPadding() - self:GetIconSize() - padding - padding - padding)
		self:SetTall(self.m_Markup:GetHeight() + padding + padding + progressHeight)
	end


	function PANEL:SetIcon(type, keypad)
		self.m_Type = type

		if bKeypads.Notifications.MoneyTypes[type] then
			
			self.m_Material = matDollar
			self.m_Color = type == bKeypads.Notifications.PAYMENT_CANT_AFFORD and SoftRed or SoftGreen

			if bKeypads.Settings:Get("notification_sounds") then
				if type == bKeypads.Notifications.PAYMENT_CANT_AFFORD then
					surface.PlaySound("buttons/button2.wav")
				elseif type == bKeypads.Notifications.PAYMENT_TAKEN then
					surface.PlaySound("garrysmod/content_downloaded.wav")
				else
					surface.PlaySound("garrysmod/save_load4.wav")
					timer.Simple(bKeypads.Settings:Get("notification_time"), function()
						surface.PlaySound("bkeypads/cash.wav")
					end)
				end
			end

			return
			
		elseif bKeypads.Notifications.AccessTypes[type] and IsValid(keypad) then

			local authMode = keypad:LinkProxy():GetAuthMode()
			self.m_Material = (
				authMode == bKeypads.AUTH_MODE.PIN and matPIN or
				authMode == bKeypads.AUTH_MODE.KEYCARD and matKeycard or
				authMode == bKeypads.AUTH_MODE.FACEID and (
					type == bKeypads.Notifications.ACCESS_GRANTED and matSmile or matSad
				)
			)
			self.m_Color = type == bKeypads.Notifications.ACCESS_GRANTED and SoftGreen or SoftRed

			if bKeypads.Settings:Get("notification_sounds") then
				surface.PlaySound(type == bKeypads.Notifications.ACCESS_GRANTED and "buttons/button9.wav" or "buttons/button11.wav")
			end

			return

		end

		self.m_Color = color_white
		self.m_Material = matSmile
	end

	function PANEL:GetIconSize()
		return math.min(self:GetTall() - self:GetIconPadding() - self:GetIconPadding(), 48)
	end

	function PANEL:GetIconPadding()
		return self.m_Markup and self.m_Markup:GetHeight() > bKeypads.Settings:Get("notification_text_size") and 15 or 10
	end

	function PANEL:SetExpire(seconds)
		self.m_LifeStart = CurTime()
		self.m_LifeEnd   = animInDuration + self.m_LifeStart + seconds + animOutDuration

		bKeypads_Notifications_ID = bKeypads_Notifications_ID + 1

		self.TimerID = "bKeypads.Notification:" .. bKeypads_Notifications_ID
		timer.Create("bKeypads.Notification:" .. bKeypads_Notifications_ID, seconds + animOutDuration + animInDuration, 1, function()
			if IsValid(self) then
				table.RemoveByValue(bKeypads.Notifications.Stack, self)
				self:Remove()
				
				bKeypads.Notifications:Shuffle()
			end
		end)
	end

	function PANEL:Expire()
		self.m_LifeEnd = math.min(self.m_LifeEnd, CurTime() + animOutDuration)
		timer.Adjust(self.TimerID, math.max((self.m_LifeEnd - CurTime()) + animOutDuration, animOutDuration))
	end

	function PANEL:Paint(w, h)
		local lifeFrac = math.Clamp(math.TimeFraction(self.m_LifeStart, self.m_LifeEnd, CurTime()), 0, 1)
		local fadeFrac = 1 - math.Clamp(math.TimeFraction(self.m_LifeEnd - animOutDuration, self.m_LifeEnd, CurTime()), 0, 1)

		local alpha = surface.GetAlphaMultiplier()
		surface.SetAlphaMultiplier(alpha * fadeFrac)

		local iconSize, iconPadding = self:GetIconSize(), self:GetIconPadding()
		local iconContainerW = iconPadding + iconSize + iconPadding

		surface.SetDrawColor(IconContainerBG)
		surface.DrawRect(0, 0, iconContainerW, h)

		surface.SetMaterial(self.m_Material)
		surface.SetDrawColor(self.m_Color)
		surface.DrawTexturedRect(iconPadding, (h - iconSize) / 2, iconSize, iconSize)

		surface.SetDrawColor(BGColor)
		surface.DrawRect(iconContainerW, 0, w, h - progressHeight)

		if self.m_Markup then
			self.m_Markup:Draw(iconContainerW + padding, (h - progressHeight) / 2, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER, 255, self.m_Markup:GetHeight() > bKeypads.Settings:Get("notification_text_size") and TEXT_ALIGN_LEFT or TEXT_ALIGN_CENTER)
		end

		surface.SetDrawColor(BGColorDark)
		surface.DrawRect(iconContainerW, h - progressHeight, w - iconPadding - iconSize - iconPadding, progressHeight)

		surface.SetAlphaMultiplier(alpha * fadeFrac * (BGColor.a / 255))
		surface.SetDrawColor(self.m_Color)
		surface.DrawRect(iconContainerW, h - progressHeight, (w - iconPadding - iconSize - iconPadding) * lifeFrac, progressHeight)
		
		surface.SetAlphaMultiplier(alpha)
	end

	vgui.Register("bKeypads.Notification", PANEL, "DPanel")

	bKeypads.Notifications:CreateFont()
end
--addons/bkeypads/lua/bkeypads/cl_keypad_esp.lua:
bKeypads.ESP = {}
-- This is not a cheat, it is part of the addon

bKeypads.ESP.IgnoreZ = false

hook.Remove("PreDrawHalos", "bKeypads.ESP.PreDrawHalos")
hook.Remove("PostDrawTranslucentRenderables", "bKeypads.ESP.Draw")

bKeypads.ESP.Active = false
function bKeypads.ESP:Activate()
	if bKeypads.ESP.Active then return end

	bKeypads.ESP.Active = true

	bKeypads.ESP.Halos:Reset()
	bKeypads.ESP.DataLinks = {}
	bKeypads.ESP.KeypadNetworks = {}

	bKeypads.ESP.ActiveTrace = {
		Color = {
			Red = false,
			Green = false
		},
		SnapTo = {
			FadingDoors = false,
			Keypads = false,
			MapLinkables = false
		},
		Keypad = NULL,
	}
	
	hook.Add("PreDrawHalos", "bKeypads.ESP.PreDrawHalos", bKeypads.ESP.PreDrawHalos)
	hook.Add("PostDrawTranslucentRenderables", "bKeypads.ESP.Draw", bKeypads.ESP.PostDrawTranslucentRenderables)
	hook.Add("PreDrawViewModel", "bKeypads.ESP.PreDrawViewModel", bKeypads.ESP.PreDrawViewModel)
	hook.Add("PostDrawViewModel", "bKeypads.ESP.PostDrawViewModel", bKeypads.ESP.PostDrawViewModel)
	hook.Add("PreDrawPlayerHands", "bKeypads.ESP.PreDrawPlayerHands", bKeypads.ESP.PreDrawViewModel)
	hook.Add("PostDrawPlayerHands", "bKeypads.ESP.PostDrawPlayerHands", bKeypads.ESP.PostDrawViewModel)

	bKeypads.ESP:Refresh()
end
function bKeypads.ESP:Deactivate()
	if not bKeypads.ESP.Active then return end

	bKeypads.ESP.Active = false
	bKeypads.ESP.IgnoreZ = false

	bKeypads.ESP.Halos:Reset()
	bKeypads.ESP.DataLinks = {}
	bKeypads.ESP.KeypadNetworks = {}
	
	hook.Remove("PreDrawHalos", "bKeypads.ESP.PreDrawHalos")
	hook.Remove("PostDrawTranslucentRenderables", "bKeypads.ESP.Draw")
	hook.Remove("PreDrawViewModel", "bKeypads.ESP.PreDrawViewModel")
	hook.Remove("PostDrawViewModel", "bKeypads.ESP.PostDrawViewModel")
	hook.Remove("PreDrawPlayerHands", "bKeypads.ESP.PreDrawPlayerHands")
	hook.Remove("PostDrawPlayerHands", "bKeypads.ESP.PostDrawPlayerHands")
end
function bKeypads.ESP:Refresh()
	if not bKeypads.ESP.Active then return end
	bKeypads.ESP.Update = true
end

--## Halos ##--

bKeypads.ESP.Halos = {}

function bKeypads.ESP.Halos:Reset()
	bKeypads.ESP.Halos.Dictionary = {
		[bKeypads.COLOR.GREEN] = {},
		[bKeypads.COLOR.RED] = {},
		[bKeypads.COLOR.PINK] = {},
		[bKeypads.COLOR.WHITE] = {}
	}
	bKeypads.ESP.Halos.List = {
		[bKeypads.COLOR.GREEN] = {},
		[bKeypads.COLOR.RED] = {},
		[bKeypads.COLOR.PINK] = {},
		[bKeypads.COLOR.WHITE] = {}
	}
end
bKeypads.ESP.Halos:Reset()

function bKeypads.ESP.Halos:Add(ent, color)
	if bKeypads.ESP.Halos.Dictionary[color][ent] == nil then
		bKeypads.ESP.Halos.Dictionary[color][ent] = table.insert(bKeypads.ESP.Halos.List[color], ent)
	end
end

bKeypads.ESP.PreDrawHalos = function()
	halo.Add(bKeypads.ESP.Halos.List[bKeypads.COLOR.GREEN], bKeypads.COLOR.GREEN, 1, 1, 1, true, bKeypads.ESP.IgnoreZ)
	halo.Add(bKeypads.ESP.Halos.List[bKeypads.COLOR.RED], bKeypads.COLOR.RED, 1, 1, 1, true, bKeypads.ESP.IgnoreZ)
	halo.Add(bKeypads.ESP.Halos.List[bKeypads.COLOR.PINK], bKeypads.COLOR.PINK, 1, 1, 1, true, bKeypads.ESP.IgnoreZ)
	halo.Add(bKeypads.ESP.Halos.List[bKeypads.COLOR.WHITE], bKeypads.COLOR.WHITE, 1, 1, 1, true, bKeypads.ESP.IgnoreZ)
end

bKeypads.ESP.PreDrawViewModel = function()
	render.DepthRange(0, 0)
end

bKeypads.ESP.PostDrawViewModel = function()
	render.DepthRange(0, 1)
end

--## Data Beams ##--

do
	local DataBeamMat = Material("cable/chain")

	local DataBeamPseudoMat = CreateMaterial("bKeypads.DataBeamPseudoMat", "UnlitGeneric", {
		["$basetexture"] = "sprites/physbeam_active_white",
		["$additive"] = 1,
		["$vertexcolor"] = 1,
		["$vertexalpha"] = 1,
	})

	function bKeypads.ESP.DrawDataBeam(ent1, ent2, color, pseudolink, solid)
		if (not isvector(ent1) and not IsValid(ent1)) or (not isvector(ent2) and not IsValid(ent2)) then return end

		local pos1 = isvector(ent1) and ent1 or ent1:LocalToWorld(ent1:OBBCenter())
		local pos2 = isvector(ent2) and ent2 or ent2:LocalToWorld(ent2:OBBCenter())

		local dist = pos1:Distance(pos2)
		local clamp = math.max(math.floor(dist / 10), 4)

		if pseudolink then
			render.SetMaterial(DataBeamPseudoMat)
			render.DrawBeam(pos1, pos2, 4, SysTime() + clamp, SysTime(), bKeypads.COLOR.PINK)
		else
			if solid then
				if bKeypads.ESP.IgnoreZ then
					render.SetColorMaterialIgnoreZ()
				else
					render.SetColorMaterial()
				end
			else
				render.SetMaterial(DataBeamMat)
			end
			render.DrawBeam(pos1, pos2, 2, SysTime() + clamp, SysTime(), color or bKeypads.COLOR.WHITE)
		end
	end

	function bKeypads.ESP.AnimateDataBeam()
		DataBeamMat:SetInt("$frame", ((SysTime() * 2) % 3) + 1)
	end

	bKeypads.ESP.PostDrawTranslucentRenderables = function(bDrawingDepth, bDrawingSkybox)
		if bDrawingSkybox then return end
		if render.GetRenderTarget() ~= nil then return end
		
		bKeypads.cam.IgnoreZ(bKeypads.ESP.IgnoreZ)

		bKeypads.ESP.AnimateDataBeam()

		for _, data_link in ipairs(bKeypads.ESP.DataLinks) do
			bKeypads.ESP.DrawDataBeam(data_link[1], data_link[2], data_link[3], data_link[4], data_link[5])
		end

		bKeypads.cam.IgnoreZ(false)
	end
end

--## Think Logic ##--

local bKeypadsTools = {
	bkeypads_linker = true,
	bkeypads_admin_tool = true,
	bkeypads_fading_door = true,
	bkeypads_breaker = true,
}

local showLinkTools = {
	bkeypads_admin_tool = true,
	bkeypads_linker = true
}

local access_mode_iter = {
	[true] = bKeypads.COLOR.GREEN,
	[false] = bKeypads.COLOR.RED,
}

function bKeypads.ESP:DrawKeypadNetwork(keypad, keypadNoDraw)
	local parent = keypad:IsParentKeypad() and keypad or keypad:GetParentKeypad()
	if IsValid(parent) then
		if parent ~= keypad and parent ~= keypadNoDraw and not bKeypads.ESP.Halos.Dictionary[bKeypads.COLOR.GREEN][parent] and not bKeypads.ESP.Halos.Dictionary[bKeypads.COLOR.RED][parent] then
			bKeypads.ESP.Halos:Add(parent, bKeypads.COLOR.PINK)
		end

		for keypad in pairs(parent:GetChildKeypads()) do
			if keypad == keypadNoDraw then continue end
			if not bKeypads.ESP.Halos.Dictionary[bKeypads.COLOR.GREEN][keypad] and not bKeypads.ESP.Halos.Dictionary[bKeypads.COLOR.RED][keypad] then
				bKeypads.ESP.Halos:Add(keypad, bKeypads.COLOR.PINK)
			end
			table.insert(bKeypads.ESP.DataLinks, { parent, keypad, bKeypads.COLOR.PINK } )
		end
	end
end

local _origin, _angles, _fov, _znear, _zfar
bKeypads.ESP.Watch = function(ply, origin, angles, fov, znear, zfar)
	if bKeypads.ESP.Update or bKeypads.ESP.Tick or (_origin ~= origin or _angles ~= angles or _fov ~= fov or _znear ~= znear or _zfar ~= zfar) then
		bKeypads.ESP.Update = false
		_origin, _angles, _fov, _znear, _zfar = origin, angles, fov, znear, zfar

		-- Force an ESP update to actually occur after a new frame
		if not bKeypads.ESP.Tick then
			bKeypads.ESP.Tick = true
			return
		else
			bKeypads.ESP.Tick = false
		end
	else
		return
	end

	bKeypads.ESP.Halos:Reset()
	bKeypads.ESP.DataLinks = {}
	bKeypads.ESP.KeypadNetworks = {}

	if not IsValid(ply) then return end

	local wep = ply:GetActiveWeapon()
	if not IsValid(wep) then return end

	local tool = ply:GetTool()

	if tool and wep:GetClass() == "gmod_tool" and bKeypadsTools[tool.Mode] then
		local tr = ply:GetEyeTrace()
		if not tr.Hit then return end

		if tool.Mode == "bkeypads_breaker" then
			if bKeypads.Permissions:Cached(LocalPlayer(), "tools/keypad_breaker") then
				bKeypads.ESP.IgnoreZ = true

				for _, ent in ipairs(ents.GetAll()) do
					if ent.bKeypad then
						bKeypads.ESP.Halos:Add(ent, ent:GetBroken() and bKeypads.COLOR.RED or bKeypads.COLOR.GREEN)
					end
				end
			end
		else
			bKeypads.ESP.IgnoreZ = tool.Mode ~= "bkeypads_fading_door"

			if tool.Mode == "bkeypads_admin_tool" then
				if bKeypads.Permissions:Cached(LocalPlayer(), "tools/admin_tool") then
					if IsValid(tool.LinkingKeypad) then
						local fadingDoorLinks = bKeypads.FadingDoors:GetLinks(tool.LinkingKeypad)
						if fadingDoorLinks then
							for ent, linkData in pairs(fadingDoorLinks) do
								local access_mode, link = next(linkData)
								if not IsValid(link) then continue end

								local espColor = access_mode_iter[access_mode]

								bKeypads.ESP.Halos:Add(ent, espColor)
								table.insert(bKeypads.ESP.DataLinks, { tool.LinkingKeypad, ent, espColor, nil, true } )

								if tool.TargetEnt == ent or not isLinking then
									bKeypads.ESP.Halos:Add(tool.LinkingKeypad, espColor)
								end
							end
						end

						local mapLinks = bKeypads.MapLinking:GetLinks(tool.LinkingKeypad)
						if mapLinks then
							for ent, linkData in pairs(mapLinks) do
								local access_mode, link = next(linkData)
								if not IsValid(link) then continue end

								local espColor = access_mode_iter[access_mode]

								bKeypads.ESP.Halos:Add(ent, espColor)
								table.insert(bKeypads.ESP.DataLinks, { tool.LinkingKeypad, ent, espColor, link:HasGeneralFlag(bKeypads.MapLinking.F_PSEUDOLINK) or nil, true } )

								if tool.TargetEnt == ent then
									bKeypads.ESP.Halos:Add(tool.LinkingKeypad, espColor)
								end
							end
						end
					end

					if IsValid(tr.Entity) and not tr.Entity:IsWorld() then
						if bKeypads.FadingDoors:IsFadingDoor(tr.Entity) then
							local fadingDoorLinks = bKeypads.FadingDoors:GetLinks(tr.Entity)
							if fadingDoorLinks then
								for keypad, linkData in pairs(fadingDoorLinks) do
									local access_mode, link = next(linkData)
									if not IsValid(link) then continue end

									local espColor = access_mode_iter[access_mode]

									bKeypads.ESP.Halos:Add(keypad, espColor)
									bKeypads.ESP.Halos:Add(tr.Entity, espColor)
									table.insert(bKeypads.ESP.DataLinks, { keypad, tr.Entity, espColor, nil, true } )
								end
							end
						elseif bKeypads.MapLinking:IsLinkEntity(tr.Entity) then
							local mapLinks = bKeypads.MapLinking:GetLinks(tr.Entity)
							if mapLinks then
								for keypad, linkData in pairs(mapLinks) do
									local access_mode, link = next(linkData)
									if not IsValid(link) then continue end

									local espColor = access_mode_iter[access_mode]

									bKeypads.ESP.Halos:Add(keypad, espColor)
									bKeypads.ESP.Halos:Add(tr.Entity, espColor)
									table.insert(bKeypads.ESP.DataLinks, { keypad, tr.Entity, espColor, link:HasGeneralFlag(bKeypads.MapLinking.F_PSEUDOLINK) or nil, true } )
								end
							end
						end
					end

					if IsValid(tool.LinkingKeypad) then
						bKeypads.ESP:DrawKeypadNetwork(tool.LinkingKeypad)
					end
				end
			else
				local showLinks = showLinkTools[tool.Mode] and IsValid(tool.LinkingKeypad)
				local isLinking = showLinks and tool.Mode == "bkeypads_linker"

				if tool.Mode == "bkeypads_fading_door" and IsValid(tr.Entity) and not tr.Entity:IsWorld() then
					if bKeypads.FadingDoors:IsFadingDoor(tr.Entity) then
						bKeypads.ESP.Halos:Add(tr.Entity, bKeypads.COLOR.PINK)

						-- Draw links to this fading door
						local fadingDoorLinks = bKeypads.FadingDoors:GetLinks(tr.Entity)
						if fadingDoorLinks then
							for keypad, linkData in pairs(fadingDoorLinks) do
								local access_mode, link = next(linkData)
								if not IsValid(link) then continue end

								local espColor = access_mode_iter[access_mode]

								bKeypads.ESP.Halos:Add(keypad, espColor)
								table.insert(bKeypads.ESP.DataLinks, { keypad, tr.Entity, espColor, nil, true } )
								
								-- Draw keypad networks
								bKeypads.ESP:DrawKeypadNetwork(keypad)
							end
						end
					elseif bKeypads.FadingDoors:CanFadingDoor(tr.Entity) then
						bKeypads.ESP.Halos:Add(tr.Entity, bKeypads.COLOR.WHITE)
					end
				end

				if showLinks then
					local fadingDoorLinks = bKeypads.FadingDoors:GetLinks(tool.LinkingKeypad)
					if fadingDoorLinks then
						for ent, linkData in pairs(fadingDoorLinks) do
							local access_mode, link = next(linkData)
							if not IsValid(link) then continue end

							local espColor = access_mode_iter[access_mode]

							bKeypads.ESP.Halos:Add(ent, espColor)
							table.insert(bKeypads.ESP.DataLinks, { tool.LinkingKeypad, ent, espColor, nil, true } )

							if tool.TargetEnt == ent or not isLinking then
								bKeypads.ESP.Halos:Add(tool.LinkingKeypad, espColor)
							end
						end
					end

					local mapLinks = bKeypads.MapLinking:GetLinks(tool.LinkingKeypad)
					if mapLinks then
						for ent, linkData in pairs(mapLinks) do
							local access_mode, link = next(linkData)
							if not IsValid(link) then continue end

							local espColor = access_mode_iter[access_mode]

							bKeypads.ESP.Halos:Add(ent, espColor)
							table.insert(bKeypads.ESP.DataLinks, { tool.LinkingKeypad, ent, espColor, link:HasGeneralFlag(bKeypads.MapLinking.F_PSEUDOLINK) or nil, true } )

							if tool.TargetEnt == ent then
								bKeypads.ESP.Halos:Add(tool.LinkingKeypad, espColor)
							end
						end
					end

					if isLinking and not tool.DisableTargetESP then
						local canLink, keypadLinkSource, keypadLinkTarget
						if IsValid(tool.TargetEnt) and tool.TargetEnt.bKeypad then
							canLink, keypadLinkSource, keypadLinkTarget = bKeypads.KeypadLinking:TranslatePair(tool.LinkingKeypad, tool.TargetEnt)
						end

						if canLink then
							local espColor = keypadLinkSource == keypadLinkTarget:LinkProxy() and bKeypads.COLOR.RED or bKeypads.COLOR.PINK
							bKeypads.ESP.Halos:Add(keypadLinkSource, espColor)
							bKeypads.ESP.Halos:Add(keypadLinkTarget, espColor)

							table.insert(bKeypads.ESP.DataLinks, { keypadLinkSource, keypadLinkTarget, espColor } )

							bKeypads.ESP:DrawKeypadNetwork(keypadLinkSource, keypadLinkTarget)
							return
						else
							local espColor = (tool.TargetAccessMode ~= nil and (tool.TargetAccessMode and bKeypads.COLOR.GREEN or bKeypads.COLOR.RED)) or (tool.AccessMode and bKeypads.COLOR.GREEN or bKeypads.COLOR.RED)

							if canLink == false then
								table.insert(bKeypads.ESP.DataLinks, { tool.LinkingKeypad, tr.HitPos, espColor } )
								bKeypads.ESP.Halos:Add(tool.LinkingKeypad, espColor)
							else
								local espColor = (tool.TargetAccessMode ~= nil and (tool.TargetAccessMode and bKeypads.COLOR.GREEN or bKeypads.COLOR.RED)) or (tool.AccessMode and bKeypads.COLOR.GREEN or bKeypads.COLOR.RED)
								table.insert(bKeypads.ESP.DataLinks, { tool.LinkingKeypad, (tool.SnapToEnt and IsValid(tool.TargetEnt) and tool.TargetEnt) or tr.HitPos, espColor, tool.MapLinking and tobool(tool:GetClientNumber("map_pseudolink")) } )

								bKeypads.ESP.Halos:Add(tool.LinkingKeypad, espColor)

								if IsValid(tool.TargetEnt) then
									bKeypads.ESP.Halos:Add(tool.TargetEnt, espColor)
								end
							end
						end
					end

					if IsValid(tool.LinkingKeypad) then
						bKeypads.ESP:DrawKeypadNetwork(tool.LinkingKeypad)
					end
				end
			end
		end
	end
end
hook.Add("CalcView", "bKeypads.ESP.Watch", bKeypads.ESP.Watch)
--addons/bkeypads/lua/bkeypads/cl_properties_display.lua:
bKeypads.Properties = {}
bKeypads.Properties.Drawing = {}

-- Remove any previous property sheets
for _, keypad in ipairs(bKeypads.Keypads) do
	if not IsValid(keypad) then continue end
	if IsValid(keypad.m_pKeypadProperties) then
		keypad.m_pKeypadProperties:Remove()
	end
	keypad.m_pKeypadProperties = nil
end

local propertiesW = 300

local displayProps = {

	--## Name ##--

	{
		Name = "Name",
		{
			{
				Name = "Name",
				Type = "Generic",
				ConVar = "bkeypads_name",
				SetValue = function(keypad)
					return keypad:GetKeypadName()
				end
			},
		}
	},

	--## Persistence ##--

	{
		Name = "Persistence",
		{
			{
				Name = "Persistent",
				Type = "Boolean",
				SetValue = function(keypad)
					return keypad:GetPersist()
				end
			}
		}
	},

	--## General ##--

	{
		Name = "General",
		{
			{
				Name = "AuthMode",
				Type = "Generic",
				SetValueConVar = function()
					local AuthMode = GetConVar("bkeypads_auth_mode"):GetInt()
					if AuthMode == 1 then
						return bKeypads.L("PIN")
					elseif AuthMode == 2 then
						return bKeypads.L("FaceID")
					elseif AuthMode == 3 then
						return bKeypads.L("Keycard")
					end
					return "ERROR"
				end,
				SetValue = function(keypad)
					local AuthMode = keypad:LinkProxy():GetAuthMode()
					if AuthMode == 1 then
						return bKeypads.L("PIN")
					elseif AuthMode == 2 then
						return bKeypads.L("FaceID")
					elseif AuthMode == 3 then
						return bKeypads.L("Keycard")
					end
					return "ERROR"
				end
			},

			{
				Name = "ScanningStatus",
				Type = "Generic",
				SetValue = function(keypad)
					local ScanningStatus = keypad:GetScanningStatus()
					if ScanningStatus == 0 then
						return bKeypads.L("LoadingEllipsis")
					elseif ScanningStatus == 1 then
						return bKeypads.L("Idle")
					elseif ScanningStatus == 2 then
						return bKeypads.L("Scanning")
					elseif ScanningStatus == 3 then
						return bKeypads.L("AccessGranted")
					elseif ScanningStatus == 4 then
						return bKeypads.L("AccessDenied")
					end
					return "ERROR"
				end
			},

			{
				NameRaw = "Wiremod",
				Type = "Boolean",
				SetValueConVar = function()
					return WireLib ~= nil and bKeypads.Permissions:Cached(LocalPlayer(), "keypads/wiremod") and GetConVar("bkeypads_wiremod"):GetBool()
				end,
				SetValue = function(keypad)
					return keypad:GetWiremodEnabled()
				end
			},

			{
				Name = "Broken",
				Type = "Boolean",
				SetValue = function(keypad)
					return keypad:GetBroken()
				end
			},

			{
				Name = "Hacked",
				Type = "Boolean",
				SetValue = function(keypad)
					return keypad:GetHacked()
				end
			},

			{
				Name = "Uncrackable",
				Type = "Boolean",
				SetValueConVar = function()
					return bKeypads.Permissions:Cached(LocalPlayer(), "keypads/uncrackable_keypads") and not GetConVar("bkeypads_uncrackable"):GetBool()
				end,
				SetValue = function(keypad)
					return keypad:GetUncrackable()
				end
			},

			{
				Name = "Freeze",
				Type = "Boolean",
				ConVar = "bkeypads_freeze",
				SetValue = function(keypad)
					local phys = keypad:GetPhysicsObject()
					return not IsValid(phys) or not phys:IsMotionEnabled()
				end
			},

			{
				Name = "Weld",
				Type = "Boolean",
				ConVar = "bkeypads_weld",
				SetValue = function(keypad)
					return keypad:GetWelded()
				end,
			}
		}
	},

	--## Access Granted ##--

	{
		Name = "AccessGranted",
		{
			{
				Name = "Key",
				Type = "Generic",
				SetValueConVar = function()
					local key = GetConVar("bkeypads_granted_key"):GetInt()
					return key == 0 and "" or language.GetPhrase(input.GetKeyName(key))
				end,
				SetValue = function(keypad)
					return keypad:GetGrantedKey() == 0 and "" or language.GetPhrase(input.GetKeyName(keypad:GetGrantedKey()))
				end
			},

			{
				Name = "Time",
				Type = "Int",
				SetValueConVar = function()
					return math.Clamp(
						GetConVar("bkeypads_granted_hold_time"):GetInt(),
						bKeypads.Config.Scanning.AccessGranted.MinimumTime,
						bKeypads.Config.Scanning.AccessGranted.MaximumTime == 0 and ((2^31)-1) or bKeypads.Config.Scanning.AccessGranted.MaximumTime
					)
				end,
				SetValue = function(keypad)
					return keypad:GetGrantedTime()
				end
			},

			{
				Name = "Delay",
				Type = "Int",
				SetValueConVar = function()
					return math.Clamp(GetConVar("bkeypads_granted_initial_delay"):GetInt(), 0, (2^31)-1)
				end,
				SetValue = function(keypad)
					return keypad:GetGrantedDelay()
				end
			},

			{
				Name = "Repeats",
				Type = "Int",
				SetValueConVar = function()
					return math.Clamp(GetConVar("bkeypads_granted_repeats"):GetInt(), 0, bKeypads.Config.Scanning.AccessGranted.MaximumRepeats)
				end,
				SetValue = function(keypad)
					return keypad:GetGrantedRepeats()
				end
			},

			{
				Name = "RepeatDelay",
				Type = "Int",
				SetValueConVar = function()
					return math.Clamp(GetConVar("bkeypads_granted_repeat_delay"):GetInt(), bKeypads.Config.Scanning.AccessGranted.MinimumRepeatDelay, (2^31)-1)
				end,
				SetValue = function(keypad)
					return keypad:GetGrantedRepeatDelay()
				end
			},
		}
	},

	--## Access Denied ##--

	{
		Name = "AccessDenied",
		{
			{
				Name = "Key",
				Type = "Generic",
				SetValueConVar = function()
					local key = GetConVar("bkeypads_denied_key"):GetInt()
					return key == 0 and "" or language.GetPhrase(input.GetKeyName(key))
				end,
				SetValue = function(keypad)
					return keypad:GetDeniedKey() == 0 and "" or language.GetPhrase(input.GetKeyName(keypad:GetDeniedKey()))
				end
			},

			{
				Name = "Time",
				Type = "Int",
				SetValueConVar = function()
					return math.Clamp(
						GetConVar("bkeypads_denied_hold_time"):GetInt(),
						bKeypads.Config.Scanning.AccessDenied.MinimumTime,
						bKeypads.Config.Scanning.AccessDenied.MaximumTime == 0 and ((2^31)-1) or bKeypads.Config.Scanning.AccessDenied.MaximumTime
					)
				end,
				SetValue = function(keypad)
					return keypad:GetDeniedTime()
				end
			},

			{
				Name = "Delay",
				Type = "Int",
				SetValueConVar = function()
					return math.Clamp(GetConVar("bkeypads_denied_initial_delay"):GetInt(), 0, (2^31)-1)
				end,
				SetValue = function(keypad)
					return keypad:GetDeniedDelay()
				end
			},

			{
				Name = "Repeats",
				Type = "Int",
				SetValueConVar = function()
					return math.Clamp(GetConVar("bkeypads_denied_repeats"):GetInt(), 0, bKeypads.Config.Scanning.AccessDenied.MaximumRepeats)
				end,
				SetValue = function(keypad)
					return keypad:GetDeniedRepeats()
				end
			},

			{
				Name = "RepeatDelay",
				Type = "Int",
				SetValueConVar = function()
					return math.Clamp(GetConVar("bkeypads_denied_repeat_delay"):GetInt(), bKeypads.Config.Scanning.AccessDenied.MinimumRepeatDelay, (2^31)-1)
				end,
				SetValue = function(keypad)
					return keypad:GetDeniedRepeatDelay()
				end
			},
		}
	},

	--## Appearance ##--

	{
		Name = "Appearance",
		{
			{
				Name = "BackgroundColor",
				Type = "VectorColor",
				SetValueConVar = function()
					return bKeypads.Permissions:Cached(LocalPlayer(), "keypads/appearance/bg_color") and bKeypads:IntToColor(GetConVar("bkeypads_background_color"):GetInt()) or bKeypads.COLOR.GMODBLUE
				end,
				SetValue = function(keypad)
					return keypad.CustomBackgroundColor or keypad.TargetBackgroundColor or bKeypads.COLOR.GMODBLUE
				end
			},

			{
				Name = "ImageURL",
				Type = "Generic",
				SetValueConVar = function()
					if not bKeypads.Permissions:Cached(LocalPlayer(), "keypads/appearance/custom_img") then return "" end

					local image_url = GetConVar("bkeypads_image_url"):GetString()
					if #image_url > 0 and bKeypads.KeypadImages:VerifyURL(image_url, true) then
						return image_url
					end

					return ""
				end,
				SetValue = function(keypad)
					return keypad:GetImageURL()
				end
			},

			{
				Name = "Slanted",
				Type = "Boolean",
				SetValue = function(keypad)
					return keypad:GetSlanted()
				end
			},
		}
	},

	--## Notifications ##--

	{
		Name = "Notifications",
		{
			{
				Name = "AccessGranted",
				Type = "Boolean",
				ConVar = "bkeypads_granted_notification",
				SetValue = function(keypad)
					return keypad:GetGrantedNotifications()
				end
			},

			{
				Name = "AccessDenied",
				Type = "Boolean",
				ConVar = "bkeypads_denied_notification",
				SetValue = function(keypad)
					return keypad:GetDeniedNotifications()
				end
			},
		}
	},
}

local function KeypadPropertiesPerformLayout(self, w, h)
	DProperties.PerformLayout(self, w, h)

	if self:GetCanvas():GetVBar():IsVisible() then
		self:GetCanvas():SizeToChildren(false, true)
		self:SizeToChildren(false, true)
	end
end

if IsValid(bKeypads_ConVarProperties) then
	bKeypads_ConVarProperties:Remove()
	bKeypads_ConVarProperties = nil
end
local function ConVarPropertiesThink(self)
	for _, category in ipairs(displayProps) do
		for _, prop in ipairs(category[1]) do
			if not prop.SetValueConVar and not prop.ConVar then continue end
			local row = self.Props[category.NameRaw or category.Name][prop.NameRaw or prop.Name]
			if prop.SetValueConVar then
				row:SetValue(prop.SetValueConVar())
			else
				local ConVar = GetConVar(prop.ConVar)
				local ConVarValue
				if prop.Type == "Generic" then
					ConVarValue = ConVar:GetString()
				elseif prop.Type == "Boolean" then
					ConVarValue = ConVar:GetBool()
				elseif prop.Type == "Int" then
					ConVarValue = ConVar:GetInt()
				elseif prop.Type == "Float" then
					ConVarValue = ConVar:GetFloat()
				end
				row:SetValue(ConVarValue)
			end
		end
	end
end

function bKeypads.Properties:Update(keypad, use_convars)	
	local KeypadProperties = bKeypads.Properties:CreatePropertiesPanel(keypad, use_convars)

	local isInWorldSpace = KeypadProperties:GetParent() == vgui.GetWorldPanel()

	if not use_convars then
		for _, category in ipairs(displayProps) do
			for _, prop in ipairs(category[1]) do
				local row = KeypadProperties.Props[category.NameRaw or category.Name][prop.NameRaw or prop.Name]
				row:SetValue(prop.SetValue(keypad))
			end
		end
	end

	if isInWorldSpace and not KeypadProperties.m_b3D2D then
		KeypadProperties.m_b3D2D = true

		KeypadProperties:SetMouseInputEnabled(false)
		KeypadProperties:SetKeyboardInputEnabled(false)
		KeypadProperties:SetPaintedManually(true)

		KeypadProperties:SetWide(propertiesW)
		KeypadProperties.PerformLayout = KeypadPropertiesPerformLayout
	end

	return KeypadProperties
end

function bKeypads.Properties:CreatePropertiesPanel(keypad, use_convars)
	if use_convars then
		if IsValid(bKeypads_ConVarProperties) then return bKeypads_ConVarProperties end
	else
		if IsValid(keypad.m_pKeypadProperties) then return keypad.m_pKeypadProperties end
	end

	local KeypadProperties = vgui.Create("DProperties")

	if use_convars then
		bKeypads_ConVarProperties = KeypadProperties
		KeypadProperties.Think = ConVarPropertiesThink
	else
		keypad.m_pKeypadProperties = KeypadProperties
	end

	KeypadProperties:SetMouseInputEnabled(false)
	KeypadProperties:SetKeyboardInputEnabled(false)
	KeypadProperties:SetPaintedManually(true)

	KeypadProperties:SetWide(propertiesW)
	KeypadProperties.PerformLayout = KeypadPropertiesPerformLayout

	KeypadProperties.Props = {}
	for _, category in ipairs(displayProps) do
		KeypadProperties.Props[category.Name] = {}
		for _, prop in ipairs(category[1]) do
			if use_convars and (not prop.SetValueConVar and not prop.ConVar) then continue end

			local options

			if prop.Type == "Float" or prop.Type == "Int" then
				options = {
					min = -math.huge,
					max = math.huge
				}
			end

			local row = KeypadProperties:CreateRow(category.NameRaw or bKeypads.L(category.Name), prop.NameRaw or (bKeypads.L(prop.Name):gsub(":", "")))
			row:Setup(prop.Type, options)

			if prop.Type == "Generic" then
				local function blockChange(self)
					local actualVal
					if use_convars then
						if prop.SetValueConVar then
							actualVal = prop.SetValueConVar()
						else
							actualVal = GetConVar(prop.ConVar):GetString()
						end
					elseif IsValid(keypad) then
						actualVal = prop.SetValue(keypad)
					else
						return
					end
					if self:GetText() ~= actualVal then
						self:SetText(actualVal)
					end
				end

				local DTextEntry = row:Find("DTextEntry")
				DTextEntry:SetUpdateOnType(true)
				DTextEntry.OnValueChange = blockChange
				DTextEntry.OnChange = blockChange
				DTextEntry.OnTextChanged = blockChange
				DTextEntry.OnEnter = blockChange
				DTextEntry.OnFocusChanged = blockChange
				DTextEntry.OnKeyCode = blockChange
				DTextEntry.AllowInput = function() return true end
			elseif prop.Type == "Boolean" then
				row:Find("DCheckBox"):SetMouseInputEnabled(false)
			elseif prop.Type == "VectorColor" then
				row:Find("DButton"):SetMouseInputEnabled(false)
			elseif prop.Type == "Int" then
				local DNumSlider = row:Find("DNumSlider")
				DNumSlider.Slider:SetVisible(false)
				DNumSlider.Scratch:SetMouseInputEnabled(false)
				DNumSlider:SetMouseInputEnabled(false)
				row.Inner.Paint = nil
			end

			KeypadProperties.Props[category.NameRaw or category.Name][prop.NameRaw or prop.Name] = row
		end
	end

	return KeypadProperties
end

function bKeypads.Properties:TrashPropertiesPanel(keypad)
	if IsValid(keypad) and IsValid(keypad.m_pKeypadProperties) then
		keypad.m_pKeypadProperties:Remove()
		keypad.m_pKeypadProperties = nil
	end
end
--addons/bkeypads/lua/bkeypads/cl_tutorial_scenes.lua:
-- Want to add your own tutorial scenes?
-- https://github.com/WilliamVenner/bkeypads-tutorials

-- This file is also loaded on the server so that models can be precached.
local function Model(mdl)
  util.PrecacheModel(mdl)
  return _G.Model(mdl)
end

if SERVER then bKeypads.Tutorial = {} end
local L = SERVER and function() end or bKeypads.L

bKeypads.Tutorial.Categories = {
  {
    Name = "Billy's Keypads",

    Scenes = {
      --[[{
        Name = "%YouTubeTutorials%",
        Tooltip = "%YouTubeTutorialsTip%",
      },]]

      {
        Name = "%Language%",
        Function = function()
          gui.ActivateGameUI()
          Derma_Message(L"TutorialLanguageMsg", "Billy's Keypads", L"Dismiss")
        end,
      },

      {
        Name = "%Settings%",
        Setting = "",
        Function = function()
          Derma_Message(L"TutorialSettingsMsg", "Billy's Keypads", L"Dismiss")
        end,
      },
    }
  },

  {
    Name = "%TutorialQuickStart%",

    Scenes = {
      "WHAT_IS_KEYPAD",
      "KEYPAD_PLACEMENT",
      "KEYPAD_ACCESS",
      "WHAT_IS_FADING_DOOR",
      "LINK_FADING_DOOR",
    }
  },

  --[=[{
    Name = "%Setting_Accessibility%",

    Scenes = {
      {
        Name = "%Setting_Dyslexia%",
        Setting = "dyslexia",
      },

      --[[{ TODO
        Name = "%Setting_ColorBlindness%",
        Setting = "color_blindness",
      },]]
    }
  },]=]

  {
    Name = "Keypads",

    Scenes = {
      {
        Shortcut = "WHAT_IS_KEYPAD",
        Name = "%TutorialWhatIsKeypad%",

        Frames = {
          {
            CameraFocus = "KEYPAD",
            CameraCenterZ = true,

            Caption = "%TutorialWhatIsKeypadCaption1%",
            Duration = 3,

            Objects = {
              {
                Class = "bkeypad",
                ID = "KEYPAD",
                Angle = Angle(0, -180, 0),

                NetworkVars = {
                  ScanningStatus = bKeypads.SCANNING_STATUS.IDLE,
                  AuthMode = bKeypads.AUTH_MODE.FACEID,
                  BackgroundColor = bKeypads.STOOL.RainbowBackgroundColor,
                }
              }
            }
          },

          {
            CircularCam = false,
            CameraFocus = "KEYPAD",
            CameraCenterZ = true,
            FOV = 90,

            Caption = "%TutorialWhatIsKeypadCaption2%",
            Duration = 4,

            Objects = {
              {
                Class = "bkeypad",
                ID = "KEYPAD",
                Angle = Angle(0, -90, 0),

                NetworkVars = {
                  ScanningStatus = bKeypads.SCANNING_STATUS.IDLE,
                  AuthMode = bKeypads.AUTH_MODE.PIN,
                }
              },
              {
                Class = "bkeypad",
                Translate = Vector(-10, 0, 0),
                Angle = Angle(0, -90, 0),

                NetworkVars = {
                  ScanningStatus = bKeypads.SCANNING_STATUS.IDLE,
                  AuthMode = bKeypads.AUTH_MODE.FACEID,
                  BackgroundColor = bKeypads.STOOL.RainbowBackgroundColor,
                }
              },
              {
                Class = "bkeypad",
                Translate = Vector(10, 0, 0),
                Angle = Angle(0, -90, 0),

                NetworkVars = {
                  ScanningStatus = bKeypads.SCANNING_STATUS.IDLE,
                  AuthMode = bKeypads.AUTH_MODE.KEYCARD,
                  BackgroundColor = bKeypads.STOOL.RainbowBackgroundColor,
                }
              },
            }
          },

          {
            Caption = "%TutorialWhatIsKeypadCaption3%",
            
            Objects = {
              {
                Class = "Player",
                ID = "PLAYER",
                Translate = Vector(-75, 0, 0),
                OutOfFrame = true,
                
                MasterSequence = true,
                Sequence = {
                  -- Walk towards fading door
                  {
                    WalkTo = Vector(-30, 0, 0),
                  },

                  -- Stop, scan
                  { Duration = bKeypads.Config.Scanning.ScanTimes.FaceID or 1.5 },

                  -- Open, wait
                  { Duration = .5 },

                  -- Walk through it
                  { WalkTo = Vector(30, 0, 0) },

                  {
                    "taunt_dance",
                    Duration = 2
                  }
                }
              },

              {
                Class = "prop_physics",
                Model = Model("models/props_building_details/Storefront_Template001a_Bars.mdl"),

                Sequence = {
                  nil,

                  nil,

                  { function(self) self:SetMaterial("models/wireframe") end },

                  nil,

                  { function(self) self:SetMaterial("") end },
                }
              },

              {
                Class = "bkeypad",
                Translate = Vector(-1.28, 0, 60),
                Angle = Angle(0, 180, 0),

                NetworkVars = {
                  ScanningStatus = bKeypads.SCANNING_STATUS.IDLE,
                  AuthMode = bKeypads.AUTH_MODE.FACEID,
                  BackgroundColor = 0x0096FF,
                },
                
                Sequence = {
                  nil,

                  {
                    function(self)
                      self:SetScanningStatus(bKeypads.SCANNING_STATUS.SCANNING)
                      self:SetScanningEntity(bKeypads.Tutorial:GetSceneObject("PLAYER"))
                      surface.PlaySound("npc/turret_floor/deploy.wav")

                      surface.PlaySound("npc/turret_floor/ping.wav")
                      timer.Create("bKeypads.Tutorial.ScanPing", self:GetScanPingInterval(), 0, function()
                        if not IsValid(self) or not bKeypads or not bKeypads.Tutorial or not IsValid(bKeypads.Tutorial.Menu) or not bKeypads.Tutorial.Menu:IsVisible() then timer.Remove("bKeypads.Tutorial.ScanPing") return end
                        surface.PlaySound("npc/turret_floor/ping.wav")
                      end)
                    end
                  },

                  {
                    function(self)
                      timer.Remove("bKeypads.Tutorial.ScanPing")
                      self:SetScanningStatus(bKeypads.SCANNING_STATUS.GRANTED)
                      self:SetScanningEntity(nil)
                      surface.PlaySound("buttons/button9.wav")
                    end
                  },

                  nil,

                  {
                    function(self)
                      self:SetScanningStatus(bKeypads.SCANNING_STATUS.IDLE)
                      surface.PlaySound("npc/turret_floor/retract.wav")
                    end
                  },
                }
              },
            }
          },
        }
      },

      --[[{
        Name = "%TutorialPlacingKeypads%",
        Tooltip = "%TutorialPlacingKeypadsTip%",
      },

      {
        Name = "%TutorialKeypadAppearance%",
        Tooltip = "%TutorialKeypadAppearanceTip%",
      },]]

      {
        Shortcut = "KEYPAD_ACCESS",
        Name = "%TutorialKeypadAccess%",
        Tooltip = "%TutorialKeypadAccessTip%",

        Frames = {
          {
            CameraFocus = "KEYPAD",
            CameraCenterZ = true,

            Caption = "%TutorialKeypadAccessCaption1%",
            Duration = 3,

            Objects = {
              {
                Class = "bkeypad",
                ID = "KEYPAD",
                Angle = Angle(0, -180, 0),

                NetworkVars = {
                  ScanningStatus = bKeypads.SCANNING_STATUS.IDLE,
                  AuthMode = bKeypads.AUTH_MODE.FACEID,
                  BackgroundColor = bKeypads.STOOL.RainbowBackgroundColor,
                }
              }
            }
          },

          {
            CircularCam = false,

            Caption = "%TutorialKeypadAccessCaption2%",
            Duration = 3,

            Objects = {
              {
                Class = "bkeypad",
                Angle = Angle(0, -90, 0),

                NetworkVars = {
                  ScanningStatus = bKeypads.SCANNING_STATUS.DENIED,
                  AuthMode = bKeypads.AUTH_MODE.FACEID,
                }
              },
              {
                Class = "bkeypad",
                Translate = Vector(-10, 0, 0),
                Angle = Angle(0, -90, 0),

                NetworkVars = {
                  ScanningStatus = bKeypads.SCANNING_STATUS.GRANTED,
                  AuthMode = bKeypads.AUTH_MODE.FACEID,
                }
              },
            }
          },

          {
            CircularCam = false,
            FOV = 80,
            Caption = "%TutorialKeypadAccessCaption3%",
            Duration = 4,

            Objects = {
              {
                Class = "Player",
                Angle = Angle(0, -90, 0),
                --Sequence = { { "gesture_wave" } },
              },
              {
                Class = "Player",
                Model = Model("models/player/monk.mdl"),
                Translate = Vector(-40, 0, 0),
                Angle = Angle(0, -90, 0),
                --Sequence = { { "gesture_agree" } },
              },
              {
                Class = "Player",
                Model = Model("models/player/police.mdl"),
                Translate = Vector(-80, 0, 0),
                Angle = Angle(0, -90, 0),
                --Sequence = { { "gesture_voicechat" } },
              },
              {
                Class = "Player",
                Model = Model("models/player/swat.mdl"),
                Translate = Vector(-120, 0, 0),
                Angle = Angle(0, -90, 0),
                --Sequence = { { "gesture_salute" } },
              }
            }
          },

          {
            Caption = "%TutorialKeypadAccessCaption4%",

            Panels = {
              {
                "DForm",

                function(self, w, h)
                  self:SetSize(w, h)
                  self:Center()
                  
                  bKeypads.STOOL.BuildCPanel(self)

                  self.Think = self.bKeypads_Think
                  self.Paint = nil

                  self:GetChildren()[1]:SetVisible(false) -- Hide header

                  -- Hide children
                  for _, c in ipairs(self:GetChildren()[2]:GetChildren()[1]:GetChildren()) do
                    c:SetVisible(false)
                  end

                  -- Show access category
                  self.AccessCategory:GetParent():SetVisible(true)
                  self.AccessCategory:AuthModeChanged(bKeypads.AUTH_MODE.FACEID)

                  self:InvalidateChildren(true)
                end,
              }
            }
          },
        }
      },

      {
        Name = "%TutorialPaymentKeypads%",

        Frames = {
          {
            Caption = "%TutorialPaymentKeypadsCaption1%",
            CameraFocus = "KEYPAD",
            CameraCenterZ = true,
            CameraTranslate = Vector(0, 0, (scripted_ents.Get("bkeypad") or {PaymentPolyHeight = 2.5}).PaymentPolyHeight),
            SceneTranslate = Vector(0, 0, (scripted_ents.Get("bkeypad") or {PaymentPolyHeight = 2.5}).PaymentPolyHeight),

            Duration = 3,

            Objects = {
              {
                Class = "bkeypad",
                ID = "KEYPAD",
                Angle = Angle(0, -180, 0),

                NetworkVars = {
                  ScanningStatus = bKeypads.SCANNING_STATUS.IDLE,
                  AuthMode = bKeypads.AUTH_MODE.FACEID,
                  BackgroundColor = bKeypads.STOOL.RainbowBackgroundColor,
                  PaymentAmount = 500,
                }
              }
            }
          },

          {
            Caption = "%TutorialPaymentKeypadsCaption2%",
            CircularCam = false,
            CameraPos = Vector(-25, -30, 63),
            CameraAngle = Angle(0, 60, 0),

            Duration = 3,

            Objects = {
              {
                ID = "PLAYER",
                Class = "Player",
                Translate = Vector(-20, 0, 0),
              },
              {
                Class = "bkeypad",
                Angle = Angle(0, -180, 0),
                Translate = Vector(0, 0, 63),

                NetworkVars = {
                  ScanningStatus = bKeypads.SCANNING_STATUS.SCANNING,
                  AuthMode = bKeypads.AUTH_MODE.FACEID,
                  PaymentAmount = 500,
                },
                
                Sequence = {
                  {
                    function(self)
                      self:SetScanningStatus(bKeypads.SCANNING_STATUS.SCANNING)
                      self:SetScanningEntity(bKeypads.Tutorial:GetSceneObject("PLAYER"))
                      surface.PlaySound("npc/turret_floor/deploy.wav")

                      surface.PlaySound("npc/turret_floor/ping.wav")
                      timer.Create("bKeypads.Tutorial.ScanPing", self:GetScanPingInterval(), 0, function()
                        if not IsValid(self) or not bKeypads or not bKeypads.Tutorial or not IsValid(bKeypads.Tutorial.Menu) or not bKeypads.Tutorial.Menu:IsVisible() then timer.Remove("bKeypads.Tutorial.ScanPing") return end
                        surface.PlaySound("npc/turret_floor/ping.wav")
                      end)
                    end,

                    Duration = bKeypads.Config.Scanning.ScanTimes.FaceID or 1.5,
                  },

                  {
                    function(self)
                      timer.Remove("bKeypads.Tutorial.ScanPing")
                      self:SetScanningStatus(bKeypads.SCANNING_STATUS.DENIED)
                      self:SetScanningEntity(nil)
                      surface.PlaySound("buttons/button11.wav")
                    end
                  },
                }
              },
            }
          },

          {
            Caption = "%TutorialPaymentKeypadsCaption3%",
            CircularCam = false,
            CameraPos = Vector(-25, -30, 63),
            CameraAngle = Angle(0, 60, 0),

            Duration = 3,

            Objects = {
              {
                ID = "PLAYER",
                Class = "Player",
                Translate = Vector(-20, 0, 0),
              },
              {
                Class = "bkeypad",
                Angle = Angle(0, -180, 0),
                Translate = Vector(0, 0, 63),

                NetworkVars = {
                  ScanningStatus = bKeypads.SCANNING_STATUS.SCANNING,
                  AuthMode = bKeypads.AUTH_MODE.FACEID,
                  PaymentAmount = 500,
                },
                
                Sequence = {
                  {
                    function(self)
                      self:SetScanningStatus(bKeypads.SCANNING_STATUS.SCANNING)
                      self:SetScanningEntity(bKeypads.Tutorial:GetSceneObject("PLAYER"))
                      surface.PlaySound("npc/turret_floor/deploy.wav")

                      surface.PlaySound("npc/turret_floor/ping.wav")
                      timer.Create("bKeypads.Tutorial.ScanPing", self:GetScanPingInterval(), 0, function()
                        if not IsValid(self) or not bKeypads or not bKeypads.Tutorial or not IsValid(bKeypads.Tutorial.Menu) or not bKeypads.Tutorial.Menu:IsVisible() then timer.Remove("bKeypads.Tutorial.ScanPing") return end
                        surface.PlaySound("npc/turret_floor/ping.wav")
                      end)
                    end,

                    Duration = bKeypads.Config.Scanning.ScanTimes.FaceID or 1.5,
                  },

                  {
                    function(self)
                      timer.Remove("bKeypads.Tutorial.ScanPing")
                      self:SetScanningStatus(bKeypads.SCANNING_STATUS.GRANTED)
                      self:SetScanningEntity(nil)
                      surface.PlaySound("buttons/button9.wav")

                      self.Particles = CreateParticleSystem(self, "bkeypads_cash", PATTACH_POINT, 0, self:WorldSpaceCenter())
                      self.Particles:SetShouldDraw(false)
                    end
                  },
                }
              },
            }
          },
          
          {
            Caption = "%TutorialPaymentKeypadsCaption4%",
            CameraFocus = "KEYPAD",
            CameraCenterZ = true,
            CameraTranslate = Vector(0, 0, (scripted_ents.Get("bkeypad") or {PaymentPolyHeight = 2.5}).PaymentPolyHeight),
            SceneTranslate = Vector(0, 0, (scripted_ents.Get("bkeypad") or {PaymentPolyHeight = 2.5}).PaymentPolyHeight),

            Duration = 3,

            Objects = {
              {
                Class = "bkeypad",
                ID = "KEYPAD",
                Angle = Angle(0, -180, 0),

                NetworkVars = {
                  ScanningStatus = bKeypads.SCANNING_STATUS.IDLE,
                  AuthMode = bKeypads.AUTH_MODE.FACEID,
                  BackgroundColor = bKeypads.STOOL.RainbowBackgroundColor,
                  PaymentAmount = 500,
                },

                Sequence = { { function(self) self.m_bRequiresPayment = false end } }
              }
            }
          },
        },
      },

      --"LINK_KEYPADS",
    }
  },

  --[[
  {
    Name = "%TutorialKeypadTypes%",

    Scenes = {
      {
        Name = "%PIN%",
        Tooltip = "%TutorialPINTip%",
      },
      
      {
        Name = "%FaceID%",
        Tooltip = "%TutorialFaceIDTip%",
      },

      {
        Name = "%KeycardScanner%",
        Tooltip = "%TutorialKeycardScannerTip%",
      },

      "KEYPAD_ACCESS",
    }
  },]]

  {
    Name = "%tool.bkeypads_fading_door.name%",

    Scenes = {
      {
        Shortcut = "WHAT_IS_FADING_DOOR",
        Name = "%TutorialWhatIsFadingDoor%",

        Frames = {
          {
            Caption = "%TutorialWhatIsFadingDoorCaption%",

            Objects = {
              {
                Class = "Player",
                Translate = Vector(-75, 0, 0),
                OutOfFrame = true,
                
                MasterSequence = true,
                Sequence = {
                  -- Walk towards fading door
                  {
                    WalkTo = Vector(-20, 0, 0),
                  },

                  -- Stop, wait
                  { Duration = .5 },

                  -- Open, wait
                  { Duration = .5 },

                  -- Walk through it
                  {
                    WalkTo = Vector(75, 0, 0),
                  },
                }
              },

              {
                Class = "prop_physics",
                Model = Model("models/props_building_details/Storefront_Template001a_Bars.mdl"),

                Sequence = {
                  nil,

                  nil,

                  { function(self) self:SetMaterial("models/wireframe") end },

                  nil,

                  {
                    function(self) self:SetMaterial("") end,
                    Duration = 2
                  },
                }
              },
            }
          },

          {
            Caption = "%TutorialWhatIsFadingDoorCaption2%",

            Objects = {
              {
                Class = "Player",
                Translate = Vector(-60, 0, 0),
                OutOfFrame = true,

                Weapon = "models/weapons/w_toolgun.mdl",
                HoldType = "revolver",

                MasterSequence = true,
                Sequence = {
                  { Duration = 1 },

                  { ShootToolgun = "FADING_DOOR", Duration = 2 },
                },
              },

              {
                ID = "FADING_DOOR",
                Class = "prop_physics",
                Model = Model("models/props_building_details/Storefront_Template001a_Bars.mdl"),

                Sequence = {
                  { Halo = { Color = color_white, BlurX = 1, BlurY = 1, DrawPasses = 2, Additive = true, IgnoreZ = false } },

                  { Halo = { Color = bKeypads.COLOR.PINK, BlurX = 1, BlurY = 1, DrawPasses = 2, Additive = true, IgnoreZ = false } },
                },
              },
            }
          },

          {
            Caption = "%TutorialWhatIsFadingDoorCaption3%",

            Objects = {
              {
                Class = "Player",
                Translate = Vector(-150, 0, 0),
                OutOfFrame = true,
                
                MasterSequence = true,
                Sequence = {
                  -- Walk towards fading door
                  { WalkTo = Vector(0, 0, 0) },

                  -- Stop, wait
                  { Caption = "%TutorialWhatIsFadingDoorCaption4%", Duration = 1 },

                  -- Walk out of it
                  { WalkTo = Vector(150, 0, 0) },
                }
              },

              {
                Class = "prop_physics",
                Model = Model("models/props_building_details/Storefront_Template001a_Bars.mdl"),
                Material = "models/wireframe",

                Sequence = {
                  nil,
                  
                  nil,

                  {
                    function(self)
                      timer.Simple(.25, function()
                        if not IsValid(self) then return end
                        self:SetMaterial("")
                      end)
                    end,
                  },
                }
              },
            }
          },
        }
      },

      --[[{
        Name = "%TutorialConfiguringFadingDoors%",
      },]]

      "LINK_FADING_DOOR"
    }
  },

  {
    Name = "%Linking%",

    Scenes = {
      --[[{
        Shortcut = "LINK_KEYPADS",
        Name = "%TutorialLinkingKeypads%",
        Tip = "%TutorialLinkingKeypadsTip%",
      },]]

      {
        Shortcut = "LINK_FADING_DOOR",
        Name = "%TutorialLinkingFadingDoors%",
        Tip = "%TutorialLinkingFadingDoorsTip%",

        Frames = {
          {
            CircularCam = false,
            CircularCamFactor = .5 * math.pi,
            Caption = "%TutorialLinkingFadingDoorsStep1%",
            Raycast = true,

            Objects = {
              {
                ID = "PLAYER",
                Class = "Player",
                Translate = Vector(-150, 0, 0),
                OutOfFrame = true,

                Weapon = "models/weapons/w_toolgun.mdl",
                HoldType = "revolver",
                
                MasterSequence = true,
                Sequence = {
                  -- Walk towards fading door
                  { WalkTo = Vector(-60, 0, 0) },

                  -- Look at the fading door
                  {
                    LookAt = "FADING_DOOR",
                    Duration = 1,
                  },

                  -- Shoot toolgun
                  { ShootToolgun = "FADING_DOOR", Duration = 1 },

                  -- Look at the keypad
                  {
                    function() surface.PlaySound("npc/combine_soldier/gear5.wav") end,

                    Caption = "%TutorialLinkingFadingDoorsStep2%",
                    LookAt = "KEYPAD",
                    Duration = 2,
                  },

                  -- Shoot toolgun
                  {
                    ShootToolgun = "KEYPAD",
                    Duration = 2,
                    DrawLinkingBeam = { "KEYPAD", {"FADING_DOOR"}, bKeypads.COLOR.GREEN },
                  },

                  -- Look at the fading door
                  {
                    Caption = "%TutorialLinkingFadingDoorsStep3%",
                    LookAt = "FADING_DOOR",
                    Duration = 2,

                    DrawLinkingBeam = { "KEYPAD", {"FADING_DOOR"}, bKeypads.COLOR.GREEN },
                  },

                  -- Shoot toolgun
                  {
                    Caption = "%TutorialEasy%",
                    ShootToolgun = "FADING_DOOR",
                    DrawLinkingBeam = { "KEYPAD", "FADING_DOOR", bKeypads.COLOR.GREEN, false, true },
                    Duration = 2
                  },

                  -- Unequip toolgun
                  {
                    Caption = "%TutorialLinkingFadingDoorsStep4%",
                    Weapon = false,
                    Duration = 1,
                  },
                  
                  -- Look at keypad
                  {
                    LookAt = "KEYPAD",
                    Duration = 1,
                  },

                  -- Scan
                  { Duration = bKeypads.Config.Scanning.ScanTimes.FaceID or 1.5 },

                  -- Open, wait
                  {
                    LookAt = "FADING_DOOR",
                    Caption = "%TutorialLinkingFadingDoorsStep5%",
                    Duration = 1
                  },

                  -- Walk through it
                  { WalkTo = Vector(60, 0, 0) },

                  {
                    "taunt_dance",
                    Duration = 2
                  }
                }
              },

              {
                Class = "prop_physics",
                Model = Model("models/hunter/plates/plate05x05.mdl"),
                Material = "phoenix_storms/metalset_1-2",
                Angle = Angle(90, 45, 0),
                Translate = Vector(-10, 50, 60),
              },
              
              {
                ID = "FADING_DOOR",
                Class = "prop_physics",
                Model = Model("models/props_building_details/Storefront_Template001a_Bars.mdl"),

                Sequence = {
                  nil,

                  { Halo = { Color = color_white, BlurX = 1, BlurY = 1, DrawPasses = 2, Additive = true, IgnoreZ = false } },

                  { Halo = { Color = bKeypads.COLOR.PINK, BlurX = 1, BlurY = 1, DrawPasses = 2, Additive = true, IgnoreZ = false } },

                  nil,

                  nil,

                  { Halo = { Raycast = true, Color = bKeypads.COLOR.GREEN, BlurX = 1, BlurY = 1, DrawPasses = 2, Additive = true, IgnoreZ = false } },

                  { Halo = { Color = bKeypads.COLOR.GREEN, BlurX = 1, BlurY = 1, DrawPasses = 2, Additive = true, IgnoreZ = false } },

                  nil,

                  nil,
                  
                  nil,

                  { function(self) self:SetMaterial("models/wireframe") end },

                  nil,

                  { function(self) self:SetMaterial("") end },
                },
              },
              
              {
                ID = "KEYPAD",
                Class = "bkeypad",
                Translate = Vector(-10 + 1.75 - (4.252956 / 2), 50 + (4.252956 / 2), 60 + (5.782784 / 2)),
                Angle = Angle(0, 180 + 45, 0),

                NetworkVars = {
                  ScanningStatus = bKeypads.SCANNING_STATUS.IDLE,
                  AuthMode = bKeypads.AUTH_MODE.FACEID,
                  BackgroundColor = 0x0096FF
                },

                Sequence = {
                  nil,

                  nil,

                  nil,

                  nil,

                  { Halo = { Color = bKeypads.COLOR.GREEN, BlurX = 1, BlurY = 1, DrawPasses = 2, Additive = true, IgnoreZ = false } },

                  { Halo = { Color = bKeypads.COLOR.GREEN, BlurX = 1, BlurY = 1, DrawPasses = 2, Additive = true, IgnoreZ = false } },

                  { Halo = { Color = bKeypads.COLOR.GREEN, BlurX = 1, BlurY = 1, DrawPasses = 2, Additive = true, IgnoreZ = false } },

                  nil,

                  nil,

                  {
                    function(self)
                      self:SetScanningStatus(bKeypads.SCANNING_STATUS.SCANNING)
                      self:SetScanningEntity(bKeypads.Tutorial:GetSceneObject("PLAYER"))
                      surface.PlaySound("npc/turret_floor/deploy.wav")

                      surface.PlaySound("npc/turret_floor/ping.wav")
                      timer.Create("bKeypads.Tutorial.ScanPing", self:GetScanPingInterval(), 0, function()
                        if not IsValid(self) or not bKeypads or not bKeypads.Tutorial or not IsValid(bKeypads.Tutorial.Menu) or not bKeypads.Tutorial.Menu:IsVisible() then timer.Remove("bKeypads.Tutorial.ScanPing") return end
                        surface.PlaySound("npc/turret_floor/ping.wav")
                      end)
                    end
                  },

                  {
                    function(self)
                      timer.Remove("bKeypads.Tutorial.ScanPing")
                      self:SetScanningStatus(bKeypads.SCANNING_STATUS.GRANTED)
                      self:SetScanningEntity(nil)
                      surface.PlaySound("buttons/button9.wav")
                    end
                  },

                  nil,

                  {
                    function(self)
                      self:SetScanningStatus(bKeypads.SCANNING_STATUS.IDLE)
                      surface.PlaySound("npc/turret_floor/retract.wav")
                    end
                  },
                }
              },
            },
          },
        },
      },

      --"MAP_OBJECTS",
    }
  },

  --[[
  {
    Name = "%MapObjects%",

    Scenes = {
      {
        Shortcut = "MAP_OBJECTS",
        Name = "%MapObjects%",
        Tip = "%TutorialLinkingMapObjectsTip%",
      },

      {
        Name = "%TutorialMapDoors%",
      },

      {
        Name = "%TutorialMapButtons%",
      },
    }
  },]]
}

if SERVER then
  AddCSLuaFile()
  bKeypads.Tutorial = nil
else
  hook.Run("bKeypads.TutorialScenes")
end
--addons/bkeypads/lua/bkeypads/sh_custom_access.lua:
bKeypads.CustomAccess = {}

function bKeypads.CustomAccess:Reset()
	bKeypads.CustomAccess.UserConfig = {}
	bKeypads.CustomAccess.UserConfig.Enabled = false
	bKeypads.CustomAccess.UserConfig.TeamGroups = {}
	bKeypads.CustomAccess.UserConfig.LuaFunctions = {}
end
bKeypads.CustomAccess:Reset()

function bKeypads:AddTeamGroup(name, teamGroup)
	if not isstring(name) then
		error("Tried to create a custom access team group with an invalid name: (" .. tostring(name) .. ") Name must be a string, but you put a " .. type(name) .. "!")
		return
	end

	local unenumeratedName = name
	local i = 2
	while bKeypads.CustomAccess.UserConfig.TeamGroups[name] do
		name = unenumeratedName .. " (" .. i .. ")"
		i = i + 1
	end

	if isnumber(teamGroup) then
		bKeypads.CustomAccess.UserConfig.TeamGroups[name] = { [teamGroup] = true }
	elseif istable(teamGroup) then
		for _, teamIndex in pairs(teamGroup) do
			bKeypads.CustomAccess.UserConfig.TeamGroups[name] = bKeypads.CustomAccess.UserConfig.TeamGroups[name] or {}
			bKeypads.CustomAccess.UserConfig.TeamGroups[name][teamIndex] = true
		end
	else
		error("Invalid custom access team group: (" .. tostring(teamGroup) .. ") You did not supply a table, TEAM_NAME or team index.")
		return
	end

	bKeypads.CustomAccess.UserConfig.Enabled = true
end

function bKeypads:AddCustomGroup(name, func)
	if not isstring(name) then
		error("Tried to create a custom access Lua function with an invalid name: (" .. tostring(name) .. ") Name must be a string, but you put a " .. type(name) .. "!")
		return
	elseif not isfunction(func) then
		error("Tried to create a custom access Lua function with an invalid function: (" .. tostring(func) .. ") How did you even manage that? The second argument must be a function, but you put a " .. type(func) .. "!")
		return
	end

	local unenumeratedName = name
	local i = 2
	while bKeypads.CustomAccess.UserConfig.LuaFunctions[name] do
		name = unenumeratedName .. " (" .. i .. ")"
		i = i + 1
	end

	bKeypads.CustomAccess.UserConfig.LuaFunctions[name] = func

	bKeypads.CustomAccess.UserConfig.Enabled = true
end

local function LoadConfig()
	if SERVER and bKeypads.simplerr then
		local succ, err = bKeypads.simplerr.runFile("bkeypads_custom_access.lua")
		if not succ then
			MsgC("\n")
			ErrorNoHalt(err or "[ERROR] UNKNOWN error in \"bkeypads_custom_access.lua\"")
		end
	else
		include("bkeypads_custom_access.lua")
	end
end
hook.Add("bKeypads.ConfigUpdated", "bKeypads.CustomAccess", LoadConfig)
LoadConfig()

--## Addons ##--

bKeypads.CustomAccess.Addons = {}
bKeypads.CustomAccess.Addons.Enabled = false
bKeypads.CustomAccess.Addons.Registry = {}
bKeypads.CustomAccess.Addons.KeyTable = {}

function bKeypads.CustomAccess.Addons:IsValid(path)
	return bKeypads.CustomAccess.AddonFunctions[path] ~= nil
end

function bKeypads.CustomAccess.Addons:Test(path, ply, keypad)
	return bKeypads.CustomAccess.Addons.KeyTable[path] ~= nil and bKeypads.CustomAccess.Addons.KeyTable[path].Function ~= nil and bKeypads.CustomAccess.Addons.KeyTable[path].Function(
		ply, keypad,
		keypad:GetAuthMode() == bKeypads.AUTH_MODE.KEYCARD and (IsValid(ply:GetWeapon("bkeycard")) and ply:GetWeapon("bkeycard")) or nil
	) or false
end

local function ID(str)
	return (str:lower():gsub("[^a-z0-9]", "-"))
end

local customAccessMeta = {}
customAccessMeta.__index = customAccessMeta
function customAccessMeta:__call(parent, icon, name, id, func)
	assert(icon ~= nil, "Missing icon")
	assert(name ~= nil, "Missing name")
	assert(id == nil or isstring(id), "ID should be a string or nil")
	assert(func == nil or isfunction(func), "Member function should be a function or nil")

	self.ID = (parent and (parent.ID .. "/") or "") .. ID(id or name)
	self.Name = name
	self.Icon = icon

	if func then
		self.Function = func
	else
		self.Members = {}
	end

	if parent then
		self.Parent = parent
		self.Addon = self.Parent.Addon or self.Parent
	else
		bKeypads.CustomAccess.Addons.Registry[self.ID] = self
	end

	bKeypads.CustomAccess.Addons.KeyTable[self.ID] = self

	return self
end
function customAccessMeta:AddCategory(icon, name, id)
	assert(self.Members ~= nil, "You can't add a category to a member, use :AddCategory() instead")
	return self.Members[table.insert(self.Members, setmetatable({}, customAccessMeta)(self, icon, name, id))]
end
function customAccessMeta:AddMember(icon, name, func, id)
	return self.Members[table.insert(self.Members, setmetatable({}, customAccessMeta)(self, icon, name, id, func))]
end

function bKeypads.CustomAccess:AddAddon(icon, name, id)
	bKeypads.CustomAccess.Addons.Enabled = true
	return setmetatable({}, customAccessMeta)(nil, icon, name, id)
end

for _, f in ipairs((file.Find("bkeypads/custom/*.lua", "LUA"))) do
	if SERVER then
		AddCSLuaFile("bkeypads/custom/" .. f)
	end
	include("bkeypads/custom/" .. f)
end
--lua/autorun/aang.lua:
local function AddPlayerModel( name, model )

	list.Set( "PlayerOptionsModel", name, model )
	player_manager.AddValidModel( name, model )

end


AddPlayerModel( "Senator Aang",		"models/player/tiki/aang.mdl" )

--lua/autorun/ackbar.lua:
player_manager.AddValidModel( "ackbar", "models/player/valley/ackbar.mdl" ) 
list.Set( "PlayerOptionsModel",  "ackbar", "models/player/valley/ackbar.mdl" ) 

--addons/ballistic_shields/lua/bs_config.lua:
include( "ballistic_shields/sh_bs_util.lua" )

--------------------- BALLISTIC SHIELDS V1.1.4 -------------------------

---- CONFIG ----
-- AVALAIBLE LANGUAGES - English
bshields.config.language = "German"
-- DISABLE HUD
bshields.config.disablehud = false
-- MINIMUM RIOT SHIELD DAMAGE
bshields.config.rshielddmgmin = 16
-- MAXIMUM RIOT SHIELD DAMAGE
bshields.config.rshielddmgmax = 25
-- HEAVY SHIELD EXPLOSION DAMAGE REDUCITON (IN %)
bshields.config.hshieldexpl = 25
-- HEAVY SHIELD MELEE DAMAGE REDUCTION (IN %)
bshields.config.hshieldmelee = 0
-- RIOT SHIELD MELEE DAMAGE REDUCTION (IN %)
bshields.config.rshieldmelee = 60
-- HEAVY SHIELD BREACH COOLDOWN (IN SECONDS)
bshields.config.hshieldcd = 20
-- DOOR RESPAWN TIMER (IN SECONDS)
bshields.config.doorrespawn = 60
-- MAXIMUM AMOUNT OF DEPLOYED SHIELDS
bshields.config.maxshields = 3
-- SHOULD FADING DOORS BE BREACHABLE?
bshields.config.breachfdoors = false
-- ALLOW BREACHING UNOWNED DOORS
bshields.config.breachudoors = false

-------- CUSTOM TEXTURES, LEAVE "" FOR DEFAULT "POLICE" TEXT. ----------
--- FOR EDITING USE THE 256x256 TEMPLATE INCLUDED IN THE MAIN FOLDER ---

-- HEAVY SHIELD
bshields.config.hShieldTexture = "https://i.imgur.com/afyGHiK.png"
-- RIOT SHIELD
bshields.config.rShieldTexture = "https://i.imgur.com/afyGHiK.png"
-- DEPLOYABLE SHIELD
bshields.config.dShieldTexture = "https://i.imgur.com/afyGHiK.png" 
-- PLAYERS MIGHT HAVE TO RECONNECT IN ORDER TO SEE THE NEW TEXTURES! ---

-- [CW2 ONLY] YOU NEED THIS ADDON: https://steamcommunity.com/sharedfiles/filedetails/?id=1771994451
-- SHOULD RIOT SHIELD BE BULLETPROOF? --
bshields.config.rshieldbp = true
--addons/ballistic_shields/lua/ballistic_shields/sh_bs_util.lua:
bshields = bshields or {}
bshields.config = bshields.config or {}

bshields.shields = {
	{
		[1] = {
			["angles"] = Angle(4,6,-14),
			["position"] = Vector(5,10,-5)
		},
		[2] = {
			["angles"] = Angle(6,1,-15),
			["position"] = Vector(6,10,-5)
		},
		[3] = {
			["angles"] = Angle(4,6,-14),
			["position"] = Vector(5,10,-5)
		}
	},
	{
		[1] = {
			["angles"] = Angle(-12,0,0),
			["position"] = Vector(6,-4,-8)
		},
		[2] = {
			["angles"] = Angle(-12,0,0),
			["position"] = Vector(1,-3,-12)
		},
		[3] = {
			["angles"] = Angle(-12,0,0),
			["position"] = Vector(6,-3,-12)
		}
	},
	{
		[1] = {
			["angles"] = Angle(70,78,-16),
			["position"] = Vector(1,-7,-13)
		},
		[2] = {
			["angles"] = Angle(70,78,-16),
			["position"] = Vector(1,-6,-22)
		},
		[3] = {
			["angles"] = Angle(70,78,-16),
			["position"] = Vector(1,-8,-12)
		}
	}
}

--addons/climb_swep_2/lua/autorun/cl_falleffect.lua:
// Falling & Roll Effect for Climb SWEP2
CreateClientConVar("climbswep2_windsound", 1, true, false)
CreateClientConVar("climbswep2_falleffect_allweps", 0, true, false)
local PrevCurT = 0
local CurAngles = nil
local Rot = 0
local Random
local Snd
local Snd2
hook.Add("CreateMove", "ClimbFall", function(cmd)

	local Ply = LocalPlayer()
	if !Snd then

		Snd = CreateSound(Ply, Sound("player/heartbeat1.wav"))
		Snd:Play()
		Snd:ChangeVolume(0, 0)
		Snd:ChangePitch(100, 0)

		Snd2 = CreateSound(Ply, Sound("ambient/ambience/Wind_Light02_loop.wav"))
		Snd2:Play()
		Snd2:ChangeVolume(0, 0)

	end
	if !IsValid(Ply) or !IsValid(Ply:GetActiveWeapon()) then return
	elseif Ply:GetVelocity().z > -900 or (GetConVarNumber("climbswep2_falleffect_allweps") == 0 and Ply:GetActiveWeapon():GetClass() != "climb_swep2") or !Ply:Alive() or Ply:GetMoveType() != MOVETYPE_WALK then

		if PrevCurT > 0 then

			cmd:SetViewAngles(Angle(CurAngles.p, CurAngles.y, 0))
			CurAngles = nil
			Snd:ChangeVolume(0, 0)
			Snd:ChangePitch(100, 0)
			Snd2:ChangeVolume(0, 0)
			hook.Remove("RenderScreenspaceEffects", "ClimbFallBlur")
			PrevCurT = 0

		end		
		return

	end
	if PrevCurT == 0 then

		PrevCurT = CurTime()
		local function DrawEffect()
			--DrawMotionBlur(0.1, Time/5, 0.01)
			local Time = CurTime() - PrevCurT
			local Colour = {}
			Colour[ "$pp_colour_addr" ] = 0
			Colour[ "$pp_colour_addg" ] = 0
			Colour[ "$pp_colour_addb" ] = 0
			Colour[ "$pp_colour_brightness" ] = 0
			Colour[ "$pp_colour_contrast" ] = (1 - Time/7.5)
			Colour[ "$pp_colour_colour" ] = (1 - Time/7.5)
			Colour[ "$pp_colour_mulr" ] = 0
			Colour[ "$pp_colour_mulg" ] = 0
			Colour[ "$pp_colour_mulb" ] = 0
			DrawColorModify(Colour)
			DrawMotionBlur(math.Clamp(0.75-Time/100, 0.25, 1), math.Clamp(Time/10, 0, 0.75), 0.05)

		end
		hook.Add("RenderScreenspaceEffects", "ClimbFallBlur", DrawEffect)

	end

	if !IsValid(CurAngles) then CurAngles = cmd:GetViewAngles(); end
	

	
	local Time = (CurTime() - PrevCurT) * (8 + (CurTime() - PrevCurT) * 2)
	if Time/25 < 1 then Snd:ChangeVolume(math.Clamp(Time/25, 0, 1), 0) end
	if Time < 101 then Snd:ChangePitch(100 + Time, 0); if GetConVarNumber("climbswep2_windsound") == 1 then Snd2:ChangeVolume(Time/100, 0) else Snd2:ChangeVolume(0, 0) end end

	CurAngles.p = math.Round(CurAngles.p) < 75 and math.Round(CurAngles.p) + 0.5 or math.Round(CurAngles.p) - 0.5

	cmd:SetViewAngles(Angle(CurAngles.p, CurAngles.y + math.sin(Time) * 1.25, 0))

end)
--lua/autorun/dathomir_pm.lua:
player_manager.AddValidModel( "Nightsister", "models/player/dathomir/pm_nightsister.mdl" );
list.Set( "PlayerOptionsModel",  "Nightsister", "models/player/dathomir/pm_nightsister.mdl" );

player_manager.AddValidModel( "Mother Talzin", "models/player/dathomir/pm_nightsister_mothertalzin.mdl" );
list.Set( "PlayerOptionsModel",  "Mother Talzin", "models/player/dathomir/pm_nightsister_mothertalzin.mdl" );

player_manager.AddValidModel( "Nightsister Ventress", "models/player/dathomir/pm_nightsister_ventress.mdl" );
list.Set( "PlayerOptionsModel",  "Nightsister Ventress", "models/player/dathomir/pm_nightsister_ventress.mdl" );

player_manager.AddValidModel( "Nightsister Undead", "models/player/dathomir/pm_nightsister_undead.mdl" );
list.Set( "PlayerOptionsModel",  "Nightsister Undead", "models/player/dathomir/pm_nightsister_undead.mdl" );

player_manager.AddValidModel( "Old Daka", "models/player/dathomir/pm_nightsister_olddaka.mdl" );
list.Set( "PlayerOptionsModel",  "Old Daka", "models/player/dathomir/pm_nightsister_olddaka.mdl" );

player_manager.AddValidModel( "Nightbrother", "models/player/dathomir/pm_nightbrother.mdl" );
list.Set( "PlayerOptionsModel",  "Nightbrother", "models/player/dathomir/pm_nightbrother.mdl" );

player_manager.AddValidModel( "Nightbrother Brawler", "models/player/dathomir/pm_nightbrother_brawler.mdl" );
list.Set( "PlayerOptionsModel",  "Nightbrother Brawler", "models/player/dathomir/pm_nightbrother_brawler.mdl" );


--lua/autorun/droid_pmselector.lua:
list.Set( "PlayerOptionsModel", "B1 Battle Droid", "models/player/b1battledroids/b1_base.mdl" )
player_manager.AddValidModel( "B1 Battle Droid", "models/player/b1battledroids/b1_base.mdl" )
player_manager.AddValidHands( "B1 Battle Droid", "models/player/b1hands/b1_base_hands.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "B1 Training Battle Droid", "models/player/b1battledroids/b1_base_training.mdl" )
player_manager.AddValidModel( "B1 Training Battle Droid", "models/player/b1battledroids/b1_base_training.mdl" )
player_manager.AddValidHands( "B1 Training Battle Droid", "models/player/b1hands/b1_training_hands.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "B1 Geonosis Battle Droid", "models/player/b1battledroids/b1_geo.mdl" )
player_manager.AddValidModel( "B1 Geonosis Battle Droid", "models/player/b1battledroids/b1_geo.mdl" )
player_manager.AddValidHands( "B1 Geonosis Battle Droid", "models/player/b1hands/b1_geo_hands.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "B1 Geonosis Commander Battle Droid", "models/player/b1battledroids/b1_geo_com.mdl" )
player_manager.AddValidModel( "B1 Geonosis Commander Battle Droid", "models/player/b1battledroids/b1_geo_com.mdl" )
player_manager.AddValidHands( "B1 Geonosis Battle Droid", "models/player/b1hands/b1_geo_hands.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "B1 Security Battle Droid", "models/player/b1battledroids/b1_base_security.mdl" )
player_manager.AddValidModel( "B1 Security Battle Droid", "models/player/b1battledroids/b1_base_security.mdl" )
player_manager.AddValidHands( "B1 Security Battle Droid", "models/player/b1hands/b1_base_hands.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "B1 Pilot Battle Droid", "models/player/b1battledroids/b1_base_pilot.mdl" )
player_manager.AddValidModel( "B1 Pilot Battle Droid", "models/player/b1battledroids/b1_base_pilot.mdl" )
player_manager.AddValidHands( "B1 Pilot Battle Droid", "models/player/b1hands/b1_base_hands.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "B1 Commander Battle Droid", "models/player/b1battledroids/b1_base_com.mdl" )
player_manager.AddValidModel( "B1 Commander Battle Droid", "models/player/b1battledroids/b1_base_com.mdl" )
player_manager.AddValidHands( "B1 Commander Battle Droid", "models/player/b1hands/b1_base_hands.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "B1 Rocket Battle Droid", "models/player/b1battledroids/b1_rocket.mdl" )
player_manager.AddValidModel( "B1 Rocket Battle Droid", "models/player/b1battledroids/b1_rocket.mdl" )
player_manager.AddValidHands( "B1 Rocket Battle Droid", "models/player/b1hands/b1_rocket_hands.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "B1 Firefighter Battle Droid", "models/player/b1battledroids/b1_firefighter.mdl" )
player_manager.AddValidModel( "B1 Firefighter Battle Droid", "models/player/b1battledroids/b1_firefighter.mdl" )
player_manager.AddValidHands( "B1 Firefighter Battle Droid", "models/player/b1hands/b1_fire_hands.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "B1 AAT Driver Battle Droid", "models/player/b1battledroids/b1_base_aatdriver.mdl" )
player_manager.AddValidModel( "B1 AAT Driver Battle Droid", "models/player/b1battledroids/b1_base_aatdriver.mdl" )
player_manager.AddValidHands( "B1 AAT Driver Battle Droid", "models/player/b1hands/b1_aat_hands.mdl",0,"10000000" )

--addons/droideka/lua/autorun/droideka.lua:


player_manager.AddValidModel( "Droideka", 		"models/starwars/stan/droidekas/droideka.mdl" );
list.Set( "PlayerOptionsModel", "Droideka", 	"models/starwars/stan/droidekas/droideka.mdl" );

local settings = {
	["name"] = "Droideka",
	["model"] = "models/starwars/stan/droidekas/droideka.mdl",
	["developermode"] = false,
	["viewoffset"] = 100,
	["duckviewoffset"] = 90,
	["seatoffset"] = 4,
	["bodygrouptalking"] = false,
	["talkingspeed"] = 0,
	["mouthbodygroup"] = 0,
	["mouthframes"] = 0,
	["mouthstandingframe"] = 0,
	["mouthstartingframe"] = 0
}

local mEnt = FindMetaTable("Entity")

mEnt.NewSetModel = mEnt.NewSetModel || mEnt.SetModel

function mEnt:SetModel(model)

	self.NewSetModel(self, model)

	if(self:IsPlayer()) then

		hook.Run("SPM_ModelChange", self)

	end

end

if SERVER then
	util.AddNetworkString(settings["name"].."ResetModel")
	util.AddNetworkString(settings["name"].."RescaleModel")

	hook.Add("SPM_ModelChange", settings["name"].."SpawningFunction", function(ply)

		timer.Simple(0, function()
			if(SPM_Pool[ply:GetModel()] == nil) then
				ply:ResetHull()
				ply:SetViewOffset(Vector(0, 0, 64))
				ply:SetViewOffsetDucked(Vector(0, 0, 28))

				net.Start(settings["name"].."ResetModel")
				net.Send(ply)
			end
		end)

		timer.Simple(FrameTime(), function()
			if(SPM_Pool[ply:GetModel()] != nil) then
				local tab = SPM_Pool[ply:GetModel()]

				ply:SetViewOffset(Vector(0, 0, tab["viewoffset"]))
				ply:SetViewOffsetDucked(Vector(0, 0, tab["duckviewoffset"]))
				net.Start(tab["name"].."RescaleModel")
				net.Send(ply)
			end
		end)
	end)
end

if CLIENT then
	net.Receive(settings["name"].."ResetModel", function()
		local ply = LocalPlayer()

		if(IsValid(ply)) then

			ply:ResetHull()
			ply:SetViewOffset(Vector(0, 0, 64))
			ply:SetViewOffsetDucked(Vector(0, 0, 28))

		end
	end)

	net.Receive(settings["name"].."RescaleModel", function()
		local ply = LocalPlayer()

		if(IsValid(ply)) then

			ply:SetViewOffset(Vector(0, 0, settings["viewoffset"]))
			ply:SetViewOffsetDucked(Vector(0, 0, settings["duckviewoffset"]))

		end
	end)
end

hook.Add("Tick", settings["name"].."ModelFixes", function()

	for k,v in pairs(player.GetAll()) do

		if(settings["bodygrouptalking"]) then

			if(v:GetNWBool("Is"..settings["name"].."Talking") == true) then

				v:SetBodygroup(settings["mouthbodygroup"], math.floor(CurTime()*settings["talkingspeed"]%settings["mouthframes"]) + settings["mouthstartingframe"])

			else

				if(v:GetModel() == settings["model"]) then

					v:SetBodygroup(settings["mouthbodygroup"], settings["mouthstandingframe"])

				end

			end

		end

	end

end)

hook.Add("PlayerEnteredVehicle", settings["name"].."VehicleOffset", function(ply, veh)

	if(ply:InVehicle()) then

		if(ply:GetModel() == settings["model"]) then

			ply:SetPos(Vector(0, 0, settings["seatoffset"]))

		end

	end

end)

hook.Add("PostPlayerDeath", settings["name"].."RemoveDeathRagdoll", function(ply)

	if(ply:GetModel() == settings["model"]) then

		local rag = ply:GetRagdollEntity()

		if(IsValid(rag)) then

			rag:Remove()

		end

	end

end)

hook.Add("PostDrawTranslucentRenderables", settings["name"].."DeveloperMode", function()

	local ply = LocalPlayer()

	if(settings["developermode"] == true) then

		if(ply:GetModel() == settings["model"]) then

			local ePos = ply:EyePos()
			local eOffset = (ePos - ply:GetPos()).Z

			if(eOffset == settings["duckviewoffset"]) then
			end

			render.SetColorMaterial()
			render.DrawBox(ply:GetPos() , Angle(0, 0, 0), min, max, Color(255, 0, 0, 150))
			render.DrawBox(ply:EyePos(), Angle(0, 0, 0), Vector(min.X, min.Y, -1), Vector(max.X, max.Y, 1), Color(255, 255, 0, 100))

		end

	end

end)

hook.Add("Initialize", settings["name"].."SetPool", function()

	SPM_Pool = {}

	timer.Simple(FrameTime(), function()

		SPM_Pool[settings["model"]] = settings

	end)

end)

--lua/autorun/egm_ccsezurin.lua:
hook.Add("BaseModel.RegisterMaterialSets", "EGM.CWRP.501stSezurin", function()
	-- 501st Sezurin Body
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "501st_Sezurin", "501st 09 - Armor", {
		["body"] = "egm/custom_char/501st/sezurin/body/body",
		["body_mirrored"] = "egm/custom_char/501st/sezurin/body/body2",

		["kama"] = "egm/501st/attachments/kama_white",
		["kama_arc"] = "egm/custom_char/501st/sezurin/attachment/kama_arc",

		["rank_tab"] = "egm/501st/attachments/rank_tab",

		["pauldron"] = "egm/501st/attachments/pauldron",
		["pauldron_simple"] = "egm/501st/attachments/pauldron_simple",

		["ammo_arm"] = "egm/501st/attachments/ammo_arm",
		["antenna_shoulder"] = "egm/501st/attachments/antenna_shoulder",

		["holsters"] = "egm/custom_char/501st/sezurin/attachment/gear",
		["pockets"] = "egm/custom_char/501st/sezurin/attachment/gear",
	})
	-- 501st Sezurin ARF Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_arf/helmet_arf.mdl", "501st_Sezurin", "501st - 09 ARF Helmet", {
		["helmet_arf"] = "egm/custom_char/501st/sezurin/body/helmet_arf",
		["armor"] = "egm/501st/attachments/armor_side",
		["antenna_arf"] = "egm/501st/attachments/armor_side",
		["rangefinder"] = "egm/501st/attachments/rangefinder",
	})
	-- 501st Sezurin Backpack
	BaseModel:RegisterMaterialSet("models/egm/core/backpack/backpack.mdl", "501st_Sezurin", "501st - 09 Backpack", {
		["backpack"] = "egm/custom_char/501st/sezurin/attachment/heavy",
	})
	-- 501st Sezurin Sidebag
	BaseModel:RegisterMaterialSet("models/egm/core/sidebag/sidebag.mdl", "501st_Sezurin", "501st - 09 Sidebag", {
		["sidebag"] = "egm/custom_char/501st/sezurin/attachment/heavy",
		["sidebag_grenades"] = "egm/custom_char/501st/sezurin/attachment/heavy",
		["sidebag_grenades"] = "egm/custom_char/501st/sezurin/attachment/heavy",
	})
end)
--lua/autorun/egm_ccstorm.lua:
hook.Add("BaseModel.RegisterMaterialSets", "EGM.CWRP.501stStorm", function()
	-- 501st Storm Body
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "501st_Storm", "501st Storm - Armor", {
		["body"] = "egm/custom_char/501st/storm/body/body",
		["body_mirrored"] = "egm/custom_char/501st/storm/body/body2",

		["kama"] = "egm/501st/attachments/kama_black",
		["kama_arc"] = "egm/custom_char/501st/storm/attachment/kama_arc",

		["rank_tab"] = "egm/501st/attachments/rank_tab",

		["pauldron"] = "egm/501st/attachments/pauldron",
		["pauldron_simple"] = "egm/501st/attachments/pauldron_simple",
		["pauldron_big"] = "egm/501st/attachments/pauldron_big",

		["ammo_arm"] = "egm/501st/attachments/ammo_arm",
		["antenna_shoulder"] = "egm/501st/attachments/antenna_shoulder",

		["holsters"] = "egm/custom_char/501st/storm/attachment/gear",
		["pockets"] = "egm/custom_char/501st/storm/attachment/gear",
	})
	-- 501st Storm ARF Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_arf/helmet_arf.mdl", "501st_Storm", "501st - Storm ARF Helmet", {
		["helmet_arf"] = "egm/custom_char/501st/storm/body/helmet_arf",
		["armor"] = "egm/501st/attachments/armor_side",
		["antenna_arf"] = "egm/501st/attachments/armor_side",
		["rangefinder"] = "egm/501st/attachments/rangefinder",
	})
end)
--lua/autorun/egm_heads.lua:
-- Register the species head models
hook.Add("Species.RegisterModels", "EGM.CWRP.Heads", function()
	Species:RegisterHeadModel("BX", "models/egm/heads/clone_head/bx_head.mdl")
    Species:RegisterHeadModel("Klon", "models/egm/heads/clone_head/clone_head.mdl")
    Species:RegisterHeadModel("Klon Glatze ", "models/egm/heads/clone_head/clone_head_bald.mdl")
    Species:RegisterHeadModel("Klon Bly", "models/egm/heads/clone_head/clone_head_bly.mdl")
    Species:RegisterHeadModel("Klon Boil", "models/egm/heads/clone_head/clone_head_boil.mdl")
    Species:RegisterHeadModel("Klon Cody", "models/egm/heads/clone_head/clone_head_cody.mdl")
    Species:RegisterHeadModel("Klon Coric", "models/egm/heads/clone_head/clone_head_coric.mdl")
    Species:RegisterHeadModel("Klon Crys", "models/egm/heads/clone_head/clone_head_crys.mdl")
    Species:RegisterHeadModel("Klon Dogma", "models/egm/heads/clone_head/clone_head_dogma.mdl")
    Species:RegisterHeadModel("Klon Fives", "models/egm/heads/clone_head/clone_head_fives.mdl")
    Species:RegisterHeadModel("Klon Hardcase", "models/egm/heads/clone_head/clone_head_hardcase.mdl")
    Species:RegisterHeadModel("Klon Heater", "models/egm/heads/clone_head/clone_head_heater.mdl")
    Species:RegisterHeadModel("Klon Jesse", "models/egm/heads/clone_head/clone_head_jesse.mdl")
    Species:RegisterHeadModel("Klon Kix", "models/egm/heads/clone_head/clone_head_kix.mdl")
    Species:RegisterHeadModel("Klon Rex", "models/egm/heads/clone_head/clone_head_rex.mdl")
    Species:RegisterHeadModel("Klon Tup", "models/egm/heads/clone_head/clone_head_tup.mdl")
    Species:RegisterHeadModel("Klon Waxer", "models/egm/heads/clone_head/clone_head_waxer.mdl")
    Species:RegisterHeadModel("Klon Wollfe", "models/egm/heads/clone_head/clone_head_wolffe.mdl")
    Species:RegisterHeadModel("Klon Alpha", "models/egm/heads/clone_head/clone_head_alpha.mdl")
    Species:RegisterHeadModel("Klon Muzzle", "models/egm/heads/clone_head/clone_head_muzzle.mdl")
    Species:RegisterHeadModel("Klon AARC", "models/egm/heads/clone_head/clone_head_aarc.mdl")
	Species:RegisterHeadModel("Klon Atin", "models/egm/heads/clone_head/clone_head_atin.mdl")
end)
--lua/autorun/egm_jedi.lua:
// Non Lore Charaktere

player_manager.AddValidModel( "jedi_female_knight", "models/gonzo/femalejedi/knight/knight.mdl" ) 
list.Set( "PlayerOptionsModel",  "jedi_female_knight", "models/gonzo/femalejedi/knight/knight.mdl" )



// Armor
player_manager.AddValidModel( "jedi_general_female_human", "models/defcon/starwars/player/jedi_general_female_human.mdl" )
list.Set( "jedi_general_female_human", "models/defcon/starwars/player/jedi_general_female_human.mdl" )

player_manager.AddValidModel( "jedi_general_human", "models/defcon/starwars/player/jedi_general_human.mdl" )
list.Set( "jedi_general_human", "models/defcon/starwars/player/jedi_general_human.mdl" )

player_manager.AddValidModel( "jedi_general_alien", "models/defcon/starwars/player/jedi_general_alien.mdl" )
list.Set( "jedi_general_alien", "models/defcon/starwars/player/jedi_general_alien.mdl" )

player_manager.AddValidModel( "jedi_general_alien1", "models/defcon/starwars/player/jedi_general_alien1.mdl" )
list.Set( "jedi_general_alien1", "models/defcon/starwars/player/jedi_general_alien1.mdl" )

player_manager.AddValidModel( "tomackerson_human", "models/fisher/tomackerson/tomackerson_human.mdl" )
list.Set( "PlayerOptionsModel",  "tomackerson_human", "models/fisher/tomackerson/tomackerson_human.mdl" )

player_manager.AddValidModel( "tomackerson_alien", "models/fisher/tomackerson/tomackerson_alien.mdl" )
list.Set( "PlayerOptionsModel",  "tomackerson_alien", "models/fisher/tomackerson/tomackerson_alien.mdl" )



// Robe

player_manager.AddValidModel( "jedi_robe_human", "models/seven/jedi_robe_human.mdl" )
list.Set( "jedi_robe_human", "models/seven/jedi_robe_human.mdl" )

player_manager.AddValidModel( "jedi_robe_alien", "models/seven/jedi_robe_alien.mdl" )
list.Set( "jedi_robe_alien", "models/seven/jedi_robe_alien.mdl" )



// Lore Charaktere

player_manager.AddValidModel( "jedi_etain_turmukan", "models/hevoc/jedi/etain.mdl" )
list.Set( "PlayerOptionsModel",  "jedi_etain_turmukan", "models/hevoc/jedi/etain.mdl" )

player_manager.AddValidModel("jedi_ahsoka_tano","models/hosti/swcw/pm_sw_ahsoka_v2.mdl")
list.Set( "PlayerOptionsModel",  "jedi_ahsoka_tano", "models/hosti/swcw/pm_sw_ahsoka_v2.mdl" )

player_manager.AddValidModel( "jedi_aayla_secura", "models/tfa/comm/gg/pm_sw_aayala.mdl" ) 
list.Set( "PlayerOptionsModel",  "jedi_aayla_secura", "models/tfa/comm/gg/pm_sw_aayala.mdl" )

player_manager.AddValidModel( "jedi_kit_fisto", "models/tfa/comm/gg/pm_sw_fisto.mdl" ) 
list.Set( "PlayerOptionsModel",  "jedi_kit_fisto", "models/tfa/comm/gg/pm_sw_fisto.mdl" )

player_manager.AddValidModel( "jedi_quinlan_vos", "models/plocool/stallionstan/hippiejedi/quinlanvos.mdl" ) 
list.Set( "PlayerOptionsModel",  "jedi_quinlan_vos", "models/plocool/stallionstan/hippiejedi/quinlanvos.mdl" )

player_manager.AddValidModel( "jedi_eeth_koth", "models/tfa/comm/gg/pm_sw_eeth_koth.mdl" ) 
list.Set( "PlayerOptionsModel",  "jedi_eeth_koth", "models/tfa/comm/gg/pm_sw_eeth_koth.mdl" )

player_manager.AddValidModel( "jedi_adi_gallia", "models/tfa/comm/gg/pm_sw_adigallia.mdl" ) 
list.Set( "PlayerOptionsModel",  "jedi_adi_gallia", "models/tfa/comm/gg/pm_sw_adigallia.mdl" )

player_manager.AddValidModel( "jedi_barriss_offee", "models/tfa/comm/gg/pm_sw_barriss.mdl" ) 
list.Set( "PlayerOptionsModel",  "jedi_barriss_offee", "models/tfa/comm/gg/pm_sw_barriss.mdl" )

player_manager.AddValidModel( "jedi_luminara_unduli", "models/synergy/cblake/luminara_pm.mdl" ) 
list.Set( "PlayerOptionsModel",  "jedi_luminara_unduli", "models/synergy/cblake/luminara_pm.mdl" )

player_manager.AddValidModel( "jedi_shaak_ti", "models/tfa/comm/gg/pm_sw_shaakti.mdl" ) 
list.Set( "PlayerOptionsModel",  "jedi_shaak_ti", "models/tfa/comm/gg/pm_sw_shaakti.mdl" )

player_manager.AddValidModel( "jedi_ki_adi_mundi", "models/player/mundi/kiadi.mdl" ) 
list.Set( "PlayerOptionsModel",  "jedi_ki_adi_mundi", "models/player/mundi/kiadi.mdl" )

player_manager.AddValidModel( "jedi_coleman_kcaj", "models/jedi/coleman_kcaj.mdl" ) 
list.Set( "PlayerOptionsModel",  "jedi_coleman_kcaj", "models/jedi/coleman_kcaj.mdl" )

player_manager.AddValidModel( "jedi_depa_billaba", "models/jedi/depa_billaba.mdl" ) 
list.Set( "PlayerOptionsModel",  "jedi_depa_billaba", "models/jedi/depa_billaba.mdl" )

list.Set( "PlayerOptionsModel",  "jedi_jocasta_nu", "models/player/valley/Ign/jocasta/jocasta.mdl" ) 
player_manager.AddValidModel( "jedi_jocasta_nu", "models/player/valley/Ign/jocasta/jocasta.mdl" ) 

player_manager.AddValidModel( "jedi_mace_windu", "models/kaiido/mace_windu.mdl" ) 
list.Set( "PlayerOptionsModel",  "jedi_mace_windu", "models/kaiido/mace_windu.mdl" )

player_manager.AddValidModel( "jedi_obi_wan_kenobi", "models/kaiido/obi_wan.mdl" )
list.Set( "PlayerOptionsModel", "jedi_obi_wan_kenobi", "models/kaiido/obi_wan.mdl" )

player_manager.AddValidModel( "jedi_obi_wan_kenobi_general", "models/kaiido/gnl/jedi_general_male_01.mdl" )
list.Set( "PlayerOptionsModel", "jedi_obi_wan_kenobi_general", "models/kaiido/gnl/jedi_general_male_01.mdl" )

player_manager.AddValidModel( "jedi_revan", "models/epangelmatikes/revan/revan_opt.mdl" )
list.Set( "PlayerOptionsModel", "jedi_revan", "models/epangelmatikes/revan/revan_opt.mdl" )

player_manager.AddValidModel( "jedi_temple_guard", "models/epangelmatikes/templeguard/temple_guard_opt.mdl" )
list.Set( "PlayerOptionsModel", "jedi_temple_guard", "models/epangelmatikes/templeguard/temple_guard_opt.mdl" )

player_manager.AddValidModel( "jedi_tiplar", "models/player/suno/p_tiplar.mdl" )
list.Set( "PlayerOptionsModel",  "jedi_tiplar", 				"models/player/suno/p_tiplar.mdl" )

player_manager.AddValidModel( "jedi_tiplee", "models/player/suno/p_tiplee.mdl" )
list.Set( "PlayerOptionsModel",  "jedi_tiplee", 				"models/player/suno/p_tiplee.mdl" )

--lua/autorun/egm_lug.lua:
-- Register the DU Custom Charakter Lug Materials
hook.Add("BaseModel.RegisterMaterialSets", "EGM.CWRP.DULug", function()
	-- Base Lug Trooper
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "du_lug", "DU - Lug Armor", {
		["body"] = "egm/custom_char/du/lug/body",
		["body_mirrored"] = "egm/custom_char/du/lug/body_2",

		["kama"] = "egm/du/shared/heavy2", 
		["ammo_shoulder"] = "egm/du/shared/heavy2",
		["pauldron"] = "egm/du/shared/specialist",
		["ammo_arm"] = "egm/du/shared/heavy2",
	})
	-- DU Trooper Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_barc/helmet_barc.mdl", "du_lug", "DU - Lug Helmet", {
		["helmet_barc"] = "egm/custom_char/du/lug/helmet",
	})
end)
--lua/autorun/egm_pack_senate.lua:
player_manager.AddValidModel( "Senate Guard Trooper", "models/hevoc/senateguard/senateguard_trooper.mdl" ) 
list.Set( "PlayerOptionsModel",  "Senate Guard Trooper", "models/hevoc/senateguard/senateguard_trooper.mdl" )
player_manager.AddValidHands( "Senate Guard Trooper", "models/hevoc/senateguard/senateguard_trooper_hands.mdl", 6, "00000000" ) 

player_manager.AddValidModel( "Senate Guard Officer", "models/hevoc/senateguard/senateguard_officer.mdl" ) 
list.Set( "PlayerOptionsModel",  "Senate Guard Officer", "models/hevoc/senateguard/senateguard_officer.mdl" )
player_manager.AddValidHands( "Senate Guard Officer", "models/hevoc/senateguard/senateguard_trooper_hands.mdl", 6, "00000000" )

player_manager.AddValidModel( "Senate Guard Commander", "models/hevoc/senateguard/senateguard_commander.mdl" ) 
list.Set( "PlayerOptionsModel",  "Senate Guard Commander", "models/hevoc/senateguard/senateguard_commander.mdl" )
player_manager.AddValidHands( "Senate Guard Commander", "models/hevoc/senateguard/senateguard_commander_hands.mdl", 6, "00000000" )



--lua/autorun/egm_redeye.lua:
-- Register the Custom Char Redeye Materials
hook.Add("BaseModel.RegisterMaterialSets", "EGM.CWRP.212thRedeye", function()
	-- Redeye Body
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "212th_Redeye", "212th Redeye - Armor", {
		["body"] = "egm/custom_char/212th/redeye/body",
		["body_mirrored"] = "egm/custom_char/212th/redeye/body",

		["kama"] = "egm/custom_char/212th/redeye/heavy",
		["kama_arc"] = "egm/212th_new/shared/kama_arc",

		["pauldron"] = "egm/212th_new/shared/specialist",
		["pauldron_simple"] = "egm/212th_new/shared/pauldron_simple",
		["ammo_arm"] = "egm/212th_new/shared/specialist",
        ["ammo_shoulder"] = "egm/212th_new/shared/heavy",
		["strap"] = "egm/212th_new/trooper/heavy",
		
		["holsters"] = "egm/212th_new/shared/gear",

		["antenna_shoulder"] = "egm/212th_new/shared/antenna_shoulder",
    })
	-- Redeye Barc Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_barc/helmet_barc.mdl", "212th_Redeye", "212th Redeye - Barc Helmet", {
		["helmet_barc"] = "egm/custom_char/212th/redeye/helmet_barc",
		["sunvisor"] = "egm/212th_new/shared/heavy",
		["armor"] = "egm/212th_new/shared/heavy",

	})
	-- Redeye Arf Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_arf/helmet_arf.mdl", "212th_Redeye", "212th Redeye - Arf Helmet", {
		["helmet_arf"] = "egm/custom_char/212th/redeye/helmet_arf",
        ["armor"] = "egm/212th_new/ghc/helmet_parts_white",

	})
	-- Redeye Sidebag
	BaseModel:RegisterMaterialSet("models/egm/core/sidebag/sidebag.mdl", "212th_Redeye", "Redeye - Sideback", {
		["sidebag"] = "egm/custom_char/212th/redeye/heavy",
		["sidebag_datapad"] = "egm/custom_char/212th/redeye/heavy",
	})
end)
--lua/autorun/egm_scar.lua:
-- Register the 104th SCAR CC AIRBORNE material sets
hook.Add("BaseModel.RegisterMaterialSets", "EGM.CWRP.104thscarccairborneTrooper", function()
	-- 104th Custom Chars --
	-- 104th AIRBORNE SCAR Body
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "104th_scar_airborne", "Custom Char - 104th Scar Airborne Body", {
		["body"] = "egm/custom_char/104th/scar/body",
		["body_mirrored"] = "egm/custom_char/104th/scar/body",
	})
	-- 104th AIRBORNE SCAR Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_airborne/helmet_airborne.mdl", "104th_scar_airborne", "Custom Char - 104th Scar Airborne Helmet", {
		["helmet_airborne"] = "egm/custom_char/104th/scar/helmet",
		["antenna_ear_big"] = "egm/custom_char/104th/scar/antenna_ear_big",
		["rangefinder"] = "egm/custom_char/104th/scar/rangefinder",
	})
	-- 104th AIRBORNE SCAR Jetpack
	BaseModel:RegisterMaterialSet("models/egm/core/bp_jetpack/bp_jetpack.mdl", "104th_scar_airborne", "Custom Char - 104th Scar Airborne Jetpack", {
		["bp_jetpack"] = "egm/custom_char/104th/scar/bp_jetpack",
	})
	-- 104th AIRBORNE SCAR Comms
	BaseModel:RegisterMaterialSet("models/egm/core/bp_comms/bp_comms.mdl", "104th_scar_airborne", "Custom Char - 104th Scar Airborne Comms", {
		["bp_comms"] = "egm/custom_char/104th/scar/bp_comms",
	})
end)
--lua/autorun/egm_seb.lua:
-- Register the SEB material sets
hook.Add("BaseModel.RegisterMaterialSets", "EGM.CWRP.SEBTrooper", function()
	-- Delta Squad --

	-- Base Delta Squad Boss
	BaseModel:RegisterMaterialSet("models/egm/core/clone_commando/clone_commando.mdl", "seb_boss", "SEB - RC Boss Armor", {
		["body"] = "egm/seb2/delta/boss/boss_body",
	})
	-- Delta Squad Boss Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_commando/helmet_commando.mdl", "seb_boss", "SEB - RC Boss Helmet", {
		["helmet_commando"] = "egm/seb2/delta/boss/boss_helmet",
	})
	-- Delta Squad Boss Backpack
	BaseModel:RegisterMaterialSet("models/egm/core/bp_commando/bp_commando.mdl", "seb_boss", "SEB - RC Backpack Boss", {
		["bp_commando"] = "egm/seb2/delta/boss/boss_backpack",
	})

	-- Base Delta Squad Fixer
	BaseModel:RegisterMaterialSet("models/egm/core/clone_commando/clone_commando.mdl", "seb_fixer", "SEB - RC Fixer Armor", {
		["body"] = "egm/seb2/delta/fixer/fixer_body",
	})
	-- Delta Squad Fixer Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_commando/helmet_commando.mdl", "seb_fixer", "SEB - RC Fixer Helmet", {
		["helmet_commando"] = "egm/seb2/delta/fixer/fixer_helmet",
		["headset"] = "egm/seb2/delta/fixer/fixer_headset",
	})
	-- Delta Squad Fixer Backpack
	BaseModel:RegisterMaterialSet("models/egm/core/bp_commando/bp_commando.mdl", "seb_fixer", "SEB - Backpack Fixer", {
		["bp_commando"] = "egm/seb2/delta/fixer/fixer_backpack",
		["bp_commando_tech"] = "egm/seb2/delta/fixer/fixer_backpack_asset",
	})

	-- Base Delta Squad Scorch
	BaseModel:RegisterMaterialSet("models/egm/core/clone_commando/clone_commando.mdl", "seb_scorch", "SEB - RC Scorch Armor", {
		["body"] = "egm/seb2/delta/scorch/scorch_body",
		["explosives"] = "egm/seb2/delta/scorch/scorch_bombs",
	})
	-- Delta Squad Scorch Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_commando/helmet_commando.mdl", "seb_scorch", "SEB - RC Scorch Helmet", {
		["helmet_commando"] = "egm/seb2/delta/scorch/scorch_helmet",
	})
	-- Delta Squad Scorch Backpack
	BaseModel:RegisterMaterialSet("models/egm/core/bp_commando/bp_commando.mdl", "seb_scorch", "SEB - Backpack Scorch", {
		["bp_commando"] = "egm/seb2/delta/scorch/scorch_backpack",
		["bp_commando_antenna"] = "egm/seb2/delta/scorch/scorch_backpack_asset",
	})

	-- Base Delta Squad Sev
	BaseModel:RegisterMaterialSet("models/egm/core/clone_commando/clone_commando.mdl", "seb_sev", "SEB - RC Sev Armor", {
		["body"] = "egm/seb2/delta/sev/sev_body",
		["bacta"] = "egm/seb2/delta/sev/sev_bacta",
	})
	-- Delta Squad Sev Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_commando/helmet_commando.mdl", "seb_sev", "SEB - RC Sev Helmet", {
		["helmet_commando"] = "egm/seb2/delta/sev/sev_helmet",
	})
	-- Delta Squad Sev Backpack
	BaseModel:RegisterMaterialSet("models/egm/core/bp_commando/bp_commando.mdl", "seb_sev", "SEB - Backpack Sev", {
		["bp_commando"] = "egm/seb2/delta/sev/sev_backpack",
	})

	-- Omega Squad --

	-- Base Omega Squad Fi
	BaseModel:RegisterMaterialSet("models/egm/core/clone_commando/clone_commando.mdl", "seb_fi", "SEB - RC Fi Armor", {
		["body"] = "egm/seb2/omega/fi/fi_body",
		["bacta"] = "egm/seb2/omega/fi/fi_bacta",
		["explosives"] = "egm/seb2/omega/darman/darman_bombs",
	})
	-- Omega Squad Fi Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_commando/helmet_commando.mdl", "seb_fi", "SEB - RC Fi Helmet", {
		["helmet_commando"] = "egm/seb2/omega/fi/fi_helmet",
		["headset"] = "egm/seb2/omega/atin/atin_headset",
	})
	-- Omega Squad Fi Backpack
	BaseModel:RegisterMaterialSet("models/egm/core/bp_commando/bp_commando.mdl", "seb_fi", "SEB - RC Backpack Fi", {
		["bp_commando"] = "egm/seb2/omega/fi/fi_backpack",
		["bp_commando_antenna"] = "egm/seb2/omega/darman/darman_backpack_asset",
		["bp_commando_tech"] = "egm/seb2/omega/atin/atin_backpack_asset",
	})

	-- Base Omega Squad Darman
	BaseModel:RegisterMaterialSet("models/egm/core/clone_commando/clone_commando.mdl", "seb_darman", "SEB - RC Darman Armor", {
		["body"] = "egm/seb2/omega/fi/fi_body",
		["explosives"] = "egm/seb2/omega/darman/darman_bombs",
		["bacta"] = "egm/seb2/omega/fi/fi_bacta",
	})
	-- Omega Squad Darman Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_commando/helmet_commando.mdl", "seb_darman", "SEB - RC Darman Helmet", {
		["helmet_commando"] = "egm/seb2/omega/fi/fi_helmet",
		["headset"] = "egm/seb2/omega/atin/atin_headset",
	})
	-- Omega Squad Darman Backpack
	BaseModel:RegisterMaterialSet("models/egm/core/bp_commando/bp_commando.mdl", "seb_darman", "SEB - RC Backpack Darman", {
		["bp_commando"] = "egm/seb2/omega/fi/fi_backpack",
		["bp_commando_antenna"] = "egm/seb2/omega/darman/darman_backpack_asset",
		["bp_commando_tech"] = "egm/seb2/omega/atin/atin_backpack_asset",
	})

	-- Base Omega Squad Atin
	BaseModel:RegisterMaterialSet("models/egm/core/clone_commando/clone_commando.mdl", "seb_atin", "SEB - RC Atin Armor", {
		["body"] = "egm/seb2/omega/fi/fi_body",
		["bacta"] = "egm/seb2/omega/fi/fi_bacta",
		["explosives"] = "egm/seb2/omega/darman/darman_bombs",
	})
	-- Omega Squad Atin Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_commando/helmet_commando.mdl", "seb_atin", "SEB - RC Atin Helmet", {
		["helmet_commando"] = "egm/seb2/omega/fi/fi_helmet",
		["headset"] = "egm/seb2/omega/atin/atin_headset",
	})
	-- Omega Squad Atin Backpack
	BaseModel:RegisterMaterialSet("models/egm/core/bp_commando/bp_commando.mdl", "seb_atin", "SEB - RC Backpack Atin", {
		["bp_commando"] = "egm/seb2/omega/fi/fi_backpack",
		["bp_commando_tech"] = "egm/seb2/omega/atin/atin_backpack_asset",
		["bp_commando_antenna"] = "egm/seb2/omega/darman/darman_backpack_asset",
	})

	-- Base Omega Squad Niner
	BaseModel:RegisterMaterialSet("models/egm/core/clone_commando/clone_commando.mdl", "seb_niner", "SEB - RC Niner Armor", {
		["body"] = "egm/seb2/omega/niner/niner_body",
		["bacta"] = "egm/seb2/omega/fi/fi_bacta",
		["explosives"] = "egm/seb2/omega/darman/darman_bombs",
	})
	-- Omega Squad Niner Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_commando/helmet_commando.mdl", "seb_niner", "SEB - RC Niner Helmet", {
		["helmet_commando"] = "egm/seb2/omega/fi/fi_helmet",
		["headset"] = "egm/seb2/omega/atin/atin_headset",
	})
	-- Omega Squad Niner Backpack
	BaseModel:RegisterMaterialSet("models/egm/core/bp_commando/bp_commando.mdl", "seb_niner", "SEB - RC Backpack Niner", {
		["bp_commando"] = "egm/seb2/omega/fi/fi_backpack",
		["bp_commando_antenna"] = "egm/seb2/omega/darman/darman_backpack_asset",
		["bp_commando_tech"] = "egm/seb2/omega/atin/atin_backpack_asset",
	})

	-- Mandos --

	-- Kal Skirata
	BaseModel:RegisterMaterialSet("models/egm/temp/mando_male/mando_male.mdl", "kal_skirata", "SEB - Kal Skirata", {
		["flightsuit"] = "egm/seb2/mando/kal_skirata/flightsuit",
		["armor_parts"] = "egm/seb2/mando/kal_skirata/armor_parts",

		["helmet"] = "egm/seb2/mando/kal_skirata/helmet",
	})
	BaseModel:RegisterMaterialSet("models/egm/temp/mando_jetpack/mando_jetpack.mdl", "kal_skirata", "SEB - Kal Skirata Jetpack", {
		["jetpack_v2"] = "egm/seb2/mando/kal_skirata/jetpack_v2",
	})

	-- Walon Vau
	BaseModel:RegisterMaterialSet("models/egm/temp/mando_male/mando_male.mdl", "walon_vau", "SEB - Walon Vau", {
		["flightsuit"] = "egm/seb2/mando/walon_vau/flightsuit",
		["armor_parts"] = "egm/seb2/mando/walon_vau/armor_parts",

		["helmet"] = "egm/seb2/mando/walon_vau/helmet",
	})
	BaseModel:RegisterMaterialSet("models/egm/temp/mando_jetpack/mando_jetpack.mdl", "walon_vau", "SEB - Walon Vau Jetpack", {
		["jetpack_v2"] = "egm/seb2/mando/walon_vau/jetpack_v2",
	})
end)
--lua/autorun/egm_shevla.lua:
-- Register the Custom Char Shevlar Materials
hook.Add("BaseModel.RegisterMaterialSets", "EGM.CWRP.SWTShevlar", function()
	-- Shevla Body
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "swt_Shevla", "SWT Shevla - Armor", {
        ["body"] = "egm/custom_char/swt/shevlar/body",
		["body_mirrored"] = "egm/custom_char/swt/shevlar/body2",
		
		["antenna_shoulder"] = "egm/swt/attachment/antenna_shoulder",
		["antenna_back"] = "egm/swt/attachment/antenna_back",
		
		["kama"] = "egm/swt/attachment/heavy_red",
		["kama_arc"] = "egm/swt/attachment/kama_arc",
		
		["holsters"] = "egm/swt/attachment/gear",
		["pockets"] = "egm/swt/attachment/gear",
		
        ["pauldron"] = "egm/swt/attachment/specialist",
		["ammo_arm"] = "egm/swt/attachment/specialist",
    })
	
	-- Shevla Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "swt_Shevla", "SWT Shevla - Helmet", {
		["helmet"] = "egm/custom_char/swt/shevlar/helmet",
		["binoculars"] = "egm/swt/attachment/specialist",

		["sunvisor"] = "egm/swt/attachment/heavy",
		["armor"] = "egm/swt/attachment/heavy",
		
		["camera"] = "egm/swt/attachment/helmet_equipment",
		["antenna_back"] = "egm/swt/attachment/helmet_equipment",
		["antenna_ear_big"] = "egm/swt/attachment/helmet_equipment",
		
		["rangefinder"] = "egm/swt/attachment/rangefinder",
		
		["antenna_big"] = "egm/swt/attachment/antenna_big",
		["antenna_ear"] = "egm/swt/attachment/antenna_ear",
	})
end)
--lua/autorun/egm_small_guys.lua:
player_manager.AddValidModel( "Jawa", "models/egm/event/jawa.mdl" );
list.Set( "PlayerOptionsModel", "Jawa",	"models/egm/event/jawa.mdl" );

player_manager.AddValidModel( "Yoda", "models/egm/jedi/yoda.mdl" );
list.Set( "PlayerOptionsModel", "Yoda", "models/egm/jedi/yoda.mdl" );
--lua/autorun/egm_temp.lua:
-- Register the temporary base models.
hook.Add("BaseModel.RegisterBaseModels", "EGM.CWRP.Temporary", function()
	-- Female Mandalorian Armor
	player_manager.AddValidModel("Female Mandalorian Armor", "models/egm/temp/mando_female/mando_female.mdl")
	BaseModel:RegisterBaseModel("models/egm/temp/mando_female/mando_female.mdl", {
		["flightsuit"] = "egm/temp/mando_female/flightsuit",
		["gloves"] = "egm/temp/mando_female/gloves",
		["armor_parts"] = "egm/temp/mando_female/armor_parts",

		["helmet"] = "egm/temp/mando_female/helmet",
		["helmet_lense"] = "egm/temp/mando_female/helmet_lense",

		["kama"] = "egm/temp/mando_female/kama",
		["mando_cape"] = "egm/temp/mando_female/mando_cape",
	})

	-- Male Mandalorian Armor
	player_manager.AddValidModel("Male Mandalorian Armor", "models/egm/temp/mando_male/mando_male.mdl")
	BaseModel:RegisterBaseModel("models/egm/temp/mando_male/mando_male.mdl", {
		["flightsuit"] = "egm/temp/mando_male/flightsuit",
		["gloves"] = "egm/temp/mando_male/gloves",
		["armor_parts"] = "egm/temp/mando_male/armor_parts",

		["helmet"] = "egm/temp/mando_male/helmet",
		["helmet_lense"] = "egm/temp/mando_male/helmet_lense",

		["kama"] = "egm/temp/mando_male/kama",
		["mando_cape"] = "egm/temp/mando_male/mando_cape",
	})

	-- Mandalorian Jetpack
	InventoryBoneMerge:RegisterBaseModel("Jetpack", "models/egm/temp/mando_jetpack/mando_jetpack.mdl", "Mandalorian Jetpack", {
		["jetpack_v2"] = "egm/temp/mando_jetpack/jetpack_v2",
	})
end)
--lua/autorun/egm_tredox.lua:
-- Register the 104th TREDOX CC BARC material sets
hook.Add("BaseModel.RegisterMaterialSets", "EGM.CWRP.104thtredoxccbarcTrooper", function()
	-- 104th Custom Chars --
	-- 104th BARC Tredox Body
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "104th_tredox_BARC", "Custom Char - 104th Tredox Barc Body", {
		["body"] = "egm/custom_char/104th/tredox/body",
		["body_mirrored"] = "egm/custom_char/104th/tredox/body2",

		["kama_arc"] = "egm/custom_char/104th/tredox/arc_kama",

		["pauldron"] = "egm/custom_char/104th/tredox/specialist",
	})
	-- 104th BARC Tredox Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_barc/helmet_barc.mdl", "104th_tredox_BARC", "Custom Char - 104th Tredox Barc Helmet", {
		["helmet_barc"] = "egm/custom_char/104th/tredox/helmet",
	})
end)
--lua/autorun/egm_zip.lua:
-- Register the Custom Char Amber Materials
hook.Add("BaseModel.RegisterMaterialSets", "EGM.CWRP.187thZip", function()
	-- Body
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "187th_zip", "187th Zip - Armor", {
        ["body"] = "egm/custom_char/187th/zip/body",
		["body_mirrored"] = "egm/custom_char/187th/zip/body2",

        ["kama"] = "egm/custom_char/187th/zip/heavy",
		["kama_arc"] = "egm/custom_char/187th/zip/kama_arc",
		
		["pauldron_big"] = "egm/custom_char/187th/zip/gear",
        ["pauldron"] = "egm/custom_char/187th/zip/specialist",
    })

	-- Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "187th_zip", "187th Zip - Helmet", {
		["helmet"] = "egm/custom_char/187th/zip/helmet",
		["sunvisor"] = "egm/custom_char/187th/zip/heavy",
		["armor"] = "egm/187th/attachment/armor",
		["rangefinder"] = "egm/custom_char/187th/zip/rangefinder",
		["binoculars"] = "egm/187th/attachment/binoculars",
	})
	
	-- Sideback
	BaseModel:RegisterMaterialSet("models/egm/core/sidebag/sidebag.mdl", "187th_zip", "187th Zip - Sideback", {
		["sidebag"] = "egm/custom_char/187th/zip/heavy",
		["sidebag_grenades"] = "egm/custom_char/187th/zip/heavy",
	})
	
	-- Backpacks
	BaseModel:RegisterMaterialSet("models/egm/core/backpack/backpack.mdl", "187th_zip", "187th Zip - Backpack", {
		["backpack"] = "egm/custom_char/187th/zip/heavy",
	})
end)
--addons/playermodels/lua/autorun/eventpack_egm.lua:
local function AddPlayerModel(name, model)
	list.Set("PlayerOptionsModel", name, model)
	player_manager.AddValidModel(name, model )
end

AddPlayerModel("C-21 Highsinger", 				"models/player/jellik/starwars/highsinger.mdl" )
AddPlayerModel("Event Attentaeter1", 			"models/lord/lord.mdl" )
AddPlayerModel("Event Attentaeter2", 			"models/lord2/lord2.mdl" )
AddPlayerModel("KF2 Horzine Security", 			"models/player/n7legion/killingfloor2/horzine_sec_suit_male.mdl" )
AddPlayerModel("KF2 Horzine Security Female", 	"models/player/n7legion/killingfloor2/horzine_sec_suit_female.mdl" )
AddPlayerModel("NCR Ranger [M]", 				"models/yates/rangercombat.mdl" )
AddPlayerModel("NCR Ranger [F]", 				"models/yates/rangercombatf.mdl" )
AddPlayerModel("PassivRP Weequay", 				"models/gonzo/narshaddaabarstaff/barmanager/barmanager.mdl" )
AddPlayerModel("Cad Bane", 						"models/grealms/characters/cadbane/cadbane.mdl" )
AddPlayerModel("Dengar", 						"models/player/hydro/swbf_dengar/swbf_dengar.mdl" )
AddPlayerModel("T3-M4 1", 						"models/player/t3_01.mdl" )
AddPlayerModel("T3-M4 2", 						"models/player/t3_02.mdl" )
AddPlayerModel("T3-M4 3", 						"models/player/t3_03.mdl" )
AddPlayerModel("T3-M4 4", 						"models/player/t3_04.mdl" )
AddPlayerModel("Gungan", 						"models/player/jedi/gungan.mdl" )
AddPlayerModel("Darth Maul", 					"models/player/darth/maul.mdl" )
AddPlayerModel("CDC Soldier", 					"models/player/cdc_soldier_player.mdl" )
AddPlayerModel("massif", 						"models/mrpounder1/player/massif.mdl" )
AddPlayerModel("Savage Opress", 				"models/syntheticgaming/characters/savageopress/savageopress.mdl" )
AddPlayerModel("pao", 							"models/player/valley/pao.mdl" )
AddPlayerModel("xalek", 						"models/player/valley/xalek.mdl" )
--lua/autorun/female_civilians.lua:
local function AddPlayerModel( name, model )

	list.Set( "PlayerOptionsModel", name, model )
	player_manager.AddValidModel( name, model )
	
end

AddPlayerModel( "Female Civilian", 				"models/player/artel/jediw3/jediw3.mdl" )

AddPlayerModel( "Female Lara Croft", 	"models/kuma96/laracroft_leatherjacket/laracroft_leatherjacket_pm.mdl" )


--lua/autorun/fire_game_modifications.lua:
--[[-------------------------------------------------------------------------
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

vFire by Vioxtar

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
---------------------------------------------------------------------------]]



--[[-------------------------------------------------------------------------


Fire Related Overrides


---------------------------------------------------------------------------]]

local entMeta = FindMetaTable("Entity")

--[[-------------------------------------------------------------------------
IsOnFire Override
---------------------------------------------------------------------------]]
local oldIsOnFire = entMeta.IsOnFire
entMeta.IsOnFire = function(ent)
	if vFireIsVFireEnt(ent) then return true end
	if ent.fires then
		if table.Count(ent.fires) > 0 then return true end
	end
	return oldIsOnFire(ent)
end

if SERVER then
	--[[-------------------------------------------------------------------------
	Ignite Override
	---------------------------------------------------------------------------]]
	local vFireIgniteOverrideEnabled = true
	function vFireGetIgniteOverride()
		return vFireIgniteOverrideEnabled
	end
	function vFireIgniteOverride(enabled)
		vFireIgniteOverrideEnabled = enabled
	end

	-- Ignite throttle factors
	local igniteThrottle = 0
	local igniteUnThrottleTime = 1
	local igniteLimit = 15

	local oldIgnite = entMeta.Ignite
	entMeta.Ignite = function(ent, time, radius)

		-- Should we override ignite behavior?
		if vFireGetIgniteOverride() then -- We should

			-- Some addons actually try to ignite the world...
			if ent:IsWorld() then return end

			local igniteSuccessful = false
			
			if igniteThrottle < igniteLimit then

				local count = 5

				-- Only create fires if we're not burning enough
				count = count - table.Count(ent.fires or {})
				if count > 0 then

					if vFireIsCharacter(ent) then

						for i = 1, count do
							CreateVFire(ent, ent:GetPos(), VectorRand(), 70)
						end
						igniteSuccessful = true

					else

						igniteSuccessful = CreateVFireEntFires(ent, count)

					end

				end

				if isnumber(radius) then
					if radius > 0 then
						for _, closeEnt in pairs(ents.FindInSphere(ent:GetPos(), radius)) do
							closeEnt:Ignite(time, 0)
						end
					end
				end

			end

			-- Throttle our next ignite calls - we need to do this because a lot of addons like to ignite
			-- a lot of entities at once, and we need to avoid immense lag
			if igniteSuccessful then
				igniteThrottle = igniteThrottle + 1
				timer.Simple(igniteUnThrottleTime, function()
					igniteThrottle = math.Max(igniteThrottle - 1, 0)
				end)
			end

		else -- We're not overriding the ignite function
			-- Trigger the old function, default fire is suppressed by other means
			oldIgnite(ent, time, radius)
			return
		end
	end

	--[[-------------------------------------------------------------------------
	Extinguish Override
	---------------------------------------------------------------------------]]
	local oldExtinguish = entMeta.Extinguish
	entMeta.Extinguish = function(ent)
		
		if vFireIsVFireEnt(ent) then
			if ent:GetClass() == "vfire" then
				ent:ChangeLife(0)
			elseif ent:GetClass() == "vfire_ball" then
				ent:ChangeLife(0)
			end

			return
		end


		if ent.fires then
			for fire, lPos in pairs(ent.fires) do
				if IsValid(fire) then
					fire:Remove()
				end
			end
		end

		-- Nothing bad happens if we also call the normal extinguish function
		oldExtinguish(ent)

	end
end









--[[-------------------------------------------------------------------------


A set of hooks and behavior logic to alter the game in favor of vFires


---------------------------------------------------------------------------]]

if SERVER then

	local defaultFireRemoveTime = 0.1


	--[[-------------------------------------------------------------------------
	
	Hooks to suppress default ignites as much as possible
	
	---------------------------------------------------------------------------]]
	hook.Add("EntityEmitSound", "vFireSuppressDefaultIngiteSound", function(data)
		-- If we're not overriding, then do nothing (current disabled because default fire sounds have weird activations)
		-- if !vFireGetIgniteOverride() then return end
		
		local ent = data.Entity
		if IsValid(ent) then
			if ent:GetClass() == "entityflame" then return false end
		end
	end)
	hook.Add("OnEntityCreated", "vFireRemoveDefaultFires", function(oldFire)
		-- If we're not overriding, then do nothing
		if !vFireGetIgniteOverride() then return end

		if oldFire:GetClass() != "entityflame" then return end
		timer.Simple(defaultFireRemoveTime, function()
			if IsValid(oldFire) then
				oldFire:Remove()
			end
		end)
	end)




	--[[-------------------------------------------------------------------------
	Have fires fall off of dying players
	---------------------------------------------------------------------------]]
	hook.Add("PlayerDeath", "vFireDropFiresFromPlayer", function(ply)
		if ply.fires then
			for fire, pos in pairs(ply.fires) do
				if IsValid(fire) then
					local fireBall = fire:Drop()
					if !IsValid(fireBall) then
						fire:Remove()
					end
				end
			end
		end
	end)

	--[[-------------------------------------------------------------------------
	Make sure players are no longer buning after a respawn
	---------------------------------------------------------------------------]]
	hook.Add("PlayerSpawn", "vFireRemoveFiresFromPlayer", function(ply)
		if ply.fires then
			for fire, pos in pairs(ply.fires) do
				fire:Remove()
			end
		end
	end)

	--[[-------------------------------------------------------------------------
	Handle fires of a burning NPC's death
	---------------------------------------------------------------------------]]
	hook.Add("OnNPCKilled", "vFireDropFiresFromNPC", function(npc, attacker, inflictor)
		if npc.fires then
			for fire, pos in pairs(npc.fires) do
				if IsValid(fire) then
					local fireBall = fire:Drop()
					if IsValid(fireBall) then
						fireBall:Ignore(npc)
					else
						fire:Remove()
					end
				end
			end
		end
	end)

	--[[-------------------------------------------------------------------------
	Handle fires on props that break
	---------------------------------------------------------------------------]]
	hook.Add("PropBreak", "vFireDropFiresFromProp", function(attacker, prop)
		if prop.fires then
			for fire, pos in pairs(prop.fires) do
				if IsValid(fire) then
					-- We'd like to 'reward' the fire's life for breaking the prop
					fire:ChangeLife(fire.life * 1.15)
					
					fire:Drop()
				end
			end
		end
	end)




	--[[-------------------------------------------------------------------------
	Fix fire dependent entities' behaviors, for instance:
	Explosive barrels rely on being ignited to explode after damaged by an explosion themselves
	Because vFire removes default fires, we need to encourage more chain explosions
	---------------------------------------------------------------------------]]
	hook.Add("EntityTakeDamage", "vFireFixExplosion", function(ent, dmg)

		if hook.Call("vFireSuppressExplosionBehavior") then return end

		if !dmg:IsExplosionDamage() then return end
		local hp = ent:Health()
		if hp < dmg:GetDamage() and hp > 0 then
			if math.random(1, 3) == 1 then
				ent:SetHealth(0)
			end
		end
	end)





	--[[-------------------------------------------------------------------------
	Create fire balls from explosions
	---------------------------------------------------------------------------]]
	hook.Add("AcceptInput", "vFireFireBallByExplosion", function(explosion, name)
		if explosion:GetClass() != "env_explosion" then return end
		if !vFireEnableExplosionFires then return end
		if name != "Explode" then return end -- Sometimes env_explosions don't directly mean explosions happen

		if hook.Call("vFireSuppressExplosionBehavior") then return end

		-- Let the explosion settle in its position
		timer.Simple(0, function()

			if !IsValid(explosion) then return end

			local count
			if game.SinglePlayer() then
				count = math.random(3, 5)
			else
				count = math.random(2, 3)
			end

			local pos = explosion:GetPos()

			for i = 1, count do
				local life = math.Rand(10, 50)
				local feed = life / 200
				if math.random(1, 10) == 1 then
					feed = feed * 6
				end
				-- The bigger the fire the smaller the reach
				local vel = VectorRand() * math.Rand(20000, 80000) / life
				CreateVFireBall(life, feed, pos, vel)
			end

			-- We'd also like to send clients information about the explosion so they can stack them
			-- if vFireEnableExplosionEffects then
			-- 	local plyCnt = player.GetCount()
			-- 	if plyCnt > 0 then
			-- 		net.Start("vFireExplosion")
			-- 			net.WriteVector(pos)
			-- 		net.SendPVS(pos)
			-- 	end
			-- end

		end)
	end)


	--[[-------------------------------------------------------------------------
	Support ignite calls via inputs
	---------------------------------------------------------------------------]]
	hook.Add("AcceptInput", "vFireIgniteByInput", function(ent, name)
		if (name != "Ignite") then return end
		vFireIgniteOverride(true)
		ent:Ignite()
	end)



	--[[-------------------------------------------------------------------------
	

	NPC Behaviors
	

	---------------------------------------------------------------------------]]


	--[[-------------------------------------------------------------------------
	NPC on fire behaviors
	---------------------------------------------------------------------------]]
	local NPCOnFireActs = {
		-- 3,
		-- 4,
		-- 5,
		-- 6,
		-- 8,
		-- 10, -- ACT_RUN
		-- 12,
		-- 14,
		-- 23,
		-- 41,
		-- 42,
		61, -- ACT_COWER
		-- 62,
		-- 63,
		-- 72,
		-- 78,
		-- 79,
		-- 81,
		-- 83, -- ACT_WALK_STIMULATED
		-- 84, -- ACT_WALK_AGITATED
		-- 87, -- ACT_RUN_STIMULATED
		-- 88, -- ACT_RUN_AGITATED
		-- 105, -- ACT_WALK_HURT
		-- 106, -- ACT_RUN_HURT
		-- 111, -- ACT_RUN_SCARED
		-- 117,
		-- 118,
		-- 119,
		-- 120,
		-- 121,
		-- 122,
		-- 123,
		-- 124,
		125, -- ACT_IDLE_ON_FIRE
		126, -- ACT_WALK_ON_FIRE
		127, -- ACT_RUN_ON_FIRE
		-- 144,
		-- 145,
		-- 146,
		-- 147,
		-- 148,
		-- 149,
		-- 150,
		-- 151,
		-- 152,
		-- 153,
		-- 154,
		-- 155,
		-- 156,
		-- 428,
		-- 429,
		-- 430,
		-- 435,
		-- 436,
		-- 437,
		-- 1930,
		-- 1932,
		-- 1933,
		-- 1934
	}

	local NPCClassAvailableFireActs = {}

	function StopNPCBurningBehavior(npc)
		npc:SetSchedule(0)
	end

	function NPCBurningBehavior(npc, behavior, fireAct)
		if !IsValid(npc) then return end
		if !npc.isBurning then return end
		if !vFireEnableNPCBehavior then return end

		local nextCall = 3.5

		
		if behavior == 1 then

			--[[-------------------------------------------------------------------------
			Run around to random positions
			---------------------------------------------------------------------------]]

			-- Can't aim well when you're burning alive
			npc:SetCurrentWeaponProficiency(1)

			if math.random(1, 8) == 1 then
				-- Have the NPC walk backwards in a retarded manner
				npc:SetEnemy(npc)
			end
			
			-- Play a death sound
			if math.random(1, 3) == 1 then
				npc:SetSchedule(SCHED_DIE_RAGDOLL)
			end

			-- Run around
			timer.Simple(0.1, function()
				if !IsValid(npc) then return end
				npc:SetSchedule(SCHED_RUN_RANDOM)
			end)

			nextCall = math.Rand(1, 2)

		elseif behavior == 2 then

			--[[-------------------------------------------------------------------------
			Utilize default ignition behavior
			---------------------------------------------------------------------------]]
			
			if !npc.lastSound or math.random(1, 10) == 1 then -- The NPC is silent, play a dying sound every once in a while
				npc:SetSchedule(SCHED_DIE_RAGDOLL)
			end

			timer.Simple(0.1, function()
				if !IsValid(npc) then return end
				npc:SetSchedule(77)

				vFireIgniteOverride(false)
					npc:Ignite(defaultFireRemoveTime)
				vFireIgniteOverride(true)
				
			end)

			nextCall = math.Rand(3, 14)

		elseif behavior == 3 then

			--[[-------------------------------------------------------------------------
			Do a fire act animation - currently disabled
			---------------------------------------------------------------------------]]

			-- Play a death sound
			if math.random(1, 1) == 1 then
				npc:SetSchedule(SCHED_DIE_RAGDOLL)
			end

			timer.Simple(0.1 , function()

				if !IsValid(npc) then return end

				-- Perform a fire act
				local class = npc:GetClass()
				-- Every class will have its own subset of availabe fire acts, find them and use them
				if !NPCClassAvailableFireActs[class] then
					local availableFireActs = {}
					for k, actID in pairs(NPCOnFireActs) do
						local seqID = npc:SelectWeightedSequence(actID)
						if seqID != -1 then
							availableFireActs[#availableFireActs + 1] = {actID, seqID}
						end
					end
					NPCClassAvailableFireActs[class] = availableFireActs
				end

				if !fireAct then fireAct = table.Random(NPCClassAvailableFireActs[class]) end

				if fireAct then
					local actID = fireAct[1]
					local seqID = fireAct[2]

					npc:SetMovementActivity(actID)
					npc:SetMovementSequence(seqID)

				end
			end)

			nextCall = math.Rand(1, 2)

		end

		-- Have a slight chance of changing the behavior
		-- if math.random(1, 4) == 1 then
			-- behavior = math.random(1, 2)
			-- if behavior != 3 then fireAct = nil end
		-- end
		-- Start a timed loop while the NPC is burning
		timer.Simple(nextCall, function()
			NPCBurningBehavior(npc, behavior, fireAct)
		end)
	end

	local defaultNPCs = {}
	defaultNPCs["npc_crow"] = true
	defaultNPCs["npc_monk"] = true
	defaultNPCs["npc_pigeon"] = true
	defaultNPCs["npc_seagull"] = true
	defaultNPCs["npc_cscanner"] = true
	defaultNPCs["npc_combinedropship"] = true
	defaultNPCs["npc_combine_s"] = true
	defaultNPCs["npc_combinegunship"] = true
	defaultNPCs["npc_hunter"] = true
	defaultNPCs["npc_helicopter"] = true
	defaultNPCs["npc_manhack"] = true
	defaultNPCs["npc_metropolice"] = true
	defaultNPCs["npc_rollermine"] = true
	defaultNPCs["npc_clawscanner"] = true
	defaultNPCs["npc_stalker"] = true
	defaultNPCs["npc_strider"] = true
	defaultNPCs["bullseye_strider_focus"] = true
	defaultNPCs["npc_turret_floor"] = true
	defaultNPCs["npc_alyx"] = true
	defaultNPCs["npc_barney"] = true
	defaultNPCs["npc_citizen"] = true
	defaultNPCs["npc_dog"] = true
	defaultNPCs["npc_magnusson"] = true
	defaultNPCs["npc_kleiner"] = true
	defaultNPCs["npc_mossman"] = true
	defaultNPCs["npc_eli"] = true
	defaultNPCs["npc_gman"] = true
	defaultNPCs["npc_vortigaunt"] = true
	defaultNPCs["npc_breen"] = true
	defaultNPCs["npc_antlion"] = true
	defaultNPCs["npc_antlionguard"] = true
	defaultNPCs["npc_antlion_worker"] = true
	defaultNPCs["npc_headcrab_fast"] = true
	defaultNPCs["npc_fastzombie"] = true
	defaultNPCs["npc_fastzombie_torso"] = true
	defaultNPCs["npc_headcrab"] = true
	defaultNPCs["npc_headcrab_black"] = true
	defaultNPCs["npc_poisonzombie"] = true
	defaultNPCs["npc_headcrab_poison"] = true
	defaultNPCs["npc_zombie"] = true
	defaultNPCs["npc_zombie_torso"] = true
	defaultNPCs["npc_zombine"] = true

	local function shouldDoBehavior(npc)
		if !IsValid(npc) then return false end
		if npc.vFireCustomBehavior != nil then return npc.vFireCustomBehavior end
		local class = npc:GetClass()
		
		npc.vFireCustomBehavior = defaultNPCs[class] or false
		
		return npc.vFireCustomBehavior
	end

	hook.Add("vFireEntityStoppedBurning", "vFireStopNPCBurningBehavior", function(npc)
		if !IsValid(npc) then return end
		if !npc:IsNPC() then return end
		if !vFireEnableDamage then return end
		if !vFireEnableNPCBehavior then return end
		if !shouldDoBehavior(npc) then return end

		npc.isBurning = false
		StopNPCBurningBehavior(npc)
	end)
	
	hook.Add("vFireEntityStartedBurning", "vFireStartNPCBurningBehavior", function(npc)
		if !IsValid(npc) then return end
		if !npc:IsNPC() then return end
		if !vFireEnableDamage then return end
		if !vFireEnableNPCBehavior then return end
		if !shouldDoBehavior(npc) then return end
		
		npc.isBurning = true

		-- Choose a random behavior and start behavior loop
		local behavior = 2
		NPCBurningBehavior(npc, behavior)
	end)

end
--addons/fprofiler/lua/fprofiler/gather.lua:
local timeMeasurementFunc = SysTime

-- Helper function, created by some ancient Lua dev
-- Retrieves the local variables and their values of a function
local function getupvalues(f)
	local t, i, k, v = {}, 1, debug.getupvalue(f, 1)
	while k do
		t[k] = v
		i = i + 1
		k,v = debug.getupvalue(f, i)
	end
	return t
end

-- Helper function
-- Get all local variables
local NIL = {}
setmetatable(NIL, {__tostring = function() return "nil" end})
local function getlocals(level)
	local i = 1
	local name, value
	local vars = {}

	while true do
		name, value = debug.getlocal(level, i)

		if not name then break end

		value = value == nil and NIL or value
		vars[name] = value
		i = i + 1
	end

	return vars
end

--[[-------------------------------------------------------------------------
Call counts:

registers how often function have been called
---------------------------------------------------------------------------]]
local callcounts = {}


-- Gets the call counts
FProfiler.Internal.getCallCounts = function() return callcounts end


-- Resets the call counts
function FProfiler.Internal.resetCallCounts()
	callcounts = {}
end

--[[-------------------------------------------------------------------------
Inclusive function times

Keeps track of how long functions take in total
i.e. average time between the start and return of a function * times called

This includes the time that any function called by this function takes
(that's what the "inclusive" refers to).
Note: recursive calls are not counted double
---------------------------------------------------------------------------]]

local inclusiveTimes = {}

-- Gets the inclusive times
FProfiler.Internal.getInclusiveTimes = function() return inclusiveTimes end

-- Resets the inclusive times
function FProfiler.Internal.resetInclusiveTimes()
	inclusiveTimes = {}
end

--[[-------------------------------------------------------------------------
Top n most expensive single function calls
Keeps track of the functions that took the longest time to run
Note: functions can appear in this list at most once
---------------------------------------------------------------------------]]
local mostExpensiveSingleCalls = {}

-- Gets most expensive single calls
FProfiler.Internal.getMostExpensiveSingleCalls = function() return mostExpensiveSingleCalls end

-- Dictionary to make sure the same function doesn't appear multiple times
-- in the top n
local mostExpensiveSingleDict = {}

function FProfiler.Internal.resetMostExpensiveSingleCalls()
	for i = 1, 50 do mostExpensiveSingleCalls[i] = {runtime = 0} end
	mostExpensiveSingleDict = {}
end

-- Initial empty list
FProfiler.Internal.resetMostExpensiveSingleCalls()

--[[-------------------------------------------------------------------------
Function information
Using debug.getinfo on a function object won't give you any function names
that's because functions can have multiple names.
Luckily, when the functions are called, debug.getinfo(level) gives the
function name and scope
---------------------------------------------------------------------------]]
local functionNames = {}

FProfiler.Internal.getFunctionNames = function() return functionNames end

--[[-------------------------------------------------------------------------
Recursion depth

Used internally to make sure recursive functions' times aren't counted
multiple times
---------------------------------------------------------------------------]]
local recursiveCount = {}

--[[-------------------------------------------------------------------------
Function start times

Used internally to keep track of when functions were called
---------------------------------------------------------------------------]]
local startTimes = {}

--[[-------------------------------------------------------------------------
Lua code event handlers
---------------------------------------------------------------------------]]

-- The recursion depth of the function that is in focus.
-- Only applies when profiling a specific function (i.e. laying focus upon)
local focusDepth = 0

-- Called when a function in the code is called
local function registerFunctionCall(funcInfo)
	local func = funcInfo.func

	-- Update call counts
	callcounts[func] = (callcounts[func] or 0) + 1

	-- Increase recursion depth for this function
	recursiveCount[func] = (recursiveCount[func] or 0) + 1

	-- Store function info
	local funcname = funcInfo.name or ""
	functionNames[func] = functionNames[func] or {}
	functionNames[func][funcname] = functionNames[func][funcname] or
		{ namewhat = funcInfo.namewhat,
		  nparams = funcInfo.nparams
		}

	local time = timeMeasurementFunc()

	-- Update inclusive function times,
	-- only when we're on the first recursive call
	if recursiveCount[func] == 1 then
		startTimes[func] = time
	end
end


-- Called when a function returns
local function registerReturn(funcInfo)
	local time = timeMeasurementFunc()
	local func = funcInfo.func
	local runtime = time - startTimes[func]

	-- Update inclusive function time
	-- Only update on the topmost call, to prevent recursive
	-- calls for being counted multiple times.
	if recursiveCount[func] == 1 then
		inclusiveTimes[func] = (inclusiveTimes[func] or 0) + runtime
	end

	-- Maintain recursion depth
	recursiveCount[func] = recursiveCount[func] - 1

	-- Update top n list
	-- This path will be taken most often: the function isn't special
	-- Also only counts the top recursion
	if runtime <= mostExpensiveSingleCalls[50].runtime or recursiveCount[func] > 1 then return end

	-- If the function already appears in the top 10, replace it or discard the result
	if mostExpensiveSingleDict[func] then
		local i = mostExpensiveSingleDict[func]

		-- Discard this info
		if runtime < mostExpensiveSingleCalls[i].runtime then return end

		-- Update the entry
		mostExpensiveSingleCalls[i].runtime = runtime
		mostExpensiveSingleCalls[i].upvalues = getupvalues(func)
		mostExpensiveSingleCalls[i].locals = getlocals(5)
		mostExpensiveSingleCalls[i].info = funcInfo
		mostExpensiveSingleCalls[i].func = func

		-- Move the updated entry up the top 10 list if applicable
		while i > 1 and runtime > mostExpensiveSingleCalls[i - 1].runtime do
			mostExpensiveSingleDict[mostExpensiveSingleCalls[i - 1].func] = i
			mostExpensiveSingleCalls[i - 1], mostExpensiveSingleCalls[i] = mostExpensiveSingleCalls[i], mostExpensiveSingleCalls[i - 1]
			i = i - 1
		end

		mostExpensiveSingleDict[func] = i

		return
	end

	-- Knowing that the function belongs in the top n, find its position
	local i = 50
	while i >= 1 and runtime > mostExpensiveSingleCalls[i].runtime do
		-- Update the dictionary
		-- All functions faster than the current one move down the list
		if not mostExpensiveSingleCalls[i].func then i = i - 1 continue end
		mostExpensiveSingleDict[mostExpensiveSingleCalls[i].func] = i + 1

		i = i - 1
	end

	-- Insert the expensive call in the top n
	mostExpensiveSingleDict[func] = i + 1
	table.insert(mostExpensiveSingleCalls, i + 1,
		{
			func = func,
			runtime = runtime,
			info = funcInfo,
			upvalues = getupvalues(func),
			locals = getlocals(5)
		})


	-- What was previously the 50th most expensive function
	-- is now kicked out of the top 10
	if mostExpensiveSingleCalls[51].func then
		mostExpensiveSingleDict[mostExpensiveSingleCalls[51].func] = nil
	end
	mostExpensiveSingleCalls[51] = nil
end


-- Called on any Lua event
local function onLuaEvent(event, focus)
	local info = debug.getinfo(3)
	local func = info.func

	if event == "call" or event == "tail call" then
		-- Only track the focussed function and the functions
		-- called by the focussed function
		if focus == func then focusDepth = focusDepth + 1 end
		if focus and focusDepth == 0 then return end

		registerFunctionCall(info)
	else
		-- Functions that return right after the call to FProfiler.Internal.start()
		-- are not to be counted
		if not recursiveCount[func] or recursiveCount[func] == 0 then return end

		if focus == func then focusDepth = focusDepth - 1 end
		if focus and focusDepth == 0 then return end

		registerReturn(info)
	end
end

--[[-------------------------------------------------------------------------
Profiling control
---------------------------------------------------------------------------]]

-- Start profiling
-- focus: only measure data of everything that happens within a certain function
function FProfiler.Internal.start(focus)
	-- Empty start times, so unfinished functions aren't
	-- registered as returns on a second profiling session
	-- local time = SysTime()
	-- for k,v in pairs(startTimes) do startTimes[k] = time end
	table.Empty(startTimes)
	table.Empty(recursiveCount)

	debug.sethook(function(event) onLuaEvent(event, focus) end, "cr")
end


-- Stop profiling
function FProfiler.Internal.stop()
	debug.sethook()
end

-- Reset all profiling data
function FProfiler.Internal.reset()
	FProfiler.Internal.resetCallCounts()
	FProfiler.Internal.resetInclusiveTimes()
	FProfiler.Internal.resetMostExpensiveSingleCalls()
end

--addons/fprofiler/lua/fprofiler/ui/frame.lua:
--[[-------------------------------------------------------------------------
The panel that contains the realm switcher
---------------------------------------------------------------------------]]
local REALMPANEL = {}

function REALMPANEL:Init()
	self:DockPadding(0, 0, 0, 0)
	self:DockMargin(0, 0, 5, 0)

	self.realmLabel = vgui.Create("DLabel", self)
	self.realmLabel:SetDark(true)
	self.realmLabel:SetText("Realm:")

	self.realmLabel:SizeToContents()
	self.realmLabel:Dock(TOP)

	self.realmbox = vgui.Create("DComboBox", self)
	self.realmbox:AddChoice("Client")
	self.realmbox:AddChoice("Server")
	self.realmbox:Dock(TOP)

	FProfiler.UI.onModelUpdate("realm", function(new)
		self.realmbox.selected = new == "client" and 1 or 2
		self.realmbox:SetText(new == "client" and "Client" or "Server")
	end)

	FProfiler.UI.onModelUpdate("serverAccess", function(hasAccess)
		self.realmbox:SetDisabled(not hasAccess)

		if not hasAccess and self.realmbox.selected == 2 then
			FProfiler.UI.updateModel("realm", "client")
		end
	end)

	self.realmbox.OnSelect = function(_, _, value) FProfiler.UI.updateModel("realm", string.lower(value)) end
end

function REALMPANEL:PerformLayout()
	self.realmLabel:SizeToContents()
	local top = ( self:GetTall() - self.realmLabel:GetTall() - self.realmbox:GetTall()) * 0.5
	self:DockPadding(0, top, 0, 0)
end

derma.DefineControl("FProfileRealmPanel", "", REALMPANEL, "Panel")

--[[-------------------------------------------------------------------------
The little red or green indicator that indicates whether the focussing
function is correct
---------------------------------------------------------------------------]]
local FUNCINDICATOR = {}

function FUNCINDICATOR:Init()
	self:SetTall(5)
	self.color = Color(0, 0, 0, 0)
end

function FUNCINDICATOR:Paint()
	draw.RoundedBox(0, 0, 0, self:GetWide(), self:GetTall(), self.color)
end

derma.DefineControl("FProfileFuncIndicator", "", FUNCINDICATOR, "DPanel")

--[[-------------------------------------------------------------------------
The panel that contains the focus text entry and the focus indicator
---------------------------------------------------------------------------]]
local FOCUSPANEL = {}

function FOCUSPANEL:Init()
	self:DockPadding(0, 0, 0, 0)
	self:DockMargin(0, 0, 5, 0)

	self.focusLabel = vgui.Create("DLabel", self)
	self.focusLabel:SetDark(true)
	self.focusLabel:SetText("Profiling Focus:")

	self.focusLabel:SizeToContents()
	self.focusLabel:Dock(TOP)

	self.funcIndicator = vgui.Create("FProfileFuncIndicator", self)
	self.funcIndicator:Dock(BOTTOM)

	self.focusBox = vgui.Create("DTextEntry", self)
	self.focusBox:SetText("")
	self.focusBox:SetWidth(150)
	self.focusBox:Dock(BOTTOM)
	self.focusBox:SetTooltip("Focus the profiling on a single function.\nEnter a global function name here (like player.GetAll)\nYou're not allowed to call functions in here (e.g. hook.GetTable() is not allowed)")

	function self.focusBox:OnChange()
		FProfiler.UI.updateCurrentRealm("focusStr", self:GetText())
	end

	FProfiler.UI.onCurrentRealmUpdate("focusObj", function(new)
		self.funcIndicator.color = FProfiler.UI.getCurrentRealmValue("focusStr") == "" and Color(0, 0, 0, 0) or new and Color(80, 255, 80, 255) or Color(255, 80, 80, 255)
	end)

	FProfiler.UI.onCurrentRealmUpdate("focusStr", function(new, old)
		if self.focusBox:GetText() == new then return end

		self.focusBox:SetText(tostring(new))
	end)
end

function FOCUSPANEL:PerformLayout()
	self.focusBox:SetWide(200)
	self.focusLabel:SizeToContents()
end

derma.DefineControl("FProfileFocusPanel", "", FOCUSPANEL, "Panel")

--[[-------------------------------------------------------------------------
The timer that keeps track of for how long the profiling has been going on
---------------------------------------------------------------------------]]
local TIMERPANEL = {}

function TIMERPANEL:Init()
	self:DockPadding(0, 5, 0, 5)
	self:DockMargin(5, 0, 5, 0)

	self.timeLabel = vgui.Create("DLabel", self)
	self.timeLabel:SetDark(true)
	self.timeLabel:SetText("Total profiling time:")

	self.timeLabel:SizeToContents()
	self.timeLabel:Dock(TOP)

	self.counter = vgui.Create("DLabel", self)
	self.counter:SetDark(true)
	self.counter:SetText("00:00:00")
	self.counter:SizeToContents()
	self.counter:Dock(RIGHT)

	function self.counter:Think()
		local recordTime, sessionStart = FProfiler.UI.getCurrentRealmValue("recordTime"), FProfiler.UI.getCurrentRealmValue("sessionStart")

		local totalTime = recordTime + (sessionStart and (CurTime() - sessionStart) or 0)

		self:SetText(string.FormattedTime(totalTime, "%02i:%02i:%02i"))
	end
end

function TIMERPANEL:PerformLayout()
	self.timeLabel:SizeToContents()
	self.counter:SizeToContents()
end

derma.DefineControl("FProfileTimerPanel", "", TIMERPANEL, "Panel")

--[[-------------------------------------------------------------------------
The top bar
---------------------------------------------------------------------------]]
local MAGICBAR = {}

function MAGICBAR:Init()
	self:DockPadding(5, 5, 5, 5)
	self.realmpanel = vgui.Create("FProfileRealmPanel", self)

	-- (Re)Start profiling
	self.restartProfiling = vgui.Create("DButton", self)
	self.restartProfiling:SetText("   (Re)Start\n    Profiling")
	self.restartProfiling:DockMargin(0, 0, 5, 0)
	self.restartProfiling:Dock(LEFT)

	self.restartProfiling.DoClick = function()
		FProfiler.UI.updateCurrentRealm("shouldReset", true)
		FProfiler.UI.updateCurrentRealm("status", "Started")
	end

	FProfiler.UI.onCurrentRealmUpdate("status", function(new)
		self.restartProfiling:SetDisabled(new == "Started")
	end)

	-- Stop profiling
	self.stopProfiling = vgui.Create("DButton", self)
	self.stopProfiling:SetText("     Stop\n  Profiling")
	self.stopProfiling:DockMargin(0, 0, 5, 0)
	self.stopProfiling:Dock(LEFT)

	self.stopProfiling.DoClick = function()
		FProfiler.UI.updateCurrentRealm("status", "Stopped")
	end

	FProfiler.UI.onCurrentRealmUpdate("status", function(new)
		self.stopProfiling:SetDisabled(new == "Stopped")
	end)

	-- Continue profiling
	self.continueProfiling = vgui.Create("DButton", self)
	self.continueProfiling:SetText("    Continue\n     Profiling")
	self.continueProfiling:DockMargin(0, 0, 5, 0)
	self.continueProfiling:Dock(LEFT)

	self.continueProfiling.DoClick = function()
		FProfiler.UI.updateCurrentRealm("shouldReset", false)
		FProfiler.UI.updateCurrentRealm("status", "Started")
	end

	FProfiler.UI.onCurrentRealmUpdate("status", function(new)
		self.continueProfiling:SetDisabled(new == "Started")
	end)

	self.realmpanel:Dock(LEFT)

	self.focuspanel = vgui.Create("FProfileFocusPanel", self)
	self.focuspanel:Dock(LEFT)

	-- Timer
	self.timerpanel = vgui.Create("FProfileTimerPanel", self)
	self.timerpanel:Dock(RIGHT)
end

function MAGICBAR:PerformLayout()
	self.realmpanel:SizeToChildren(true, false)
	self.focuspanel:SizeToChildren(true, false)
	self.timerpanel:SizeToChildren(true, false)
end


derma.DefineControl("FProfileMagicBar", "", MAGICBAR, "DPanel")

--[[-------------------------------------------------------------------------
The Bottlenecks tab's contents
---------------------------------------------------------------------------]]
local BOTTLENECKTAB = {}

function BOTTLENECKTAB:Init()
	self:SetMultiSelect(false)
	self:AddColumn("Name")
	self:AddColumn("Path")
	self:AddColumn("Lines")
	self:AddColumn("Amount of times called")
	self:AddColumn("Total time in ms (inclusive)")
	self:AddColumn("Average time in ms (inclusive)")

	FProfiler.UI.onCurrentRealmUpdate("bottlenecks", function(new)
		self:Clear()

		for _, row in ipairs(new) do
			local names = {}
			local path = row.info.short_src
			local lines = path ~= "[C]" and row.info.linedefined .. " - " .. row.info.lastlinedefined or "N/A"
			local amountCalled = row.total_called
			local totalTime = row.total_time * 100
			local avgTime = row.average_time * 100

			for _, fname in ipairs(row.names or {}) do
				if fname.namewhat == "" and fname.name == "" then continue end
				table.insert(names, fname.namewhat .. " " .. fname.name)
			end

			if #names == 0 then names[1] = "Unknown" end

			local line = self:AddLine(table.concat(names, "/"), path, lines, amountCalled, totalTime, avgTime)
			line.data = row
		end
	end)

	FProfiler.UI.onCurrentRealmUpdate("currentSelected", function(new, old)
		if new == old then return end

		for _, line in pairs(self.Lines) do
			line:SetSelected(line.data.func == new.func)
		end
	end)
end


function BOTTLENECKTAB:OnRowSelected(id, line)
	FProfiler.UI.updateCurrentRealm("currentSelected", line.data)
end


derma.DefineControl("FProfileBottleNecks", "", BOTTLENECKTAB, "DListView")

--[[-------------------------------------------------------------------------
The Top n lag spikes tab's contents
---------------------------------------------------------------------------]]
local TOPTENTAB = {}

function TOPTENTAB:Init()
	self:SetMultiSelect(false)
	self:AddColumn("Name")
	self:AddColumn("Path")
	self:AddColumn("Lines")
	self:AddColumn("Runtime in ms")

	FProfiler.UI.onCurrentRealmUpdate("topLagSpikes", function(new)
		self:Clear()

		for _, row in ipairs(new) do
			if not row.func then break end

			local name = row.info.name and row.info.name ~= "" and (row.info.namewhat .. " " .. row.info.name) or "Unknown"
			local path = row.info.short_src
			local lines = path ~= "[C]" and row.info.linedefined .. " - " .. row.info.lastlinedefined or "N/A"
			local runtime = row.runtime * 100

			local line = self:AddLine(name, path, lines, runtime)
			line.data = row
		end
	end)

	FProfiler.UI.onCurrentRealmUpdate("currentSelected", function(new, old)
		if new == old then return end

		for _, line in pairs(self.Lines) do
			line:SetSelected(line.data.func == new.func)
		end
	end)
end

function TOPTENTAB:OnRowSelected(id, line)
	FProfiler.UI.updateCurrentRealm("currentSelected", line.data)
end

derma.DefineControl("FProfileTopTen", "", TOPTENTAB, "DListView")

--[[-------------------------------------------------------------------------
The Tab panel of the bottlenecks and top n lag spikes
---------------------------------------------------------------------------]]
local RESULTSHEET = {}

function RESULTSHEET:Init()
	self:DockMargin(0, 10, 0, 0)
	self:SetPadding(0)

	self.bottlenecksTab = vgui.Create("FProfileBottleNecks")
	self:AddSheet("Bottlenecks", self.bottlenecksTab)

	self.toptenTab = vgui.Create("FProfileTopTen")
	self:AddSheet("Top 50 most expensive function calls", self.toptenTab)

end


derma.DefineControl("FProfileResultSheet", "", RESULTSHEET, "DPropertySheet")

--[[-------------------------------------------------------------------------
The function details panel
---------------------------------------------------------------------------]]
local FUNCDETAILS = {}

function FUNCDETAILS:Init()
	self.titleLabel = vgui.Create("DLabel", self)
	self.titleLabel:SetDark(true)
	self.titleLabel:SetFont("DermaLarge")
	self.titleLabel:SetText("Function Details")
	self.titleLabel:SizeToContents()
	-- self.titleLabel:Dock(TOP)

	self.focus = vgui.Create("DButton", self)
	self.focus:SetText("Focus")
	self.focus:SetTall(50)
	self.focus:SetFont("DermaDefaultBold")
	self.focus:Dock(BOTTOM)

	function self.focus:DoClick()
		local sel = FProfiler.UI.getCurrentRealmValue("currentSelected")
		if not sel then return end

		FProfiler.UI.updateCurrentRealm("focusStr", sel.func)
	end

	self.source = vgui.Create("DTextEntry", self)
	self.source:SetKeyboardInputEnabled(false)
	self.source:DockMargin(0, 40, 0, 0)
	self.source:SetMultiline(true)
	self.source:Dock(FILL)

	FProfiler.UI.onCurrentRealmUpdate("sourceText", function(new)
		self.source:SetText(string.Replace(new, "\t", "    "))
	end)

	self.toConsole = vgui.Create("DButton", self)
	self.toConsole:SetText("Print Details to Console")
	self.toConsole:SetTall(50)
	self.toConsole:SetFont("DermaDefaultBold")
	self.toConsole:Dock(BOTTOM)

	function self.toConsole:DoClick()
		FProfiler.UI.updateCurrentRealm("toConsole", FProfiler.UI.getCurrentRealmValue("currentSelected"))
	end
end

function FUNCDETAILS:PerformLayout()
	self.titleLabel:CenterHorizontal()
end
derma.DefineControl("FProfileFuncDetails", "", FUNCDETAILS, "DPanel")

--[[-------------------------------------------------------------------------
The actual frame
---------------------------------------------------------------------------]]
local FRAME = {}

local frameInstance
function FRAME:Init()
	self:SetTitle("FProfiler profiling tool")
	self:SetSize(ScrW() * 0.8, ScrH() * 0.8)
	self:Center()
	self:SetVisible(true)
	self:MakePopup()
	self:SetDeleteOnClose(false)

	self.magicbar = vgui.Create("FProfileMagicBar", self)
	self.magicbar:SetTall(math.max(self:GetTall() * 0.07, 48))
	self.magicbar:Dock(TOP)

	self.resultsheet = vgui.Create("FProfileResultSheet", self)
	self.resultsheet:SetWide(self:GetWide() * 0.8)
	self.resultsheet:Dock(LEFT)

	self.details = vgui.Create("FProfileFuncDetails", self)
	self.details:SetWide(self:GetWide() * 0.2 - 12)
	self.details:DockMargin(5, 31, 0, 0)
	self.details:Dock(RIGHT)
end

function FRAME:OnClose()
	FProfiler.UI.updateModel("frameVisible", false)
end

derma.DefineControl("FProfileFrame", "", FRAME, "DFrame")

--[[-------------------------------------------------------------------------
The command to start the profiler
---------------------------------------------------------------------------]]
concommand.Add("FProfiler",
	function()
		frameInstance = frameInstance or vgui.Create("FProfileFrame")
		frameInstance:SetVisible(true)

		FProfiler.UI.updateModel("frameVisible", true)
	end,
	nil, "Starts FProfiler")

--addons/fprofiler/lua/fprofiler/ui/servercontrol.lua:
local get, update, onUpdate = FProfiler.UI.getModelValue, FProfiler.UI.updateModel, FProfiler.UI.onModelUpdate


--[[-------------------------------------------------------------------------
Update the current selected focus object when data is entered
---------------------------------------------------------------------------]]
onUpdate({"server", "focusStr"}, function(new)
	if not new or get({"server", "fromServer"}) then return end

	net.Start("FProfile_focusObj")
		net.WriteString(new)
	net.SendToServer()
end)

net.Receive("FProfile_focusObj", function()
	update({"server", "focusObj"}, net.ReadBool() and get({"server", "focusStr"}) or nil)
end)

-- A focus update occurs when someone else changes the focus
net.Receive("FProfile_focusUpdate", function()
	update({"server", "fromServer"}, true)

	local focusStr = net.ReadString()
	update({"server", "focusStr"}, focusStr)
	update({"server", "focusObj"}, net.ReadBool() and focusStr or nil)

	update({"server", "fromServer"}, false)
end)

--[[-------------------------------------------------------------------------
(Re)start profiling
---------------------------------------------------------------------------]]
local function restartProfiling()
	local shouldReset = get({"server", "shouldReset"})

	net.Start("FProfile_startProfiling")
		net.WriteBool(shouldReset)
	net.SendToServer()
end

net.Receive("FProfile_startProfiling", function()
	update({"server", "fromServer"}, true)
	update({"server", "status"}, "Started")
	update({"server", "recordTime"}, net.ReadDouble())
	update({"server", "sessionStart"}, net.ReadDouble())
	update({"server", "fromServer"}, false)
end)


--[[-------------------------------------------------------------------------
Stop profiling
---------------------------------------------------------------------------]]
local function stopProfiling()
	net.Start("FProfile_stopProfiling")
	net.SendToServer()
end

-- Read a row from a net message
local function readDataRow(countSize, readSpecific)
	local res = {}

	local count = net.ReadUInt(countSize)

	for i = 1, count do
		local row = {}
		row.info = {}

		row.func = net.ReadString()
		row.info.short_src = net.ReadString()
		row.info.linedefined = net.ReadUInt(16)
		row.info.lastlinedefined = net.ReadUInt(16)

		readSpecific(row)

		table.insert(res, row)
	end

	return res
end

-- Read a bottleneck row
local function readBottleneckRow(row)
	local nameCount = net.ReadUInt(8)

	row.names = {}
	for i = 1, nameCount do
		table.insert(row.names, {
			name = net.ReadString(),
			namewhat = net.ReadString()
		})
	end

	row.total_called = net.ReadUInt(32)
	row.total_time = net.ReadDouble()
	row.average_time = net.ReadDouble()
end

-- Read the top n row
local function readTopNRow(row)
	row.info.name = net.ReadString()
	row.info.namewhat = net.ReadString()
	row.runtime = net.ReadDouble()
end

net.Receive("FProfile_stopProfiling", function()
	update({"server", "fromServer"}, true)
	update({"server", "status"}, "Stopped")
	update({"server", "sessionStart"}, nil)
	update({"server", "recordTime"}, net.ReadDouble())

	update({"server", "bottlenecks"}, readDataRow(16, readBottleneckRow))
	update({"server", "topLagSpikes"}, readDataRow(8, readTopNRow))
	update({"server", "fromServer"}, false)
end)


--[[-------------------------------------------------------------------------
Start/stop recording when the recording status is changed
---------------------------------------------------------------------------]]
onUpdate({"server", "status"}, function(new, old)
	if new == old or get({"server", "fromServer"}) then return end
	(new == "Started" and restartProfiling or stopProfiling)()
end)


--[[-------------------------------------------------------------------------
Update info when a different line is selected
---------------------------------------------------------------------------]]
onUpdate({"server", "currentSelected"}, function(new)
	if not new or not new.info or not new.info.linedefined or not new.info.lastlinedefined or not new.info.short_src then return end

	net.Start("FProfile_getSource")
		net.WriteString(tostring(new.func))
	net.SendToServer()
end)

net.Receive("FProfile_getSource", function()
	update({"server", "sourceText"}, net.ReadString())
end)


--[[-------------------------------------------------------------------------
When a function is to be printed to console
---------------------------------------------------------------------------]]
onUpdate({"server", "toConsole"}, function(data)
	if not data then return end

	update({"server", "toConsole"}, nil)

	net.Start("FProfile_printFunction")
		net.WriteBool(data.total_called and true or false) -- true for bottleneck function, false for top-n function
		net.WriteString(tostring(data.func))
	net.SendToServer()
end)

net.Receive("FProfile_printFunction", function(len)
	local data = net.ReadData(len)
	local decompressed = util.Decompress(data)

	-- Print the text line by line, otherwise big parts of big data will not be printed
	local split = string.Explode("\n", decompressed, false)
	for _, line in ipairs(split) do
		MsgN(line)
	end

	-- Write the thing to a file
	file.CreateDir("fprofiler")
	file.Write("fprofiler/profiledata.txt", showStr(data))
	MsgC(Color(200, 200, 200), "-----", Color(120, 120, 255), "NOTE", Color(200, 200, 200), "---------------\n")
	MsgC(Color(200, 200, 200), "In the server's console you can find a colour coded version of the above output.\nIf the above function does not fit in console, you can find it in data/fprofiler/profiledata.txt\n\n")
end)


--[[-------------------------------------------------------------------------
Check access when the frame opens
Also request a full serverside model update
---------------------------------------------------------------------------]]
onUpdate("frameVisible", function(isOpen)
	-- Don't network if the server doesn't have FProfiler installed
	if util.NetworkStringToID("FProfile_fullModelUpdate") == 0 then
		update("serverAccess", false)
		return
	end

	-- Update access
	CAMI.PlayerHasAccess(LocalPlayer(), "FProfiler", function(b, _)
		update("serverAccess", b)
	end)

	if not isOpen then
		net.Start("FProfile_unsubscribe")
		net.SendToServer()

		return
	end

	net.Start("FProfile_fullModelUpdate")
	net.SendToServer()
end)


net.Receive("FProfile_fullModelUpdate", function()
	update({"server", "fromServer"}, true)

	local focusExists = net.ReadBool()
	if focusExists then
		local focus = net.ReadString()
		update({"server", "focusObj"}, focus)
		update({"server", "focusStr"}, focus)
	end

	local startingTimeExists = net.ReadBool()

	if startingTimeExists then
		update({"server", "status"}, "Started")
		update({"server", "sessionStart"}, net.ReadDouble())
	else
		update({"server", "status"}, "Stopped")
	end

	update({"server", "recordTime"}, net.ReadDouble())

	update({"server", "bottlenecks"}, readDataRow(16, readBottleneckRow))
	update({"server", "topLagSpikes"}, readDataRow(8, readTopNRow))

	update({"server", "fromServer"}, false)
end)


--lua/autorun/glowsticks_sfx_ammo.lua:
sound.Add(
{
    name = "Glowstick.Shake",
    channel = CHAN_USER_BASE+1,
    volume = 0.2,
	pitch = { 95, 110 },
    soundlevel = SNDLVL_IDLE,
    sound = "glowstick/glowstick_shake.wav"
})
sound.Add(
{
    name = "Glowstick.Snap",
    channel = CHAN_USER_BASE+1,
    volume = 0.7,
	pitch = { 95, 110 },
    soundlevel = SNDLVL_IDLE,
    sound = "glowstick/glowstick_snap.wav"
})
	
game.AddAmmoType( {
	name = "glowsticks",
	dmgtype = DMG_CRUSH,
	tracer = TRACER_NONE,
	plydmg = 0,
	npcdmg = 0,
	force = 0,
	maxcarry = 5
} )

cleanup.Register( "glowsticks" )
--addons/gm_express/lua/gm_express/cl_init.lua:
express._receiverMadeQueue = {}
express._canSendReceiverMade = false


net.Receive( "express_access", function()
    express:SetAccess( net.ReadString() )
    express:_sendReceiversMadeQueue()
end )

function express:_sendReceiversMadeQueue()
    express._canSendReceiverMade = true

    local messages = table.GetKeys( express._receiverMadeQueue )
    express:_alertReceiversMade( unpack( messages ) )
end

function express:_alertReceiversMade( ... )
    local names = { ... }
    local receiverCount = #names

    net.Start( "express_receivers_made" )
    net.WriteUInt( receiverCount, 8 )

    for i = 1, receiverCount do
        net.WriteString( names[i] )
    end

    net.SendToServer()
end


-- Registers a basic receiver --
function express.Receive( message, cb )
    express:_setReceiver( message, cb )

    if not express._canSendReceiverMade then
        express._receiverMadeQueue[message] = true
        return
    end

    express:_alertReceiversMade( message )
end


-- Calls the main _send function but passes nil for the recipient --
function express.Send( message, data, onProof )
    express:_send( message, data, nil, onProof )
end


function express:SetExpected( hash, cb )
    self._awaitingProof[hash] = cb
end

--lua/autorun/hanchewie.lua:
/*
	Addon by Voikanaa	
*/

player_manager.AddValidModel( "Han Solo", 		"models/player/han_solo.mdl" );
player_manager.AddValidHands( "Han Solo", 	"models/player/han_solo_hands.mdl", 0, "00000000" )
list.Set( "PlayerOptionsModel", "Han Solo", 	"models/player/han_solo.mdl" );

player_manager.AddValidModel( "Chewie", 		"models/player/chewie.mdl" );
player_manager.AddValidHands( "Chewie", 	"models/player/chewie_hands.mdl", 0, "00000000" )
list.Set( "PlayerOptionsModel", "Chewie", 	"models/player/chewie.mdl" );
--lua/autorun/install_tfa_base.lua:
local function checkForTFA()
	if TFA and TFA_BASE_VERSION and TFA_BASE_VERSION >= 4 then return end -- we're 100% good

	if CLIENT then
		Derma_Query(
			"The weapon(s) you have installed requires TFA Base. Use the button below to install it.",
			"Install TFA Base !!!",
			"Workshop",
			function() gui.OpenURL("http://steamcommunity.com/workshop/filedetails/?id=415143062") end
		)
	else
		print("#################### WARNING!!! ####################")
		print("The weapon(s) you have installed requires TFA Base.")
		print("http://steamcommunity.com/workshop/filedetails/?id=415143062")
		print("####################################################")
	end
end

hook.Add("InitPostEntity", "INSTALL TFA BASE", checkForTFA)
--lua/autorun/kneedeep_mountparticles.lua:
game.AddParticles("particles/fireflies_kneedeep.pcf")
--addons/lvs_base/lua/lvs_framework/autorun/cl_hud.lua:

--LVS.HudForceDefault = true

LVS.HudEditors = LVS.HudEditors or {}
LVS.HudEditorsHide = {}

local function ResetFrame( id )
	if not LVS.HudEditors[ id ] then return end

	LVS.HudEditors[ id ].w = LVS.HudEditors[ id ].DefaultWidth
	LVS.HudEditors[ id ].h = LVS.HudEditors[ id ].DefaultHeight
	LVS.HudEditors[ id ].X = LVS.HudEditors[ id ].DefaultX
	LVS.HudEditors[ id ].Y = LVS.HudEditors[ id ].DefaultY
	LVS.HudEditorsHide[ id ] = nil
end

local function MakeFrame( id, X, Y, w, h, minw, minh, text )
	local Frame = vgui.Create("DFrame")
	Frame:SetSize( w, h )
	Frame:SetPos( X, Y )
	Frame:SetTitle( text )
	Frame:SetScreenLock( true )
	Frame:MakePopup()
	Frame:SetSizable( true )
	Frame:SetMinWidth( minw )
	Frame:SetMinHeight( minh )
	Frame.id = id
	Frame.OnClose = function( self )
		ResetFrame( self.id )
	end
	Frame.Paint = function(self, w, h )
		surface.SetDrawColor(0,0,0,150)
		surface.DrawRect(0, 0, w, h)

		surface.SetDrawColor(80,80,80,255)
		surface.DrawRect(0, 0, 2, h)
		surface.DrawRect(w - 2, 0, 2, h)
		surface.DrawRect(0, 0, w, 2)
		surface.DrawRect(0, h - 2, w, 2)

		if not LVS.HudEditors[ self.id ] then return end

		local Width = self:GetWide()
		local Height = self:GetTall()

		LVS.HudEditors[ self.id ].w = Width
		LVS.HudEditors[ self.id ].h = Height

		LVS.HudEditors[ self.id ].X = math.min( self:GetX(), ScrW() - Width )
		LVS.HudEditors[ self.id ].Y = math.min( self:GetY(), ScrH() - Height )

		if self:IsDragging() or input.IsMouseDown( MOUSE_LEFT ) then return end

		local Ratio = LVS.HudEditors[ self.id ].DefaultHeight / LVS.HudEditors[ self.id ].DefaultWidth

		if math.Round( Height / Width, 2 ) ~= math.Round( Ratio ,2 ) then
			local NewHeight = Width * Ratio

			self:SetHeight( NewHeight )

			LVS.HudEditors[ self.id ].h = NewHeight
		end
	end

	local DCheckbox = vgui.Create( "DCheckBoxLabel", Frame )
	DCheckbox:Dock( RIGHT )
	DCheckbox:DockMargin( 0, 0, 0, 0 )
	DCheckbox:SetText("Hide")	
	DCheckbox:SizeToContents()
	DCheckbox.id = id
	DCheckbox:SetChecked( LVS.HudEditorsHide[ id ] == true )
	DCheckbox.OnChange = function( self, bVal )
		if not self.id then return end

		if bVal then LVS.HudEditorsHide[ self.id ] = true return end

		LVS.HudEditorsHide[ self.id ] = nil
	end

	LVS.HudEditors[ id ].Frame = Frame

	return Frame
end

local ScreenWidth = ScrW()
local ScreenHeight = ScrH()

local function SaveEditors()
	if LVS.HudForceDefault then return end

	if ScreenWidth ~= ScrW() or ScreenHeight ~= ScrH() then return end -- player changed resolution while ingame... don't save because everything is fucked up now...

	local SaveString = ""
	for id, data in pairs( LVS.HudEditors ) do
		local w = data.w
		local h = data.h

		local X = math.min( data.X / ScrW(), 1 )
		local Y = math.min( data.Y / ScrH(), 1 )

		local hide = LVS.HudEditorsHide[ id ] and "?" or " "

		SaveString = SaveString..id.."~"..hide.."~"..w.."#"..h.."/"..X.."#"..Y.."\n"
	end

	file.Write( "lvs_hud_settings.txt", SaveString )
end

local function LoadEditors()
	if LVS.HudForceDefault then return end

	local LoadString = file.Read( "lvs_hud_settings.txt" )

	if not LoadString then return end

	for _, garbage in pairs( string.Explode( "\n", LoadString ) ) do
		local data1 = string.Explode( "~", garbage )

		if not data1[3] then continue end

		local data2 =  string.Explode( "/", data1[3] )

		local size = string.Explode( "#", data2[1] )
		local pos = string.Explode( "#", data2[2] )

		local ID = data1[1]

		if not LVS.HudEditors[ ID ] or not size[1] or not size[2] or not pos[1] or not pos[2] then continue end

		LVS.HudEditors[ ID ].w = math.max( LVS.HudEditors[ ID ].minw, size[1] )
		LVS.HudEditors[ ID ].h = math.max( LVS.HudEditors[ ID ].minh, size[2] )
		LVS.HudEditors[ ID ].X = math.min( pos[1] * ScrW(), ScrW() - size[1] )
		LVS.HudEditors[ ID ].Y = math.min( pos[2] * ScrH(), ScrH() - size[2] )

		if data1[2] == "?" then
			LVS.HudEditorsHide[ ID ] = true
		end
	end
end

function LVS:AddHudEditor( id, X, Y, w, h, minw, minh, text, func )
	LVS.HudEditors[ id ] = {
		DefaultX = X,
		DefaultY = Y,
		DefaultWidth = w,
		DefaultHeight = h,
		X = X,
		Y = Y,
		w = w,
		h = h,
		minw = minw,
		minh = minh,
		text = text,
		func = func,
	}
end

hook.Add( "OnContextMenuOpen", "!!!!!LVS_hud", function()
	if not IsValid( LocalPlayer():lvsGetVehicle() ) then return end

	if not GetConVar( "lvs_edit_hud" ):GetBool() then return end

	LVS:OpenEditors()

	return false
end )

hook.Add( "InitPostEntity", "!!!lvs_load_hud", function()
	LoadEditors()
end )

function LVS:OpenEditors()
	for id, editor in pairs( LVS.HudEditors ) do
		if IsValid( editor.Frame ) then continue end

		MakeFrame( id, editor.X, editor.Y, editor.w, editor.h, editor.minw, editor.minh, editor.text )
	end

	local T = CurTime()
	local ply = LocalPlayer()
	local pod = ply:GetVehicle()

	ply.SwitcherTime = T + 9999

	if not IsValid( pod ) then return end

	pod._SelectActiveTime = T + 9999
end

function LVS:CloseEditors()
	SaveEditors()

	for id, editor in pairs( LVS.HudEditors ) do
		if not IsValid( editor.Frame ) then continue end
		editor.Frame:Remove()
	end

	local T = CurTime()
	local ply = LocalPlayer()
	local pod = ply:GetVehicle()

	ply.SwitcherTime = T

	if not IsValid( pod ) then return end

	pod._SelectActiveTime = T
end

hook.Add( "OnContextMenuClose", "!!!!!LVS_hud", function()
	LVS:CloseEditors()
end )

function LVS:DrawDiamond( X, Y, radius, perc )
	if perc <= 0 then return end

	local segmentdist = 90

	draw.NoTexture()

	for a = 90, 360, segmentdist do
		local Xa = math.Round( math.sin( math.rad( -a ) ) * radius, 0 )
		local Ya = math.Round( math.cos( math.rad( -a ) ) * radius, 0 )

		local C = math.sqrt( radius ^ 2 + radius ^ 2 )

		if a == 90 then
			C = C * math.min(math.max(perc - 0.75,0) / 0.25,1)
		elseif a == 180 then
			C = C * math.min(math.max(perc - 0.5,0) / 0.25,1)
		elseif a == 270 then
			C = C * math.min(math.max(perc - 0.25,0) / 0.25,1)
		elseif a == 360 then
			C = C * math.min(math.max(perc,0) / 0.25,1)
		end

		if C > 0 then
			local AxisMoveX = math.Round( math.sin( math.rad( -a + 135) ) * (C + 3) * 0.5, 0 )
			local AxisMoveY =math.Round( math.cos( math.rad( -a + 135) ) * (C + 3) * 0.5, 0 )

			surface.DrawTexturedRectRotated(X - Xa - AxisMoveX, Y - Ya - AxisMoveY,3, math.ceil( C ), a - 45)
		end
	end
end

local function PaintIdentifier( ent )
	if not LVS.ShowIdent or LVS:IsIndicatorForced() then return end

	local VehicleIdentifierRange = ent.VehicleIdentifierRange
	local MyPos = ent:GetPos()
	local MyTeam = ent:GetAITEAM()

	for _, v in pairs( LVS:GetVehicles() ) do
		if not IsValid( v ) or v == ent then continue end

		local rPos = v:LocalToWorld( v:OBBCenter() )

		local Pos = rPos:ToScreen()
		local Dist = (MyPos - rPos):Length()

		if Dist > VehicleIdentifierRange or util.TraceLine( {start = ent:LocalToWorld( ent:OBBCenter() ),endpos = rPos,mask = MASK_NPCWORLDSTATIC,} ).Hit then continue end

		local Alpha = 255 * (1 - (Dist / VehicleIdentifierRange) ^ 2)
		local Team = v:GetAITEAM()
		local IndicatorColor = Color( 255, 0, 0, Alpha )

		if Team == 0 then
			if MyTeam == 0 then continue end

			IndicatorColor = Color( 0, 255, 0, Alpha )
		else
			if Team == 1 or Team == 2 then
				if Team ~= MyTeam and MyTeam ~= 0 then
					IndicatorColor = Color( 255, 0, 0, Alpha )
				else
					IndicatorColor = Color( 0, 127, 255, Alpha )
				end
			end
		end

		if Team > 3 then continue end

		v:LVSHudPaintVehicleIdentifier( Pos.x, Pos.y, IndicatorColor )
	end
end

hook.Add( "HUDPaint", "!!!!!LVS_hud", function()
	local ply = LocalPlayer()

	if ply:GetViewEntity() ~= ply then return end

	local Pod = ply:GetVehicle()
	local Parent = ply:lvsGetVehicle()

	if not IsValid( Pod ) or not IsValid( Parent ) then
		ply._lvsoldPassengers = {}

		return
	end

	local X = ScrW()
	local Y = ScrH()

	PaintIdentifier( Parent )
	Parent:LVSHudPaint( X, Y, ply )

	local base = Pod:lvsGetWeapon()
	if IsValid( base ) then
		local weapon = base:GetActiveWeapon()
		if weapon and weapon.HudPaint then
			weapon.HudPaint( base, X, Y, ply )
		end
	else
		local weapon = Parent:GetActiveWeapon()
		if ply == Parent:GetDriver() and weapon and weapon.HudPaint then
			weapon.HudPaint( Parent, X, Y, ply )
		end
	end

	for id, editor in pairs( LVS.HudEditors ) do
		if LVS.HudEditorsHide[ id ] then continue end

		local ScaleX = editor.w / editor.DefaultWidth
		local ScaleY = editor.h / editor.DefaultHeight

		local PosX = editor.X / ScaleX
		local PosY = editor.Y / ScaleY

		local Width = editor.w / ScaleX
		local Height = editor.h / ScaleY

		local ScrW = X / ScaleX
		local ScrH = Y / ScaleY

		if ScaleX == 1 and ScaleY == 1 then
			editor:func( Parent, PosX, PosY, Width, Height, ScrW, ScrH, ply )
		else
			local m = Matrix()
			m:Scale( Vector( ScaleX, ScaleY, 1 ) )

			cam.PushModelMatrix( m )
				editor:func( Parent, PosX, PosY, Width, Height, ScrW, ScrH, ply )
			cam.PopModelMatrix()
		end
	end
end )
--addons/lvs_base/lua/lvs_framework/autorun/lvs_force_directinput.lua:

local cVar_forcedirect = CreateConVar( "lvs_force_directinput", "0", {FCVAR_REPLICATED , FCVAR_ARCHIVE},"Force Direct Input Steering Method?" )
local cVar_forceindicator = CreateConVar( "lvs_force_forceindicator", "0", {FCVAR_REPLICATED , FCVAR_ARCHIVE},"Force Direct Input Steering Method?" )

function LVS:IsDirectInputForced()
	return LVS.ForceDirectInput == true
end

function LVS:IsIndicatorForced()
	return LVS.ForceIndicator == true
end

if SERVER then
	util.AddNetworkString( "lvs_forced_input_getter" )

	local function UpdateForcedSettings( ply )
		net.Start( "lvs_forced_input_getter" )

		net.WriteBool( LVS:IsDirectInputForced() )
		net.WriteBool( LVS:IsIndicatorForced() )

		if IsValid( ply ) then
			net.Send( ply )
		else
			net.Broadcast()
		end
	end

	LVS.ForceDirectInput = cVar_forcedirect and cVar_forcedirect:GetBool() or false
	cvars.AddChangeCallback( "lvs_force_directinput", function( convar, oldValue, newValue ) 
		LVS.ForceDirectInput = tonumber( newValue ) ~=0

		UpdateForcedSettings()
	end)

	LVS.ForceIndicator = cVar_forceindicator and cVar_forceindicator:GetBool() or false
	cvars.AddChangeCallback( "lvs_force_forceindicator", function( convar, oldValue, newValue ) 
		LVS.ForceIndicator = tonumber( newValue ) ~=0

		UpdateForcedSettings()
	end)

	net.Receive( "lvs_forced_input_getter", function( length, ply )
		UpdateForcedSettings( ply )
	end)
else
	net.Receive( "lvs_forced_input_getter", function( length )
		LVS.ForceDirectInput = net.ReadBool()
		LVS.ForceIndicator = net.ReadBool()
	end )

	hook.Add( "InitPostEntity", "!11!!!lvsIsPlayerReady", function()
		net.Start( "lvs_forced_input_getter" )
		net.SendToServer()
	end )
end
--addons/openpermissions/lua/autorun/openpermissions.lua:
OpenPermissions_Readying = true
OpenPermissions_Ready = nil

if (CLIENT and IsValid(OpenPermissions_Menu)) then
	OpenPermissions_Menu:Close()
end

OpenPermissions = {}
OpenPermissions.pon = include("openpermissions/thirdparty/pon.lua")

OpenPermissions.Version = "v1.0"

OpenPermissions.COLOR_WHITE      = Color(255,255,255)
OpenPermissions.COLOR_LIGHT_BLUE = Color(0,255,255)
OpenPermissions.COLOR_YELLOW     = Color(0,255,255)
OpenPermissions.COLOR_RED        = Color(255,0,0)
OpenPermissions.COLOR_GREEN      = Color(0,255,0)
OpenPermissions.COLOR_BLACK      = Color(0,0,0)
OpenPermissions.COLOR_SOFT_GREEN = Color(76,216,76)
OpenPermissions.COLOR_SOFT_RED   = Color(216,76,76)

local version_info = "Version: " .. OpenPermissions.Version
local padding = (65 - #version_info) / 2
local version_str = (" "):rep(math.ceil(padding)) .. version_info .. (" "):rep(math.floor(padding))

local github_link = "https://github.com/WilliamVenner/GLua-OpenPermissions"
local padding = (65 - #github_link) / 2
local github_str = (" "):rep(math.ceil(padding)) .. github_link .. (" "):rep(math.floor(padding))

MsgC(OpenPermissions.COLOR_YELLOW, [[

     _____             _____               _         _             
    |     |___ ___ ___|  _  |___ ___ _____|_|___ ___|_|___ ___ ___ 
    |  |  | . | -_|   |   __| -_|  _|     | |_ -|_ -| | . |   |_ -|
    |_____|  _|___|_|_|__|  |___|_| |_|_|_|_|___|___|_|___|_|_|___|
          |_|                                                      

]])
MsgC(OpenPermissions.COLOR_GREEN,  "  [=================================================================]\n")
MsgC(OpenPermissions.COLOR_YELLOW, "  [" ..                       version_str                       .. "]\n")
MsgC(OpenPermissions.COLOR_YELLOW, "  [" ..                       github_str                        .. "]\n")
MsgC(OpenPermissions.COLOR_GREEN,  "  [=================================================================]\n\n")

function OpenPermissions:Print(msg, prefix, color)
	MsgC(color or Color(0,255,255), "[OpenPermissions] " .. (prefix or "") .. " ", Color(255,255,255), msg, "\n")
end
function OpenPermissions:ChatPrint(msg, prefix, color)
	chat.AddText(color or Color(0,255,255), "[OpenPermissions] " .. (prefix or "") .. " ", Color(255,255,255), msg)
end

--## BillysErrors ##--

if (file.Exists("includes/modules/billyserrors.lua", "LUA")) then
	require("billyserrors")
end
if (SERVER and BillysErrors) then
	OpenPermissions.BillysErrors = BillysErrors:AddAddon({
		Name  = "OpenPermissions",
		Color = Color(80,0,255),
		Icon  = "icon16/group.png",
	})
end

--## Initialize configs ##--
OpenPermissions.Operators = {}

local function InstallConfigAddon()
	if (SERVER and BillysErrors) then
		OpenPermissions.BillysErrors:AddMessage("Looks like the OpenPermissions Config Addon has not been installed to your server: ", {Link = "https://gmodsto.re/openpermissions-config-addon"}, "\nYou need to install this addon in order to use & configure OpenPermissions.")
	else
		OpenPermissions:Print("Looks like the OpenPermissions Config Addon has not been installed to your server: https://gmodsto.re/openpermissions-config-addon\nYou need to install this addon in order to use & configure OpenPermissions.", "[ERROR]", OpenPermissions.COLOR_RED)
	end
end

if (not file.Exists("openpermissions_config.lua", "LUA")) then
	return InstallConfigAddon()
else
	local config_worked = include("openpermissions_config.lua")
	if (not config_worked) then
		if (SERVER and BillysErrors) then
			OpenPermissions.BillysErrors:AddMessage("Your config file appears to have an error! Please fix the errors by looking above or by resetting to the default config.")
		else
			OpenPermissions:Print("Your config file appears to have an error! Please fix the errors by looking above or by resetting to the default config.", "[ERROR]", OpenPermissions.COLOR_RED)
		end
		return
	end
end

if (not file.Exists("openpermissions_lua_functions.lua", "LUA")) then
	return InstallConfigAddon()
else
	local config_worked = include("openpermissions_lua_functions.lua")
	if (not config_worked) then
		if (SERVER and BillysErrors) then
			OpenPermissions.BillysErrors:AddMessage("Your Lua functions file appears to have an error! Please fix the errors by looking above or by resetting to the default Lua functions config.")
		else
			OpenPermissions:Print("Your Lua functions file appears to have an error! Please fix the errors by looking above or by resetting to the default Lua functions config.", "[ERROR]", OpenPermissions.COLOR_RED)
		end
		return
	else
		OpenPermissions.LuaFunctions = config_worked
	end
end

--## Languages ##--

if (CLIENT) then
	function OpenPermissions.L(phrase)
		return OpenPermissions.LANG.Phrases[phrase] or OpenPermissions.LANG_ENGLISH.Phrases[phrase] or phrase
	end
	function OpenPermissions.Lf(phrase, ...)
		return (OpenPermissions.LANG.Phrases[phrase] or OpenPermissions.LANG_ENGLISH.Phrases[phrase] or phrase):format(...)
	end

	function OpenPermissions:LoadPhrasebook()
		if (not file.Exists("openpermissions_lang.txt", "DATA")) then
			file.Write("openpermissions_lang.txt", "english")
		end
		local selected_language = file.Read("openpermissions_lang.txt", "DATA")
		if (not selected_language or not file.Find("openpermissions/lang/" .. selected_language .. ".lua", "LUA")) then selected_language = "english" end
		OpenPermissions.LANG_ENGLISH = include("openpermissions/lang/english.lua")
		if (selected_language == "english" or not file.Exists("openpermissions/lang/" .. selected_language .. ".lua", "LUA")) then
			OpenPermissions.LANG = OpenPermissions.LANG_ENGLISH or {}
		else
			OpenPermissions.LANG = include("openpermissions/lang/" .. selected_language .. ".lua") or {}
		end
	end
	OpenPermissions:LoadPhrasebook()
else
	local fs = file.Find("openpermissions/lang/*.lua", "LUA")
	for _,f in ipairs(fs) do
		AddCSLuaFile("openpermissions/lang/" .. f)
	end
end

--## Enums and Data Structures ##--

OpenPermissions.ACCESS_GROUP = {}
OpenPermissions.ACCESS_GROUP.USERGROUP = 1
OpenPermissions.ACCESS_GROUP.STEAMID = 2
OpenPermissions.ACCESS_GROUP.TEAM = 3
OpenPermissions.ACCESS_GROUP.LUA_FUNCTION = 4
OpenPermissions.ACCESS_GROUP.DARKRP_CATEGORY = 5

OpenPermissions.ACCESS_GROUP_KEY = {
	[OpenPermissions.ACCESS_GROUP.USERGROUP] = Color(216,76,76),
	[OpenPermissions.ACCESS_GROUP.STEAMID] = Color(81,174,255),
	[OpenPermissions.ACCESS_GROUP.TEAM] = Color(76,216,76),
	[OpenPermissions.ACCESS_GROUP.LUA_FUNCTION] = Color(76,76,216),
	[OpenPermissions.ACCESS_GROUP.DARKRP_CATEGORY] = Color(255,163,71),
}

OpenPermissions.CHECKBOX = {}
OpenPermissions.CHECKBOX.INHERIT = 0
OpenPermissions.CHECKBOX.TICKED = 1
OpenPermissions.CHECKBOX.CROSSED = 2

--## Add resources ##--

if (SERVER) then
	resource.AddWorkshop("1603635147")
	for _,f in ipairs((file.Find("materials/openpermissions/*.vmt", "GAME"))) do
		resource.AddFile("materials/openpermissions/" .. f)
	end
end

local function IsDarkRPCheck()
	hook.Remove(SERVER and "PlayerConnect" or "InitPostEntity", "OpenPermissions.IsDarkRP")
	OpenPermissions.IsDarkRP = DarkRP and DarkRP.getCategories and RPExtraTeams and true
end
hook.Add(SERVER and "PlayerConnect" or "InitPostEntity", "OpenPermissions.IsDarkRP", IsDarkRPCheck)

--## Initialize files ##--
include("openpermissions/sh.lua")
if (SERVER) then
	AddCSLuaFile("openpermissions/thirdparty/pon.lua")
	AddCSLuaFile("openpermissions_config.lua")
	AddCSLuaFile("openpermissions_lua_functions.lua")
	AddCSLuaFile("openpermissions/sh.lua")
	AddCSLuaFile("openpermissions/cl.lua")

	include("openpermissions/sv.lua")
else
	include("openpermissions/cl.lua")
end
--lua/autorun/r2.lua:
player_manager.AddValidModel( "Astromech R2", "models/ace/sw/r2.mdl" );
list.Set( "PlayerOptionsModel",  "Astromech R2", "models/ace/sw/r2.mdl" );
--lua/autorun/r5.lua:
player_manager.AddValidModel( "Astromech R5", "models/ace/sw/r5.mdl" );
list.Set( "PlayerOptionsModel",  "Astromech R5", "models/ace/sw/r5.mdl" );
--lua/autorun/rb655_ext_props.lua:

AddCSLuaFile()

local function rb655_property_filter( filtor, ent, ply )
	if ( type( filtor ) == "string" and filtor != ent:GetClass() ) then return false end
	if ( type( filtor ) == "table" and !table.HasValue( filtor, ent:GetClass() ) ) then return false end
	if ( type( filtor ) == "function" and !filtor( ent, ply ) ) then return false end

	return true
end

function AddEntFunctionProperty( name, label, pos, filtor, func, icon )
	properties.Add( name, {
		MenuLabel = label,
		MenuIcon = icon,
		Order = pos,
		Filter = function( self, ent, ply )
			if ( !IsValid( ent ) or !gamemode.Call( "CanProperty", ply, name, ent ) ) then return false end
			if ( !rb655_property_filter( filtor, ent, ply ) ) then return false end
			return true
		end,
		Action = function( self, ent )
			self:MsgStart()
				net.WriteEntity( ent )
			self:MsgEnd()
		end,
		Receive = function( self, length, ply )
			local ent = net.ReadEntity()

			if ( !IsValid( ply ) or !IsValid( ent ) or !self:Filter( ent, ply ) ) then return false end

			func( ent, ply )
		end
	} )
end

function AddEntFireProperty( name, label, pos, class, input, icon )
	AddEntFunctionProperty( name, label, pos, class, function( e ) e:Fire( unpack( string.Explode( " ", input ) ) ) end, icon )
end




if ( SERVER ) then

	local SyncFuncs = {}

	SyncFuncs.prop_door_rotating = function( ent )
		ent:SetNWBool( "Locked", ent:GetInternalVariable( "m_bLocked" ) )
		local state = ent:GetInternalVariable( "m_eDoorState" )
		ent:SetNWBool( "Closed", state == 0 or state == 3 )
	end
	SyncFuncs.func_door = function( ent )
		ent:SetNWBool( "Locked", ent:GetInternalVariable( "m_bLocked" ) )
		--[[local state = ent:GetInternalVariable( "m_eDoorState" )
		ent:SetNWBool( "Closed", state == 0 or state == 3 )]]
	end
	SyncFuncs.func_door_rotating = function( ent )
		ent:SetNWBool( "Locked", ent:GetInternalVariable( "m_bLocked" ) )
		--[[local state = ent:GetInternalVariable( "m_eDoorState" )
		ent:SetNWBool( "Closed", state == 0 or state == 3 )]]
	end
	SyncFuncs.prop_vehicle_jeep = function( ent )
		ent:SetNWBool( "Locked", ent:GetInternalVariable( "VehicleLocked" ) )
		ent:SetNWBool( "HasDriver", IsValid( ent:GetDriver() ) )
		ent:SetNWBool( "m_bRadarEnabled", ent:GetInternalVariable( "m_bRadarEnabled" ) )
	end
	SyncFuncs.prop_vehicle_airboat = function( ent )
		ent:SetNWBool( "Locked", ent:GetInternalVariable( "VehicleLocked" ) )
		ent:SetNWBool( "HasDriver", IsValid( ent:GetDriver() ) )
	end
	--[[SyncFuncs.prop_vehicle_prisoner_pod = function( ent )
		ent:SetNWBool( "Locked", ent:GetInternalVariable( "VehicleLocked" ) )
		ent:SetNWBool( "HasDriver", IsValid( ent:GetDriver() ) )
	end]]
	SyncFuncs.func_tracktrain = function( ent )
		ent:SetNWInt( "m_dir", ent:GetInternalVariable( "m_dir" ) )
		ent:SetNWBool( "m_moving", ent:GetInternalVariable( "speed" ) != 0 )
		--[[local driver = ent:GetDriver()
		ent:SetNWBool( "HasDriver", IsValid( driver ) )]]
	end

	-- Periodically sync server data to clients.
	local nextSync = 0
	hook.Add( "Tick", "rb655_propperties_sync", function()
		if ( nextSync > CurTime() ) then return end
		nextSync = CurTime() + 1

		for id, ent in ents.Iterator() do
			if ( SyncFuncs[ ent:GetClass() ] ) then
				SyncFuncs[ ent:GetClass() ]( ent )
			end
		end
	end )

end



local ExplodeIcon = "icon16/bomb.png"
local EnableIcon = "icon16/tick.png"
local DisableIcon = "icon16/cross.png"
local ToggleIcon = "icon16/arrow_switch.png"

-------------------------------------------------- Half - Life 2 Specific --------------------------------------------------

AddEntFireProperty( "rb655_door_open", "Open", 655, function( ent, ply )
	if ( !ent:GetNWBool( "Closed" ) and ent:GetClass() == "prop_door_rotating" ) then return false end

	return rb655_property_filter( { "prop_door_rotating", "func_door_rotating", "func_door" }, ent, ply )
end, "Open", "icon16/door_open.png" )
AddEntFireProperty( "rb655_door_close", "Close", 656, function( ent, ply )
	if ( ent:GetNWBool( "Closed" ) and ent:GetClass() == "prop_door_rotating" ) then return false end

	return rb655_property_filter( { "prop_door_rotating", "func_door_rotating", "func_door" }, ent, ply )
end, "Close", "icon16/door.png" )
AddEntFireProperty( "rb655_door_lock", "Lock", 657, function( ent, ply )
	if ( ent:GetNWBool( "Locked" ) and ent:GetClass() != "prop_vehicle_prisoner_pod" ) then return false end

	return rb655_property_filter( { "prop_door_rotating", "func_door_rotating", "func_door", "prop_vehicle_jeep", "prop_vehicle_airboat", "prop_vehicle_prisoner_pod" }, ent, ply )
end, "Lock", "icon16/lock.png" )
AddEntFireProperty( "rb655_door_unlock", "Unlock", 658, function( ent, ply )
	if ( !ent:GetNWBool( "Locked" ) and ent:GetClass() != "prop_vehicle_prisoner_pod" ) then return false end

	return rb655_property_filter( { "prop_door_rotating", "func_door_rotating", "func_door", "prop_vehicle_jeep", "prop_vehicle_airboat", "prop_vehicle_prisoner_pod" }, ent, ply )
end, "Unlock", "icon16/lock_open.png" )

AddEntFireProperty( "rb655_func_movelinear_open", "Start", 655, "func_movelinear", "Open", "icon16/arrow_right.png" )
AddEntFireProperty( "rb655_func_movelinear_close", "Return", 656, "func_movelinear", "Close", "icon16/arrow_left.png" )

AddEntFireProperty( "rb655_func_tracktrain_StartForward", "Start Forward", 655, function( ent, ply )
	if ( ent:GetNWInt( "m_dir" ) == 1 ) then return false end

	return rb655_property_filter( "func_tracktrain", ent, ply )
end, "StartForward", "icon16/arrow_right.png" )
AddEntFireProperty( "rb655_func_tracktrain_StartBackward", "Start Backward", 656, function( ent, ply )
	if ( ent:GetNWInt( "m_dir" ) == -1 ) then return false end

	return rb655_property_filter( "func_tracktrain", ent, ply )
end, "StartBackward", "icon16/arrow_left.png" )
--AddEntFireProperty( "rb655_func_tracktrain_Reverse", "Reverse", 657, "func_tr2acktrain", "Reverse", "icon16/arrow_undo.png" ) -- Same as two above
AddEntFireProperty( "rb655_func_tracktrain_Stop", "Stop", 658, function( ent, ply )
	if ( !ent:GetNWBool( "m_moving" ) ) then return false end

	return rb655_property_filter( "func_tracktrain", ent, ply )
end, "Stop", "icon16/shape_square.png" )
AddEntFireProperty( "rb655_func_tracktrain_Resume", "Resume", 659, function( ent, ply )
	if ( ent:GetNWInt( "m_moving" ) ) then return false end

	return rb655_property_filter( "func_tracktrain", ent, ply )
end, "Resume", "icon16/resultset_next.png" )
--AddEntFireProperty( "rb655_func_tracktrain_Toggle", "Toggle", 660, "func_track2train", "Toggle", ToggleIcon ) -- Same as two above

AddEntFireProperty( "rb655_breakable_break", "Break", 655, function( ent, ply )
	if ( ent:Health() < 1 ) then return false end

	return rb655_property_filter( { "func_breakable", "func_physbox", "prop_physics", "func_pushable" }, ent, ply )
end, "Break", ExplodeIcon ) -- Do not include item_item_crate, it insta crashes the server, dunno why.



local dissolve_id = 0
local dissolver
function rb655_dissolve( ent )
	local phys = ent:GetPhysicsObject()
	if ( IsValid( phys ) ) then phys:EnableGravity( false ) end

	if ( !IsValid( dissolver ) ) then
		dissolver = ents.Create( "env_entity_dissolver" )
		dissolver:SetPos( ent:GetPos() )
		dissolver:Spawn()
		dissolver:Activate()
		dissolver:SetKeyValue( "magnitude", 100 )
		dissolver:SetKeyValue( "dissolvetype", 0 )
	end

	ent:SetName( "rb655_dissolve" .. dissolve_id )
	dissolver:Fire( "Dissolve", "rb655_dissolve" .. dissolve_id )
	dissolve_id = dissolve_id + 1

	-- Clean it up if it is not being used for 60 seconds
	timer.Create( "rb655_ep_cleanupDissolver", 60, 1, function()
		if ( IsValid( dissolver ) ) then dissolver:Remove() end
	end )
end

AddEntFunctionProperty( "rb655_dissolve", "Disintegrate", 657, function( ent, ply )
	if ( ent:GetModel() and ent:GetModel():StartWith( "*" ) ) then return false end
	if ( ent:IsPlayer() ) then return false end

	return true
end, function( ent )
	rb655_dissolve( ent )
end, "icon16/wand.png" )



AddEntFireProperty( "rb655_turret_toggle", "Toggle", 655, { "npc_combine_camera", "npc_turret_ceiling", "npc_turret_floor" }, "Toggle", ToggleIcon )
AddEntFireProperty( "rb655_self_destruct", "Self Destruct", 656, { "npc_turret_floor", "npc_helicopter" }, "SelfDestruct", ExplodeIcon )

AddEntFunctionProperty( "rb655_turret_ammo_remove", "Deplete Ammo", 657, function( ent )
	if ( bit.band( ent:GetSpawnFlags(), 256 ) == 256 ) then return false end
	if ( ent:GetClass() == "npc_turret_floor" or ent:GetClass() == "npc_turret_ceiling" ) then return true end
	return false
end, function( ent )
	ent:SetKeyValue( "spawnflags", bit.bor( ent:GetSpawnFlags(), 256 ) )
	ent:Activate()
end, "icon16/delete.png" )

AddEntFunctionProperty( "rb655_turret_ammo_restore", "Restore Ammo", 658, function( ent )
	if ( bit.band( ent:GetSpawnFlags(), 256 ) == 0 ) then return false end
	if ( ent:GetClass() == "npc_turret_floor" or ent:GetClass() == "npc_turret_ceiling" ) then return true end
	return false
end, function( ent )
	ent:SetKeyValue( "spawnflags", bit.bxor( ent:GetSpawnFlags(), 256 ) )
	ent:Activate()
end, "icon16/add.png" )

AddEntFunctionProperty( "rb655_turret_make_friendly", "Make Friendly", 659, function( ent )
	if ( bit.band( ent:GetSpawnFlags(), 512 ) == 512 ) then return false end
	if ( ent:GetClass() == "npc_turret_floor" ) then return true end
	return false
end, function( ent )
	ent:SetKeyValue( "spawnflags", bit.bor( ent:GetSpawnFlags(), SF_FLOOR_TURRET_CITIZEN ) )
	--ent:SetMaterial( "models/combine_turrets/floor_turret/floor_turret_citizen" )
	ent:Activate()
end, "icon16/user_green.png" )

AddEntFunctionProperty( "rb655_turret_make_hostile", "Make Hostile", 660, function( ent )
	if ( bit.band( ent:GetSpawnFlags(), 512 ) == 0 ) then return false end
	if ( ent:GetClass() == "npc_turret_floor" ) then return true end
	return false
end, function( ent )
	ent:SetKeyValue( "spawnflags", bit.bxor( ent:GetSpawnFlags(), SF_FLOOR_TURRET_CITIZEN ) )
	ent:Activate()
end, "icon16/user_red.png" )

AddEntFireProperty( "rb655_suitcharger_recharge", "Recharge", 655, "item_suitcharger", "Recharge", "icon16/arrow_refresh.png" )

AddEntFireProperty( "rb655_manhack_jam", "Jam", 655, "npc_manhack", "InteractivePowerDown", ExplodeIcon )

AddEntFireProperty( "rb655_scanner_mineadd", "Equip Mine", 655, "npc_clawscanner", "EquipMine", "icon16/add.png" )
AddEntFireProperty( "rb655_scanner_minedeploy", "Deploy Mine", 656, "npc_clawscanner", "DeployMine", "icon16/arrow_down.png" ) -- m_bIsOpen
AddEntFireProperty( "rb655_scanner_disable_spotlight", "Disable Spotlight", 658, { "npc_clawscanner", "npc_cscanner" }, "DisableSpotlight", DisableIcon ) -- SpotlightDisabled

-- AddEntFireProperty( "rb655_dropship_d1", "1", 655, "npc_combinedropship", "DropMines 1", DisableIcon )

AddEntFireProperty( "rb655_rollermine_selfdestruct", "Self Destruct", 655, "npc_rollermine", "InteractivePowerDown", ExplodeIcon )
AddEntFireProperty( "rb655_rollermine_turnoff", "Turn Off", 656, "npc_rollermine", "TurnOff", DisableIcon ) -- m_bTurnedOn
AddEntFireProperty( "rb655_rollermine_turnon", "Turn On", 657, "npc_rollermine", "TurnOn", EnableIcon )

AddEntFireProperty( "rb655_helicopter_gun_on", "Enable Turret", 655, "npc_helicopter", "GunOn", EnableIcon ) -- m_fHelicopterFlags = 1?
AddEntFireProperty( "rb655_helicopter_gun_off", "Disable Turret", 656, "npc_helicopter", "GunOff", DisableIcon ) -- m_fHelicopterFlags = 0?
AddEntFireProperty( "rb655_helicopter_dropbomb", "Drop Bomb", 657, "npc_helicopter", "DropBomb", "icon16/arrow_down.png" )
AddEntFireProperty( "rb655_helicopter_norm_shoot", "Start Normal Shooting", 660, "npc_helicopter", "StartNormalShooting", "icon16/clock.png" ) -- m_nShootingMode = 0
AddEntFireProperty( "rb655_helicopter_long_shoot", "Start Long Cycle Shooting", 661, "npc_helicopter", "StartLongCycleShooting", "icon16/clock_red.png" ) -- m_nShootingMode = 1
AddEntFireProperty( "rb655_helicopter_deadly_on", "Enable Deadly Shooting", 662, "npc_helicopter", "EnableDeadlyShooting", EnableIcon ) -- m_bDeadlyShooting
AddEntFireProperty( "rb655_helicopter_deadly_off", "Disable Deadly Shooting", 663, "npc_helicopter", "DisableDeadlyShooting", DisableIcon )

AddEntFireProperty( "rb655_gunship_OmniscientOn", "Enable Omniscient", 655, "npc_combinegunship", "OmniscientOn", EnableIcon ) -- m_fOmniscient
AddEntFireProperty( "rb655_gunship_OmniscientOff", "Disable Omniscient", 656, "npc_combinegunship", "OmniscientOff", DisableIcon )
AddEntFireProperty( "rb655_gunship_BlindfireOn", "Enable Blindfire", 657, "npc_combinegunship", "BlindfireOn", EnableIcon ) -- m_fBlindfire
AddEntFireProperty( "rb655_gunship_BlindfireOff", "Disable Blindfire", 658, "npc_combinegunship", "BlindfireOff", DisableIcon )

AddEntFireProperty( "rb655_alyx_HolsterWeapon", "Holster Weapon", 655, function( ent )
	if ( !ent:IsNPC() or ent:GetClass() != "npc_alyx" or !IsValid( ent:GetActiveWeapon() ) ) then return false end
	return true
end, "HolsterWeapon", "icon16/gun.png" )
AddEntFireProperty( "rb655_alyx_UnholsterWeapon", "Unholster Weapon", 656, "npc_alyx", "UnholsterWeapon", "icon16/gun.png" )
AddEntFireProperty( "rb655_alyx_HolsterAndDestroyWeapon", "Holster And Destroy Weapon", 657, function( ent )
	if ( !ent:IsNPC() or ent:GetClass() != "npc_alyx" or !IsValid( ent:GetActiveWeapon() ) ) then return false end
	return true
end, "HolsterAndDestroyWeapon", "icon16/gun.png" )

AddEntFireProperty( "rb655_antlion_burrow", "Burrow", 655, { "npc_antlion" , "npc_antlion_worker" }, "BurrowAway", "icon16/arrow_down.png" )
AddEntFireProperty( "rb655_barnacle_free", "Free Target", 655, "npc_barnacle", "LetGo", "icon16/heart.png" )

AddEntFireProperty( "rb655_zombine_suicide", "Suicide", 655, "npc_zombine", "PullGrenade", ExplodeIcon )
AddEntFireProperty( "rb655_zombine_sprint", "Sprint", 656, "npc_zombine", "StartSprint", "icon16/flag_blue.png" )

AddEntFireProperty( "rb655_thumper_enable", "Enable", 655, "prop_thumper", "Enable", EnableIcon ) -- m_bEnabled
AddEntFireProperty( "rb655_thumper_disable", "Disable", 656, "prop_thumper", "Disable", DisableIcon )

AddEntFireProperty( "rb655_dog_fetch_on", "Start Playing Fetch", 655, "npc_dog", "StartCatchThrowBehavior", "icon16/accept.png" ) -- m_bDoCatchThrowBehavior=true
AddEntFireProperty( "rb655_dog_fetch_off", "Stop Playing Fetch", 656, "npc_dog", "StopCatchThrowBehavior", "icon16/cancel.png" )

AddEntFireProperty( "rb655_soldier_look_off", "Enable Blindness", 655, "npc_combine_s", "LookOff", "icon16/user_green.png" )
AddEntFireProperty( "rb655_soldier_look_on", "Disable Blindness", 656, "npc_combine_s", "LookOn", "icon16/user_gray.png" )

AddEntFireProperty( "rb655_citizen_wep_pick_on", "Permit Weapon Upgrade Pickup", 655, "npc_citizen", "EnableWeaponPickup", EnableIcon )
AddEntFireProperty( "rb655_citizen_wep_pick_off", "Restrict Weapon Upgrade Pickup", 656, "npc_citizen", "DisableWeaponPickup", DisableIcon )
AddEntFireProperty( "rb655_citizen_panic", "Start Panicking", 658, { "npc_citizen", "npc_alyx", "npc_barney" }, "SetReadinessPanic", "icon16/flag_red.png" )
AddEntFireProperty( "rb655_citizen_panic_off", "Stop Panicking", 659, { "npc_citizen", "npc_alyx", "npc_barney" }, "SetReadinessHigh", "icon16/flag_green.png" )

AddEntFireProperty( "rb655_camera_angry", "Make Angry", 656, "npc_combine_camera", "SetAngry", "icon16/flag_red.png" )
AddEntFireProperty( "rb655_combine_mine_disarm", "Disarm", 655, "combine_mine", "Disarm", "icon16/wrench.png" )

AddEntFireProperty( "rb655_hunter_enable", "Enable Shooting", 655, "npc_hunter", "EnableShooting", EnableIcon )
AddEntFireProperty( "rb655_hunter_disable", "Disable Shooting", 656, "npc_hunter", "DisableShooting", DisableIcon )

AddEntFireProperty( "rb655_vortigaunt_enable", "Enable Armor Recharge", 655, "npc_vortigaunt", "EnableArmorRecharge", EnableIcon )
AddEntFireProperty( "rb655_vortigaunt_disable", "Disable Armor Recharge", 656, "npc_vortigaunt", "DisableArmorRecharge", DisableIcon )

AddEntFireProperty( "rb655_antlion_enable", "Enable Jump", 655, { "npc_antlion", "npc_antlion_worker" }, "EnableJump", EnableIcon )
AddEntFireProperty( "rb655_antlion_disable", "Disable Jump", 656, { "npc_antlion", "npc_antlion_worker" }, "DisableJump", DisableIcon )
AddEntFireProperty( "rb655_antlion_hear", "Hear Bugbait", 657, { "npc_antlion", "npc_antlion_worker" }, "HearBugbait", EnableIcon )
AddEntFireProperty( "rb655_antlion_ignore", "Ignore Bugbait", 658, { "npc_antlion", "npc_antlion_worker" }, "IgnoreBugbait", DisableIcon )

AddEntFireProperty( "rb655_antlion_grub_squash", "Squash", 655, "npc_antlion_grub", "Squash", "icon16/bug.png" )

AddEntFireProperty( "rb655_antlionguard_bark_on", "Enable Antlion Summon", 655, "npc_antlionguard", "EnableBark", EnableIcon )
AddEntFireProperty( "rb655_antlionguard_bark_off", "Disable Antlion Summon", 656, "npc_antlionguard", "DisableBark", DisableIcon )

AddEntFireProperty( "rb655_headcrab_burrow", "Burrow", 655, "npc_headcrab", "BurrowImmediate", "icon16/arrow_down.png" )

AddEntFireProperty( "rb655_strider_stand", "Force Stand", 655, "npc_strider", "Stand", "icon16/arrow_up.png" )
AddEntFireProperty( "rb655_strider_crouch", "Force Crouch", 656, "npc_strider", "Crouch", "icon16/arrow_down.png" )
AddEntFireProperty( "rb655_strider_break", "Destroy", 657, { "npc_strider", "npc_clawscanner", "npc_cscanner" }, "Break", ExplodeIcon )

-- This just doesn't do anything
AddEntFireProperty( "rb655_patrol_on", "Start Patrolling", 660, { "npc_citizen", "npc_combine_s" }, "StartPatrolling", "icon16/flag_green.png" )
AddEntFireProperty( "rb655_patrol_off", "Stop Patrolling", 661, { "npc_citizen", "npc_combine_s" }, "StopPatrolling", "icon16/flag_red.png" )

AddEntFireProperty( "rb655_strider_aggressive_e", "Make More Aggressive", 658, "npc_strider", "EnableAggressiveBehavior", EnableIcon )
AddEntFireProperty( "rb655_strider_aggressive_d", "Make Less Aggressive", 659, "npc_strider", "DisableAggressiveBehavior", DisableIcon )

AddEntFunctionProperty( "rb655_healthcharger_recharge", "Recharge", 655, "item_healthcharger", function( ent )
	local n = ents.Create( "item_healthcharger" )
	n:SetPos( ent:GetPos() )
	n:SetAngles( ent:GetAngles() )
	n:Spawn()
	n:Activate()
	n:EmitSound( "items/suitchargeok1.wav" )

	undo.ReplaceEntity( ent, n )
	cleanup.ReplaceEntity( ent, n )

	ent:Remove()
end, "icon16/arrow_refresh.png" )

-------------------------------------------------- Vehicles --------------------------------------------------

AddEntFunctionProperty( "rb655_vehicle_exit", "Kick Driver", 655, function( ent )
	if ( ent:IsVehicle() and ent:GetNWBool( "HasDriver" ) ) then return true end
	return false
end, function( ent )
	if ( !IsValid( ent:GetDriver() ) or !ent:GetDriver().ExitVehicle ) then return end
	ent:GetDriver():ExitVehicle()
end, "icon16/car.png" )

AddEntFireProperty( "rb655_vehicle_radar", "Enable Radar", 655, function( ent )
	if ( !ent:IsVehicle() or ent:GetClass() != "prop_vehicle_jeep" ) then return false end
	if ( ent:LookupAttachment( "controlpanel0_ll" ) == 0 ) then return false end -- These two attachments must exist!
	if ( ent:LookupAttachment( "controlpanel0_ur" ) == 0 ) then return false end
	if ( ent:GetNWBool( "m_bRadarEnabled", false ) ) then return false end
	return true
end, "EnableRadar", "icon16/application_add.png" )

AddEntFireProperty( "rb655_vehicle_radar_off", "Disable Radar", 655, function( ent )
	if ( !ent:IsVehicle() or ent:GetClass() != "prop_vehicle_jeep" ) then return false end
	-- if ( ent:LookupAttachment( "controlpanel0_ll" ) == 0 ) then return false end -- These two attachments must exist!
	-- if ( ent:LookupAttachment( "controlpanel0_ur" ) == 0 ) then return false end
	if ( !ent:GetNWBool( "m_bRadarEnabled", false ) ) then return false end
	return true
end, "DisableRadar", "icon16/application_delete.png" )

AddEntFunctionProperty( "rb655_vehicle_enter", "Enter Vehicle", 656, function( ent )
	if ( ent:IsVehicle() and !ent:GetNWBool( "HasDriver" ) ) then return true end
	return false
end, function( ent, ply )
	ply:ExitVehicle()
	ply:EnterVehicle( ent )
end, "icon16/car.png" )

AddEntFunctionProperty( "rb655_vehicle_add_gun", "Mount Gun", 657, function( ent )
	if ( !ent:IsVehicle() ) then return false end
	if ( ent:GetNWBool( "EnableGun", false ) ) then return false end
	if ( ent:GetBodygroup( 1 ) == 1 ) then return false end
	if ( ent:LookupSequence( "aim_all" ) > 0 ) then return true end
	if ( ent:LookupSequence( "weapon_yaw" ) > 0 and ent:LookupSequence( "weapon_pitch" ) > 0 ) then return true end
	return false
end, function( ent )
	ent:SetKeyValue( "EnableGun", "1" )
	ent:Activate()

	ent:SetBodygroup( 1, 1 )

	ent:SetNWBool( "EnableGun", true )
end, "icon16/gun.png" )

-------------------------------------------------- Garry's Mod Specific --------------------------------------------------

AddEntFunctionProperty( "rb655_baloon_break", "Pop", 655, "gmod_balloon", function( ent, ply )
	local dmginfo = DamageInfo()
	dmginfo:SetAttacker( ply )

	ent:OnTakeDamage( dmginfo )
end, ExplodeIcon )

AddEntFunctionProperty( "rb655_dynamite_activate", "Explode", 655, "gmod_dynamite", function( ent, ply )
	ent:Explode( 0, ply )
end, ExplodeIcon )

-- Emitter
AddEntFunctionProperty( "rb655_emitter_on", "Start Emitting", 655, function( ent )
	if ( ent:GetClass() == "gmod_emitter" and !ent:GetOn() ) then return true end
	return false
end, function( ent, ply )
	ent:SetOn( true )
end, EnableIcon )

AddEntFunctionProperty( "rb655_emitter_off", "Stop Emitting", 656, function( ent )
	if ( ent:GetClass() == "gmod_emitter" and ent:GetOn() ) then return true end
	return false
end, function( ent, ply )
	ent:SetOn( false )
end, DisableIcon )

-- Lamps
AddEntFunctionProperty( "rb655_lamp_on", "Enable", 655, function( ent )
	if ( ent:GetClass() == "gmod_lamp" and !ent:GetOn() ) then return true end
	return false
end, function( ent, ply )
	ent:Switch( true )
end, EnableIcon )

AddEntFunctionProperty( "rb655_lamp_off", "Disable", 656, function( ent )
	if ( ent:GetClass() == "gmod_lamp" and ent:GetOn() ) then return true end
	return false
end, function( ent, ply )
	ent:Switch( false )
end, DisableIcon )

-- Light
AddEntFunctionProperty( "rb655_light_on", "Enable", 655, function( ent )
	if ( ent:GetClass() == "gmod_light" and !ent:GetOn() ) then return true end
	return false
end, function( ent, ply )
	ent:SetOn( true )
end, EnableIcon )

AddEntFunctionProperty( "rb655_light_off", "Disable", 656, function( ent )
	if ( ent:GetClass() == "gmod_light" and ent:GetOn() ) then return true end
	return false
end, function( ent, ply )
	ent:SetOn( false )
end, DisableIcon )

-- No thruster, it is glitchy

-------------------------------------------------- HL1 Specific --------------------------------------------------

AddEntFireProperty( "rb655_func_rotating_forward", "Start Forward", 655, "func_rotating", "StartForward", "icon16/arrow_right.png" )
AddEntFireProperty( "rb655_func_rotating_backward", "Start Backward", 656, "func_rotating", "StartBackward", "icon16/arrow_left.png" )
AddEntFireProperty( "rb655_func_rotating_reverse", "Reverse", 657, "func_rotating", "Reverse", "icon16/arrow_undo.png" )
AddEntFireProperty( "rb655_func_rotating_stop", "Stop", 658, "func_rotating", "Stop", "icon16/shape_square.png" )

AddEntFireProperty( "rb655_func_platrot_up", "Go Up", 655, "func_platrot", "GoUp", "icon16/arrow_up.png" )
AddEntFireProperty( "rb655_func_platrot_down", "Go Down", 656, "func_platrot", "GoDown", "icon16/arrow_down.png" )
AddEntFireProperty( "rb655_func_platrot_toggle", "Toggle", 657, "func_platrot", "Toggle", ToggleIcon )

AddEntFireProperty( "rb655_func_train_start", "Start", 655, "func_train", "Start", "icon16/arrow_right.png" )
AddEntFireProperty( "rb655_func_train_stop", "Stop", 656, "func_train", "Stop", "icon16/arrow_left.png" )
AddEntFireProperty( "rb655_func_train_toggle", "Toggle", 657, "func_train", "Toggle", ToggleIcon )

-------------------------------------------------- Pickupable Items --------------------------------------------------

AddEntFunctionProperty( "rb655_item_suit", "Wear", 655, function( ent, ply )
	if ( ent:GetClass() != "item_suit" ) then return false end
	if ( !ply:IsSuitEquipped() ) then return true end
	return false
end, function( ent, ply )
	ent:Remove()
	ply:EquipSuit()
end, "icon16/user_green.png" )

local CheckFuncs = {}
CheckFuncs[ "item_ammo_pistol" ] = function( ply ) return ply:GetAmmoCount( "pistol" ) < 9999 end
CheckFuncs[ "item_ammo_pistol_large" ] = function( ply ) return ply:GetAmmoCount( "pistol" ) < 9999 end
CheckFuncs[ "item_ammo_smg1" ] = function( ply ) return ply:GetAmmoCount( "smg1" ) < 9999 end
CheckFuncs[ "item_ammo_smg1_large" ] = function( ply ) return ply:GetAmmoCount( "smg1" ) < 9999 end
CheckFuncs[ "item_ammo_smg1_grenade" ] = function( ply ) return ply:GetAmmoCount( "smg1_grenade" ) < 9999 end
CheckFuncs[ "item_ammo_ar2" ] = function( ply ) return ply:GetAmmoCount( "ar2" ) < 9999 end
CheckFuncs[ "item_ammo_ar2_large" ] = function( ply ) return ply:GetAmmoCount( "ar2" ) < 9999 end
CheckFuncs[ "item_ammo_ar2_altfire" ] = function( ply ) return ply:GetAmmoCount( "AR2AltFire" ) < 9999 end
CheckFuncs[ "item_ammo_357" ] = function( ply ) return ply:GetAmmoCount( "357" ) < 9999 end
CheckFuncs[ "item_ammo_357_large" ] = function( ply ) return ply:GetAmmoCount( "357" ) < 9999 end
CheckFuncs[ "item_ammo_crossbow" ] = function( ply ) return ply:GetAmmoCount( "xbowbolt" ) < 9999 end
CheckFuncs[ "item_rpg_round" ] = function( ply ) return ply:GetAmmoCount( "rpg_round" ) < 9999 end
CheckFuncs[ "item_box_buckshot" ] = function( ply ) return ply:GetAmmoCount( "buckshot" ) < 9999 end
CheckFuncs[ "item_battery" ] = function( ply ) return ply:Armor() < 100 end
CheckFuncs[ "item_healthvial" ] = function( ply ) return ply:Health() < 100 end
CheckFuncs[ "item_healthkit" ] = function( ply ) return ply:Health() < 100 end
CheckFuncs[ "item_grubnugget" ] = function( ply ) return ply:Health() < 100 end

AddEntFunctionProperty( "rb655_pickupitem", "Pick up", 655, function( ent, ply )
	if ( !table.HasValue( table.GetKeys( CheckFuncs ), ent:GetClass() ) ) then return false end
	if ( CheckFuncs[ ent:GetClass() ]( ply ) ) then return true end
	return false
end, function( ent, ply )
	ply:Give( ent:GetClass() )
	ent:Remove()
end, "icon16/user_green.png" )

-------------------------------------------------- NPCs --------------------------------------------------

-- Passive NPCs - You cannot make these hostile or friendly
local passive = {
	"npc_seagull", "npc_crow", "npc_piegon",  "monster_cockroach",
	"npc_dog", "npc_gman", "npc_antlion_grub",
	-- "monster_scientist", -- Can't attack, but does run away
	"monster_nihilanth", -- Doesn't attack from spawn menu, so not allowing to change his dispositions
	"npc_turret_floor" -- Uses a special input for this sort of stuff
}

local friendly = {
	"npc_monk", "npc_alyx", "npc_barney", "npc_citizen",
	"npc_turret_floor", "npc_dog", "npc_vortigaunt",
	"npc_kleiner", "npc_eli", "npc_magnusson", "npc_breen", "npc_mossman", -- They can use SHOTGUNS!
	"npc_fisherman", -- He sorta can use shotgun
	"monster_barney", "monster_scientist", "player"
}

local hostile = {
	"npc_turret_ceiling", "npc_combine_s", "npc_combinegunship", "npc_combinedropship",
	"npc_cscanner", "npc_clawscanner", "npc_turret_floor", "npc_helicopter", "npc_hunter", "npc_manhack",
	"npc_stalker", "npc_rollermine", "npc_strider", "npc_metropolice", "npc_turret_ground",
	"npc_cscanner", "npc_clawscanner", "npc_combine_camera", -- These are friendly to enemies

	"monster_human_assassin", "monster_human_grunt", "monster_turret", "monster_miniturret", "monster_sentry"
}

local monsters = {
	"npc_antlion", "npc_antlion_worker", "npc_antlionguard", "npc_barnacle", "npc_fastzombie", "npc_fastzombie_torso",
	"npc_headcrab", "npc_headcrab_fast", "npc_headcrab_black", "npc_headcrab_poison", "npc_poisonzombie", "npc_zombie", "npc_zombie_torso", "npc_zombine",
	"monster_alien_grunt", "monster_alien_slave", "monster_babycrab", "monster_headcrab", "monster_bigmomma", "monster_bullchicken", "monster_barnacle",
	"monster_alien_controller", "monster_gargantua", "monster_nihilanth", "monster_snark", "monster_zombie", "monster_tentacle", "monster_houndeye"
}

---------------------------- Functional stuff ----------------------------

local NPCsThisWorksOn = {}
local function RecalcUsableNPCs()
	-- Not resetting NPCsThisWorksOn as you can't remove classes from the tables below
	-- Not including passive monsters here, you can't make them hostile or friendly
	for _, class in pairs( friendly ) do NPCsThisWorksOn[ class ] = true end
	for _, class in pairs( hostile ) do NPCsThisWorksOn[ class ] = true end
	for _, class in pairs( monsters ) do NPCsThisWorksOn[ class ] = true end
end
RecalcUsableNPCs()

-- For mods
function ExtProp_AddPassive( class ) table.insert( passive, class ) end -- Probably shouldn't exist
function ExtProp_AddFriendly( class ) table.insert( friendly, class ) RecalcUsableNPCs() end
function ExtProp_AddHostile( class ) table.insert( hostile, class ) RecalcUsableNPCs() end
function ExtProp_AddMonster( class ) table.insert( monsters, class ) RecalcUsableNPCs() end

local friendliedNPCs = {}
local hostaliziedNPCs = {}
local function SetRelationships( ent, tab, status )
	for id, fnpc in pairs( tab ) do
		if ( !IsValid( fnpc ) ) then table.remove( tab, id ) continue end
		fnpc:AddEntityRelationship( ent, status, 999 )
		ent:AddEntityRelationship( fnpc, status, 999 )
	end
end

local function Rbt_ProcessOtherNPC( ent )
	if ( table.HasValue( friendly, ent:GetClass() ) and !table.HasValue( hostaliziedNPCs, ent ) ) then -- It's a friendly that isn't made hostile
		SetRelationships( ent, friendliedNPCs, D_LI )
		SetRelationships( ent, hostaliziedNPCs, D_HT )
	elseif ( table.HasValue( hostile, ent:GetClass() ) and !table.HasValue( friendliedNPCs, ent ) ) then -- It's a hostile that isn't made friendly
		SetRelationships( ent, friendliedNPCs, D_HT )
		SetRelationships( ent, hostaliziedNPCs, D_LI )
	elseif ( table.HasValue( monsters, ent:GetClass() ) and !table.HasValue( friendliedNPCs, ent ) and !table.HasValue( hostaliziedNPCs, ent ) ) then -- It's a monster that isn't made friendly or hostile to the player
		SetRelationships( ent, friendliedNPCs, D_HT )
		SetRelationships( ent, hostaliziedNPCs, D_HT )
	end
end

if ( SERVER ) then
	hook.Add( "OnEntityCreated", "rb655_properties_friently/hostile", function( ent )
		if ( ent:IsNPC() ) then Rbt_ProcessOtherNPC( ent ) end
	end )

	hook.Add( "EntityRemoved", "rb655_properties_friently/hostile_remove", function( ent )
		for id, fnpc in pairs( friendliedNPCs ) do
			if ( !IsValid( fnpc ) or fnpc == ent ) then table.remove( friendliedNPCs, id ) break end
		end

		for id, fnpc in pairs( hostaliziedNPCs ) do
			if ( !IsValid( fnpc ) or fnpc == ent ) then table.remove( hostaliziedNPCs, id ) break end
		end
	end )
end

AddEntFunctionProperty( "rb655_make_friendly", "Make Friendly", 652, function( ent )
	if ( ent:IsNPC() and !table.HasValue( passive, ent:GetClass() ) and NPCsThisWorksOn[ ent:GetClass() ] ) then return true end
	return false
end, function( ent )
	table.insert( friendliedNPCs, ent )
	table.RemoveByValue( hostaliziedNPCs, ent )

	-- Remove the NPC from any squads so the console doesn't spam. TODO: Add a suffix like _friendly instead?
	ent:Fire( "SetSquad", "" )

	-- Special case for stalkers
	if ( ent:GetClass() == "npc_stalker" ) then
		ent:SetSaveValue( "m_iPlayerAggression", 0 )
	end

	-- Is this even necessary anymore?
	for id, class in pairs( friendly ) do ent:AddRelationship( class .. " D_LI 999" ) end
	for id, class in pairs( monsters ) do ent:AddRelationship( class .. " D_HT 999" ) end
	for id, class in pairs( hostile ) do ent:AddRelationship( class .. " D_HT 999" ) end

	SetRelationships( ent, friendliedNPCs, D_LI )
	SetRelationships( ent, hostaliziedNPCs, D_HT )

	for id, oent in pairs( ents.GetAll() ) do
		if ( oent:IsNPC() and oent != ent ) then Rbt_ProcessOtherNPC( oent ) end
	end

	ent:Activate()
end, "icon16/user_green.png" )

AddEntFunctionProperty( "rb655_make_hostile", "Make Hostile", 653, function( ent )
	if ( ent:IsNPC() and !table.HasValue( passive, ent:GetClass() ) and NPCsThisWorksOn[ ent:GetClass() ] ) then return true end
	return false
end, function( ent )
	table.insert( hostaliziedNPCs, ent )
	table.RemoveByValue( friendliedNPCs, ent )

	-- Remove the NPC from any squads so the console doesn't spam. TODO: Add a suffix like _hostile instead?
	ent:Fire( "SetSquad", "" )

	-- Special case for stalkers
	if ( ent:GetClass() == "npc_stalker" ) then
		ent:SetSaveValue( "m_iPlayerAggression", 1 )
	end

	-- Is this even necessary anymore?
	for id, class in pairs( hostile ) do ent:AddRelationship( class .. " D_LI 999" ) end
	for id, class in pairs( monsters ) do ent:AddRelationship( class .. " D_HT 999" ) end
	for id, class in pairs( friendly ) do ent:AddRelationship( class .. " D_HT 999" ) end

	SetRelationships( ent, friendliedNPCs, D_HT )
	SetRelationships( ent, hostaliziedNPCs, D_LI )

	for id, oent in pairs( ents.GetAll() ) do
		if ( oent:IsNPC() and oent != ent ) then Rbt_ProcessOtherNPC( oent ) end
	end
end, "icon16/user_red.png" )

--lua/autorun/rb655_extended_spawnmenu.lua:

AddCSLuaFile()

if ( SERVER ) then

	util.AddNetworkString( "rb655_playsound" )

	concommand.Add( "rb655_playsound_all", function( ply, cmd, args )
		if ( !ply:IsSuperAdmin() or !args[ 1 ] or string.Trim( args[ 1 ] ) == "" ) then return end

		net.Start( "rb655_playsound" )
		net.WriteString( args[ 1 ] or "" )
		net.Broadcast()
	end )

	return

end

local cl_addTabs = CreateClientConVar( "rb655_create_sm_tabs", "0", true, true )

--[[local function removeOldTabls()
	for k, v in pairs( g_SpawnMenu.CreateMenu.Items ) do
		if (v.Tab:GetText() == language.GetPhrase( "spawnmenu.category.npcs" ) or
			v.Tab:GetText() == language.GetPhrase( "spawnmenu.category.entities" ) or
			v.Tab:GetText() == language.GetPhrase( "spawnmenu.category.weapons" ) or
			v.Tab:GetText() == language.GetPhrase( "spawnmenu.category.vehicles" ) or
			v.Tab:GetText() == language.GetPhrase( "spawnmenu.category.postprocess" ) ) then
			g_SpawnMenu.CreateMenu:CloseTab( v.Tab, true )
		end
	end
end

hook.Add( "PopulateContent", "rb655_extended_spawnmenu", function( pnlContent, tree, node )
	removeOldTabls() removeOldTabls() removeOldTabls() -- For some reason it doesn't work with only one call
end )]]

local function getGameList()
	local games = engine.GetGames()
	table.insert( games, {
		title = "All",
		folder = "GAME",
		icon = "all",
		mounted = true
	} )
	table.insert( games, {
		title = "Garry's Mod",
		folder = "garrysmod",
		mounted = true
	} )
	return games
end

--[[ ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ ]]

local theSound = nil

function rb655_playsound( snd )

	if ( theSound ) then theSound:Stop() end

	theSound = CreateSound( LocalPlayer(), snd )
	theSound:Play()

end

net.Receive( "rb655_playsound", function( len )
	rb655_playsound( net.ReadString() )
end )

spawnmenu.AddContentType( "sound", function( container, obj )
	if ( !obj.nicename ) then return end
	if ( !obj.spawnname ) then return end

	local icon = vgui.Create( "ContentIcon", container )
	icon:SetContentType( "sound" )
	icon:SetSpawnName( obj.spawnname )
	icon:SetName( obj.nicename )
	icon:SetMaterial( "icon16/sound.png" )

	icon.DoClick = function()
		rb655_playsound( obj.spawnname )
	end

	icon.OpenMenu = function( icn )
		local menu = DermaMenu()
			menu:AddOption( "#spawnmenu.menu.copy", function() SetClipboardText( obj.spawnname ) end ):SetIcon( "icon16/page_copy.png" )
			menu:AddOption( "Play on all clients", function() RunConsoleCommand( "rb655_playsound_all", obj.spawnname ) end ):SetIcon( "icon16/sound.png" )
			menu:AddOption( "Stop all sounds", function() RunConsoleCommand( "stopsound" ) end ):SetIcon( "icon16/sound_mute.png" )
			menu:AddSpacer()
			menu:AddOption( "#spawnmenu.menu.delete", function() icn:Remove() hook.Run( "SpawnlistContentChanged", icn ) end ):SetIcon( "icon16/bin_closed.png" )
		menu:Open()
	end

	if ( IsValid( container ) ) then
		container:Add( icon )
	end

	return icon

end )

local function OnSndNodeSelected( self, node, name, path, pathid, icon, ViewPanel, pnlContent )

	ViewPanel:Clear( true )

	local Path = node:GetFolder()

	local files = file.Find( Path .. "/*.wav", node:GetPathID() )
	files = table.Add( files, file.Find( Path .. "/*.mp3", node:GetPathID() ) )
	files = table.Add( files, file.Find( Path .. "/*.ogg", node:GetPathID() ) )

	local offset = 0
	local limit = 512
	if ( node.offset ) then offset = node.offset or 0 end

	for k, v in pairs( files ) do
		if ( k > limit + offset ) then
			if ( !node.Done ) then
				offset = offset + limit
				local mats = ( self.Parent or node ):AddNode( ( self.Text or node:GetText() ) .. " (" .. offset .. " - " .. offset + limit .. ")" )
				mats:SetFolder( node:GetFolder() )
				mats.Text = self.Text or node:GetText()
				mats.Parent = self.Parent or node
				mats:SetPathID( node:GetPathID() )
				mats:SetIcon( node:GetIcon() )
				mats.offset = offset
				mats.OnNodeSelected = function( mats_self, mats_node )
					OnSndNodeSelected( mats_self, mats_node, mats_self.Text, mats_node:GetFolder(), mats_node:GetPathID(), mats_node:GetIcon(), ViewPanel, pnlContent )
				end
			end
			node.Done = true
		break end
		if ( k <= offset ) then continue end

		local p = Path .. "/"
		if ( string.StartWith( path, "addons/" ) or string.StartWith( path, "download/" ) ) then
			p = string.sub( p, string.find( p, "/sound/" ) + 1 )
		end

		p = string.sub( p .. v, 7 )

		spawnmenu.CreateContentIcon( "sound", ViewPanel, { spawnname = p, nicename = string.Trim( v ) } )

	end

	pnlContent:SwitchPanel( ViewPanel )

end

local function AddBrowseContentSnd( node, name, icon, path, pathid )

	local ViewPanel = node.ViewPanel
	local pnlContent = node.pnlContent

	if ( !string.EndsWith( path, "/" ) && string.len( path ) > 1 ) then path = path .. "/" end

	local fi, fo = file.Find( path .. "sound", pathid )
	if ( !fo && !fi ) then return end

	local sounds = node:AddFolder( name, path .. "sound", pathid, false, false, "*.*" )
	sounds:SetIcon( icon )

	sounds.OnNodeSelected = function( self, node_sel )
		OnSndNodeSelected( self, node_sel, name, path, pathid, icon, ViewPanel, pnlContent )
	end

end

language.Add( "spawnmenu.category.browsesounds", "Browse Sounds" )

local function RefreshAddonSounds( browseAddonSounds )
		for _, addon in SortedPairsByMemberValue( engine.GetAddons(), "title" ) do

		if ( !addon.downloaded ) then continue end
		if ( !addon.mounted ) then continue end
		if ( !table.HasValue( select( 2, file.Find( "*", addon.title ) ), "sound" ) ) then continue end

		AddBrowseContentSnd( browseAddonSounds, addon.title, "icon16/bricks.png", "", addon.title )
	end
end
local function RefreshGameSounds( browseGameSounds )
	local games = getGameList()

	for _, game in SortedPairsByMemberValue( games, "title" ) do
		if ( !game.mounted ) then continue end
		AddBrowseContentSnd( browseGameSounds, game.title, "games/16/" .. ( game.icon or game.folder ) .. ".png", "", game.folder )
	end
end

local browseGameSounds
local browseAddonSounds
hook.Add( "PopulateContent", "SpawnmenuLoadSomeSounds", function( pnlContent, tree, browseNode ) timer.Simple( 0.5, function()

	if ( !IsValid( tree ) or !IsValid( pnlContent ) ) then
		print( "!!! Extended Spawnmenu: FAILED TO INITALIZE PopulateContent HOOK FOR SOUNDS !!!" )
		print( "!!! Extended Spawnmenu: FAILED TO INITALIZE PopulateContent HOOK FOR SOUNDS !!!" )
		print( "!!! Extended Spawnmenu: FAILED TO INITALIZE PopulateContent HOOK FOR SOUNDS !!!" )
		return
	end

	local ViewPanel = vgui.Create( "ContentContainer", pnlContent )
	ViewPanel:SetVisible( false )

	local browseSounds = tree:AddNode( "#spawnmenu.category.browsesounds", "icon16/sound.png" )
	browseSounds.ViewPanel = ViewPanel
	browseSounds.pnlContent = pnlContent

	--[[ --------------------------------------------------------------------------------------- ]]

	browseAddonSounds = browseSounds:AddNode( "#spawnmenu.category.addons", "icon16/folder_database.png" )
	browseAddonSounds.ViewPanel = ViewPanel
	browseAddonSounds.pnlContent = pnlContent

	RefreshAddonSounds( browseAddonSounds )

	--[[ --------------------------------------------------------------------------------------- ]]

	local addon_sounds = {}
	local _, snd_folders = file.Find( "addons/*", "MOD" )
	for _, addon in SortedPairs( snd_folders ) do

		if ( !file.IsDir( "addons/" .. addon .. "/sound/", "MOD" ) ) then continue end

		table.insert( addon_sounds, addon )

	end

	local browseLegacySounds = browseSounds:AddNode( "#spawnmenu.category.addonslegacy", "icon16/folder_database.png" )
	browseLegacySounds.ViewPanel = ViewPanel
	browseLegacySounds.pnlContent = pnlContent

	for _, addon in SortedPairsByValue( addon_sounds ) do

		AddBrowseContentSnd( browseLegacySounds, addon, "icon16/bricks.png", "addons/" .. addon .. "/", "MOD" )

	end

	--[[ --------------------------------------------------------------------------------------- ]]

	AddBrowseContentSnd( browseSounds, "#spawnmenu.category.downloads", "icon16/folder_database.png", "download/", "MOD" )

	--[[ --------------------------------------------------------------------------------------- ]]

	browseGameSounds = browseSounds:AddNode( "#spawnmenu.category.games", "icon16/folder_database.png" )
	browseGameSounds.ViewPanel = ViewPanel
	browseGameSounds.pnlContent = pnlContent

	RefreshGameSounds( browseGameSounds )

end ) end )

hook.Add( "GameContentChanged", "ES_RefreshSpawnmenuSounds", function()

	if ( IsValid( browseAddonSounds ) ) then

		-- TODO: Maybe be more advaced and do not delete => recreate all the nodes, only delete nodes for addons that were removed, add only the new ones?
		browseAddonSounds:Clear()
		browseAddonSounds.ViewPanel:Clear( true )

		RefreshAddonSounds( browseAddonSounds )

	end

	if ( IsValid( browseGameSounds ) ) then

		-- TODO: Maybe be more advaced and do not delete => recreate all the nodes, only delete nodes for addons that were removed, add only the new ones?
		browseGameSounds:Clear()
		browseGameSounds.ViewPanel:Clear( true )

		RefreshGameSounds( browseGameSounds )

	end

end )

--[[ ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ ]]

local function IsMaterialUsableOnEntities( matPath )
	-- A png file? No thanks
	if ( string.GetExtensionFromFilename( matPath ) ) then return false end

	local mat = Material( matPath )
	if ( !string.find( mat:GetShader(), "LightmappedGeneric" )
	&& !string.find( mat:GetShader(), "WorldVertexTransition" )
	&& !string.find( mat:GetShader(), "Spritecard" )
	&& !string.find( mat:GetShader(), "Water" )
	&& !string.find( mat:GetShader(), "Cable" )
	--&& !string.find( mat:GetShader(), "UnlitGeneric" )
	&& !string.find( mat:GetShader(), "Refract" ) ) then
		return true
	end

	return false
end

local DisplayedWarning = false
local function DisplayOneTimeWarning()
	if ( DisplayedWarning ) then return end
	DisplayedWarning = true

	Derma_Message( "Please note that not all materials are usable on entities, such as map textures, etc.\nYou can still try though!", "Warning", "OK" )
end

spawnmenu.AddContentType( "material", function( container, obj )
	if ( !obj.nicename ) then return end
	if ( !obj.spawnname ) then return end

	local icon = vgui.Create( "ContentIcon", container )
	icon:SetContentType( "material" )
	icon:SetSpawnName( obj.spawnname )
	icon:SetName( obj.nicename )
	if ( string.GetExtensionFromFilename( obj.spawnname ) == "png" ) then
		icon:SetMaterial( obj.spawnname )
	else
		icon.Image:SetImage( obj.spawnname )
	end

	icon.DoClick = function()
		if ( !IsMaterialUsableOnEntities( obj.spawnname ) ) then DisplayOneTimeWarning() end

		RunConsoleCommand( "material_override", obj.spawnname )
		spawnmenu.ActivateTool( "material" )
		surface.PlaySound( "garrysmod/ui_click.wav" )
	end

	icon.OpenMenu = function( icn )
		local menu = DermaMenu()
			menu:AddOption( "#spawnmenu.menu.copy", function() SetClipboardText( obj.spawnname ) end ):SetIcon( "icon16/page_copy.png" )

			local str = "Use with Material Tool"
			if ( !IsMaterialUsableOnEntities( obj.spawnname ) ) then
				str = "Try to use with Material Tool (Probably won't work)"
			end
			menu:AddOption( str, function()
				RunConsoleCommand( "material_override", obj.spawnname )
				spawnmenu.ActivateTool( "material" )
			end ):SetIcon( "icon16/pencil.png" )

			menu:AddSpacer()
			menu:AddOption( "#spawnmenu.menu.delete", function() icn:Remove() hook.Run( "SpawnlistContentChanged", icn ) end ):SetIcon( "icon16/bin_closed.png" )
		menu:Open()
	end

	if ( IsValid( container ) ) then
		container:Add( icon )
	end

	return icon

end )

local function OnMatNodeSelected( self, node, name, path, pathid, icon, ViewPanel, pnlContent )

	ViewPanel:Clear( true )

	local Path = node:GetFolder()

	local mat_files = file.Find( Path .. "/*.vmt", node:GetPathID() )
	mat_files = table.Add( mat_files, file.Find( Path .. "/*.png", node:GetPathID() ) )

	local offset = 0
	local limit = 512
	if ( node.offset ) then offset = node.offset or 0 end

	for k, v in pairs( mat_files ) do
		if ( k > limit + offset ) then
			if ( !node.Done ) then
				offset = offset + limit
				local mats = ( self.Parent or node ):AddNode( ( self.Text or node:GetText() ) .. " (" .. offset .. " - " .. offset + limit .. ")" )
				mats:SetFolder( node:GetFolder() )
				mats.Text = self.Text or node:GetText()
				mats.Parent = self.Parent or node
				mats:SetPathID( node:GetPathID() )
				mats:SetIcon( node:GetIcon() )
				mats.offset = offset
				mats.OnNodeSelected = function( self_mats, node_sel )
					OnMatNodeSelected( self_mats, node_sel, self_mats.Text, node_sel:GetFolder(), node_sel:GetPathID(), node_sel:GetIcon(), ViewPanel, pnlContent )
				end
			end
			node.Done = true
		break end
		if ( k <= offset ) then continue end

		local p = Path .. "/"
		if ( string.StartWith( path, "addons/" ) or string.StartWith( path, "download/" ) ) then
			p = string.sub( p, string.find( p, "/materials/" ) + 1 )
		end

		p = string.sub( p .. v, 11 )

		if ( string.GetExtensionFromFilename( p ) == "vmt" ) then
			p = string.StripExtension( p )
			v = string.StripExtension( v )
		end

		if ( Material( p ):GetShader() == "Spritecard" ) then continue end

		spawnmenu.CreateContentIcon( "material", ViewPanel, { spawnname = p, nicename = v } )
	end

	pnlContent:SwitchPanel( ViewPanel )

end

local function AddBrowseContentMaterial( node, name, icon, path, pathid )

	local ViewPanel = node.ViewPanel
	local pnlContent = node.pnlContent

	if ( !string.EndsWith( path, "/" ) && string.len( path ) > 1 ) then path = path .. "/" end

	local fi, fo = file.Find( path .. "materials", pathid )
	if ( !fi && !fo ) then return end

	local materials = node:AddFolder( name, path .. "materials", pathid, false, false, "*.*" )
	materials:SetIcon( icon )

	materials.OnNodeSelected = function( self, node_sel )
		OnMatNodeSelected( self, node_sel, name, path, pathid, icon, ViewPanel, pnlContent )
	end

end

language.Add( "spawnmenu.category.browsematerials", "Browse Materials" )

local function RefreshAddonMaterials( node )
	for _, addon in SortedPairsByMemberValue( engine.GetAddons(), "title" ) do

		if ( !addon.downloaded ) then continue end
		if ( !addon.mounted ) then continue end
		if ( !table.HasValue( select( 2, file.Find( "*", addon.title ) ), "materials" ) ) then continue end

		AddBrowseContentMaterial( node, addon.title, "icon16/bricks.png", "", addon.title )

	end
end
local function RefreshGameMaterials( node )
	local games = getGameList()

	for _, game in SortedPairsByMemberValue( games, "title" ) do
		if ( !game.mounted ) then continue end
		AddBrowseContentMaterial( node, game.title, "games/16/" .. ( game.icon or game.folder ) .. ".png", "", game.folder )
	end
end

local browseAddonMaterials
local browseGameMaterials
hook.Add( "PopulateContent", "SpawnmenuLoadSomeMaterials", function( pnlContent, tree, browseNode ) timer.Simple( 0.5, function()

	if ( !IsValid( tree ) or !IsValid( pnlContent ) ) then
		print( "!!! Extended Spawnmenu: FAILED TO INITALIZE PopulateContent HOOK FOR MATERIALS!!!" )
		print( "!!! Extended Spawnmenu: FAILED TO INITALIZE PopulateContent HOOK FOR MATERIALS!!!" )
		print( "!!! Extended Spawnmenu: FAILED TO INITALIZE PopulateContent HOOK FOR MATERIALS!!!" )
		return
	end

	local ViewPanel = vgui.Create( "ContentContainer", pnlContent )
	ViewPanel:SetVisible( false )

	local browseMaterials = tree:AddNode( "#spawnmenu.category.browsematerials", "icon16/picture_empty.png" )
	browseMaterials.ViewPanel = ViewPanel
	browseMaterials.pnlContent = pnlContent

	--[[ --------------------------------------------------------------------------------------- ]]

	browseAddonMaterials = browseMaterials:AddNode( "#spawnmenu.category.addons", "icon16/folder_database.png" )
	browseAddonMaterials.ViewPanel = ViewPanel
	browseAddonMaterials.pnlContent = pnlContent

	RefreshAddonMaterials( browseAddonMaterials )

	--[[ --------------------------------------------------------------------------------------- ]]

	local addon_mats = {}
	local _, mat_folders = file.Find( "addons/*", "MOD" )
	for _, addon in SortedPairs( mat_folders ) do

		if ( !file.IsDir( "addons/" .. addon .. "/materials/", "MOD" ) ) then continue end

		table.insert( addon_mats, addon )

	end

	local browseLegacyMaterials = browseMaterials:AddNode( "#spawnmenu.category.addonslegacy", "icon16/folder_database.png" )
	browseLegacyMaterials.ViewPanel = ViewPanel
	browseLegacyMaterials.pnlContent = pnlContent

	for _, addon in SortedPairsByValue( addon_mats ) do

		AddBrowseContentMaterial( browseLegacyMaterials, addon, "icon16/bricks.png", "addons/" .. addon .. "/", "MOD" )

	end

	--[[ --------------------------------------------------------------------------------------- ]]

	AddBrowseContentMaterial( browseMaterials, "#spawnmenu.category.downloads", "icon16/folder_database.png", "download/", "MOD" )

	--[[ --------------------------------------------------------------------------------------- ]]

	browseGameMaterials = browseMaterials:AddNode( "#spawnmenu.category.games", "icon16/folder_database.png" )
	browseGameMaterials.ViewPanel = ViewPanel
	browseGameMaterials.pnlContent = pnlContent

	RefreshGameMaterials( browseGameMaterials )

end ) end )

hook.Add( "GameContentChanged", "ES_RefreshSpawnmenuMaterials", function()

	if ( IsValid( browseAddonMaterials ) ) then

		-- TODO: Maybe be more advaced and do not delete => recreate all the nodes, only delete nodes for addons that were removed, add only the new ones?
		browseAddonMaterials:Clear()
		browseAddonMaterials.ViewPanel:Clear( true )

		RefreshAddonMaterials( browseAddonMaterials )

	end

	if ( IsValid( browseGameMaterials ) ) then

		-- TODO: Maybe be more advaced and do not delete => recreate all the nodes, only delete nodes for addons that were removed, add only the new ones?
		browseGameMaterials:Clear()
		browseGameMaterials.ViewPanel:Clear( true )

		RefreshGameMaterials( browseGameMaterials )

	end

end )

--[[ ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ ]]
--[[ ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ ]]
--[[ ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ ]]
--[[ ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ ]]
--[[ ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ ]]

hook.Add( "PopulateContent", "rb655_extended_spawnmenu_entities", function( pnlContent, tree, node )
	if ( !cl_addTabs:GetBool() ) then return end

	local node_w = tree:AddNode( "#spawnmenu.category.entities", "icon16/bricks.png" )

	node_w.PropPanel = vgui.Create( "ContentContainer", pnlContent )
	node_w.PropPanel:SetVisible( false )

	function node_w:DoClick()
		pnlContent:SwitchPanel( self.PropPanel )
	end

	local Categorised = {}

	local SpawnableEntities = list.Get( "SpawnableEntities" )
	if ( SpawnableEntities ) then
		for k, v in pairs( SpawnableEntities ) do
			v.Category = v.Category or "Other"
			Categorised[ v.Category ] = Categorised[ v.Category ] or {}
			table.insert( Categorised[ v.Category ], v )
		end
	end

	for CategoryName, v in SortedPairs( Categorised ) do

		local node_new = node_w:AddNode( CategoryName, "icon16/bricks.png" )

		local CatPropPanel = vgui.Create( "ContentContainer", pnlContent )
		CatPropPanel:SetVisible( false )

		local Header = vgui.Create("ContentHeader", node_w.PropPanel )
		Header:SetText( CategoryName )
		node_w.PropPanel:Add( Header )

		for k, ent in SortedPairsByMemberValue( v, "PrintName" ) do
			local t = {
				nicename	= ent.PrintName or ent.ClassName,
				spawnname	= ent.ClassName,
				material	= "entities/" .. ent.ClassName .. ".png",
				admin		= ent.AdminOnly
			}
			spawnmenu.CreateContentIcon( ent.ScriptedEntityType or "entity", CatPropPanel, t )
			spawnmenu.CreateContentIcon( ent.ScriptedEntityType or "entity", node_w.PropPanel, t )
		end

		function node_new:DoClick()
			pnlContent:SwitchPanel( CatPropPanel )
		end

	end
end )

hook.Add( "PopulateContent", "rb655_extended_spawnmenu_post_processing", function( pnlContent, tree, node )
	if ( !cl_addTabs:GetBool() ) then return end

	local node_w = tree:AddNode( "#spawnmenu.category.postprocess", "icon16/picture.png" )

	node_w.PropPanel = vgui.Create( "ContentContainer", pnlContent )
	node_w.PropPanel:SetVisible( false )

	function node_w:DoClick()
		pnlContent:SwitchPanel( self.PropPanel )
	end

	-- Get the table

	local Categorised = {}
	local PostProcess = list.Get( "PostProcess" )

	if ( PostProcess ) then
		for k, v in pairs( PostProcess ) do
			v.category = v.category or "Other"
			v.name = k
			Categorised[ v.category ] = Categorised[ v.category ] or {}
			table.insert( Categorised[ v.category ], v )
		end
	end

	-- Put table into panels
	for CategoryName, v in SortedPairs( Categorised ) do

		local node_new = node_w:AddNode( CategoryName, "icon16/picture.png" )

		local CatPropPanel = vgui.Create( "ContentContainer", pnlContent )
		CatPropPanel:SetVisible( false )

		local Header = vgui.Create( "ContentHeader", node_w.PropPanel )
		Header:SetText( CategoryName )
		node_w.PropPanel:Add( Header )

		for k, pp in SortedPairsByMemberValue( v, "PrintName" ) do
			if ( pp.func ) then pp.func( CatPropPanel ) pp.func( node_w.PropPanel ) continue end

			local t = {
				name = pp.name,
				icon = pp.icon
			}

			spawnmenu.CreateContentIcon( "postprocess", CatPropPanel, t )
			spawnmenu.CreateContentIcon( "postprocess", node_w.PropPanel, t )
		end

		function node_new:DoClick()
			pnlContent:SwitchPanel( CatPropPanel )
		end
	end

end )

hook.Add( "PopulateContent", "rb655_extended_spawnmenu_npcs", function( pnlContent, tree, node )
	if ( !cl_addTabs:GetBool() ) then return end

	local node_w = tree:AddNode( "#spawnmenu.category.npcs", "icon16/monkey.png" )

	node_w.PropPanel = vgui.Create( "ContentContainer", pnlContent )
	node_w.PropPanel:SetVisible( false )

	function node_w:DoClick()
		pnlContent:SwitchPanel( self.PropPanel )
	end

	local NPCList = list.Get( "NPC" )
	local Categories = {}

	for k, v in pairs( NPCList ) do
		local Category = v.Category or "Other"
		local Tab = Categories[ Category ] or {}

		Tab[ k ] = v

		Categories[ Category ] = Tab
	end

	for CategoryName, v in SortedPairs( Categories ) do

		local node_new = node_w:AddNode( CategoryName, "icon16/monkey.png" )

		local CatPropPanel = vgui.Create( "ContentContainer", pnlContent )
		CatPropPanel:SetVisible( false )

		local Header = vgui.Create("ContentHeader", node_w.PropPanel )
		Header:SetText( CategoryName )
		node_w.PropPanel:Add( Header )

		for name, ent in SortedPairsByMemberValue( v, "Name" ) do
			local t = {
				nicename	= ent.Name or name,
				spawnname	= name,
				material	= "entities/" .. name .. ".png",
				weapon		= ent.Weapons,
				admin		= ent.AdminOnly
			}
			spawnmenu.CreateContentIcon( "npc", CatPropPanel, t )
			spawnmenu.CreateContentIcon( "npc", node_w.PropPanel, t )
		end

		function node_new:DoClick()
			pnlContent:SwitchPanel( CatPropPanel )
		end

	end
end )

hook.Add( "PopulateContent", "rb655_extended_spawnmenu_vehicles", function( pnlContent, tree, node )
	if ( !cl_addTabs:GetBool() ) then return end

	local node_w = tree:AddNode( "#spawnmenu.category.vehicles", "icon16/car.png" )

	node_w.PropPanel = vgui.Create( "ContentContainer", pnlContent )
	node_w.PropPanel:SetVisible( false )

	function node_w:DoClick()
		pnlContent:SwitchPanel( self.PropPanel )
	end

	local Categorised = {}
	local Vehicles = list.Get( "Vehicles" )
	if ( Vehicles ) then
		for k, v in pairs( Vehicles ) do
			v.Category = v.Category or "Other"
			Categorised[ v.Category ] = Categorised[ v.Category ] or {}
			v.ClassName = k
			v.PrintName = v.Name
			v.ScriptedEntityType = "vehicle"
			table.insert( Categorised[ v.Category ], v )
		end
	end

	for CategoryName, v in SortedPairs( Categorised ) do

		local node_new = node_w:AddNode( CategoryName, "icon16/car.png" )

		local CatPropPanel = vgui.Create( "ContentContainer", pnlContent )
		CatPropPanel:SetVisible( false )

		local Header = vgui.Create("ContentHeader", node_w.PropPanel )
		Header:SetText( CategoryName )
		node_w.PropPanel:Add( Header )

		for k, ent in SortedPairsByMemberValue( v, "PrintName" ) do
			local t = {
				nicename	= ent.PrintName or ent.ClassName,
				spawnname	= ent.ClassName,
				material	= "entities/" .. ent.ClassName .. ".png",
				admin		= ent.AdminOnly
			}
			spawnmenu.CreateContentIcon( ent.ScriptedEntityType or "entity", node_w.PropPanel, t )
			spawnmenu.CreateContentIcon( ent.ScriptedEntityType or "entity", CatPropPanel, t )
		end

		function node_new:DoClick()
			pnlContent:SwitchPanel( CatPropPanel )
		end

	end

end )

hook.Add( "PopulateContent", "rb655_extended_spawnmenu_weapons", function( pnlContent, tree, node )
	if ( !cl_addTabs:GetBool() ) then return end

	local node_w = tree:AddNode( "#spawnmenu.category.weapons", "icon16/gun.png" )

	node_w.PropPanel = vgui.Create( "ContentContainer", pnlContent )
	node_w.PropPanel:SetVisible( false )

	function node_w:DoClick()
		pnlContent:SwitchPanel( self.PropPanel )
	end

	local Weapons = list.Get( "Weapon" )
	local Categorised = {}

	for k, weapon in pairs( Weapons ) do
		if ( !weapon.Spawnable && !weapon.AdminSpawnable ) then continue end

		Categorised[ weapon.Category ] = Categorised[ weapon.Category ] or {}
		table.insert( Categorised[ weapon.Category ], weapon )
	end

	for CategoryName, v in SortedPairs( Categorised ) do
		local node_new = node_w:AddNode( CategoryName, "icon16/gun.png" )

		local CatPropPanel = vgui.Create( "ContentContainer", pnlContent )
		CatPropPanel:SetVisible( false )

		local Header = vgui.Create("ContentHeader", node_w.PropPanel )
		Header:SetText( CategoryName )
		node_w.PropPanel:Add( Header )

		for k, ent in SortedPairsByMemberValue( v, "PrintName" ) do
			local t = {
				nicename	= ent.PrintName or ent.ClassName,
				spawnname	= ent.ClassName,
				material	= "entities/" .. ent.ClassName .. ".png",
				admin		= ent.AdminOnly
			}
			spawnmenu.CreateContentIcon( ent.ScriptedEntityType or "weapon", CatPropPanel, t )
			spawnmenu.CreateContentIcon( ent.ScriptedEntityType or "weapon", node_w.PropPanel, t )
		end

		function node_new:DoClick()
			pnlContent:SwitchPanel( CatPropPanel )
		end

	end

end )

--lua/autorun/royal_guard.lua:
player_manager.AddValidModel( "Royal Guard", "models/player/mandalorian/royal_guard_male.mdl" );
--addons/sam/lua/autorun/sam.lua:
if SAM_LOADED then return end

local version = tonumber("144") or 144

sam = {}
sam.config = {}
sam.language = {}
sam.player = {}
sam.ranks = {}
sam.permissions = {}
sam.author = "Srlion"
sam.version = version

function sam.print(...)
	MsgC(
		Color(236, 240, 241), "(",
		Color(244, 67, 54), "SAM",
		Color(236, 240, 241), ") ",
		Color(236, 240, 241), ...
	) Msg("\n")
end

local FAILED = false
do
	local types = {
		sv_ = SERVER and include or function() end,
		cl_ = SERVER and AddCSLuaFile or include,
		sh_ = function(name)
			if SERVER then
				AddCSLuaFile(name)
			end
			return include(name)
		end
	}

	sam.load_file = function(name, type)
		if FAILED then return end

		if type and not type:EndsWith("_") then
			type = type .. "_"
		end

		local func = types[type] or types[name:GetFileFromFilename():sub(1, 3)] or types["sh_"]
		if func then
			local rets = {func(name)}
			if rets[1] == false then
				FAILED = true
				sam.print("Failed to load!")
			end
			return unpack(rets)
		end
	end
end
local load_file = sam.load_file

sam.print("Loading...")

load_file("sam/libs/sh_types.lua")
load_file("sam/libs/sh_pon.lua")
load_file("sam/libs/sh_mp.lua")
load_file("sam/libs/sh_netstream.lua")
load_file("sam/libs/sh_async_netstream.lua")
load_file("sam/libs/sh_globals.lua")
load_file("sam/libs/sql/sv_init.lua")
sam.Promise = load_file("sam/libs/sh_promises.lua")

load_file("sam/sh_colors.lua")

load_file("sam/sh_util.lua")
load_file("sam/sh_lang.lua")
load_file("sam/sv_sql.lua")
load_file("sam/sh_permissions.lua")

load_file("sam/ranks/sh_ranks.lua")
load_file("sam/ranks/sv_ranks.lua")

load_file("sam/config/sh_config.lua")
load_file("sam/config/sv_config.lua")
load_file("sam/config/cl_config.lua")

load_file("sam/player/sh_player.lua")
load_file("sam/player/sh_nw_vars.lua")
load_file("sam/player/sv_player.lua")
load_file("sam/player/cl_player.lua")
load_file("sam/player/sv_ranks.lua")
load_file("sam/player/sv_auth.lua")
load_file("sam/player/sv_bans.lua")

load_file("sam/command/sh_command.lua")
load_file("sam/command/sv_command.lua")
load_file("sam/command/cl_command.lua")

for _, f in ipairs(file.Find("sam/command/arguments/*.lua", "LUA")) do
	load_file("sam/command/arguments/" .. f, "sh")
end

load_file("sam/sh_restrictions.lua")

load_file("sam/menu/sh_init.lua")
load_file("sam/menu/cl_init.lua")

load_file("sam/sh_motd.lua")

local modules = file.Find("sam/modules/*.lua", "LUA")
for _, module in ipairs(modules) do
	load_file("sam/modules/" .. module)
end

load_file("sam/reports/cl_reports.lua")
load_file("sam/reports/sv_reports.lua")

do
	if SERVER then
		hook.Add("SAM.LoadedConfig", "SAM.AdvertsMain", function(config)
			if not config.Adverts then
				sam.config.set("Adverts", {})
			end
		end)
	end
	load_file("sam/cl_adverts.lua")
end

if not FAILED then
	sam.print("Loaded!")
end

if SERVER then
	local path = "sam/importers/"

	concommand.Add("sam_import", function(ply, _, args)
		if IsValid(ply) then return end

		local admin_mod = args[1]
		if not admin_mod then
			sam.print("You need to provide an admin mod to import!")
			return
		end

		if not file.Exists(path .. admin_mod, "LUA") then
			sam.print("There is no importer for '" .. admin_mod .. "'")
			return
		end

		CompileFile(path .. admin_mod .. "/main.lua")()
	end, nil, nil, FCVAR_PROTECTED)
end

SAM_LOADED = true
--addons/sam/lua/sam/libs/sh_types.lua:
if SAM_LOADED then return end

-- https://gist.github.com/CapsAdmin/0d9c1e77d0fc22d910e182bfeb9812e5
local getmetatable = getmetatable

do
	local types = {
		["string"] = "",
		["boolean"] = true,
		["number"] = 0,
		["function"] = function() end,
		["thread"] = coroutine.create(getmetatable),
		["Color"] = Color(0, 0, 0),
	}

	for k, v in pairs(types) do
		if not getmetatable(v) then
			debug.setmetatable(v, {MetaName = k})
		else
			getmetatable(v).MetaName = k
		end
	end
end

function sam.type(value)
	if value == nil then
		return "nil"
	end
	local meta = getmetatable(value)
	if meta then
		meta = meta.MetaName
		if meta then
			return meta
		end
	end
	return "table"
end

do
	local function add(name)
		local new_name = name
		if name == "bool" then
			new_name = "boolean"
		end
		sam["is" .. name:lower()] = function(value)
			local meta = getmetatable(value)
			if meta and meta.MetaName == new_name then
				return true
			else
				return false
			end
		end
	end

	add("string")
	add("number")
	add("bool")
	add("function")

	add("Angle")
	add("Vector")
	add("Panel")
	add("Matrix")
end

function sam.isentity(value)
	local meta = getmetatable(value)
	if meta then
		if meta.MetaName == "Entity" then
			return true
		end
		meta = meta.MetaBaseClass
		if meta then
			return meta.MetaName == "Entity"
		end
	end
	return false
end
sam.IsEntity = sam.isentity

local type = sam.type
function sam.istable(value)
	return type(value) == "table"
end
--addons/sam/lua/sam/config/sh_config.lua:
if SAM_LOADED then return end

local sam = sam
local config = sam.config

sam.permissions.add("manage_config", nil, "superadmin")

local updates = {}
function config.hook(keys, func)
	for i = #keys, 1, -1 do
		keys[keys[i]] = true
		keys[i] = nil
	end

	local id = table.insert(updates, {
		keys = keys,
		func = func
	})

	if config.loaded then
		func()
	end

	return id
end

function config.get_updated(key, default)
	local setting = {}
	config.hook({key}, function()
		setting.value = config.get(key, default)
	end)
	return setting
end

function config.remove_hook(key)
	updates[key] = nil
end

hook.Add("SAM.LoadedConfig", "RunHooks", function()
	for k, v in pairs(updates) do
		v.func()
	end
end)

hook.Add("SAM.UpdatedConfig", "RunHooks", function(key, value, old)
	for k, v in pairs(updates) do
		if v.keys[key] then
			v.func(value, old)
		end
	end
end)
--addons/sam/lua/sam/command/arguments/dropdown.lua:
if SAM_LOADED then return end

local sam, command = sam, sam.command

command.new_argument("dropdown")
    :OnExecute(function(arg, input, ply, _, result)
        if not arg.options or table.Empty(arg.options) then
            ply:sam_send_message("no data", {S = "dropdown", S_2 = input})
            return
        end

        table.insert(result, input)
    end)
    :Menu(function(set_result, body, buttons, arg)
        local default = arg.hint or "select"

        local cbo = buttons:Add("SAM.ComboBox")
        cbo:SetValue(default)
		cbo:SetTall(25)

        function cbo:OnSelect(_, value)
            set_result(value)
            default = value
        end

        function cbo:DoClick()
            if self:IsMenuOpen() then
                return self:CloseMenu()
            end

            self:Clear()
            self:SetValue(default)

            if not arg.options then
                LocalPlayer():sam_send_message("dropdown has no options data")
                return
            end

            for k, v in pairs(arg.options) do
                self:AddChoice(v)
            end

            self:OpenMenu()
        end

        return cbo
    end)
:End()
--addons/sam/lua/sam/command/arguments/number.lua:
if SAM_LOADED then return end

local sam, command = sam, sam.command

local get_number = function(argument, input, gsub)
	if (input == "" or input == nil) and argument.optional then
		if argument.default ~= nil then
			return argument.default
		end
		return ""
	end

	local number = tonumber(input)
	if gsub ~= false and not isnumber(number) then
		number = tonumber(input:gsub("%D", ""), 10 /*gsub returns two args*/)
	end

	return number
end

command.new_argument("number")
	:OnExecute(function(argument, input, ply, _, result, i)
		local number = get_number(argument, input)
		if number == "" then
			result[i] = nil
		elseif not number then
			ply:sam_send_message("invalid", {
				S = argument.hint or "number", S_2 = input
			})
			return false
		else
			if argument.min then
				number = math.max(number, argument.min)
			end

			if argument.max then
				number = math.min(number, argument.max)
			end

			if argument.round then
				number = math.Round(number)
			end

			result[i] = number
		end
	end)
	:Menu(function(set_result, body, buttons, argument)
		local number_entry = buttons:Add("SAM.TextEntry")
		number_entry:SetUpdateOnType(true)
		number_entry:SetNumeric(true)
		number_entry:SetTall(25)

		number_entry:SetCheck(function(number)
			number = get_number(argument, number, false)
			set_result(number)
			return number or false
		end)

		local hint = argument.hint or "number"
		if argument.default then
			hint = hint .. " = " .. tostring(argument.default)
		end
		number_entry:SetPlaceholder(hint)

		return number_entry
	end)
:End()
--addons/sam/lua/sam/command/arguments/rank.lua:
if SAM_LOADED then return end

local sam, command = sam, sam.command

local is_good_rank = function(rank, arg, ply)
	if arg.check and not arg.check(rank, ply) then
		return false
	end
	return true
end

command.new_argument("rank")
	:OnExecute(function(arg, input, ply, _, result, i)
		if not input and arg.optional then
			result[i] = nil
			return
		end

		if not sam.ranks.is_rank(input) or not is_good_rank(input, arg, ply) then
			ply:sam_send_message("invalid", {
				S = arg.hint or "rank", S_2 = input
			})
			return false
		end

		result[i] = input
	end)

	:Menu(function(set_result, body, buttons, arg)
		local current_rank = arg.hint or "select rank"

		local ranks = buttons:Add("SAM.ComboBox")
		ranks:SetValue(current_rank)
		ranks:SetTall(25)

		function ranks:OnSelect(_, value)
			set_result(value)
			current_rank = value
		end

		function ranks:DoClick()
			if self:IsMenuOpen() then
				return self:CloseMenu()
			end

			self:Clear()
			self:SetValue(current_rank)

			for rank_name in SortedPairsByMemberValue(sam.ranks.get_ranks(), "immunity", true) do
				if is_good_rank(rank_name, arg, LocalPlayer()) then
					self:AddChoice(rank_name)
				end
			end

			self:OpenMenu()
		end

		return ranks
	end)

	:AutoComplete(function(arg, result, name)
		for rank_name in SortedPairsByMemberValue(sam.ranks.get_ranks(), "immunity", true) do
			if rank_name:lower():find(name, 1, true) and is_good_rank(rank_name, arg, LocalPlayer()) then
				table.insert(result, rank_name)
			end
		end
	end)
:End()
--addons/sam/lua/sam/sh_restrictions.lua:
if SAM_LOADED then return end

local loaded = false
local load_restrictions = function()
	local sam = sam
	local config = sam.config
	local hook = hook
	local SERVER = SERVER

	if CLIENT then
		local add_setting = function(body, title, key)
			local setting = body:Add("SAM.LabelPanel")
			setting:Dock(TOP)
			setting:SetLabel(title)

			local enable = setting:Add("SAM.ToggleButton")
			enable:SetConfig(key, true)

			return setting
		end

		config.add_menu_setting("Restrictions", function(body)
			local setting = body:Add("SAM.LabelPanel")
			setting:Dock(TOP)
			setting:DockMargin(8, 6, 8, 0)
			setting:SetLabel("Restrictions (Check these settings in ranks' permissions)")

			local setting_body = body:Add("Panel")
			setting_body:Dock(TOP)
			setting_body:DockMargin(8, 6, 8, 0)
			setting_body:DockPadding(8, 0, 8, 0)

			add_setting(setting_body, "Tool (Eg. using button tool)", "Restrictions.Tool")
			add_setting(setting_body, "Spawning (Eg. spawning props)", "Restrictions.Spawning")
			add_setting(setting_body, "Limits (Eg. how many props can you spawn)", "Restrictions.Limits")

			function setting_body:PerformLayout()
				setting_body:SizeToChildren(false, true)
			end
		end)
	end

	local tools = weapons.GetStored("gmod_tool")
	if sam.istable(tools) then
		if config.get("Restrictions.Tool", true) then
			for k, v in pairs(tools.Tool) do
				sam.permissions.add(v.Mode, "Tools - " .. (v.Category or "Other"), "user")
			end

			hook.Add("CanTool", "SAM.Module.Restrictions", function(ply, _, tool)
				if not ply:HasPermission(tool) then
					if CLIENT and sam.player.check_cooldown(ply, "ToolNoPermission", 0.1) then
						ply:sam_send_message("You don't have permission to use this tool.")
					end
					return false
				end
			end)
		else
			for k, v in pairs(tools.Tool) do
				sam.permissions.remove(v.Mode)
			end

			hook.Remove("CanTool", "SAM.Module.Restrictions")
		end
	end

	sam.permissions.add("admin_weapons", "Spawning", "superadmin")

	local function no_permission(ply, name)
		ply:sam_play_sound("buttons/button10.wav")
		ply:sam_send_message("You don't have permission to spawn {S Blue}.", {
			S = name
		})
	end

	local spawning = {
		PlayerSpawnProp = {
			name = "props",
			permission = "user",
			call_gm = true,
		},
		PlayerGiveSWEP = {
			name = "give_weapons",
			cb = function(_, ply, _, wep)
				if wep.sam_AdminOnly and not ply:HasPermission("admin_weapons") then
					no_permission(ply, "admin weapons")
					return false
				end
				return true
			end,
			hook = sam.hook_first,
		},
		PlayerSpawnSWEP = {
			name = "spawn_weapons",
			cb = function(_, ply, _, wep)
				if wep.sam_AdminOnly and not ply:HasPermission("admin_weapons") then
					no_permission(ply, "admin weapons")
					return false
				end
				return true
			end,
			hook = sam.hook_first,
		},
		-- PlayerSpawnSENT = {
		-- 	name = "entities",
		-- 	check_limit = "sents"
		-- },
		PlayerSpawnNPC = {
			name = "npcs",
			check_limit = "npcs",
		},
		PlayerSpawnVehicle = {
			name = "vehicles",
			check_limit = "vehicles",
		},
		PlayerSpawnRagdoll = {
			name = "ragdolls",
			permission = "user",
		}
	}

	local override_lists = {
		"Weapon",
		-- "SpawnableEntities"
	}

	local function LimitReachedProcess(ply, str)
		if not IsValid(ply) then return true end
		return ply:CheckLimit(str)
	end

	local GAMEMODE = GAMEMODE

	if config.get("Restrictions.Spawning", true) then
		for k, v in pairs(spawning) do
			local name = v
			local permission = "superadmin"
			local check
			local check_limit
			local hook = sam.hook_last
			if istable(v) then
				name = v.name
				permission = v.permission or permission
				if v.call_gm then
					check = GAMEMODE[k]
				elseif v.cb then
					check = v.cb
				end
				hook = v.hook or hook
				check_limit = v.check_limit
			end

			sam.permissions.add(name, "Spawning", permission)

			if SERVER then
				hook(k, "SAM.Spawning." .. k .. name, function(ply, ...)
					if not ply:HasPermission(name) then
						no_permission(ply, name)
						return false
					end

					if check_limit then
						return LimitReachedProcess(ply, check_limit)
					end

					if check then
						return check(GAMEMODE, ply, ...)
					end

					return true
				end)
			end
		end

		for i = 1, #override_lists do
			for k, v in pairs(list.GetForEdit(override_lists[i])) do
				v.sam_AdminOnly = v.sam_AdminOnly or v.AdminOnly
				v.AdminOnly = false
			end
		end
	else
		for k, v in pairs(spawning) do
			sam.permissions.remove(istable(v) and v.name or v)

			if SERVER then
				hook.Remove(k, "SAM.Spawning." .. k)
			end
		end

		for i = 1, #override_lists do
			for k, v in pairs(list.GetForEdit(override_lists[i])) do
				if v.sam_AdminOnly ~= nil then
					v.AdminOnly = v.sam_AdminOnly
				end
			end
		end
	end

	local PLAYER = FindMetaTable("Player")
	if config.get("Restrictions.Limits", true) then
		local get_limit = sam.ranks.get_limit
		function PLAYER:GetLimit(limit_type)
			return get_limit(self:sam_getrank(), limit_type)
		end

		sam.hook_first("PlayerCheckLimit", "SAM.PlayerCheckLimit", function(ply, limit_type, count)
			local ply_limit = ply:GetLimit(limit_type)
			if ply_limit < 0 then return true end

			if count > ply_limit - 1 then
				return false
			end

			return true
		end)

		sam.limit_types = {}
		for _, limit_type in SortedPairs(cleanup.GetTable(), true) do
			local cvar = GetConVar("sbox_max" .. limit_type)
			if cvar then
				table.insert(sam.limit_types, limit_type)
			end
		end
	else
		sam.limit_types = nil
		PLAYER.GetLimit = nil
		hook.Remove("PlayerCheckLimit", "SAM.PlayerCheckLimit")
	end

	if not loaded then
		loaded = true
		hook.Call("SAM.LoadedRestrictions")
	end
end

timer.Simple(5, function()
	if GAMEMODE.IsSandboxDerived then
		sam.config.hook({"Restrictions.Tool", "Restrictions.Spawning", "Restrictions.Limits"}, load_restrictions)
	end
end)
--addons/sui/lua/includes/modules/sui.lua:
if sui then return end

AddCSLuaFile()

sui = {}

do
	local wspace_chs = {} -- whitespace  characters except a normal space " "
	for k, v in ipairs({0x0c, 0x0a, 0x0d, 0x09, 0x0b}) do
		wspace_chs[string.char(v)] = true
	end
	sui.wspace_chs = wspace_chs

	local cntrl_chs = {string.char(0x7f)} -- control characters
	for i = 0x00, 0x1f do
		cntrl_chs[string.char(i)] = true
	end
	sui.cntrl_chs = cntrl_chs
end

if SERVER then
	AddCSLuaFile("sui/libs/tdlib/cl_tdlib.lua")
	AddCSLuaFile("sui/libs/bshadows.lua")
	AddCSLuaFile("sui/libs/gif_loader.lua")
	AddCSLuaFile("sui/libs/png_encoder.lua")
	AddCSLuaFile("sui/libs/types.lua")
	AddCSLuaFile("sui/cl_base.lua")
else
	include("sui/libs/tdlib/cl_tdlib.lua")
	include("sui/libs/bshadows.lua")
	include("sui/libs/types.lua")
	include("sui/cl_base.lua")
end

if SERVER then
	for _, f in ipairs(file.Find("sui/vgui/*.lua", "LUA")) do
		AddCSLuaFile("sui/vgui/" .. f)
	end
end
--addons/sui/lua/sui/libs/tdlib/cl_tdlib.lua:
--[[
	Three's Derma Lib
	Made by Threebow

	You are free to use this anywhere you like, or sell any addons
	made using this, as long as I am properly accredited.
]]

local pairs = pairs
local ipairs = ipairs
local Color = Color
local render = render
local SysTime = SysTime
local Lerp, RealFrameTime = Lerp, RealFrameTime
local RoundedBox, RoundedBoxEx, NoTexture = draw.RoundedBox, draw.RoundedBoxEx, draw.NoTexture
local SetDrawColor, DrawRect = surface.SetDrawColor, surface.DrawRect
local DrawPoly = surface.DrawPoly
local sui = sui

local Panel = FindMetaTable("Panel")

--[[
	Constants
]]
local BLUR = CreateMaterial("SUI.TDLib.Blur", "gmodscreenspace", {
	["$basetexture"] = "_rt_fullframefb",
	["$blur"] = (1 / 3) * 7,
})

local COL_WHITE_1 = Color(255, 255, 255)
local COL_WHITE_2 = Color(255, 255, 255, 30)

--[[
	credits to http://slabode.exofire.net/circle_draw.shtml
]]
local calculate_circle do
	local cos = math.cos
	local sin = math.sin
	local round = math.Round
	local sqrt = math.sqrt
	local pi = math.pi
	calculate_circle = function(circle, x_centre, y_centre, r)
		if circle.x == x_centre and circle.y == y_centre and circle.r == r then return end

		local step = (2 * pi) / round(6 * sqrt(r))

		local i = 0
		for theta = 2 * pi, 0, -step do
			local x = x_centre + r * cos(theta)
			local y = y_centre - r * sin(theta)
			i = i + 1
			circle[i] = {
				x = x,
				y = y
			}
		end

		for i = i + 1, #circle do
			circle[i] = nil
		end

		circle.x = x_centre
		circle.y = y_centre
		circle.r = r
	end
end

--[[
void DrawArc(float cx, float cy, float r, float start_angle, float arc_angle, int num_segments)
{
	float theta = arc_angle / float(num_segments - 1);//theta is now calculated from the arc angle instead, the - 1 bit comes from the fact that the arc is open

	float tangetial_factor = tanf(theta);

	float radial_factor = cosf(theta);


	float x = r * cosf(start_angle);//we now start at the start angle
	float y = r * sinf(start_angle);

	glBegin(GL_LINE_STRIP);//since the arc is not a closed curve, this is a strip now
	for(int ii = 0; ii < num_segments; ii++)
	{
		glVertex2f(x + cx, y + cy);

		float tx = -y;
		float ty = x;

		x += tx * tangetial_factor;
		y += ty * tangetial_factor;

		x *= radial_factor;
		y *= radial_factor;
	}
	glEnd();
}
]]

local copy_color = function(color)
	return Color(color.r, color.g, color.b, color.a)
end

local color_alpha = function(color, a)
	color.a = a
	return color
end

--[[
	Collection of various utilities
]]

local TDLibUtil = {}

function TDLibUtil.DrawCircle(circle, x, y, r, color)
	calculate_circle(circle, x, y, r)

	SetDrawColor(color)
	NoTexture()
	DrawPoly(circle)
end
local DrawCircle = TDLibUtil.DrawCircle

do
	local SetMaterial = surface.SetMaterial
	local UpdateScreenEffectTexture, DrawTexturedRect, SetScissorRect = render.UpdateScreenEffectTexture, surface.DrawTexturedRect, render.SetScissorRect

	local scrW, scrH = ScrW(), ScrH()
	hook.Add("OnScreenSizeChanged", "SUI.TDLib", function()
		scrW, scrH = ScrW(), ScrH()
	end)

	function TDLibUtil.BlurPanel(s)
		local x, y = s:LocalToScreen(0, 0)

		SetDrawColor(255, 255, 255)
		SetMaterial(BLUR)

		for i = 1, 2 do
			UpdateScreenEffectTexture()
			DrawTexturedRect(x * -1, y * -1, scrW, scrH)
		end
	end

	function TDLibUtil.DrawBlur(x, y, w, h)
		SetDrawColor(255, 255, 255)
		SetMaterial(BLUR)

		SetScissorRect(x, y, x + w, y + h, true)
			for i = 1, 2 do
				UpdateScreenEffectTexture()
				DrawTexturedRect(-1, -1, scrW, scrH)
			end
		SetScissorRect(0, 0, 0, 0, false)
	end
end

local LibClasses = {}

do
	local on_funcs = {}

	function LibClasses:On(name, func)
		local old_func = self[name]

		if not old_func then
			self[name] = func
			return self
		end

		local name_2 = name .. "_funcs"

		-- we gotta avoid creating 13535035 closures
		if not on_funcs[name] then
			on_funcs[name] = function(s, a1, a2, a3, a4)
				local funcs = s[name_2]
				local i, n = 0, #funcs
				::loop::
				i = i + 1
				if i <= n then
					funcs[i](s, a1, a2, a3, a4)
					goto loop
				end
			end
		end

		if not self[name_2] then
			self[name] = on_funcs[name]
			self[name_2] = {
				old_func,
				func
			}
		else
			table.insert(self[name_2], func)
		end

		return self
	end
end

do
	local UnPredictedCurTime = UnPredictedCurTime

	local transition_func = function(s)
		local transitions = s.transitions
		local i, n = 0, #transitions
		::loop::
		i = i + 1

		if i <= n then
			local v = transitions[i]
			local name = v.name
			local v2 = s[name]
			if v.func(s) then
				if v.start_0 then
					v.start_1, v.start_0 = UnPredictedCurTime(), nil
				end

				if v2 ~= 1 then
					s[name] = Lerp((UnPredictedCurTime() - v.start_1) / v.time, v2, 1)
				end
			else
				if v.start_1 then
					v.start_0, v.start_1 = UnPredictedCurTime(), nil
				end

				if v2 ~= 0 then
					s[name] = Lerp((UnPredictedCurTime() - v.start_0) / v.time, v2, 0)
				end
			end

			goto loop
		end
	end

	function LibClasses:SetupTransition(name, time, func)
		self[name] = 0

		local transition = {
			name = name,
			time = time,
			func = func,
			start_0 = 0,
			start_1 = 0,
		}

		if self.transitions then
			for k, v in ipairs(self.transitions) do
				if v.name == name then
					self.transitions[k] = transition
					return self
				end
			end
			table.insert(self.transitions, transition)
		else
			self.transitions = {transition}
			self:On("Think", transition_func)
		end

		return self
	end
end

function LibClasses:ClearPaint()
	self.Paint = nil
	self.Paint_funcs = nil
	local SetPaintBackgroundEnabled = self.SetPaintBackgroundEnabled
	if SetPaintBackgroundEnabled then
		SetPaintBackgroundEnabled(self, false)
	end
	return self
end

function LibClasses:RoundedBox(id, r, x, y, w, h, c)
	self.colors = self.colors or {}
	local colors = self.colors

	local id_c = colors[id]
	if not id_c then
		id_c = Color(c:Unpack())
		colors[id] = id_c
	end

	sui.lerp_color(id_c, c)
	RoundedBox(r, x, y, w, h, id_c)
end

do
	local SetFGColor = Panel.SetFGColor

	local set_color = function(s, col)
		s.m_colText = col
		SetFGColor(s, col.r, col.g, col.b, col.a)
	end

	local paint = function(s)
		local col = s.sui_textcolor
		sui.lerp_color(col, s.new_col)
		set_color(s, col)
	end

	function LibClasses:TextColor(c, use_paint)
		local col = self.sui_textcolor
		if not col then
			col = Color(c:Unpack())
			self.sui_textcolor = col

			if use_paint then
				self:On("Paint", paint)
			end
		end

		if use_paint then
			self.new_col = c
		else
			sui.lerp_color(col, c)
			self:SetTextColor(col)
		end
	end
end

do
	local fade_hover_Paint = function(s, w, h)
		if s.FadeHovers ~= 0 then
			color_alpha(s.fadehover_color, s.fadehover_old_alpha * s.FadeHovers)
			if s.fadehover_radius > 0 then
				RoundedBox(s.fadehover_radius, 0, 0, w, h, s.fadehover_color)
			else
				SetDrawColor(s.fadehover_color)
				DrawRect(0, 0, w, h)
			end
		end
	end

	function LibClasses:FadeHover(color, time, radius, func)
		color = copy_color(color or COL_WHITE_2)
		self.fadehover_color = color
		self.fadehover_radius = radius or 0
		self.fadehover_old_alpha = color.a
		self:SetupTransition("FadeHovers", time or 0.8, func or TDLibUtil.HoverFunc)
		self:On("Paint", fade_hover_Paint)
		return self
	end
end

function LibClasses:BarHover(color, height, time)
	color = color or COL_WHITE_1
	height = height or 2
	time = time or 1.6
	self:SetupTransition("BarHovers", time, TDLibUtil.HoverFunc)
	self:On("Paint", function(s, w, h)
		if s.BarHovers ~= 0 then
			local bar = Round(w * s.BarHovers)
			SetDrawColor(color)
			DrawRect((w / 2) - (bar / 2), h - height, bar, height)
		end
	end)
	return self
end

do
	local paint = function(s, w, h)
		draw.RoundedBox(0, 0, 0, w, h, s.SUI_GetColor("line"))
	end

	function LibClasses:Line(dock, m1, m2, m3, m4)
		self.making_line = true

		local line = self:Add("SAM.Panel")
		line:Dock(dock or TOP)

		if self.line_margin then
			line:DockMargin(unpack(self.line_margin))
		else
			line:DockMargin(m1 or 0, m2 or 0, m3 or 0, m4 or 10)
		end

		line.no_scale = true
		line:SetTall(1)
		line.Paint = paint

		self.making_line = false
		return line
	end

	function LibClasses:LineMargin(m1, m2, m3, m4)
		self.line_margin = {m1 or 0, m2 or 0, m3 or 0, m4 or 0}
		return self
	end
end

do
	local background_Paint_1 = function(s)
		s:SetBGColor(s.background_color)
	end

	local background_Paint_2 = function(s, w, h)
		RoundedBoxEx(s.background_radius, 0, 0, w, h, s.background_color, true, true, true, true)
	end

	local background_Paint_3 = function(s, w, h)
		RoundedBoxEx(s.background_radius, 0, 0, w, h, s.background_color, s.background_r_tl, s.background_r_tr, s.background_r_bl, s.background_r_br)
	end

	function LibClasses:Background(color, radius, r_tl, r_tr, r_bl, r_br)
		self.background_color = color
		if isnumber(radius) and radius ~= 0 then
			self.background_radius = radius
			if isbool(r_tl) or isbool(r_tr) or isbool(r_bl) or isbool(r_br) then
				self.background_r_tl = r_tl
				self.background_r_tr = r_tr
				self.background_r_bl = r_bl
				self.background_r_br = r_br
				self:On("Paint", background_Paint_3)
			else
				self:On("Paint", background_Paint_2)
			end
		else
			self:SetPaintBackgroundEnabled(true)
			self:On("ApplySchemeSettings", background_Paint_1)
			self:On("PerformLayout", background_Paint_1)
		end
		return self
	end
end

function LibClasses:CircleClick(color, speed, target_radius)
	self.circle_click_color = color or COL_WHITE_2

	speed = speed or 5
	target_radius = isnumber(target_radius) and target_radius or false

	local radius, alpha, click_x, click_y = 0, -1, 0, 0
	local circle = {}
	self:On("Paint", function(s, w)
		if alpha >= 0 then
			DrawCircle(circle, click_x, click_y, radius, ColorAlpha(self.circle_click_color, alpha))
			local frame_time = RealFrameTime()
			radius, alpha = Lerp(frame_time * speed, radius, target_radius or w), Lerp(frame_time * speed, alpha, -1)
		end
	end)
	self:On("DoClick", function()
		click_x, click_y = self:CursorPos()
		radius, alpha = 0, self.circle_click_color.a
	end)
	return self
end

do
	local min = math.min
	function LibClasses:CircleClick2(color, speed, target_radius, start_radius)
		color = color or COL_WHITE_2
		local _color = Color(color:Unpack())

		speed = speed or 5
		target_radius = isnumber(target_radius) and target_radius or false

		local radius, alpha = 0, -1
		local circle = {}
		self:On("Paint", function(s, w, h)
			if alpha >= 0 then
				_color.a = alpha
				DrawCircle(circle, w / 2, h / 2, radius, _color)

				local frame_time = RealFrameTime()
				radius, alpha = Lerp(frame_time * speed, radius, target_radius or min(w, h) / 2), Lerp(frame_time * speed, alpha, -1)
			end
		end)

		self:On("DoClick", function()
			radius, alpha = start_radius or 0, color.a
		end)

		return self
	end
end

-- https://github.com/Facepunch/garrysmod/pull/1520#issuecomment-410458090
function LibClasses:Outline(color, width)
	color = color or COL_WHITE_1
	width = width or 1
	self:On("Paint", function(s, w, h)
		SetDrawColor(color)
		DrawRect(0, 0, w, width)
		DrawRect(0, h - width, w, width)
		DrawRect(0, width, width, h - (width * 2))
		DrawRect(w - width, width, width, h - (width * 2))
	end)
	return self
end

function LibClasses:LinedCorners(color, len)
	color = color or COL_WHITE_1
	len = len or 15
	self:On("Paint", function(s, w, h)
		SetDrawColor(color)
		DrawRect(0, 0, len, 1)
		DrawRect(0, 1, 1, len - 1)
		DrawRect(w - len, h - 1, len, 1)
		DrawRect(w - 1, h - len, 1, len - 1)
	end)
	return self
end

function LibClasses:SideBlock(color, size, side)
	color = color or COL_WHITE_1
	size = size or 3
	side = side or LEFT
	self:On("Paint", function(s, w, h)
		SetDrawColor(color)
		if side == LEFT then
			DrawRect(0, 0, size, h)
		elseif side == TOP then
			DrawRect(0, 0, w, size)
		elseif size == RIGHT then
			DrawRect(w - size, 0, size, h)
		elseif side == BOTTOM then
			DrawRect(0, h - size, w, size)
		end
	end)
	return self
end

function LibClasses:Blur()
	self:On("Paint", TDLibUtil.BlurPanel)
	return self
end

do
	local STENCILOPERATION_REPLACE = STENCILOPERATION_REPLACE
	local STENCILOPERATION_ZERO = STENCILOPERATION_ZERO
	local STENCILCOMPARISONFUNCTION_NEVER = STENCILCOMPARISONFUNCTION_NEVER
	local STENCILCOMPARISONFUNCTION_EQUAL = STENCILCOMPARISONFUNCTION_EQUAL

	local ClearStencil = render.ClearStencil
	local SetStencilEnable = render.SetStencilEnable
	local SetStencilWriteMask = render.SetStencilWriteMask
	local SetStencilTestMask = render.SetStencilTestMask
	local SetStencilFailOperation = render.SetStencilFailOperation
	local SetStencilPassOperation = render.SetStencilPassOperation
	local SetStencilZFailOperation = render.SetStencilZFailOperation
	local SetStencilCompareFunction = render.SetStencilCompareFunction
	local SetStencilReferenceValue = render.SetStencilReferenceValue

	local color_white = color_white

	local avatar_setplayer = function(s, ply, size)
		s.avatar:SetPlayer(ply, size)
	end

	local avatar_setsteamid = function(s, steamid, size)
		s.avatar:SetSteamID(steamid, size)
	end

	function LibClasses:CircleAvatar()
		local avatar = self:Add("AvatarImage")
		avatar:Dock(FILL)
		avatar:SetPaintedManually(true)
		self.avatar = avatar
		self.SetSteamID = avatar_setsteamid
		self.SetPlayer = avatar_setplayer

		local circle = {}
		local PaintManual = avatar.PaintManual
		self.Paint = function(s, w, h)
			ClearStencil()
			SetStencilEnable(true)

			SetStencilWriteMask(1)
			SetStencilTestMask(1)

			SetStencilFailOperation(STENCILOPERATION_REPLACE)
			SetStencilPassOperation(STENCILOPERATION_ZERO)
			SetStencilZFailOperation(STENCILOPERATION_ZERO)
			SetStencilCompareFunction(STENCILCOMPARISONFUNCTION_NEVER)
			SetStencilReferenceValue(1)

			local a = w / 2
			DrawCircle(circle, a, a, a, color_white)

			SetStencilFailOperation(STENCILOPERATION_ZERO)
			SetStencilPassOperation(STENCILOPERATION_REPLACE)
			SetStencilZFailOperation(STENCILOPERATION_ZERO)
			SetStencilCompareFunction(STENCILCOMPARISONFUNCTION_EQUAL)
			SetStencilReferenceValue(1)

			PaintManual(avatar)

			SetStencilEnable(false)
		end
		return self
	end
end

do
	function LibClasses:AnimationThinkInternal()
		local systime = SysTime()

		if self.Term and self.Term <= systime then
			self:Remove()

			return
		end

		local m_AnimList = self.m_AnimList
		if not m_AnimList then return end

		for i = #m_AnimList, 1, -1 do
			local anim = m_AnimList[i]
			if systime >= anim.StartTime then
				local frac = math.TimeFraction(anim.StartTime, anim.EndTime, systime)
				frac = math.Clamp(frac, 0, 1)

				local Think = anim.Think
				if Think then
					Think(anim, self, frac ^ (1.0 - (frac - 0.5)))
				end

				if frac == 1 then
					local OnEnd = anim.OnEnd
					if OnEnd then
						OnEnd(anim, self)
					end

					m_AnimList[i] = nil
				end
			end
		end
	end

	local sort = function(a, b)
		return a.EndTime > b.EndTime
	end

	function LibClasses:NewAnimation(length, delay, ease, callback)
		delay = delay or 0
		ease = ease or -1

		if self.m_AnimQueue then
			delay = delay + self:AnimTail()
			self.m_AnimQueue = false
		else
			delay = delay + SysTime()
		end

		local anim = {
			StartTime = delay,
			EndTime = delay + length,
			Ease = ease,
			OnEnd = callback
		}

		self:SetAnimationEnabled(true)

		if self.m_AnimList == nil then
			self.m_AnimList = {}
		end

		table.insert(self.m_AnimList, anim)
		table.sort(self.m_AnimList, sort)

		self.AnimationThink = self.AnimationThinkInternal

		return anim
	end

	local MoveThink = function(anim, panel, frac)
		if not anim.startx then
			anim.startx = panel.x
			anim.starty = panel.y
		end

		local x = Lerp(frac, anim.startx, anim.x)
		local y = Lerp(frac, anim.starty, anim.y)
		panel:SetPos(x, y)
	end

	function LibClasses:MoveTo(x, y, length, delay, ease, callback)
		if self.x == x and self.y == y then return end

		local anim = self:NewAnimation(length, delay, ease, callback)
		anim.x = x
		anim.y = y
		anim.Think = MoveThink
	end

	local SetSize = Panel.SetSize
	local SizeThink = function(anim, panel, frac)
		if not anim.startw then
			anim.startw, anim.starth = panel:GetSize()
		end

		local w, h
		if anim.sizew and anim.sizeh then
			w = Lerp(frac, anim.startw, anim.w)
			h = Lerp(frac, anim.starth, anim.h)
			SetSize(panel, w, h)
		elseif anim.sizew then
			w = Lerp(frac, anim.startw, anim.w)
			SetSize(panel, w, panel.starth)
		else
			h = Lerp(frac, anim.starth, anim.h)
			SetSize(panel, panel.startw, h)
		end

		if panel:GetDock() > 0 then
			panel:InvalidateParent()
		end
	end

	function LibClasses:SizeTo(w, h, length, delay, ease, callback)
		local anim = self:NewAnimation(length, delay, ease, callback)

		if w ~= -1 then
			anim.sizew = true
		end

		if h ~= -1 then
			anim.sizeh = true
		end

		anim.w, anim.h = w, h
		anim.Think = SizeThink

		return anim
	end

	local SetVisible = Panel.SetVisible
	local IsVisible = Panel.IsVisible

	local is_visible = function(s)
		local state = s.visible_state
		if state ~= nil then
			return state
		else
			return IsVisible(s)
		end
	end

	function LibClasses:AnimatedSetVisible(visible, cb)
		if visible == is_visible(self) then
			if cb then
				cb()
			end
			return
		end

		if visible then
			SetVisible(self, true)
		end

		self.visible_state = visible
		self:Stop()

		self:AlphaTo(visible and 255 or 0, 0.2, 0, function()
			SetVisible(self, visible)
			self:InvalidateParent(true)
			if cb then
				cb()
			end
		end)

		self:InvalidateParent(true)
	end

	function LibClasses:AnimatedToggleVisible()
		self:AnimatedSetVisible(not is_visible(self))
	end

	function LibClasses:AnimatedIsVisible()
		return is_visible(self)
	end
end

function Panel:SUI_TDLib()
	for k, v in pairs(LibClasses) do
		self[k] = v
	end
	return self
end

TDLibUtil.Install = Panel.SUI_TDLib

local count = 0
TDLibUtil.Start = function()
	count = count + 1
	for k, v in pairs(LibClasses) do
		if not Panel["SUI_OLD" .. k] then
			local old = Panel[k]
			if old == nil then
				old = v
			end
			Panel[k], Panel["SUI_OLD" .. k] = v, old
		end
	end
end

TDLibUtil.End = function()
	count = count - 1
	if count > 0 then return end
	for k, v in pairs(LibClasses) do
		local old = Panel["SUI_OLD" .. k]
		if old == v then
			Panel[k] = nil
		else
			Panel[k] = old
		end
		Panel["SUI_OLD" .. k] = nil
	end
end

TDLibUtil.HoverFunc = function(p)
	return p:IsHovered() and not p:GetDisabled()
end

TDLibUtil.DrawOutlinedBox = function(radius, x, y, w, h, bg, outline, thickness)
	thickness = thickness or 2
	draw.RoundedBox(radius, x, y, w, h, outline)
	draw.RoundedBox(radius, x + thickness, y + thickness, w - (thickness * 2), h - (thickness * 2), bg)
end

do
	local cos, sin, sqrt = math.cos, math.sin, math.sqrt
	local clamp, floor = math.Clamp, math.floor
	local min, max = math.min, math.max

	local calc_ellipse_points = function(rx, ry)
		local points = sqrt(((rx * ry) / 2) * 6)
		return max(points, 8)
	end

	local M_PI = 3.14159265358979323846
	calc_rect = function(c, r, x, y, w, h)
		if
			(c.r == r) and
			(c.x == x and c.y == y) and
			(c.w == w and c.h == h)
		then return end

		r = clamp(r, 0, min(w, h) / 2)

		local rx, ry = r, r
		if w >= 0.02 then
			rx = min(rx, w / 2.0 - 0.01)
		end
		if h >= 0.02 then
			ry = min(ry, h / 2.0 - 0.01)
		end

		local points = max(calc_ellipse_points(rx, ry) / 4, 1)
		points = floor(points)

		local half_pi = M_PI / 2
		local angle_shift = half_pi / (points + 1)

		local phi = 0
		for i = 1, points + 2 do
			c[i] = {
				x = x + rx * (1 - cos(phi)),
				y = y + ry * (1 - sin(phi))
			}
			phi = phi + angle_shift
		end

		phi = half_pi
		for i = points + 3, 2 * (points + 2) do
			c[i] = {
				x = x + w - rx * (1 + cos(phi)),
				y = y +     ry * (1 - sin(phi))
			}
			phi = phi + angle_shift
		end

		phi = 2 * half_pi
		for i = (2 * (points + 2)) + 1, 3 * (points + 2) do
			c[i] = {
				x = x + w - rx * (1 + cos(phi)),
				y = y + h - ry * (1 + sin(phi))
			}
			phi = phi + angle_shift
		end

		phi = 3 * half_pi
		for i = (3 * (points + 2)) + 1, 4 * (points + 2) do
			c[i] = {
				x = x +     rx * (1 - cos(phi)),
				y = y + h - ry * (1 + sin(phi))
			}
			phi = phi + angle_shift
		end

		local last = (points + 2) * 4 + 1
		c[last] = c[1]

		for i = last + 1, #c do
			c[i] = nil
		end

		c.r = r
		c.x, c.y = x, y
		c.w, c.h = w, h
	end

	TDLibUtil.RoundedBox = function(c, r, x, y, w, h, color)
		calc_rect(c, r, x, y, w, h)

		SetDrawColor(color)
		NoTexture()
		DrawPoly(c)
	end
end

TDLibUtil.LibClasses = LibClasses

sui.TDLib = TDLibUtil
--addons/sam/lua/sam/menu/cl_init.lua:
if SAM_LOADED then return end

local vgui = vgui
local draw = draw

local sam = sam
local sui = sui
local TDLib = sui.TDLib

local config = sam.config

do
	local funcs = {
		["SAM.ComboBox"] = {
			event = "OnSelect",
			function(s, _, value)
				config.set(s.config_key, value)
			end
		},
		["SAM.TextEntry"] = {
			event = "OnEnter",
			function(s)
				local v = s:GetText()
				if s:GetNumeric() then
					v = tonumber(v)
				end
				config.set(s.config_key, v)
			end
		},
		["SAM.ToggleButton"] = {
			event = "OnChange",
			function(s, v)
				config.set(s.config_key, v)
			end
		}
	}

	sam.SUI = sam.SUI or sui.new("SAM", true, {
		SetConfig = function(s, key, default)
			s.config_key = key

			local i = config.hook({key}, function(value, old)
				local v = config.get(key, default)
				s:SetValue(v)
			end)

			local t = funcs[s:GetName()]
			s[t.event] = t[1]

			s:On("OnRemove", function()
				config.remove_hook(i)
			end)
		end
	})
end

local SUI = sam.SUI
local GetColor = SUI.GetColor

sam.menu = {}

local tabs = {}
function sam.menu.add_tab(icon, func, check, pos)
	local tab = {
		icon = icon,
		func = func,
		check = check,
		pos = pos
	}
	for k, v in ipairs(tabs) do
		if v.icon == icon then
			tabs[k] = tab
			return
		end
	end
	table.insert(tabs, tab)
end

function sam.menu.remove_tab(name)
	for k, v in ipairs(tabs) do
		if v.name == name then
			table.remove(tabs, k)
			break
		end
	end
end

SAM_TAB_TITLE_FONT = SUI.CreateFont("TabTitle", "Roboto Bold", 22)
SAM_TAB_DESC_FONT = SUI.CreateFont("TabDesc", "Roboto Medium", 15)

local MENU_LOADING = SUI.CreateFont("MenuLoading", "Roboto", 30)

SUI.AddToTheme("Dark", {
	frame = "#181818",

	scroll_panel = "#181818",

	menu_tabs_title = "#ffffff",

	--=--
	player_list_titles = "#f2f1ef",

	player_list_names = "#eeeeee",
	player_list_names_2 = "#ff6347",
	player_list_data = "#e8e8e8",

	player_list_rank = "#41b9ff",
	player_list_console = "#00c853",
	player_list_rank_text = "#2c3e50",

	player_list_steamid = "#a4a4a4",
	--=--

	--=--
	actions_button = Color(0, 0, 0, 0),
	actions_button_hover = Color(200, 200, 200, 60),

	actions_button_icon = "#aaaaaa",
	actions_button_icon_hover = "#ffffff",
	--=--

	--=--
	page_switch_bg = "#222222",
	--=--
})

SUI.SetTheme("Dark")

function SUI.panels.Frame:Paint(w, h)
	if GetColor("frame_blur") then
		TDLib.BlurPanel(self)
	end

	draw.RoundedBox(8, 0, 0, w, h, GetColor("frame"))
end

function SUI.panels.Frame:HeaderPaint(w, h)
	draw.RoundedBoxEx(8, 0, 0, w, h, GetColor("header"), true, true, false, false)
	draw.RoundedBox(0, 0, h - 1, w, 1, GetColor("line"))
end

do
	function sam.menu.add_loading_panel(parent)
		local is_loading = false

		local loading_panel = parent:Add("Panel")
		loading_panel:SetVisible(false)
		loading_panel:SetZPos(999999)
		loading_panel:SetMouseInputEnabled(false)

		function loading_panel:Paint(w, h)
			draw.RoundedBox(3, 0, 0, w, h, Color(50, 50, 50, 200))
			draw.SimpleText(string.rep(".", (CurTime() * 3) % 3), MENU_LOADING, w/2, h/2, Color(200, 200, 200, 200), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
		end

		parent:SUI_TDLib()
		parent:On("PerformLayout", function(s, w, h)
			loading_panel:SetSize(w, h)
		end)

		local first = true
		local toggle_loading = function(bool)
			if not IsValid(loading_panel) then return end

			is_loading = bool or not is_loading
			if is_loading and not first then
				loading_panel:SetVisible(is_loading and true or false)
				loading_panel:SetMouseInputEnabled(is_loading)
			else
				timer.Simple(0.2, function()
					if not IsValid(loading_panel) then return end
					loading_panel:SetVisible(is_loading and true or false)
					loading_panel:SetMouseInputEnabled(is_loading)
				end)
			end

			first = false
		end

		return toggle_loading, function()
			return is_loading
		end
	end
end

local sam_menu
function sam.menu.open_menu()
	if IsValid(sam_menu) then
		return sam_menu:IsVisible() and sam_menu:Hide() or sam_menu:Show()
		-- sam_menu:Remove()
	end

	sam_menu = vgui.Create("SAM.Frame")
	sam_menu:Center()
	sam_menu:MakePopup()
	sam_menu:SetTitle("SAM")

	sam_menu:AddAnimations(800, 600)

	sam_menu.close.DoClick = function()
		sam_menu:Hide()
	end

	local sheet = sam_menu:Add("SAM.ColumnSheet")
	sheet:Dock(FILL)
	sheet:InvalidateParent(true)
	sheet:InvalidateLayout(true)
	sheet.Paint = nil

	local tab_scroller = sheet.tab_scroller
	tab_scroller:DockMargin(0, 1, 0, 1)

	function tab_scroller:Paint(w, h)
		draw.RoundedBoxEx(8, 0, 0, w, h, GetColor("column_sheet_bar"), false, false, true, false)
	end

	local sheets = {}
	for _, v in SortedPairsByMemberValue(tabs, "pos") do
		sheets[v.icon] = sheet:AddSheet(v.icon, v.func)
	end

	tab_scroller = tab_scroller:GetCanvas()
	sam_menu:On("Think", function()
		for _, v in ipairs(tabs) do
			local tab = sheets[v.icon]
			if v.check and not v.check() then
				if tab:IsVisible() then
					tab:SetVisible(false)
					if sheet:GetActiveTab() == tab then
						sheet:SetActiveTab(sheet.tabs[1])
					end
					tab_scroller:InvalidateLayout()
				end
			elseif not tab:IsVisible() then
				tab:SetVisible(true)
				tab_scroller:InvalidateLayout()
			end
		end
	end)
end

function sam.menu.get()
	return sam_menu
end

hook.Add("GUIMouseReleased", "SAM.CloseMenu", function(mouse_code)
	local panel = vgui.GetHoveredPanel()
	if mouse_code == MOUSE_LEFT and panel == vgui.GetWorldPanel() and IsValid(sam_menu) and sam_menu:HasHierarchicalFocus() then
		sam_menu:Hide()
	end
end)

for _, f in ipairs(file.Find("sam/menu/tabs/*.lua", "LUA")) do
	sam.load_file("sam/menu/tabs/" .. f, "sh")
end
--addons/sui/lua/sui/vgui/sui_image.lua:
local table = table
local file = file
local coroutine = coroutine
local surface = surface

local UnPredictedCurTime = UnPredictedCurTime
local pairs = pairs

local color_white = color_white

local sui = sui
local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name

local read_gif = include("sui/libs/gif_loader.lua")
local generate_png = include("sui/libs/png_encoder.lua")

local images_path = (NAME .. "/images/"):lower()
file.CreateDir(images_path)

local get_image_path = function(url)
	return images_path .. (url:gsub("%W", "_") .. ".png")
end

local Write = file.Write
local gif_to_png; do
	local internal_gif_to_png = function(file_path, chunk)
		local gif = read_gif(chunk)
		local frames = gif:get_frames()
		local w, h = gif.width, gif.height

		local path = file_path .. "/"
		file.CreateDir(path)

		for frame_id = 1, #frames do
			local frame = frames[frame_id]
			local data = frame.data
			local png = generate_png(w, h, data)
			Write(("%s%d_%d.png"):format(path, frame_id, frame.delay), png)
			coroutine.yield()
		end
	end

	local delay = 0.01
	local next_run = 0

	local coroutines = {}
	local callbacks = {}
	gif_to_png = function(file_path, data, callback)
		local co = coroutine.create(internal_gif_to_png)
		local i = table.insert(coroutines, co)
		callbacks[i] = callback
		coroutine.resume(co, file_path, data)
		next_run = UnPredictedCurTime()
	end

	hook.Add("Think", NAME .. "ProcessGIFs", function()
		local co = coroutines[1]
		if not co then return end
		if UnPredictedCurTime() < next_run then return end

		if coroutine.status(co) == "suspended" then
			coroutine.resume(co)
		else
			callbacks[1]()
			table.remove(coroutines, 1)
			table.remove(callbacks, 1)
		end

		next_run = UnPredictedCurTime() + delay
	end)

	hook.Add(NAME .. "ImagesCleared", "ClearCoroutines", function()
		table.Empty(coroutines)
		table.Empty(callbacks)
	end)
end

local download_image, is_downloading_image; do
	-- https://stackoverflow.com/questions/25959386/how-to-check-if-a-file-is-a-valid-image
	local valid_images = {
		["\xff\xd8\xff"] = "jpeg",
		["\x89PNG\r\n\x1a\n"] = "png",
		["GIF87a"] = "gif",
		["GIF89a"] = "gif",
	}

	local get_image_type = function(data)
		for k, v in pairs(valid_images) do
			if data:StartWith(k) then
				return v
			end
		end
		return false
	end

	local downloading_images = {}

	local process_callbacks = function(url)
		local callbacks = downloading_images[url] or {}
		downloading_images[url] = nil

		for _, func in ipairs(callbacks) do
			func()
		end
	end

	download_image = function(url, callback)
		if downloading_images[url] then
			table.insert(downloading_images[url], callback)
			return
		end

		downloading_images[url] = {callback}

		http.Fetch(url, function(data)
			local image_type = get_image_type(data)
			if not image_type then
				downloading_images[url] = nil
				return
			end

			local image_path = get_image_path(url)

			if image_type == "gif" then
				gif_to_png(image_path, data, function()
					process_callbacks(url)
				end)
			else
				file.Write(image_path, data)
				process_callbacks(url)
			end
		end, function(err)
			print("(SUI) Failed to download an image, error: " .. err)
			downloading_images[url] = nil
		end)
	end

	is_downloading_image = function(url)
		return downloading_images[url] ~= nil
	end

	hook.Add(NAME .. "ImagesCleared", "ClearDownloadingImages", function()
		table.Empty(downloading_images)
	end)
end

local images_panels = {}

local PANEL = {}

local err_mat = SUI.Material("error")

function PANEL:Init()
	self:SetMouseInputEnabled(false)

	self.minus = 0
	self.rotation = 0
	self.image = err_mat
	self.image_col = color_white

	table.insert(images_panels, self)
end

function PANEL:OnRemove()
	for k, v in ipairs(images_panels) do
		if v == self then
			table.remove(images_panels, k)
			return
		end
	end
end

function PANEL:SetMinus(minus)
	self.minus = minus
end

function PANEL:SetRotation(rotation)
	self.rotation = rotation
end

function PANEL:SetImageColor(col)
	self.image_col = col
end

local cached_files = {}
local get_files = function(image_path)
	local f = cached_files[image_path]
	if f then return f end

	cached_files[image_path] = file.Find(image_path .. "/*", "DATA")

	return cached_files[image_path]
end

function PANEL:SetImage(url)
	self.image = err_mat

	self.pos = nil
	self.delay = nil

	self.images = nil
	self.delays = nil
	self.url = url

	if url:sub(1, 4) ~= "http" then
		self.image = SUI.Material(url)
		return
	end

	local image_path = get_image_path(url)
	if not file.Exists(image_path, "DATA") or is_downloading_image(url) then
		download_image(url, function()
			if self:IsValid() then
				self:SetImage(url)
			end
		end)
		return
	end

	local is_gif = file.IsDir(image_path, "DATA")
	if is_gif then
		local images = {}
		local delays = {}

		local files = get_files(image_path)
		for i = 1, #files do
			local v = files[i]
			local id, delay = v:match("(.*)_(.*)%.png")
			id = tonumber(id)
			local img_path = "../data/" .. image_path .. "/" .. v
			images[id] = img_path
			delays[id] = delay
		end

		self.frame = 1
		self.delay = (UnPredictedCurTime() * 100) + delays[1]

		self.images = images
		self.delays = delays

		self.max_images = #files
	else
		self.image = SUI.Material("../data/" .. image_path)
	end
end

local SetMaterial = surface.SetMaterial
function PANEL:PaintGIF(w, h, images)
	local frame = self.frame

	-- SUI.Material() caches materials by default
	local mat = SUI.Material(images[frame], true)
	if not mat then
		if frame > 1 then
			mat = SUI.Material(images[frame - 1])
		else
			mat = err_mat
		end

		SetMaterial(mat)

		return
	end

	SetMaterial(mat)

	local curtime = UnPredictedCurTime() * 100
	if curtime < self.delay then return end
	frame = frame + 1
	if frame > self.max_images then
		frame = 1
	end

	self.frame = frame
	self.delay = curtime + self.delays[frame]
end

local PaintGIF = PANEL.PaintGIF
local SetDrawColor = surface.SetDrawColor
local DrawTexturedRectRotated = surface.DrawTexturedRectRotated
function PANEL:Paint(w, h)
	SetDrawColor(self.image_col)

	local images = self.images
	if images then
		PaintGIF(self, w, h, images)
	else
		SetMaterial(self.image)
	end

	if self.Draw then
		self:Draw(w, h, true)
	else
		local minus = self.minus
		DrawTexturedRectRotated(w * 0.5, h * 0.5, w - minus, h - minus, self.rotation)
	end
end

sui.register("Image", PANEL, "PANEL")

function SUI.ClearImages()
	local files, dirs = file.Find(images_path .. "/*", "DATA")
	for _, f in ipairs(files) do
		file.Delete(images_path .. f)
	end

	for _, d in ipairs(dirs) do
		for _, f in ipairs(file.Find(images_path .. d .. "/*", "DATA")) do
			file.Delete(images_path .. (d .. "/" .. f))
		end
		file.Delete(images_path .. d)
	end

	table.Empty(SUI.materials)
	table.Empty(cached_files)

	hook.Call(NAME .. "ImagesCleared")

	for k, v in ipairs(images_panels) do
		if v.url then
			v:SetImage(v.url)
		end
	end
end
--addons/sui/lua/sui/vgui/sui_menu.lua:
local BSHADOWS = sui.BSHADOWS
local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name

local GetColor = SUI.GetColor
local lerp_color = sui.lerp_color
local contrast_color = sui.contrast_color

local RoundedBox = sui.TDLib.LibClasses.RoundedBox
local TextColor = sui.TDLib.LibClasses.TextColor

local OPTION_FONT = SUI.CreateFont("MenuOption", "Roboto Medium", 15, 500)

local PANEL = {}

AccessorFunc(PANEL, "m_bIsMenuComponent", "IsMenu")
AccessorFunc(PANEL, "m_bDeleteSelf", "DeleteSelf")
AccessorFunc(PANEL, "m_iMinimumWidth", "MinimumWidth")
AccessorFunc(PANEL, "m_SetInternal", "Internal")

PANEL:SetIsMenu(true)
PANEL:SetDeleteSelf(true)

local pad = 4

function PANEL:Init()
	self:DockPadding(0, pad, 0, pad)
	self:SetMinimumWidth(SUI.Scale(100))
	self:SetKeyboardInputEnabled(false)
	self:SetTall(pad * 2)
	self:SetAlpha(0)
	self.tall = pad * 2
	RegisterDermaMenuForClose(self)
end

function PANEL:Paint(w, h)
	local x, y = self:LocalToScreen()

	BSHADOWS.BeginShadow()
		self:RoundedBox("Background", pad, x, y, w, h, GetColor("menu"))
	BSHADOWS.EndShadow(1, 3, 3)

	self:MoveToFront()
end

function PANEL:PerformLayout()
	local w, h = self:ChildrenSize()
	self:SetSize(math.max(self:GetMinimumWidth(), w), h)
end

function PANEL:Open(x, y)
	self:SizeToChildren(true, false)

	local w, h = self:GetSize()

	local internal = self:GetInternal()
	internal:On("OnRemove", function()
		self:Remove()
	end)
	if not x then
		x, y = internal:LocalToScreen(0, 0)
		y = y + (internal:GetTall() + 2)
	end

	if y + h > ScrH() then
		y = y - h
	end

	if x + w > ScrW() then
		x = x - w
	end

	if y < 1 then
		y = 1
	end

	if x < 1 then
		x = 1
	end

	self:SetPos(x, y)
	self:MakePopup()
	self:AlphaTo(255, 0.23)
	self:SetDrawOnTop(true)
	self:MoveToFront()
end

local option_OnMouseReleased = function(s, mousecode)
	if s.Depressed and mousecode == MOUSE_LEFT then
		CloseDermaMenus()
	end
	DButton.OnMouseReleased(s, mousecode)
end

function PANEL:AddOption(str, callback)
	local option = self:Add("DButton")
	option:Dock(TOP)
	option:SetFont(OPTION_FONT)
	option:SetText(str)
	option:SizeToContentsX(20)
	option:SizeToContentsY(10)
	option:InvalidateLayout(true)
	option.OnMouseReleased = option_OnMouseReleased

	function option:Paint(w, h)
		RoundedBox(self, "Background", 0, 0, 0, w, h, self.Hovered and GetColor("menu_option_hover") or GetColor("menu_option"))
		TextColor(self, self.Hovered and GetColor("menu_option_hover_text") or GetColor("menu_option_text"))
	end

	option.DoClick = callback

	self.tall = self.tall + option:GetTall()
	self:SetTall(self.tall)

	return option
end

function PANEL:AddSpacer()
	local spacer = self:Add("Panel")
	spacer:Dock(TOP)
	spacer:DockMargin(0, 1, 0, 1)
	spacer:SetTall(2)

	function spacer:Paint(w, h)
		RoundedBox(self, "Background", 0, 0, 0, w, h, GetColor("menu_spacer"))
	end

	spacer:InvalidateLayout(true)
end

sui.register("Menu", PANEL, "PANEL")
--addons/sui/lua/sui/vgui/sui_slider.lua:
local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name
local TDLib = sui.TDLib

local Panel = {}

sui.scaling_functions(Panel)

AccessorFunc(Panel, "m_bValue", "Value", FORCE_NUMBER)
AccessorFunc(Panel, "m_bMin", "Min", FORCE_NUMBER)
AccessorFunc(Panel, "m_bMax", "Max", FORCE_NUMBER)
AccessorFunc(Panel, "m_bDecimals", "Decimals", FORCE_NUMBER)

function Panel:Init()
	self:ScaleInit()

	self:SetMin(0)
	self:SetMax(10)
	self:SetValue(1)
	self:SetDecimals(1)

	self:SetSize(100, 12)

	self.rounded_box = {}

	self.Knob.circle = {}
	self.Knob.Paint = self.KnobPaint
	self:SetTrapInside(true)
end

function Panel:SetMinMax(min, max)
	self:SetMin(min)
	self:SetMax(max)
end

function Panel:TranslateValues(x, y)
	self:SetValue(self:GetMin() + (x * self:GetRange()))
	return self:GetFraction(), y
end

function Panel:GetFraction()
	return (self:GetValue() - self:GetMin()) / self:GetRange()
end

function Panel:SetValue(val)
	val = math.Clamp(val, self:GetMin(), self:GetMax())
	val = math.Round(val, self:GetDecimals())

	self.m_bValue = val
	self:SetSlideX((val - self:GetMin()) / self:GetRange())

	self:OnValueChanged(val)
end

function Panel:OnValueChanged(val)
end

function Panel:GetRange()
	return self:GetMax() - self:GetMin()
end

function Panel:Paint(w, h)
	local _h = SUI.Scale(2)
	TDLib.RoundedBox(self.rounded_box, 3, 0, h / 2 - _h / 2, w, _h, SUI.GetColor("slider_track"))
end

function Panel:KnobPaint(w, h)
	if self.Depressed then
		TDLib.DrawCircle(self.circle, w / 2, h / 2, h / 1.1, SUI.GetColor("slider_pressed"))
	elseif self.Hovered then
		TDLib.DrawCircle(self.circle, w / 2, h / 2, h / 1.1, SUI.GetColor("slider_hover"))
	end

	TDLib.DrawCircle(self.circle, w / 2, h / 2, h / 2, SUI.GetColor("slider_knob"))
end

function Panel:PerformLayout(w, h)
	self.Knob:SetSize(SUI.Scale(12), SUI.Scale(12))
	DSlider.PerformLayout(self, w, h)
end

sui.register("Slider", Panel, "DSlider")
--addons/sam/lua/sam/menu/tabs/bans.lua:
if SAM_LOADED then return end

local sam = sam
local SQL = sam.SQL
local SUI = sam.SUI
local netstream = sam.netstream

sam.permissions.add("manage_bans", nil, "superadmin")

local get_pages_count = function(bans_count)
	bans_count = bans_count / 35
	local i2 = math.floor(bans_count)
	return bans_count ~= i2 and i2 + 1 or bans_count
end

if SERVER then
	local check = function(ply)
		return ply:HasPermission("manage_bans") and ply:sam_check_cooldown("MenuManageBans", 0.1)
	end

	local limit = 35

	local get_page_count = function(res, callback, page, order_by, keyword)
		local current_time = os.time()
		local query = [[
			SELECT
				COUNT(`steamid`) AS `count`
			FROM
				`sam_bans`
			WHERE
				(`unban_date` >= %d OR `unban_date` = 0)]]

		query = query:format(current_time)

		if keyword then
			query = query .. " AND `steamid` LIKE " .. SQL.Escape("%" .. keyword .. "%")
		end

		SQL.Query(query, callback, true, {res, page, order_by, keyword, current_time})
	end

	local resolve_promise = function(data, arguments)
		local res = arguments[1]
		arguments[1] = data
		res(arguments)
	end

	local get_bans = function(count_data, arguments)
		local res, page, order_by, keyword, current_time = unpack(arguments)
		local count = count_data.count

		local current_page
		if page < 1 then
			page, current_page = 1, 1
		end

		local pages_count = get_pages_count(count)
		if page > pages_count then
			page, current_page = pages_count, pages_count
		end

		local query = [[
			SELECT
				`sam_bans`.*,
				IFNULL(`p1`.`name`, '') AS `name`,
				IFNULL(`p2`.`name`, '') AS `admin_name`
			FROM
				`sam_bans`
			LEFT OUTER JOIN
				`sam_players` AS `p1`
			ON
				`sam_bans`.`steamid` = `p1`.`steamid`
			LEFT OUTER JOIN
				`sam_players` AS `p2`
			ON
				`sam_bans`.`admin` = `p2`.`steamid`
			WHERE
				(`sam_bans`.`unban_date` >= %d OR `sam_bans`.`unban_date` = 0)]]

		query = query:format(current_time)

		if keyword then
			query = query .. " AND `sam_bans`.`steamid` LIKE " .. SQL.Escape("%" .. keyword .. "%")
		end

		local offset = math.abs(limit * (page - 1))
		query = query .. ([[
			ORDER BY
				`sam_bans`.`id` %s
			LIMIT
				%d OFFSET %d]]):format(order_by, limit, offset)

		SQL.Query(query, resolve_promise, nil, {res, count, current_page})
	end

	netstream.async.Hook("SAM.GetBans", function(res, ply, page, order_by, keyword)
		if not isnumber(page) then return end
		if order_by ~= "ASC" and order_by ~= "DESC" then return end
		if keyword ~= nil and not sam.isstring(keyword) then return end

		get_page_count(res, get_bans, page, order_by, keyword)
	end, check)

	return
end

local GetColor = SUI.GetColor
local Line = sui.TDLib.LibClasses.Line

local COLUMN_FONT = SUI.CreateFont("Column", "Roboto", 18)
local LINE_FONT = SUI.CreateFont("Line", "Roboto", 16)
local NEXT_FONT = SUI.CreateFont("NextButton", "Roboto", 18)

sam.menu.add_tab("https://raw.githubusercontent.com/Srlion/Addons-Data/main/icons/sam/ban-user.png", function(column_sheet)
	local refresh, pages
	local current_page, current_order, keyword = nil, "DESC", nil

	local bans_body = column_sheet:Add("Panel")
	bans_body:Dock(FILL)
	bans_body:DockMargin(0, 1, 0, 0)
	bans_body:DockPadding(10, 10, 10, 10)

	local toggle_loading, is_loading = sam.menu.add_loading_panel(bans_body)

	local title = bans_body:Add("SAM.Label")
	title:Dock(TOP)
	title:SetFont(SAM_TAB_TITLE_FONT)
	title:SetText("Bans")
	title:SetTextColor(GetColor("menu_tabs_title"))
	title:SizeToContents()

	local total = bans_body:Add("SAM.Label")
	total:Dock(TOP)
	total:DockMargin(0, 6, 0, 0)
	total:SetFont(SAM_TAB_DESC_FONT)
	total:SetText("60 total bans")
	total:SetTextColor(GetColor("menu_tabs_title"))
	total:SetPos(10, SUI.Scale(40))
	total:SizeToContents()

	do
		local container = bans_body:Add("SAM.Panel")
		container:Dock(TOP)
		container:DockMargin(0, 6, 10, 0)
		container:SetTall(30)

		local sort_order = container:Add("SAM.ComboBox")
		sort_order:Dock(RIGHT)
		sort_order:SetWide(96)
		sort_order:SetValue("Desc")
		sort_order:AddChoice("Desc")
		sort_order:AddChoice("Asc")

		function sort_order:OnSelect(_, value)
			value = value:upper()
			if current_order ~= value then
				current_order = value
				refresh()
			end
		end

		local search_entry = container:Add("SAM.TextEntry")
		search_entry:Dock(LEFT)
		search_entry:SetNoBar(true)
		search_entry:SetPlaceholder("Search...")
		search_entry:SetRadius(4)
		search_entry:SetWide(220)

		function search_entry:OnEnter()
			local value = self:GetValue()
			if keyword ~= value then
				keyword = value ~= "" and value or nil
				refresh()
			end
		end
	end

	Line(bans_body, nil, -5, 15, -5, 0)

	do
		local columns = bans_body:Add("Panel")
		columns:Dock(TOP)
		columns:DockMargin(0, 10, 0, 0)

		local info = columns:Add("SAM.Label")
		info:Dock(LEFT)
		info:DockMargin(4, 0, 0, 0)
		info:SetFont(COLUMN_FONT)
		info:SetText("Player")
		info:SetTextColor(GetColor("player_list_titles"))
		info:SetWide(SUI.Scale(280) + SUI.Scale(34))
		info:SizeToContentsY(3)

		local time_left = columns:Add("SAM.Label")
		time_left:Dock(LEFT)
		time_left:DockMargin(-4, 0, 0, 0)
		time_left:SetFont(COLUMN_FONT)
		time_left:SetText("Time Left")
		time_left:SetTextColor(GetColor("player_list_titles"))
		time_left:SetWide(SUI.Scale(180))
		time_left:SizeToContentsY(3)

		local reason = columns:Add("SAM.Label")
		reason:Dock(LEFT)
		reason:DockMargin(-4, 0, 0, 0)
		reason:SetFont(COLUMN_FONT)
		reason:SetText("Reason")
		reason:SetTextColor(GetColor("player_list_titles"))
		reason:SetWide(SUI.Scale(280))
		reason:SizeToContentsY(3)

		columns:SizeToChildren(false, true)
	end

	local body = bans_body:Add("SAM.ScrollPanel")
	body:Dock(FILL)
	body:DockMargin(0, 10, 0, 0)
	body:SetVBarPadding(6)

	local set_data = function(data)
		body:GetCanvas():Clear()
		body.VBar.Scroll = 0

		local bans, bans_count, current_page_2 = unpack(data)
		total:SetText(bans_count .. " total bans")

		pages = get_pages_count(bans_count)
		current_page.i = pages == 0 and 0 or current_page_2 or current_page.i
		current_page:SetText(current_page.i .. "/" .. pages)

		body:Line()

		for k, v in ipairs(bans) do
			local line = body:Add("SAM.PlayerLine")
			line:DockMargin(0, 0, 0, 10)

			local name = v.name ~= "" and v.name or nil
			local admin_name = v.admin_name ~= "" and v.admin_name or nil
			line:SetInfo({
				steamid = v.steamid,
				name = name,
				rank = admin_name or (v.admin == "Console" and "Console"),
				rank_bg = not admin_name and GetColor("player_list_console")
			})

			local unban_date = tonumber(v.unban_date)
			local time_left = line:Add("SAM.Label")
			time_left:Dock(LEFT)
			time_left:DockMargin(-3, 0, 0, 0)
			time_left:SetFont(LINE_FONT)
			time_left:SetText(unban_date == 0 and "Never" or sam.reverse_parse_length((unban_date - os.time()) / 60))
			time_left:SetTextColor(GetColor("player_list_data"))
			time_left:SetContentAlignment(4)
			time_left:SetWide(SUI.Scale(180))

			local reason = line:Add("SAM.Label")
			reason:Dock(LEFT)
			reason:DockMargin(4, 0, 0, 0)
			reason:SetFont(LINE_FONT)
			reason:SetText(v.reason)
			reason:SetTextColor(GetColor("player_list_data"))
			reason:SetContentAlignment(4)
			reason:SetWrap(true)
			reason:SetWide(SUI.Scale(200))

			local old_tall = line.size
			function reason:PerformLayout()
				local _, h = self:GetTextSize()
				if old_tall < h then
					line:SetTall(h)
				end
			end

			local but = line:Actions()
			but:On("DoClick", function()
				local dmenu = vgui.Create("SAM.Menu")
				dmenu:SetInternal(but)
				if name then
					dmenu:AddOption("Copy Name", function()
						SetClipboardText(name)
					end)
				end
				dmenu:AddOption("Copy SteamID", function()
					SetClipboardText(v.steamid)
				end)
				dmenu:AddOption("Copy Reason", function()
					SetClipboardText(v.reason)
				end)
				dmenu:AddOption("Copy Time Left", function()
					SetClipboardText(time_left:GetText())
				end)

				if v.admin ~= "Console" then
					dmenu:AddSpacer()

					if admin_name then
						dmenu:AddOption("Copy Admin Name", function()
							SetClipboardText(admin_name)
						end)
					end

					dmenu:AddOption("Copy Admin SteamID", function()
						SetClipboardText(v.admin)
					end)
				end

				if LocalPlayer():HasPermission("unban") then
					dmenu:AddSpacer()
					dmenu:AddOption("Unban", function()
						local user = name and ("%s (%s)"):format(name, v.steamid) or v.steamid
						local querybox = vgui.Create("SAM.QueryBox")
						querybox:SetWide(350)
						querybox:SetTitle(user)

						local check = querybox:Add("SAM.Label")
						check:SetText(sui.wrap_text("Are you sure that you want to unban\n" .. user, LINE_FONT, SUI.Scale(350)))
						check:SetFont(LINE_FONT)
						check:SizeToContents()

						querybox:Done()
						querybox.save:SetEnabled(true)
						querybox.save:SetText("UNBAN")

						querybox.save:SetContained(false)
						querybox.save:SetColors(GetColor("query_box_cancel"), GetColor("query_box_cancel_text"))

						querybox.cancel:SetContained(true)
						querybox.cancel:SetColors()

						querybox:SetCallback(function()
							RunConsoleCommand("sam", "unban", v.steamid)
						end)
					end)
				end
				dmenu:Open()
			end)

			body:Line()
		end

		body:InvalidateLayout(true)
		body:GetCanvas():InvalidateLayout(true)
	end

	refresh = function()
		if not is_loading() and LocalPlayer():HasPermission("manage_bans") then
			local refresh_query = netstream.async.Start("SAM.GetBans", toggle_loading, current_page.i, current_order, keyword)
			refresh_query:done(set_data)
		end
	end

	local bottom_panel = bans_body:Add("SAM.Panel")
	bottom_panel:Dock(BOTTOM)
	bottom_panel:DockMargin(0, 6, 0, 0)
	bottom_panel:SetTall(30)
	bottom_panel:Background(GetColor("page_switch_bg"))

	local previous_page = bottom_panel:Add("SAM.Button")
	previous_page:Dock(LEFT)
	previous_page:SetWide(30)
	previous_page:SetText("<")
	previous_page:SetFont(NEXT_FONT)

	previous_page:On("DoClick", function()
		if current_page.i <= 1 then return end

		current_page.i = current_page.i - 1
		refresh()
	end)

	current_page = bottom_panel:Add("SAM.Label")
	current_page:Dock(FILL)
	current_page:SetContentAlignment(5)
	current_page:SetFont(SAM_TAB_DESC_FONT)
	current_page:SetText("loading...")
	current_page.i = 1

	local next_page = bottom_panel:Add("SAM.Button")
	next_page:Dock(RIGHT)
	next_page:SetWide(30)
	next_page:SetText(">")
	next_page:SetFont(NEXT_FONT)

	next_page:On("DoClick", function()
		if current_page.i == pages then return end

		current_page.i = current_page.i + 1
		refresh()
	end)

	function bottom_panel:Think()
		next_page:SetEnabled(current_page.i ~= pages)
		previous_page:SetEnabled(current_page.i > 1)
	end

	for k, v in ipairs({"SAM.BannedPlayer", "SAM.BannedSteamID", "SAM.EditedBan", "SAM.UnbannedSteamID"}) do
		hook.Add(v, "SAM.MenuBans", function()
			if IsValid(body) then
				refresh()
			end
		end)
	end

	refresh()

	return bans_body
end, function()
	return LocalPlayer():HasPermission("manage_bans")
end, 4)
--addons/sam/lua/sam/menu/tabs/commands.lua:
if SAM_LOADED then return end
if SERVER then return end

local sam = sam
local SUI = sam.SUI
local type = sam.type

local Line = sui.TDLib.LibClasses.Line

local COMMAND_HELP = SUI.CreateFont("CommandHelp", "Roboto", 14)
local COMMAND_RUN = SUI.CreateFont("CommandRun", "Roboto Medium", 14)

sam.menu.add_tab("https://raw.githubusercontent.com/Srlion/Addons-Data/main/icons/sam/command_window.png", function(column_sheet)
	local tab_body = column_sheet:Add("Panel")
	tab_body:Dock(FILL)
	tab_body:DockMargin(0, 1, 0, 0)

	do
		local title = tab_body:Add("SAM.Label")
		title:Dock(TOP)
		title:DockMargin(10, 10, 0, 0)
		title:SetFont(SAM_TAB_TITLE_FONT)
		title:SetText("Commands")
		title:SetTextColor(SUI.GetColor("menu_tabs_title"))
		title:SizeToContents()
	end

	local body = tab_body:Add("Panel")
	body:Dock(FILL)
	body:DockMargin(10, 5, 10, 10)

	Line(body)

	local left_body = body:Add("SAM.Panel")
	left_body:Dock(LEFT)
	left_body:SetWide(148)

	local search_entry = left_body:Add("SAM.TextEntry")
	search_entry:Dock(TOP)
	search_entry:SetNoBar(true)
	search_entry:SetPlaceholder("Search...")
	search_entry:SetRadius(4)
	search_entry:SetTall(27)

	local category_list = left_body:Add("SAM.CollapseCategory")
	category_list:Dock(FILL)
	category_list:DockMargin(0, SUI.Scale(10), 0, 0)

	local canvas = category_list:GetCanvas()

	local commands_refresh = function()
		if not IsValid(category_list) then return end

		canvas:Clear()
		table.Empty(category_list.items)
		table.Empty(category_list.categories)

		for k, v in ipairs(sam.command.get_commands()) do
			if (v.permission and not LocalPlayer():HasPermission(v.permission)) or v.menu_hide then
				continue
			end

			local item = category_list:add_item(v.name, v.category)
			item:InvalidateParent(true)
			item.help = v.help
			item.command = v

			item.names = {v.name:lower()}
			for _, aliase in ipairs(v.aliases) do
				table.insert(item.names, aliase:lower())
			end
		end
	end
	commands_refresh()

	do
		local hooks = {
			"SAM.CommandAdded", "SAM.CommandModified", "SAM.CommandRemoved",
			"SAM.RemovedPermission",
			{"SAM.ChangedPlayerRank", func = function(ply, rank, old_rank)
				if rank == old_rank then return end
				if ply == LocalPlayer() then
					commands_refresh()
				end
			end},
			{
				"SAM.RankPermissionGiven", "SAM.RankPermissionTaken", "SAM.ChangedInheritRank",
				func = function(rank)
					if rank == LocalPlayer():sam_getrank() then
						commands_refresh()
					end
				end
			},
			{
				"SAM.AddedPermission", "SAM.PermissionModified",
				func = function(_, _, rank)
					if rank == LocalPlayer():sam_getrank() then
						commands_refresh()
					end
				end
			}
		}
		for _, v in ipairs(hooks) do
			if type(v) == "table" then
				for _, v2 in ipairs(v) do
					hook.Add(v2, "SAM.Menu.RefreshCommands", v.func)
				end
			else
				hook.Add(v, "SAM.Menu.RefreshCommands", commands_refresh)
			end
		end
	end

	function search_entry:OnValueChange(text)
		category_list:Search(text:lower())
	end

	do
		local line = Line(body, LEFT)
		line:DockMargin(10, 0, 10, 0)
		line:SetWide(1)
	end

	local buttons = body:Add("SAM.ScrollPanel")
	buttons:Dock(FILL)

	local childs = {}
	local pos = 0
	buttons:GetCanvas():On("OnChildAdded", function(s, child)
		child:Dock(TOP)
		child:DockMargin(0, 0, 0, 5)
		child:SetAlpha(0)
		child:SetVisible(false)
		table.insert(childs, child)

		pos = pos + 1
		child:SetZPos(pos)
	end)

	local run_command = buttons:Add("SAM.Button")
	run_command:Dock(TOP)
	run_command:SetTall(25)
	run_command:SetFont(COMMAND_RUN)
	run_command:SetZPos(100)
	run_command:SetEnabled(false)

	run_command:On("DoClick", function(self)
		LocalPlayer():ConCommand("sam\"" .. self:GetText() .. "\"\"" .. table.concat(self.input_arguments, "\"\"") .. "\"")
	end)

	local help = buttons:Add("SAM.Label")
	help:Dock(TOP)
	help:SetFont(COMMAND_HELP)
	help:SetZPos(101)
	help:SetWrap(true)
	help:SetAutoStretchVertical(true)

	sam.menu.get():On("OnKeyCodePressed", function(s, key_code)
		if key_code == KEY_ENTER and IsValid(run_command) and run_command:IsEnabled() and run_command:IsMouseInputEnabled() and tab_body:IsVisible() then
			run_command:DoClick()
		end
	end)

	function category_list:item_selected(item)
		local arguments = sam.command.get_arguments()
		local command = item.command
		local command_arguments = command.args
		local input_arguments = {}

		for i = #childs, 3, -1 do
			local v = childs[i]
			if not v.no_change or not command:HasArg(v.no_change) then
				if v.no_remove ~= true then
					v:Remove()
				else
					v:Hide()
				end
			end
		end

		local NIL = {}
		for _, v in ipairs(command_arguments) do
			local func = arguments[v.name]["menu"]
			if not func then continue end

			local i = table.insert(input_arguments, NIL)
			local p = func(function(allow)
				if not IsValid(run_command) then return end
				input_arguments[i] = allow == nil and NIL or allow
				for i_2 = 1, #input_arguments do
					if input_arguments[i_2] == NIL then
						run_command:SetEnabled(false)
						return
					end
				end
				run_command:SetEnabled(true)
			end, body, buttons, v, childs)
			if p then
				p:AnimatedSetVisible(true)
			end
		end

		if #command_arguments == 0 then
			run_command:SetEnabled(true)
		end

		run_command:SetText(command.name)
		run_command:AnimatedSetVisible(true)
		run_command.input_arguments = input_arguments

		if command.help then
			help:SetText(command.help)
			help:AnimatedSetVisible(true)
			help:SizeToContents()
		else
			help:AnimatedSetVisible(false)
		end

		buttons:InvalidateLayout(true)
	end

	return tab_body
end, nil, 1)
--addons/sam/lua/sam/menu/tabs/config/server.lua:
if SAM_LOADED then return end

local sam = sam
local config = sam.config

config.add_tab("Server", function(parent)
	local server_body = parent:Add("SAM.ScrollPanel")
	server_body:Dock(FILL)
	server_body:LineMargin(0, 6, 0, 0)

	local i = 0
	server_body:GetCanvas():On("OnChildAdded", function(s, child)
		i = i + 1
		child:SetZPos(i)
	end)

	for k, v in ipairs(sam.config.get_menu_settings()) do
		local panel = v.func(server_body)
		if ispanel(panel) then
			local setting = server_body:Add("SAM.LabelPanel")
			setting:DockMargin(8, 6, 8, 0)
			setting:SetLabel(v.title)
			setting:SetPanel(panel)
		end

		server_body:Line()
	end

	return server_body
end, function()
	return LocalPlayer():HasPermission("manage_config")
end, 1)
--addons/sam/lua/sam/sh_motd.lua:
if SAM_LOADED then return end

local sam = sam
local config = sam.config
local command = sam.command

if CLIENT then
	config.add_menu_setting("MOTD URL (Leave empty for no MOTD)", function()
		local entry = vgui.Create("SAM.TextEntry")
		entry:SetPlaceholder("")
		entry:SetNoBar(true)
		entry:SetConfig("MOTDURL", "")

		return entry
	end)
end

local motd
local load_motd = function()
	local url = config.get("MOTDURL", "")
	if url == "" then
		command.remove_command("motd")
		hook.Remove("HUDPaint", "SAM.OpenMOTD")
		return
	end

	if IsValid(motd) then
		motd:Remove()
	end

	command.set_category("Menus")

	command.new("motd")
		:Help("Open MOTD menu")
		:OnExecute(function(ply)
			sam.netstream.Start(ply, "OpenMOTD")
		end)
	:End()

	if CLIENT then
		function sam.menu.open_motd()
			if IsValid(motd) then
				motd:Remove()
			end

			motd = vgui.Create("SAM.Frame")
			motd:Dock(FILL)
			motd:DockMargin(40, 40, 40, 40)
			motd:MakePopup()

			function motd.close.DoClick()
				motd:Remove()
			end

			local html = motd:Add("DHTML")
			html:Dock(FILL)
			html:OpenURL(url)
		end

		sam.netstream.Hook("OpenMOTD", function()
			sam.menu.open_motd()
		end)

		hook.Add("HUDPaint", "SAM.OpenMOTD", function()
			sam.menu.open_motd()
			hook.Remove("HUDPaint", "SAM.OpenMOTD")
		end)
	end
end
config.hook({"MOTDURL"}, load_motd)
--addons/sam/lua/sam/modules/utime.lua:
if SAM_LOADED then return end

local PLAYER = FindMetaTable("Player")

function PLAYER:GetUTime()
	return self:sam_get_nwvar("TotalUTime")
end

function PLAYER:SetUTime(time)
	self:sam_set_nwvar("TotalUTime", time)
end

function PLAYER:GetUTimeStart()
	return self:sam_get_nwvar("UTimeStart")
end

function PLAYER:SetUTimeStart(time)
	self:sam_set_nwvar("UTimeStart", time)
end

function PLAYER:GetUTimeSessionTime()
	return CurTime() - self:GetUTimeStart()
end

function PLAYER:GetUTimeTotalTime()
	return self:GetUTime() + CurTime() - self:GetUTimeStart()
end

if SERVER then
	hook.Add("SAM.AuthedPlayer", "SAM.UTime", function(ply)
		ply:SetUTime(ply:sam_get_play_time())
		ply:SetUTimeStart(CurTime())
	end)
end
--addons/sam/lua/sam/reports/cl_reports.lua:
if SAM_LOADED then return end

local sam = sam
local netstream = sam.netstream
local SUI = sam.SUI

local config = sam.config

local Trim = string.Trim

local muted_var = CreateClientConVar("sam_mute_reports", "0", false, false, "", 0, 1)

local position = config.get_updated("Reports.Position", "Left")
local max_reports = config.get_updated("Reports.MaxReports", 4)
local always_show = config.get_updated("Reports.AlwaysShow", true)
local pad_x = config.get_updated("Reports.XPadding", 5)
local pad_y = config.get_updated("Reports.YPadding", 5)

local duty_jobs = {}
config.hook({"Reports.DutyJobs"}, function()
	local jobs = config.get("Reports.DutyJobs", ""):Split(",")
	for i = #jobs, 1, -1 do
		local v = Trim(jobs[i])
		if v ~= "" then
			jobs[v] = true
		end
		jobs[i] = nil
	end
	duty_jobs = jobs
end)

local commands = {}
config.hook({"Reports.Commands"}, function()
	local cmds = config.get("Reports.Commands", ""):Split(",")
	for i = 1, #cmds do
		local v = Trim(cmds[i])
		if v ~= "" then
			cmds[i] = {
				name = v,
				func = function(_, ply)
					if IsValid(ply) then
						RunConsoleCommand("sam", v, "#" .. ply:EntIndex())
					end
				end
			}
		end
	end
	commands = cmds
end)

local reports = {}
local queued_reports = {}

local new_report, remove_report, check_queued, get_report, append_report

get_report = function(ply, index)
	for i = 1, #reports do
		local v = reports[i]
		local _ply = index and v.index or v.ply
		if _ply == ply then return v end
	end

	for i = 1, #queued_reports do
		local v = queued_reports[i]
		local _ply = index and v.index or v.ply
		if _ply == ply then return v, i end
	end
end

remove_report = function(ply)
	local report, delayed_i = get_report(ply)

	if delayed_i then
		return table.remove(queued_reports, delayed_i)
	end

	local panel = report.panel
	panel:MoveToNewX(position.value == "Right" and ScrW() or -panel:GetWide(), function()
		for i = report.pos + 1, #reports do
			local v = reports[i]
			v.pos = v.pos - 1
			v.panel:MoveToNewY(v.panel:GetY())
		end

		panel:Remove()
		table.remove(reports, report.pos)

		check_queued()
	end)
end

check_queued = function()
	while (max_reports.value - #reports > 0 and #queued_reports > 0) do
		new_report(table.remove(queued_reports, 1))
	end
end

append_report = function(ply, text)
	local report, delayed = get_report(ply)
	if delayed then
		table.insert(report.comments, text)
	else
		report.panel:AddComment(text)
	end
end

new_report = function(report)
	if #reports >= max_reports.value then
		return table.insert(queued_reports, report)
	end

	report.pos = table.insert(reports, report)

	local panel = vgui.Create("SAM.Report")
	panel:SetReport(report)

	for k, v in ipairs(commands) do
		panel:AddButton(v.name:gsub("^%l", string.upper), v.func)
	end

	local claim = panel:AddButton("Claim", function(self, ply)
		if panel:HasReport() then
			return LocalPlayer():sam_send_message("You have an active case, close it first.")
		end

		self.DoClick = function()
		end

		local claim_query = netstream.async.Start("ClaimReport", nil, ply)
		claim_query:done(function(claimed)
			if not IsValid(panel) then return end

			if claimed then
				panel:SetHasReport(ply)

				self:SetText("Close")

				self.background = Color(231, 76, 60, 200)
				self.hover = Color(255, 255, 255, 25)

				panel:FixWide()

				for k, v in ipairs(panel:GetChildren()[3]:GetChildren()) do
					v:SetDisabled(false)
					v:SetCursor("hand")
				end

				self.DoClick = function()
					panel:Close()
				end
			else
				panel:SetClaimed()
			end
		end)
	end)

	panel.claim = claim

	claim:SetCursor("hand")
	claim:SetDisabled(false)

	claim.background = Color(39, 174, 96, 200)
	claim.hover = Color(255, 255, 255, 25)

	panel:FixWide()

	local x = pad_x.value
	if position.value == "Right" then
		x = (ScrW() - panel:GetWide()) - x
	end

	panel:MoveToNewX(x)
	panel:MoveToNewY(panel:GetY())

	panel.new = true
	for k, v in ipairs(report.comments) do
		panel:AddComment(v)
	end
	panel.new = nil
end

netstream.Hook("Report", function(ply, comment)
	if not IsValid(ply) then return end

	if muted_var:GetBool() then return end

	local report = get_report(ply)
	if not report then
		report = {
			ply = ply,
			index = ply:EntIndex(),
			comments = {comment}
		}

		if not always_show.value and not duty_jobs[team.GetName(LocalPlayer():Team())] then
			LocalPlayer():sam_send_message("({S Blue}) {S_2 Red}: {S_3}", {
				S = "Report", S_2 = ply:Name(), S_3 = comment
			})
		else
			new_report(report)
		end
	else
		append_report(ply, comment)
	end
end)

netstream.Hook("ReportClaimed", function(ply)
	local report, delayed = get_report(ply)
	if not report then return end

	if delayed then
		table.remove(queued_reports, delayed)
	else
		report.panel:SetClaimed()
	end
end)

netstream.Hook("ReportClosed", function(index)
	local report, delayed = get_report(index, true)
	if not report then return end

	if delayed then
		table.remove(queued_reports, delayed)
	else
		report.panel:SetClosed()
	end
end)

do
	local REPORTS_HEADER = SUI.CreateFont("ReportHeader", "Roboto", 14, 540)
	local REPORT_COMMENT = SUI.CreateFont("ReportComment", "Roboto", 13, 540)
	local REPORT_BUTTONS = SUI.CreateFont("ReportButtons", "Roboto", 13, 550)

	local Panel = {}

	function Panel:Init()
		sui.TDLib.Start()

		self:Blur()
			:Background(Color(30, 30, 30, 240))

		local p_w, p_h = SUI.Scale(300), SUI.Scale(125)
		self:SetSize(p_w, p_h)

		local x = p_w * 2

		if position.value == "Right" then
			x = ScrW() + x
		else
			x = -x
		end

		self:SetPos(x, -p_h)

		local top_panel = self:Add("Panel")
		top_panel:Dock(TOP)
		top_panel:SetTall(SUI.Scale(24))
		top_panel:Background(Color(60, 60, 60, 200))

		local ply_name = top_panel:Add("DLabel")
		ply_name:Dock(LEFT)
		ply_name:DockMargin(5, 0, 0, 0)
		ply_name:SetTextColor(Color(200, 200, 200))
		ply_name:SetFont(REPORTS_HEADER)
		self.ply_name = ply_name

		local scroll = self:Add("SAM.ScrollPanel")
		scroll:Dock(FILL)
		scroll:DockMargin(5, 5, 5, 5)
		scroll.Paint = nil
		self.scroll = scroll

		local comment = scroll:Add("DLabel")
		comment:Dock(TOP)
		comment:SetText("")
		comment:SetTextColor(Color(200, 200, 200))
		comment:SetFont(REPORT_COMMENT)
		comment:SetMultiline(true)
		comment:SetWrap(true)
		comment:SetAutoStretchVertical(true)
		self.comment = comment

		local bottom = self:Add("Panel")
		bottom:Dock(BOTTOM)
		bottom:SetTall(SUI.Scale(24))
		self.bottom = bottom

		sui.TDLib.End()
	end

	function Panel:GetY()
		return (self:GetTall() + 5) * (self.report.pos - 1) + pad_y.value
	end

	function Panel:Close()
		remove_report(self.report.ply)
	end

	local change_state = function(self, text)
		self.claim:SetText(text)
		self.claim.DoClick = function() end

		self.claim:SUI_TDLib()
			:Background(Color(41, 128, 185, 200))

		timer.Simple(5, function()
			if IsValid(self) then
				self:Close()
			end
		end)

		if self:HasReport() == self.report.ply then
			self:SetHasReport()
		end

		self:FixWide()
	end

	function Panel:SetClaimed()
		change_state(self, "Case clamied!")
	end

	function Panel:SetClosed()
		change_state(self, "Case closed!")
	end

	function Panel:SetReport(report)
		surface.PlaySound("garrysmod/balloon_pop_cute.wav")

		report.panel = self

		self.report = report
		self.ply_name:SetText(report.ply:Name())
		self.ply_name:SetWide(self:GetWide())
	end

	local disabled = Color(60, 60, 60, 200)
	local click = Color(255, 255, 255, 30)
	local button_paint = function(self, w, h)
		draw.RoundedBox(0, 0, 0, w, h, self.background)

		if self:GetDisabled() then
			draw.RoundedBox(0, 0, 0, w, h, disabled)
		else
			if self:IsHovered() then
				draw.RoundedBox(0, 0, 0, w, h, self.hover)
			end

			if self.Depressed then
				draw.RoundedBox(0, 0, 0, w, h, click)
			end
		end
	end

	local button_click = function(self)
		self.cb(self, self.report.ply)
	end

	local background = Color(60, 60, 60, 200)
	local hover = Color(14, 134, 204, 100)
	function Panel:AddButton(text, cb)
		local button = self.bottom:Add("DButton")
		button:Dock(LEFT)
		button:SetText(text)
		button:SetTextColor(Color(200, 200, 200))
		button:SetFont(REPORT_BUTTONS)
		button:SetDisabled(true)
		button:SetCursor("arrow")

		button.Paint = button_paint
		button.DoClick = button_click

		button.background = background
		button.hover = hover

		button.cb = cb
		button.report = self.report

		return button
	end

	function Panel:FixWide()
		local wide = 0

		for _, v in ipairs(self.bottom:GetChildren()) do
			v:SizeToContents()
			v:SetWide(v:GetWide() + 6)
			wide = wide + v:GetWide()
		end

		self:SetWide(wide)

		return wide
	end

	function Panel:OnRemove()
		local reporter = self:HasReport()
		if reporter then
			netstream.Start("CloseReport", reporter)
			self:SetHasReport()
		end
	end

	function Panel:AddComment(text)
		local comment = self.comment

		local old_text = comment:GetText()
		if old_text ~= "" then
			old_text = old_text .. "\n"
		end

		if not self.new then
			surface.PlaySound("ambient/water/drip4.wav")
		end

		comment:SetText(old_text .. "- " .. text)
		comment:SizeToContents()

		self.scroll:ScrollToBottom()
	end

	function Panel:HasReport()
		return LocalPlayer().sam_has_report
	end

	function Panel:SetHasReport(v)
		LocalPlayer().sam_has_report = v
	end

	local new_animation = function(panel, name)
		local new_name = "anim_" .. name
		panel["MoveToNew" .. name:upper()] = function(self, new, cb)
			if self[new_name] then
				table.RemoveByValue(self.m_AnimList, self[new_name])
			end

			self[new_name] = self:NewAnimation(0.2, 0, -1, function()
				self[new_name] = nil
				if cb then cb() end
			end)

			self[new_name].Think = function(_, _, frac)
				self[name] = Lerp(frac, self[name], new)
			end
		end
	end

	new_animation(Panel, "x")
	new_animation(Panel, "y")

	vgui.Register("SAM.Report", Panel, "EditablePanel")
end
--addons/sui/lua/sui/vgui/sui_label.lua:
local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name
local MOUSE_LEFT = MOUSE_LEFT

local SysTime = SysTime

local PANEL = {}

AccessorFunc(PANEL, "m_colText", "TextColor")
AccessorFunc(PANEL, "m_colTextStyle", "TextStyleColor")
AccessorFunc(PANEL, "m_FontName", "Font")

AccessorFunc(PANEL, "m_bDoubleClicking", "DoubleClickingEnabled", FORCE_BOOL)
AccessorFunc(PANEL, "m_bAutoStretchVertical", "AutoStretchVertical", FORCE_BOOL)
AccessorFunc(PANEL, "m_bIsMenuComponent", "IsMenu", FORCE_BOOL)

AccessorFunc(PANEL, "m_bBackground", "PaintBackground",	FORCE_BOOL)
AccessorFunc(PANEL, "m_bBackground", "DrawBackground",	FORCE_BOOL)
AccessorFunc(PANEL, "m_bDisabled", "Disabled", FORCE_BOOL)

AccessorFunc(PANEL, "m_bIsToggle", "IsToggle", FORCE_BOOL)
AccessorFunc(PANEL, "m_bToggle", "Toggle", FORCE_BOOL)

AccessorFunc(PANEL, "m_bBright", "Bright", FORCE_BOOL)
AccessorFunc(PANEL, "m_bDark", "Dark", FORCE_BOOL)
AccessorFunc(PANEL, "m_bHighlight",	"Highlight", FORCE_BOOL)

PANEL:SetIsToggle(false)
PANEL:SetToggle(false)
PANEL:SetDisabled(false)
PANEL:SetDoubleClickingEnabled(true)

local Panel = FindMetaTable("Panel")
local SetMouseInputEnabled = Panel.SetMouseInputEnabled
local SetPaintBackgroundEnabled = Panel.SetPaintBackgroundEnabled
local SetPaintBorderEnabled = Panel.SetPaintBorderEnabled
local InvalidateLayout = Panel.InvalidateLayout
local SetFGColor = Panel.SetFGColor
function PANEL:Init()
	SetMouseInputEnabled(self, false)
	SetPaintBackgroundEnabled(self, false)
	SetPaintBorderEnabled(self, false)
end

function PANEL:AllowScale()
	SUI.OnScaleChanged(self, self.ScaleChanged)
end

function PANEL:ScaleChanged()
	self:SizeToContents()
end

function PANEL:SetFont(font)
	if self.m_FontName == font then return end

	self.m_FontName = font
	self:SetFontInternal(self.m_FontName)
end

function PANEL:SetTextColor(col)
	if self.m_colText == col then return end

	self.m_colText = col
	SetFGColor(self, col.r, col.g, col.b, col.a)
end
PANEL.SetColor = PANEL.SetTextColor

function PANEL:GetColor()
	return self.m_colText or self.m_colTextStyle
end

function PANEL:Toggle()
	if not self:GetIsToggle() then return end

	self:SetToggle(not self:GetToggle())
	self:OnToggled(self:GetToggle())
end

function PANEL:SetDisabled(bDisabled)
	self.m_bDisabled = bDisabled
	InvalidateLayout(self)
end

function PANEL:SetEnabled(bEnabled)
	self:SetDisabled(not bEnabled)
end

function PANEL:IsEnabled()
	return not self:GetDisabled()
end

function PANEL:ApplySchemeSettings()
	local col = self:GetColor()
	if not col then return end

	self:SetFGColor(col.r, col.g, col.b, col.a)
end

function PANEL:AutoStretchVerticalThink()
	self:SizeToContentsY()
end

function PANEL:SetAutoStretchVertical(enable)
	self.m_bAutoStretchVertical = enable
	self.Think = enable and self.AutoStretchVerticalThink or nil
end

function PANEL:OnCursorEntered()
	InvalidateLayout(self, true)
end

function PANEL:OnCursorExited()
	InvalidateLayout(self, true)
end

function PANEL:OnMousePressed(mousecode)
	if self:GetDisabled() then return end

	if mousecode == MOUSE_LEFT and not dragndrop.IsDragging() and self.m_bDoubleClicking then
		if self.LastClickTime and SysTime() - self.LastClickTime < 0.2 then

			self:DoDoubleClickInternal()
			self:DoDoubleClick()
			return
		end

		self.LastClickTime = SysTime()
	end

	if self:IsSelectable() and mousecode == MOUSE_LEFT and input.IsShiftDown() then
		return self:StartBoxSelection()
	end

	self:MouseCapture(true)
	self.Depressed = true
	self:OnDepressed()
	InvalidateLayout(self, true)

	self:DragMousePress(mousecode)
end

function PANEL:OnMouseReleased(mousecode)
	self:MouseCapture(false)

	if self:GetDisabled() then return end
	if not self.Depressed and dragndrop.m_DraggingMain ~= self then return end

	if self.Depressed then
		self.Depressed = nil
		self:OnReleased()
		InvalidateLayout(self, true)
	end

	if self:DragMouseRelease(mousecode) then return end

	if self:IsSelectable() and mousecode == MOUSE_LEFT then
		local canvas = self:GetSelectionCanvas()
		if canvas then
			canvas:UnselectAll()
		end
	end

	if not self.Hovered then return end

	self.Depressed = true

	if mousecode == MOUSE_RIGHT then
		self:DoRightClick()
	end

	if mousecode == MOUSE_LEFT then
		self:DoClickInternal()
		self:DoClick()
	end

	if mousecode == MOUSE_MIDDLE then
		self:DoMiddleClick()
	end

	self.Depressed = nil
end

function PANEL:OnReleased()
end

function PANEL:OnDepressed()
end

function PANEL:OnToggled(bool)
end

function PANEL:DoClick()
	self:Toggle()
end

function PANEL:DoRightClick()
end

function PANEL:DoMiddleClick()
end

function PANEL:DoClickInternal()
end

function PANEL:DoDoubleClick()
end

function PANEL:DoDoubleClickInternal()
end

sui.register("Label", PANEL, "Label")
--addons/sui/lua/sui/vgui/sui_label_panel.lua:
local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name

local LABEL_FONT = SUI.CreateFont("LabelPanel", "Roboto", 18)

local PANEL = {}

local add = function(s, c)
	if IsValid(s.pnl) then
		s.pnl:Remove()
	end

	local pnl = vgui.Create(c, s)
	s.pnl = pnl

	return pnl
end

function PANEL:Init()
	self.title = ""

	local label = self:Add(NAME .. ".Label")
	label:Dock(LEFT)
	self.label = label

	self:SetFont(LABEL_FONT)

	self:Dock(TOP)
	self:InvalidateLayout(true)
	self.Add = add
end

function PANEL:SetPanel(pnl)
	if IsValid(self.pnl) then
		self.pnl:Remove()
	end

	pnl:SetParent(self)
	self.pnl = pnl
end

function PANEL:SetLabel(lbl)
	self.title = lbl
	self:InvalidateLayout(true)
end

function PANEL:SetFont(font)
	self.font = font
	self.label:SetFont(font)
end

function PANEL:PerformLayout(w, h)
	local label = self.label
	local pnl = self.pnl

	local pnl_w, pnl_h = 0, 0
	if pnl then
		pnl_w, pnl_h = pnl:GetSize()
	end

	label:SetWide(w - pnl_w - 4)
	label:SetText(sui.wrap_text(self.title, self.font, w - pnl_w - 4))

	local _, _h = label:GetTextSize()
	self:SetTall(math.max(_h, pnl_h))

	if pnl then
		pnl:SetPos(w - pnl_w, h / 2 - pnl_h / 2)
	end
end

sui.register("LabelPanel", PANEL, "PANEL")
--addons/sui/lua/sui/vgui/sui_panel.lua:
local PANEL = {}

sui.scaling_functions(PANEL)

function PANEL:Init()
	self:ScaleInit()
end

sui.register("Panel", PANEL, "Panel")
--addons/sui/lua/sui/vgui/sui_scroll_panel.lua:
local math = math
local table = table

local pairs = pairs
local RealFrameTime = RealFrameTime

local TDLib = sui.TDLib
local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name
local RoundedBox = sui.TDLib.LibClasses.RoundedBox

local Panel = {}

AccessorFunc(Panel, "m_bFromBottom", "FromBottom", FORCE_BOOL)
AccessorFunc(Panel, "m_bVBarPadding", "VBarPadding", FORCE_NUMBER)

Panel:SetVBarPadding(0)

Panel.NoOverrideClear = true

-- VBar
local starting_scroll_speed = 3

local vbar_OnMouseWheeled = function(s, delta)
	s.scroll_speed = s.scroll_speed + (14 * RealFrameTime() --[[ slowly increase scroll speed ]])
	s:AddScroll(delta * -s.scroll_speed)
end

-- default set scroll clamps amount
local vbar_SetScroll = function(s, amount)
	if not s.Enabled then s.Scroll = 0 return end

	s.scroll_target = amount
	s:InvalidateLayout()
end

-- ¯\_(ツ)_/¯ https://github.com/Facepunch/garrysmod/blob/cd3d894288b847e3d081570129963d4089e36261/garrysmod/lua/vgui/dvscrollbar.lua#L234
local vbar_OnCursorMoved = function(s, _, y)
	if s.Dragging then
		y = y - s.HoldPos
		y = y / (s:GetTall() - s:GetWide() * 2 - s.btnGrip:GetTall())
		s.scroll_target = y * s.CanvasSize
	end
end

local vbar_Think = function(s)
	local frame_time = RealFrameTime() * 14
	local scroll_target = s.scroll_target

	s.Scroll = Lerp(frame_time, s.Scroll, scroll_target)

	if not s.Dragging then
		s.scroll_target = Lerp(frame_time, scroll_target, math.Clamp(scroll_target, 0, s.CanvasSize))
	end

	-- now start slowing it down!!!
	s.scroll_speed = Lerp(frame_time / 14, s.scroll_speed, starting_scroll_speed)
end

local vbar_Paint = function(s, w, h)
	TDLib.RoundedBox(s.vertices, 3, 0, 0, w, h, SUI.GetColor("scroll"))
end

local vbarGrip_Paint = function(s, w, h)
	TDLib.RoundedBox(s.vertices, 3, 0, 0, w, h, SUI.GetColor("scroll_grip"))
end

local vbar_PerformLayout = function(s, w, h)
	local scroll = s:GetScroll() / s.CanvasSize
	local bar_size = math.max(s:BarScale() * h, 10)

	local track = (h - bar_size) + 1
	scroll = scroll * track

	s.btnGrip.y = scroll
	s.btnGrip:SetSize(w, bar_size)
end
--

function Panel:Init()
	local canvas = self:GetCanvas()
	canvas:SUI_TDLib()

	local children = {}
	function canvas:OnChildAdded(child)
		table.insert(children, child)
	end
	function canvas:OnChildRemoved(child)
		for i = 1, #children do
			local v = children[i]
			if v == child then
				table.remove(children, i)
				return
			end
		end
	end
	canvas.GetChildren = function()
		return children
	end
	canvas.children = children

	local vbar = self.VBar
	vbar:SetHideButtons(true)
	vbar.btnUp:SetVisible(false)
	vbar.btnDown:SetVisible(false)

	vbar.vertices = {}
	vbar.scroll_target = 0
	vbar.scroll_speed = starting_scroll_speed

	vbar.OnMouseWheeled = vbar_OnMouseWheeled
	vbar.SetScroll = vbar_SetScroll
	vbar.OnCursorMoved = vbar_OnCursorMoved
	vbar.Think = vbar_Think
	vbar.Paint = vbar_Paint
	vbar.PerformLayout = vbar_PerformLayout

	vbar.btnGrip.vertices = {}
	vbar.btnGrip.Paint = vbarGrip_Paint

	self:ScaleChanged()
	SUI.OnScaleChanged(self, self.ScaleChanged)
end

function Panel:OnChildAdded(child)
	self:AddItem(child)
	self:ChildAdded(child)
end

function Panel:ChildAdded()
end

function Panel:ScaleChanged()
	local w = SUI.Scale(4)

	self.VBar:SetWide(w)
	self.VBar.btnDown:SetSize(w, 0)
	self.VBar.btnUp:SetSize(w, 0)
end

function Panel:Paint(w, h)
	local outline = SUI.GetColor("scroll_panel_outline")
	if outline then
		TDLib.DrawOutlinedBox(3, 0, 0, w, h, SUI.GetColor("scroll_panel"), outline, 1)
	else
		RoundedBox(self, "Background", 3, 0, 0, w, h, SUI.GetColor("scroll_panel"))
	end
end

function Panel:ScrollToBottom()
	local vbar = self.VBar
	for k, anim in pairs(vbar.m_AnimList or {}) do
		anim:Think(vbar, 1)
		vbar.m_AnimList[k] = nil
	end

	self:InvalidateParent(true)
	self:InvalidateChildren(true)

	vbar:SetScroll(vbar.CanvasSize)
end

function Panel:PerformLayoutInternal(w, h)
	w = w or self:GetWide()
	h = h or self:GetTall()

	local canvas = self.pnlCanvas

	self:Rebuild()

	local vbar = self.VBar
	vbar:SetUp(h, canvas:GetTall())

	if vbar.Enabled then
		w = w - vbar:GetWide() - self.m_bVBarPadding
	end

	canvas:SetWide(w)

	self:Rebuild()
end

function Panel:Think()
	local canvas = self.pnlCanvas

	local vbar = self.VBar
	if vbar.Enabled then
		canvas.y = -vbar.Scroll
	else
		if self:GetFromBottom() then
			canvas._y = Lerp(14 * RealFrameTime(), canvas._y or canvas.y, self:GetTall() - canvas:GetTall())
		else
			canvas._y = Lerp(14 * RealFrameTime(), canvas._y or canvas.y, -vbar.Scroll)
		end
		canvas.y = canvas._y
	end
end

sui.register("ScrollPanel", Panel, "DScrollPanel")
--addons/sui/lua/sui/vgui/sui_text_entry.lua:
local sui = sui

local surface = surface
local utf8 = sui.utf8
local draw = draw
local math = math

local IsValid = IsValid
local tostring = tostring
local tonumber = tonumber

local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name

local GetColor = SUI.GetColor
local TEXT_ENTRY_FONT = SUI.CreateFont("TextEntry", "Roboto Regular", 16)

local Panel = {}

sui.scaling_functions(Panel)

AccessorFunc(Panel, "m_FontName", "Font", FORCE_STRING)
AccessorFunc(Panel, "m_Editable", "Editable", FORCE_BOOL)
AccessorFunc(Panel, "m_Placeholder", "Placeholder", FORCE_STRING)
AccessorFunc(Panel, "m_MaxChars", "MaxChars", FORCE_NUMBER)
AccessorFunc(Panel, "m_Numeric", "Numeric", FORCE_BOOL)
AccessorFunc(Panel, "m_NoBar", "NoBar", FORCE_BOOL)
AccessorFunc(Panel, "m_BarColor", "BarColor")
AccessorFunc(Panel, "m_Background", "Background")
AccessorFunc(Panel, "m_Radius", "Radius")
AccessorFunc(Panel, "m_NoEnter", "NoEnter")

Panel:SetRadius(3)

function Panel:Init()
	self:ScaleInit()

	self:SetupTransition("TextEntryReady", 0.9, function()
		return self:IsEditing() or self:GetBarColor() ~= nil
	end)

	self:SetUpdateOnType(true)
	self:SetCursor("beam")
	self:SetFont(TEXT_ENTRY_FONT)
	self:SetPlaceholder("Placeholder text")

	self:SetSize(200, 22)

	self.allowed_numeric_characters = "1234567890.-"

	self.history = {}
	self.history_pos = 1
	self.can_use_history = true

	self:OnScaleChange()
end

function Panel:SetCaretPos(pos)
	DTextEntry.SetCaretPos(self, math.Clamp(pos, 0, utf8.len(self:GetText())))
end

function Panel:SetValue(value)
	self:SetText(value)
	self:OnValueChange(value)
end

function Panel:AllowInput(ch)
	if self:CheckNumeric(ch) then return true end

	if sui.wspace_chs[ch] or sui.cntrl_chs[ch] then
		return true
	end

	local max_chars = self:GetMaxChars()
	if max_chars and #self:GetText() >= max_chars then
		surface.PlaySound("resource/warning.wav")
		return true
	end
end

function Panel:AddValue(v, i, j)
	local original_text = self:GetText()

	local start
	if i then
		start = original_text:sub(1, i)
	else
		start = utf8.sub(original_text, 1, self:GetCaretPos())
	end

	local text = start .. v
	local caret_pos = utf8.len(text)

	local _end
	if j then
		_end = original_text:sub(j)
	else
		_end = utf8.sub(original_text, utf8.len(start) + 1)
	end
	text = text .. _end

	local max_chars = self:GetMaxChars()
	if max_chars then
		text = text:sub(1, max_chars)
	end

	self:SetValue(text)
	self:SetCaretPos(caret_pos)
end

function Panel:OnKeyCodeTyped(code)
	if self.no_down then
		self.no_down = nil
		return
	end

	if code == KEY_UP or code == KEY_DOWN then
		if not self:UpdateFromHistory(code) then
			return true
		end

		local lines, caret_line = self:GetNumLines()

		if lines == 1 then
			return true
		end

		--
		-- this fixes a weird issue
		-- make the text entry has at least 2 lines, go up then go down, you won't be able to go up again
		--
		if code == KEY_DOWN and lines == caret_line + 1 then
			self.no_down = true
			gui.InternalKeyCodeTyped(KEY_DOWN)
		end
	end

	self:OnKeyCode(code)

	if code == KEY_ENTER then
		if IsValid(self.Menu) then
			self.Menu:Remove()
		end

		if not self:GetNoEnter() then
			self:FocusNext()
			self:OnEnter()
		end
	end
end

function Panel:DisallowFloats(disallow)
	if not isbool(disallow) then
		disallow = true
	end

	if disallow then
		self.allowed_numeric_characters = self.allowed_numeric_characters:gsub("%.", "", 1)
	elseif not self.allowed_numeric_characters:find(".", 1, true) then
		self.allowed_numeric_characters = self.allowed_numeric_characters .. "."
	end
end

function Panel:DisallowNegative(disallow)
	if not isbool(disallow) then
		disallow = true
	end

	if disallow then
		self.allowed_numeric_characters = self.allowed_numeric_characters:gsub("%-", "", 1)
	elseif not self.allowed_numeric_characters:find("-", 1, true) then
		self.allowed_numeric_characters = self.allowed_numeric_characters .. "-"
	end
end

function Panel:CheckNumeric(value)
	if not self:GetNumeric() then return false end

	if not self.allowed_numeric_characters:find(value, 1, true) then
		return true
	end

	local new_value = ""
	local current_value = tostring(self:GetText())

	local caret_pos = self:GetCaretPos()
	for i = 0, #current_value do
		new_value = new_value .. current_value:sub(i, i)
		if i == caret_pos then
			new_value = new_value .. value
		end
	end

	if #current_value ~= 0 and not tonumber(new_value) then
		return true
	end

	return false
end

function Panel:AddHistory(txt)
	if not txt or txt == "" then return end
	local history = self.history
	if history[#history] ~= txt then
		table.insert(history, txt)
	end
end

function Panel:UpdateFromHistory(code)
	if not self.can_use_history then return end

	local lines, caret_line = self:GetNumLines()

	if code == KEY_UP then
		if caret_line > 1 then return true end -- enable the caret to move up and down

		if self.history_pos <= 1 then return end

		self.history_pos = self.history_pos - 1
	elseif code == KEY_DOWN then
		if caret_line ~= lines then return true end

		if self.history_pos >= #self.history then
			self:SetValue("")
			self:SetCaretPos(0)
			self.history_pos = #self.history + 1
			return
		end

		self.history_pos = self.history_pos + 1
	end

	local text = self.history[self.history_pos]
	if not text then return end

	self:SetValue(text)
	self:SetCaretPos(utf8.len(text))
end

function Panel:OnTextChanged()
	self.history_pos = #self.history + 1

	local text = self:GetText()

	self.can_use_history = text == "" and true or false

	if self:GetUpdateOnType() then
		self:UpdateConvarValue()
		self:OnValueChange(text)
	end

	self:OnChange()
end

function Panel:OnScaleChange()
	self:InvalidateLayout()
	self:InvalidateLayout(true)
end

function Panel:Paint(w, h)
	self:RoundedBox("Background", self:GetRadius(), 0, 0, w, h, GetColor("text_entry_bg") or self:GetBackground())

	local text_entry_3 = GetColor("text_entry_3")

	if self:GetText() == "" then
		local old_text = self:GetText()
		self:SetText(self:GetPlaceholder())
		self:DrawTextEntryText(GetColor("text_entry_2"), text_entry_3, text_entry_3)
		self:SetText(old_text)
	else
		self:DrawTextEntryText(GetColor("text_entry"), text_entry_3, text_entry_3)
	end

	if not self:GetNoBar() then
		local bar_color = self:GetBarColor()

		self:RoundedBox("Bar1", 0, 0, h - 1, w, 1, GetColor("text_entry_bar_color"))

		local bar = math.Round(w * self.TextEntryReady)
		if bar > 0 then
			self:RoundedBox("Bar2", 0, (w / 2) - (bar / 2), h - 1, bar, 1, bar_color or text_entry_3)
		end
	end
end

-- https://github.com/ValveSoftware/source-sdk-2013/blob/0d8dceea4310fde5706b3ce1c70609d72a38efdf/mp/src/vgui2/vgui_controls/TextEntry.cpp#L969
function Panel:GetNumLines(wide)
	local num_lines = 1

	wide = wide or self:GetWide() - 2

	local vbar = self:GetChildren()[1]
	if vbar then
		wide = wide - vbar:GetWide()
	end

	local char_width
	local x = 3

	local word_start_index = 1
	local word_start_len
	local word_length = 0
	local has_word = false
	local just_started_new_line = true
	local word_started_on_new_line = true

	local start_char = 1

	surface.SetFont(self:GetFont())

	local i = start_char
	local text, n = utf8.force(self:GetText())
	local caret_line = 0
	local caret_pos = self:GetCaretPos()
	local caret_i = 1
	while i <= n do
		local ch_len = utf8.char_bytes(text:byte(i))
		local ch = text:sub(i, i + ch_len - 1)

		if ch ~= " " then
			if not has_word then
				word_start_index = i
				word_start_len = ch_len
				has_word = true
				word_started_on_new_line = just_started_new_line
				word_length = 0
			end
		else
			has_word = false
		end

		char_width = surface.GetTextSize(ch)
		just_started_new_line = false

		if (x + char_width) >= wide then
			x = 3

			just_started_new_line = true
			has_word = false

			if word_started_on_new_line then
				num_lines = num_lines + 1
			else
				num_lines = num_lines + 1
				i = (word_start_index + word_start_len) - ch_len
			end

			word_length = 0
		end

		x = x + char_width
		word_length = word_length + char_width

		if caret_i == caret_pos then
			caret_line = num_lines
		end

		i = i + ch_len
		caret_i = caret_i + 1
	end

	return num_lines, caret_line
end

function Panel:SetCheck(func, col)
	function self:OnValueChange(text)
		if func(text) == false then
			self.valid = false
			self:SetBarColor(GetColor("close_hover"))
			self:SetNoEnter(true)
		else
			self.valid = true
			self:SetBarColor(col)
			self:SetNoEnter(false)
		end
	end
	self:SetValue(self:GetText())
end

sui.register("TextEntry", Panel, "DTextEntry")
--addons/scb_chatbox/lua/scb/settings/tabs/client.lua:
if SCB_LOADED then return end

local vgui = vgui

local ipairs = ipairs

local scb = scb
local SUI = scb.SUI
local language = scb.language

local toggle_convars = {
	{
		title = "show_time",
		convar = "scb_show_timestamps",
	},
	{
		title = "disable_rainbow",
		convar = "scb_disable_rainbow_colors",
		value = "0"
	},
	{
		title = "disable_flashing",
		convar = "scb_disable_flashing_texts",
		value = "0"
	},
	{
		title = "blur_theme",
		convar = "scb_blur_theme",
		value = SUI.current_theme == "Blur" and "1" or "0",
		on_change = function(value)
			SUI.SetTheme(value == "1" and "Blur" or "Dark")
		end
	},
	{
		title = "join_messages",
		convar = "scb_joindisconnect_message",
		value = "1"
	},
	{
		"number",
		title = "scale",
		convar = "scb_scale",
		value = "5",
		min = 1,
		max = 9,
		load = function(slider, convar)
			slider:GetParent():SetWide(110)

			slider:SetDecimals(0)
			slider:SetMinMax(1, 9)
			slider.Knob:SUI_TDLib()

			local on_mouse_released = function()
				convar:SetInt(slider:GetValue())
			end
			slider:On("OnMouseReleased", on_mouse_released)
			slider.Knob:On("OnMouseReleased", on_mouse_released)

			slider:SetValue(scb.to_new_range(SUI.GetScale(), 0.5, 1.5, 1, 9))
		end,
		on_change = function(value)
			SUI.SetScale(scb.to_new_range(value, 1, 9, 0.5, 1.5))
		end
	},
	{
		"number",
		title = "messages_fade",
		convar = "scb_message_fade_out_time",
		value = "6",
		min = 0,
		max = 60,
		load = function(slider, convar)
			slider:GetParent():SetWide(160)

			slider:SetDecimals(0)
			slider:SetMinMax(0, 60)
			slider.Knob:SUI_TDLib()

			local on_mouse_released = function()
				convar:SetFloat(slider:GetValue())
			end
			slider:On("OnMouseReleased", on_mouse_released)
			slider.Knob:On("OnMouseReleased", on_mouse_released)

			slider:SetValue(convar:GetFloat())
		end
	},
	{
		"number",
		title = "max_messages",
		convar = "scb_max_messages",
		value = "200",
		min = 100,
		max = 400,
		load = function(slider, convar)
			slider:GetParent():SetWide(160)

			slider:SetDecimals(0)
			slider:SetMinMax(100, 400)
			slider.Knob:SUI_TDLib()

			local on_mouse_released = function()
				convar:SetInt(slider:GetValue())
			end
			slider:On("OnMouseReleased", on_mouse_released)
			slider.Knob:On("OnMouseReleased", on_mouse_released)

			slider:SetValue(convar:GetInt())
		end
	}
}

if scb.config.enable_avatars then
	table.insert(toggle_convars, 1, {
		title = "show_avatars",
		convar = "scb_show_avatars",
	})
end

if not scb.config.enable_custom_join_messages and not scb.config.enable_custom_leave_messages then
	for k, v in ipairs(toggle_convars) do
		if v.convar == "scb_joindisconnect_message" then
			table.remove(toggle_convars, k)
			break
		end
	end
end

for _, v in ipairs(toggle_convars) do
	local convar = CreateClientConVar(v.convar, v.value or "1", true, false, "", v.min or 0, v.max or 1)

	if v.on_change then
		v.on_change(convar:GetString())
		cvars.AddChangeCallback(v.convar, function(_, _, value_new)
			v.on_change(value_new, v.panel)
		end)
	end
end

return {
	title = language.client_title,
	pos = 1,
	check = false,
	func = function(parent)
		local body = parent:Add("SCB.ScrollPanel")
		body:Dock(FILL)
		body:DockMargin(0, 1, 0, 0)

		local add_setting = function(title, pnl)
			local setting = body:Add("SCB.LabelPanel")
			setting:DockMargin(4, 4, 4, 0)
			setting:SetLabel(title)
			setting:SetPanel(pnl)
			return setting
		end

		for _, v in ipairs(toggle_convars) do
			local panel
			if v[1] == "number" then
				panel = vgui.Create("SCB.NumberSlider")

				v.panel = panel.slider
				v.load(panel.slider, v.convar and GetConVar(v.convar))
			else
				panel = vgui.Create("SCB.ToggleButton")
				panel:SetConVar(v.convar)
			end

			add_setting(language[v.title], panel)
		end

		local reset_size = vgui.Create("SCB.Button")
		reset_size:SetText("Reset")
		reset_size:SetSize(70, 24)
		reset_size:On("DoClick", function()
			scb.chatbox:SetSize(480, 220)
		end)
		add_setting(language.reset_size, reset_size)

		local reset_position = vgui.Create("SCB.Button")
		reset_position:SetText("Reset")
		reset_position:SetSize(70, 24)
		reset_position:On("DoClick", function()
			scb.chatbox:SetPos(sui.scale(18), ScrH() - scb.chatbox:GetTall() - sui.scale(170))
			scb.chatbox:OnPosChanged()
		end)
		add_setting(language.reset_position, reset_position)

		local clear_cache = vgui.Create("SCB.Button")
		clear_cache:SetText("Clear")
		clear_cache:SetSize(70, 24)

		clear_cache:On("DoClick", function()
			SUI.ClearImages()
		end)

		add_setting(language.clear_reload, clear_cache)

		return body
	end
}

--lua/autorun/serv_statuseffects.lua:
if SERVER then AddCSLuaFile() end

GMSERV = {}
GMSERV.StatusEffects = {
	["heal"] = {
		["string"] = "Healing",
		["function"] =
			function(target, dealer, effect, duration, amount)
				local mult
				if target == dealer then
					mult = 0.25
				else
					mult = 1
				end
				local hpam = amount*mult
				local hpdur = duration
				local hptick = (amount/duration)*mult

				local HealAmount
				for i = 1, hpdur*hptick do
					timer.Simple(i/hptick, function()
						if !target:IsValid() then return end
						local futureheal = ( hpam/hpdur )/hptick

						if (target:GetMaxHealth()*2) - target:Health() >= futureheal then
							HealAmount = futureheal
						else
							HealAmount = ((target:GetMaxHealth()*2) - target:Health())
						end

						target:SetHealth( target:Health() + HealAmount )
					end)
				end

				if effect then
					local ED_Heal = EffectData()
					ED_Heal:SetOrigin( target:GetPos() )
					ED_Heal:SetEntity( target )
					ED_Heal:SetMagnitude( hpam )
					ED_Heal:SetScale( hpdur )
					util.Effect("serv_passive_heal", ED_Heal, true, true)
				end
			end
		},
	["stun"] = {
		["string"] = "Stun",
		["function"] =
			function(target, dealer, effect, duration)
				local function RemoveFrozen(target)
					if target:IsValid() then
						target.SERVStatFrozen = false

						if target:IsPlayer() then
							target:ScreenFade( SCREENFADE.IN, Color( 0, 0, 0, 0 ), 0.4, 0.2 )
							target:Freeze( false )
						elseif target:IsNPC() then
							target:SetCondition( 68 )
							if target:Health() < 1 then
								target:SetNPCState(7)
							end
						end
					end
				end

				if ((target:IsPlayer() and target ~= dealer) or target:IsNPC()) then
					if target.SERVStatFrozen then
						if target:Health() < 1 then
							RemoveFrozen(target)
						end
					else
						target.SERVStatFrozen = true

						if target:IsPlayer() then
							target:ScreenFade( SCREENFADE.OUT, Color( 0, 200, 255, 0 ), 0.2, 2.5 )
							target:Freeze( true ) 
						elseif target:IsNPC() then
							target:SetSchedule( SCHED_NPC_FREEZE )
							target:StopMoving()
						end

						timer.Simple( duration, function()
							RemoveFrozen(target)
						end )
					end

					if effect then
						local ED_Stun = EffectData()
						ED_Stun:SetOrigin( target:GetPos() )
						ED_Stun:SetEntity( target )
						ED_Stun:SetScale( duration )
						util.Effect("SERV_passive_stun", ED_Stun, true, true)
					end
				end
			end
		},
	["poison"] = {
		["string"] = "Poison",
		["function"] =
			function(target, dealer, effect, duration, damage)
				if !(target:IsPlayer() or target:IsNPC()) then return false end
				local tick = damage/duration
				if target:IsPlayer() then
					local playerdead = false
				end
				for i = 1, duration do
					timer.Simple(i-1, function()
						if target:IsPlayer() then
							if !target:Alive() then 
								playerdead = true
							end
							if playerdead then return end
						end
						if !target:IsValid() then return end
						local futdmg = ( damage/duration )
						target:TakeDamage(futdmg, dealer, dealer)
					end)
				end

				if effect then
					local ED_Poison = EffectData()
					ED_Poison:SetOrigin( target:GetPos() )
					ED_Poison:SetEntity( target )
					ED_Poison:SetMagnitude( damage )
					ED_Poison:SetScale( duration )
					util.Effect("SERV_passive_poison", ED_Poison, true, true)
				end

			end
		},
}

function GMSERV:AddStatus(target, dealer, type, a, b, c)
	if target:IsPlayer() or target:IsNPC() then
		GMSERV.StatusEffects[type]["function"](target, dealer, c, a, b)
	end
end
--addons/fusioncutter/lua/fusioncutter/sh_config.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--           Fusion Cutter           --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--     Fusion Cutter | SH Config     --
---------------------------------------

Fusioncutter.Distance = 200

Fusioncutter.Modes = {
	["vehicleMode"] = {
		displayName = "Fahrzeug-Modus",
		description = "Mit Linksklick kannst du ein Fahrzeug reparieren. Mit Rechtsklick beschädigst du es und mit Nachladen füllst du dessen Munition auf.",
		canUse = function(self, vehicle)
			if not vehicle.LVS then return false end

			return true
		end,

		PrimaryAttack = function(self, vehicle)
			if self.SabotageOnly then return false end

			if vehicle:GetHP() >= vehicle.MaxHealth then return false end

			vehicle:SetHP(math.min(vehicle:GetHP() + 1000, vehicle.MaxHealth))

			return true
		end,

		SecondaryAttack = function(self, vehicle)
			if vehicle:GetHP() <= 1 then return false end

			vehicle:SetHP(math.max(vehicle:GetHP() - 500, 1))

			return true
		end,

		Reload = function(self, vehicle)
			if self.SabotageOnly then return false end

			if vehicle:WeaponRestoreAmmo() then
				vehicle:EmitSound("items/ammo_pickup.wav")
			end

			return true
		end
	},

	["vehicleModeLight"] = {
		displayName = "Fahrzeug-Modus",
		description = "Mit Linksklick kannst du ein Fahrzeug reparieren.",
		canUse = function(self, vehicle)
			if not vehicle.LVS then return false end

			return true
		end,

		PrimaryAttack = function(self, vehicle)
			if vehicle:GetHP() >= vehicle.MaxHealth * 0.6 then return false end

			vehicle:SetHP(math.min(vehicle:GetHP() + 1000, vehicle.MaxHealth * 0.6))

			return true
		end,

		SecondaryAttack = function(self, vehicle)
			return false
		end,

		Reload = function(self, vehicle)
			return false
		end
	},

	["systemEnt"] = {
		displayName = "Basis-Systeme",
		description = "Mit Linksklick reparierst du ein System-Entity. Mit Rechtsklick beschädigst es.",
		canUse = function(self, ent)
			if ent.IsSystem then return true end

			return false
		end,

		PrimaryAttack = function(self, ent)
			if self.SabotageOnly then return false end

			local hp = math.min(ent:Health() + 100, 2000)
			if hp ~= ent:Health() then
				ent:SetHealth(hp)
				ent:SetPlayerRepairing(true)
				return true
			else
				return false
			end
		end,

		SecondaryAttack = function(self, ent)
			local hp = math.max(ent:Health() - 100, 10)
			if hp ~= ent:Health() then
				ent:SetHealth(hp)
				return true
			else
				return false
			end
		end,

		Reload = function(self, vehicle)
			return false
		end
	},

	["emplacement"] = {
		displayName = "Geschütze",
		description = "Mit Linksklick reparierst du ein Geschütz. Mit Rechtsklick beschädigst es.",
		canUse = function(self, ent)
			if ent.IsTurret then return true end

			return false
		end,

		PrimaryAttack = function(self, ent)
			if self.SabotageOnly then return false end

			local hp = math.min(ent:Health() + 10, ent:GetMaxHealth())
			if hp ~= ent:Health() then
				ent:SetHealth(hp)
				return true
			else
				return false
			end
		end,

		SecondaryAttack = function(self, ent)
			local hp = math.max(ent:Health() - 10, 100)
			if hp ~= ent:Health() then
				ent:SetHealth(hp)
				return true
			else
				return false
			end
		end,

		Reload = function(self, vehicle)
			return false
		end
	},

	["mines"] = {
		displayName = "Entschärfungskit",
		description = "Mit Linksklick entschärfst du eine Mine.",
		canUse = function(self, ent)
			if ent.IsMine then return true end

			return false
		end,

		PrimaryAttack = function(self, ent)
			ent:TakeDamage(10)
			return true
		end,

		SecondaryAttack = function(self, ent)
			ent:TakeDamage(10)
			return true
		end,

		Reload = function(self, vehicle)
			return false
		end
	},

	["repairkit"] = {
		displayName = "Plastoid",
		description = "Mit Linksklick kannst du die Rüstung eines Spielers aufwerten.",
		canUse = function(self, ent)
			return true
		end,

		PrimaryAttack = function(self, ent)
			if ent:IsPlayer() and ent:Alive() then
				local giveArmor = self:GiveArmor(ent)

				return giveArmor
			end

			return false
		end,

		SecondaryAttack = function(self, ent)
			return false
		end,

		Reload = function(self, vehicle)
			return false
		end
	},
}
--addons/map_control/lua/autorun/sh_index_mapcontrol.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--            Mapcontrol             --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--      Mapcontrol | SH Index        --
---------------------------------------

Mapcontrol = Mapcontrol || {}

if SERVER then
	AddCSLuaFile("map_control/sh_config.lua")

	include("map_control/sh_config.lua")
end

if CLIENT then
	include("map_control/sh_config.lua")
end


--addons/starwars_universe/lua/autorun/sh_swu_loader.lua:
SWU = SWU or {}

local function LoadFile(file, dir)
    local filePath = dir .. "/" .. file
    if (file:StartWith("sh_")) then
        if (SERVER) then
            AddCSLuaFile(filePath)
        end
        include(filePath)
    elseif (file:StartWith("cl_")) then
        if (SERVER) then
            AddCSLuaFile(filePath)
        else
            include(filePath)
        end
    elseif (file:StartWith("sv_")) then
        if (SERVER) then
            include(filePath)
        end
    end
end

local function LoadFolder(dir)
    local f, d = file.Find(dir .. "/*", "LUA")

    for i, v in pairs(f) do
        LoadFile(v, dir)
    end

    for i, v in pairs(d) do
        LoadFolder(dir .. "/" .. v)
    end
end

LoadFolder("star-wars-universe")

hook.Run("SWU.Loaded")
--addons/starwars_universe/lua/libs/advanceddraw.lua:
--    Advanced Draw:
--    - IMGUI Source Code: https://github.com/wyozi-gmod/imgui
--    - Draw Precache Arc
--    - Draw Line with thickness

local adraw = {}

adraw.skin = {
    background = Color(0, 0, 0, 0),
    backgroundHover = Color(0, 0, 0, 0),
    border = Color(255, 255, 255),
    borderHover = Color(255, 127, 0),
    borderPress = Color(255, 80, 0),
    foreground = Color(255, 255, 255),
    foregroundHover = Color(255, 127, 0),
    foregroundPress = Color(255, 80, 0),
}

local devCvar = GetConVar("developer")

function adraw.IsDeveloperMode()
    return not adraw.DisableDeveloperMode and devCvar:GetInt() > 0
end

local _devMode = false -- cached local variable updated once in a while

function adraw.Hook(name, id, callback)
    local hookUniqifier = debug.getinfo(4).short_src
    hook.Add(name, "adraw / " .. id .. " / " .. hookUniqifier, callback)
end

local local_player
local gState = {}

local function shouldAcceptInput()
    -- don't process input during non-main renderpass
    if render.GetRenderTarget() ~= nil then return false end
    -- don't process input if we're doing VGUI stuff (and not in context menu)
    if vgui.CursorVisible() and vgui.GetHoveredPanel() ~= g_ContextMenu then return false end

    return true
end

adraw.Hook("PreRender", "adraw / Input", function()
    -- calculate mouse state
    if shouldAcceptInput() then
        local useBind = input.LookupBinding("+use", true)
        local attackBind = input.LookupBinding("+attack", true)
        local USE = useBind and input.GetKeyCode(useBind)
        local ATTACK = attackBind and input.GetKeyCode(attackBind)
        local wasPressing = gState.pressing
        gState.pressing = (USE and input.IsButtonDown(USE)) or (ATTACK and input.IsButtonDown(ATTACK))
        gState.pressed = not wasPressing and gState.pressing
    end
end)

hook.Add("NotifyShouldTransmit", "adraw / ClearRenderBounds", function(ent, shouldTransmit)
    if not shouldTransmit then return end
    local tb = ent:GetTable()
    if not tb._adrawRBExpansion then return end
    tb._adrawRBExpansion = nil
end)

local traceResultTable = {}

local traceQueryTable = {
    output = traceResultTable,
    filter = {}
}

local function isObstructed(eyePos, hitPos, ignoredEntity)
    local q = traceQueryTable
    q.start = eyePos
    q.endpos = hitPos
    q.filter[1] = local_player
    q.filter[2] = ignoredEntity
    local tr = util.TraceLine(q)

    if tr.Hit then
        return true, tr.Entity
    else
        return false
    end
end

function adraw.Start3D2D(pos, angles, scale, distanceHide, distanceFadeStart)
    local_player = local_player or LocalPlayer()

    if gState.shutdown == true then return end

    if gState.rendering == true then
        print("[AdvancedDraw] Starting a new adraw context when previous one is still rendering" .. "Shutting down rendering pipeline to prevent crashes..")
        gState.shutdown = true

        return false
    end

    _devMode = adraw.IsDeveloperMode()
    local eyePos = local_player:EyePos()
    local eyePosToPos = pos - eyePos

    -- OPTIMIZATION: Test that we are in front of the UI
    do
        local normal = angles:Up()
        local dot = eyePosToPos:Dot(normal)

        if _devMode then
            gState._devDot = dot
        end

        -- since normal is pointing away from surface towards viewer, dot<0 is visible
        if dot >= 0 then return false end
    end

    -- OPTIMIZATION: Distance based fade/hide
    if distanceHide then
        local distance = eyePosToPos:Length()
        if distance > distanceHide then return false end

        if _devMode then
            gState._devDist = distance
            gState._devHideDist = distanceHide
        end

        if distanceHide and distanceFadeStart and distance > distanceFadeStart then
            local blend = math.min(math.Remap(distance, distanceFadeStart, distanceHide, 1, 0), 1)
            render.SetBlend(blend)
            surface.SetAlphaMultiplier(blend)
        end
    end

    gState.rendering = true
    gState.pos = pos
    gState.angles = angles
    gState.scale = scale
    cam.Start3D2D(pos, angles, scale)

    -- calculate mousepos
    if not vgui.CursorVisible() or vgui.IsHoveringWorld() then
        local tr = local_player:GetEyeTrace()
        local eyepos = tr.StartPos
        local eyenormal

        if vgui.CursorVisible() and vgui.IsHoveringWorld() then
            eyenormal = gui.ScreenToVector(gui.MousePos())
        else
            eyenormal = tr.Normal
        end

        local planeNormal = angles:Up()
        local hitPos = util.IntersectRayWithPlane(eyepos, eyenormal, pos, planeNormal)

        if hitPos then
            local obstructed, obstructer = isObstructed(eyepos, hitPos, gState.entity)

            if obstructed then
                gState.mx = nil
                gState.my = nil

                if _devMode then
                    gState._devInputBlocker = "collision " .. obstructer:GetClass() .. "/" .. obstructer:EntIndex()
                end
            else
                local diff = pos - hitPos
                -- This cool code is from Willox's keypad CalculateCursorPos
                local x = diff:Dot(-angles:Forward()) / scale
                local y = diff:Dot(-angles:Right()) / scale
                gState.mx = x
                gState.my = y
            end
        else
            gState.mx = nil
            gState.my = nil

            if _devMode then
                gState._devInputBlocker = "not looking at plane"
            end
        end
    else
        gState.mx = nil
        gState.my = nil

        if _devMode then
            gState._devInputBlocker = "not hovering world"
        end
    end

    if _devMode then
        gState._renderStarted = SysTime()
    end

    return true
end

function adraw.Entity3D2D(ent, lpos, lang, scale, ...)
    gState.entity = ent
    local ret = adraw.Start3D2D(ent:LocalToWorld(lpos), ent:LocalToWorldAngles(lang), scale, ...)

    if not ret then
        gState.entity = nil
    end

    return ret
end

local function calculateRenderBounds(x, y, w, h)
    local pos = gState.pos
    local fwd, right = gState.angles:Forward(), gState.angles:Right()
    local scale = gState.scale
    local firstCorner, secondCorner = pos + fwd * x * scale + right * y * scale, pos + fwd * (x + w) * scale + right * (y + h) * scale
    local minrb, maxrb = Vector(math.huge, math.huge, math.huge), Vector(-math.huge, -math.huge, -math.huge)
    minrb.x = math.min(minrb.x, firstCorner.x, secondCorner.x)
    minrb.y = math.min(minrb.y, firstCorner.y, secondCorner.y)
    minrb.z = math.min(minrb.z, firstCorner.z, secondCorner.z)
    maxrb.x = math.max(maxrb.x, firstCorner.x, secondCorner.x)
    maxrb.y = math.max(maxrb.y, firstCorner.y, secondCorner.y)
    maxrb.z = math.max(maxrb.z, firstCorner.z, secondCorner.z)

    return minrb, maxrb
end

function adraw.ExpandRenderBoundsFromRect(x, y, w, h)
    local ent = gState.entity

    if IsValid(ent) then
        local tb = ent:GetTable()
        -- make sure we're not applying same expansion twice
        local expansion = tb._adrawRBExpansion

        if expansion then
            local ex, ey, ew, eh = unpack(expansion)
            if ex == x and ey == y and ew == w and eh == h then return end
        end

        local minrb, maxrb = calculateRenderBounds(x, y, w, h)
        ent:SetRenderBoundsWS(minrb, maxrb)

        if _devMode then
            print("[adraw] Updated renderbounds of ", ent, " to ", minrb, "x", maxrb)
        end

        tb._adrawRBExpansion = {x, y, w, h}
    else
        if _devMode then
            print("[adraw] Attempted to update renderbounds when entity is not valid!! ", debug.traceback())
        end
    end
end

local devOffset = Vector(0, 0, 30)

local devColours = {
    background = Color(0, 0, 0, 200),
    title = Color(78, 205, 196),
    mouseHovered = Color(0, 255, 0),
    mouseUnhovered = Color(255, 0, 0),
    pos = Color(255, 255, 255),
    distance = Color(200, 200, 200, 200),
    ang = Color(255, 255, 255),
    dot = Color(200, 200, 200, 200),
    angleToEye = Color(200, 200, 200, 200),
    renderTime = Color(255, 255, 255),
    renderBounds = Color(0, 0, 255)
}

local function developerText(str, x, y, clr)
    draw.SimpleText(str, "DefaultFixedDropShadow", x, y, clr, TEXT_ALIGN_CENTER, nil)
end

local function drawDeveloperInfo()
    local camAng = local_player:EyeAngles()
    camAng:RotateAroundAxis(camAng:Right(), 90)
    camAng:RotateAroundAxis(camAng:Up(), -90)
    cam.IgnoreZ(true)
    cam.Start3D2D(gState.pos + devOffset, camAng, 0.15)
        local bgCol = devColours["background"]
        surface.SetDrawColor(bgCol.r, bgCol.g, bgCol.b, bgCol.a)
        surface.DrawRect(-100, 0, 200, 140)
        local titleCol = devColours["title"]
        developerText("adraw developer", 0, 5, titleCol)
        surface.SetDrawColor(titleCol.r, titleCol.g, titleCol.b)
        surface.DrawLine(-50, 16, 50, 16)
        local mx, my = gState.mx, gState.my
    
        if mx and my then
            developerText(string.format("mouse: hovering %d x %d", mx, my), 0, 20, devColours["mouseHovered"])
        else
            developerText(string.format("mouse: %s", gState._devInputBlocker or ""), 0, 20, devColours["mouseUnhovered"])
        end
    
        local pos = gState.pos
        developerText(string.format("pos: %.2f %.2f %.2f", pos.x, pos.y, pos.z), 0, 40, devColours["pos"])
        developerText(string.format("distance %.2f / %.2f", gState._devDist or 0, gState._devHideDist or 0), 0, 53, devColours["distance"])
        local ang = gState.angles
        developerText(string.format("ang: %.2f %.2f %.2f", ang.p, ang.y, ang.r), 0, 75, devColours["ang"])
        developerText(string.format("dot %d", gState._devDot or 0), 0, 88, devColours["dot"])
        local angToEye = (pos - local_player:EyePos()):Angle()
        angToEye:RotateAroundAxis(ang:Up(), -90)
        angToEye:RotateAroundAxis(ang:Right(), 90)
        developerText(string.format("angle to eye (%d,%d,%d)", angToEye.p, angToEye.y, angToEye.r), 0, 100, devColours["angleToEye"])
        developerText(string.format("rendertime avg: %.2fms", (gState._devBenchAveraged or 0) * 1000), 0, 120, devColours["renderTime"])
    cam.End3D2D()
    cam.IgnoreZ(false)
    local ent = gState.entity

    if not IsValid(ent) then return end
    local tb = ent:GetTable()
    if not tb._adrawRBExpansion then return end
    local ex, ey, ew, eh = unpack(tb._adrawRBExpansion)
    local minrb, maxrb = calculateRenderBounds(ex, ey, ew, eh)
    render.DrawWireframeBox(vector_origin, angle_zero, minrb, maxrb, devColours["renderBounds"])
end

function adraw.End3D2D()
    if gState then
        if _devMode then
            local renderTook = SysTime() - gState._renderStarted
            gState._devBenchTests = (gState._devBenchTests or 0) + 1
            gState._devBenchTaken = (gState._devBenchTaken or 0) + renderTook

            if gState._devBenchTests == 100 then
                gState._devBenchAveraged = gState._devBenchTaken / 100
                gState._devBenchTests = 0
                gState._devBenchTaken = 0
            end
        end

        gState.rendering = false
        cam.End3D2D()
        render.SetBlend(1)
        surface.SetAlphaMultiplier(1)

        if _devMode then
            drawDeveloperInfo()
        end

        gState.entity = nil
    end
end

function adraw.CursorPos()
    local mx, my = gState.mx, gState.my

    return mx, my
end

function adraw.IsHovering(x, y, w, h)
    local mx, my = gState.mx, gState.my

    return mx and my and mx >= x and mx <= (x + w) and my >= y and my <= (y + h)
end

function adraw.IsPressing()
    return shouldAcceptInput() and gState.pressing
end

function adraw.IsPressed()
    return shouldAcceptInput() and gState.pressed
end

local _createdFonts = {}
local _adrawFontToGmodFont = {}
local EXCLAMATION_BYTE = string.byte("!")

function adraw.xFont(font, defaultSize)
    -- special font
    if string.byte(font, 1) == EXCLAMATION_BYTE then
        local existingGFont = _adrawFontToGmodFont[font]
        if existingGFont then return existingGFont end
        -- Font not cached; parse the font
        local name, size = font:match("!([^@]+)@(.+)")

        if size then
            size = tonumber(size)
        end

        if not size and defaultSize then
            name = font:match("^!([^@]+)$")
            size = defaultSize
        end

        local fontName = string.format("adraw_%s_%d", name, size)
        _adrawFontToGmodFont[font] = fontName

        if not _createdFonts[fontName] then
            surface.CreateFont(fontName, {
                font = name,
                size = size
            })

            _createdFonts[fontName] = true
        end

        return fontName
    end

    return font
end

function adraw.DrawBox(x,y,w,h,borderWidth, borderColor)
    if borderWidth > 0 then
        surface.SetDrawColor(borderColor)
        surface.DrawRect(x, y, w, borderWidth)
        surface.DrawRect(x, y + borderWidth, borderWidth, h - borderWidth * 2)
        surface.DrawRect(x, y + h - borderWidth, w, borderWidth)
        surface.DrawRect(x + w - borderWidth + 1, y, borderWidth, h)
    end
end

function adraw.xButton(x, y, w, h, borderWidth, borderClr, hoverClr, pressColor)
    local bw = borderWidth or 1
    local bgColor = adraw.IsHovering(x, y, w, h) and adraw.skin.backgroundHover or adraw.skin.background
    local borderColor = ((adraw.IsPressing() and adraw.IsHovering(x, y, w, h)) and (pressColor or adraw.skin.borderPress)) or (adraw.IsHovering(x, y, w, h) and (hoverClr or adraw.skin.borderHover)) or (borderClr or adraw.skin.border)
    surface.SetDrawColor(bgColor)
    surface.DrawRect(x, y, w, h)

    adraw.DrawBox(x,y,w,h,bw,borderColor)

    local isHovering = adraw.IsHovering(x, y, w, h)
    return shouldAcceptInput() and isHovering and gState.pressed, isHovering
end

function adraw.xOneColorButton(x, y, w, h, borderWidth, clr)
    local bw = borderWidth or 1
    surface.SetDrawColor(clr)
    surface.DrawRect(x, y, w, h)

    if bw > 0 then
        surface.SetDrawColor(clr)
        surface.DrawRect(x, y, w, bw)
        surface.DrawRect(x, y + bw, bw, h - bw * 2)
        surface.DrawRect(x, y + h - bw, w, bw)
        surface.DrawRect(x + w - bw + 1, y, bw, h)
    end

    return shouldAcceptInput() and adraw.IsHovering(x, y, w, h) and gState.pressed
end

function adraw.xCursor(x, y, w, h)
    local fgColor = adraw.IsPressing() and adraw.skin.foregroundPress or adraw.skin.foreground
    local mx, my = gState.mx, gState.my
    if not mx or not my then return end
    if x and w and (mx < x or mx > x + w) then return end
    if y and h and (my < y or my > y + h) then return end
    local cursorSize = math.ceil(0.3 / gState.scale)
    surface.SetDrawColor(fgColor)
    surface.DrawLine(mx - cursorSize, my, mx + cursorSize, my)
    surface.DrawLine(mx, my - cursorSize, mx, my + cursorSize)
end

function adraw.xTextButton(text, font, x, y, w, h, borderWidth, color, hoverClr, pressColor)
    local fgColor = ((adraw.IsPressing() and adraw.IsHovering(x, y, w, h)) and (pressColor or adraw.skin.foregroundPress)) or (adraw.IsHovering(x, y, w, h) and (hoverClr or adraw.skin.foregroundHover)) or (color or adraw.skin.foreground)
    local clicked = adraw.xButton(x, y, w, h, borderWidth, color, hoverClr, pressColor)
    font = adraw.xFont(font, math.floor(h * 0.618))
    draw.SimpleText(text, font, x + w / 2, y + h / 2, fgColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)

    return clicked
end

function adraw.xConButton(x, y, w, h, borderWidth, color, hoverClr, pressColor, conColor, condition)
    local fgColor
    local clicked
    if condition then
        fgColor = conColor
        clicked = adraw.xOneColorButton(x, y, w, h, borderWidth, conColor)
    else
        fgColor = ((adraw.IsPressing() and adraw.IsHovering(x, y, w, h)) and (pressColor or adraw.skin.foregroundPress)) or (adraw.IsHovering(x, y, w, h) and (hoverClr or adraw.skin.foregroundHover)) or (color or adraw.skin.foreground)
        clicked = adraw.xButton(x, y, w, h, borderWidth, color, hoverClr, pressColor)
    end

    return clicked
end

function adraw.xSymbolButton(symbol, x, y, w, h, borderWidth, color, hoverClr, pressColor)
    local fgColor = ((adraw.IsPressing() and adraw.IsHovering(x, y, w, h)) and (pressColor or adraw.skin.foregroundPress)) or (adraw.IsHovering(x, y, w, h) and (hoverClr or adraw.skin.foregroundHover)) or (color or adraw.skin.foreground)
    local clicked = adraw.xButton(x, y, w, h, borderWidth, color, hoverClr, pressColor)
    surface.SetMaterial(symbol)
    surface.SetDrawColor(fgColor)
    surface.DrawTexturedRect(x, y, w, h)

    return clicked
end

function adraw.xDrawLine(x, y, x2, y2, sz)
    local midX = (x + x2) / 2
    local midY = (y + y2) / 2

    local dx = x2 - x
    local dy = y2 - y
    local ang = -math.deg(math.atan2(dy, dx))

    local len = math.sqrt((x2 - x) ^ 2 + (y2 - y) ^ 2)
    draw.NoTexture()
    surface.DrawTexturedRectRotated(midX, midY, len, sz, ang)
end

local cached = {}

function adraw.Arc(cx, cy, radius, thickness, startang, endang, roughness, color)
    local arc = tostring(cx) .. tostring(cy) .. tostring(radius) .. tostring(thickness) .. tostring(startang) .. tostring(endang) .. tostring(roughness)
    surface.SetDrawColor(color)
    draw.NoTexture()

    if (cached[arc] == nil) then
        cached[arc] = adraw.PrecacheArc(cx, cy, radius, thickness, startang, endang, roughness)
    end

    adraw.DrawArc(cached[arc])
end

function adraw.PrecacheArc(cx, cy, radius, thickness, startang, endang, roughness)
    local triarc = {}
    local roughness = math.max(roughness or 1, 1)
    local step = roughness
    local startang, endang = startang or 0, endang or 0

    if startang > endang then
        step = math.abs(step) * -1
    end

    local inner = {}
    local r = radius - thickness

    for deg = startang, endang, step do
        local rad = math.rad(deg)
        local ox, oy = cx + (math.cos(rad) * r), cy + (-math.sin(rad) * r)

        table.insert(inner, {
            x = ox,
            y = oy,
            u = (ox - cx) / radius + .5,
            v = (oy - cy) / radius + .5,
        })
    end

    local outer = {}

    for deg = startang, endang, step do
        local rad = math.rad(deg)
        local ox, oy = cx + (math.cos(rad) * radius), cy + (-math.sin(rad) * radius)

        table.insert(outer, {
            x = ox,
            y = oy,
            u = (ox - cx) / radius + .5,
            v = (oy - cy) / radius + .5,
        })
    end

    for tri = 1, #inner * 2 do
        local p1, p2, p3
        p1 = outer[math.floor(tri / 2) + 1]
        p3 = inner[math.floor((tri + 1) / 2) + 1]

        if tri % 2 == 0 then
            p2 = outer[math.floor((tri + 1) / 2)]
        else
            p2 = inner[math.floor((tri + 1) / 2)]
        end

        table.insert(triarc, {p1, p2, p3})
    end

    return triarc
end

function adraw.DrawArc(arc)
    for _, v in ipairs(arc) do
        surface.DrawPoly(v)
    end
end

function adraw.DrawTexturedRectRotatedPoint( x, y, w, h, rot, x0, y0 )
    local c = math.cos( math.rad( rot ) )
    local s = math.sin( math.rad( rot ) )

    local newx = y0 * s - x0 * c
    local newy = y0 * c + x0 * s

    surface.DrawTexturedRectRotated( x + newx, y + newy, w, h, rot )
end

local matBlurScreen = Material("pp/blurscreen")
function adraw.Derma_DrawPanelBlur(panel, color)
    color = color or Color(10,10,10,100)
    local x, y = panel:LocalToScreen( 0, 0 )

    -- Menu cannot do blur
    if ( not MENU_DLL ) then
        surface.SetMaterial( matBlurScreen )
        surface.SetDrawColor( 255, 255, 255, 255 )

        for i = 0.33, 1, 0.33 do
            matBlurScreen:SetFloat( "$blur", 5 * i )
            matBlurScreen:Recompute()
            if ( render ) then
                render.UpdateScreenEffectTexture()
            end
            surface.DrawTexturedRect( x * -1, y * -1, ScrW(), ScrH() )
        end
    end

    surface.SetDrawColor(color)
    surface.DrawRect( x * -1, y * -1, ScrW(), ScrH() )
end

return adraw

--addons/starwars_universe/lua/libs/advanceddraw.lua:
--    Advanced Draw:
--    - IMGUI Source Code: https://github.com/wyozi-gmod/imgui
--    - Draw Precache Arc
--    - Draw Line with thickness

local adraw = {}

adraw.skin = {
    background = Color(0, 0, 0, 0),
    backgroundHover = Color(0, 0, 0, 0),
    border = Color(255, 255, 255),
    borderHover = Color(255, 127, 0),
    borderPress = Color(255, 80, 0),
    foreground = Color(255, 255, 255),
    foregroundHover = Color(255, 127, 0),
    foregroundPress = Color(255, 80, 0),
}

local devCvar = GetConVar("developer")

function adraw.IsDeveloperMode()
    return not adraw.DisableDeveloperMode and devCvar:GetInt() > 0
end

local _devMode = false -- cached local variable updated once in a while

function adraw.Hook(name, id, callback)
    local hookUniqifier = debug.getinfo(4).short_src
    hook.Add(name, "adraw / " .. id .. " / " .. hookUniqifier, callback)
end

local local_player
local gState = {}

local function shouldAcceptInput()
    -- don't process input during non-main renderpass
    if render.GetRenderTarget() ~= nil then return false end
    -- don't process input if we're doing VGUI stuff (and not in context menu)
    if vgui.CursorVisible() and vgui.GetHoveredPanel() ~= g_ContextMenu then return false end

    return true
end

adraw.Hook("PreRender", "adraw / Input", function()
    -- calculate mouse state
    if shouldAcceptInput() then
        local useBind = input.LookupBinding("+use", true)
        local attackBind = input.LookupBinding("+attack", true)
        local USE = useBind and input.GetKeyCode(useBind)
        local ATTACK = attackBind and input.GetKeyCode(attackBind)
        local wasPressing = gState.pressing
        gState.pressing = (USE and input.IsButtonDown(USE)) or (ATTACK and input.IsButtonDown(ATTACK))
        gState.pressed = not wasPressing and gState.pressing
    end
end)

hook.Add("NotifyShouldTransmit", "adraw / ClearRenderBounds", function(ent, shouldTransmit)
    if not shouldTransmit then return end
    local tb = ent:GetTable()
    if not tb._adrawRBExpansion then return end
    tb._adrawRBExpansion = nil
end)

local traceResultTable = {}

local traceQueryTable = {
    output = traceResultTable,
    filter = {}
}

local function isObstructed(eyePos, hitPos, ignoredEntity)
    local q = traceQueryTable
    q.start = eyePos
    q.endpos = hitPos
    q.filter[1] = local_player
    q.filter[2] = ignoredEntity
    local tr = util.TraceLine(q)

    if tr.Hit then
        return true, tr.Entity
    else
        return false
    end
end

function adraw.Start3D2D(pos, angles, scale, distanceHide, distanceFadeStart)
    local_player = local_player or LocalPlayer()

    if gState.shutdown == true then return end

    if gState.rendering == true then
        print("[AdvancedDraw] Starting a new adraw context when previous one is still rendering" .. "Shutting down rendering pipeline to prevent crashes..")
        gState.shutdown = true

        return false
    end

    _devMode = adraw.IsDeveloperMode()
    local eyePos = local_player:EyePos()
    local eyePosToPos = pos - eyePos

    -- OPTIMIZATION: Test that we are in front of the UI
    do
        local normal = angles:Up()
        local dot = eyePosToPos:Dot(normal)

        if _devMode then
            gState._devDot = dot
        end

        -- since normal is pointing away from surface towards viewer, dot<0 is visible
        if dot >= 0 then return false end
    end

    -- OPTIMIZATION: Distance based fade/hide
    if distanceHide then
        local distance = eyePosToPos:Length()
        if distance > distanceHide then return false end

        if _devMode then
            gState._devDist = distance
            gState._devHideDist = distanceHide
        end

        if distanceHide and distanceFadeStart and distance > distanceFadeStart then
            local blend = math.min(math.Remap(distance, distanceFadeStart, distanceHide, 1, 0), 1)
            render.SetBlend(blend)
            surface.SetAlphaMultiplier(blend)
        end
    end

    gState.rendering = true
    gState.pos = pos
    gState.angles = angles
    gState.scale = scale
    cam.Start3D2D(pos, angles, scale)

    -- calculate mousepos
    if not vgui.CursorVisible() or vgui.IsHoveringWorld() then
        local tr = local_player:GetEyeTrace()
        local eyepos = tr.StartPos
        local eyenormal

        if vgui.CursorVisible() and vgui.IsHoveringWorld() then
            eyenormal = gui.ScreenToVector(gui.MousePos())
        else
            eyenormal = tr.Normal
        end

        local planeNormal = angles:Up()
        local hitPos = util.IntersectRayWithPlane(eyepos, eyenormal, pos, planeNormal)

        if hitPos then
            local obstructed, obstructer = isObstructed(eyepos, hitPos, gState.entity)

            if obstructed then
                gState.mx = nil
                gState.my = nil

                if _devMode then
                    gState._devInputBlocker = "collision " .. obstructer:GetClass() .. "/" .. obstructer:EntIndex()
                end
            else
                local diff = pos - hitPos
                -- This cool code is from Willox's keypad CalculateCursorPos
                local x = diff:Dot(-angles:Forward()) / scale
                local y = diff:Dot(-angles:Right()) / scale
                gState.mx = x
                gState.my = y
            end
        else
            gState.mx = nil
            gState.my = nil

            if _devMode then
                gState._devInputBlocker = "not looking at plane"
            end
        end
    else
        gState.mx = nil
        gState.my = nil

        if _devMode then
            gState._devInputBlocker = "not hovering world"
        end
    end

    if _devMode then
        gState._renderStarted = SysTime()
    end

    return true
end

function adraw.Entity3D2D(ent, lpos, lang, scale, ...)
    gState.entity = ent
    local ret = adraw.Start3D2D(ent:LocalToWorld(lpos), ent:LocalToWorldAngles(lang), scale, ...)

    if not ret then
        gState.entity = nil
    end

    return ret
end

local function calculateRenderBounds(x, y, w, h)
    local pos = gState.pos
    local fwd, right = gState.angles:Forward(), gState.angles:Right()
    local scale = gState.scale
    local firstCorner, secondCorner = pos + fwd * x * scale + right * y * scale, pos + fwd * (x + w) * scale + right * (y + h) * scale
    local minrb, maxrb = Vector(math.huge, math.huge, math.huge), Vector(-math.huge, -math.huge, -math.huge)
    minrb.x = math.min(minrb.x, firstCorner.x, secondCorner.x)
    minrb.y = math.min(minrb.y, firstCorner.y, secondCorner.y)
    minrb.z = math.min(minrb.z, firstCorner.z, secondCorner.z)
    maxrb.x = math.max(maxrb.x, firstCorner.x, secondCorner.x)
    maxrb.y = math.max(maxrb.y, firstCorner.y, secondCorner.y)
    maxrb.z = math.max(maxrb.z, firstCorner.z, secondCorner.z)

    return minrb, maxrb
end

function adraw.ExpandRenderBoundsFromRect(x, y, w, h)
    local ent = gState.entity

    if IsValid(ent) then
        local tb = ent:GetTable()
        -- make sure we're not applying same expansion twice
        local expansion = tb._adrawRBExpansion

        if expansion then
            local ex, ey, ew, eh = unpack(expansion)
            if ex == x and ey == y and ew == w and eh == h then return end
        end

        local minrb, maxrb = calculateRenderBounds(x, y, w, h)
        ent:SetRenderBoundsWS(minrb, maxrb)

        if _devMode then
            print("[adraw] Updated renderbounds of ", ent, " to ", minrb, "x", maxrb)
        end

        tb._adrawRBExpansion = {x, y, w, h}
    else
        if _devMode then
            print("[adraw] Attempted to update renderbounds when entity is not valid!! ", debug.traceback())
        end
    end
end

local devOffset = Vector(0, 0, 30)

local devColours = {
    background = Color(0, 0, 0, 200),
    title = Color(78, 205, 196),
    mouseHovered = Color(0, 255, 0),
    mouseUnhovered = Color(255, 0, 0),
    pos = Color(255, 255, 255),
    distance = Color(200, 200, 200, 200),
    ang = Color(255, 255, 255),
    dot = Color(200, 200, 200, 200),
    angleToEye = Color(200, 200, 200, 200),
    renderTime = Color(255, 255, 255),
    renderBounds = Color(0, 0, 255)
}

local function developerText(str, x, y, clr)
    draw.SimpleText(str, "DefaultFixedDropShadow", x, y, clr, TEXT_ALIGN_CENTER, nil)
end

local function drawDeveloperInfo()
    local camAng = local_player:EyeAngles()
    camAng:RotateAroundAxis(camAng:Right(), 90)
    camAng:RotateAroundAxis(camAng:Up(), -90)
    cam.IgnoreZ(true)
    cam.Start3D2D(gState.pos + devOffset, camAng, 0.15)
        local bgCol = devColours["background"]
        surface.SetDrawColor(bgCol.r, bgCol.g, bgCol.b, bgCol.a)
        surface.DrawRect(-100, 0, 200, 140)
        local titleCol = devColours["title"]
        developerText("adraw developer", 0, 5, titleCol)
        surface.SetDrawColor(titleCol.r, titleCol.g, titleCol.b)
        surface.DrawLine(-50, 16, 50, 16)
        local mx, my = gState.mx, gState.my
    
        if mx and my then
            developerText(string.format("mouse: hovering %d x %d", mx, my), 0, 20, devColours["mouseHovered"])
        else
            developerText(string.format("mouse: %s", gState._devInputBlocker or ""), 0, 20, devColours["mouseUnhovered"])
        end
    
        local pos = gState.pos
        developerText(string.format("pos: %.2f %.2f %.2f", pos.x, pos.y, pos.z), 0, 40, devColours["pos"])
        developerText(string.format("distance %.2f / %.2f", gState._devDist or 0, gState._devHideDist or 0), 0, 53, devColours["distance"])
        local ang = gState.angles
        developerText(string.format("ang: %.2f %.2f %.2f", ang.p, ang.y, ang.r), 0, 75, devColours["ang"])
        developerText(string.format("dot %d", gState._devDot or 0), 0, 88, devColours["dot"])
        local angToEye = (pos - local_player:EyePos()):Angle()
        angToEye:RotateAroundAxis(ang:Up(), -90)
        angToEye:RotateAroundAxis(ang:Right(), 90)
        developerText(string.format("angle to eye (%d,%d,%d)", angToEye.p, angToEye.y, angToEye.r), 0, 100, devColours["angleToEye"])
        developerText(string.format("rendertime avg: %.2fms", (gState._devBenchAveraged or 0) * 1000), 0, 120, devColours["renderTime"])
    cam.End3D2D()
    cam.IgnoreZ(false)
    local ent = gState.entity

    if not IsValid(ent) then return end
    local tb = ent:GetTable()
    if not tb._adrawRBExpansion then return end
    local ex, ey, ew, eh = unpack(tb._adrawRBExpansion)
    local minrb, maxrb = calculateRenderBounds(ex, ey, ew, eh)
    render.DrawWireframeBox(vector_origin, angle_zero, minrb, maxrb, devColours["renderBounds"])
end

function adraw.End3D2D()
    if gState then
        if _devMode then
            local renderTook = SysTime() - gState._renderStarted
            gState._devBenchTests = (gState._devBenchTests or 0) + 1
            gState._devBenchTaken = (gState._devBenchTaken or 0) + renderTook

            if gState._devBenchTests == 100 then
                gState._devBenchAveraged = gState._devBenchTaken / 100
                gState._devBenchTests = 0
                gState._devBenchTaken = 0
            end
        end

        gState.rendering = false
        cam.End3D2D()
        render.SetBlend(1)
        surface.SetAlphaMultiplier(1)

        if _devMode then
            drawDeveloperInfo()
        end

        gState.entity = nil
    end
end

function adraw.CursorPos()
    local mx, my = gState.mx, gState.my

    return mx, my
end

function adraw.IsHovering(x, y, w, h)
    local mx, my = gState.mx, gState.my

    return mx and my and mx >= x and mx <= (x + w) and my >= y and my <= (y + h)
end

function adraw.IsPressing()
    return shouldAcceptInput() and gState.pressing
end

function adraw.IsPressed()
    return shouldAcceptInput() and gState.pressed
end

local _createdFonts = {}
local _adrawFontToGmodFont = {}
local EXCLAMATION_BYTE = string.byte("!")

function adraw.xFont(font, defaultSize)
    -- special font
    if string.byte(font, 1) == EXCLAMATION_BYTE then
        local existingGFont = _adrawFontToGmodFont[font]
        if existingGFont then return existingGFont end
        -- Font not cached; parse the font
        local name, size = font:match("!([^@]+)@(.+)")

        if size then
            size = tonumber(size)
        end

        if not size and defaultSize then
            name = font:match("^!([^@]+)$")
            size = defaultSize
        end

        local fontName = string.format("adraw_%s_%d", name, size)
        _adrawFontToGmodFont[font] = fontName

        if not _createdFonts[fontName] then
            surface.CreateFont(fontName, {
                font = name,
                size = size
            })

            _createdFonts[fontName] = true
        end

        return fontName
    end

    return font
end

function adraw.DrawBox(x,y,w,h,borderWidth, borderColor)
    if borderWidth > 0 then
        surface.SetDrawColor(borderColor)
        surface.DrawRect(x, y, w, borderWidth)
        surface.DrawRect(x, y + borderWidth, borderWidth, h - borderWidth * 2)
        surface.DrawRect(x, y + h - borderWidth, w, borderWidth)
        surface.DrawRect(x + w - borderWidth + 1, y, borderWidth, h)
    end
end

function adraw.xButton(x, y, w, h, borderWidth, borderClr, hoverClr, pressColor)
    local bw = borderWidth or 1
    local bgColor = adraw.IsHovering(x, y, w, h) and adraw.skin.backgroundHover or adraw.skin.background
    local borderColor = ((adraw.IsPressing() and adraw.IsHovering(x, y, w, h)) and (pressColor or adraw.skin.borderPress)) or (adraw.IsHovering(x, y, w, h) and (hoverClr or adraw.skin.borderHover)) or (borderClr or adraw.skin.border)
    surface.SetDrawColor(bgColor)
    surface.DrawRect(x, y, w, h)

    adraw.DrawBox(x,y,w,h,bw,borderColor)

    local isHovering = adraw.IsHovering(x, y, w, h)
    return shouldAcceptInput() and isHovering and gState.pressed, isHovering
end

function adraw.xOneColorButton(x, y, w, h, borderWidth, clr)
    local bw = borderWidth or 1
    surface.SetDrawColor(clr)
    surface.DrawRect(x, y, w, h)

    if bw > 0 then
        surface.SetDrawColor(clr)
        surface.DrawRect(x, y, w, bw)
        surface.DrawRect(x, y + bw, bw, h - bw * 2)
        surface.DrawRect(x, y + h - bw, w, bw)
        surface.DrawRect(x + w - bw + 1, y, bw, h)
    end

    return shouldAcceptInput() and adraw.IsHovering(x, y, w, h) and gState.pressed
end

function adraw.xCursor(x, y, w, h)
    local fgColor = adraw.IsPressing() and adraw.skin.foregroundPress or adraw.skin.foreground
    local mx, my = gState.mx, gState.my
    if not mx or not my then return end
    if x and w and (mx < x or mx > x + w) then return end
    if y and h and (my < y or my > y + h) then return end
    local cursorSize = math.ceil(0.3 / gState.scale)
    surface.SetDrawColor(fgColor)
    surface.DrawLine(mx - cursorSize, my, mx + cursorSize, my)
    surface.DrawLine(mx, my - cursorSize, mx, my + cursorSize)
end

function adraw.xTextButton(text, font, x, y, w, h, borderWidth, color, hoverClr, pressColor)
    local fgColor = ((adraw.IsPressing() and adraw.IsHovering(x, y, w, h)) and (pressColor or adraw.skin.foregroundPress)) or (adraw.IsHovering(x, y, w, h) and (hoverClr or adraw.skin.foregroundHover)) or (color or adraw.skin.foreground)
    local clicked = adraw.xButton(x, y, w, h, borderWidth, color, hoverClr, pressColor)
    font = adraw.xFont(font, math.floor(h * 0.618))
    draw.SimpleText(text, font, x + w / 2, y + h / 2, fgColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)

    return clicked
end

function adraw.xConButton(x, y, w, h, borderWidth, color, hoverClr, pressColor, conColor, condition)
    local fgColor
    local clicked
    if condition then
        fgColor = conColor
        clicked = adraw.xOneColorButton(x, y, w, h, borderWidth, conColor)
    else
        fgColor = ((adraw.IsPressing() and adraw.IsHovering(x, y, w, h)) and (pressColor or adraw.skin.foregroundPress)) or (adraw.IsHovering(x, y, w, h) and (hoverClr or adraw.skin.foregroundHover)) or (color or adraw.skin.foreground)
        clicked = adraw.xButton(x, y, w, h, borderWidth, color, hoverClr, pressColor)
    end

    return clicked
end

function adraw.xSymbolButton(symbol, x, y, w, h, borderWidth, color, hoverClr, pressColor)
    local fgColor = ((adraw.IsPressing() and adraw.IsHovering(x, y, w, h)) and (pressColor or adraw.skin.foregroundPress)) or (adraw.IsHovering(x, y, w, h) and (hoverClr or adraw.skin.foregroundHover)) or (color or adraw.skin.foreground)
    local clicked = adraw.xButton(x, y, w, h, borderWidth, color, hoverClr, pressColor)
    surface.SetMaterial(symbol)
    surface.SetDrawColor(fgColor)
    surface.DrawTexturedRect(x, y, w, h)

    return clicked
end

function adraw.xDrawLine(x, y, x2, y2, sz)
    local midX = (x + x2) / 2
    local midY = (y + y2) / 2

    local dx = x2 - x
    local dy = y2 - y
    local ang = -math.deg(math.atan2(dy, dx))

    local len = math.sqrt((x2 - x) ^ 2 + (y2 - y) ^ 2)
    draw.NoTexture()
    surface.DrawTexturedRectRotated(midX, midY, len, sz, ang)
end

local cached = {}

function adraw.Arc(cx, cy, radius, thickness, startang, endang, roughness, color)
    local arc = tostring(cx) .. tostring(cy) .. tostring(radius) .. tostring(thickness) .. tostring(startang) .. tostring(endang) .. tostring(roughness)
    surface.SetDrawColor(color)
    draw.NoTexture()

    if (cached[arc] == nil) then
        cached[arc] = adraw.PrecacheArc(cx, cy, radius, thickness, startang, endang, roughness)
    end

    adraw.DrawArc(cached[arc])
end

function adraw.PrecacheArc(cx, cy, radius, thickness, startang, endang, roughness)
    local triarc = {}
    local roughness = math.max(roughness or 1, 1)
    local step = roughness
    local startang, endang = startang or 0, endang or 0

    if startang > endang then
        step = math.abs(step) * -1
    end

    local inner = {}
    local r = radius - thickness

    for deg = startang, endang, step do
        local rad = math.rad(deg)
        local ox, oy = cx + (math.cos(rad) * r), cy + (-math.sin(rad) * r)

        table.insert(inner, {
            x = ox,
            y = oy,
            u = (ox - cx) / radius + .5,
            v = (oy - cy) / radius + .5,
        })
    end

    local outer = {}

    for deg = startang, endang, step do
        local rad = math.rad(deg)
        local ox, oy = cx + (math.cos(rad) * radius), cy + (-math.sin(rad) * radius)

        table.insert(outer, {
            x = ox,
            y = oy,
            u = (ox - cx) / radius + .5,
            v = (oy - cy) / radius + .5,
        })
    end

    for tri = 1, #inner * 2 do
        local p1, p2, p3
        p1 = outer[math.floor(tri / 2) + 1]
        p3 = inner[math.floor((tri + 1) / 2) + 1]

        if tri % 2 == 0 then
            p2 = outer[math.floor((tri + 1) / 2)]
        else
            p2 = inner[math.floor((tri + 1) / 2)]
        end

        table.insert(triarc, {p1, p2, p3})
    end

    return triarc
end

function adraw.DrawArc(arc)
    for _, v in ipairs(arc) do
        surface.DrawPoly(v)
    end
end

function adraw.DrawTexturedRectRotatedPoint( x, y, w, h, rot, x0, y0 )
    local c = math.cos( math.rad( rot ) )
    local s = math.sin( math.rad( rot ) )

    local newx = y0 * s - x0 * c
    local newy = y0 * c + x0 * s

    surface.DrawTexturedRectRotated( x + newx, y + newy, w, h, rot )
end

local matBlurScreen = Material("pp/blurscreen")
function adraw.Derma_DrawPanelBlur(panel, color)
    color = color or Color(10,10,10,100)
    local x, y = panel:LocalToScreen( 0, 0 )

    -- Menu cannot do blur
    if ( not MENU_DLL ) then
        surface.SetMaterial( matBlurScreen )
        surface.SetDrawColor( 255, 255, 255, 255 )

        for i = 0.33, 1, 0.33 do
            matBlurScreen:SetFloat( "$blur", 5 * i )
            matBlurScreen:Recompute()
            if ( render ) then
                render.UpdateScreenEffectTexture()
            end
            surface.DrawTexturedRect( x * -1, y * -1, ScrW(), ScrH() )
        end
    end

    surface.SetDrawColor(color)
    surface.DrawRect( x * -1, y * -1, ScrW(), ScrH() )
end

return adraw

--addons/starwars_universe/lua/star-wars-universe/client/vgui/cl_swu_configruationframe.lua:
local PANEL = {}

surface.CreateFont("SwuSettingsHeader", {
    font = "Saira",
    size = 90,
    weight = 200,
    antialias = true,
    shadow = false
})

local closeIconMaterial = Material("the-coding-ducks/swu/icons/close-icon.png", "smooth")
local swuIconMaterial = Material("the-coding-ducks/swu/icons/swu-icon.png", "smooth")

function PANEL:Init()
    self:SetSize(ScrW() * 0.55, ScrH() * 0.7)
    self:SetTitle("")
    self:ShowCloseButton(false)
    self:SetDraggable(false)

    self:MakePopup()
    self:Center()

    self.PanelDist = ScrH() * 0.01

    self.Header = self:Add("swu_basepanel")
    local header = self.Header
    header:SetSize(self:GetWide(), self:GetTall() * 0.15)
    header:SetBackgroundColor(Color(10,10,10,200))
    local margin = header:GetTall() * 0.25

    header.SwuIcon = header:Add("swu_icon")
    local swuIcon = header.SwuIcon
    swuIcon:Dock(LEFT)
    swuIcon:SetPaintBackground(false)
    swuIcon:SetMaterial(swuIconMaterial)
    swuIcon:DockMargin(margin, margin * 0.5, 0, margin * 0.5)
    swuIcon:SetSize(header:GetTall() - margin, header:GetTall())

    header.Title = header:Add("DLabel")
    local title = header.Title
    title:SetText("Configuration")
    title:SetFont("SwuSettingsHeader")
    title:SetColor(Color(255,255,255))
    title:SizeToContents()
    title:SetContentAlignment(4)
    title:Dock(LEFT)
    title:DockMargin(margin,0,0,0)

    header.Close = header:Add("swu_icon")
    local close = header.Close
    close:Dock(RIGHT)
    close:SetPaintBackground(false)
    close:SetMaterial(closeIconMaterial)
    close:SetColor(Color(200,20,20))
    close:SetOnClick(function () self:Remove() end, Color(150,0,0), Color(100,0,0))
    close:DockMargin(margin, margin, margin, margin)
    close:SetSize(header:GetTall() - margin * 2, header:GetTall() - margin * 2)

    self.Navigation = self:Add("swu_basepanel")
    local nav = self.Navigation
    nav:SetSize(self:GetWide() * 0.25, self:GetTall() - header:GetTall() - self.PanelDist)
    nav:SetPos(0, header:GetTall() + self.PanelDist)
    nav:SetBackgroundColor(Color(50,50,50,100))

    self.Content = self:Add("swu_basepanel")
    local content = self.Content
    content:SetPaintBackground(false)
    content:SetPos(nav:GetWide() + self.PanelDist, header:GetTall() + self.PanelDist)
    content:SetSize(self:GetWide() - nav:GetWide() - self.PanelDist, self:GetTall() - header:GetTall() - self.PanelDist)

    for i, v in ipairs(SWU.Configuration:GetTabs()) do
        local entry = nav:Add("swu_navigationentry")
        entry:SetText(v.title)
        entry:Dock(TOP)
        entry:SetOnClick(function ()
            self:LoadContent(i)
        end)
        entry:SetId(i)

        if (self.ActiveContentId == nil) then
            self:LoadContent(i)
        end
    end
end

function PANEL:Paint()
end

function PANEL:ClearContent()
    self.Content:Clear()
end

function PANEL:LoadContent(id)
    local newTab = SWU.Configuration:GetTabs()[id]

    if (not istable(newTab)) then return end

    self:ClearContent()

    self.ActiveContentId = id
    newTab.open(self.Content)
    self:UpdateNavigationButtons()
end

function PANEL:UpdateNavigationButtons()
    for i, v in ipairs(self.Navigation:GetChildren()) do
        if (v:GetId() == self.ActiveContentId) then
            v:SetActive(true)
        else
            v:SetActive(false)
        end
    end
end

vgui.Register("swu_configruationframe", PANEL, "DFrame")

--addons/starwars_universe/lua/star-wars-universe/client/vgui/cl_swu_internal_inputfield.lua:
local adraw = include("libs/advanceddraw.lua")
local PANEL = {}

function PANEL:Init()
    self:SetPaintBackground(false)
    self:SetTextColor(SWU.Colors.Default.passive)
    self:SetCursorColor(SWU.Colors.Default.passive)
    self:SetDrawLanguageID(false)
end

function PANEL:UpdateFont(h)
    self:SetFont(adraw.xFont("!Saira", math.floor(h * 0.9)))
end

function PANEL:OnSizeChanged(w,h)
    self:UpdateFont(h)
end

function PANEL:Paint(w,h)
    derma.SkinHook("Paint", "TextEntry", self, w, h)
    return false
end


vgui.Register("swu_internal_inputfield", PANEL, "DTextEntry")
--addons/starwars_universe/lua/libs/advanceddraw.lua:
--    Advanced Draw:
--    - IMGUI Source Code: https://github.com/wyozi-gmod/imgui
--    - Draw Precache Arc
--    - Draw Line with thickness

local adraw = {}

adraw.skin = {
    background = Color(0, 0, 0, 0),
    backgroundHover = Color(0, 0, 0, 0),
    border = Color(255, 255, 255),
    borderHover = Color(255, 127, 0),
    borderPress = Color(255, 80, 0),
    foreground = Color(255, 255, 255),
    foregroundHover = Color(255, 127, 0),
    foregroundPress = Color(255, 80, 0),
}

local devCvar = GetConVar("developer")

function adraw.IsDeveloperMode()
    return not adraw.DisableDeveloperMode and devCvar:GetInt() > 0
end

local _devMode = false -- cached local variable updated once in a while

function adraw.Hook(name, id, callback)
    local hookUniqifier = debug.getinfo(4).short_src
    hook.Add(name, "adraw / " .. id .. " / " .. hookUniqifier, callback)
end

local local_player
local gState = {}

local function shouldAcceptInput()
    -- don't process input during non-main renderpass
    if render.GetRenderTarget() ~= nil then return false end
    -- don't process input if we're doing VGUI stuff (and not in context menu)
    if vgui.CursorVisible() and vgui.GetHoveredPanel() ~= g_ContextMenu then return false end

    return true
end

adraw.Hook("PreRender", "adraw / Input", function()
    -- calculate mouse state
    if shouldAcceptInput() then
        local useBind = input.LookupBinding("+use", true)
        local attackBind = input.LookupBinding("+attack", true)
        local USE = useBind and input.GetKeyCode(useBind)
        local ATTACK = attackBind and input.GetKeyCode(attackBind)
        local wasPressing = gState.pressing
        gState.pressing = (USE and input.IsButtonDown(USE)) or (ATTACK and input.IsButtonDown(ATTACK))
        gState.pressed = not wasPressing and gState.pressing
    end
end)

hook.Add("NotifyShouldTransmit", "adraw / ClearRenderBounds", function(ent, shouldTransmit)
    if not shouldTransmit then return end
    local tb = ent:GetTable()
    if not tb._adrawRBExpansion then return end
    tb._adrawRBExpansion = nil
end)

local traceResultTable = {}

local traceQueryTable = {
    output = traceResultTable,
    filter = {}
}

local function isObstructed(eyePos, hitPos, ignoredEntity)
    local q = traceQueryTable
    q.start = eyePos
    q.endpos = hitPos
    q.filter[1] = local_player
    q.filter[2] = ignoredEntity
    local tr = util.TraceLine(q)

    if tr.Hit then
        return true, tr.Entity
    else
        return false
    end
end

function adraw.Start3D2D(pos, angles, scale, distanceHide, distanceFadeStart)
    local_player = local_player or LocalPlayer()

    if gState.shutdown == true then return end

    if gState.rendering == true then
        print("[AdvancedDraw] Starting a new adraw context when previous one is still rendering" .. "Shutting down rendering pipeline to prevent crashes..")
        gState.shutdown = true

        return false
    end

    _devMode = adraw.IsDeveloperMode()
    local eyePos = local_player:EyePos()
    local eyePosToPos = pos - eyePos

    -- OPTIMIZATION: Test that we are in front of the UI
    do
        local normal = angles:Up()
        local dot = eyePosToPos:Dot(normal)

        if _devMode then
            gState._devDot = dot
        end

        -- since normal is pointing away from surface towards viewer, dot<0 is visible
        if dot >= 0 then return false end
    end

    -- OPTIMIZATION: Distance based fade/hide
    if distanceHide then
        local distance = eyePosToPos:Length()
        if distance > distanceHide then return false end

        if _devMode then
            gState._devDist = distance
            gState._devHideDist = distanceHide
        end

        if distanceHide and distanceFadeStart and distance > distanceFadeStart then
            local blend = math.min(math.Remap(distance, distanceFadeStart, distanceHide, 1, 0), 1)
            render.SetBlend(blend)
            surface.SetAlphaMultiplier(blend)
        end
    end

    gState.rendering = true
    gState.pos = pos
    gState.angles = angles
    gState.scale = scale
    cam.Start3D2D(pos, angles, scale)

    -- calculate mousepos
    if not vgui.CursorVisible() or vgui.IsHoveringWorld() then
        local tr = local_player:GetEyeTrace()
        local eyepos = tr.StartPos
        local eyenormal

        if vgui.CursorVisible() and vgui.IsHoveringWorld() then
            eyenormal = gui.ScreenToVector(gui.MousePos())
        else
            eyenormal = tr.Normal
        end

        local planeNormal = angles:Up()
        local hitPos = util.IntersectRayWithPlane(eyepos, eyenormal, pos, planeNormal)

        if hitPos then
            local obstructed, obstructer = isObstructed(eyepos, hitPos, gState.entity)

            if obstructed then
                gState.mx = nil
                gState.my = nil

                if _devMode then
                    gState._devInputBlocker = "collision " .. obstructer:GetClass() .. "/" .. obstructer:EntIndex()
                end
            else
                local diff = pos - hitPos
                -- This cool code is from Willox's keypad CalculateCursorPos
                local x = diff:Dot(-angles:Forward()) / scale
                local y = diff:Dot(-angles:Right()) / scale
                gState.mx = x
                gState.my = y
            end
        else
            gState.mx = nil
            gState.my = nil

            if _devMode then
                gState._devInputBlocker = "not looking at plane"
            end
        end
    else
        gState.mx = nil
        gState.my = nil

        if _devMode then
            gState._devInputBlocker = "not hovering world"
        end
    end

    if _devMode then
        gState._renderStarted = SysTime()
    end

    return true
end

function adraw.Entity3D2D(ent, lpos, lang, scale, ...)
    gState.entity = ent
    local ret = adraw.Start3D2D(ent:LocalToWorld(lpos), ent:LocalToWorldAngles(lang), scale, ...)

    if not ret then
        gState.entity = nil
    end

    return ret
end

local function calculateRenderBounds(x, y, w, h)
    local pos = gState.pos
    local fwd, right = gState.angles:Forward(), gState.angles:Right()
    local scale = gState.scale
    local firstCorner, secondCorner = pos + fwd * x * scale + right * y * scale, pos + fwd * (x + w) * scale + right * (y + h) * scale
    local minrb, maxrb = Vector(math.huge, math.huge, math.huge), Vector(-math.huge, -math.huge, -math.huge)
    minrb.x = math.min(minrb.x, firstCorner.x, secondCorner.x)
    minrb.y = math.min(minrb.y, firstCorner.y, secondCorner.y)
    minrb.z = math.min(minrb.z, firstCorner.z, secondCorner.z)
    maxrb.x = math.max(maxrb.x, firstCorner.x, secondCorner.x)
    maxrb.y = math.max(maxrb.y, firstCorner.y, secondCorner.y)
    maxrb.z = math.max(maxrb.z, firstCorner.z, secondCorner.z)

    return minrb, maxrb
end

function adraw.ExpandRenderBoundsFromRect(x, y, w, h)
    local ent = gState.entity

    if IsValid(ent) then
        local tb = ent:GetTable()
        -- make sure we're not applying same expansion twice
        local expansion = tb._adrawRBExpansion

        if expansion then
            local ex, ey, ew, eh = unpack(expansion)
            if ex == x and ey == y and ew == w and eh == h then return end
        end

        local minrb, maxrb = calculateRenderBounds(x, y, w, h)
        ent:SetRenderBoundsWS(minrb, maxrb)

        if _devMode then
            print("[adraw] Updated renderbounds of ", ent, " to ", minrb, "x", maxrb)
        end

        tb._adrawRBExpansion = {x, y, w, h}
    else
        if _devMode then
            print("[adraw] Attempted to update renderbounds when entity is not valid!! ", debug.traceback())
        end
    end
end

local devOffset = Vector(0, 0, 30)

local devColours = {
    background = Color(0, 0, 0, 200),
    title = Color(78, 205, 196),
    mouseHovered = Color(0, 255, 0),
    mouseUnhovered = Color(255, 0, 0),
    pos = Color(255, 255, 255),
    distance = Color(200, 200, 200, 200),
    ang = Color(255, 255, 255),
    dot = Color(200, 200, 200, 200),
    angleToEye = Color(200, 200, 200, 200),
    renderTime = Color(255, 255, 255),
    renderBounds = Color(0, 0, 255)
}

local function developerText(str, x, y, clr)
    draw.SimpleText(str, "DefaultFixedDropShadow", x, y, clr, TEXT_ALIGN_CENTER, nil)
end

local function drawDeveloperInfo()
    local camAng = local_player:EyeAngles()
    camAng:RotateAroundAxis(camAng:Right(), 90)
    camAng:RotateAroundAxis(camAng:Up(), -90)
    cam.IgnoreZ(true)
    cam.Start3D2D(gState.pos + devOffset, camAng, 0.15)
        local bgCol = devColours["background"]
        surface.SetDrawColor(bgCol.r, bgCol.g, bgCol.b, bgCol.a)
        surface.DrawRect(-100, 0, 200, 140)
        local titleCol = devColours["title"]
        developerText("adraw developer", 0, 5, titleCol)
        surface.SetDrawColor(titleCol.r, titleCol.g, titleCol.b)
        surface.DrawLine(-50, 16, 50, 16)
        local mx, my = gState.mx, gState.my
    
        if mx and my then
            developerText(string.format("mouse: hovering %d x %d", mx, my), 0, 20, devColours["mouseHovered"])
        else
            developerText(string.format("mouse: %s", gState._devInputBlocker or ""), 0, 20, devColours["mouseUnhovered"])
        end
    
        local pos = gState.pos
        developerText(string.format("pos: %.2f %.2f %.2f", pos.x, pos.y, pos.z), 0, 40, devColours["pos"])
        developerText(string.format("distance %.2f / %.2f", gState._devDist or 0, gState._devHideDist or 0), 0, 53, devColours["distance"])
        local ang = gState.angles
        developerText(string.format("ang: %.2f %.2f %.2f", ang.p, ang.y, ang.r), 0, 75, devColours["ang"])
        developerText(string.format("dot %d", gState._devDot or 0), 0, 88, devColours["dot"])
        local angToEye = (pos - local_player:EyePos()):Angle()
        angToEye:RotateAroundAxis(ang:Up(), -90)
        angToEye:RotateAroundAxis(ang:Right(), 90)
        developerText(string.format("angle to eye (%d,%d,%d)", angToEye.p, angToEye.y, angToEye.r), 0, 100, devColours["angleToEye"])
        developerText(string.format("rendertime avg: %.2fms", (gState._devBenchAveraged or 0) * 1000), 0, 120, devColours["renderTime"])
    cam.End3D2D()
    cam.IgnoreZ(false)
    local ent = gState.entity

    if not IsValid(ent) then return end
    local tb = ent:GetTable()
    if not tb._adrawRBExpansion then return end
    local ex, ey, ew, eh = unpack(tb._adrawRBExpansion)
    local minrb, maxrb = calculateRenderBounds(ex, ey, ew, eh)
    render.DrawWireframeBox(vector_origin, angle_zero, minrb, maxrb, devColours["renderBounds"])
end

function adraw.End3D2D()
    if gState then
        if _devMode then
            local renderTook = SysTime() - gState._renderStarted
            gState._devBenchTests = (gState._devBenchTests or 0) + 1
            gState._devBenchTaken = (gState._devBenchTaken or 0) + renderTook

            if gState._devBenchTests == 100 then
                gState._devBenchAveraged = gState._devBenchTaken / 100
                gState._devBenchTests = 0
                gState._devBenchTaken = 0
            end
        end

        gState.rendering = false
        cam.End3D2D()
        render.SetBlend(1)
        surface.SetAlphaMultiplier(1)

        if _devMode then
            drawDeveloperInfo()
        end

        gState.entity = nil
    end
end

function adraw.CursorPos()
    local mx, my = gState.mx, gState.my

    return mx, my
end

function adraw.IsHovering(x, y, w, h)
    local mx, my = gState.mx, gState.my

    return mx and my and mx >= x and mx <= (x + w) and my >= y and my <= (y + h)
end

function adraw.IsPressing()
    return shouldAcceptInput() and gState.pressing
end

function adraw.IsPressed()
    return shouldAcceptInput() and gState.pressed
end

local _createdFonts = {}
local _adrawFontToGmodFont = {}
local EXCLAMATION_BYTE = string.byte("!")

function adraw.xFont(font, defaultSize)
    -- special font
    if string.byte(font, 1) == EXCLAMATION_BYTE then
        local existingGFont = _adrawFontToGmodFont[font]
        if existingGFont then return existingGFont end
        -- Font not cached; parse the font
        local name, size = font:match("!([^@]+)@(.+)")

        if size then
            size = tonumber(size)
        end

        if not size and defaultSize then
            name = font:match("^!([^@]+)$")
            size = defaultSize
        end

        local fontName = string.format("adraw_%s_%d", name, size)
        _adrawFontToGmodFont[font] = fontName

        if not _createdFonts[fontName] then
            surface.CreateFont(fontName, {
                font = name,
                size = size
            })

            _createdFonts[fontName] = true
        end

        return fontName
    end

    return font
end

function adraw.DrawBox(x,y,w,h,borderWidth, borderColor)
    if borderWidth > 0 then
        surface.SetDrawColor(borderColor)
        surface.DrawRect(x, y, w, borderWidth)
        surface.DrawRect(x, y + borderWidth, borderWidth, h - borderWidth * 2)
        surface.DrawRect(x, y + h - borderWidth, w, borderWidth)
        surface.DrawRect(x + w - borderWidth + 1, y, borderWidth, h)
    end
end

function adraw.xButton(x, y, w, h, borderWidth, borderClr, hoverClr, pressColor)
    local bw = borderWidth or 1
    local bgColor = adraw.IsHovering(x, y, w, h) and adraw.skin.backgroundHover or adraw.skin.background
    local borderColor = ((adraw.IsPressing() and adraw.IsHovering(x, y, w, h)) and (pressColor or adraw.skin.borderPress)) or (adraw.IsHovering(x, y, w, h) and (hoverClr or adraw.skin.borderHover)) or (borderClr or adraw.skin.border)
    surface.SetDrawColor(bgColor)
    surface.DrawRect(x, y, w, h)

    adraw.DrawBox(x,y,w,h,bw,borderColor)

    local isHovering = adraw.IsHovering(x, y, w, h)
    return shouldAcceptInput() and isHovering and gState.pressed, isHovering
end

function adraw.xOneColorButton(x, y, w, h, borderWidth, clr)
    local bw = borderWidth or 1
    surface.SetDrawColor(clr)
    surface.DrawRect(x, y, w, h)

    if bw > 0 then
        surface.SetDrawColor(clr)
        surface.DrawRect(x, y, w, bw)
        surface.DrawRect(x, y + bw, bw, h - bw * 2)
        surface.DrawRect(x, y + h - bw, w, bw)
        surface.DrawRect(x + w - bw + 1, y, bw, h)
    end

    return shouldAcceptInput() and adraw.IsHovering(x, y, w, h) and gState.pressed
end

function adraw.xCursor(x, y, w, h)
    local fgColor = adraw.IsPressing() and adraw.skin.foregroundPress or adraw.skin.foreground
    local mx, my = gState.mx, gState.my
    if not mx or not my then return end
    if x and w and (mx < x or mx > x + w) then return end
    if y and h and (my < y or my > y + h) then return end
    local cursorSize = math.ceil(0.3 / gState.scale)
    surface.SetDrawColor(fgColor)
    surface.DrawLine(mx - cursorSize, my, mx + cursorSize, my)
    surface.DrawLine(mx, my - cursorSize, mx, my + cursorSize)
end

function adraw.xTextButton(text, font, x, y, w, h, borderWidth, color, hoverClr, pressColor)
    local fgColor = ((adraw.IsPressing() and adraw.IsHovering(x, y, w, h)) and (pressColor or adraw.skin.foregroundPress)) or (adraw.IsHovering(x, y, w, h) and (hoverClr or adraw.skin.foregroundHover)) or (color or adraw.skin.foreground)
    local clicked = adraw.xButton(x, y, w, h, borderWidth, color, hoverClr, pressColor)
    font = adraw.xFont(font, math.floor(h * 0.618))
    draw.SimpleText(text, font, x + w / 2, y + h / 2, fgColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)

    return clicked
end

function adraw.xConButton(x, y, w, h, borderWidth, color, hoverClr, pressColor, conColor, condition)
    local fgColor
    local clicked
    if condition then
        fgColor = conColor
        clicked = adraw.xOneColorButton(x, y, w, h, borderWidth, conColor)
    else
        fgColor = ((adraw.IsPressing() and adraw.IsHovering(x, y, w, h)) and (pressColor or adraw.skin.foregroundPress)) or (adraw.IsHovering(x, y, w, h) and (hoverClr or adraw.skin.foregroundHover)) or (color or adraw.skin.foreground)
        clicked = adraw.xButton(x, y, w, h, borderWidth, color, hoverClr, pressColor)
    end

    return clicked
end

function adraw.xSymbolButton(symbol, x, y, w, h, borderWidth, color, hoverClr, pressColor)
    local fgColor = ((adraw.IsPressing() and adraw.IsHovering(x, y, w, h)) and (pressColor or adraw.skin.foregroundPress)) or (adraw.IsHovering(x, y, w, h) and (hoverClr or adraw.skin.foregroundHover)) or (color or adraw.skin.foreground)
    local clicked = adraw.xButton(x, y, w, h, borderWidth, color, hoverClr, pressColor)
    surface.SetMaterial(symbol)
    surface.SetDrawColor(fgColor)
    surface.DrawTexturedRect(x, y, w, h)

    return clicked
end

function adraw.xDrawLine(x, y, x2, y2, sz)
    local midX = (x + x2) / 2
    local midY = (y + y2) / 2

    local dx = x2 - x
    local dy = y2 - y
    local ang = -math.deg(math.atan2(dy, dx))

    local len = math.sqrt((x2 - x) ^ 2 + (y2 - y) ^ 2)
    draw.NoTexture()
    surface.DrawTexturedRectRotated(midX, midY, len, sz, ang)
end

local cached = {}

function adraw.Arc(cx, cy, radius, thickness, startang, endang, roughness, color)
    local arc = tostring(cx) .. tostring(cy) .. tostring(radius) .. tostring(thickness) .. tostring(startang) .. tostring(endang) .. tostring(roughness)
    surface.SetDrawColor(color)
    draw.NoTexture()

    if (cached[arc] == nil) then
        cached[arc] = adraw.PrecacheArc(cx, cy, radius, thickness, startang, endang, roughness)
    end

    adraw.DrawArc(cached[arc])
end

function adraw.PrecacheArc(cx, cy, radius, thickness, startang, endang, roughness)
    local triarc = {}
    local roughness = math.max(roughness or 1, 1)
    local step = roughness
    local startang, endang = startang or 0, endang or 0

    if startang > endang then
        step = math.abs(step) * -1
    end

    local inner = {}
    local r = radius - thickness

    for deg = startang, endang, step do
        local rad = math.rad(deg)
        local ox, oy = cx + (math.cos(rad) * r), cy + (-math.sin(rad) * r)

        table.insert(inner, {
            x = ox,
            y = oy,
            u = (ox - cx) / radius + .5,
            v = (oy - cy) / radius + .5,
        })
    end

    local outer = {}

    for deg = startang, endang, step do
        local rad = math.rad(deg)
        local ox, oy = cx + (math.cos(rad) * radius), cy + (-math.sin(rad) * radius)

        table.insert(outer, {
            x = ox,
            y = oy,
            u = (ox - cx) / radius + .5,
            v = (oy - cy) / radius + .5,
        })
    end

    for tri = 1, #inner * 2 do
        local p1, p2, p3
        p1 = outer[math.floor(tri / 2) + 1]
        p3 = inner[math.floor((tri + 1) / 2) + 1]

        if tri % 2 == 0 then
            p2 = outer[math.floor((tri + 1) / 2)]
        else
            p2 = inner[math.floor((tri + 1) / 2)]
        end

        table.insert(triarc, {p1, p2, p3})
    end

    return triarc
end

function adraw.DrawArc(arc)
    for _, v in ipairs(arc) do
        surface.DrawPoly(v)
    end
end

function adraw.DrawTexturedRectRotatedPoint( x, y, w, h, rot, x0, y0 )
    local c = math.cos( math.rad( rot ) )
    local s = math.sin( math.rad( rot ) )

    local newx = y0 * s - x0 * c
    local newy = y0 * c + x0 * s

    surface.DrawTexturedRectRotated( x + newx, y + newy, w, h, rot )
end

local matBlurScreen = Material("pp/blurscreen")
function adraw.Derma_DrawPanelBlur(panel, color)
    color = color or Color(10,10,10,100)
    local x, y = panel:LocalToScreen( 0, 0 )

    -- Menu cannot do blur
    if ( not MENU_DLL ) then
        surface.SetMaterial( matBlurScreen )
        surface.SetDrawColor( 255, 255, 255, 255 )

        for i = 0.33, 1, 0.33 do
            matBlurScreen:SetFloat( "$blur", 5 * i )
            matBlurScreen:Recompute()
            if ( render ) then
                render.UpdateScreenEffectTexture()
            end
            surface.DrawTexturedRect( x * -1, y * -1, ScrW(), ScrH() )
        end
    end

    surface.SetDrawColor(color)
    surface.DrawRect( x * -1, y * -1, ScrW(), ScrH() )
end

return adraw

--addons/starwars_universe/lua/star-wars-universe/client/vgui/tabs/cl_swu_basetab.lua:
local PANEL = {}

function PANEL:Init()
    local parent = self:GetParent()
    self:SetSize(parent:GetWide(), parent:GetTall())
    self:SetBackgroundColor(Color(50,50,50,100))

    local padding = self:GetWide() * 0.02
    self:DockPadding(padding, padding * 0.25, padding, padding * 0.25)
end

vgui.Register("swu_basetab", PANEL, "swu_basepanel")
--addons/starwars_universe/lua/libs/netdata.lua:
-- Source Code: https://github.com/wyozi-gmod/netdata

local Entity = FindMetaTable("Entity")

if SERVER then
    function Entity:NetDataUpdate()
        net.Start("netdata")
        net.WriteEntity(self)
        net.WriteUInt(self.NetDataHash and tonumber(util.CRC(self:NetDataHash())) or 0, 32)
        self:NetDataWrite()
        net.SendPVS(self:LocalToWorld(self:OBBCenter()))
    end

    util.AddNetworkString("netdata")

    net.Receive("netdata", function(len, cl)
        local ent = net.ReadEntity()
        local prevHash = net.ReadUInt(32)

        if not IsValid(ent) then return end

        local tb = ent:GetTable()

        if not tb.NetDataWrite then return end

        local curHash = tb.NetDataHash and tonumber(util.CRC(ent:NetDataHash())) or 0

        if curHash == 0 or prevHash == 0 or curHash ~= prevHash then
            net.Start("netdata")
            net.WriteEntity(ent)
            net.WriteUInt(curHash, 32)
            ent:NetDataWrite()
            net.Send(cl)
        end
    end)
end

if CLIENT then
    hook.Add("NotifyShouldTransmit", "NetDataRequest", function(e, should)
        if not should then return end

        local tb = e:GetTable()

        if not tb.NetDataRead then return end

        local prevHash = tb._NetDataPrevHash or 0
        net.Start("netdata")
        net.WriteEntity(e)
        net.WriteUInt(prevHash, 32)
        net.SendToServer()

        if cvars.Number("developer") > 0 then
            print("[NetData] Asking for netdata due to PVS for " .. tostring(e) .. " using hash " .. prevHash)
        end
    end)

    hook.Add("NetworkEntityCreated", "NetDataRequest", function(e)
        local sent = scripted_ents.GetStored(e:GetClass())

        if e:GetTable().NetDataRead or (sent and sent.t and sent.t.NetDataRead) then
            net.Start("netdata")
            net.WriteEntity(e)
            net.WriteUInt(0, 32)
            net.SendToServer()

            if cvars.Number("developer") > 0 then
                print("[NetData] Asking for netdata due to NEC for " .. tostring(e))
            end
        end
    end)

    net.Receive("netdata", function(len, cl)
        local ent = net.ReadEntity()
        local hash = net.ReadUInt(32)

        if IsValid(ent) then
            if cvars.Number("developer") > 0 then
                print("[NetData] Received netdata for " .. tostring(ent) .. " with hash " .. hash)
            end

            ent:NetDataRead()
            ent:GetTable()._NetDataPrevHash = hash
        end
    end)
end

if SERVER then
    util.AddNetworkString("entaction")

    net.Receive("entaction", function(len, cl)
        local ent = net.ReadEntity()

        if IsValid(ent) and ent:GetTable().ReceiveNetAction then
            ent:ReceiveNetAction(cl)
        end
    end)
end

if CLIENT then
    function Entity:StartNetAction(unreliable)
        net.Start("entaction", unreliable)
        net.WriteEntity(self)
    end
end

--addons/starwars_universe/lua/star-wars-universe/shared/sh_swu_util.lua:
SWU = SWU or {}
SWU.Util = SWU.Util or {}

local function VectorFromTable(tbl)
    return Vector(tbl[1], tbl[2], tbl[3])
end

local function VectorCenter(min, max)
    return Vector((min.x + max.x) * 0.5, (min.y + max.y) * 0.5, (min.z + max.z) * 0.5)
end

function SWU.Util:MeasureSkybox(pos)
    local lineLength = 10240

    local min, max = {}, {}
    for i = 1, 3 do
        for j = 1, 2 do
            local modifier = 1
            if (j == 1) then
                modifier = -1
            end

            local endpos = pos:ToTable()
            endpos[i] = endpos[i] + lineLength * modifier
            local trace = {
                start = pos,
                endpos = VectorFromTable(endpos),
                filter = function (ent) return false end
            }
            trace = util.TraceLine(trace)

            if (j == 1) then
                min[i] = trace.HitPos:ToTable()[i]
            else
                max[i] = trace.HitPos:ToTable()[i]
            end
        end
    end

    min, max = VectorFromTable(min), VectorFromTable(max)
    return min, max, VectorCenter(min, max)
end

local function disableFog()
    render.FogMode(MATERIAL_FOG_LINEAR)
    render.FogMaxDensity(0)
    return true
end

function SWU.Util:DisableFog()
    hook.Add("SetupWorldFog", "SWU_DisableWorldFog", disableFog)
    hook.Add("SetupSkyboxFog", "SWU_DisableSkyboxFog", disableFog)
end

function SWU.Util:DisableSun()
    local list = ents.FindByClass("env_sun")
    if (#list > 0) then
        local sun = list[1]
        sun:SetKeyValue("size", 0)
        sun:SetKeyValue("overlaysize", 0)
    end
end

local function chunkFloor(n)
    local f = (n - (n % SWU.GlobalConfig.chunkSize)) / SWU.GlobalConfig.chunkSize
    if (f == -0) then
        f = 0
    end
    return f
end

function SWU.Util:ChunkToVector(chunk)
    local s = string.Split(chunk, ":")
    return Vector(s[1] * SWU.GlobalConfig.chunkSize, s[2] * SWU.GlobalConfig.chunkSize, 0)
end

function SWU.Util:VectorToChunk(vector)
    return chunkFloor(vector.x) .. ":" .. chunkFloor(vector.y)
end

function SWU:CalculateWorldPos(universePos)
    local shipWorldPos = self.Controller:GetPos()
    local shipPos = self.Controller:GetShipPos()
    local shipAngles = self.Controller:GetInternalShipAngles()
    local scale = self.config.scale or 1

    local worldPos = (universePos - shipPos) * scale
    worldPos:Rotate(shipAngles)
    worldPos = shipWorldPos + worldPos

    local absoluteWorldPos = Vector(worldPos)
    absoluteWorldPos:Rotate(-shipAngles)
    return worldPos, absoluteWorldPos
end

function SWU:CalculateMovement(currentPos, currentAngle, currentPercentAcceleration, maxAcceleration)
    return currentPos + (maxAcceleration * FrameTime() * currentPercentAcceleration * currentAngle:Forward() * Vector(1,-1,0))
end
--lua/autorun/sh_vmenu.lua:
--[[ 
	 _    __      ____              _     _          __  ___                
	| |  / /___ _/ / /____  _______(_)__ ( )_____   /  |/  /__  ____  __  __
	| | / / __ `/ / //_/ / / / ___/ / _ \|// ___/  / /|_/ / _ \/ __ \/ / / /
	| |/ / /_/ / / ,< / /_/ / /  / /  __/ (__  )  / /  / /  __/ / / / /_/ / 
	|___/\__,_/_/_/|_|\__, /_/  /_/\___/ /____/  /_/  /_/\___/_/ /_/\__,_/  
	                 /____/                                                 
	v2.0
]]--

g_vMenuVer = "2.0"
g_vMenuAddons = g_vMenuAddons or {}

if (SERVER) then
	AddCSLuaFile( "sh_vmenu.lua" )
end

if (CLIENT) then
	function ScaleToWideScreen( size )
		return math.min(math.max( ScreenScale(size / 2.62467192), math.min(size, 14) ), size)
	end

	surface.CreateFont( "VAddonsCredits",  {font='Roboto Condensed', size=ScaleToWideScreen(22), weight=500, antialias=true, additive=false})
	surface.CreateFont( "VAddonsHeader",  {font='Roboto Condensed', size=ScaleToWideScreen(26), weight=500, antialias=true, additive=false})
	surface.CreateFont( "VAddonsMenuBar",  {font='Roboto Condensed', size=ScaleToWideScreen(20), weight=500, antialias=true, additive=false})
	
	local TitleBarSize = 35
	list.Set( "DesktopWindows", "GmodLegsEditor", 
	{
		title		= "VAddons",
		icon		= "icon64/playermodel.png",
		width	   	= 960,
		height	  	= 700,
		onewindow   = true,
		init		= function( icon, window )

			window:SetTitle("")
			window.Paint = function()
				draw.RoundedBox(0, 0, 0, window:GetWide(), window:GetTall(), Color( 37, 37, 37, 255 ) )
				draw.RoundedBox(0, 0, 0, window:GetWide(), TitleBarSize, Color( 50, 50, 50, 255 ))
				draw.SimpleText("Valkyrie's Addons", "VAddonsMenuBar", window:GetWide()/2, TitleBarSize/2 -2, Color(142, 142, 142), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)	
			end

			local tabs = vgui.Create( "DPropertySheet", window )
			tabs.Paint = function(this, w, h)
				draw.RoundedBox(0, 0, 0, w, h, Color( 37, 37, 37, 255 ) )
			end
			tabs.AddSheet = function(this, label, panel, material, NoStretchX, NoStretchY, Tooltip )
				if ( !IsValid( panel ) ) then
					ErrorNoHalt( "DPropertySheet:AddSheet tried to add invalid panel!" )
					debug.Trace()
					return
				end

				local Sheet = {}

				Sheet.Name = label

				Sheet.Tab = vgui.Create( "DTab", this )
				Sheet.Tab.Paint = function(_tab, w, h)
					if ( _tab:IsActive() ) then
						draw.RoundedBox(0, 0, 0, w, h, Color( 30, 30, 30 ) )
						return
					end
					draw.RoundedBox(0, 0, 0, w, h, Color( 45, 45, 45 ) )
				end
				Sheet.Tab.GetTabHeight = function(_tab, w, h)
					return 48
				end

				Sheet.Tab:Setup( label, this, panel, material )

				Sheet.Panel = panel
				Sheet.Panel.NoStretchX = NoStretchX
				Sheet.Panel.NoStretchY = NoStretchY
				Sheet.Panel:SetPos( this:GetPadding(), 20 + this:GetPadding() )
				Sheet.Panel:SetVisible( false )

				panel:SetParent( this )

				table.insert( this.Items, Sheet )

				if ( !this:GetActiveTab() ) then
					this:SetActiveTab( Sheet.Tab )
					Sheet.Panel:SetVisible( true )
				end

				this.tabScroller:AddPanel( Sheet.Tab )

				return Sheet
			end
			tabs:SetPos(0, TitleBarSize)
			tabs:SetSize(window:GetWide(), window:GetTall() - TitleBarSize)
			tabs:SetPadding(0)
			
			hook.Run( "GetVMenuTabs", window, tabs )	
		end
	} )
end	
--addons/shieldgenerator/lua/autorun/shield2.lua:
if SERVER then return end

CDRAW1 = CDRAW1 or {}

local circle_cache = {}

function CDRAW1.DrawCircle(x,y,radius,seg)
	local segstr = x..y..radius..seg
	if circle_cache[segstr] then
		surface.DrawPoly(circle_cache[segstr])
	else
		local cir = {}
		cir[#cir+1] = {x=x,y=y,u=0.5,v=0.5}
		for i = 0, seg do
			local a = math.rad((i/seg)*-360)
			cir[#cir+1] = {x=x+math.sin(a)*radius,y=y+math.cos(a)*radius,u=math.sin(a)/2+0.5,v=math.cos(a)/2+0.5}
		end
		local a = math.rad(0)
		cir[#cir+1] = {x=x+math.sin(a)*radius,y=y+math.cos(a)*radius,u=math.sin(a)/2+0.5,v=math.cos(a)/2+0.5}
		circle_cache[segstr] = cir
		surface.DrawPoly(cir)
	end
end

function CDRAW1.DrawRect(col,x,y,w,h)
	x, y = math.Round(x), math.Round(y)
	w, h = math.Round(w), math.Round(h)
	surface.SetDrawColor(col.r,col.g,col.b,col.a)
	surface.DrawRect(x,y,w,h)
end

function CDRAW1.GetTextSize(...)
	local aye = {...}
	surface.SetFont(aye[1])
	local legx, legy = 0, 0
	for i = 2, #aye do
		if isstring(aye[i]) then
			local xd, yd = surface.GetTextSize(tostring(aye[i]))
			legx = legx + xd
			legy = legy > yd and legy or yd
		end
	end
	return legx, legy
end

function CDRAW1.DrawText(...)
	local aye = {...}
	surface.SetFont(aye[1])
	aye[2], aye[3] = math.Round(aye[2]), math.Round(aye[3])
	local oldx, oldy = 0, 0
	for i = 4, #aye do
		if istable(aye[i]) then
			surface.SetTextColor(aye[i].r,aye[i].g,aye[i].b,aye[i].a)
		else
			surface.SetTextPos(aye[2]+oldx,aye[3])
			surface.DrawText(aye[i])
			local _ox, _oy = surface.GetTextSize(aye[i])
			oldx, oldy = oldx+_ox, oldy+_oy
		end
	end
end

function CDRAW1.DrawNiceText(Col,Off,Font,Text)
	local sw, sh = CDRAW1.GetTextSize(Font,Text)
	CDRAW1.DrawText(Font..'_blur',-sw/2,-sh/2-Off,Col,Text)
	CDRAW1.DrawText(Font,-sw/2,-sh/2-Off,Col,Text)
end

return CDRAW1
--lua/autorun/smartsnap.lua:
--[[


Written by Syranide, me@syranide.com
fixed and updated by minifisch, mail@minifisch.net
big thanks to Syranide! :)


]]
--
if SERVER then
    AddCSLuaFile()
end

if CLIENT then
    local target = {
        active = false
    }

    local snaptarget = {
        active = false
    }

    local snapkey = false
    local snaptime = false
    local snaplock = false
    local snapclick = false
    local snapclickfade = 0
    local snapcursor = false
    local snapspawnmenu = false

    local cache = {
        vPlayerPos = 0,
        vLookPos = 0,
        vLookClipPos = 0,
        vLookVector = 0
    }

    local condefs = {
        snap_enabled = 1,
        snap_gcboost = 1,
        snap_gcstrength = 125,
        snap_hidegrid = 0,
        snap_clickgrid = 0,
        snap_toggledelay = 0,
        snap_disableuse = 0,
        snap_allentities = 0,
        snap_alltools = 0,
        snap_enabletoggle = 0,
        snap_lockdelay = 0.5,
        snap_distance = 250,
        snap_gridlimit = 16,
        snap_gridsize = 8,
        snap_gridalpha = 0.4,
        snap_gridoffset = 0.5,
        snap_boundingbox = 1,
        snap_revertaim = 1,
        snap_centerline = 1
    }

    local convars = {}

    for key, value in pairs(condefs) do
        convars[#convars + 1] = key
    end

    local modelsaveset = {}
    local modeloffsets = {}

    local function DrawScreenLine(vsA, vsB)
        surface.DrawLine(vsA.x, vsA.y, vsB.x, vsB.y)
    end

    local function ToScreen(vWorld)
        local vsScreen = vWorld:ToScreen()

        return Vector(vsScreen.x, vsScreen.y, 0)
    end

    local function PointToScreen(vPoint)
        if cache.vLookVector:DotProduct(vPoint - cache.vLookClipPos) > 0 then return ToScreen(vPoint) end
    end

    local function LineToScreen(vStart, vEnd)
        local dotStart = cache.vLookVector:DotProduct(vStart - cache.vLookClipPos)
        local dotEnd = cache.vLookVector:DotProduct(vEnd - cache.vLookClipPos)

        if dotStart > 0 and dotEnd > 0 then
            return ToScreen(vStart), ToScreen(vEnd)
        elseif dotStart > 0 or dotEnd > 0 then
            local vLength = vEnd - vStart
            local vIntersect = vStart + vLength * ((cache.vLookClipPos:DotProduct(cache.vLookVector) - vStart:DotProduct(cache.vLookVector)) / vLength:DotProduct(cache.vLookVector))

            if dotStart <= 0 then
                return ToScreen(vIntersect), ToScreen(vEnd)
            else
                return ToScreen(vStart), ToScreen(vIntersect)
            end
        end
    end

    local function RayQuadIntersect(vOrigin, vDirection, vPlane, vX, vY)
        local vp = vDirection:Cross(vY)
        local d = vX:DotProduct(vp)
        if (d <= 0.0) then return end
        local vt = vOrigin - vPlane
        local u = vt:DotProduct(vp)
        if (u < 0.0 or u > d) then return end
        local v = vDirection:DotProduct(vt:Cross(vX))
        if (v < 0.0 or v > d) then return end

        return Vector(u / d, v / d, 0)
    end

    local function OnInitialize()
        for key, value in pairs(condefs) do
            CreateClientConVar(key, value, true, false)
        end

        for _, filename in ipairs(file.Find('smartsnap_offsets_*.png', "GAME")) do
            local file = file.Read(filename)

            if file then
                lines = string.Explode("\n", file)
                header = table.remove(lines, 1)

                if header == "SMARTSNAP_OFFSETS" then
                    for _, line in ipairs(lines) do
                        local pos = string.find(line, '=')

                        if pos then
                            local key = string.lower(string.Trim(string.sub(line, 1, pos - 1)))
                            local value = string.Trim(string.sub(line, pos + 1))
                            local c = string.Explode(",", value)
                            modeloffsets[key] = {tonumber(c[1]), tonumber(c[2]), tonumber(c[3]), tonumber(c[4]), tonumber(c[5]), tonumber(c[6])}
                        end
                    end
                end
            end
        end
    end

    local function OnShutDown()
        output = file.Read('smartsnap_offsets_custom.png')

        if output == nil then
            output = "SMARTSNAP_OFFSETS\n"
        end

        for model, _ in pairs(modelsaveset) do
            output = output .. model .. '=' .. table.concat(modeloffsets[model], ",") .. "\n"
        end

        file.Write('smartsnap_offsets_custom.png', output)
    end

    local function GetDevOffset()
        local model = string.lower(target.entity:GetModel())

        if modeloffsets[model] == nil then
            modeloffsets[model] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}
        end

        return modeloffsets[model]
    end

    concommand.Add("snap_dev_alloffset", function(player, command, arguments)
        if target.active == true then
            if #arguments >= 1 then
                local v = GetDevOffset()

                for i = 1, 6 do
                    v[i] = v[i] + tonumber(arguments[1])
                end
            end
        end
    end)

    concommand.Add("snap_dev_gridoffset", function(player, command, arguments)
        if target.active == true then
            if #arguments >= 1 then
                local v = GetDevOffset()
                v[target.face] = v[target.face] + tonumber(arguments[1])
            end
        end
    end)

    concommand.Add("snap_dev_saveoffset", function(player, command, arguments)
        if target.active == true then
            local v = GetDevOffset()
            modelsaveset[string.lower(target.entity:GetModel())] = true
        end
    end)

    local function SnapToggleGrid()
        if (GetConVarNumber("snap_enabled") == 0) then
            RunConsoleCommand('snap_enabled', '1')
        else
            RunConsoleCommand('snap_enabled', '0')
        end
    end

    local function SnapPress()
        if GetConVarNumber("snap_clickgrid") ~= 0 and not snapclick then
            snapclick = true
            snapclickfade = CurTime()
        elseif GetConVarNumber("snap_clickgrid") == 0 or snapclick then
            if (snaplock or snapcursor) then
                snaptime = false
            else
                local toggledelay = GetConVarNumber("snap_toggledelay")

                if (toggledelay > 0 and snaptime and snaptime + toggledelay > CurTime()) then
                    SnapToggleGrid()
                    snaptime = false
                    snaplock = false
                else
                    snaptime = CurTime()
                end
            end

            snapkey = target.active

            if (not snapcursor) then
                snaplock = false
            end
        end
    end

    local function SnapRelease()
        snapkey = false
    end

    local function SnapLock()
        snaplock = not snaplock
    end

    local function OnSpawnMenu()
        snapspawnmenu = true
    end

    local function OnKeyPress(player, key)
        if (key == IN_USE and GetConVarNumber("snap_disableuse") == 0) then
            SnapPress()
        end
    end

    local function OnKeyRelease(player, key)
        if (key == IN_USE and GetConVarNumber("snap_disableuse") == 0) then
            SnapRelease()
        end
    end

    local function OnThink()
        if (vgui.CursorVisible()) then
            if (not snapcursor and snaplock) then
                snaptarget = table.Copy(target)
            end

            snaptime = false
            snapcursor = true
        else
            if (snapcursor and snaplock) then
                target = snaptarget
            end

            snapspawnmenu = false
            snapcursor = false
        end

        if (GetConVarNumber("snap_enabletoggle") ~= 0) then
            if (snapkey and snaptime and not snaplock) then
                if (CurTime() > snaptime + GetConVarNumber("snap_lockdelay")) then
                    snaplock = true
                    snaptime = false
                end
            end
        end

        local locked = target.locked and target.active
        target.locked = (snapkey or snaplock and not snapcursor) and target.active

        if (not target.locked and locked and GetConVarNumber("snap_revertaim") ~= 0) then
            if (snapcursor) then
                local screen = target.entity:LocalToWorld(target.vector):ToScreen()
                gui.SetMousePos(math.Round(screen.x), math.Round(screen.y))
            else
                local angles = (target.entity:LocalToWorld(target.vector) - LocalPlayer():GetShootPos()):Angle()
                LocalPlayer():SetEyeAngles(angles)
            end
        end
    end

    local function CalculateGridAxis(L)
        local length = L:Length()
        local grid = math.Clamp(math.floor(length / (2 * GetConVarNumber("snap_gridsize"))) * 2, 2, GetConVarNumber("snap_gridlimit"))
        local offset = math.Clamp(GetConVarNumber("snap_gridoffset") / length, 0, 1 / grid)
        local scale = 1 - offset * 2

        return {
            length = length,
            offset = offset,
            scale = scale,
            grid = grid
        }
    end

    local function CalculateSnap(X, Y, v)
        local LX = CalculateGridAxis(X)
        local LY = CalculateGridAxis(Y)
        local BX = math.Clamp(math.Round(v.x * LX.grid), 0, LX.grid)
        local BY = math.Clamp(math.Round(v.y * LY.grid), 0, LY.grid)

        if BX == 1 and v.x < (1 / LX.grid + LX.offset) / 2 then
            BX = 0
        end

        if BX == LX.grid - 1 and v.x > 1 - (1 / LX.grid + LX.offset) / 2 then
            BX = LX.grid
        end

        if BY == 1 and v.y < (1 / LY.grid + LY.offset) / 2 then
            BY = 0
        end

        if BY == LY.grid - 1 and v.y > 1 - (1 / LY.grid + LY.offset) / 2 then
            BY = LY.grid
        end

        local RX = X * (BX / LX.grid)
        local RY = Y * (BY / LY.grid)

        if BX == 0 then
            RX = X * math.Clamp(LX.offset, 0, 1 / LX.grid)
        end

        if BX == LX.grid then
            RX = X * (1 - math.Clamp(LX.offset, 0, 1 / LX.grid))
        end

        if BY == 0 then
            RY = Y * math.Clamp(LY.offset, 0, 1 / LY.grid)
        end

        if BY == LY.grid then
            RY = Y * (1 - math.Clamp(LY.offset, 0, 1 / LY.grid))
        end

        return RX + RY
    end

    local function DrawGridLines(vOrigin, vSX, vSY, gridLines, offsetX, offsetY, sign)
        local centerline = (GetConVarNumber("snap_centerline") ~= 0)
        local vTemp = vOrigin + vSX * 0.5
        local vX = vTemp + vSY * (offsetY)
        local vY = vTemp + vSY * (1 - offsetY)
        local vOffset, temp
        local xtemp = ToScreen(vX) - ToScreen(vY)
        xtemp:Normalize()
        local vsNormal = xtemp

        if math.abs(vsNormal.x) < 1 - math.abs(vsNormal.y) then
            temp = -0.5 * sign
        else
            temp = 0.5 * sign
        end

        if math.abs(vsNormal.x) < math.abs(vsNormal.y) then
            vsOffset = Vector(temp, 0, 0)
        else
            vsOffset = Vector(0, temp, 0)
        end

        if offsetX < 1 / gridLines then
            local vTemp = vOrigin + vSX * offsetX
            local vX = vTemp + vSY * offsetY
            local vY = vTemp + vSY * (1 - offsetY)
            local vsX, vsY = LineToScreen(vX, vY)

            if (vsX) then
                DrawScreenLine(vsX + vsOffset, vsY + vsOffset)
            end
        end

        for i = 1, gridLines - 1 do
            local vTemp = vOrigin + vSX * (i / gridLines)
            local vX = vTemp + vSY * offsetY
            local vY = vTemp + vSY * (1 - offsetY)
            local vsX, vsY = LineToScreen(vX, vY)

            if (vsX) then
                if (gridLines / i == 2 and centerline) then
                    DrawScreenLine(vsX + vsOffset * -1, vsY + vsOffset * -1)
                    DrawScreenLine(vsX + vsOffset * 3, vsY + vsOffset * 3)
                else
                    DrawScreenLine(vsX + vsOffset, vsY + vsOffset)
                end
            end
        end

        if offsetX < 1 / gridLines then
            local vTemp = vOrigin + vSX * (1 - offsetX)
            local vX = vTemp + vSY * offsetY
            local vY = vTemp + vSY * (1 - offsetY)
            local vsX, vsY = LineToScreen(vX, vY)

            if (vsX) then
                DrawScreenLine(vsX + vsOffset, vsY + vsOffset)
            end
        end
    end

    local function DrawGrid(vOrigin, vSX, vSY)
        local LX = CalculateGridAxis(vSX)
        local LY = CalculateGridAxis(vSY)
        surface.SetDrawColor(0, 0, 0, math.Round(GetConVarNumber("snap_gridalpha") * 255))
        DrawGridLines(vOrigin, vSX, vSY, LX.grid, LX.offset, LY.offset, 1)
        DrawGridLines(vOrigin, vSY, vSX, LY.grid, LY.offset, LX.offset, 1)
        surface.SetDrawColor(255, 255, 255, math.Round(GetConVarNumber("snap_gridalpha") * 255))
        DrawGridLines(vOrigin, vSX, vSY, LX.grid, LX.offset, LY.offset, -1)
        DrawGridLines(vOrigin, vSY, vSX, LY.grid, LY.offset, LX.offset, -1)
    end

    local function DrawBoundaryLines(vOrigin, vOpposite)
        local vPoint

        if (vOrigin:Distance(vOpposite) > 5) then
            local x = vOpposite - vOrigin
            x:Normalize()
            vPoint = vOrigin + x * 5
        else
            vPoint = vOrigin + (vOpposite - vOrigin) / 2
        end

        local vsA, vsB = LineToScreen(vPoint, vOrigin)

        if (vsA) then
            surface.SetDrawColor(0, 0, 255, 192)
            DrawScreenLine(vsA, vsB)
        end
    end

    local function DrawBoundary(vOrigin, vX, vY, vZ)
        DrawBoundaryLines(vOrigin, vX)
        DrawBoundaryLines(vOrigin, vY)
        DrawBoundaryLines(vOrigin, vZ)
    end

    local function DrawSnapCross(vsCenter, r, g, b)
        surface.SetDrawColor(0, 0, 0, 255)
        DrawScreenLine(vsCenter + Vector(-2.5, -2.0), vsCenter + Vector(2.5, 3.0))
        DrawScreenLine(vsCenter + Vector(1.5, -2.0), vsCenter + Vector(-3.5, 3.0))
        surface.SetDrawColor(r, g, b, 255)
        DrawScreenLine(vsCenter + Vector(-1.5, -2.0), vsCenter + Vector(3.5, 3.0))
        DrawScreenLine(vsCenter + Vector(2.5, -2.0), vsCenter + Vector(-2.5, 3.0))
    end

    local function ComputeEdges(entity, obbmax, obbmin)
        return {
            lsw = entity:LocalToWorld(Vector(obbmin.x, obbmin.y, obbmin.z)),
            lse = entity:LocalToWorld(Vector(obbmax.x, obbmin.y, obbmin.z)),
            lnw = entity:LocalToWorld(Vector(obbmin.x, obbmax.y, obbmin.z)),
            lne = entity:LocalToWorld(Vector(obbmax.x, obbmax.y, obbmin.z)),
            usw = entity:LocalToWorld(Vector(obbmin.x, obbmin.y, obbmax.z)),
            use = entity:LocalToWorld(Vector(obbmax.x, obbmin.y, obbmax.z)),
            unw = entity:LocalToWorld(Vector(obbmin.x, obbmax.y, obbmax.z)),
            une = entity:LocalToWorld(Vector(obbmax.x, obbmax.y, obbmax.z))
        }
    end

    local function OnPaintHUD()
        target.active = false
        if GetConVarNumber("snap_clickgrid") ~= 0 and not snapclick then return end
        snapclickprev = snapclick
        snapclick = snapclickprev and snapclickfade > CurTime()
        if (GetConVarNumber("snap_enabled") == 0) then return end
        if (not LocalPlayer():Alive() or LocalPlayer():InVehicle()) then return end

        if (target.locked) then
            if (not target.entity:IsValid()) then return end
        else
            local trace = LocalPlayer():GetEyeTrace()
            cache.vLookTrace = trace
            if (not trace.HitNonWorld) then return end
            local entity = trace.Entity
            if (entity == nil) then return end
            if (not entity:IsValid()) then return end
            local class = entity:GetClass()
            if (class ~= 'prop_physics' and class ~= 'phys_magnet' and class ~= 'gmod_spawner' and GetConVarNumber('snap_allentities') == 0 or class == 'player') then return end
            if (not LocalPlayer():GetActiveWeapon():IsValid()) then return end
            if (LocalPlayer():GetActiveWeapon():GetClass() == 'weapon_physgun') then return end
            if (LocalPlayer():GetActiveWeapon():GetClass() ~= 'gmod_tool' and GetConVarNumber('snap_alltools') == 0) then return end
            target.entity = entity
        end

        --ErrorNoHalt(collectgarbage("count"))
        if GetConVarNumber("snap_gcboost") ~= 0 then
            collectgarbage("step", GetConVarNumber("snap_gcstrength"))
        end

        snapclick = snapclickprev
        snapclickfade = CurTime() + 0.25
        -- updating the cache perhaps shouldn't be done here, CalcView?
        cache.vLookPos = LocalPlayer():GetShootPos()
        cache.vLookVector = LocalPlayer():GetAimVector()
        cache.vLookClipPos = cache.vLookPos + cache.vLookVector * 3
        local model = string.lower(target.entity:GetModel())
        local offsets = modeloffsets[model]

        if not offsets then
            local offset = 0.25
            offsets = {offset, offset, offset, offset, offset, offset}
        end

        if cache.eEntity ~= target.entity or cache.vEntAngles ~= target.entity:GetAngles() or vEntPosition ~= target.entity:GetPos() then
            cache.eEntity = target.entity
            cache.vEntAngles = target.entity:GetAngles()
            cache.vEntPosition = target.entity:GetPos()
            local obbmax = target.entity:OBBMaxs()
            local obbmin = target.entity:OBBMins()
            local obvsnap = ComputeEdges(target.entity, obbmax, obbmin)
            local obbmax = target.entity:OBBMaxs() - Vector(offsets[5], offsets[3], offsets[1])
            local obbmin = target.entity:OBBMins() + Vector(offsets[6], offsets[4], offsets[2])
            local obvgrid = ComputeEdges(target.entity, obbmax, obbmin)
            local faces = {{obvgrid.unw, obvgrid.usw - obvgrid.unw, obvgrid.une - obvgrid.unw, obvgrid.lnw - obvgrid.unw, Vector(0, 0, -offsets[1])}, {obvgrid.lsw, obvgrid.lnw - obvgrid.lsw, obvgrid.lse - obvgrid.lsw, obvgrid.usw - obvgrid.lsw, Vector(0, 0, offsets[2])}, {obvgrid.unw, obvgrid.une - obvgrid.unw, obvgrid.lnw - obvgrid.unw, obvgrid.usw - obvgrid.unw, Vector(0, -offsets[3], 0)}, {obvgrid.usw, obvgrid.lsw - obvgrid.usw, obvgrid.use - obvgrid.usw, obvgrid.unw - obvgrid.usw, Vector(0, offsets[4], 0)}, {obvgrid.une, obvgrid.use - obvgrid.une, obvgrid.lne - obvgrid.une, obvgrid.unw - obvgrid.une, Vector(-offsets[5], 0, 0)}, {obvgrid.unw, obvgrid.lnw - obvgrid.unw, obvgrid.usw - obvgrid.unw, obvgrid.une - obvgrid.unw, Vector(offsets[6], 0, 0)}}
            cache.aGrid = obvgrid
            cache.aSnap = obvsnap
            cache.aFaces = faces
        end

        local obvgrid = cache.aGrid
        local obvsnap = cache.aSnap
        local faces = cache.aFaces

        if (not target.locked) then
            -- should improve this by expanding the bounding box or something instead!
            -- create a larger bounding box and then planes for each side, and check distance from the plane
            -- separate function perhaps?
            local distance = (LocalPlayer():GetPos() - target.entity:GetPos()):Length() - (obvgrid.unw - obvgrid.lse):Length()
            if (distance > GetConVarNumber("snap_distance")) then return end

            for face, vertices in ipairs(faces) do
                intersection = RayQuadIntersect(cache.vLookPos, cache.vLookVector, vertices[1], vertices[2], vertices[3])

                if (intersection) then
                    target.face = face
                    break
                end
            end

            if intersection == nil then return end
        end

        if (GetConVarNumber("snap_boundingbox") ~= 0) then
            DrawBoundary(obvgrid.unw, obvgrid.lnw, obvgrid.usw, obvgrid.une)
            DrawBoundary(obvgrid.une, obvgrid.lne, obvgrid.use, obvgrid.unw)
            DrawBoundary(obvgrid.lnw, obvgrid.unw, obvgrid.lsw, obvgrid.lne)
            DrawBoundary(obvgrid.lne, obvgrid.une, obvgrid.lse, obvgrid.lnw)
            DrawBoundary(obvgrid.usw, obvgrid.lsw, obvgrid.unw, obvgrid.use)
            DrawBoundary(obvgrid.use, obvgrid.lse, obvgrid.une, obvgrid.usw)
            DrawBoundary(obvgrid.lsw, obvgrid.usw, obvgrid.lnw, obvgrid.lse)
            DrawBoundary(obvgrid.lse, obvgrid.use, obvgrid.lne, obvgrid.lsw)
        end

        local vectorOrigin = faces[target.face][1]
        local vectorX = faces[target.face][2]
        local vectorY = faces[target.face][3]
        local vectorZ = faces[target.face][4]
        local vectorOffset = faces[target.face][5]
        local vectorGrid

        if (not target.locked) then
            vectorGrid = vectorOrigin + CalculateSnap(vectorX, vectorY, intersection)

            local trace = util.TraceLine({
                start = target.entity:LocalToWorld(target.entity:WorldToLocal(vectorGrid) - vectorOffset) - vectorZ:GetNormalized() * 0.01,
                endpos = vectorGrid + vectorZ
            })

            local vectorSnap = trace.HitPos
            target.offset = target.entity:WorldToLocal(vectorSnap)
            target.vector = target.entity:WorldToLocal(vectorGrid)
            target.error = true

            if (trace.Entity == nil or not trace.Entity:IsValid()) then
                snaperror = -1
            elseif (trace.Entity ~= target.entity) then
                snaperror = -2
            elseif (trace.HitPos == trace.StartPos) then
                snaperror = -2
            else
                snaperror = (LocalPlayer():GetEyeTrace().HitPos - trace.HitPos):Length()
                target.error = false

                if ((vectorSnap - vectorGrid):Length() > 0.5) then
                    local marker = PointToScreen(vectorSnap)

                    if (marker) then
                        DrawSnapCross(marker, 255, 255, 255)
                    end
                end
            end
        else
            vectorGrid = target.entity:LocalToWorld(target.vector)
            local vectorSnap = target.entity:LocalToWorld(target.offset)
            local marker = PointToScreen(vectorSnap)
            snaperror = (LocalPlayer():GetEyeTrace().HitPos - vectorSnap):Length()

            if (marker) then
                if (target.error == true) then
                    snaperror = -2
                    DrawSnapCross(marker, 0, 255, 255)
                elseif (snaperror < 0.001) then
                    DrawSnapCross(marker, 0, 255, 0)
                elseif (snaperror < 0.1) then
                    DrawSnapCross(marker, 255, 255, 0)
                else
                    DrawSnapCross(marker, 255, 0, 0)
                end
            end
        end

        if (GetConVarNumber("snap_hidegrid") == 0) then
            DrawGrid(vectorOrigin, vectorX, vectorY)
        end

        target.active = true
        local vsCursor = PointToScreen(vectorGrid)

        if (vsCursor) then
            if (snaperror == -1) then
                target.active = false
                DrawSnapCross(vsCursor, 0, 255, 255)
            elseif (snaperror == -2) then
                DrawSnapCross(vsCursor, 255, 0, 255)
            elseif (snaperror < 0.001) then
                DrawSnapCross(vsCursor, 0, 255, 0)
            elseif (snaperror < 0.1) then
                DrawSnapCross(vsCursor, 255, 255, 0)
            else
                DrawSnapCross(vsCursor, 255, 0, 0)
            end
        end
    end

    local function OnSnapView(player, origin, angles, fov)
        local targetvalid = target.active and target.locked and target.entity:IsValid()
        local snaptargetvalid = snaptarget.active and snaptarget.locked and snaptarget.entity:IsValid()

        if (snapcursor and not snapspawnmenu and targetvalid) then
            local screen = ToScreen(target.entity:LocalToWorld(target.offset))
            gui.SetMousePos(math.Round(screen.x), math.Round(screen.y))
        end

        if (not snapcursor and targetvalid) then
            return {
                angles = (target.entity:LocalToWorld(target.offset) - player:GetShootPos()):Angle()
            }
        elseif (snaplock and snaptargetvalid) then
            return {
                angles = (snaptarget.entity:LocalToWorld(snaptarget.offset) - player:GetShootPos()):Angle()
            }
        end
    end

    local function OnSnapAim(user)
        local targetvalid = target.active and target.locked and target.entity:IsValid()
        local snaptargetvalid = snaptarget.active and snaptarget.locked and snaptarget.entity:IsValid()

        if (not snapcursor and targetvalid) then
            user:SetViewAngles((target.entity:LocalToWorld(target.offset) - LocalPlayer():GetShootPos()):Angle())
        elseif (snaplock and snaptargetvalid) then
            user:SetViewAngles((snaptarget.entity:LocalToWorld(snaptarget.offset) - LocalPlayer():GetShootPos()):Angle())
        end
    end

    concommand.Add("+snap", SnapPress)
    concommand.Add("-snap", SnapRelease)
    concommand.Add("snaplock", SnapLock)
    concommand.Add("snaptogglegrid", SnapToggleGrid)
    hook.Add("Initialize", "SmartsnapInitialize", OnInitialize)
    hook.Add("SpawnMenuOpen", "SmartsnapSpawnMenu", OnSpawnMenu)
    hook.Add("Think", "SmartsnapThink", OnThink)
    hook.Add("ShutDown", "SmartsnapShutDown", OnShutDown)
    hook.Add("KeyPress", "SmartsnapKeyPress", OnKeyPress)
    hook.Add("KeyRelease", "SmartsnapKeyRelease", OnKeyRelease)
    hook.Add("CreateMove", "SmartsnapSnap", OnSnapAim)
    hook.Add("CalcView", "SmartsnapSnapView", OnSnapView)
    hook.Add("SpawnMenuOpen", "SmartsnapSpawnMenu", OnSpawnMenu)
    hook.Add("HUDPaintBackground", "SmartsnapPaintHUD", OnPaintHUD)

    local function OnPopulateToolPanel(panel)
        panel:AddControl("ComboBox", {
            Options = {
                ["default"] = condefs
            },
            CVars = convars,
            Label = "",
            MenuButton = "1",
            Folder = "smartsnap"
        })

        panel:AddControl("CheckBox", {
            Label = "Enable",
            Command = "snap_enabled"
        })

        panel:AddControl("CheckBox", {
            Label = "Use click grid (USE temporarily enables grid)",
            Command = "snap_clickgrid"
        })

        panel:AddControl("CheckBox", {
            Label = "Hide grid (only shows snap point)",
            Command = "snap_hidegrid"
        })

        panel:AddControl("CheckBox", {
            Label = "Smart toggle enabled",
            Command = "snap_enabletoggle"
        })

        panel:AddControl("CheckBox", {
            Label = "Revert aim to grid snap on detach",
            Command = "snap_revertaim"
        })

        panel:AddControl("CheckBox", {
            Label = "Enable for all entities",
            Command = "snap_allentities"
        })

        panel:AddControl("CheckBox", {
            Label = "Enable for all tools",
            Command = "snap_alltools"
        })

        panel:AddControl("CheckBox", {
            Label = "Draw thick center lines",
            Command = "snap_centerline"
        })

        panel:AddControl("Slider", {
            Label = "Grid toggle delay (double click snap-key)",
            Command = "snap_toggledelay",
            Type = "Float",
            Min = "0.0",
            Max = "0.2"
        })

        panel:AddControl("Slider", {
            Label = "Smart lock delay",
            Command = "snap_lockdelay",
            Type = "Float",
            Min = "0.0",
            Max = "5.0"
        })

        panel:AddControl("CheckBox", {
            Label = "Bounding box enabled",
            Command = "snap_boundingbox"
        })

        panel:AddControl("Slider", {
            Label = "Grid draw distance",
            Command = "snap_distance",
            Type = "Integer",
            Min = "50",
            Max = "1000"
        })

        panel:AddControl("Slider", {
            Label = "Grid edge offset",
            Command = "snap_gridoffset",
            Type = "Float",
            Min = "0.0",
            Max = "2.5"
        })

        panel:AddControl("Slider", {
            Label = "Grid transparency",
            Command = "snap_gridalpha",
            Type = "Float",
            Min = "0.1",
            Max = "1.0"
        })

        panel:AddControl("Slider", {
            Label = "Maximum number of snap points on an axis",
            Command = "snap_gridlimit",
            Type = "Integer",
            Min = "2",
            Max = "64"
        })

        panel:AddControl("Slider", {
            Label = "Minimum distance between each snap point",
            Command = "snap_gridsize",
            Type = "Integer",
            Min = "2",
            Max = "64"
        })

        panel:AddControl("Label", {
            Text = ""
        })

        panel:AddControl("Label", {
            Text = "The following option should prevent FPS drops from occuring, however it might have a slight impact on the average FPS while the grid is showing. Do NOT uncheck this option unless you are experiencing very low FPS or fully understands its purpose."
        })

        panel:AddControl("Label", {
            Text = "NOTE: This option is only effective when the grid is showing, it does not impact regular gameplay!"
        })

        panel:AddControl("Label", {
            Text = ""
        })

        panel:AddControl("CheckBox", {
            Label = "Garbage collection boost",
            Command = "snap_gcboost"
        })
    end

    function OnPopulateToolMenu()
        spawnmenu.AddToolMenuOption("Options", "Player", "SmartSnapSettings", "SmartSnap", "", "", OnPopulateToolPanel, {
            SwitchConVar = 'snap_enabled'
        })
    end

    hook.Add("PopulateToolMenu", "SmartSnapToolMenu", OnPopulateToolMenu)
end
--lua/autorun/sv_tracer_count.lua:
CreateConVar("rw_sw_bit_amount", "10", 8192, "change the amount of bit particle of the reworked impact effects")
CreateConVar("rw_sw_smoke_amount", "5", 8192, "change the amount of smoke particle of the reworked impact effects")
CreateConVar("rw_sw_impact_duration", "4", 8192, "change the duration of the impact color particle of the reworked impact effects")
CreateConVar("rw_sw_impact_size", "16", 8192, "change the size of the impact color particle of the reworked impact effects")

CreateConVar("cl_dynamic_tracer", "0", 8192, "#OVERRIDE# To disable by default the light on tracer to reduce potential crash, you can reactivate it with replace the 0 to 1.")
--lua/autorun/swbf2_boushh_nada.lua:
player_manager.AddValidModel( "Boushh",						"models/nada/Boushh.mdl" ) 
list.Set( "PlayerOptionsModel",  "Boushh",						"models/nada/Boushh.mdl" )
player_manager.AddValidHands( "Boushh", "models/nada/hands/Boushh_arms.mdl", 0, "00000000" )
--lua/autorun/swbf_greedo_nada.lua:
player_manager.AddValidModel( "Greedo",						"models/nada/Greedo.mdl" ) 
list.Set( "PlayerOptionsModel",  "Greedo",						"models/nada/Greedo.mdl" )
player_manager.AddValidHands( "Greedo", "models/nada/hands/Greedo_arms.mdl", 0, "00000000" )
--lua/autorun/tac_npc.lua:
local NPC = {
	Name = "Black Tactical Droid (Friendly)",
	Class = "npc_citizen",
	Category = "CGI CIS Tactical Droids",
	Model = "models/npc_tactical_black/npc_droid_tactical_black_f.mdl",
	KeyValues = { citizentype = CT_UNIQUE }
}
list.Set( "NPC", "npc_droid_tactical_black_f", NPC )


local NPC = {
	Name = "Black Tactical Droid  (Hostile)",
	Class = "npc_combine_s",
	Category = "CGI CIS Tactical Droids",
	Model = "models/npc_tactical_black/npc_droid_tactical_black_h.mdl"
}
list.Set( "NPC", "npc_droid_tactical_black_h", NPC )

local NPC = {
	Name = "Blue Tactical Droid  (Friendly)",
	Class = "npc_citizen",
	Category = "CGI CIS Tactical Droids",
	Model = "models/npc_tactical_blue/npc_droid_tactical_blue_f.mdl",
	KeyValues = { citizentype = CT_UNIQUE }
}
list.Set( "NPC", "npc_droid_tactical_blue_f", NPC )


local NPC = {
	Name = "Blue Tactical Droid (Hostile)",
	Class = "npc_combine_s",
	Category = "CGI CIS Tactical Droids",
	Model = "models/npc_tactical_blue/npc_droid_tactical_blue_h.mdl"
}
list.Set( "NPC", "npc_droid_tactical_blue_h", NPC )

local NPC = {
	Name = "Gold Tactical Droid (Friendly)",
	Class = "npc_citizen",
	Category = "CGI CIS Tactical Droids",
	Model = "models/npc_tactical_gold/npc_droid_tactical_gold_f.mdl",
	KeyValues = { citizentype = CT_UNIQUE }
}
list.Set( "NPC", "npc_droid_tactical_gold_f", NPC )


local NPC = {
	Name = "Gold Tactical Droid (Hostile)",
	Class = "npc_combine_s",
	Category = "CGI CIS Tactical Droids",
	Model = "models/npc_tactical_gold/npc_droid_tactical_gold_h.mdl"
}
list.Set( "NPC", "npc_droid_tactical_gold_h", NPC )

local NPC = {
	Name = "Purple Tactical Droid (Friendly)",
	Class = "npc_citizen",
	Category = "CGI CIS Tactical Droids",
	Model = "models/npc_tactical_purple/npc_droid_tactical_purple_f.mdl",
	KeyValues = { citizentype = CT_UNIQUE }
}
list.Set( "NPC", "npc_droid_tactical_purple_f", NPC )


local NPC = {
	Name = "Purple Tactical Droid (Hostile)",
	Class = "npc_combine_s",
	Category = "CGI CIS Tactical Droids",
	Model = "models/npc_tactical_purple/npc_droid_tactical_purple_h.mdl"
}
list.Set( "NPC", "npc_droid_tactical_purple_h", NPC )

local NPC = {
	Name = "Red Tactical Droid (Friendly)",
	Class = "npc_citizen",
	Category = "CGI CIS Tactical Droids",
	Model = "models/npc_tactical_red/npc_droid_tactical_red_f.mdl",
	KeyValues = { citizentype = CT_UNIQUE }
}
list.Set( "NPC", "npc_droid_tactical_red_f", NPC )


local NPC = {
	Name = "Red Tactical Droid (Hostile)",
	Class = "npc_combine_s",
	Category = "CGI CIS Tactical Droids",
	Model = "models/npc_tactical_red/npc_droid_tactical_red_h.mdl"
}
list.Set( "NPC", "npc_droid_tactical_red_h", NPC )

--lua/autorun/tactical_pm.lua:
player_manager.AddValidModel( "pm_droid_tactical_black", "models/tactical_black/pm_droid_tactical_black.mdl" )
player_manager.AddValidModel( "pm_droid_tactical_blue", "models/tactical_blue/pm_droid_tactical_blue.mdl" )
player_manager.AddValidModel( "pm_droid_tactical_gold", "models/tactical_gold/pm_droid_tactical_gold.mdl" )
player_manager.AddValidModel( "pm_droid_tactical_purple", "models/tactical_purple/pm_droid_tactical_purple.mdl" )
player_manager.AddValidModel( "pm_droid_tactical_red", "models/tactical_red/pm_droid_tactical_red.mdl" )
player_manager.AddValidModel( "pm_droid_tactical_kalani", "models/super_tactical_kalani/pm_droid_tactical_kalani.mdl" )
player_manager.AddValidModel( "pm_droid_tactical_stuxnet", "models/super_tactical_stuxnet/pm_droid_tactical_stuxnet.mdl" )
--lua/autorun/talz.lua:
player_manager.AddValidModel( "talz", "models/player/valley/talz.mdl" ) 
list.Set( "PlayerOptionsModel",  "talz", "models/player/valley/talz.mdl" ) 

--addons/tfa_base/lua/autorun/tfa_base_autorun.lua:
if SERVER then AddCSLuaFile() end

TFA = TFA or {}

local version = 4.791
local version_string = "4.7.9.1"
local changelog = [[
	* (4.7.9.0) Many fixes and improvements. For full list of changes check changelog on GitHub!
	* Fixed black screen for weapons with instant aiming/scoping
]]

local function testFunc()
end

local my_path = debug.getinfo(testFunc)
if my_path and type(my_path) == "table" and my_path.short_src then
	my_path = my_path["short_src"]
else
	my_path = "legacy"
end

local official_modules_sorted = {
	"tfa_commands.lua",
	"cl_tfa_commands.lua", -- we need to load clientside convars before anything else

	"tfa_envcheck.lua",

	"tfa_data.lua",
	"tfa_ammo.lua",
	"tfa_attachments.lua",
	"tfa_ballistics.lua",
	"tfa_bodygroups.lua",

	"tfa_darkrp.lua",
	"tfa_effects.lua",
	"tfa_functions.lua",
	"tfa_hooks.lua",
	"tfa_keybinds.lua",
	"tfa_keyvalues.lua",
	"tfa_matproxies.lua",
	"tfa_melee_autorun.lua",
	"tfa_meta.lua",
	"tfa_netcode.lua",
	"tfa_small_entities.lua",
	"tfa_npc_teamcolor.lua",
	"tfa_npc_weaponmenu.lua",
	"tfa_nzombies.lua",
	"tfa_particles.lua",
	"tfa_snd_timescale.lua",
	"tfa_soundscripts.lua",
	"tfa_tttpatch.lua",

	"sv_tfa_settingsmenu.lua", -- TFA.BASE_LOAD_COMPLETE server

	"cl_tfa_attachment_icon.lua",
	"cl_tfa_attachment_panel.lua",
	"cl_tfa_attachment_tip.lua",
	"cl_tfa_changelog.lua",

	"cl_tfa_devtools.lua",
	"cl_tfa_fonts.lua",
	"cl_tfa_hitmarker.lua",
	"cl_tfa_inspection.lua",
	"cl_tfa_materials.lua",
	"cl_tfa_models.lua",
	"cl_tfa_particles_lua.lua",
	"cl_tfa_projtex.lua",
	"cl_tfa_rendertarget.lua",
	"cl_tfa_rtbgblur.lua",
	"cl_tfa_settingsmenu.lua",
	"cl_tfa_vgui.lua",
	"cl_tfa_vm_blur.lua",
	"cl_tfa_stencilsights.lua",
	"cl_tfa_subcategories.lua", -- TFA.BASE_LOAD_COMPLETE client
}

local official_modules = {}

for _, modulename in ipairs(official_modules_sorted) do
	official_modules[modulename] = true
end

TFA_BASE_VERSION = version
TFA_BASE_VERSION_STRING = version_string
TFA_BASE_VERSION_CHANGES = changelog
TFA_FILE_PATH = my_path

TFA.BASE_LOAD_COMPLETE = false

TFA.Enum = TFA.Enum or {}

local flist = file.Find("tfa/enums/*.lua","LUA")

for _, filename in pairs(flist) do
	local typev = "SHARED"

	if filename:StartWith("cl_") then
		typev = "CLIENT"
	elseif filename:StartWith("sv_") then
		typev = "SERVER"
	end

	if SERVER and typev ~= "SERVER" then
		AddCSLuaFile("tfa/enums/" .. filename)
	end

	if SERVER and typev ~= "CLIENT" or CLIENT and typev ~= "SERVER" then
		include("tfa/enums/" .. filename)
	end
end

hook.Run("TFABase_PreEarlyInit")

for _, filename in ipairs(official_modules_sorted) do
	if filename:StartWith("cl_") then
		if SERVER then
			AddCSLuaFile("tfa/modules/" .. filename)
		else
			include("tfa/modules/" .. filename)
		end
	elseif filename:StartWith("sv_") then
		if SERVER then
			include("tfa/modules/" .. filename)
		end
	else
		if SERVER then
			AddCSLuaFile("tfa/modules/" .. filename)
		end

		include("tfa/modules/" .. filename)
	end
end

hook.Run("TFABase_EarlyInit")
hook.Run("TFABase_PreInit")

flist = file.Find("tfa/modules/*.lua", "LUA")
local toload = {}
local toload2 = {}

for _, filename in pairs(flist) do
	if not official_modules[filename] then
		local typev = "SHARED"

		if filename:StartWith("cl_") then
			typev = "CLIENT"
		elseif filename:StartWith("sv_") then
			typev = "SERVER"
		end

		if SERVER and typev ~= "SERVER" then
			AddCSLuaFile("tfa/modules/" .. filename)
		end

		if SERVER and typev == "SERVER" or CLIENT and typev == "CLIENT" then
			table.insert(toload2, filename)
		elseif typev == "SHARED" then
			table.insert(toload, filename)
		end
	end
end

local yell = #toload ~= 0 or #toload2 ~= 0

table.sort(toload)
table.sort(toload2)

for _, filename in ipairs(toload) do
	include("tfa/modules/" .. filename)
	print("[TFA Base] [!] Loaded unofficial module " .. string.sub(filename, 1, -5) .. ".")
end

for _, filename in ipairs(toload2) do
	include("tfa/modules/" .. filename)
	print("[TFA Base] [!] Loaded unofficial module " .. string.sub(filename, 1, -5) .. ".")
end

hook.Run("TFABase_Init")
hook.Run("TFABase_PreFullInit")

flist = file.Find("tfa/external/*.lua", "LUA")
toload = {}
toload2 = {}

for _, filename in pairs(flist) do
	local typev = "SHARED"

	if filename:StartWith("cl_") then
		typev = "CLIENT"
	elseif filename:StartWith("sv_") then
		typev = "SERVER"
	end

	if SERVER and typev ~= "SERVER" then
		AddCSLuaFile("tfa/external/" .. filename)
	end

	if SERVER and typev == "SERVER" or CLIENT and typev == "CLIENT" then
		table.insert(toload2, filename)
	elseif typev == "SHARED" then
		table.insert(toload, filename)
	end
end

table.sort(toload)
table.sort(toload2)

for _, filename in ipairs(toload) do
	include("tfa/external/" .. filename)
end

for _, filename in ipairs(toload2) do
	include("tfa/external/" .. filename)
end

if yell then
	print("[TFA Base] [!] Some of files not belonging to TFA Base were loaded from tfa/modules/ directory")
	print("[TFA Base] This behavior is kept for backward compatiblity and using this is highly discouraged!")
	print("[TFA Base] Files loaded this way have no pre-defined sorting applied and result of execution of those files is undefined.")
	print("[TFA Base] If you are author of these files, please consider moving your modules to tfa/external/ as soon as possible.")
end

hook.Run("TFABase_FullInit")

if not VLL2_FILEDEF then
	TFAUpdateAttachments(false)
end

hook.Run("TFABase_LateInit")
--addons/tfa_base/lua/tfa/modules/tfa_functions.lua:
local gas_cl_enabled = GetConVar("cl_tfa_fx_gasblur")
local oldshell_cl_enabled = GetConVar("cl_tfa_legacy_shells")

local ScrW, ScrH = ScrW, ScrH

local BindToKeyTBL = {
	["ctrl"] = KEY_LCONTROL,
	["rctrl"] = KEY_LCONTROL,
	["alt"] = KEY_LALT,
	["ralt"] = KEY_RALT,
	["space"] = KEY_SPACE,
	["caps"] = KEY_CAPSLOCK,
	["capslock"] = KEY_CAPSLOCK,
	["tab"] = KEY_TAB,
	["back"] = KEY_BACKSPACE,
	["backspace"] = KEY_BACKSPACE,
	[0] = KEY_0,
	[1] = KEY_1,
	[2] = KEY_2,
	[3] = KEY_3,
	[4] = KEY_4,
	[5] = KEY_5,
	[6] = KEY_6,
	[7] = KEY_7,
	[8] = KEY_8,
	[9] = KEY_9
}

local alphabet = "abcdefghijklmnopqrstuvwxyz"

for i = 1, string.len(alphabet) do
	local sstr = string.sub( alphabet, i, i )
	BindToKeyTBL[ sstr ] =  string.byte( sstr ) - 86
end


local SoundChars = {
	["*"] = "STREAM",--Streams from the disc and rapidly flushed; good on memory, useful for music or one-off sounds
	["#"] = "DRYMIX",--Skip DSP, affected by music volume rather than sound volume
	["@"] = "OMNI",--Play the sound audible everywhere, like a radio voiceover or surface.PlaySound
	[">"] = "DOPPLER",--Left channel for heading towards the listener, Right channel for heading away
	["<"] = "DIRECTIONAL",--Left channel = front facing, Right channel = read facing
	["^"] = "DISTVARIANT",--Left channel = close, Right channel = far
	["("] = "SPATIALSTEREO_LOOP",--Position a stereo sound in 3D space; broken
	[")"] = "SPATIALSTEREO",--Same as above but actually useful
	["}"] = "FASTPITCH",--Low quality pitch shift
	["$"] = "CRITICAL",--Keep it around in memory
	["!"] = "SENTENCE",--NPC dialogue
	["?"] = "USERVOX"--Fake VOIP data; not that useful
}
local DefaultSoundChar = ")"

local SoundChannels = {
	["shoot"] = CHAN_WEAPON,
	["shootwrap"] = CHAN_STATIC,
	["misc"] = CHAN_AUTO
}


--Scope

local cv_rt

function TFA.RTQuality()
	if not cv_rt then
		cv_rt = GetConVar("cl_tfa_3dscope_quality")
	end

	return math.Clamp(cv_rt:GetInt(), cv_rt:GetMin(), cv_rt:GetMax())
end

--Sensitivity

local ss, fov_og, resrat, fov_cv

fov_cv = GetConVar("fov_desired")
function TFA.CalculateSensitivtyScale( fov_target, fov_src, screenscale )
	if not LocalPlayer():IsValid() then return 1 end
	resrat = ScrW() / ScrH()
	fov_og = fov_src or TFADUSKFOV or fov_cv:GetFloat()
	ss = screenscale or 1
	return math.Clamp(math.atan( resrat * math.tan(math.rad( fov_target / 2  ) ) ) / math.atan( resrat * math.tan( math.rad( fov_og / 2) ) ) / ss, 0, 1)
end

--Ammo

local AmmoTypesByName = {}
local AmmoTypesAdded = {}

function TFA.AddAmmo(id, name)
	if not AmmoTypesAdded[id] then
		AmmoTypesAdded[id] = true

		game.AddAmmoType({
			name = id
		})
	end

	if name and language then
		language.Add(id .. "_ammo", name)
	end

	if name then
		AmmoTypesByName[name] = AmmoTypesByName[name] or id

		return AmmoTypesByName[name]
	end

	return id
end

--Particles

function TFA.ParticleTracer( name,startPos,endPos,doWhiz,ent,att)
	if type(ent) ~= "number" and IsValid(ent) and ent.EntIndex then
		ent = ent:EntIndex()
	end
	if ent then
		att = att or -1
		return util.ParticleTracerEx(name,startPos,endPos,doWhiz,ent,att)
	else
		return util.ParticleTracerEx(name,startPos,endPos,doWhiz,0,-1)
	end
end

--Binds

function TFA.BindToKey( bind, default )
	return BindToKeyTBL[ string.lower( bind ) ] or default or KEY_C
end

--Sounds

function TFA.PatchSound( path, kind )
	local pathv
	local c = string.sub(path,1,1)

	if SoundChars[c] then
		pathv = string.sub( path, 2, string.len(path) )
	else
		pathv = path
	end

	local kindstr = kind
	if not kindstr then
		kindstr = DefaultSoundChar
	end
	if string.len(kindstr) > 1 then
		local found = false
		for k,v in pairs( SoundChars ) do
			if v == kind then
				kindstr = k
				found = true
				break
			end
		end
		if not found then
			kindstr = DefaultSoundChar
		end
	end

	return kindstr .. pathv
end

function TFA.AddSound( name, channel, volume, level, pitch, wave, char )
	char = char or ""

	local SoundData = {
		name = name,
		channel = channel or CHAN_AUTO,
		volume = volume or 1,
		level = level or 75,
		pitch = pitch or 100
	}

	if char ~= "" then
		if type(wave) == "string" then
			wave = TFA.PatchSound(wave, char)
		elseif type(wave) == "table" then
			local patchWave = table.Copy(wave)

			for k, v in pairs(patchWave) do
				patchWave[k] = TFA.PatchSound(v, char)
			end

			wave = patchWave
		end
	end

	SoundData.sound = wave

	sound.Add(SoundData)
end

function TFA.AddFireSound( id, path, wrap, kindv )
	kindv = kindv or ")"

	TFA.AddSound(id, wrap and SoundChannels.shootwrap or SoundChannels.shoot, 1, 120, {97, 103}, path, kindv)
end

function TFA.AddWeaponSound( id, path, kindv )
	kindv = kindv or ")"

	TFA.AddSound(id, SoundChannels.misc, 1, 80, {97, 103}, path, kindv)
end

--Frametime

--CVar Mediators
function TFA.GetGasEnabled()
	local enabled = false

	if gas_cl_enabled then
		enabled = gas_cl_enabled:GetBool()
	end

	return enabled
end

function TFA.GetLegacyShellsEnabled()
	local enabled = false

	if oldshell_cl_enabled then
		enabled = oldshell_cl_enabled:GetBool()
	end

	return enabled
end

local ejectionsmoke_cl_enabled = GetConVar("cl_tfa_fx_ejectionsmoke")
local muzzlesmoke_cl_enabled = GetConVar("cl_tfa_fx_muzzlesmoke")

function TFA.GetMZSmokeEnabled()
	local enabled = false

	if muzzlesmoke_cl_enabled then
		enabled = muzzlesmoke_cl_enabled:GetBool()
	end

	return enabled
end

function TFA.GetEJSmokeEnabled()
	local enabled = false

	if ejectionsmoke_cl_enabled then
		enabled = ejectionsmoke_cl_enabled:GetBool()
	end

	return enabled
end

local muzzleflashsmoke_cl_enabled = GetConVar("cl_tfa_fx_muzzleflashsmoke")

function TFA.GetMZFSmokeEnabled()
	local enabled = false

	if muzzleflashsmoke_cl_enabled then
		enabled = muzzleflashsmoke_cl_enabled:GetBool()
	end

	return enabled
end

local ricofx_cl_enabled = GetConVar("cl_tfa_fx_impact_ricochet_enabled")

function TFA.GetRicochetEnabled()
	local enabled = false

	if ricofx_cl_enabled then
		enabled = ricofx_cl_enabled:GetBool()
	end

	return enabled
end

--Local function for detecting TFA Base weapons.
function TFA.PlayerCarryingTFAWeapon(ply)
	if not ply then
		if CLIENT then
			if LocalPlayer():IsValid() then
				ply = LocalPlayer()
			else
				return false, nil, nil
			end
		elseif game.SinglePlayer() then
			ply = Entity(1)
		else
			return false, nil, nil
		end
	end

	if not (IsValid(ply) and ply:IsPlayer() and ply:Alive()) then return end
	local wep = ply:GetActiveWeapon()

	if IsValid(wep) then
		if (wep.IsTFAWeapon) then return true, ply, wep end

		return false, ply, wep
	end

	return false, ply, nil
end

local sv_cheats = GetConVar("sv_cheats")
local host_timescale = GetConVar("host_timescale")

function TFA.FrameTime()
	return engine.TickInterval() * game.GetTimeScale() * (sv_cheats:GetBool() and host_timescale:GetFloat() or 1)
end

local buffer = {}

function TFA.tbezier(t, values, amount)
	assert(isnumber(t), 't is not a number')
	assert(t >= 0 and t <= 1, '0 <= t <= 1!')
	assert(#values >= 2, 'at least two values must be provided')
	amount = amount or #values
	local a, b = values[1], values[2]

	-- linear
	if amount == 2 then
		return a + (b - a) * t
	-- square
	elseif amount == 3 then
		return (1 - t) * (1 - t) * a + 2 * t * (1 - t) * b + t * t * values[3]
	-- cube
	elseif amount == 4 then
		return (1 - t) * (1 - t) * (1 - t) * a + 3 * t * (1 - t) * (1 - t) * b + 3 * t * t * (1 - t) * values[3] + t * t * t * values[4]
	end

	for point = 1, amount do
		local point1 = values[point]
		local point2 = values[point + 1]
		if not point2 then break end
		buffer[point] = point1 + (point2 - point1) * t
	end

	return TFA.tbezier(t, buffer, amount - 1)
end

if DLib and math.tbezier and isfunction(math.tbezier) then
	TFA.tbezier = math.tbezier
end

function TFA.Quintic(t)
	return t * t * t * (t * (t * 6 - 15) + 10)
end

function TFA.Cosine(t)
	return (1 - math.cos(t * math.pi)) / 2
end

function TFA.Sinusine(t)
	return (1 - math.sin(t * math.pi)) / 2
end

function TFA.Cubic(t)
	return -2 * t * t * t + 3 * t * t
end

function TFA.UnfoldBaseClass(tableInput, tableOutput)
	if tableOutput == nil then tableOutput = tableInput end
	if not istable(tableInput) or not istable(tableOutput) then return tableOutput end

	if tableInput ~= tableOutput then
		for k, v in pairs(tableInput) do
			if tableOutput[k] == nil then
				tableOutput[k] = v
			end
		end
	end

	if istable(tableInput.BaseClass) then
		TFA.UnfoldBaseClass(tableInput.BaseClass, tableOutput)
	end

	return tableOutput
end

if CLIENT then
	local cvar_scale = GetConVar("cl_tfa_hud_scale")
	local sscache = {}

	function TFA.ScaleH(num)
		if not sscache[num] then
			sscache[num] = num * (ScrH() / 1080) * cvar_scale:GetFloat()
		end

		return sscache[num]
	end

	local function EmptyCache()
		sscache = {}
	end

	cvars.AddChangeCallback("cl_tfa_hud_scale", EmptyCache, "TFA_ClearSScaleCache")
	hook.Add("OnScreenSizeChanged", "_TFA_DropSScaleCache", EmptyCache)

	local color_black = Color(0, 0, 0, 255)
	function TFA.DrawTextShadowed(text, font, x, y, color, shadowlength, shadowcolor)
		shadowlength = shadowlength or 2
		shadowcolor = shadowcolor or ColorAlpha(color_black, color.a)

		surface.SetFont(font)

		surface.SetTextPos(x + shadowlength, y + shadowlength)
		surface.SetTextColor(shadowcolor.r, shadowcolor.g, shadowcolor.b, shadowcolor.a)
		surface.DrawText(text)

		surface.SetTextPos(x, y)
		surface.SetTextColor(color.r, color.g, color.b, color.a)
		surface.DrawText(text)
	end
end

--addons/tfa_base/lua/tfa/modules/tfa_soundscripts.lua:
sound.Add({
	name = "Weapon_Bow.1",
	channel = CHAN_STATIC,
	volume = 1.0,
	sound = {"weapons/tfbow/fire1.wav", "weapons/tfbow/fire2.wav", "weapons/tfbow/fire3.wav"}
})

sound.Add({
	name = "Weapon_Bow.boltpull",
	channel = CHAN_USER_BASE + 11,
	volume = 1.0,
	sound = {"weapons/tfbow/pull1.wav", "weapons/tfbow/pull2.wav", "weapons/tfbow/pull3.wav"}
})

sound.Add({
	name = "TFA.NearlyEmpty",
	channel = CHAN_USER_BASE + 15,
	volume = 1,
	pitch = 100,
	level = 65,
	sound = "weapons/tfa/lowammo.wav"
})

sound.Add({
	name = "TFA.Bash",
	channel = CHAN_USER_BASE + 14,
	volume = 1.0,
	sound = {
		")weapons/tfa/melee1.wav",
		")weapons/tfa/melee2.wav",
		")weapons/tfa/melee3.wav",
		")weapons/tfa/melee4.wav",
		")weapons/tfa/melee5.wav",
		")weapons/tfa/melee6.wav"
	},
	pitch = {97, 103}
})

sound.Add({
	name = "TFA.BashWall",
	channel = CHAN_USER_BASE + 14,
	volume = 1.0,
	sound = {
		")weapons/tfa/melee_hit_world1.wav",
		")weapons/tfa/melee_hit_world2.wav",
		")weapons/tfa/melee_hit_world3.wav"
	},
	pitch = {97, 103}
})

sound.Add({
	name = "TFA.BashFlesh",
	channel = CHAN_USER_BASE + 14,
	volume = 1.0,
	sound = {
		")weapons/tfa/melee_hit_body1.wav",
		")weapons/tfa/melee_hit_body2.wav",
		")weapons/tfa/melee_hit_body3.wav",
		")weapons/tfa/melee_hit_body4.wav",
		")weapons/tfa/melee_hit_body5.wav",
		")weapons/tfa/melee_hit_body6.wav"
	},
	pitch = {97, 103}
})

sound.Add({
	name = "TFA.IronIn",
	channel = CHAN_USER_BASE + 13,
	volume = 1.0,
	sound = {"weapons/tfa/ironin.wav"},
	pitch = {97, 103}
})

sound.Add({
	name = "TFA.IronOut",
	channel = CHAN_USER_BASE + 13,
	volume = 1.0,
	sound = {"weapons/tfa/ironout.wav"},
	pitch = {97, 103}
})

sound.Add({
	name = "Weapon_Pistol.Empty2",
	channel = CHAN_USER_BASE + 11,
	volume = 1.0,
	level = 80,
	sound = {"weapons/pistol/pistol_empty.wav"},
	pitch = {97, 103}
})

sound.Add({
	name = "Weapon_AR2.Empty2",
	channel = CHAN_USER_BASE + 11,
	volume = 1.0,
	level = 80,
	sound = {"weapons/ar2/ar2_empty.wav"},
	pitch = {97, 103}
})

sound.Add({
	name = "TFA.LowAmmo",
	channel = CHAN_USER_BASE + 15,
	volume = 1.0,
	level = 75,
	pitch = 100,
	sound = ")weapons/tfa/lowammo_indicator_automatic.wav"
})
sound.Add({
	name = "TFA.LowAmmo_Dry",
	channel = CHAN_USER_BASE + 15,
	volume = 1.0,
	level = 75,
	pitch = 100,
	sound = ")weapons/tfa/lowammo_dry_automatic.wav"
})

local ammos = {
	["Handgun"] = "handgun",
	["Shotgun"] = "shotgun",
	["AutoShotgun"] = "shotgun_auto",
	["MachineGun"] = "mg",
	["AssaultRifle"] = "ar",
	["DMR"] = "dmr",
	["Revolver"] = "revolver",
	["Sniper"] = "sr",
	["SMG"] = "smg",
	["SciFi"] = "scifi",
	["GL"] = "gl",
}
for k,v in pairs(ammos) do
	sound.Add({
		name = "TFA.LowAmmo." .. k, -- "TFA.LowAmmo.Handgun"
		channel = CHAN_USER_BASE + 15,
		volume = 1.0,
		level = 75,
		pitch = 100,
		sound = ")weapons/tfa/lowammo_indicator_" .. v .. ".wav"
	})
	sound.Add({
		name = "TFA.LowAmmo." .. k .. "_Dry", -- "TFA.LowAmmo.Handgun_Dry"
		channel = CHAN_USER_BASE + 15,
		volume = 1.0,
		level = 75,
		pitch = 100,
		sound = ")weapons/tfa/lowammo_dry_" .. v .. ".wav"
	})
end
--tfa_dev_tools:
		local rshift = bit.rshift
		local band = bit.band
		return function(state)
			return band(rshift(state, 0), 1) == 0 and 0 or 1, band(rshift(state, 1), 1) == 0 and 0 or 1		end
	
--tfa_dev_tools:
		local rshift = bit.rshift
		local band = bit.band
		return function(state)
			return band(rshift(state, 0), 1) == 0 and 0 or 1, band(rshift(state, 1), 1) == 0 and 0 or 1, band(rshift(state, 2), 1) == 0 and 0 or 1, band(rshift(state, 3), 1) == 0 and 0 or 1, band(rshift(state, 4), 1) == 0 and 0 or 1, band(rshift(state, 5), 1) == 0 and 0 or 1, band(rshift(state, 6), 1) == 0 and 0 or 1		end
	
--tfa_dev_tools:
		local rshift = bit.rshift
		local band = bit.band
		return function(state)
			return band(rshift(state, 0), 1) == 0 and 0 or 1, band(rshift(state, 1), 1) == 0 and 0 or 1, band(rshift(state, 2), 1) == 0 and 0 or 1, band(rshift(state, 3), 1) == 0 and 0 or 1, band(rshift(state, 4), 1) == 0 and 0 or 1, band(rshift(state, 5), 1) == 0 and 0 or 1, band(rshift(state, 6), 1) == 0 and 0 or 1, band(rshift(state, 7), 1) == 0 and 0 or 1, band(rshift(state, 8), 1) == 0 and 0 or 1		end
	
--tfa_dev_tools:
		local rshift = bit.rshift
		local band = bit.band
		return function(state)
			return band(rshift(state, 0), 1) == 0 and 0 or 1, band(rshift(state, 1), 1) == 0 and 0 or 1, band(rshift(state, 2), 1) == 0 and 0 or 1, band(rshift(state, 3), 1) == 0 and 0 or 1, band(rshift(state, 4), 1) == 0 and 0 or 1, band(rshift(state, 5), 1) == 0 and 0 or 1, band(rshift(state, 6), 1) == 0 and 0 or 1, band(rshift(state, 7), 1) == 0 and 0 or 1, band(rshift(state, 8), 1) == 0 and 0 or 1, band(rshift(state, 9), 1) == 0 and 0 or 1, band(rshift(state, 10), 1) == 0 and 0 or 1		end
	
--tfa_dev_tools:
		local rshift = bit.rshift
		local band = bit.band
		return function(state)
			return band(rshift(state, 0), 1) == 0 and 0 or 1, band(rshift(state, 1), 1) == 0 and 0 or 1, band(rshift(state, 2), 1) == 0 and 0 or 1, band(rshift(state, 3), 1) == 0 and 0 or 1, band(rshift(state, 4), 1) == 0 and 0 or 1, band(rshift(state, 5), 1) == 0 and 0 or 1, band(rshift(state, 6), 1) == 0 and 0 or 1, band(rshift(state, 7), 1) == 0 and 0 or 1, band(rshift(state, 8), 1) == 0 and 0 or 1, band(rshift(state, 9), 1) == 0 and 0 or 1, band(rshift(state, 10), 1) == 0 and 0 or 1, band(rshift(state, 11), 1) == 0 and 0 or 1		end
	
--tfa_dev_tools:
		local rshift = bit.rshift
		local band = bit.band
		return function(state)
			return band(rshift(state, 0), 1) == 0 and 0 or 1, band(rshift(state, 1), 1) == 0 and 0 or 1, band(rshift(state, 2), 1) == 0 and 0 or 1, band(rshift(state, 3), 1) == 0 and 0 or 1, band(rshift(state, 4), 1) == 0 and 0 or 1, band(rshift(state, 5), 1) == 0 and 0 or 1, band(rshift(state, 6), 1) == 0 and 0 or 1, band(rshift(state, 7), 1) == 0 and 0 or 1, band(rshift(state, 8), 1) == 0 and 0 or 1, band(rshift(state, 9), 1) == 0 and 0 or 1, band(rshift(state, 10), 1) == 0 and 0 or 1, band(rshift(state, 11), 1) == 0 and 0 or 1, band(rshift(state, 12), 1) == 0 and 0 or 1, band(rshift(state, 13), 1) == 0 and 0 or 1, band(rshift(state, 14), 1) == 0 and 0 or 1, band(rshift(state, 15), 1) == 0 and 0 or 1, band(rshift(state, 16), 1) == 0 and 0 or 1, band(rshift(state, 17), 1) == 0 and 0 or 1, band(rshift(state, 18), 1) == 0 and 0 or 1		end
	
--tfa_dev_tools:
		local rshift = bit.rshift
		local band = bit.band
		return function(state)
			return band(rshift(state, 0), 1) == 0 and 0 or 1, band(rshift(state, 1), 1) == 0 and 0 or 1, band(rshift(state, 2), 1) == 0 and 0 or 1, band(rshift(state, 3), 1) == 0 and 0 or 1, band(rshift(state, 4), 1) == 0 and 0 or 1, band(rshift(state, 5), 1) == 0 and 0 or 1, band(rshift(state, 6), 1) == 0 and 0 or 1, band(rshift(state, 7), 1) == 0 and 0 or 1, band(rshift(state, 8), 1) == 0 and 0 or 1, band(rshift(state, 9), 1) == 0 and 0 or 1, band(rshift(state, 10), 1) == 0 and 0 or 1, band(rshift(state, 11), 1) == 0 and 0 or 1, band(rshift(state, 12), 1) == 0 and 0 or 1, band(rshift(state, 13), 1) == 0 and 0 or 1, band(rshift(state, 14), 1) == 0 and 0 or 1, band(rshift(state, 15), 1) == 0 and 0 or 1, band(rshift(state, 16), 1) == 0 and 0 or 1, band(rshift(state, 17), 1) == 0 and 0 or 1, band(rshift(state, 18), 1) == 0 and 0 or 1, band(rshift(state, 19), 1) == 0 and 0 or 1		end
	
--addons/tfa_base/lua/tfa/modules/cl_tfa_hitmarker.lua:
local ScrW, ScrH = ScrW, ScrH

local markers = {}

local cl_drawhud = GetConVar("cl_drawhud")
local enabledcvar = GetConVar("cl_tfa_hud_hitmarker_enabled")
local solidtimecvar = GetConVar("cl_tfa_hud_hitmarker_solidtime")
local fadetimecvar = GetConVar("cl_tfa_hud_hitmarker_fadetime")
local scalecvar = GetConVar("cl_tfa_hud_hitmarker_scale")
local tricross_cvar = GetConVar("cl_tfa_hud_crosshair_triangular")

local rcvar = GetConVar("cl_tfa_hud_hitmarker_color_r")
local gcvar = GetConVar("cl_tfa_hud_hitmarker_color_g")
local bcvar = GetConVar("cl_tfa_hud_hitmarker_color_b")
local acvar = GetConVar("cl_tfa_hud_hitmarker_color_a")

net.Receive("tfaHitmarker", function()
	if not enabledcvar:GetBool() then return end

	local marker = {
		time = RealTime()
	}

	table.insert(markers, marker)
end)

net.Receive("tfaHitmarker3D", function()
	if not enabledcvar:GetBool() then return end

	local marker = {
		pos = net.ReadVector(),
		time = RealTime()
	}

	table.insert(markers, marker)
end)

local mat_regular = Material("vgui/tfa_hitmarker.png", "smooth mips")
local mat_triang = Material("vgui/tfa_hitmarker_triang.png", "smooth mips")

local cl_tfa_hud_crosshair_enable_custom = GetConVar("cl_tfa_hud_crosshair_enable_custom")

hook.Add("HUDPaint", "tfaDrawHitmarker", function()
	if not enabledcvar:GetBool() or not cl_drawhud:GetBool() then return end

	local solidtime = solidtimecvar:GetFloat()
	local fadetime = math.max(fadetimecvar:GetFloat(), 0.001)

	local r = rcvar:GetFloat()
	local g = gcvar:GetFloat()
	local b = bcvar:GetFloat()
	local a = acvar:GetFloat()

	local w, h = ScrW(), ScrH()
	local sprh = math.floor((h / 1080) * 64 * scalecvar:GetFloat())
	local sprh2 = sprh / 2
	local mX, mY = w / 2, h / 2
	local ltime = RealTime()

	if cl_tfa_hud_crosshair_enable_custom:GetBool() and isnumber(TFA.LastCrosshairPosX) and isnumber(TFA.LastCrosshairPosY) then
		local weapon = LocalPlayer():GetActiveWeapon()

		if IsValid(weapon) and weapon.IsTFAWeapon then
			mX, mY = TFA.LastCrosshairPosX, TFA.LastCrosshairPosY
		end
	end

	for k, v in pairs(markers) do
		if v.time then
			local alpha = math.Clamp(v.time - ltime + solidtime + fadetime, 0, fadetime) / fadetime

			if alpha > 0 then
				local x, y = mX, mY
				local visible = true

				if v.pos then
					local pos = v.pos:ToScreen()
					x, y = pos.x, pos.y
					visible = pos.visible
				end

				if visible then
					surface.SetDrawColor(r, g, b, a * alpha)
					surface.SetMaterial(tricross_cvar:GetBool() and mat_triang or mat_regular)
					surface.DrawTexturedRect(x - sprh2, y - sprh2, sprh, sprh)
				end
			else
				markers[k] = nil
			end
		else
			markers[k] = nil
		end
	end
end)

--addons/tfa_base/lua/tfa/modules/cl_tfa_models.lua:
TFA.ClientsideModels = TFA.ClientsideModels or {}

timer.Create("TFA_UpdateClientsideModels", 0.1, 0, function()
	local i = 1

	while i <= #TFA.ClientsideModels do
		local t = TFA.ClientsideModels[i]

		if not t then
			table.remove(TFA.ClientsideModels, i)
		elseif not IsValid(t.wep) then
			t.mdl:Remove()
			table.remove(TFA.ClientsideModels, i)
		elseif IsValid(t.wep:GetOwner()) and t.wep:GetOwner().GetActiveWeapon and t.wep ~= t.wep:GetOwner():GetActiveWeapon() then
			t.mdl:Remove()
			table.remove(TFA.ClientsideModels, i)
		elseif t.wep.IsHidden and t.wep:IsHidden() then
			t.mdl:Remove()
			table.remove(TFA.ClientsideModels, i)
		else
			i = i + 1
		end
	end

	if #TFA.ClientsideModels == 0 then
		timer.Stop("TFA_UpdateClientsideModels")
	end
end)

if #TFA.ClientsideModels == 0 then
	timer.Stop("TFA_UpdateClientsideModels")
end

function TFA.RegisterClientsideModel(cmdl, wepv) -- DEPRECATED
	-- don't use please
	-- pleaz
	TFA.ClientsideModels[#TFA.ClientsideModels + 1] = {
		["mdl"] = cmdl,
		["wep"] = wepv
	}

	timer.Start("TFA_UpdateClientsideModels")
end

local function NotifyShouldTransmit(ent, notdormant)
	if notdormant or not ent.IsTFAWeapon then return end
	if ent:GetOwner() == LocalPlayer() then return end

	ent:CleanModels(ent:GetStatRaw("ViewModelElements", TFA.LatestDataVersion))
	ent:CleanModels(ent:GetStatRaw("WorldModelElements", TFA.LatestDataVersion))
end

local function EntityRemoved(ent)
	if not ent.IsTFAWeapon then return end

	ent:CleanModels(ent:GetStatRaw("ViewModelElements", TFA.LatestDataVersion))
	ent:CleanModels(ent:GetStatRaw("WorldModelElements", TFA.LatestDataVersion))
end

hook.Add("NotifyShouldTransmit", "TFA_ClientsideModels", NotifyShouldTransmit)
hook.Add("EntityRemoved", "TFA_ClientsideModels", EntityRemoved)

--addons/egm_tfa_weapons/lua/tfa/external/csgo_hooks.lua:
local csgo_flashtime = 5
local csgo_flashfade = 2
local csgo_flashdistance = 1280
local csgo_flashdistancefade = 1280 - 512

local tab = {
		["$pp_colour_addr"] = 0,
		["$pp_colour_addg"] = 0,
		["$pp_colour_addb"] = 0,
		["$pp_colour_brightness"] = 0.0,
		["$pp_colour_contrast"] = 1.0,
		["$pp_colour_colour"] = 1.0,
		["$pp_colour_mulr"] = 0,
		["$pp_colour_mulg"] = 0,
		["$pp_colour_mulb"] = 0
}

hook.Add("RenderScreenspaceEffects", "TFA_CSGO_FLASHBANG", function()
		local ply = LocalPlayer()
		if not IsValid(ply) then return end
		local flashtime = ply:GetNWFloat("LastFlash", -999)
		local flashdistance = ply:GetNWFloat("FlashDistance", 0)
		local flashfac = ply:GetNWFloat("FlashFactor", 1)
		local distancefac = 1 - math.Clamp((flashdistance - csgo_flashdistance + csgo_flashdistancefade) / csgo_flashdistancefade, 0, 1)
		local intensity = 1 - math.Clamp(((CurTime() - flashtime) / distancefac - csgo_flashtime + csgo_flashfade) / csgo_flashfade, 0, 1)
		intensity = intensity * distancefac
		intensity = intensity * math.Clamp(flashfac + 0.1, 0.35, 1)

		if intensity > 0.01 then
				tab["$pp_colour_brightness"] = math.pow(intensity, 3)
				tab["$pp_colour_colour"] = 1 - intensity * 0.33
				DrawColorModify(tab) --Draws Color Modify effect
				DrawMotionBlur(0.2, intensity, 0.03)
		end
end)
--lua/tfa/att/blue_stun.lua:
if not ATTACHMENT then
	ATTACHMENT = {}
end

ATTACHMENT.Name = "Blue Tibanna Stun Cartridges"
ATTACHMENT.ShortName = "BTSGC" --Abbreviation, 5 chars or less please
--ATTACHMENT.ID = "base" -- normally this is just your filename
ATTACHMENT.Description = { 
TFA.AttachmentColors["="],"Stun ammo. Uses the same unique ammo as the explosive and assination types.",
TFA.AttachmentColors["-"],"%50 increase to Clip Size",
TFA.AttachmentColors["-"],"",
}
ATTACHMENT.Icon = "entities/tfa_ammo_fragshell.png" --Revers to label, please give it an icon though!  This should be the path to a png, like "entities/tfa_ammo_match.png"
ATTACHMENT.Damage = 8

ATTACHMENT.WeaponTable = {
	["Primary"] = {
		["Damage"] = 8,
		["ClipSize"] = 50,
		["DefaultClip"] = 50,
		["RPM"] = 200,
		["RPM_Burst"] = function( wep, val) return val * 0.75 end,
		["Spread"] = function( wep, val) return val * 2 end,
		["IronAccuracy"] = function( wep, val) return val * 10 end,
		["Force "] = 500,
		["AmmoConsumption"] = 5,
		["Ammo"] = "RPG_Round",
		["Sound"] = "weapons/bf3/e11_light.wav"
	},
	["MoveSpeed"] = 1.05,
	["TracerName"] = "effect_sw_laser_blue_stun",
	["CustomBulletCallback"] = function(a,b,c)
	TFA_RP_MeltEasy(a,b,c,8,"BGOLightning")
end
}



if not TFA_ATTACHMENT_ISUPDATING then
	TFAUpdateAttachments()
end
--lua/tfa/att/mod_stun5_servius.lua:
if not ATTACHMENT then
	ATTACHMENT = {}
end


ATTACHMENT.Name = "Charge Round Alpha"
ATTACHMENT.ShortName = "5s" --Abbreviation, 5 chars or less please
--ATTACHMENT.ID = "base" -- normally this is just your filename
ATTACHMENT.Description = { 
	TFA.AttachmentColors["+"],"Stunned for 5 Seconds",
}
ATTACHMENT.Icon = "entities/icon/mod_stun5.png" --Refers to label, please give it an icon though!  This should be the path to a png, like "entities/tfa_ammo_match.png"

ATTACHMENT.WeaponTable = {
	["Primary"] = {
		["AmmoConsumption"] = 7,
		["StatusEffect"] = "stun",
		["StatusEffectDmg"] = 5,
		["StatusEffectDur"] = 5,
		["StatusEffectParticle"] = true,
	},
	["TracerName"] = "effect_sw_laser_blue_stun",
}

function ATTACHMENT:Attach(wep)
	wep.CustomBulletCallbackOld = wep.CustomBulletCallbackOld or wep.CustomBulletCallback
	wep.CustomBulletCallback = function(a, tr, dmg)
		local wep = dmg:GetInflictor()
		if wep:GetStat("Primary.StatusEffect") then
			GMSERV:AddStatus(tr.Entity, wep:GetOwner(), wep:GetStat("Primary.StatusEffect"), wep:GetStat("Primary.StatusEffectDur"), wep:GetStat("Primary.StatusEffectDmg"), wep:GetStat("Primary.StatusEffectParticle"))
			--util.Effect("BGOLightning", ED_Stun, true, true)
		end
	end
end

function ATTACHMENT:Detach(wep)
	wep.CustomBulletCallback = wep.CustomBulletCallbackOld
	wep.CustomBulletCallbackOld = nil
end

if not TFA_ATTACHMENT_ISUPDATING then
	TFAUpdateAttachments()
end
--addons/egm_tfa_weapons/lua/tfa/att/swrp_dc17m_rocket.lua:
if not ATTACHMENT then
	ATTACHMENT = {}
end

ATTACHMENT.Name = "Grenade Launcher Module"
ATTACHMENT.ShortName = "G.L.M."
ATTACHMENT.Icon = "entities/dc17m_rocket.png"
ATTACHMENT.Description = {
	TFA.AttachmentColors["="], "Wechsel zum Granatwerfer Aufsatz",
}

ATTACHMENT.WeaponTable = {
	["VElements"] = {
		["rifle_module"] = {["active"] = false},
		["rifle_mag"] = {["active"] = false},
		["rocket_module"] = {["active"] = true},
	},

	["WElements"] = {
		["rifle_module"] = {["active"] = false},
		["rifle_mag"] = {["active"] = false},
		["rocket_module"] = {["active"] = true},
	},

	["Primary"] = {
		["Sound"] = "w/dc17mrocket.wav",
		["KickUp"] = function(wep,stat) return stat * 4 end,
		["KickDown"] = function(wep,stat) return stat * 4 end,
		["Damage"] = 2000,
		["Projectile"] = "zeus_explosivegrenade",
		["ProjectileVelocity"] = 3000,
		["Ammo"] = "smg1_grenade",
		["ClipSize"] = 1,
		["RPM"] = 200,
	},

	["FireModes"] = {
		"rw_sw_ent_nade_impact",
		"rw_sw_ent_nade_heal",
		"rw_sw_ent_nade_incendiary",
		"rw_sw_ent_nade_poison",
		"rw_sw_ent_nade_poison_stun",
		"rw_sw_ent_nade_smoke",
		"rw_sw_ent_nade_stun",
		"rw_sw_ent_nade_thermal",
		"rw_sw_ent_nade_train",
		"rw_sw_ent_nade_flash",
		"rw_sw_ent_nade_emp",
	},
}

function ATTACHMENT:Attach(wep)
	wep.IsGrenadelauncher = true
	wep:Unload()

	timer.Simple(1, function()
		wep:CycleFireMode()
	end)
end

function ATTACHMENT:Detach(wep)
	wep.IsGrenadelauncher = false
	wep:Unload()

	timer.Simple(1, function()
		wep:SetFireMode(1)
		wep:CycleSafety()
	end)
end

if not TFA_ATTACHMENT_ISUPDATING then
	TFAUpdateAttachments()
end
--addons/egm_tfa_weapons/lua/tfa/att/swrp_snp_silencer.lua:
if not ATTACHMENT then
	ATTACHMENT = {}
end

ATTACHMENT.Name = "Schalldämpfer"
ATTACHMENT.ShortName = "SIL" --Abbreviation, 5 chars or less please
ATTACHMENT.Description = { TFA.Attachments.Colors["+"], "Veringert Schussgeräusch", TFA.Attachments.Colors["-"], "Veringert Abkühlung um 50%"}
ATTACHMENT.Icon = "entities/tfa_ammo_match.png" --Revers to label, please give it an icon though!  This should be the path to a png, like "entities/tfa_ammo_match.png"

ATTACHMENT.WeaponTable = {
	["CoolPerSecond"] = function( wep, stat ) return stat * 0.5 end,
	["Primary"] = {
		["Sound"] = "w/dc19.wav",
	},
}

if not TFA_ATTACHMENT_ISUPDATING then
	TFAUpdateAttachments()
end

--addons/tfa_base/lua/tfa/attbatch/0_base_attachments.lua:
if not TFA_ATTACHMENT_ISUPDATING then TFAUpdateAttachments(false) return end

TFA.Attachments.RegisterFromTable("am_gib", {
	Name = "G.I.B Ammunition",
	ShortName = "GIB",
	Description = {
		TFA.Attachments.Colors["+"], "Always gibs enemies",
		TFA.Attachments.Colors["+"], "10% more damage",
		TFA.Attachments.Colors["-"], "20% more recoil",
		TFA.Attachments.Colors["-"], "10% more spread"
	},
	Icon = "entities/tfa_ammo_gib.png",
	TFADataVersion = TFA.LatestDataVersion,

	WeaponTable = {
		Primary = {
			DamageType = function(wep,stat) return bit.bor( stat or DMG_BULLET, DMG_ALWAYSGIB ) end,
			Damage = function( wep, stat ) return stat * 1.1 end,
			Spread = function( wep, stat ) return stat * 1.1 end,
			IronAccuracy = function( wep, stat ) return stat * 1.1 end,
			KickUp = function( wep, stat ) return stat * 1.2 end,
			KickDown = function( wep, stat ) return stat * 1.2 end
		}
	}
})
TFA.Attachments.RegisterFromTable("am_magnum", {
	Name = "Magnum Ammunition",
	ShortName = "MAG",
	Description = {
		TFA.Attachments.Colors["+"], "10% more damage",
		TFA.Attachments.Colors["-"], "15% more recoil",
		TFA.Attachments.Colors["-"], "10% more spread"
	},
	Icon = "entities/tfa_ammo_magnum.png",
	TFADataVersion = TFA.LatestDataVersion,

	WeaponTable = {
		Primary = {
			Damage = function( wep, stat ) return stat * 1.1 end,
			Spread = function( wep, stat ) return stat * 1.1 end,
			IronAccuracy = function( wep, stat ) return stat * 1.1 end,
			KickUp = function( wep, stat ) return stat * 1.15 end,
			KickDown = function( wep, stat ) return stat * 1.15 end
		}
	}
})
TFA.Attachments.RegisterFromTable("am_match", {
	Name = "Match Ammunition",
	ShortName = "Match",
	Description = {
		TFA.Attachments.Colors["+"], "20% lower spread kick",
		"10% lower recoil",
		TFA.Attachments.Colors["-"], "20% lower spread recovery"
	},
	Icon = "entities/tfa_ammo_match.png",
	TFADataVersion = TFA.LatestDataVersion,

	WeaponTable = {
		Primary = {
			SpreadIncrement = function( wep, stat ) return stat * 0.9 end,
			SpreadRecovery = function( wep, stat ) return stat * 0.8 end,
			KickUp = function( wep, stat ) return stat * 0.9 end,
			KickDown = function( wep, stat ) return stat * 0.9 end
		}
	}
})

TFA.Attachments.RegisterFromTable("sg_frag", {
	Name = "Frag Ammunition",
	ShortName = "Frag",
	Description = {
		TFA.Attachments.Colors["+"], "Explosive Damage",
		"2x damage",
		TFA.Attachments.Colors["-"], "0.5x pellets"
	},
	Icon = "entities/tfa_ammo_fragshell.png",
	TFADataVersion = TFA.LatestDataVersion,

	WeaponTable = {
		["Primary"] = {
			["DamageType"] = function(wep,stat) return bit.bor( stat or 0, DMG_BLAST ) end,
			["Damage"] = function(wep,stat) return stat * 2 end,
			["NumShots"] = function(wep,stat) return stat / 2 end
		}
	}
})
TFA.Attachments.RegisterFromTable("sh_slug", {
	Name = "Slug Ammunition",
	ShortName = "Slug",
	Description = {
		TFA.Attachments.Colors["+"], "Much lower spread",
		TFA.Attachments.Colors["+"], "100m higher range",
		TFA.Attachments.Colors["-"], "30% less damage",
		"One pellet"
	},
	Icon = "entities/tfa_ammo_slug.png",
	TFADataVersion = TFA.LatestDataVersion,

	WeaponTable = {
		Primary = {
			Damage = function( wep, stat ) return wep.Primary_TFA.NumShots * stat * 0.7 end,
			NumShots = function( wep, stat ) return 1, true end,
			Spread = function( wep, stat ) return math.max( stat - 0.015, stat * 0.5 ) end,
			IronAccuracy = function( wep, stat ) return math.max( stat - 0.03, stat * 0.25 ) end,
			Range = function( wep, stat ) return stat + 100 * 39.370 end
		}
	}
})



TFA.Attachments.RegisterFromTable("br_supp", {
	Name = "Suppressor",
	Description = {
		TFA.Attachments.Colors["+"], "Less firing noise",
		TFA.Attachments.Colors["-"], "10% less spread",
		TFA.Attachments.Colors["-"], "5% less damage",
		TFA.Attachments.Colors["-"], "10% less vertical recoil"
	},
	Icon = "entities/tfa_br_supp.png",
	ShortName = "SUPP",
	TFADataVersion = TFA.LatestDataVersion,

	WeaponTable = {
		["ViewModelElements"] = {
			["suppressor"] = {
				["active"] = true
			}
		},
		["WorldModelElements"] = {
			["suppressor"] = {
				["active"] = true
			}
		},
		["Primary"] = {
			["Damage"] = function(wep,stat) return stat * 0.95 end,
			["KickUp"] = function(wep,stat) return stat * 0.9 end,
			["KickDown"] = function(wep,stat) return stat * 0.9 end,
			["Spread"] = function(wep,stat) return stat * 0.9 end,
			["IronAccuracy"] = function(wep,stat) return stat * 0.9 end,
			["Sound"] = function(wep,stat) return wep.Primary.SilencedSound or stat end
		},
		["MuzzleFlashEffect"] = "tfa_muzzleflash_silenced",
		["MuzzleAttachmentMod"] = function(wep,stat) return wep.MuzzleAttachmentSilenced or stat end
	}
})

TFA.Attachments.RegisterFromTable("si_acog", {
	Base = "si_rt_base",
	Name = "ACOG",
	Description = {
		TFA.Attachments.Colors["="], "4x zoom",
		TFA.Attachments.Colors["-"], "20% higher zoom time",
		TFA.Attachments.Colors["-"], "10% slower aimed walking"
	},
	Icon = "entities/tfa_si_acog.png",
	ShortName = "ACOG",
	TFADataVersion = TFA.LatestDataVersion,

	WeaponTable = {
		["ViewModelElements"] = {
			["acog"] = {
				["active"] = true
			},
			["rtcircle_acog"] = {
				["active"] = true
			}
		},
		["WorldModelElements"] = {
			["acog"] = {
				["active"] = true
			}
		},
		["IronSightsPosition"] = function( wep, val ) return wep.IronSightsPos_ACOG or val, true end,
		["IronSightsAngle"] = function( wep, val ) return wep.IronSightsAng_ACOG or val, true end,
		["IronSightsSensitivity"] = function(wep,val) return TFA.CalculateSensitivtyScale( 90 / 4 / 2, wep:GetStatL("Secondary.OwnerFOV"), wep.ACOGScreenScale ) end ,
		["Secondary"] = {
			["OwnerFOV"] = function( wep, val ) return val * 0.7 end
		},
		["IronSightTime"] = function( wep, val ) return val * 1.20 end,
		["IronSightMoveSpeed"] = function(stat) return stat * 0.9 end,
		["RTOpaque"] = true,
		["RTMaterialOverride"] = -1,

		["RTScopeFOV"] = 90 / 4 / 2, -- Default FOV / Scope Zoom / screenscale

		["RTReticleMaterial"] = Material("scope/gdcw_acog"),
		["RTReticleScale"] = 1,
	}
})
TFA.Attachments.RegisterFromTable("si_aimpoint", {
	Name = "Aimpoint",
	Description = {
		TFA.Attachments.Colors["="], "10% higher zoom",
		TFA.Attachments.Colors["-"], "10% higher zoom time"
	},
	Icon = "entities/tfa_si_aimpoint.png",
	ShortName = "AIM",
	TFADataVersion = TFA.LatestDataVersion,

	WeaponTable = {
		["ViewModelElements"] = {
			["aimpoint"] = {
				["active"] = true
			},
			["aimpoint_spr"] = {
				["active"] = true
			}
		},
		["WorldModelElements"] = {
			["aimpoint"] = {
				["active"] = true
			},
			["aimpoint_spr"] = {
				["active"] = true
			}
		},
		["IronSightsPosition"] = function( wep, val ) return wep.IronSightsPos_AimPoint or val, true end,
		["IronSightsAngle"] = function( wep, val ) return wep.IronSightsAng_AimPoint or val, true end,
		["Secondary"] = {
			["OwnerFOV"] = function( wep, val ) return val * 0.9 end
		},
		["IronSightTime"] = function( wep, val ) return val * 1.10 end
	}
})
TFA.Attachments.RegisterFromTable("si_eotech", {
	Name = "EOTech",
	Description = {
		TFA.Attachments.Colors["="], "10% higher zoom",
		TFA.Attachments.Colors["-"], "10% higher zoom time"
	},
	Icon = "entities/tfa_si_eotech.png",
	ShortName = "EOTEK",
	TFADataVersion = TFA.LatestDataVersion,

	WeaponTable = {
		["ViewModelElements"] = {
			["eotech"] = {
				["active"] = true
			}
		},
		["WorldModelElements"] = {
			["eotech"] = {
				["active"] = true
			}
		},
		["IronSightsPosition"] = function( wep, val ) return wep.IronSightsPos_EOTech or val, true end,
		["IronSightsAngle"] = function( wep, val ) return wep.IronSightsAng_EOTech or val, true end,
		["Secondary"] = {
			["OwnerFOV"] = function( wep, val ) return val * 0.9 end
		},
		["IronSightTime"] = function( wep, val ) return val * 1.10 end
	}
})

--lua/autorun/tomackerson.lua:
list.Set( "PlayerOptionsModel", "tomackerson", "models/fisher/tomackerson/tomackerson.mdl")
player_manager.AddValidModel( "tomackerson", "models/fisher/tomackerson/tomackerson.mdl")
--lua/autorun/vector_cvp.lua:
list.Set( "PlayerOptionsModel",  "Vector_cvp", "models/player/lordvipes/rerc_vector/vector_cvp.mdl" )
player_manager.AddValidModel( "Vector_cvp", "models/player/lordvipes/rerc_vector/vector_cvp.mdl" )
player_manager.AddValidHands( "Vector_cvp", "models/player/lordvipes/rerc_vector/arms/vectorarms_cvp.mdl", 0, "00000000" )

--lua/autorun/venator_border_toggle.lua:
// Created by Airfox aka. Konsti
// Huge thanks to him!

if game.GetMap() ~= "rp_venator_extensive_v1_4" then return end

local nextTick = nextTick or 0
local material = Material("kingpommes/map_borders/red_opacity3")
local defaultTexture = "kingpommes/map_borders/red_opacity3"
local invisibleTexture = "kingpommes/starwars/venator/invis"
local borderVisible = true
material:SetTexture("$basetexture", defaultTexture)

if SERVER then
	util.AddNetworkString("Venator_Ext_BorderNet")

	-- Networks current state to every new player that joins the server.
	hook.Add("PlayerInitialSpawn", "Venator_Ext_BorderConnectSync", function(ply)
		net.Start("Venator_Ext_BorderNet")
			net.WriteBool(borderVisible)
		net.Send(ply)
	end)
end

hook.Add("Think", "Venator_Ext_BorderThink", function()
	if nextTick > CurTime() then return end

	nextTick = CurTime() + 1
	
	if SERVER then
		-- Finds all entities with this name.
		local entities = ents.FindByName("border_target")

		-- Checks if an entity has been found and alarm is on. Also if the network has already been sent.
		if #entities >= 1 and borderVisible then
			borderVisible = false
			net.Start("Venator_Ext_BorderNet")
				net.WriteBool(borderVisible)
			net.Broadcast()
			
			if material:GetTexture("$basetexture"):GetName() == defaultTexture then
				material:SetTexture("$basetexture", invisibleTexture)
			end
		elseif #entities == 0 and not borderVisible then
			borderVisible = true
			net.Start("Venator_Ext_BorderNet")
				net.WriteBool(borderVisible)
			net.Broadcast()

			if material:GetTexture("$basetexture"):GetName() == invisibleTexture then
				material:SetTexture("$basetexture", defaultTexture)
			end
		end
	elseif CLIENT then
		-- Checks if alarm is on. 
		if not borderVisible then
			-- Changes between textured.
			if material:GetTexture("$basetexture"):GetName() == defaultTexture then
				material:SetTexture("$basetexture", invisibleTexture)
			end
		else
			-- Resets the texture to default, when the border should be visible.
			if material:GetTexture("$basetexture"):GetName() == invisibleTexture then
				material:SetTexture("$basetexture", defaultTexture)
			end
		end
	end
end)

if CLIENT then
	-- Receives current state.
	net.Receive("Venator_Ext_BorderNet", function(len)
		borderVisible = net.ReadBool()
	end)
end
--lua/autorun/venator_hdrenabler.lua:

--Created by Mattzi
--Oninoni helped too

if game.GetMap() ~= "rp_venator_extensive_v1_4" then
	return
end

if SERVER then 
	AddCSLuaFile()
end

if CLIENT then
	timer.Simple(5, function()
	local deathstar_mat_hdr_level = GetConVar( "mat_hdr_level" ):GetInt()
		if deathstar_mat_hdr_level < 2 then
			local HDRFrame = vgui.Create("DFrame")
			HDRFrame:SetSize(ScrW()*0.2, ScrH()*0.1)
			HDRFrame:Center()
			HDRFrame:MakePopup()
			HDRFrame:SetTitle("Change HDR Level?")
			HDRFrame:ShowCloseButton(false)
		
			local RichTextHDR = vgui.Create("RichText", HDRFrame)
			RichTextHDR:InsertColorChange(255,70,70,255)
			RichTextHDR:Dock(FILL)
			RichTextHDR:SetVerticalScrollbarEnabled(false)
			RichTextHDR:AppendText("This map only supports HDR. Enable it or live with this horrid mess.")
			function RichTextHDR:PerformLayout()
				self:SetFontInternal( "DermaLarge" )
			end
		
			local acceptbutton = vgui.Create("DButton", HDRFrame)
			acceptbutton:SetText("Activate and reconnect")
			acceptbutton:Dock(BOTTOM)
			acceptbutton.DoClick = function()
				RunConsoleCommand( "mat_hdr_level", "2" )
				timer.Simple( 3, function() RunConsoleCommand( "retry" ) end )
			end
		
			local leavebutton = vgui.Create("DButton", HDRFrame)
			leavebutton:SetText("I dont care")
			leavebutton:Dock(BOTTOM)
			leavebutton.DoClick = function()
				-- RunConsoleCommand("disconnect")
				HDRFrame:Remove()
			end
		end
	end)
end
--lua/autorun/visas_marr.lua:
player_manager.AddValidModel( "[K] Visas Marr", "models/kryptonite/visas_marr/visas_marr.mdl" ) 
list.Set( "PlayerOptionsModel",  "[K] Visas Marr", "models/kryptonite/visas_marr/visas_marr.mdl" ) 
--addons/vyhub-gmod/lua/autorun/vyhub_load.lua:

local f = string.format

VyHub = VyHub or {}
VyHub.Config = VyHub.Config or {}
VyHub.Lib = VyHub.Lib or {}
VyHub.ready = false

local vyhub_root = "vyhub"

local color_warn = Color(211, 120, 0)
local color_err = Color(255, 0, 0)
local color_green = Color(0, 255, 0)

function VyHub:msg(message, type)
    type = type or "neutral"

    // Remove color tags
    message = string.gsub(message, "<([%l]+)>([^<]+)</%1>", "%2")

	if type == "success" then
		MsgC("[VyHub] ", color_green, message .. "\n")
	elseif type == "error" then
		MsgC("[VyHub] [ERROR] ", color_err, message .. "\n")
	elseif type == "neutral" then
		MsgC("[VyHub] ", color_white, message .. "\n")
    elseif type == "warning" then
		MsgC("[VyHub] [WARN] ", color_warn, message .. "\n")
    elseif type == "debug" and VyHub.Config.debug then
		MsgC("[VyHub] [Debug] ", color_white, message .. "\n")
	end
end

VyHub:msg("Initializing...")

if SERVER then
    addon_incomplete = false

    if file.Exists( vyhub_root .. '/lang/en.json', "LUA") then
        if file.Exists( vyhub_root .. '/config/sv_config.lua', "LUA") then
            hook.Run("vyhub_loading_start")

            -- libs
            VyHub:msg("Loading lib files...")
            local files = file.Find( vyhub_root .."/lib/*.lua", "LUA" )
            for _, file in ipairs( files ) do
                AddCSLuaFile( vyhub_root .. "/lib/" .. file )
                include( vyhub_root .. "/lib/" .. file )
            end

            -- Shared Config
            include( vyhub_root .. '/config/sh_config.lua' )
            AddCSLuaFile( vyhub_root .. "/config/sh_config.lua" )

            -- Language
            VyHub:msg('Loading ' .. VyHub.Config.lang .. ' language...')
            include( vyhub_root .. '/shared/sh_lang.lua' )

            -- Config Files
            VyHub:msg("Loading config files...")
            include( vyhub_root .. '/config/sv_config.lua' )

            -- Shared Files
            VyHub:msg("Loading shared files...")
            local files = file.Find( vyhub_root .."/shared/*.lua", "LUA" )
            for _, file in ipairs( files ) do
                AddCSLuaFile( vyhub_root .. "/shared/" .. file )
                include( vyhub_root .. "/shared/" .. file )
            end
            
            -- Client Files
            VyHub:msg("Loading client files...")
            local files = file.Find( vyhub_root .."/client/*.lua", "LUA" )
            for _, file in ipairs( files ) do
                AddCSLuaFile( vyhub_root .."/client/" .. file )
            end

            -- Server Files
            VyHub:msg("Loading server files...")
            local files = file.Find( vyhub_root .. "/server/*.lua", "LUA" )
            for _, file in ipairs( files ) do
                include( vyhub_root .. "/server/" .. file )
            end

            game.ConsoleCommand("sv_hibernate_think 1\n")

            file.CreateDir("vyhub")

            VyHub.Config:load_cache_config()

            timer.Simple(2, function()
                hook.Run("vyhub_loading_finish")
            end)
            
            VyHub:msg("Finished loading!")
        else
            VyHub:msg("Could not find lua/vyhub/config/sv_config.lua. Please make sure it exists.", "error")
        end
    else
        VyHub:msg("!!!", "error")
        VyHub:msg("!!!", "error")
        VyHub:msg("!!!", "error")
        VyHub:msg("Could not find language files!!! Please make sure to download a correct vyhub-gmod release here: https://github.com/matbyte-com/vyhub-gmod/releases", "error")
        VyHub:msg("Cannot proceed with initialization.", "error")
        VyHub:msg("!!!", "error")
        VyHub:msg("!!!", "error")
        VyHub:msg("!!!", "error")
    end
end


if CLIENT then
    if file.Exists( vyhub_root .. '/shared/sh_lang.lua', "LUA") then
        hook.Run("vyhub_loading_start")
        
        -- libs
        VyHub:msg("Loading lib files...")
        local files = file.Find( vyhub_root .."/lib/*.lua", "LUA" )
        for _, file in ipairs( files ) do
            include( vyhub_root .. "/lib/" .. file )
        end

        -- Language
        VyHub:msg('Loading language...')
        include( vyhub_root .. '/shared/sh_lang.lua' )

        -- Config Files
        VyHub:msg("Loading config files...")
        local files = file.Find( vyhub_root .."/config/*.lua", "LUA" )
        for _, file in ipairs( files ) do
            if not string.StartWith(file, 'sv_') then
                include( vyhub_root .. "/config/" .. file )
            end
        end

        -- Shared Files
        VyHub:msg("Loading shared files...")
        local files = file.Find( vyhub_root .."/shared/*.lua", "LUA" )
        for _, file in ipairs( files ) do
            include( vyhub_root .. "/shared/" .. file )
        end

        -- Client Files
        VyHub:msg("Loading client files...")
        local files = file.Find( vyhub_root .."/client/*.lua", "LUA" )
        for _, file in ipairs( files ) do
            include( vyhub_root .."/client/" .. file )
        end

        timer.Simple(2, function()
            hook.Run("vyhub_loading_finish")
        end)
        
        VyHub:msg("Finished loading!")
    else
        VyHub:msg("!!!", "error")
        VyHub:msg("!!!", "error")
        VyHub:msg("!!!", "error")
        VyHub:msg("VyHub not correctly loaded. Please check the server log.", "error")
        VyHub:msg("!!!", "error")
        VyHub:msg("!!!", "error")
        VyHub:msg("!!!", "error")
    end
end

--addons/vyhub-gmod/lua/vyhub/client/cl_chattag.lua:
local f = string.format

local color_red = Color(255, 0, 0)

if VyHub.Config.chat_tags and not DarkRP then
	hook.Add("OnPlayerChat", "vyhub_chattag_OnPlayerChat", function(ply, msg)
		if IsValid(ply) then
			local group = VyHub.Group:get(ply:GetUserGroup())

			if group then
				local teamcolor = team.GetColor(ply:Team())
				local deadTag = ""

				if not ply:Alive() then
					deadTag = f("*%s* ", VyHub.lang.other.dead)
				end

				chat.AddText(VyHub.Util:hex2rgb(group.color), "[", group.name, "]", " ", color_red, deadTag, teamcolor, ply:Nick(), color_white, ": ", msg)

				return true
			end
		end
	end)
end
--addons/vyhub-gmod/lua/vyhub/client/cl_dashboard.lua:
local f = string.format

VyHub.Dashboard = VyHub.Dashboard or {}

VyHub.Dashboard.ui = VyHub.Dashboard.ui or nil

VyHub.Dashboard.html_ready = false
VyHub.Dashboard.html_generated = VyHub.Dashboard.html_generated or false

local dashboard_html = dashboard_html or "Loading, please try again. If this does not help, please ask the server owner to check for errors in the server console. In most cases, vyhub-gmod has not been downloaded correctly and is missing files."

function VyHub.Dashboard:create_ui()
	VyHub.Dashboard.html_ready = false

	local xsize = ScrW() - ScrW()/4
	local ysize = ScrH() - ScrH()/4
	local xpos  = ScrW()/2 - xsize/2
	local ypos  = ScrH()/2 - ysize/2
	local title = "VyHub Server-Dashboard"
	local box_color = Color(94, 0, 0, 255)

	VyHub.Dashboard.ui = vgui.Create("DFrame")
	VyHub.Dashboard.ui:SetSize(xsize, ysize)
	VyHub.Dashboard.ui:SetPos(xpos, ypos)
	VyHub.Dashboard.ui:SetDraggable(true)
	VyHub.Dashboard.ui:SetTitle(title)
	VyHub.Dashboard.ui:SetDeleteOnClose(false)
	function VyHub.Dashboard.ui.Paint(self, w, h)
		surface.SetDrawColor(box_color)
		surface.DrawRect(0, 0, w, 24)
	end

	VyHub.Dashboard.ui_html = vgui.Create("DHTML", VyHub.Dashboard.ui)
	VyHub.Dashboard.ui_html:SetSize(xsize, ysize - 24)
	VyHub.Dashboard.ui_html:SetPos(0, 24)
	VyHub.Dashboard.ui_html:SetHTML(dashboard_html)

	function VyHub.Dashboard.ui_html:OnDocumentReady()
		MsgN("VyHub Dashboard: HTML Loaded")
		VyHub.Dashboard.html_ready = true
		VyHub.Dashboard.ui_html:RunJavascript('local_steamid64 = ' .. LocalPlayer():SteamID64())
	end

	VyHub.Dashboard.ui_html:AddFunction("vyhub", "warning_toggle", function (warning_id)
		LocalPlayer():ConCommand(f("vh_warning_toggle %s", warning_id))
	end)
	VyHub.Dashboard.ui_html:AddFunction("vyhub", "warning_delete", function (warning_id)
		LocalPlayer():ConCommand(f("vh_warning_delete %s", warning_id))
	end)
	VyHub.Dashboard.ui_html:AddFunction("vyhub", "ban_set_status", function (ban_id, status)
		LocalPlayer():ConCommand(f("vh_ban_set_status %s %s", ban_id, status))
	end)
	VyHub.Dashboard.ui_html:AddFunction("vyhub", "warning_create", function (steamid, reason)
		LocalPlayer():ConCommand(f('vh_warn %s "%s"', steamid, VyHub.Util:escape_concommand_str(reason)))
	end)
	VyHub.Dashboard.ui_html:AddFunction("vyhub", "ban_create", function (steamid, minutes, reason)
		LocalPlayer():ConCommand(f('vh_ban %s "%s" "%s"', steamid, minutes, VyHub.Util:escape_concommand_str(reason)))
	end)
end

function VyHub.Dashboard:load_html()
	VyHub.Dashboard.html_generated = true
	dashboard_html = [[
		<html>
			<head>
				<meta charset="utf-8">
				<meta name="viewport" content="width=device-width, initial-scale=1">

				<link rel="stylesheet" href="http://cdn.vyhub.net/assets/roboto-v30-latin/roboto-v30-latin.css">
				<link rel="stylesheet" href="http://cdn.vyhub.net/assets/font-awesome-4.7.0/css/font-awesome.min.css">
				<link rel="stylesheet" href="http://cdn.vyhub.net/assets/bootswatch-darkly.min.css">

				<style>
					::selection {
						background: #b5b5b5; /* WebKit/Blink Browsers */
					}

					body{
						overflow-x: hidden;
						overflow-y: scroll;
						font-family: Roboto !important;
					}

					.vh-input {
						background-color: #303030; 
						color: white; 
						height: 30px;
					}

					.nav-pills .active {
						background-color: #303030;
						font-weight: bold;
						margin-left: 4px;
					}

					.user-tab {
						padding: 3px 6px 3px 6px;
						border-radius: 8px;
						text-overflow: ellipsis;
						overflow:hidden; 
					}

					#user_name {
						width: 50%;
						text-overflow: ellipsis;
						overflow: hidden;
					}
				</style>
			</head>
			<body>	
				<div class="row" style="margin: 10px">
					<div class="col-xs-4 col-lg-3">
						<div class="input-group">
							<div class="input-group-addon"><i class="fa fa-search"></i></div>
							<input style="height: 40px;" id="user_search" type="text" class="form-control vh-input" onclick="$('#user_search').val(''); generate_user_list();" onkeyup="generate_user_list()" >
						</div>
						<br/>
						<ul class="nav nav-pills nav-stacked" id="user_list">

						</ul>
					</div>
					<div class="col-xs-8 col-lg-9">
						<div id="user_content_empty">
							]] .. VyHub.lang.dashboard.select_user .. [[
						</div>
						<div class="tab-content" id="user_content" style="display: none;">
							<h3 style="margin: 5px 0px 0px 0;">
								<div class="row">
									<div class="col-xs-9">
										<span id="user_name">
											<span class="label label-default" style="background-color: #5E0000; border-radius: .25em 0 0 .25em;">
												<i class="fa fa-user"></i> &nbsp;<span id="user_content_name"></span>
											</span>
											<span class="label label-default" style="border-radius: 0 .25em .25em 0;">
												<span id="user_content_username"></span>
											</span>
										</span>
									</div>
									<div class="col-xs-3">
										<span id="user_memberships" class="pull-right">
										</span>
									</div>
								</div>
							</h3>

							<hr/>

							<h4><span class="label label-default"><i class="fa fa-exclamation-triangle"></i> &nbsp;]] .. VyHub.lang.other.warnings .. [[</span></h3>

							<div class="row perm-warning_edit">
								<div class="col-xs-10">
									<input id="user_warn" type="text" class="form-control vh-input" onclick="$('#user_warn').val('');" placeholder="]] .. VyHub.lang.other.reason .. [[" />
								</div>
								<div class="col-xs-2" style="padding-left: 0;">
									<button style="height: 30px;" onclick="create_warning()" class="btn btn-warning btn-xs btn-block"><i class="fa fa-exclamation-triangle"></i> &nbsp; ]] .. VyHub.lang.dashboard.action_warn .. [[</button>
								</div>
							</div>

							<br/>

							<table class="table table-condensed table-hover">
								<tr>
									<th width="10px"></th>
									<th>]] .. VyHub.lang.other.reason .. [[</th>
									<th>]] .. VyHub.lang.other.admin .. [[</th>
									<th>]] .. VyHub.lang.other.date .. [[</th>
									<th class="text-right">]] .. VyHub.lang.other.actions .. [[</th>
								</tr>

								<tbody id="user_content_warnings">
								</tbody>
							</table>

							<div>
								<span class="label label-success"><i class="fa fa-check"></i>&nbsp; ]] .. VyHub.lang.other.active .. [[</span>
								<span class="label label-warning"><i class="fa fa-hourglass"></i>&nbsp; ]] .. VyHub.lang.other.inactive .. [[</span>
								<span class="label label-default"><i class="fa fa-times"></i>&nbsp; ]] .. VyHub.lang.other.disabled .. [[</span>
							</div>

							<hr />
							
							<h4><span class="label label-default"><i class="fa fa-gavel"></i> &nbsp;]] .. VyHub.lang.other.bans .. [[</span></h3>

							<div class="row perm-ban_edit">
								<div class="col-xs-8">
									<input id="user_ban_reason" type="text" class="form-control vh-input" onclick="$('#user_ban_reason').val('');" placeholder="]] .. VyHub.lang.other.reason .. [[" />
								</div>
								<div class="col-xs-2" style="padding-left: 0;">
									<input id="user_ban_minutes" type="text" class="form-control vh-input" onclick="$('#user_ban_minutes').val('');" placeholder="]] .. VyHub.lang.other.minutes .. [[" />
								</div>
								<div class="col-xs-2" style="padding-left: 0;">
									<button style="height: 30px;" onclick="create_ban()" class="btn btn-danger btn-xs btn-block"><i class="fa fa-gavel"></i> &nbsp; ]] .. VyHub.lang.dashboard.action_ban .. [[</button>
								</div>
							</div>

							<br/>

							<table class="table table-condensed table-hover">
								<tr>
									<th width="10px"></th>
									<th>]] .. VyHub.lang.other.reason .. [[</th>
									<th>]] .. VyHub.lang.other.admin .. [[</th>
									<th>]] .. VyHub.lang.other.date .. [[</th>
									<th>]] .. VyHub.lang.other.minutes .. [[</th>
									<th class="text-right">]] .. VyHub.lang.other.actions .. [[</th>
								</tr>

								<tbody id="user_content_bans">
								</tbody>
							</table>

							<div>
								<span class="label label-success"><i class="fa fa-check"></i>&nbsp; ]] .. VyHub.lang.other.active .. [[</span>
								<span class="label label-info"><i class="fa fa-globe"></i>&nbsp; ]] .. VyHub.lang.other.active_global .. [[</span>
								<span class="label label-warning"><i class="fa fa-times"></i>&nbsp; ]] .. VyHub.lang.other.unbanned .. [[</span>
								<span class="label label-danger"><i class="fa fa-hourglass"></i>&nbsp; ]] .. VyHub.lang.other.inactive .. [[</span>
							</div>
						</div>
					</div>
				</div>
			</body>

			<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.2.4/jquery.min.js"></script>
			<script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.30.1/moment.min.js"></script>
			<script>
				var perms = null;
				var users = [];
				var users_by_id = {};
				var current_user = null;
				var local_steamid64 = null;

				function escape(str) {
					return $("<div>").text(str).html();
				}

				function format_date(iso_str) {
					return moment(iso_str).format('YYYY-MM-DD HH:mm');
				}

				function load_data(new_data) {
					users = new_data;
					users_by_id = {};
					
					new_data.forEach(function(user) {
						users_by_id[user.id] = user;
					});

					generate_user_list() 
				}

				function load_perms(new_perms) {
					perms = new_perms;
				}
				
				function enforce_perms() {
					if (perms == null) { return; }

					Object.keys(perms).forEach(function(perm) {
						var has_perm = perms[perm];

						if (has_perm) {
							$('.perm-' + perm).show();
						} else {
							$('.perm-' + perm).hide();
						}
					});
				}

				function generate_user_list() {
					$('#user_list').html('');

					var filter = null;

					if ($('#user_search').val()) {
						filter = $('#user_search').val().toLowerCase();
					}

					var ids = [];

					var only_local_user = perms == null || (!perms.warning_show && !perms.ban_show);

					users.forEach(function(user) {
						var activity = user.activities[0];

						if (activity == null) { return; }
						if (only_local_user && user.identifier !== local_steamid64) { return; }

						if (filter != null) {
							if (activity.extra.Nickname.toLowerCase().indexOf(filter) == -1 && user.username.toLowerCase().indexOf(filter) == -1) {
								return;
							}
						}

						var color = 'white';
						if (user.memberships.length > 0) {
							color = user.memberships[0].group.color;
						}

						var warn_badge_color = ((user.warnings.length == 0) ? '#444' : "#f0ad4e");
						var ban_badge_color = ((user.bans.length == 0) ? '#444' : "#d9534f");

						$('#user_list').append(' \
						<li class="user-tab" id="user_tab_' + user.id + '" onclick="generate_user_overview(\'' + user.id + '\')" style="cursor:pointer; color: ' + color + ';"> \
							' + escape(activity.extra.Nickname) + ' \
							<span class="badge pull-right" style="background-color: ' + ban_badge_color + ';">' + user.bans.length + ' <i class="fa fa-gavel"></i></span> \
							<span class="badge pull-right" style="background-color: ' + warn_badge_color + '; margin-left: 3px; margin-right: 3px;">' + user.warnings.length + ' <i class="fa fa-exclamation-triangle"></i></span> \
						</li> \
						');

						ids.push(user.id);
					});

					if (ids.length == 1) {
						generate_user_overview(ids[0]);
					} else if (ids.length == 0) {
						$('#user_content_empty').show();
						$('#user_content').hide();
					}
				}

				function generate_user_overview(user_id) {
					current_user = null;

					$('#user_content_empty').hide();
					$('#user_content').hide();

					var user = users_by_id[user_id];
					if (user == null) {	return; }

					var activity = user.activities[0];
					if (activity == null) { return; }

					current_user = user;

					$('#user_content_name').text(activity.extra.Nickname);
					$('#user_content_username').text(user.username);

					if (activity.extra.Nickname === user.username) {
						$('#user_content_username').hide();
					} else {
						$('#user_content_username').show();
					}

					$('.user-tab').removeClass("active");
					$('#user_tab_' + user_id).addClass("active");

					$('#user_content_warnings').html('');
					user.warnings.forEach(function(warning) {
						var row_class = "success";

						if (warning.disabled) {
							row_class = "active";
						} else if (!warning.active) {
							row_class = "warning";
						}

						$('#user_content_warnings').append(' \
							<tr> \
								<td class="' + row_class + '"></td> \
								<td>' + escape(warning.reason) + '</td> \
								<td>' + escape(warning.creator.username) + '</td> \
								<td>' + format_date(warning.created_on) + '</td> \
								<td class="text-right"> \
									<button class="btn btn-default btn-xs perm-warning_edit" onclick="vyhub.warning_toggle(\'' + warning.id + '\')"><i class="fa fa-play"></i><i class="fa fa-pause"></i></button> \
									<button class="btn btn-default btn-xs perm-warning_delete" onclick="vyhub.warning_delete(\'' + warning.id + '\')"><i class="fa fa-trash"></i></button> \
								</td> \
							</tr> \
						');
					});

					$('#user_content_bans').html('');
					user.bans.forEach(function(ban) {
						var minutes = '∞';

						if (ban.length != null) {
							minutes = Math.round(ban.length/60);
						}

						var row_class = "success";

						if (ban.status == "UNBANNED") {
							row_class = "warning";
						} else if (!ban.active) {
							row_class = "danger";
						} else if (ban.serverbundle == null) {
							row_class = "info";
						}

						var actions = "";

						if (ban.status == "ACTIVE") {
							actions += '<button class="btn btn-default btn-xs perm-ban_edit" onclick="vyhub.ban_set_status(\'' + ban.id + '\', \'UNBANNED\')"><i class="fa fa-check"></i> &nbsp;]] .. VyHub.lang.other.unban .. [[</button>';
						} else if (ban.status == "UNBANNED") {
							actions += '<button class="btn btn-default btn-xs perm-ban_edit" onclick="vyhub.ban_set_status(\'' + ban.id + '\', \'ACTIVE\')"><i class="fa fa-gavel"></i> &nbsp;]] .. VyHub.lang.other.reban .. [[</button>';
						}

						$('#user_content_bans').append(' \
							<tr> \
								<td class="' + row_class + '"></td> \
								<td>' + escape(ban.reason) + '</td> \
								<td>' + escape(ban.creator.username) + '</td> \
								<td>' + format_date(ban.created_on) + '</td> \
								<td>' + minutes + '</td> \
								<td class="text-right">' + actions + '</td> \
							</tr> \
						');
					});

					$('#user_memberships').html('');

					user.memberships.forEach(function(membership) {
						$('#user_memberships').append('<span class="label label-default" style="background-color: ' + membership.group.color + ';">' + membership.group.name + '</span>');
					});

					$('#user_content').show();

					enforce_perms();
				}

				function reload_current_user() {
					if (current_user != null) {
						generate_user_overview(current_user.id);
					}
				}

				function create_warning() {
					if (current_user == null) {
						return;
					}

					var reason = $('#user_warn').val();

					vyhub.warning_create(current_user.identifier, reason);

					$('#user_warn').val('');
				}

				function create_ban() {
					if (current_user == null) {
						return;
					}

					var reason = $('#user_ban_reason').val();
					var minutes = $('#user_ban_minutes').val();

					vyhub.ban_create(current_user.identifier, minutes, reason);

					$('#user_ban_reason').val('');
					$('#user_ban_minutes').val('');
				}
			</script>
		</html>
	]]
end


function VyHub.Dashboard:load_users(users_json) 
	VyHub.Dashboard.ui_html:RunJavascript("load_data(" .. users_json .. ");")
	VyHub.Dashboard.ui_html:RunJavascript("reload_current_user();")
end

function VyHub.Dashboard:load_perms(perms_json) 
	VyHub.Dashboard.ui_html:RunJavascript("load_perms(" .. perms_json .. ");")
end

concommand.Add("vh_dashboard", function ()
	if VyHub.Dashboard.ui == nil or not VyHub.Dashboard.ui:IsValid() then
		VyHub.Dashboard:create_ui()
		VyHub.Dashboard.ui:Show()
		VyHub.Dashboard.ui:MakePopup()
	else
		-- VyHub.Dashboard:create_ui()

--		if VyHub.Dashboard.ui != nil and VyHub.Dashboard.ui:IsValid() and VyHub.Dashboard.ui:IsVisible() then
--			VyHub.Dashboard.ui:Hide()
--		else
			VyHub.Dashboard.ui:Show()
			VyHub.Dashboard.ui:MakePopup()
--		end
	end

	net.Start("vyhub_dashboard")
	net.SendToServer()
end)


net.Receive("vyhub_dashboard", function()
	local data_length = net.ReadUInt(16)
	local data_raw = net.ReadData(data_length)
	local perms_json = net.ReadString()
	local users_json = util.Decompress(data_raw)

	timer.Create("vyhub_dashboard_html_ready", 0.3, 20, function ()
		if not VyHub.Dashboard.html_ready then
			MsgN("VyHub Dashboard: Waiting for HTML to load.")
			return
		end

		timer.Remove("vyhub_dashboard_html_ready")

		VyHub.Dashboard:load_perms(perms_json)
		VyHub.Dashboard:load_users(users_json)
	end)
end)


net.Receive("vyhub_dashboard_reload", function()
	if VyHub.Dashboard.ui and VyHub.Dashboard.ui:IsVisible() then
		MsgN("Reloading dashboard data, because server told us.")
		net.Start("vyhub_dashboard")
		net.SendToServer()
	end
end)

hook.Add("vyhub_lang_loaded", "vyhub_dashboard_vyhub_lang_loaded", function ()
	VyHub.Dashboard:load_html()
end)

if VyHub.Dashboard.html_generated then
	VyHub.Dashboard:load_html()
end


--addons/wiltos_animation_base/lua/autorun/wiltos_animbase_loader.lua:

--[[-------------------------------------------------------------------
	Animation Base:
		Create your own animations, mount animations from other games, and more!
			Powered by
						  _ _ _    ___  ____  
				__      _(_) | |_ / _ \/ ___| 
				\ \ /\ / / | | __| | | \___ \ 
				 \ V  V /| | | |_| |_| |___) |
				  \_/\_/ |_|_|\__|\___/|____/ 
											  
 _____         _                 _             _           
|_   _|__  ___| |__  _ __   ___ | | ___   __ _(_) ___  ___ 
  | |/ _ \/ __| '_ \| '_ \ / _ \| |/ _ \ / _` | |/ _ \/ __|
  | |  __/ (__| | | | | | | (_) | | (_) | (_| | |  __/\__ \
  |_|\___|\___|_| |_|_| |_|\___/|_|\___/ \__, |_|\___||___/
                                         |___/             
-------------------------------------------------------------------]]--[[
							  
	Lua Developer: King David
	Contact: http://steamcommunity.com/groups/wiltostech
		
----------------------------------------]]--


if SERVER then
	AddCSLuaFile( "wos/anim_extension/loader/loader.lua" )
end

include( "wos/anim_extension/loader/loader.lua" )
--addons/wiltos_animation_base/lua/wos/anim_extension/loader/loader.lua:
--[[-------------------------------------------------------------------
	wiltOS Animation Register:
		A simple register to keep track of all wiltOS extensions installed
			Powered by
						  _ _ _    ___  ____  
				__      _(_) | |_ / _ \/ ___| 
				\ \ /\ / / | | __| | | \___ \ 
				 \ V  V /| | | |_| |_| |___) |
				  \_/\_/ |_|_|\__|\___/|____/ 
											  
 _____         _                 _             _           
|_   _|__  ___| |__  _ __   ___ | | ___   __ _(_) ___  ___ 
  | |/ _ \/ __| '_ \| '_ \ / _ \| |/ _ \ / _` | |/ _ \/ __|
  | |  __/ (__| | | | | | | (_) | | (_) | (_| | |  __/\__ \
  |_|\___|\___|_| |_|_| |_|\___/|_|\___/ \__, |_|\___||___/
                                         |___/             
-------------------------------------------------------------------]]--[[
							  
	Lua Developer: King David
	Contact: http://steamcommunity.com/groups/wiltostech
		
----------------------------------------]]--

wOS = wOS or {}
wOS.AnimExtension = wOS.AnimExtension or {}
wOS.AnimExtension.Mounted = wOS.AnimExtension.Mounted or {}

local string = string
local file = file

local function _AddCSLuaFile( lua )

	if SERVER then
		AddCSLuaFile( lua )
	end
	
end

local function _include( load_type, lua )

	if load_type then
		include( lua )
	end
	
end

function wOS.AnimExtension:Autoloader()
	
	for _,source in pairs( file.Find( "wos/anim_extension/extensions/*", "LUA"), true ) do
		local lua = "wos/anim_extension/extensions/" .. source
		_AddCSLuaFile( lua )
		_include( SERVER, lua )
		_include( CLIENT, lua )
	end
	
	_AddCSLuaFile( "wos/anim_extension/vgui/wiltos_anim_viewer.lua" )
	_include( CLIENT, "wos/anim_extension/vgui/wiltos_anim_viewer.lua" )
	
	_AddCSLuaFile( "wos/anim_extension/core/sh_metatable.lua" )
	_include( SERVER, "wos/anim_extension/core/sh_metatable.lua" )
	_include( CLIENT, "wos/anim_extension/core/sh_metatable.lua" )
	
	_AddCSLuaFile( "wos/anim_extension/core/sh_holdtypes.lua" )
	_include( SERVER, "wos/anim_extension/core/sh_holdtypes.lua" )
	_include( CLIENT, "wos/anim_extension/core/sh_holdtypes.lua" )

	_AddCSLuaFile( "wos/anim_extension/core/sh_prone_support.lua" )
	_include( SERVER, "wos/anim_extension/core/sh_prone_support.lua" )
	_include( CLIENT, "wos/anim_extension/core/sh_prone_support.lua" )
	
	for _,source in pairs( file.Find( "wos/anim_extension/holdtypes/*", "LUA"), true ) do
		local lua = "wos/anim_extension/holdtypes/" .. source
		_AddCSLuaFile( lua )
		_include( SERVER, lua )
		_include( CLIENT, lua )
	end
	
end

wOS.AnimExtension:Autoloader()
--addons/wiltos_animation_base/lua/wos/anim_extension/extensions/wos_bs.lua:
--[[-------------------------------------------------------------------
	wiltOS Animation Extension Register:
		Prints some feedback saying the Animation Extension successfully loaded.
			Powered by
						  _ _ _    ___  ____  
				__      _(_) | |_ / _ \/ ___| 
				\ \ /\ / / | | __| | | \___ \ 
				 \ V  V /| | | |_| |_| |___) |
				  \_/\_/ |_|_|\__|\___/|____/ 
											  
 _____         _                 _             _           
|_   _|__  ___| |__  _ __   ___ | | ___   __ _(_) ___  ___ 
  | |/ _ \/ __| '_ \| '_ \ / _ \| |/ _ \ / _` | |/ _ \/ __|
  | |  __/ (__| | | | | | | (_) | | (_) | (_| | |  __/\__ \
  |_|\___|\___|_| |_|_| |_|\___/|_|\___/ \__, |_|\___||___/
                                         |___/             
-------------------------------------------------------------------]]--[[
							  
	Lua Developer: King David
	Contact: http://steamcommunity.com/groups/wiltostech
		
----------------------------------------]]--

wOS.AnimExtension.Mounted[ "Blade Symphony" ] = true
MsgC( Color( 255, 255, 255 ), "[wOS] Successfully mounted animation extension: Blade Symphony\n" )
--lua/autorun/client/all_cl_spawn.lua:
 -- Attempting to cache aye? well we override your cache with a blank file.
--addons/prop_list/lua/autorun/client/ausruestung.lua:
hook.Add("PopulatePropMenu", "Ausrüstung", function()
	
local contents = {}
	table.insert( contents, {
		type = "header",
		text = "Ausrüstung"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/sw_battlefront/weapons/dc15a_rifle.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/sw_battlefront/weapons/dc17_blaster.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/weapons/w_bowcaster.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/weapons/synbf3/w_a280.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/servius/starwars/cwa/deathwatch_rifle.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/sw_battlefront/weapons/dc15s_carbine.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/weapons/w_dc17m_at.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/weapons/w_dc17m_br.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/weapons/w_dc17m_sn.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/weapons/w_de10.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/weapons/w_dsbp.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/weapons/w_e5.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/weapons/w_swrcdeton.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/weapons/synbf3/w_dh17.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/weapons/synbf3/w_dl44.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/weapons/synbf3/w_dlt19.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/farena/weapons/w_e-11d.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/weapons/c_ee3.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/weapons/w_elg3a.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/weapons/w_fireaxe.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/weapons/w_katana.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/weapons/w_kyd21.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/weapons/w_ll30.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/weapons/synbf3/w_binoculars.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/w_rptnblstr_001.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/w_rptnblstr_002.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/nate159/swbf2015/pewpew/rocketlauncher.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/servius/starwars/cwa/steela_rifle.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/servius/starwars/cwa2/umbaran_rifle.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/sw_battlefront/weapons/valken_38x.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/weapons/w_alphablaster.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/weapons/w_westar34.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/weapons/synbf3/w_e11.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/weapons/synbf3/w_se14c.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/swbf3/cis/shotgun.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/rcremastered/w_dc-17m.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/rcremastered/w_dc15pistol.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/rcremastered/weapons/w_dc-17m_antiarmor.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/rcremastered/weapons/w_dc-17m_sniper.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/oninoni/prp_magna_guard_weapon_combined.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/oninoni/prp_magna_guard_weapon_season4.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/cs574/objects/ammo_box.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/damik/p-47d thunderbolt/hvar rocket.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/bomb/helfire.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/servius/starwars/cwa/rakohardeen_rifle.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/sw_battlefront/props/e11_clip/e11_clip.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/sw_battlefront/props/e11_grip/e11_grip.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/sw_battlefront/props/e11_scope/e11_scope.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/sw_battlefront/props/e11r_grip/e11r_grip.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/sw_battlefront/props/e11b_stock/e11b_stock.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/sw_battlefront/props/e11r_scope/e11r_scope.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/sw_battlefront/props/e11r_stock/e11r_stock.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/sw_battlefront/props/flashlight/flashlight.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/sw_battlefront/props/powerpack/power_pack.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/sw_battlefront/props/powerprongs/power_prongs.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/weapons/w_dc15a.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/weapons/w_dc15sa.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/cs574/explosif/grenade_bacta.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/cs574/explosif/grenade_base.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/cs574/explosif/grenade_dioxis.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/cs574/explosif/grenade_flash.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/cs574/explosif/grenade_impact.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/cs574/explosif/grenade_shock.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/cs574/explosif/grenade_smoke.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/cs574/explosif/grenade_train.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/forrezzur/bactagrenade.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/forrezzur/dioxisgrenade.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/forrezzur/dioxisgrenade_2.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/forrezzur/flashgrenade.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/forrezzur/impactgrenade.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/sw_battlefront/weapons/pinglauncher.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/weapons/tfa_ins2/w_f1.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/weapons/tfa_ins2/w_m67.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/weapons/tfa_starwars/w_flash.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/weapons/tfa_starwars/w_incendiary.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/weapons/tfa_starwars/w_smoke.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/cs574/ammo/reworked_rocket.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/rocket/rocket_v1.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/sw_battlefront/weapons/rocketprojectile.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/weapons/tfa_starwars/w_thermal.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/twcustom/weapons/w_reciprocating_quad_blaster.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/bshields/dshield.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/bshields/dshield_open.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/bshields/dshield_open.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/bshields/hshield.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/bshields/rshield.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/weapons/w_datapad.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/ace/sw/w_macrobinoculars.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/cs574/dc17m/dc17m_base.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/cs574/dc17m/dc17m_holosights.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/cs574/dc17m/dc17m_ironsight.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/cs574/dc17m/dc17m_mag.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/cs574/dc17m/dc17m_rifle.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/cs574/dc17m/dc17m_rocket.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/cs574/dc17m/dc17m_sniper.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/cs574/dc17m/dc17m_snipermag.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/cs574/objects/indicateur.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/cs574/weapons/arc_leftwrist.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/cs574/weapons/b2_hand.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/cs574/weapons/dc15se.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/cs574/weapons/e60r.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/cs574/weapons/hh12.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/cs574/weapons/nn14.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/fisher/dc17s/dc17s.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/fisher/extendeddc17/extendeddc17.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/hauptmann/star wars/weapons/bowcaster.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/hauptmann/star wars/weapons/ddt12.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/katharsmodels/syringe_out/syringe_out.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/lt_c/sci_fi/91_container_small.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/nate159/swbf2015/pewpew/electrobinocular.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/nate159/swbf2015/pewpew/rocketlauncher.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/rcremastered/w_dc15pistol.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/rps6/zl_rps-6.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/servius/starwars/cwa2/umbaran_rifle.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/shells/pellet.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/sw_battlefront/weapons/cr2_pistol.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/sw_battlefront/weapons/dc15a_rifle.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/sw_battlefront/weapons/dc15le_rifle.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/sw_battlefront/weapons/dc15s_carbine.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/sw_battlefront/weapons/dl44_pistol.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/sw_battlefront/weapons/ee3_carbine.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/sw_battlefront/weapons/nt242_longblaster.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/sw_battlefront/weapons/tusken_cycler_rifle.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/sw_battlefront/weapons/valken_38x.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/sw_battlefront/weapons/westar_35_pistol.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/sw_battlefront/weapons/z6_rotary_cannon.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/sw_battlefront/weapons/2019/a280c_scope1.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/sw_battlefront/weapons/mods/blurrg_cycler_default.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/sw_battlefront/weapons/mods/blurrg_cycler_mod.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/sw_battlefront/weapons/mods/s5_barrel_default.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/sw_battlefront/weapons/new/westar_m5_blaster_rifle.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/sw_battlefront/weapons/new/westar_m5_blaster_rifle_holster.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/swbf3/weapons/cisshotgun.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/swcw_items/sw_datapad.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/weapons/w_e60r.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/weapons/w_katana.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/weapons/w_swrcdeton.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/weapons/eabf2/npc/dp24.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/weapons/twcustom/mando_sniper/mando_sniper.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/reach/weapons/turret/hmg.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/reach/weapons/turret/hmg_fix.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/reach/weapons/turret/tripod.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/turret/gl_stand.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/turret/gl_turret.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/turret/mg_stand.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/turret/mg_turret.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/turret/rail_turret.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/weapons/w_fire_extinguisher.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/fire_extinguisher.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/bomb_tiny/bomb_tiny.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/chappi/chembomb.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/chappi/clusterbomblet.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/chappi/cookie.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/chappi/cookie_alt.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/chappi/cookie_alt_tail.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/chappi/moab.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/chappi/rb.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/chappi/ssm.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/chappi/tulip.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/chappi/zippo.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/failure/mk6/mk6.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/failure/spacenuke/spacenuke.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/military2/bomb/bomb_cbu.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/military2/bomb/bomb_gbu.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/military2/bomb/bomb_gbu10.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/military2/bomb/bomb_gbu12.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/military2/bomb/bomb_jdam.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/military2/bomb/bomb_kab.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/military2/bomb/bomb_mk82.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/military2/bomb/bomb_mk82s.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/military2/missile/missile_agm88.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/military2/missile/missile_barak.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/military2/missile/missile_harpoon.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/military2/missile/missile_moskit.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/military2/missile/missile_patriot.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/military2/missile/missile_r-17.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/military2/missile/missile_s300.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/military2/missile/missile_sm2.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/military2/missile/missile_taepodong.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/military2/missile/missile_tomahawk.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/military2/missile/missile_tomahawk2.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/military2/missile/missile_tomahawk3.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/models/castlerubaut.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/models/gb4/mortar_cache.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/models/thedoctor/photon.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_fallout/megatonbomb.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/squeegy/daisycutter.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/squeegy/fab.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/thedoctor/1000lb.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/thedoctor/100lb.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/thedoctor/500lb.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/thedoctor/50lb.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/thedoctor/antimatter_canister.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/thedoctor/atomicannie.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/thedoctor/atomicanniebase.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/thedoctor/atomicshell.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/thedoctor/bomb_cbu.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/thedoctor/bomb_gbu.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/thedoctor/bomb_gbu10.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/thedoctor/bomb_gbu12.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/thedoctor/bomb_jdam.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/thedoctor/bomb_kab.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/thedoctor/bomb_mk82.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/thedoctor/bomb_mk82s.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/thedoctor/darkmatter.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/thedoctor/davy.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/thedoctor/davy_launcher.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/thedoctor/davy_tripod.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/thedoctor/davy_propellant.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/thedoctor/emp_bomb.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/thedoctor/fatman.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/thedoctor/hypersonic.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/thedoctor/t12.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/thedoctor/tsar.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/thedoctor/v2.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/thedoctor/howitzer/howitzer.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/thedoctor/howitzer/howitzer_chlorine.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/thedoctor/howitzer/howitzer_frag.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/thedoctor/howitzer/howitzer_he.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/thedoctor/howitzer/howitzer_inc.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/thedoctor/icbm/body.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/thedoctor/mines/clustermine_1.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/thedoctor/mines/clustermine_2.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/weapons/w_c4.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/weapons/w_c4_planted.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/thedoctor/missile_tomahawk2.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/thedoctor/missile_tomahawk3.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/thedoctor/mutagenbomb.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/thedoctor/napalm.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/thedoctor/nitro.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/thedoctor/photon.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/repubturret.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/nmrih/weapons/exp_molotov/w_exp_molotov.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/lt_c/sci_fi/extinguisher.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/lt_c/sci_fi/shuttle/gun_left.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/lt_c/sci_fi/shuttle/gun_right.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/lt_c/sci_fi/shuttle/nacelle_left.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/lt_c/sci_fi/shuttle/nacelle_right.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/bomb/detpack/detpack.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/hoff/weapons/seal6_c4/w_c4.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/hoff/weapons/seal6_c4/w_c4_0-5.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/themexicanjew/jetpack.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/cosmo/starwarscutter.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/dolunity/starwars/mortar.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/dolunity/starwars/mortar_packedup.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/dolunity/starwars/mortar_visor.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/dolunity/starwars/mortar/shell.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/starwars/tech/proton_shell.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/starwars/weapons/ap_mine.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/starwars/weapons/beamturret.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/starwars/weapons/detpack.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/starwars/weapons/end_prop_ewok_catapult.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/starwars/weapons/fusion_cutter.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/starwars/weapons/grenade_launcher.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/starwars/weapons/hh15.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/starwars/weapons/hoth_bomb.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/starwars/weapons/hoth_turret.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/starwars/weapons/hoth_turret2.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/starwars/weapons/hoth_turret3.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/starwars/weapons/hoth_turret4.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/starwars/weapons/imperial_turbolaser.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/starwars/weapons/lasertrap.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/starwars/weapons/rep_launcher.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/starwars/weapons/seismic_charge.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/starwars/weapons/smart_launcher.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/starwars/weapons/vibroknuckler.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/starwars/weapons/wookie_rocket.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/deathstar/xx9a1.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/deathstar/xx9a2.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/deathstar/xx9b.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/deathstar/xx9c.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/deathstar/xx9c_static.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/venator/turbolaser_barrel.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/venator/turbolaser_barrel_static.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/venator/turbolaser_base.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/venator/turbolaser_bolt.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/venator/turbolaser_bolt_smaller.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/weapons/vfirethrower/w_flamethrower.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/misc/18pounder.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/misc/lefh.mdl"
	} )
	
	spawnmenu.AddPropCategory( "22", "Ausrüstung", contents, "icon16/brick.png" )
end )
--addons/prop_list/lua/autorun/client/droiden.lua:
hook.Add("PopulatePropMenu", "Droiden", function()
	
local contents = {}
	table.insert( contents, {
		type = "header",
		text = "Droiden"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/misc/droids/gnk_550.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/misc/droids/gnk_droid.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/misc/droids/mouse_droid.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/misc/droids/r2_q5.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/misc/droids/r4_i9.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/misc/droids/r5_j2.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/misc/droids/wed_15.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/playermodels/astromech.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/playermodels/gnk.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/playermodels/wed.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/summe/shieldgenerator_sphere.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/npc/starwars/crabby/crabdroid.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/npc/starwars/droidekas/droideka.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "mmodels/player/valley/aquadroid/aquadroid.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/nicholasray/sws/r2d2b.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/nicholasray/sws/r2d2g.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/nicholasray/sws/r2d2r.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/starwars/tech/gonk_droid.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/starwars/vehicles/droideka_dispenser.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/starwars/vehicles/sbd_dispenser.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/syphadias/props/hoth_barrack/r1_droid.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/syphadias/props/hoth_barrack/treadwell_droid.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/misc/droids/gnk_550.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/misc/droids/gnk_droid.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/misc/droids/head_r2.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/misc/droids/head_r4.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/misc/droids/head_r5.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/misc/droids/leg_front.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/misc/droids/leg_side.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/misc/droids/lin_droid.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/misc/droids/lin_droid_arm.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/misc/droids/lin_droid_base.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/misc/droids/lin_droid_dome.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/misc/droids/mouse_droid.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/misc/droids/r2_q5.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/misc/droids/r4_i9.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/misc/droids/r5_j2.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/misc/droids/torso.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/misc/droids/wed_15.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/playermodels/astromech.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/playermodels/gnk.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/playermodels/lin.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/playermodels/mouse.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/playermodels/wed.mdl"
	} )
	
	spawnmenu.AddPropCategory( "19", "Droiden", contents, "icon16/brick.png" )
end )
--addons/prop_list/lua/autorun/client/ragdoll.lua:
hook.Add("PopulatePropMenu", "Model Liste", function()

	-- 41 Elite Legion
	local contents = {}
		table.insert( contents, {
			type = "header",
			text = "91st"
			} )
		
		table.insert( contents, {
			type = "model",
			model = "models/dexton/91st/91st_pit_droid.mdl"
			} )
		
		table.insert( contents, {
			type = "model",
			model = "models/dominance/91st/arf/91st_arf.mdl"
			} )
		
		table.insert( contents, {
			type = "model",
			model = "models/dominance/91st/barc/91st_barc.mdl"
			} )
		
		table.insert( contents, {
			type = "model",
			model = "models/dominance/91st/neyo/91st_neyo.mdl"
			} )
		
		table.insert( contents, {
			type = "model",
			model = "models/dominance/91st/razorstack/91st_razorstack.mdl"
			} )
		
		table.insert( contents, {
			type = "model",
			model = "models/dominance/91st/trooper/91st_trooper.mdl"
			} )
							
		table.insert( contents, {
			type = "model",
			model = "models/dominance/custom_char/91st/bara.mdl"
			} )
							
		table.insert( contents, {
			type = "model",
			model = "models/dominance/custom_char/91st/dom.mdl"
			} )
							
		table.insert( contents, {
			type = "model",
			model = "models/dominance/custom_char/91st/grays.mdl"
			} )
					
	-- 104th Wolfpack
		table.insert( contents, {
			type = "header",
			text = "104th Wolfpack"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/rafalee/104th/lore/boost.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/rafalee/104th/lore/comet.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/rafalee/104th/lore/sinker.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/rafalee/104th/lore/wolffe.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/rafalee/104th/regular/trooper.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/tack/104th/evo.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/cast/custom_char/104th/wolfy.mdl"
		} )
			
		table.insert( contents, {
			type = "model",
			model = "models/dominance/custom_char/104th/fix.mdl"
		} )
				
		table.insert( contents, {
			type = "model",
			model = "models/dominance/custom_char/104th/nade.mdl"
		} )
				
		table.insert( contents, {
			type = "model",
			model = "models/dominance/custom_char/104th/scar.mdl"
		} )
				
		table.insert( contents, {
			type = "model",
			model = "models/dominance/custom_char/104th/voca.mdl"
		} )
		
		
	-- 187th Legion
		table.insert( contents, {
			type = "header",
			text = "187th Legion"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/linxreen/airborne/187th_airborne.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/linxreen/cmd/187th_commander.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/linxreen/lore/187th_lore.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/linxreen/sf/187th_sf.mdl"
		} )	

		table.insert( contents, {
			type = "model",
			model = "models/linxreen/trooper/187th_trooper.mdl"
		} )	

		table.insert( contents, {
			type = "model",
			model = "models/linxreen/custom_char/187th/falcon/falcon.mdl"
		} )
			
		table.insert( contents, {
			type = "model",
			model = "models/linxreen/custom_char/187th/lasse/lasse_cc.mdl"
		} )
			
		table.insert( contents, {
			type = "model",
			model = "models/linxreen/custom_char/187th/leomon/leomon_airborne.mdl"
		} )
	
	
	
	-- 212th Attack Battalion
		table.insert( contents, {
			type = "header",
			text = "212th Attack Battalion"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/dominance/212th/2nd/212th_airborne.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/dominance/212th/ghc/212th_arf.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/dominance/212th/lore/212th_barlex.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/dominance/212th/lore/212th_boil.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/dominance/212th/lore/212th_cody.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/dominance/212th/lore/212th_crys.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/dominance/212th/lore/212th_gearshift.mdl"
		} )		

		table.insert( contents, {
			type = "model",
			model = "models/dominance/212th/lore/212th_peel.mdl"
		} )	

		table.insert( contents, {
			type = "model",
			model = "models/dominance/212th/lore/212th_trapper.mdl"
		} )		

		table.insert( contents, {
			type = "model",
			model = "models/dominance/212th/lore/212th_waxer.mdl"
		} )		

		table.insert( contents, {
			type = "model",
			model = "models/dominance/212th/lore/212th_wooley.mdl"
		} )		

		table.insert( contents, {
			type = "model",
			model = "models/dominance/212th/trooper/212th_trooper.mdl"
		} )		

		table.insert( contents, {
			type = "model",
			model = "models/assault/custom_char/212th/clik.mdl"
		} )		

		table.insert( contents, {
			type = "model",
			model = "models/assault/custom_char/212th/jett.mdl"
		} )

		table.insert( contents, {
			type = "model",
			model = "models/dominance/custom_char/212th/maves.mdl"
		} )

		table.insert( contents, {
			type = "model",
			model = "models/dominance/custom_char/212th/ops.mdl"
		} )

		table.insert( contents, {
			type = "model",
			model = "models/tack/custom_char/212th/drift.mdl"
		} )
		
		
	--327th Star Corps
		table.insert( contents, {
			type = "header",
			text = "327th Star Corps"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/tack/327th/k_company/327th_barc.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/tack/327th/lore_chars/barr/327th_barr.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/tack/327th/lore_chars/bly/327th_bly.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/tack/327th/lore_chars/deviss/327th_deviss.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/tack/327th/lore_chars/galle/327th_galle.mdl"
		} )		

		table.insert( contents, {
			type = "model",
			model = "models/tack/327th/trooper/327th_trooper.mdl"
		} )
				
		table.insert( contents, {
			type = "model",
			model = "models/dominance/custom_char/327th/kushinsky.mdl"
		} )
				
		table.insert( contents, {
			type = "model",
			model = "models/glaenzer/custom_char/327th/ares.mdl"
		} )
		
		
	-- 501st Legion
		table.insert( contents, {
			type = "header",
			text = "501st Legion"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/dominance/501st/arf/501st_arf.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/dominance/501st/lore/allrounder/501st_allrounder.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/dominance/501st/lore/echo/501st_echo.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/dominance/501st/lore/fives/501st_fives.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/dominance/501st/lore/kano/501st_kano.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/dominance/501st/lore/rex/501st_rex.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/dominance/501st/trooper/501st_trooper.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/dominance/custom_char/501st/blue.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/dominance/custom_char/501st/dominance.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/dominance/custom_char/501st/kuro.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/dominance/custom_char/501st/storm.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/linxreen/custom_char/501st/truck.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/tack/custom_char/501st/sezurin.mdl"
		} )	

		table.insert( contents, {
			type = "model",
			model = "models/player/r2d2.mdl"
		} )
			
		
	-- Alpha Class Advanced Recon Commando
		table.insert( contents, {
			type = "header",
			text = "Alpha-Class Advanced Recon Commando"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/nydyyy_ravix/allrounder/trooper.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/nydyyy_ravix/alpha/trooper.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/nydyyy_ravix/fordo/trooper.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/nydyyy_ravix/heavy_gunner/trooper.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/nydyyy_ravix/marek/trooper.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/nydyyy_ravix/muzzle/trooper.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/nydyyy_ravix/spots/trooper.mdl"
		} )		

		table.insert( contents, {
			type = "model",
			model = "models/dominance/custom_char/aarc/dan.mdl"
		} )
				
		table.insert( contents, {
			type = "model",
			model = "models/dominance/custom_char/aarc/vapid.mdl"
		} )
				
		table.insert( contents, {
			type = "model",
			model = "models/tack/custom_char/aarc/luxer.mdl"
		} )
				
		table.insert( contents, {
			type = "model",
			model = "models/tack/custom_char/aarc/tira.mdl"
		} )
		
		
	-- Dooms Unit
		table.insert( contents, {
			type = "header",
			text = "Dooms Unit"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/dexton/du/doom/doom.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/dexton/du/trooper/squads.mdl"
		} )		

		table.insert( contents, {
			type = "model",
			model = "models/dexton/du/trooper/trooper.mdl"
		} )
			
		table.insert( contents, {
			type = "model",
			model = "models/dominance/custom_char/du/bull.mdl"
		} )
			
		table.insert( contents, {
			type = "model",
			model = "models/dominance/custom_char/du/falconeye.mdl"
		} )
			
		table.insert( contents, {
			type = "model",
			model = "models/linxreen/custom_char/du/prav.mdl"
		} )
	
	
	-- Galactic Marines
		table.insert( contents, {
			type = "header",
			text = "Galactic Marines"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/aussiwozzi/phase1clones/21st/marine_trooper.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/fisher/21st/bacara/bacara.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/magma/sw/commander_keller.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/rafalee/galacticmarine/trooper/trooper.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/dominance/custom_char/gm/jackal.mdl"
		} )		

		table.insert( contents, {
			type = "model",
			model = "models/linxreen/custom_char/gm/straight.mdl"
		} )
				
		table.insert( contents, {
			type = "model",
			model = "models/linxreen/custom_char/gms/sigma/sigma_cc.mdl"
		} )
		
		
	-- Shadow Trooper
		table.insert( contents, {
			type = "header",
			text = "Shadow Trooper"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/linxreen/egm/shadow_trooper.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/player/armand_isard_grady/armand_isard_grady.mdl"
		} )	

		table.insert( contents, {
			type = "model",
			model = "models/dominance/custom_char/ris/bandit.mdl"
		} )
			
		table.insert( contents, {
			type = "model",
			model = "models/dominance/custom_char/ris/silent.mdl"
		} )
		
		
	-- Republic Medical Corps
		table.insert( contents, {
			type = "header",
			text = "Republic Medical Corps"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/dominance/rmc/airborne/rmc_airborne.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/dominance/rmc/operation/rmc_operation.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/dominance/rmc/plague/rmc_plague.mdl"
		} )		

		table.insert( contents, {
			type = "model",
			model = "models/dominance/rmc/trooper/rmc_trooper.mdl"
		} )
				
		table.insert( contents, {
			type = "model",
			model = "models/dominance/custom_char/rmc/deltaa.mdl"
		} )
				
		table.insert( contents, {
			type = "model",
			model = "models/dominance/custom_char/rmc/ice.mdl"
		} )
				
		table.insert( contents, {
			type = "model",
			model = "models/dominance/custom_char/rmc/keanu.mdl"
		} )
				
		table.insert( contents, {
			type = "model",
			model = "models/dominance/custom_char/rmc/omega.mdl"
		} )
				
		table.insert( contents, {
			type = "model",
			model = "models/dominance/custom_char/rmc/saem.mdl"
		} )
				
		table.insert( contents, {
			type = "model",
			model = "models/tack/custom_char/rmc/cast_cc.mdl"
		} )
	
		
	-- Republic navy
		table.insert( contents, {
			type = "header",
			text = "Republic Navy"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/navy_clone/navy_clone.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/navy_krennic/navy_krennic.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/navy_officer_1/navy_officer_1.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/navy_officer_2/navy_officer_2.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/navy_officer_3/navy_officer_3.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/navy_officer_4/navy_officer_4.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/navy_officer_5/navy_officer_5.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/navy_officer_6/navy_officer_6.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/navy_officer_7/navy_officer_7.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/navy_tarkin/navy_tarkin.mdl"
		} )		

		table.insert( contents, {
			type = "model",
			model = "models/navy_krennic/navy_krennic.mdl"
		} )
		
		
-- Sondereinsatzbrigade unter der Führung von Marcel Davis ääähm Delta und Ryan
		table.insert( contents, {
			type = "header",
			text = "SEB"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/player/hevoc/rc/omega/niner.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/hevoc/hokan/ghezhokan.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/player/hevoc/rc/omega/atin.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/player/sample/rc/delta/boss.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/player/sample/rc/delta/fixer.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/hevoc/jedi/bardan_jusik.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/player/aussiwozzi/mandalorians/kal_skirata.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/player/aussiwozzi/mandalorians/walon_vau.mdl"
		} )
		
-- Starfighter Corps
		table.insert( contents, {
			type = "header",
			text = "Starfighter Corps"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/hydra/sc/contrail/contrail.mdl"
		} )		
		table.insert( contents, {
			type = "model",
			model = "models/hydra/sc/lore/broadside.mdl"
		} )
				
		table.insert( contents, {
			type = "model",
			model = "models/hydra/sc/lore/hawk.mdl"
		} )
				
		table.insert( contents, {
			type = "model",
			model = "models/hydra/sc/lore/jaigalaar.mdl"
		} )
				
		table.insert( contents, {
			type = "model",
			model = "models/hydra/sc/lore/warthog.mdl"
		} )
				
		table.insert( contents, {
			type = "model",
			model = "models/hydra/sc/trooper/trooper.mdl"
		} )
				
		table.insert( contents, {
			type = "model",
			model = "models/hydra/sc/trooper_1/trooper_1.mdl"
		} )
				
		table.insert( contents, {
			type = "model",
			model = "models/hydra/sc/trooper_2/trooper_2.mdl"
		} )
				
		table.insert( contents, {
			type = "model",
			model = "models/hydra/sc/trooper_2/trooper_2.mdl"
		} )
				
		table.insert( contents, {
			type = "model",
			model = "models/tack/custom_char/sc/redko.mdl"
		} )
				
		table.insert( contents, {
			type = "model",
			model = "models/dominance/custom_char/sc/salarza.mdl"
		} )
				
		table.insert( contents, {
			type = "model",
			model = "models/dominance/custom_char/sc/ernergiker.mdl"
		} )				

		table.insert( contents, {
			type = "model",
			model = "models/hydra/stealth/lore/stealth_blackout.mdl"
		} )
									
		table.insert( contents, {
			type = "model",
			model = "models/hydra/stealth/lore/stealth_spark.mdl"
		} )
									
		table.insert( contents, {
			type = "model",
			model = "models/hydra/stealth/trooper/stealth_trooper.mdl"
		} )
					
					
		
-- Shock Trooper
		table.insert( contents, {
			type = "header",
			text = "Shock Trooper"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/egm/st/k9/st_k9_arf.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/cheek/st/rt/trooper.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/egm/st/lore/st_hound.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/egm/st/lore/st_lore_01.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/egm/st/lore/st_lore_02.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/egm/st/trooper/st_trooper.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/assault/custom_char/st/haraca.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/dominance/custom_char/st/mountain.mdl"
		} )

	-- Tactical Engineering Battalion
	
		table.insert( contents, {
			type = "header",
			text = "Tactical Engineering Battalion"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/dominance/teb/38th/teb_38th.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/dominance/teb/flametrooper/teb_flametrooper.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/dominance/teb/lore/teb_chatter.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/dominance/teb/lore/teb_corr.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/dominance/teb/trooper/teb_trooper.mdl"
		} )		

		table.insert( contents, {
			type = "model",
			model = "models/dominance/custom_char/teb/rame.mdl"
		} )
				
		table.insert( contents, {
			type = "model",
			model = "models/glaenzer/custom_char/teb/pulse.mdl"
		} )
		
			  
-- Ausbilder
		table.insert( contents, {
			type = "header",
			text = "Ausbilder"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/rafalee/einfachgaming/trooper/egm_instructor.mdl"
		} )
		  
-- Clone Trooper
		table.insert( contents, {
			type = "header",
			text = "Clone Trooper"
		} )

		table.insert( contents, {
			type = "model",
			model = "models/dexton/einheiten/adjutanten.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/dexton/snowtrooper/snowtrooper_faction.mdl"
		} )
  
		table.insert( contents, {
			type = "model",
			model = "models/dominance/ct/arf/arf_trooper.mdl"
		} )
  
		table.insert( contents, {
			type = "model",
			model = "models/dominance/ct/barc/barc_trooper.mdl"
		} )
  
		table.insert( contents, {
			type = "model",
			model = "models/dominance/ct/bx/bx_trooper.mdl"
		} )
  
		table.insert( contents, {
			type = "model",
			model = "models/dominance/ct/officer/officer_trooper.mdl"
		} )
  
		table.insert( contents, {
			type = "model",
			model = "models/dominance/ct/p1/p1_trooper.mdl"
		} )
  
		table.insert( contents, {
			type = "model",
			model = "models/dominance/ct/para/para_trooper.mdl"
		} )
  
		table.insert( contents, {
			type = "model",
			model = "models/dominance/ct/pilot/pilot_trooper.mdl"
		} )
  
		table.insert( contents, {
			type = "model",
			model = "models/fisher/clone/trooper/private.mdl"
		} )
  
		table.insert( contents, {
			type = "model",
			model = "models/fisher/scuba/scuba.mdl"
		} )
  
		table.insert( contents, {
			type = "model",
			model = "models/dominance/custom_char/ct/peaky.mdl"
		} )
  
		table.insert( contents, {
			type = "model",
			model = "models/dominance/custom_char/ct/twinkle.mdl"
		} )
  
  

-- Konföderation Unabhängiger Systeme
		table.insert( contents, {
			type = "header",
			text = "KUS"
		} )
		
	
		table.insert( contents, {
			type = "model",
			model = "models/player/swcw/std_kraken.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/super_tactical_kalani/pm_droid_tactical_kalani.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/super_tactical_stuxnet/pm_droid_tactical_stuxnet.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/tactical_black/pm_droid_tactical_black.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/tactical_blue/pm_droid_tactical_blue.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/tactical_gold/pm_droid_tactical_gold.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/tactical_purple/pm_droid_tactical_purple.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/tactical_red/pm_droid_tactical_red.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/pm_admiral_trench.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/aussisengels/grievous/general_grievous.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/player/b1battledroids/b1_base.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/player/b1battledroids/b1_base_aatdriver.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/player/b1battledroids/b1_base_com.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/player/b1battledroids/b1_base_gen1.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/player/b1battledroids/b1_base_pilot.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/player/b1battledroids/b1_base_security.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/player/b1battledroids/b1_base_training.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/player/b1battledroids/b1_firefighter.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/player/b1battledroids/b1_geo.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/player/b1battledroids/b1_geo_com.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/player/b1battledroids/b1_rocket.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/player/hydro/b2_battledroid/b2_battledroid.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/player/nsn/gunray.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/player/nsn/poggle.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/player/nsn/wattambor_noanim.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/sally/tkaro/bx_commando_droid.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/sirris_sw/dooku_pm.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/player/swcw/std_auto.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/player/swcw/std_kalani.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/player/swcw/std_kraken.mdl"
		} )		

		table.insert( contents, {
			type = "model",
			model = "models/starwars/stan/droidekas/droideka.mdl"
		} )

		table.insert( contents, {
			type = "model",
			model = "models/jellik/asajj/asajj.mdl"
		} )

		table.insert( contents, {
			type = "model",
			model = "models/loic_buzzdroid/buzzdroid.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/tfa/comm/gg/pm_sw_magna_guard_combined.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/tfa/comm/gg/pm_sw_magna_guard_season4.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/tfa/comm/gg/pm_sw_magna_guard_trainer.mdl"
		} )	
		
	-- Klon Offizier
		table.insert( contents, {
			type = "header",
			text = "Clone Officer"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/gar_clone/gar_clone.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/gar_wolffe/gar_wolffe.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/intelligence_clone/intelligence_clone.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/smitty/bf2_reg/clone_recruit/clone_recruit.mdl"
		} )
		
		
	-- Jedi Orden
		table.insert( contents, {
			type = "header",
			text = "Jedi Orden"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/artel/snowashoka/snowashoka.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/cheek/jedi/jedi_female.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/cyanblue/sw/anakin/anakin.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/defcon/starwars/player/jedi_general_alien.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/defcon/starwars/player/jedi_general_alien1.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/defcon/starwars/player/jedi_general_female_human.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/defcon/starwars/player/jedi_general_human.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/epangelmatikes/revan/revan_opt.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/epangelmatikes/templeguard/temple_guard_opt.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/fisher/tomackerson/tomackerson.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/fisher/tomackerson/tomackerson_alien.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/fisher/tomackerson/tomackerson_human.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/gonzo/femalejedi/knight/knight.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/gonzo/saeseetiin/saeseetiin.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/hevoc/bf2_plokoon/bf2_plokoon.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/hevoc/jedi/etain.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/hosti/swcw/pm_sw_ahsoka_v2.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/kaiido/mace_windu.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/kaiido/obi_wan.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/kaiido/gnl/jedi_general_male_01.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/player/aussiwozzi/mandalorians/bardan/bardan_mando.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/player/mundi/kiadi.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/player/plokoon/plokoon.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/player/suno/p_tiplar.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/player/suno/p_tiplee.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/player/valley/ign/jocasta/jocasta.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/seven/jedi_robe_alien.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/seven/jedi_robe_alien.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/seven/jedi_robe_human.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/summe/nuru_chiss.mdl"
		} )		

		table.insert( contents, {
			type = "model",
			model = "models/synergy/cblake/luminara_pm.mdl"
		} )

		table.insert( contents, {
			type = "model",
			model = "models/tfa/comm/gg/pm_sw_aayala.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/tfa/comm/gg/pm_sw_adigallia.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/tfa/comm/gg/pm_sw_barriss.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/tfa/comm/gg/pm_sw_eeth_koth.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/tfa/comm/gg/pm_sw_fisto.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/tfa/comm/gg/pm_sw_shaakti.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/tfa/comm/gg/pm_sw_yoda.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/plocool/stallionstan/hippiejedi/quinlanvos.mdl"
		} )
		
		
		
	-- Zivilisten
		table.insert( contents, {
			type = "header",
			text = "Zivilisten"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/hcn/starwars/bf/alien/alien.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/hcn/starwars/bf/alien/alien_2.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/hcn/starwars/bf/alien/alien_3.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/hcn/starwars/bf/alien/alien_4.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/hcn/starwars/bf/alien/alien_5.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/hcn/starwars/bf/alien/alien_6.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/hcn/starwars/bf/bossk/bossk.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/hcn/starwars/bf/bossk/trandoshan.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/hcn/starwars/bf/human/human_male.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/hcn/starwars/bf/human/human_male_2.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/hcn/starwars/bf/human/human_male_3.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/hcn/starwars/bf/human/human_male_4.mdl"
		} )

		table.insert( contents, {
			type = "model",
			model = "models/hcn/starwars/bf/human/human_male_5.mdl"
		} )
				
		table.insert( contents, {
			type = "model",
			model = "models/kuma96/laracroft_leatherjacket/laracroft_leatherjacket_pm.mdl"
		} )
				
		table.insert( contents, {
			type = "model",
			model = "models/player/artel/jediw3/jediw3.mdl"
		} )
				
		table.insert( contents, {
			type = "model",
			model = "models/player/aussiwozzi/mandalorians/female_mando.mdl"
		} )
				
		table.insert( contents, {
			type = "model",
			model = "models/player/aussiwozzi/mandalorians/male_mando.mdl"
		} )
				
		table.insert( contents, {
			type = "model",
			model = "models/player/lordvipes/rerc_vector/vector_cvp.mdl"
		} )
				
		table.insert( contents, {
			type = "model",
			model = "models/gonzo/knightofren/knightofren.mdl"
		} )
				
		table.insert( contents, {
			type = "model",
			model = "models/gonzo/lucien/lucien.mdl"
		} )
				
		table.insert( contents, {
			type = "model",
			model = "models/gonzo/narshaddaacharacters/droid1/droid1.mdl"
		} )
				
		table.insert( contents, {
			type = "model",
			model = "models/gonzo/narshaddaacharacters/droid2/droid2.mdl"
		} )
				
		table.insert( contents, {
			type = "model",
			model = "models/gonzo/narshaddaacharacters/droiddealer/droiddealer.mdl"
		} )
				
		table.insert( contents, {
			type = "model",
			model = "models/gonzo/narshaddaacharacters/hound2/hound2.mdl"
		} )
				
		table.insert( contents, {
			type = "model",
			model = "models/gonzo/narshaddaacharacters/snake/snake.mdl"
		} )
				
		table.insert( contents, {
			type = "model",
			model = "models/gonzo/narshaddaacharacters/xaameqessh/xaameqessh.mdl"
		} )
				
		table.insert( contents, {
			type = "model",
			model = "models/gonzo/tenarshaddaaarmourpack/archaelogymaster/archaelogymaster.mdl"
		} )
				
		table.insert( contents, {
			type = "model",
			model = "models/gonzo/tenarshaddaaarmourpack/armourtechmaster/armourtechmaster.mdl"
		} )
				
		table.insert( contents, {
			type = "model",
			model = "models/gonzo/tenarshaddaaarmourpack/armstechmaster/armstechmaster.mdl"
		} )
				
		table.insert( contents, {
			type = "model",
			model = "models/gonzo/tenarshaddaaarmourpack/heavycrusaderarmour/heavycrusaderarmour.mdl"
		} )
				
		table.insert( contents, {
			type = "model",
			model = "models/gonzo/tenarshaddaaarmourpack/lightcrusaderarmour/lightcrusaderarmour.mdl"
		} )
				
		table.insert( contents, {
			type = "model",
			model = "models/gonzo/tenarshaddaaarmourpack/mediumcrusaderarmour/mediumcrusaderarmour.mdl"
		} )
					
		table.insert( contents, {
			type = "model",
			model = "models/gonzo/tenarshaddaaarmourpack/scraparmour/scraparmour.mdl"
		} )
		
-- Senat
		table.insert( contents, {
			type = "header",
			text = "Galaktischer Senat"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/hevoc/senateguard/senateguard_commander.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/hevoc/senateguard/senateguard_officer.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/hevoc/senateguard/senateguard_trooper.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/player/imagundi/padme/padme.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/player/tiki/aang.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/player/tiki/ameda.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/player/tiki/ask.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/player/tiki/bailorgana.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/player/tiki/concorkill.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/player/tiki/mothma.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/player/tiki/nm.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/player/tiki/saam.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/player/tiki/tikkes.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/player/tiki/tills.mdl"
		} )
	
		table.insert( contents, {
			type = "model",
			model = "models/player/c3po.mdl"
		} )

-- Event
		table.insert( contents, {
			type = "header",
			text = "Event"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/badbatch/crosshair/badbatchcrosshair.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/badbatch/echo/echo.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/badbatch/hunter/hunter.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/badbatch/tech/tech.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/badbatch/wrecker/wrecker.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/dw_bokatan/pm_deathwatch_bokatan.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/dw_cpt/pm_deathwatch_cpt.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/dw_grunt/pm_deathwatch_grunt.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/dw_nightowl/pm_deathwatch_nightowl.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/dw_previzsla/pm_deathwatch_previzsla.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/gonzo/durge/durge.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/gonzo/narshaddaabarstaff/barmanager/barmanager.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/grealms/characters/cadbane/cadbane.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/hydra/rancor/rancorbattalion.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/jazzmcfly/jka/palpatine/palpatine.mdl"
		} )
			
		table.insert( contents, {
			type = "model",
			model = "models/lord/lord.mdl"
		} )
			
		table.insert( contents, {
			type = "model",
			model = "models/lord2/lord2.mdl"
		} )
			
		table.insert( contents, {
			type = "model",
			model = "models/mrpounder1/player/massif.mdl"
		} )
			
		table.insert( contents, {
			type = "model",
			model = "models/player/cdc_soldier_npc.mdl"
		} )
			
		table.insert( contents, {
			type = "model",
			model = "models/player/cdc_soldier_player.mdl"
		} )
			
		table.insert( contents, {
			type = "model",
			model = "models/player/t3_01.mdl"
		} )
			
		table.insert( contents, {
			type = "model",
			model = "models/player/t3_02.mdl"
		} )
			
		table.insert( contents, {
			type = "model",
			model = "models/player/t3_03.mdl"
		} )
			
		table.insert( contents, {
			type = "model",
			model = "models/player/t3_04.mdl"
		} )
			
		table.insert( contents, {
			type = "model",
			model = "models/player/darth/maul.mdl"
		} )
			
		table.insert( contents, {
			type = "model",
			model = "models/player/hydro/swbf_dengar/swbf_dengar.mdl"
		} )
			
		table.insert( contents, {
			type = "model",
			model = "models/player/icefusenetworks/ifnumbaran.mdl"
		} )
			
		table.insert( contents, {
			type = "model",
			model = "models/player/icefusenetworks/ifnumbarangeneral.mdl"
		} )
			
		table.insert( contents, {
			type = "model",
			model = "models/player/ig88/ig88.mdl"
		} )
			
		table.insert( contents, {
			type = "model",
			model = "models/player/jedi/gungan.mdl"
		} )
			
		table.insert( contents, {
			type = "model",
			model = "models/player/jellik/starwars/highsinger.mdl"
		} )
			
		table.insert( contents, {
			type = "model",
			model = "models/player/mandalorian/dutchess_satine.mdl"
		} )
			
		table.insert( contents, {
			type = "model",
			model = "models/player/mandalorian/royal_guard_male.mdl"
		} )
			
		table.insert( contents, {
			type = "model",
			model = "models/player/n7legion/killingfloor2/horzine_sec_suit_female.mdl"
		} )
			
		table.insert( contents, {
			type = "model",
			model = "models/player/n7legion/killingfloor2/horzine_sec_suit_male.mdl"
		} )
			
		table.insert( contents, {
			type = "model",
			model = "models/player/ohanak_gang/pm_pirate_hondo.mdl"
		} )
			
		table.insert( contents, {
			type = "model",
			model = "models/player/republiccommandosmp/rc_white.mdl"
		} )
				
		table.insert( contents, {
			type = "model",
			model = "models/player/tcw/human/lux_bonteri.mdl"
		} )
				
		table.insert( contents, {
			type = "model",
			model = "models/player/tcw/human/saw_gerrera.mdl"
		} )
				
		table.insert( contents, {
			type = "model",
			model = "models/player/tcw/human/steela_gerrera.mdl"
		} )
				
		table.insert( contents, {
			type = "model",
			model = "models/player/tiki/ben.mdl"
		} )
				
		table.insert( contents, {
			type = "model",
			model = "models/player/tiki/bric.mdl"
		} )
				
		table.insert( contents, {
			type = "model",
			model = "models/player/tiki/chirrut.mdl"
		} )
				
		table.insert( contents, {
			type = "model",
			model = "models/player/tiki/el-les.mdl"
		} )
				
		table.insert( contents, {
			type = "model",
			model = "models/player/tiki/embo.mdl"
		} )
				
		table.insert( contents, {
			type = "model",
			model = "models/player/tiki/kaminoan.mdl"
		} )
				
		table.insert( contents, {
			type = "model",
			model = "models/player/tiki/med_droid.mdl"
		} )
				
		table.insert( contents, {
			type = "model",
			model = "models/player/tiki/proxy.mdl"
		} )
				
		table.insert( contents, {
			type = "model",
			model = "models/player/valley/ackbar.mdl"
		} )
				
		table.insert( contents, {
			type = "model",
			model = "models/player/valley/pao.mdl"
		} )
				
		table.insert( contents, {
			type = "model",
			model = "models/player/valley/policedroid.mdl"
		} )
				
		table.insert( contents, {
			type = "model",
			model = "models/player/valley/talz.mdl"
		} )
				
		table.insert( contents, {
			type = "model",
			model = "models/player/valley/xalek.mdl"
		} )
				
		table.insert( contents, {
			type = "model",
			model = "models/starwars/grady/protocol_droids/protocol-black.mdl"
		} )
				
		table.insert( contents, {
			type = "model",
			model = "models/swrp/swrp/geonosian_01.mdl"
		} )
				
		table.insert( contents, {
			type = "model",
			model = "models/swrp/swrp/geonosian_02.mdl"
		} )
				
		table.insert( contents, {
			type = "model",
			model = "models/syntheticgaming/characters/savageopress/savageopress.mdl"
		} )
				
		table.insert( contents, {
			type = "model",
			model = "models/tack/covertops/covert_trooper.mdl"
		} )
				
		table.insert( contents, {
			type = "model",
			model = "models/yates/rangercombat.mdl"
		} )
				
		table.insert( contents, {
			type = "model",
			model = "models/yates/rangercombatf.mdl"
		} )
				
		table.insert( contents, {
			type = "model",
			model = "models/zyan7259/zusken_raider_player/zusken_raider_player.mdl"
		} )
				
		table.insert( contents, {
			type = "model",
			model = "models/player/chewie.mdl"
		} )
				
		table.insert( contents, {
			type = "model",
			model = "models/player/han_solo.mdl"
		} )
				
		table.insert( contents, {
			type = "model",
			model = "models/kingpommes/starwars/playermodels/astromech.mdl"
		} )
				
		table.insert( contents, {
			type = "model",
			model = "models/kingpommes/starwars/playermodels/gnk.mdl"
		} )
				
		table.insert( contents, {
			type = "model",
			model = "models/kingpommes/starwars/playermodels/lin.mdl"
		} )
				
		table.insert( contents, {
			type = "model",
			model = "models/kingpommes/starwars/playermodels/mouse.mdl"
		} )
				
		table.insert( contents, {
			type = "model",
			model = "models/kingpommes/starwars/playermodels/wed.mdl"
		} )
				
		table.insert( contents, {
			type = "model",
			model = "models/jajoff/sw/blizz.mdl"
		} )
				
		table.insert( contents, {
			type = "model",
			model = "models/jajoff/sw/jawa.mdl"
		} )
				
		table.insert( contents, {
			type = "model",
			model = "models/jajoff/sw/jawa02.mdl"
		} )
				
		table.insert( contents, {
			type = "model",
			model = "models/jajoff/sw/jawachef.mdl"
		} )
				
		table.insert( contents, {
			type = "model",
			model = "models/jajoff/sw/jawacustom.mdl"
		} )
				
		table.insert( contents, {
			type = "model",
			model = "models/jajoff/sw/jawamechanic.mdl"
		} )
				
		table.insert( contents, {
			type = "model",
			model = "models/jajoff/sw/jawamwarrior.mdl"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/player/valley/bobafettyoungsuit.mdl"
		} )


		-- NPC
		table.insert( contents, {
			type = "header",
			text = "NPC"
		} )

		table.insert( contents, {
			type = "model",
			model = "models/jediacad/rancor.mdl"
		} )

		table.insert( contents, {
			type = "model",
			model = "models/jfo/npcs/banebackspider.mdl"
		} )

		table.insert( contents, {
			type = "model",
			model = "models/npc/starwars/crabby/crabdroid.mdl"
		} )

		table.insert( contents, {
			type = "model",
			model = "models/npc/starwars/droidekas/droideka.mdl"
		} )

		table.insert( contents, {
			type = "model",
			model = "models/npc/starwars/dwarfspider/dwarfspiderdroid.mdl"
		} )

		table.insert( contents, {
			type = "model",
			model = "models/odd/nikout/swtor/player/hk51.mdl"
		} )

		table.insert( contents, {
			type = "model",
			model = "models/player/swtor/droids/bodyguard_droid.mdl"
		} )

		table.insert( contents, {
			type = "model",
			model = "models/player/swtor/droids/combat_medicaldroid.mdl"
		} )

		table.insert( contents, {
			type = "model",
			model = "models/player/swtor/droids/enforcerdroid.mdl"
		} )

		table.insert( contents, {
			type = "model",
			model = "models/player/swtor/droids/slicer_droid.mdl"
		} )

		table.insert( contents, {
			type = "model",
			model = "models/player/swtor/droids/worker_droid.mdl"
		} )

		table.insert( contents, {
			type = "model",
			model = "models/swtor/npcs/acklay_a01.mdl"
		} )

		table.insert( contents, {
			type = "model",
			model = "models/swtor/npcs/bull_reek_a01.mdl"
		} )

		table.insert( contents, {
			type = "model",
			model = "models/swtor/npcs/colicoid_a01.mdl"
		} )

		table.insert( contents, {
			type = "model",
			model = "models/swtor/npcs/colicoid_a02.mdl"
		} )

		table.insert( contents, {
			type = "model",
			model = "models/swtor/npcs/nexu_a01.mdl"
		} )

		table.insert( contents, {
			type = "model",
			model = "models/swtor/npcs/rakghoul.mdl"
		} )

		table.insert( contents, {
			type = "model",
			model = "models/swtor/npcs/womprat_a01.mdl"
		} )


-- Sonstiges
		table.insert( contents, {
			type = "header",
			text = "Sonstiges"
		} )

		table.insert( contents, {
			type = "model",
			model = "models/ace/sw/r4.mdl"
		} )

		table.insert( contents, {
			type = "model",
			model = "models/ace/sw/r2.mdl"
		} )

		table.insert( contents, {
			type = "model",
			model = "models/ace/sw/r5.mdl"
		} )

		table.insert( contents, {
			type = "model",
			model = "models/novux/023/novux_scp-023.mdl"
		} )

		table.insert( contents, {
			type = "model",
			model = "models/novux/023/novux_scp-023_white.mdl"
		} )



	spawnmenu.AddPropCategory( "30", "Model Liste", contents, "icon16/brick.png" )
end )
--addons/system_entities/lua/autorun/client/system.lua:
net.Receive("summe_ChatAddTextOnServer", function(len)
	chat.AddText(unpack(net.ReadTable()))
end)
--lua/autorun/client/tfa_shared_convars.lua:
-- Toggle dynamic lighting on blaster bolts
if !ConVarExists("cl_dynamic_tracer") then
    CreateClientConVar("cl_dynamic_tracer", 1, true, false, "Enable/Disable dynamic lighting on Star Wars weapons")
end
--addons/wos-alcs-custom/lua/wos/advswl/config/general/sh_serverwos.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2022
	
	Contact: www.wiltostech.com
----------------------------------------]]--

wOS = wOS or {}
wOS.ALCS = wOS.ALCS or {}
wOS.ALCS.Config = wOS.ALCS.Config or {}
--Should the player move in the direction of the animation when attacking?
--VERY VERY ( VERY )IMPORTANT NOTE: I highly recommend you disable this if your tick rate is BELOW 33. YOU WILL SEE STUTTERING OTHERWISE
wOS.ALCS.Config.EnableLunge = false

--Enabling this will stop the force icons from rendering.
--Useful for servers with 3D2D HUDs, as it will save clients some frames.
--This will also remove the little icon in the Force Select menu. 
wOS.ALCS.Config.DisableForceIcons = false

--The frequency ( in seconds ) that the wiltOS Advanced Saber Combat advertisement will print in chat.
--To disable advertisements, just set this to false
--I won't get angry if you disable it, promise
wOS.ALCS.Config.AdvertTime = false

--This is used to enable the realistic camera on first person lightsabers. 
--Players will be locked into their model's eyes and the camera will be limited by their head movements
--Good for RP purposes, but hard aim and use force abiltiies with
wOS.ALCS.Config.AlwaysFirstPerson = false

--If your server is using Zhrom's Starwars Prop Pack, this will automatically mount them to the toolgun/crafting benches
--YOU AND YOUR SERVER WILL NEED THIS ADDON!
-- http://steamcommunity.com/sharedfiles/filedetails/?id=740395760&searchtext=Zhrom
wOS.ALCS.Config.EnableZhromExtension = false

--If your server is using the CloneWars Adventure pack, this will automatically mount them to the toolgun/crafting benches
--YOU AND YOUR SERVER WILL NEED THE CLONE WAR PACK!
wOS.ALCS.Config.EnableCloneAdventures = false

-- This ignores any of the robotboy console commands and forces it for clients to not draw any hilts on their belt
-- This can be set at any time in lua so it can also be set per client with hooks!
wOS.ALCS.Config.StopDrawOnBelt = false


--addons/wos-alcs-custom/lua/wos/advswl/config/crafting/sh_craftwos.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2022
	
	Contact: www.wiltostech.com
----------------------------------------]]--

wOS = wOS or {}
wOS.ALCS = wOS.ALCS or {}
wOS.ALCS.Config = wOS.ALCS.Config or {}
wOS.ALCS.Config.Crafting = wOS.ALCS.Config.Crafting or {}

--How much experience is required for the first level?
--This is an assumption based on my default quadratic increase, but it may have no purpose to you.
wOS.ALCS.Config.Crafting.SaberMinimumExperience = 200

--Create your own leveling formula with this. The default property is a quadratic increase
--( level^2 )*wOS.ALCS.Config.Skills.MinimumExperience*0.5 + level*wOS.ALCS.Config.Skills.MinimumExperience + wOS.ALCS.Config.Skills.MinimumExperience
--This amounts to the ( ax^2 + bx + c ) format of increase
--You can use this to create set amounts per level by returning a table
--If you need help setting this up you'll probably want to ask, but it's just simple math so there's probably tutorials everywhere
wOS.ALCS.Config.Crafting.SaberXPScaleFormula = function( level )
	local required_experience = ( level^2 ) * wOS.ALCS.Config.Crafting.SaberMinimumExperience * 0.5 + level * wOS.ALCS.Config.Crafting.SaberMinimumExperience + wOS.ALCS.Config.Crafting.SaberMinimumExperience
	return required_experience
end

--What is the max level for the proficiency system? Set this to FALSE if you want it to go infinitely
wOS.ALCS.Config.Crafting.SaberMaxLevel = false

--How many proficiency levels will it take before the saber gets another misc slot?
wOS.ALCS.Config.Crafting.LevelPerSlot = 1

local defaultHilt = "models/sgg/starwars/weapons/w_common_jedi_saber_hilt.mdl"
local defaultLength = 45
local defaultWidth = 2
local defaultColor = Color(255, 255, 0)
local defaultUseDarkInner = 0
local defaultSaberDamage = 125

wOS.ALCS.Config.Crafting.DefaultPersonalSaber = {}
wOS.ALCS.Config.Crafting.DefaultPersonalSaber.UseHilt = defaultHilt
wOS.ALCS.Config.Crafting.DefaultPersonalSaber.UseLength = defaultLength
wOS.ALCS.Config.Crafting.DefaultPersonalSaber.UseWidth = defaultWidth
wOS.ALCS.Config.Crafting.DefaultPersonalSaber.UseColor = defaultColor
wOS.ALCS.Config.Crafting.DefaultPersonalSaber.UseDarkInner  = defaultUseDarkInner
wOS.ALCS.Config.Crafting.DefaultPersonalSaber.UseInnerColor  = color_white
wOS.ALCS.Config.Crafting.DefaultPersonalSaber.SaberDamage  = defaultSaberDamage
wOS.ALCS.Config.Crafting.DefaultPersonalSaber.SaberBurnDamage  = defaultSaberDamage
wOS.ALCS.Config.Crafting.DefaultPersonalSaber.UseSwingSound = "lightsaber/saber_swing1.wav"
wOS.ALCS.Config.Crafting.DefaultPersonalSaber.UseLoopSound = "lightsaber/saber_loop1.wav"
wOS.ALCS.Config.Crafting.DefaultPersonalSaber.UseOnSound = "lightsaber/saber_on1.wav"
wOS.ALCS.Config.Crafting.DefaultPersonalSaber.UseOffSound = "lightsaber/saber_off1.wav"

-- YOU CAN SET CUSTOM SETTINGS FOR THE PERSONAL LIGHTSABER HERE, SUCH AS A DEFAULT CRYSTAL TYPE
wOS.ALCS.Config.Crafting.DefaultPersonalSaber.CustomSettings = {}

-- THESE ARE DEFAULT FORMS FOR THE PERSONAL LIGHTSABER. SET THIS TO FALSE IF YOU WANT IT TO HAVE NOTHING
wOS.ALCS.Config.Crafting.DefaultPersonalSaber.UseForms = false

wOS.ALCS.Config.Crafting.DefaultSecPersonalSaber = {}
wOS.ALCS.Config.Crafting.DefaultSecPersonalSaber.UseHilt = defaultHilt
wOS.ALCS.Config.Crafting.DefaultSecPersonalSaber.UseLength = defaultLength
wOS.ALCS.Config.Crafting.DefaultSecPersonalSaber.UseWidth = defaultWidth
wOS.ALCS.Config.Crafting.DefaultSecPersonalSaber.UseColor = defaultColor
wOS.ALCS.Config.Crafting.DefaultSecPersonalSaber.UseDarkInner  = defaultUseDarkInner
wOS.ALCS.Config.Crafting.DefaultSecPersonalSaber.UseInnerColor  = color_white
wOS.ALCS.Config.Crafting.DefaultSecPersonalSaber.SaberDamage  = defaultSaberDamage
wOS.ALCS.Config.Crafting.DefaultSecPersonalSaber.SaberBurnDamage  = defaultSaberDamage
wOS.ALCS.Config.Crafting.DefaultSecPersonalSaber.CustomSettings = {}

wOS.ALCS.Config.Crafting.MaxInventorySlots = 40

--Where is the crafting camera located? ( VECTOR POSITION )
wOS.ALCS.Config.Crafting.CraftingCamLocation = Vector( -9999, -9999, -9999 )
--addons/wos-grandmaster-einf/lua/wos/advswl/core/sh_core.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2020
	
	Contact: www.wiltostech.com
		----------------------------------------]]--








































































wOS = wOS or {}
wOS.ALCS = wOS.ALCS or {}
																					
PrecacheParticleSystem("har_explosion_a")
PrecacheParticleSystem("har_explosion_b")
PrecacheParticleSystem("har_explosion_c")
PrecacheParticleSystem("har_explosion_a_air")
PrecacheParticleSystem("har_explosion_b_air")
PrecacheParticleSystem("har_explosion_c_air")

if CLIENT then
	game.AddParticles( "particles/harry_explosion.pcf" )
end
--addons/wos-grandmaster-einf/lua/wos/advswl/core/sh_hilt_extension.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2020
	
	Contact: www.wiltostech.com
		----------------------------------------]]--








































































wOS = wOS or {}

hook.Add( "PostGamemodeLoaded", "wOS.AddZhromHilts", function()

	if wOS.ALCS.Config.EnableZhromExtension then 
		
		list.Set( "LightsaberModels", "models/dani/dani.mdl", {} )
		list.Set( "LightsaberModels", "models/donation gauntlet/donation gauntlet.mdl", {} )
		list.Set( "LightsaberModels", "models/donation1/donation1.mdl", {} )	
		list.Set( "LightsaberModels", "models/donation2/donation2.mdl", {} )	
		list.Set( "LightsaberModels", "models/donation3/donation3.mdl", {} )
		list.Set( "LightsaberModels", "models/donation4/donation4.mdl", {} )
		list.Set( "LightsaberModels", "models/donation7/donation7.mdl", {} )	
		list.Set( "LightsaberModels", "models/lightsaber/lightsaber.mdl", {} )	
		list.Set( "LightsaberModels", "models/lightsaber2/lightsaber2.mdl", {} )
		list.Set( "LightsaberModels", "models/lightsaber3/lightsaber3.mdl", {} )
		list.Set( "LightsaberModels", "models/lightsaber4/lightsaber4.mdl", {} )	
		list.Set( "LightsaberModels", "models/pike/pike.mdl", {} )		
		list.Set( "LightsaberModels", "models/sgg/starwars/weapons/w_reborn_saber_hilt.mdl", {} )
		list.Set( "LightsaberModels", "models/sgg/starwars/weapons/w_saber_1_hilt.mdl", {} )
		list.Set( "LightsaberModels", "models/sgg/starwars/weapons/w_saber_2_hilt.mdl", {} )	
		list.Set( "LightsaberModels", "models/sgg/starwars/weapons/w_saber_3_hilt.mdl", {} )	
		list.Set( "LightsaberModels", "models/sgg/starwars/weapons/w_saber_4_hilt.mdl", {} )
		list.Set( "LightsaberModels", "models/sgg/starwars/weapons/w_saber_5_hilt.mdl", {} )
		list.Set( "LightsaberModels", "models/sgg/starwars/weapons/w_saber_6_hilt.mdl", {} )
		list.Set( "LightsaberModels", "models/sgg/starwars/weapons/w_saber_7_hilt.mdl", {} )
		list.Set( "LightsaberModels", "models/sgg/starwars/weapons/w_saber_8_hilt.mdl", {} )
		list.Set( "LightsaberModels", "models/sgg/starwars/weapons/w_saber_9_hilt.mdl", {} )
		list.Set( "LightsaberModels", "models/sgg/starwars/weapons/w_saber_dual_1_hilt.mdl", {} )
		list.Set( "LightsaberModels", "models/sgg/starwars/weapons/w_saber_dual_2_hilt.mdl", {} )
		list.Set( "LightsaberModels", "models/sgg/starwars/weapons/w_saber_dual_3_hilt.mdl", {} )
		list.Set( "LightsaberModels", "models/sgg/starwars/weapons/w_saber_dual_4_hilt.mdl", {} )
		list.Set( "LightsaberModels", "models/sgg/starwars/weapons/w_saber_dual_5_hilt.mdl", {} )
		list.Set( "LightsaberModels", "models/snake/snake.mdl", {} )
		list.Set( "LightsaberModels", "models/snake2/snake2.mdl", {} )	
		list.Set( "LightsaberModels", "models/training/training.mdl", {} )	
		list.Set( "LightsaberModels", "models/trident/trident.mdl", {} )
		list.Set( "LightsaberModels", "models/donation gauntlet/donation gauntlet.mdl", {} )
		list.Set( "LightsaberModels", "models/donation1/donation1.mdl", {} )	
		list.Set( "LightsaberModels", "models/donation1/donation1.mdl", {} )	
	end
	
	if wOS.ALCS.Config.EnableCloneAdventures then
		list.Set( "LightsaberModels", "models/starwars/cwa/lightsabers/aaylasecura.mdl", {} )
		list.Set( "LightsaberModels", "models/starwars/cwa/lightsabers/adigalia.mdl", {} )
		list.Set( "LightsaberModels", "models/starwars/cwa/lightsabers/ahsoka.mdl", {} )
		list.Set( "LightsaberModels", "models/starwars/cwa/lightsabers/byph.mdl", {} )
		list.Set( "LightsaberModels", "models/starwars/cwa/lightsabers/compressedcrystal.mdl", {} )
		list.Set( "LightsaberModels", "models/starwars/cwa/lightsabers/darkforcephase1.mdl", {} )
		list.Set( "LightsaberModels", "models/starwars/cwa/lightsabers/darkforcephase2.mdl", {} )
		list.Set( "LightsaberModels", "models/starwars/cwa/lightsabers/darkknight1.mdl", {} )
		list.Set( "LightsaberModels", "models/starwars/cwa/lightsabers/darkknight2.mdl", {} )
		list.Set( "LightsaberModels", "models/starwars/cwa/lightsabers/darksaber.mdl", {} )
		list.Set( "LightsaberModels", "models/starwars/cwa/lightsabers/darksaberancient.mdl", {} )
		list.Set( "LightsaberModels", "models/starwars/cwa/lightsabers/darthmaul.mdl", {} )
		list.Set( "LightsaberModels", "models/starwars/cwa/lightsabers/exile.mdl", {} )
		list.Set( "LightsaberModels", "models/starwars/cwa/lightsabers/felucia1.mdl", {} )
		list.Set( "LightsaberModels", "models/starwars/cwa/lightsabers/felucia2.mdl", {} )
		list.Set( "LightsaberModels", "models/starwars/cwa/lightsabers/forked.mdl", {} )
		list.Set( "LightsaberModels", "models/starwars/cwa/lightsabers/ganodi.mdl", {} )
		list.Set( "LightsaberModels", "models/starwars/cwa/lightsabers/gungan.mdl", {} )
		list.Set( "LightsaberModels", "models/starwars/cwa/lightsabers/gungi.mdl", {} )
		list.Set( "LightsaberModels", "models/starwars/cwa/lightsabers/jocastanu.mdl", {} )
		list.Set( "LightsaberModels", "models/starwars/cwa/lightsabers/kashyyyk.mdl", {} )
		list.Set( "LightsaberModels", "models/starwars/cwa/lightsabers/katooni.mdl", {} )
		list.Set( "LightsaberModels", "models/starwars/cwa/lightsabers/kitfisto.mdl", {} )
		list.Set( "LightsaberModels", "models/starwars/cwa/lightsabers/lightsideaffiliation.mdl", {} )
		list.Set( "LightsaberModels", "models/starwars/cwa/lightsabers/luminara.mdl", {} )
		list.Set( "LightsaberModels", "models/starwars/cwa/lightsabers/petro.mdl", {} )
		list.Set( "LightsaberModels", "models/starwars/cwa/lightsabers/pulsating.mdl", {} )
		list.Set( "LightsaberModels", "models/starwars/cwa/lightsabers/pulsatingblue.mdl", {} )
		list.Set( "LightsaberModels", "models/starwars/cwa/lightsabers/reverseahsoka.mdl", {} )
		list.Set( "LightsaberModels", "models/starwars/cwa/lightsabers/saeseetiin.mdl", {} )
		list.Set( "LightsaberModels", "models/starwars/cwa/lightsabers/samurai.mdl", {} )
		list.Set( "LightsaberModels", "models/starwars/cwa/lightsabers/shaakti.mdl", {} )
		list.Set( "LightsaberModels", "models/starwars/cwa/lightsabers/sparklingcrystal.mdl", {} )
		list.Set( "LightsaberModels", "models/starwars/cwa/lightsabers/spiralling.mdl", {} )
		list.Set( "LightsaberModels", "models/starwars/cwa/lightsabers/talz.mdl", {} )
		list.Set( "LightsaberModels", "models/starwars/cwa/lightsabers/training.mdl", {} )
		list.Set( "LightsaberModels", "models/starwars/cwa/lightsabers/trainingbuggy.mdl", {} )
		list.Set( "LightsaberModels", "models/starwars/cwa/lightsabers/unstable.mdl", {} )
		list.Set( "LightsaberModels", "models/starwars/cwa/lightsabers/ventress.mdl", {} )
		list.Set( "LightsaberModels", "models/starwars/cwa/lightsabers/zatt.mdl", {} )
		list.Set( "LightsaberModels", "models/starwars/cwa/lightsabers/zebra.mdl", {} )
		
	end
	
end )
--addons/wos-grandmaster-einf/lua/wos/advswl/combat/cl_dualsaber.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2020
	
	Contact: www.wiltostech.com
		----------------------------------------]]--








































































wOS = wOS or {}

hook.Add( "PrePlayerDraw", "wOS.CloakHook", function( ply )
	local wep = ply:GetActiveWeapon()
	if !IsValid( wep ) or !wep.IsLightsaber then 
		if ply.CloakSet then
			ply:SetMaterial( "" )		
			ply.CloakSet = false
		end
		return
	end	
	if not wep:GetCloaking() then 
		if ply.CloakSet then
			ply:SetMaterial( "" )
			ply.CloakSet = false
		end
		return
	end
	ply:SetMaterial("models/shadertest/shader3") 
	ply.CloakSet = true
	if ply:GetVelocity():Length() > 130 then return end
	return true
end )

--addons/wos-grandmaster-einf/lua/wos/advswl/devsys/cl_net.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2020
	
	Contact: www.wiltostech.com
		----------------------------------------]]--








































































wOS = wOS or {}
wOS.AvailableDevestators = wOS.AvailableDevestators or {}
wOS.DevestatorIcons = wOS.DevestatorIcons or {}

net.Receive( "wOS.Lightsabers.SendDevestatorData", function()
	wOS.AvailableDevestators = net.ReadTable()
	for name, data in pairs( wOS.AvailableDevestators ) do
		if data.image then
			wOS.DevestatorIcons[ name ] = Material( data.image, "unlitgeneric" )
		end
	end
end )


net.Receive( "wOS.ALCS.OpenDevestatorMenu", function()
	wOS:OpenDevestatorMenu()
end )

--addons/wos-grandmaster-einf/lua/wos/advswl/formsys/cl_forms.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2020
	
	Contact: www.wiltostech.com
		----------------------------------------]]--








































































wOS = wOS or {}
																																																																																		
net.Receive( "wOS.SendForm", function( len, ply )

	wOS.Form = net.ReadTable()
	print( "[wOS] Advanced Lightsaber Forms have been localized!" )

end )

net.Receive( "wOS.SendFGroups", function( len, ply )

	wOS.Forms = net.ReadTable()
	wOS.DualForms = net.ReadTable()

end )
--addons/wos-grandmaster-einf/lua/wos/advswl/crafting/core/cl_core.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2020
	
	Contact: www.wiltostech.com
		----------------------------------------]]--







































































wOS = wOS or {}

local w,h = ScrW(), ScrH()
local lookingat = nil

language.Add( "wos_primary_saber", "PRIMARY" )
language.Add( "wos_secondary_saber", "SECONDARY" )
language.Add( "wos_primary_blade", "Primary Blade" )
language.Add( "wos_secondary_blade", "Secondary Blade" )
language.Add( "wos_dual_saber", "DUAL" )
language.Add( "wos_option_hilt", "Hilt" )
language.Add( "wos_option_color", "Crystal" )
language.Add( "wos_option_blade", "Blade" )
language.Add( "wos_option_misc", "Energizers" )
language.Add( "wos_advert_wiltos", "Powered by wiltOS Technologies" )
language.Add( "wos_select_primaryhilt", "Set as Primary Hilt" )
language.Add( "wos_select_secondaryhilt", "Set as Secondary Hilt" )
language.Add( "wos_info_bladel", "Blade Length:" )
language.Add( "wos_info_bladew", "Blade Width:" )
language.Add( "wos_info_dark", "Dark Inner Blade" )
language.Add( "wos_info_primcrystal", "Primary Crystal" )
language.Add( "wos_info_seccrystal", "Secondary Crystal" )
language.Add( "wos_info_igniter", "Crystal Activator" )
language.Add( "wos_info_humsound", "Idle Regulator" )
language.Add( "wos_info_swingsound", "Power Vortex Regulator" )
language.Add( "wos_info_constructor", "Construction Module" )
language.Add( "wos_info_miscitem", "Proficiency Mods" )

language.Add( "wos_info_forgem", "Forging Routine" )
language.Add( "wos_info_smeltm", "Recycling Routine" )

local centerpoint = wOS.ALCS.Config.Crafting.CraftingCamLocation
local color_unselected = Color( 0, 0, 0, 100 )
local LastCamOrigin = vector_origin
local LastCamAng = Angle( 0, 0, 0 )

wOS.CraftingCamera = {}
wOS.CraftingCamera[ "Overview" ] = { origin = centerpoint - Vector( 400, -35, -25 ), angles = Angle( 20.840, -30.501, 0.000 ) }

surface.CreateFont( "wOS.CraftTitles", {
	font = "Roboto Cn",
	extended = false,
	size = 100,
	weight = 1000,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
} )

surface.CreateFont( "wOS.CraftDescriptions", {
	font = "Roboto Cn",
	extended = false,
	size = 60,
	weight = 1000,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
} )

surface.CreateFont( "wOS.CraftMinors", {
	font = "Roboto Cn",
	extended = false,
	size = 30,
	weight = 1000,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
} )

surface.CreateFont( "wOS.ItemTitles", {
	font = "Roboto Cn",
	extended = false,
	size = 100,
	weight = 1000,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
} )

surface.CreateFont( "wOS.ItemDescriptions", {
	font = "Roboto Cn",
	extended = false,
	size = 90,
	weight = 1000,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
} )

--local wallMat = Material("models/xqm/lightlinesred_tool")
--local wallMat = Material("phoenix_storms/FuturisticTrackRamp_1-2")
local wallMat = Material( "wos/phoenix_storms/wire/pcb_black", "unlitgeneric" )
--local wallMat = Material("phoenix_storms/Future_vents")

local upButton = Material( "wos/crafting/gui/up.png", "unlitgeneric" )
local downButton = Material( "wos/crafting/gui/down.png", "unlitgeneric" )
local bufferBar = Material( "wos/crafting/gui/buffer.png", "unlitgeneric" )

local ItemTable = {}
ItemTable[ WOSTYPE.CRYSTAL ] = Material( "wos/crafting/items/crystal.png", "unlitgeneric" )
ItemTable[ WOSTYPE.IGNITER ] = Material( "wos/crafting/items/crystal_ignitor.png", "unlitgeneric" )
ItemTable[ WOSTYPE.IDLE ] = Material( "wos/crafting/items/idle_regulator.png", "unlitgeneric" )
ItemTable[ WOSTYPE.VORTEX ] = Material( "wos/crafting/items/power_vortex.png", "unlitgeneric" ) 
ItemTable[ WOSTYPE.HILT ] = Material( "wos/crafting/items/hilt.png", "unlitgeneric" )
ItemTable[ WOSTYPE.BLUEPRINT ] = Material( "wos/crafting/items/blueprint.png", "unlitgeneric" ) 

hook.Add( "PostDrawOpaqueRenderables", "VoidHole", function()

	if !IsValid( wOS.CraftingMenu ) then return end
	if !wOS.CraftingMenu.RenderNow and !wOS.CraftingMenu.FullScreen then return end
	if !wOS.CraftingMenu:IsVisible() then return end
	local pos = Vector( centerpoint ) 
	local angle = Angle(0, 0, 0)
    local scale = 200
    local size = 5
    local center = pos - Vector( 0, 0, 200 )
	render.SetMaterial(wallMat)
	render.DrawQuadEasy(center + Vector(0, 0, 400), Vector(0, 0, -1), size*scale, size*scale, 0, Color(255, 0, 0), 0)
	render.DrawQuadEasy(center - Vector(0, size*scale/2, 100), Vector(0, 1, 0), size*scale, size*scale, 0, Color(255, 0, 0), 0)
	render.DrawQuadEasy(center - Vector(size*scale/2, 0, 100), Vector(1, 0, 0), size*scale, size*scale, 0, Color(255, 0, 0), 0)
	render.DrawQuadEasy(center - Vector(0, -size*scale/2, 100), Vector(0, -1, 0), size*scale, size*scale, 0, Color(255, 0, 0), 0)
	render.DrawQuadEasy(center - Vector(-size*scale/2, 0, 100), Vector(-1, 0, 0), size*scale, size*scale, 0, Color(255, 0, 0), 0)
	render.DrawQuadEasy(center - Vector(0, 0, 100), Vector(0, 0, 1), size*scale, size*scale, 0, Color(255, 0, 0 ), 0)
	
end )

hook.Add( "PostDrawTranslucentRenderables", "wOS.DrawSaberBladeAnd3D2D", function()

	if lookingat then
		lookingat:Renders()
		lookingat:Render( lookingat.CamPos, lookingat.CamAng, lookingat.Scaling or 0.1 )
	end

	if !IsValid( wOS.CraftingMenu ) then return end
	if !wOS.CraftingMenu.RenderNow and !wOS.CraftingMenu.FullScreen then return end
	if !wOS.CraftingMenu:IsVisible() then return end
	if !IsValid( wOS.CraftingMenu.Saber ) then return end
	
	wOS.CraftingMenu.Saber:DrawModel()

	local bladesFound = false -- true if the model is OLD and does not have blade attachments
	local blades = 0

	for id, t in pairs( wOS.CraftingMenu.Saber:GetAttachments() ) do
		if ( !string.match( t.name, "blade(%d+)" ) && !string.match( t.name, "quillon(%d+)" ) ) then continue end

		local bladeNum = string.match( t.name, "blade(%d+)" )
		local quillonNum = string.match( t.name, "quillon(%d+)" )
		if ( bladeNum && wOS.CraftingMenu.Saber:LookupAttachment( "blade" .. bladeNum ) > 0 ) then
			blades = blades + 1
			local pos, dir = wOS:FindBladePosAng( bladeNum, false, wOS.CraftingMenu.Saber )
			if not pos then return end
			rb655_RenderBlade_wos( pos, dir, wOS[ wOS.CurrentCraftTable ].UseLength, wOS[ wOS.CurrentCraftTable ].UseLength, wOS[ wOS.CurrentCraftTable ].UseWidth, wOS[ wOS.CurrentCraftTable ].UseColor, wOS[ wOS.CurrentCraftTable ].UseDarkInner == 1, wOS[ wOS.CurrentCraftTable ].UseInnerColor, wOS.CraftingMenu.Saber:EntIndex(), false, false, blades, wOS[ wOS.CurrentCraftTable ].CustomSettings )
			bladesFound = true
		end

		if ( quillonNum && wOS.CraftingMenu.Saber:LookupAttachment( "quillon" .. quillonNum ) > 0 ) then
			blades = blades + 1
			local pos, dir = wOS:FindBladePosAng( quillonNum, true, wOS.CraftingMenu.Saber )
			if not pos then return end
			rb655_RenderBlade_wos( pos, dir, wOS[ wOS.CurrentCraftTable ].UseLength, wOS[ wOS.CurrentCraftTable ].UseLength, wOS[ wOS.CurrentCraftTable ].UseWidth, wOS[ wOS.CurrentCraftTable ].UseColor, wOS[ wOS.CurrentCraftTable ].UseDarkInner == 1, wOS[ wOS.CurrentCraftTable ].UseInnerColor, wOS.CraftingMenu.Saber:EntIndex(), false, true, blades, wOS[ wOS.CurrentCraftTable ].CustomSettings )
		end

	end	
	
	if not bladesFound then
		local pos, dir = wOS:FindBladePosAng( nil, false, wOS.CraftingMenu.Saber )
		rb655_RenderBlade_wos( pos, dir, wOS[ wOS.CurrentCraftTable ].UseLength, wOS[ wOS.CurrentCraftTable ].UseLength, wOS[ wOS.CurrentCraftTable ].UseWidth, wOS[ wOS.CurrentCraftTable ].UseColor, wOS[ wOS.CurrentCraftTable ].UseDarkInner == 1, wOS[ wOS.CurrentCraftTable ].UseInnerColor, wOS.CraftingMenu.Saber:EntIndex(), false, false, blades, wOS[ wOS.CurrentCraftTable ].CustomSettings )
	end
	
	for _, frame in ipairs( wOS.CraftingButtons ) do
		frame:Renders()
		frame:Render( frame.CamPos, frame.CamAng, frame.Scaling or 0.1 )
	end
	
	if wOS.blueprint_item then wOS.blueprint_item:Think() end
	if wOS.blueprint_smelter then wOS.blueprint_smelter:Think() end

end )

hook.Add( "CalcView", "wOS.CraftingCamera", function( ply, pos, ang )
	if ( !IsValid( ply ) or !ply:Alive() or ply:InVehicle() or ply:GetViewEntity() != ply ) then return end
	if !IsValid( wOS.CraftingMenu ) then return end
	if !wOS.CraftingMenu.RenderNow and !wOS.CraftingMenu.FullScreen then return end
	if !wOS.CraftingMenu:IsVisible() then return end
	LastCamOrigin = ( LastCamOrigin == wOS.CraftingCamera[ wOS.CraftingFocus ].origin and wOS.CraftingCamera[ wOS.CraftingFocus ].origin ) or Lerp( FrameTime()*3, LastCamOrigin, wOS.CraftingCamera[ wOS.CraftingFocus ].origin )
	LastCamAng = ( LastCamAng == wOS.CraftingCamera[ wOS.CraftingFocus ].angles and wOS.CraftingCamera[ wOS.CraftingFocus ].angles ) or Lerp( FrameTime()*3, LastCamAng, wOS.CraftingCamera[ wOS.CraftingFocus ].angles )	
	return  { 
				origin = LastCamOrigin,
				angles = LastCamAng,
				drawviewer = false,
		    }
	
end )

hook.Add( "PostRenderVGUI", "wOS.ALCS.Crafting.CreateRenderWindow", function()
	if !IsValid( wOS.CraftingMenu ) then return end
	if not wOS.CraftingMenu:IsVisible() then return end
	wOS.CraftingMenu.DrawRender = true
		wOS.CraftingMenu:Paint() 
	if not wOS.CraftingMenu then return end
	wOS.CraftingMenu.DrawRender = false
end )

function wOS:CheckButtonHover( pan, lst )
	if not pan.LastHover then pan.LastHover = 0 end
	if pan.LastButt != lst or pan.LastHover <= CurTime() then
		pan.LastButt = lst
		surface.PlaySound( "wos/alcs/ui_rollover.wav" )
	end
	pan.LastHover = CurTime() + 0.08
end

wOS.PersonalSaber = table.Copy( wOS.ALCS.Config.Crafting.DefaultPersonalSaber )
wOS.SecPersonalSaber = table.Copy( wOS.ALCS.Config.Crafting.DefaultSecPersonalSaber )

function wOS:CleanCraftingMenus( button )
	if not button then
		if IsValid( self.CraftingMenu.Saber ) then 
			self.CraftingMenu.Saber:Remove()
		end
		self.CraftingMenu:Remove()
		self.CraftingMenu = nil
		gui.EnableScreenClicker( false )
	end
	if self.blueprint_floor then self.blueprint_floor:Remove() end
	if self.blueprint_item then self.blueprint_item:Remove() end
	if self.blueprint_smelter then self.blueprint_smelter:Remove() end
	self.blueprint_floor = nil
	self.blueprint_item = nil
	self.blueprint_smelter = nil
	self.CraftingButtons = {}
end

function wOS:OpenSaberCrafting()

	if self.CraftingMenu then 
		self:CleanCraftingMenus()
		net.Start( "wOS.ALCS.Crafting.CleanExit" )
		net.SendToServer()
		return
	end
	
	gui.EnableScreenClicker( true )
	
	if !self.PreCraftingMenu then
		wOS.UsingDualLightsaber = false
		self.PreCraftingMenu = vgui.Create( "DPanel" )
		self.PreCraftingMenu:SetSize( w, h )
		self.PreCraftingMenu:Center()
		self.PreCraftingMenu.Paint = function() end
		self.PreCraftingMenu.Think = function()
			if not vgui.CursorVisible() then gui.EnableScreenClicker( true ) end
		end
		
		local PrimarySaber = vgui.Create( "DButton", self.PreCraftingMenu )
		PrimarySaber:SetSize( w*0.12, h*0.05 )
		PrimarySaber:SetPos( w*0.38, h*0.44 )
		PrimarySaber:SetText( "" )
		PrimarySaber.Paint = function( pan, ww, hh )
			surface.SetDrawColor( ( pan:IsHovered() and Color( 0, 166, 255, 255 ) ) or color_white )
			surface.DrawOutlinedRect( 0, 0, ww, hh )
			draw.RoundedBox( 0, 0, 0, ww, hh, Color( 0, 0, 0, 155 ) )
			draw.SimpleText( "Primary Lightsaber", "wOS.CraftMinors", ww/2, hh/2, ( pan:IsHovered() and Color( 0, 166, 255, 255 ) ) or color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		end
		PrimarySaber.DoClick = function( pan )
			wOS.CurrentInventoryTable = "EquippedItems"
			wOS.CurrentCraftTable = "PersonalSaber"
			wOS.UsingDualLightsaber = false
			wOS:OpenSaberCrafting()
		end		
		
		local SecondarySaber = vgui.Create( "DButton", self.PreCraftingMenu )
		SecondarySaber:SetSize( w*0.12, h*0.05 )
		SecondarySaber:SetPos( w*0.51, h*0.51 )
		SecondarySaber:SetText( "" )
		SecondarySaber.Paint = function( pan, ww, hh )
			surface.SetDrawColor( ( pan:IsHovered() and Color( 0, 166, 255, 255 ) ) or color_white )
			surface.DrawOutlinedRect( 0, 0, ww, hh )
			draw.RoundedBox( 0, 0, 0, ww, hh, Color( 0, 0, 0, 155 ) )
			draw.SimpleText( "Off Hand Lightsaber", "wOS.CraftMinors", ww/2, hh/2, ( pan:IsHovered() and Color( 0, 166, 255, 255 ) ) or color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		end
		SecondarySaber.DoClick = function( pan )
			wOS.CurrentInventoryTable = "SecEquippedItems"
			wOS.CurrentCraftTable = "SecPersonalSaber"
			wOS.UsingDualLightsaber = true
			wOS:OpenSaberCrafting()
		end		
		return
	else
		self.PreCraftingMenu:Remove()
		self.PreCraftingMenu = nil
	end
	
	if self.InventoryPanel then
		self:ViewInventory()
	end
	
	gui.EnableScreenClicker( true )	
	wOS.PersonalSaber.Hilt = GetConVar( "rb655_lightsaber_model" ):GetString()
	wOS.PersonalSaber.CustomSettings[ "CraftingSaber" ] = true
	self.CraftingFocus = "Overview"
	
	self.CraftingMenu = vgui.Create( "DFrame" )
	self.CraftingMenu:SetDraggable( true )
	self.CraftingMenu:ShowCloseButton( false )
	self.CraftingMenu:SetTitle( "" )
	self.CraftingMenu:SetSize( ScrW()*0.9, ScrH()*0.9 )
	self.CraftingMenu:Center()
	self.CraftingMenu.SpawnTime = CurTime()
	self.CraftingMenu.PosData = { x = -1, y = -1 }

	local mw, mh = self.CraftingMenu:GetSize()
	local button = vgui.Create( "DButton", self.CraftingMenu )
	button:SetSize( mw*0.015, mh*0.02 )
	button:SetPos( mw*0.985, 0 )
	button:SetText( "" )
	button.DoClick = function()
		self:CleanCraftingMenus()
		net.Start( "wOS.ALCS.Crafting.CleanExit" )
		net.SendToServer()	
	end	
	button.Paint = nil

	self.CraftingMenu.Paint = function( pan, ww, hh )
		if not pan.DrawRender then return end
		local ww, hh = pan:GetSize()
		local px, py = pan:GetPos()
		pan.PosData.x, pan.PosData.y = pan:CursorPos()
		
		pan.RenderNow = true	
			draw.RoundedBox( 0, px, py, ww*0.985, hh*0.02, Color( 255, 255, 255, 155 ) )
			draw.RoundedBox( 0, px + ww*0.985, py, ww*0.015, hh*0.02, Color( 255, 0, 0 ) )
			local tbl = hook.Call( "CalcView", GAMEMODE, LocalPlayer() )
			tbl.w = ww
			tbl.h = hh*0.98
			tbl.x = px
			tbl.y = py + hh*0.02
			tbl.fov = 85
			render.RenderView( tbl )
		pan.RenderNow = false

	end 
	self.CraftingMenu.Think = function()
		if not vgui.CursorVisible() then gui.EnableScreenClicker( true ) end
		if not LocalPlayer():Alive() or input.IsKeyDown( KEY_BACKSPACE ) then
			wOS:CleanCraftingMenus()
			net.Start( "wOS.ALCS.Crafting.CleanExit" )
			net.SendToServer()
			return
		end
	end
	self.CraftingMenu.OriginalItems = table.Copy( self[ self.CurrentInventoryTable ] )
	
	self:BuildCraftingSaber()
	LastCamOrigin = self.CraftingMenu.Saber:GetPos() + Vector( 0, 0, 50 )
	LastCamAng = Angle( 90, 0, 0 )
	self:RebuildCraftingMenus()
	
end

function wOS:BuildCraftingSaber()
	if !IsValid( self.CraftingMenu ) then return end
	if IsValid( self.CraftingMenu.Saber ) then 
		self.CraftingMenu.Saber:Remove()
	end
	self.CraftingMenu.Saber = ClientsideModel( self[ self.CurrentCraftTable ].UseHilt, RENDERGROUP_BOTH )
	self.CraftingMenu.Saber:SetPos( centerpoint - Vector( 350, -10, 0 ) )
	local ang = self.CraftingMenu.Saber:GetAngles()
	if self[ self.CurrentCraftTable ].UseHilt:find( "maul_saber_staff" ) then
		ang:RotateAroundAxis( ang:Up(), -90 )
	else
		ang:RotateAroundAxis( ang:Up(), 90 )	
	end
	self.CraftingMenu.Saber:SetAngles( ang )
	self.CraftingMenu.Saber:SetNoDraw( true )
end

function wOS:RebuildCraftingMenus()
	self:CleanCraftingMenus( true )
	self.CraftMenuLibrary[ self.CraftingFocus ]()
end

function wOS:FindBladePosAng( num, side, model )
	
	num = num or 1
	local attachment = model:LookupAttachment( "blade" .. num )
	if ( side ) then
		attachment = model:LookupAttachment( "quillon" .. num )
	end
	
	if ( attachment && attachment > 0 ) then
		local PosAng = model:GetAttachment( attachment )
		return PosAng.Pos, PosAng.Ang:Forward()
	end
	
	local ang = model:GetAngles()
	ang = -1*ang:Forward()
	local pos = model:GetPos() + Vector( 0.6, 0.6, -0.25 )
	
	if num > 1 then
		ang = ang*-1
	end
	
	pos = pos - ang	
		
	return pos, ang
	
end

function wOS:FindHandPosAng( model )

	local attachment = model:LookupBone( "ValveBiped.Bip01_R_Hand" )

	if ( attachment && attachment >= 0 ) then
		local Pos, Ang = model:GetBonePosition( attachment )
		return Pos + Vector( 0, 0, 3 ), -1*Ang:Up()
	end
	
	local ang = model:GetAngles()
	ang = -1*ang:Forward()
	local pos = model:GetPos()
	
	if num > 1 then
		ang = ang*-1
	end
	
	pos = pos - ang	
		
	return pos, ang
	
end

wOS.CraftMenuLibrary = {}

wOS.CraftMenuLibrary[ "Overview" ] = function()
	local spos, sang = wOS:FindBladePosAng( nil, false, wOS.CraftingMenu.Saber )
	local bladecat = tduiw.Create()
	bladecat.SizeX = 10
	bladecat.SizeY = 5
	bladecat.ShouldAcceptInputs = true
	bladecat.Renders = function( pan )
		local ww, hh = pan.SizeX, pan.SizeY
		pan:Line( 0, 0, 0, -15 + 2*hh )
		pan:Line( 0, -15 + 2*hh, 5, -15 + hh/2 )
		pan:Rect( 5, -15, ww, hh, Color( 25, 25, 25, 245 ), color_unselected )
		--pan:Text( "Crystal", "wOS.TitleFont", ww/2, hh/2, color_unselected, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		local _jp, _pr, _hov = pan:Button( language.GetPhrase( "wos_option_color" ), "wOS.TitleFont", 5, -15, ww, hh )
	    if _jp then
			surface.PlaySound( "buttons/button9.wav" )
	       	wOS.CraftingFocus = language.GetPhrase( "wos_option_color" )
			wOS:RebuildCraftingMenus() 
	    elseif _hov then
			wOS:CheckButtonHover( pan, 0 )
		end
		pan:BlockUseBind()
	end
	bladecat:SetUIScale( 10 )
	bladecat:SetIgnoreZ( false )
	local cang = wOS.CraftingCamera[ wOS.CraftingFocus ].angles + Angle( 0, 0, 0 )
	bladecat.CamPos = spos + sang*wOS[ wOS.CurrentCraftTable ].UseLength*0.5
	bladecat.CamAng = cang
	wOS.CraftingCamera[ language.GetPhrase( "wos_option_color" ) ] = { origin = bladecat.CamPos + Vector( -15, -10, 5 ), angles = Vector( 15, -7, -5 ):Angle() + Angle( 0, 45, 0 ) - Angle( 0, 360, 0 )  }
	table.insert( wOS.CraftingButtons, bladecat )
	
	local hiltcat = tduiw.Create()
	hiltcat.SizeX = 10
	hiltcat.SizeY = 5
	hiltcat.ShouldAcceptInputs = true
	hiltcat.Renders = function( pan )
		local ww, hh = pan.SizeX, pan.SizeY
		pan:Line( 0, 0, 0, -15 + 2*hh )
		pan:Line( 0, -15 + 2*hh, -5, -15 + hh/2 )
		pan:Rect( -5 - ww, -15, ww, hh, Color( 25, 25, 25, 245 ), color_unselected )
		--pan:Text( "Crystal", "wOS.TitleFont", ww/2, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		local _jp, _pr, _hov = pan:Button(language.GetPhrase( "wos_option_hilt" ), "wOS.TitleFont", -5 - ww, -15, ww, hh )
	    if _jp then
			surface.PlaySound( "buttons/button9.wav" )
	       	wOS.CraftingFocus = language.GetPhrase( "wos_option_hilt" )
			wOS:RebuildCraftingMenus() 
	    elseif _hov then
			wOS:CheckButtonHover( pan, 0 )
		end
		pan:BlockUseBind()
	end
	hiltcat:SetUIScale( 10 )
	hiltcat:SetIgnoreZ( false )
	local apos, aang = wOS:FindHandPosAng( wOS.CraftingMenu.Saber )	
	hiltcat.CamPos = apos
	hiltcat.CamAng = cang
	wOS.CraftingCamera[ language.GetPhrase( "wos_option_hilt" ) ] = { origin = hiltcat.CamPos + Vector( 0, 0, 30 ), angles = ( Vector( 0, 0, -30 ) ):Angle() + Angle( 0, 0, 90 ) }
	table.insert( wOS.CraftingButtons, hiltcat )
	
	local ignitecat = tduiw.Create()
	ignitecat.SizeX = 15
	ignitecat.SizeY = 5
	ignitecat.ShouldAcceptInputs = true
	ignitecat.Renders = function( pan )
		local ww, hh = pan.SizeX, pan.SizeY
		pan:Line( 0, 0, 0, 15 - 2*hh )
		pan:Line( 0, 15 - 2*hh, 5, 15 - hh/2 )
		pan:Rect( 5, 15 - hh, ww, hh, Color( 25, 25, 25, 245 ), color_unselected )
		--pan:Text( "Crystal", "wOS.TitleFont", ww/2, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		local _jp, _pr, _hov = pan:Button(language.GetPhrase( "wos_info_igniter" ), "wOS.TitleFont", 5, 15 - hh, ww, hh )
	    if _jp then
			surface.PlaySound( "buttons/button9.wav" )
	       	wOS.CraftingFocus = language.GetPhrase( "wos_info_igniter" )
			wOS:RebuildCraftingMenus() 
	    elseif _hov then
			wOS:CheckButtonHover( pan, 0 )
		end
		pan:BlockUseBind()
	end
	ignitecat:SetUIScale( 10 )
	ignitecat:SetIgnoreZ( false )
	ignitecat.CamPos = spos
	ignitecat.CamAng = cang
	wOS.CraftingCamera[ language.GetPhrase( "wos_info_igniter" ) ] = { origin = ignitecat.CamPos + Vector( -5, -5, -2 ), angles = Vector( 5, 5, 2 ):Angle() - Angle( 360, 0, 0 )  }
	table.insert( wOS.CraftingButtons, ignitecat )
	
	local idlecat = tduiw.Create()
	idlecat.SizeX = 15
	idlecat.SizeY = 5
	idlecat.ShouldAcceptInputs = true
	idlecat.Renders = function( pan )
		local ww, hh = pan.SizeX, pan.SizeY
		pan:Line( 0, 0, 0, 15 - 2*hh )
		pan:Line( 0, 15 - 2*hh, -5, 15 - hh/2 )
		pan:Rect( -5 - ww, 15 - hh, ww, hh, Color( 25, 25, 25, 245 ), color_unselected )
		--pan:Text( "Crystal", "wOS.TitleFont", ww/2, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		local _jp, _pr, _hov = pan:Button(language.GetPhrase( "wos_info_humsound" ), "wOS.TitleFont", -5 - ww, 15 - hh, ww, hh )
	    if _jp then
			surface.PlaySound( "buttons/button9.wav" )
	       	wOS.CraftingFocus = language.GetPhrase( "wos_info_humsound" )
			wOS:RebuildCraftingMenus() 
	    elseif _hov then
			wOS:CheckButtonHover( pan, 0 )
		end
		pan:BlockUseBind()
	end
	idlecat:SetUIScale( 10 )
	idlecat:SetIgnoreZ( false )
	idlecat.CamPos = apos - aang*3
	idlecat.CamAng = cang
	wOS.CraftingCamera[ language.GetPhrase( "wos_info_humsound" ) ] = { origin = idlecat.CamPos + Vector( 5, 5, -5 ), angles = Vector( -5, -5, 5 ):Angle() - Angle( 360, 360, 0 )  }
	table.insert( wOS.CraftingButtons, idlecat )
	
	local powercat = tduiw.Create()
	powercat.SizeX = 20
	powercat.SizeY = 5
	powercat.ShouldAcceptInputs = true
	powercat.Renders = function( pan )
		local ww, hh = pan.SizeX, pan.SizeY
		pan:Line( 0, 0, -5, -5 )
		pan:Line( -5, -5, -15, -5 )
		pan:Rect( -15 - ww, -5 - hh/2, ww, hh, Color( 25, 25, 25, 245 ), color_unselected )
		--pan:Text( "Crystal", "wOS.TitleFont", ww/2, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		local _jp, _pr, _hov = pan:Button(language.GetPhrase( "wos_info_swingsound" ), "wOS.TitleFont", -15 - ww, -5 - hh/2, ww, hh )
	    if _jp then
			surface.PlaySound( "buttons/button9.wav" )
	       	wOS.CraftingFocus = language.GetPhrase( "wos_info_swingsound" )
			wOS:RebuildCraftingMenus() 
	    elseif _hov then
			wOS:CheckButtonHover( pan, 0 )
		end
		pan:BlockUseBind()
	end
	powercat:SetUIScale( 10 )
	powercat:SetIgnoreZ( false )
	powercat.CamPos = apos - aang*1.5
	powercat.CamAng = cang
	wOS.CraftingCamera[ language.GetPhrase( "wos_info_swingsound" ) ] = { origin = powercat.CamPos + Vector( 5, 5, 3 ), angles = Vector( -5, -5, -3 ):Angle() - Angle( 0, 360, 0 )  }
	table.insert( wOS.CraftingButtons, powercat )
	
	local bluecat = tduiw.Create()
	bluecat.SizeX = 20
	bluecat.SizeY = 25
	bluecat.ShouldAcceptInputs = true
	bluecat.Renders = function( pan )
		local ww, hh = pan.SizeX, pan.SizeY
		local x = 35
		pan:Rect( x, -10, ww, hh/8, Color( 25, 25, 25, 245 ), color_unselected )
		local _jp, _pr, _hov = pan:Button( language.GetPhrase( "wos_info_constructor" ), "wOS.TitleFont", x, -10, ww, hh/8 )
	    if _jp then
			surface.PlaySound( "buttons/button9.wav" )
	       	wOS.CraftingFocus = language.GetPhrase( "wos_info_constructor" )
			wOS:RebuildCraftingMenus() 
	    elseif _hov then
			wOS:CheckButtonHover( pan, 0 )
		end
		pan:Rect( x, -6.3, ww, hh/8, Color( 25, 25, 25, 245 ), color_unselected )
		local _jp, _pr, _hov = pan:Button( language.GetPhrase( "wos_info_miscitem" ), "wOS.TitleFont", x, -6.3, ww, hh/8 )
	    if _jp then
			surface.PlaySound( "buttons/button9.wav" )
	       	wOS.CraftingFocus = language.GetPhrase( "wos_info_miscitem" )
			wOS:RebuildCraftingMenus() 
	    elseif _hov then
			wOS:CheckButtonHover( pan, 1 )
		end
		pan:BlockUseBind()
	end
	bluecat:SetUIScale( 20 )
	bluecat.Scaling = 0.05
	bluecat:SetIgnoreZ( false )
	bluecat.CamPos = apos - aang*1.5
	bluecat.CamAng = cang
	wOS.CraftingCamera[ language.GetPhrase( "wos_info_miscitem" ) ] = { origin = centerpoint - Vector( 100, -35, -25 ), angles = Angle( 20.840, 30.501, 0.000 )  }
	wOS.CraftingCamera[ language.GetPhrase( "wos_info_constructor" ) ] = { origin = centerpoint - Vector( 100, -35, -25 ), angles = Angle( 20.840, 30.501, 0.000 )  }
	table.insert( wOS.CraftingButtons, bluecat )
	
	
	local backbutt = tduiw.Create()
	backbutt.SizeX = 20
	backbutt.SizeY = 25
	backbutt.ShouldAcceptInputs = true
	backbutt.Renders = function( pan )
		local ww, hh = pan.SizeX, pan.SizeY
		local x = 35
		pan:Rect( x, -10 - hh*(7/8) - 0.5, ww, hh*(7/8), Color( 25, 25, 25, 245 ), color_white )		
		pan:Rect( x, -10 - hh*(7/8) - 0.5, ww, hh*(1/8), Color( 25, 25, 25, 245 ), color_white )
		pan:Text( "Current Stats", "wOS.TitleFont", x + ww*0.05, -10 - hh*(7/8) - 0.5 + hh/16, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )		
		pan:Text( "Proficiency Level: " .. LocalPlayer():GetNW2Int( "wOS.ProficiencyLevel", 0 ), "wOS.TitleFont", x + ww*0.95, -10 - hh*(7/8) - 0.5 + hh/16, color_white, TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER )	
		pan:Text( "Hilt: " .. wOS[ wOS.CurrentInventoryTable ][ WOSTYPE.HILT ], "wOS.TitleFont", x + 1, -10 - hh*(7/8) - 0.5 + hh/8 + 1.5, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )		
		pan:Text( "Crystal: " .. wOS[ wOS.CurrentInventoryTable ][ WOSTYPE.CRYSTAL ], "wOS.TitleFont", x + 1, -10 - hh*(7/8) - 0.5 + hh/8 + 1.5 + 2, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )	
		pan:Text( "Idle Regulator: " .. wOS[ wOS.CurrentInventoryTable ][ WOSTYPE.IDLE ], "wOS.TitleFont", x + 1, -10 - hh*(7/8) - 0.5 + hh/8 + 1.5 + 4, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )	
		pan:Text( "Crystal Activator: " .. wOS[ wOS.CurrentInventoryTable ][ WOSTYPE.IGNITER ], "wOS.TitleFont", x + 1, -10 - hh*(7/8) - 0.5 + hh/8 + 1.5 + 6, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )			
		pan:Text( "Power Vortex Regulator: " .. wOS[ wOS.CurrentInventoryTable ][ WOSTYPE.VORTEX ], "wOS.TitleFont", x + 1, -10 - hh*(7/8) - 0.5 + hh/8 + 1.5 + 8, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )	
		pan:Text( "Blade Length: " .. wOS[ wOS.CurrentCraftTable ].UseLength, "wOS.TitleFont", x + 1, -10 - hh*(7/8) - 0.5 + hh/8 + 1.5 + 10, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )			
		pan:Text( "Blade Width: " .. wOS[ wOS.CurrentCraftTable ].UseWidth, "wOS.TitleFont", x + 1, -10 - hh*(7/8) - 0.5 + hh/8 + 1.5 + 12, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )	
		pan:Text( "Base Damage: " .. wOS[ wOS.CurrentCraftTable ].SaberDamage, "wOS.TitleFont", x + 1, -10 - hh*(7/8) - 0.5 + hh/8 + 1.5 + 14, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )	
		pan:Text( "Base Burn Damage: " .. wOS[ wOS.CurrentCraftTable ].SaberBurnDamage, "wOS.TitleFont", x + 1, -10 - hh*(7/8) - 0.5 + hh/8 + 1.5 + 16, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )	
		pan:Rect( x, 1, ww, hh/8, Color( 25, 25, 25, 245 ), color_unselected )
		local _jp, _pr, _hov = pan:Button( "Fabricate", "wOS.TitleFont", x, 1, ww, hh/8 )
	    if _jp then
			surface.PlaySound( "buttons/button24.wav" )
			wOS:CleanCraftingMenus()
			net.Start( "wOS.Crafting.UpdateItems" )
				net.WriteTable( wOS.EquippedItems )
				net.WriteTable( wOS.SecEquippedItems )
				net.WriteTable( wOS.SaberMiscSlots )
			net.SendToServer()
	    elseif _hov then
			wOS:CheckButtonHover( pan, 0 )
		end
		pan:BlockUseBind()
	end
	backbutt:SetUIScale( 20 )
	backbutt.Scaling = 0.05
	backbutt.CamPos = apos - aang*1.5
	backbutt.CamAng = cang

	table.insert( wOS.CraftingButtons, backbutt )
end

wOS.CraftMenuLibrary[ language.GetPhrase( "wos_option_color" ) ] = function()
	local spos, sang = wOS:FindBladePosAng( nil, false, wOS.CraftingMenu.Saber )
	local cpos = wOS.CraftingCamera[ wOS.CraftingFocus ].origin
	local cang = wOS.CraftingCamera[ wOS.CraftingFocus ].angles
	
	local sorted_list = {}
	sorted_list[1] = wOS[ wOS.CurrentInventoryTable ][ WOSTYPE.CRYSTAL ]
	if sorted_list[1] != "Standard" then
		sorted_list[2] = "Standard"
	end
	for name, data in pairs( wOS.SortedItemList[ WOSTYPE.CRYSTAL ] ) do
		if wOS:GetSaberItemInInventory( wOS.SaberInventory, name ) then
			if !table.HasValue( sorted_list, name ) then
				sorted_list[ #sorted_list + 1 ] = name
			end
		end
	end
	
	local bladecat = tduiw.Create()
	bladecat.SizeX = 10
	bladecat.SizeY = 2.5
	bladecat.ShouldAcceptInputs = true
	bladecat.ScrollMin = 1
	bladecat.ScrollMax = 3
	bladecat.SortedList = table.Copy( sorted_list )
	bladecat.Renders = function( pan )
		local ww, hh = pan.SizeX, pan.SizeY
		local offset = 2
		local bw, bh = ww, hh*0.5

		if #pan.SortedList > 3  then
			pan:Mat( upButton, ww*0.48 - hh/2, offset - bh/2, hh/2, hh/2 )
			local _jp, _pr, _hov = pan:Button("", "wOS.CraftDescriptions", ww*0.48 - hh/2, offset - bh/2, hh/2, hh/2 )
			if _jp then
				if pan.ScrollMin > 1 then
					surface.PlaySound( "buttons/lightswitch2.wav" )
					pan.ScrollMin = pan.ScrollMin - 1
					pan.ScrollMax = pan.ScrollMax - 1
				end
			elseif _hov then
				wOS:CheckButtonHover( pan, 0 )
			end

			pan:Mat( bufferBar, ww*0.48 - hh/2, offset + bh/2 + bh/6, hh/2, 2*bh )
			pan:Rect( ww*0.48 - hh/2, offset + bh/2 + bh/6, hh/2, 2*bh, Color( 0, 0, 0, 0 ), color_white )
		end

		for i = pan.ScrollMin, pan.ScrollMax do
			local data = wOS.SortedItemList[ WOSTYPE.CRYSTAL ][ pan.SortedList[ i ] ]
			if not data then continue end
			pan:Rect( ww*0.5, offset, bw, bh, Color( 25, 25, 25, 245 ), color_white )
			local col = color_white
			pan:Text( data.Name, "wOS.CraftDescriptions", ww*0.5 + bw*0.01, offset + bh*0.05, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP )
			pan:Text( data.Description, "wOS.CraftMinors", ww*0.5 + bw*0.01, offset + bh*0.62, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP )
			if data.BurnOnUse then
				pan:Text( "BURNED ON USE", "wOS.CraftMinors", ww*0.5 + bw*0.98, offset + bh*0.05, Color( 255, 0, 0 ), TEXT_ALIGN_RIGHT, TEXT_ALIGN_TOP )			
			end
			if wOS[ wOS.CurrentInventoryTable ][ WOSTYPE.CRYSTAL ] == data.Name then
				pan:Rect( ww*0.5, offset, bw, bh, Color( 0, 0, 0, 0 ), Color( 0, 128, 255 ) )				
			else
				local _jp, _pr, _hov = pan:Button("", "wOS.CraftDescriptions", ww*0.5, offset, bw, bh )
				if _jp then
					surface.PlaySound( "buttons/button9.wav" )
					wOS[ wOS.CurrentInventoryTable ][ WOSTYPE.CRYSTAL ] = data.Name
					net.Start( "wOS.Crafting.PreviewChange" )
						net.WriteBool( wOS.UsingDualLightsaber )
						net.WriteTable( wOS[ wOS.CurrentInventoryTable ] )
					net.SendToServer()
				elseif _hov then
					wOS:CheckButtonHover( pan, i + 30 )
				end
			end
			offset = offset + bh + 0.25
		end
		if #pan.SortedList > 3  then
			offset = offset - 0.25
			pan:Mat( downButton, ww*0.48 - hh/2, offset - bh/2, hh/2, hh/2 )
			local _jp, _pr, _hov = pan:Button("", "wOS.CraftDescriptions", ww*0.48 - hh/2, offset - bh/2, hh/2, hh/2 )
			if _jp then
				if pan.ScrollMax < #pan.SortedList then
					surface.PlaySound( "buttons/lightswitch2.wav" )
					pan.ScrollMin = pan.ScrollMin + 1
					pan.ScrollMax = pan.ScrollMax + 1
				end
			elseif _hov then
				wOS:CheckButtonHover( pan, 0.1 )
			end
		end
	end
	bladecat:SetUIScale( 100 )
	bladecat.Scaling = 0.01
	bladecat.CamPos = spos + sang * wOS[ wOS.CurrentCraftTable ].UseLength * 0.5
	bladecat.CamAng = sang:Angle() + Angle( 0, 90, 0 )

	table.insert( wOS.CraftingButtons, bladecat )
	
	local backbutt = tduiw.Create()
	backbutt.SizeX = 8
	backbutt.SizeY = 2
	backbutt.ShouldAcceptInputs = true
	backbutt.Renders = function( pan )
		local ww, hh = pan.SizeX, pan.SizeY
		pan:Rect( -2*ww, 4, ww, hh, Color( 25, 25, 25, 245 ), color_unselected )
		local _jp, _pr, _hov = pan:Button( "Back", "wOS.CraftTitles", -2*ww, 4, ww, hh )
	    if _jp then
			surface.PlaySound( "buttons/combine_button2.wav" )
	       	wOS.CraftingFocus = "Overview"
			wOS:RebuildCraftingMenus() 
	    elseif _hov then
			wOS:CheckButtonHover( pan, 0 )
		end
		pan:BlockUseBind()
	end
	backbutt:SetUIScale( 100 )
	backbutt.Scaling = 0.01	
	backbutt.CamPos = spos + sang*wOS[ wOS.CurrentCraftTable ].UseLength*0.5
	backbutt.CamAng = sang:Angle() + Angle( 0, 90, 0 )
	
	table.insert( wOS.CraftingButtons, backbutt )		
	
end

wOS.CraftMenuLibrary[ language.GetPhrase( "wos_option_hilt" ) ] = function()
	local spos, sang = wOS:FindBladePosAng( nil, false, wOS.CraftingMenu.Saber )
	local cpos = wOS.CraftingCamera[ wOS.CraftingFocus ].origin
	local cang = wOS.CraftingCamera[ wOS.CraftingFocus ].angles
	local apos, aang = wOS:FindHandPosAng( wOS.CraftingMenu.Saber )
	
	local sorted_list = {}
	sorted_list[1] = wOS[ wOS.CurrentInventoryTable ][ WOSTYPE.HILT ]
	if sorted_list[1] != "Standard" then
		sorted_list[2] = "Standard"
	elseif wOS.CraftingMenu.OriginalItems[ WOSTYPE.HILT ] != "Standard" then
		sorted_list[2] = wOS.CraftingMenu.OriginalItems[ WOSTYPE.HILT ]
	end

	for name, data in pairs( wOS.SortedItemList[ WOSTYPE.HILT ] ) do
		if wOS:GetSaberItemInInventory( wOS.SaberInventory, name ) then
			if !table.HasValue( sorted_list, name ) then
				sorted_list[ #sorted_list + 1 ] = name
			end
		end
	end

	if wOS[ wOS.CurrentCraftTable ].UseHilt:find( "maul_saber_staff" ) then
		aang = aang*-1
	end
	
	local bladecat = tduiw.Create()
	bladecat.SizeX = 10
	bladecat.SizeY = 2.5
	bladecat.ShouldAcceptInputs = true
	bladecat.ScrollMin = 1
	bladecat.ScrollMax = 3
	bladecat.SortedList = table.Copy( sorted_list )
	bladecat.Renders = function( pan )
		local ww, hh = pan.SizeX, pan.SizeY
		local offset = -2.3
		local bw, bh = ww, hh*0.5
		
		if #pan.SortedList > 3  then
			pan:Mat( upButton, ww*0.48 - hh/2, offset - bh/2, hh/2, hh/2 )
			local _jp, _pr, _hov = pan:Button("", "wOS.CraftDescriptions", ww*0.48 - hh/2, offset - bh/2, hh/2, hh/2 )
			if _jp then
				if pan.ScrollMin > 1 then
					surface.PlaySound( "buttons/lightswitch2.wav" )
					pan.ScrollMin = pan.ScrollMin - 1
					pan.ScrollMax = pan.ScrollMax - 1
				end
			elseif _hov then
				wOS:CheckButtonHover( pan, 0 )
			end
				
			pan:Mat( bufferBar, ww*0.48 - hh/2, offset + bh/2 + bh/6, hh/2, 2*bh )
			pan:Rect( ww*0.48 - hh/2, offset + bh/2 + bh/6, hh/2, 2*bh, Color( 0, 0, 0, 0 ), color_white )					
		end
		
		
		for i = pan.ScrollMin, pan.ScrollMax do
			local data = wOS.SortedItemList[ WOSTYPE.HILT ][ pan.SortedList[ i ] ]
			if not data then continue end
			pan:Rect( ww*0.5, offset, bw, bh, Color( 25, 25, 25, 245 ), color_white )
			local col = color_white
			pan:Text( data.Name, "wOS.CraftDescriptions", ww*0.5 + bw*0.01, offset + bh*0.05, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP )
			pan:Text( data.Description, "wOS.CraftMinors", ww*0.5 + bw*0.01, offset + bh*0.62, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP )
			if data.BurnOnUse then
				pan:Text( "BURNED ON USE", "wOS.CraftMinors", ww*0.5 + bw*0.98, offset + bh*0.05, Color( 255, 0, 0 ), TEXT_ALIGN_RIGHT, TEXT_ALIGN_TOP )			
			end
			if wOS[ wOS.CurrentInventoryTable ][ WOSTYPE.HILT ] == data.Name then
				pan:Rect( ww*0.5, offset, bw, bh, Color( 0, 0, 0, 0 ), Color( 0, 128, 255 ) )				
			else
				local _jp, _pr, _hov = pan:Button("", "wOS.CraftDescriptions", ww*0.5, offset, bw, bh )
				if _jp then
					surface.PlaySound( "buttons/button9.wav" )
					wOS[ wOS.CurrentInventoryTable ][ WOSTYPE.HILT ] = data.Name
					net.Start( "wOS.Crafting.PreviewChange" )
						net.WriteBool( wOS.UsingDualLightsaber )
						net.WriteTable( wOS[ wOS.CurrentInventoryTable ] )
					net.SendToServer()
				elseif _hov then
					wOS:CheckButtonHover( pan, i + 30 )
				end
			end
			offset = offset + bh + 0.25
		end
		if #pan.SortedList > 3  then
			offset = offset - 0.25
			pan:Mat( downButton, ww*0.48 - hh/2, offset - bh/2, hh/2, hh/2 )
			local _jp, _pr, _hov = pan:Button("", "wOS.CraftDescriptions", ww*0.48 - hh/2, offset - bh/2, hh/2, hh/2 )
			if _jp then
				if pan.ScrollMax < #pan.SortedList then
					surface.PlaySound( "buttons/lightswitch2.wav" )
					pan.ScrollMin = pan.ScrollMin + 1
					pan.ScrollMax = pan.ScrollMax + 1
				end
			elseif _hov then
				wOS:CheckButtonHover( pan, 0.1 )
			end
		end
	end
	bladecat:SetUIScale( 100 )
	bladecat.Scaling = 0.01
	bladecat.CamPos = apos + Vector( 0, 0, 8 )
	bladecat.CamAng = aang:Angle() + Angle( 94, -5, 0 )
	
	table.insert( wOS.CraftingButtons, bladecat )	
	
	local backbutt = tduiw.Create()
	backbutt.SizeX = 8
	backbutt.SizeY = 2
	backbutt.ShouldAcceptInputs = true
	backbutt.Renders = function( pan )
		local ww, hh = pan.SizeX, pan.SizeY
		pan:Rect( -9 - ww/2, 4, ww, hh, Color( 25, 25, 25, 245 ), color_unselected )
		local _jp, _pr, _hov = pan:Button( "Back", "wOS.CraftTitles", -9 - ww/2, 4, ww, hh )
	    if _jp then
			surface.PlaySound( "buttons/combine_button2.wav" )
	       	wOS.CraftingFocus = "Overview"
			wOS:RebuildCraftingMenus() 
	    elseif _hov then
			wOS:CheckButtonHover( pan, 0 )
		end
		pan:BlockUseBind()
	end
	backbutt:SetUIScale( 100 )
	backbutt.Scaling = 0.01	
	backbutt.CamPos = apos + Vector( 0, 0, 8 )
	backbutt.CamAng = aang:Angle() + Angle( 94, -5, 0 )
	
	table.insert( wOS.CraftingButtons, backbutt )		
	
end

wOS.CraftMenuLibrary[ language.GetPhrase( "wos_info_igniter" ) ] = function()
	local spos, sang = wOS:FindBladePosAng( nil, false, wOS.CraftingMenu.Saber )
	local cpos = wOS.CraftingCamera[ wOS.CraftingFocus ].origin
	local cang = wOS.CraftingCamera[ wOS.CraftingFocus ].angles
	local apos, aang = wOS:FindHandPosAng( wOS.CraftingMenu.Saber )	
	
	local sorted_list = {}
	sorted_list[1] = wOS[ wOS.CurrentInventoryTable ][ WOSTYPE.IGNITER ]
	if sorted_list[1] != "Standard" then
		sorted_list[2] = "Standard"
	elseif wOS.CraftingMenu.OriginalItems[ WOSTYPE.IGNITER ] != "Standard" then
		sorted_list[2] = wOS.CraftingMenu.OriginalItems[ WOSTYPE.IGNITER ]
	end

	for name, data in pairs( wOS.SortedItemList[ WOSTYPE.IGNITER ] ) do
		if wOS:GetSaberItemInInventory( wOS.SaberInventory, name ) then
			if !table.HasValue( sorted_list, name ) then
				sorted_list[ #sorted_list + 1 ] = name
			end
		end
	end

	local bladecat2 = tduiw.Create()
	bladecat2.SizeX = 10
	bladecat2.SizeY = 2.5
	bladecat2.ShouldAcceptInputs = true
	bladecat2.ScrollMin = 1
	bladecat2.ScrollMax = 3
	bladecat2.SortedList = table.Copy( sorted_list )
	bladecat2.Renders = function( pan )
		local ww, hh = pan.SizeX, pan.SizeY
		local x = -2
		local offset = 3.5
		local bw, bh = ww, hh*0.5
		if #pan.SortedList > 3 then
			pan:Mat( upButton, x*1.1 - hh/2, offset - bh/2, hh/2, hh/2 )
			local _jp, _pr, _hov = pan:Button("", "wOS.CraftDescriptions", x*1.1 - hh/2, offset - bh/2, hh/2, hh/2 )
			if _jp then
				if pan.ScrollMin > 1 then
					surface.PlaySound( "buttons/lightswitch2.wav" )
					pan.ScrollMin = pan.ScrollMin - 1
					pan.ScrollMax = pan.ScrollMax - 1
				end
			elseif _hov then
				wOS:CheckButtonHover( pan, 0 )
			end

			pan:Mat( bufferBar, x*1.1 - hh/2, offset + bh/2 + bh/6, hh/2, 2*bh )
			pan:Rect( x*1.1 - hh/2, offset + bh/2 + bh/6, hh/2, 2*bh, Color( 0, 0, 0, 0 ), color_white )
		end

		for i = pan.ScrollMin, pan.ScrollMax do
			local data = wOS.SortedItemList[ WOSTYPE.IGNITER ][ pan.SortedList[ i ] ]
			if not data then continue end
			pan:Rect( x, offset, bw, bh, Color( 25, 25, 25, 245 ), color_white )
			local col = color_white
			pan:Text( data.Name, "wOS.CraftDescriptions", x + bw*0.01, offset + bh*0.05, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP )
			pan:Text( data.Description, "wOS.CraftMinors", x + bw*0.01, offset + bh*0.62, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP )
			if data.BurnOnUse then
				pan:Text( "BURNED ON USE", "wOS.CraftMinors", x + bw*0.98, offset + bh*0.05, Color( 255, 0, 0 ), TEXT_ALIGN_RIGHT, TEXT_ALIGN_TOP )
			end
			if wOS[ wOS.CurrentInventoryTable ][ WOSTYPE.IGNITER ] == data.Name then
				pan:Rect( x, offset, bw, bh, Color( 0, 0, 0, 0 ), Color( 0, 128, 255 ) )
			else
				local _jp, _pr, _hov = pan:Button("", "wOS.CraftDescriptions", x, offset, bw, bh )
				if _jp then
					surface.PlaySound( "buttons/button9.wav" )
					wOS[ wOS.CurrentInventoryTable ][ WOSTYPE.IGNITER ] = data.Name
					net.Start( "wOS.Crafting.PreviewChange" )
						net.WriteBool( wOS.UsingDualLightsaber )
						net.WriteTable( wOS[ wOS.CurrentInventoryTable ] )
					net.SendToServer()
				elseif _hov then
					wOS:CheckButtonHover( pan, i + 30 )
				end
			end
			offset = offset + bh + 0.25
		end
		if #pan.SortedList > 3  then
			offset = offset - 0.25
			pan:Mat( downButton, x*1.1 - hh/2, offset - bh/2, hh/2, hh/2 )
			local _jp, _pr, _hov = pan:Button("", "wOS.CraftDescriptions", x*1.1 - hh/2, offset - bh/2, hh/2, hh/2 )
			if _jp then
				if pan.ScrollMax < #pan.SortedList then
					surface.PlaySound( "buttons/lightswitch2.wav" )
					pan.ScrollMin = pan.ScrollMin + 1
					pan.ScrollMax = pan.ScrollMax + 1
				end
			elseif _hov then
				wOS:CheckButtonHover( pan, 0.1 )
			end
		end
	end
	bladecat2:SetUIScale( 100 )
	bladecat2.Scaling = 0.004
	bladecat2.CamPos = spos
	bladecat2.CamAng = sang:Angle() + Angle( 0, 90, 0 )

	table.insert( wOS.CraftingButtons, bladecat2 )	
	
	local backbutt = tduiw.Create()
	backbutt.SizeX = 8
	backbutt.SizeY = 2
	backbutt.ShouldAcceptInputs = true
	backbutt.Renders = function( pan )
		local ww, hh = pan.SizeX, pan.SizeY
		pan:Rect( -11 - ww/2, 3, ww, hh, Color( 25, 25, 25, 245 ), color_unselected )
		local _jp, _pr, _hov = pan:Button( "Back", "wOS.CraftTitles", -11 - ww/2, 3, ww, hh )
	    if _jp then
			surface.PlaySound( "buttons/combine_button2.wav" )
	       	wOS.CraftingFocus = "Overview"
			wOS:RebuildCraftingMenus() 
	    elseif _hov then
			wOS:CheckButtonHover( pan, 0 )
		end
		pan:BlockUseBind()
	end
	backbutt:SetUIScale( 100 )
	backbutt.Scaling = 0.005	
	backbutt.CamPos = spos
	backbutt.CamAng = sang:Angle() + Angle( 0, 90, 0 )

	table.insert( wOS.CraftingButtons, backbutt )
end

wOS.CraftMenuLibrary[ language.GetPhrase( "wos_info_humsound" ) ] = function()
	local spos, sang = wOS:FindBladePosAng( nil, false, wOS.CraftingMenu.Saber )
	local cpos = wOS.CraftingCamera[ wOS.CraftingFocus ].origin
	local cang = wOS.CraftingCamera[ wOS.CraftingFocus ].angles
	local apos, aang = wOS:FindHandPosAng( wOS.CraftingMenu.Saber )
	
	local sorted_list = {}
	sorted_list[1] = wOS[ wOS.CurrentInventoryTable ][ WOSTYPE.IDLE ]
	if sorted_list[1] != "Standard" then
		sorted_list[2] = "Standard"
	elseif wOS.CraftingMenu.OriginalItems[ WOSTYPE.IDLE ] != "Standard" then
		sorted_list[2] = wOS.CraftingMenu.OriginalItems[ WOSTYPE.IDLE ]
	end

	for name, data in pairs( wOS.SortedItemList[ WOSTYPE.IDLE ] ) do
		if wOS:GetSaberItemInInventory( wOS.SaberInventory, name ) then
			if !table.HasValue( sorted_list, name ) then
				sorted_list[ #sorted_list + 1 ] = name
			end
		end
	end

	local bladecat2 = tduiw.Create()
	bladecat2.SizeX = 10
	bladecat2.SizeY = 2.5
	bladecat2.ShouldAcceptInputs = true
	bladecat2.ScrollMin = 1
	bladecat2.ScrollMax = 3
	bladecat2.SortedList = table.Copy( sorted_list )
	bladecat2.Renders = function( pan )
		local ww, hh = pan.SizeX, pan.SizeY
		local x = -2
		local offset = 3.5
		local bw, bh = ww, hh*0.5
		if #pan.SortedList > 3 then
			pan:Mat( upButton, x*1.1 - hh/2, offset - bh/2, hh/2, hh/2 )
			local _jp, _pr, _hov = pan:Button("", "wOS.CraftDescriptions", x*1.1 - hh/2, offset - bh/2, hh/2, hh/2 )
			if _jp then
				if pan.ScrollMin > 1 then
					surface.PlaySound( "buttons/lightswitch2.wav" )
					pan.ScrollMin = pan.ScrollMin - 1
					pan.ScrollMax = pan.ScrollMax - 1
				end
			elseif _hov then
				wOS:CheckButtonHover( pan, 0 )
			end
				
			pan:Mat( bufferBar, x*1.1 - hh/2, offset + bh/2 + bh/6, hh/2, 2*bh )
			pan:Rect( x*1.1 - hh/2, offset + bh/2 + bh/6, hh/2, 2*bh, Color( 0, 0, 0, 0 ), color_white )					
		end
		
		
		for i = pan.ScrollMin, pan.ScrollMax do
			local data = wOS.SortedItemList[ WOSTYPE.IDLE ][ pan.SortedList[ i ] ]
			if not data then continue end
			pan:Rect( x, offset, bw, bh, Color( 25, 25, 25, 245 ), color_white )
			local col = color_white
			pan:Text( data.Name, "wOS.CraftDescriptions", x + bw*0.01, offset + bh*0.05, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP )
			pan:Text( data.Description, "wOS.CraftMinors", x + bw*0.01, offset + bh*0.62, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP )
			if data.BurnOnUse then
				pan:Text( "BURNED ON USE", "wOS.CraftMinors", x + bw*0.98, offset + bh*0.05, Color( 255, 0, 0 ), TEXT_ALIGN_RIGHT, TEXT_ALIGN_TOP )			
			end
			if wOS[ wOS.CurrentInventoryTable ][ WOSTYPE.IDLE ] == data.Name then
				pan:Rect( x, offset, bw, bh, Color( 0, 0, 0, 0 ), Color( 0, 128, 255 ) )				
			else
				local _jp, _pr, _hov = pan:Button("", "wOS.CraftDescriptions", x, offset, bw, bh )
				if _jp then
					surface.PlaySound( "buttons/button9.wav" )
					wOS[ wOS.CurrentInventoryTable ][ WOSTYPE.IDLE ] = data.Name
					net.Start( "wOS.Crafting.PreviewChange" )
						net.WriteBool( wOS.UsingDualLightsaber )
						net.WriteTable( wOS[ wOS.CurrentInventoryTable ] )
					net.SendToServer()
				elseif _hov then
					wOS:CheckButtonHover( pan, i + 30 )
				end
			end
			offset = offset + bh + 0.25
		end
		if #pan.SortedList > 3  then
			offset = offset - 0.25
			pan:Mat( downButton, x*1.1 - hh/2, offset - bh/2, hh/2, hh/2 )
			local _jp, _pr, _hov = pan:Button("", "wOS.CraftDescriptions", x*1.1 - hh/2, offset - bh/2, hh/2, hh/2 )
			if _jp then
				if pan.ScrollMax < #pan.SortedList then
					surface.PlaySound( "buttons/lightswitch2.wav" )
					pan.ScrollMin = pan.ScrollMin + 1
					pan.ScrollMax = pan.ScrollMax + 1
				end
			elseif _hov then
				wOS:CheckButtonHover( pan, 0.1 )
			end
		end
	end
	bladecat2:SetUIScale( 100 )
	bladecat2.Scaling = 0.004
	bladecat2.CamPos = apos - aang*3
	bladecat2.CamAng = sang:Angle() + Angle( 0, -90, 0 )
	
	table.insert( wOS.CraftingButtons, bladecat2 )	
	
	local backbutt = tduiw.Create()
	backbutt.SizeX = 8
	backbutt.SizeY = 2
	backbutt.ShouldAcceptInputs = true
	backbutt.Renders = function( pan )
		local ww, hh = pan.SizeX, pan.SizeY
		pan:Rect( -11 - ww/2, 3, ww, hh, Color( 25, 25, 25, 245 ), color_unselected )
		local _jp, _pr, _hov = pan:Button( "Back", "wOS.CraftTitles", -11 - ww/2, 3, ww, hh )
	    if _jp then
			surface.PlaySound( "buttons/combine_button2.wav" )
	       	wOS.CraftingFocus = "Overview"
			wOS:RebuildCraftingMenus() 
	    elseif _hov then
			wOS:CheckButtonHover( pan, 0 )
		end
		pan:BlockUseBind()
	end
	backbutt:SetUIScale( 100 )
	backbutt.Scaling = 0.005	
	backbutt.CamPos = apos - aang*3
	backbutt.CamAng = sang:Angle() + Angle( 0, -90, 0 )
	
	table.insert( wOS.CraftingButtons, backbutt )		
	
end

wOS.CraftMenuLibrary[ language.GetPhrase( "wos_info_swingsound" ) ] = function()
	local spos, sang = wOS:FindBladePosAng( nil, false, wOS.CraftingMenu.Saber )
	local cpos = wOS.CraftingCamera[ wOS.CraftingFocus ].origin
	local cang = wOS.CraftingCamera[ wOS.CraftingFocus ].angles
	local apos, aang = wOS:FindHandPosAng( wOS.CraftingMenu.Saber )	
	
	local sorted_list = {}
	sorted_list[1] = wOS[ wOS.CurrentInventoryTable ][ WOSTYPE.VORTEX ]
	if sorted_list[1] != "Standard" then
		sorted_list[2] = "Standard"
	elseif wOS.CraftingMenu.OriginalItems[ WOSTYPE.VORTEX ] != "Standard" then
		sorted_list[2] = wOS.CraftingMenu.OriginalItems[ WOSTYPE.VORTEX ]
	end
	
	for name, data in pairs( wOS.SortedItemList[ WOSTYPE.VORTEX ] ) do
		if wOS:GetSaberItemInInventory( wOS.SaberInventory, name ) then
			if !table.HasValue( sorted_list, name ) then
				sorted_list[ #sorted_list + 1 ] = name
			end
		end
	end
	
	local bladecat2 = tduiw.Create()
	bladecat2.SizeX = 10
	bladecat2.SizeY = 2.5
	bladecat2.ShouldAcceptInputs = true
	bladecat2.ScrollMin = 1
	bladecat2.ScrollMax = 3
	bladecat2.SortedList = table.Copy( sorted_list )
	bladecat2.Renders = function( pan )
		local ww, hh = pan.SizeX, pan.SizeY
		local x = 0
		local offset = -11
		local bw, bh = ww, hh*0.5
		if #pan.SortedList > 3 then
			pan:Mat( upButton, x - 0.5 - hh/2, offset - bh/2, hh/2, hh/2 )
			local _jp, _pr, _hov = pan:Button("", "wOS.CraftDescriptions", x - 0.5 - hh/2, offset - bh/2, hh/2, hh/2 )
			if _jp then
				if pan.ScrollMin > 1 then
					surface.PlaySound( "buttons/lightswitch2.wav" )
					pan.ScrollMin = pan.ScrollMin - 1
					pan.ScrollMax = pan.ScrollMax - 1
				end
			elseif _hov then
				wOS:CheckButtonHover( pan, 0 )
			end
				
			pan:Mat( bufferBar, x - 0.5 - hh/2, offset + bh/2 + bh/6, hh/2, 2*bh )
			pan:Rect( x - 0.5 - hh/2, offset + bh/2 + bh/6, hh/2, 2*bh, Color( 0, 0, 0, 0 ), color_white )					
		end
		
		
		for i = pan.ScrollMin, pan.ScrollMax do
			local data = wOS.SortedItemList[ WOSTYPE.VORTEX ][ pan.SortedList[ i ] ]
			if not data then continue end
			pan:Rect( x, offset, bw, bh, Color( 25, 25, 25, 245 ), color_white )
			local col = color_white
			pan:Text( data.Name, "wOS.CraftDescriptions", x + bw*0.01, offset + bh*0.05, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP )
			pan:Text( data.Description, "wOS.CraftMinors", x + bw*0.01, offset + bh*0.62, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP )
			if data.BurnOnUse then
				pan:Text( "BURNED ON USE", "wOS.CraftMinors", x + bw*0.98, offset + bh*0.05, Color( 255, 0, 0 ), TEXT_ALIGN_RIGHT, TEXT_ALIGN_TOP )			
			end
			if wOS[ wOS.CurrentInventoryTable ][ WOSTYPE.VORTEX ] == data.Name then
				pan:Rect( x, offset, bw, bh, Color( 0, 0, 0, 0 ), Color( 0, 128, 255 ) )				
			else
				local _jp, _pr, _hov = pan:Button("", "wOS.CraftDescriptions", x, offset, bw, bh )
				if _jp then
					surface.PlaySound( "buttons/button9.wav" )
					wOS[ wOS.CurrentInventoryTable ][ WOSTYPE.VORTEX ] = data.Name
					net.Start( "wOS.Crafting.PreviewChange" )
						net.WriteBool( wOS.UsingDualLightsaber )
						net.WriteTable( wOS[ wOS.CurrentInventoryTable ] )
					net.SendToServer()
				elseif _hov then
					wOS:CheckButtonHover( pan, i + 30 )
				end
			end
			offset = offset + bh + 0.25
		end
		if #pan.SortedList > 3  then
			offset = offset - 0.25
			pan:Mat( downButton, x - 0.5 - hh/2, offset - bh/2, hh/2, hh/2 )
			local _jp, _pr, _hov = pan:Button("", "wOS.CraftDescriptions", x - 0.5 - hh/2, offset - bh/2, hh/2, hh/2 )
			if _jp then
				if pan.ScrollMax < #pan.SortedList then
					surface.PlaySound( "buttons/lightswitch2.wav" )
					pan.ScrollMin = pan.ScrollMin + 1
					pan.ScrollMax = pan.ScrollMax + 1
				end
			elseif _hov then
				wOS:CheckButtonHover( pan, 0.1 )
			end
		end
	end
	bladecat2:SetUIScale( 100 )
	bladecat2.Scaling = 0.003
	bladecat2.CamPos = apos - aang*3
	bladecat2.CamAng = sang:Angle() + Angle( 0, -90, 0 )
	
	table.insert( wOS.CraftingButtons, bladecat2 )	
	
	local backbutt = tduiw.Create()
	backbutt.SizeX = 8
	backbutt.SizeY = 2
	backbutt.ShouldAcceptInputs = true
	backbutt.Renders = function( pan )
		local ww, hh = pan.SizeX, pan.SizeY
		pan:Rect( -5 - ww/2, 3, ww, hh, Color( 25, 25, 25, 245 ), color_unselected )
		local _jp, _pr, _hov = pan:Button( "Back", "wOS.CraftTitles", -5 - ww/2, 3, ww, hh )
	    if _jp then
			surface.PlaySound( "buttons/combine_button2.wav" )
	       	wOS.CraftingFocus = "Overview"
			wOS:RebuildCraftingMenus() 
	    elseif _hov then
			wOS:CheckButtonHover( pan, 0 )
		end
		pan:BlockUseBind()
	end
	backbutt:SetUIScale( 100 )
	backbutt.Scaling = 0.005	
	backbutt.CamPos = apos - aang*3
	backbutt.CamAng = sang:Angle() + Angle( 0, -90, 0 )
	
	table.insert( wOS.CraftingButtons, backbutt )		
	
end

local blueprint_selected = false
local craftbox = Material( "wos/crafting/craft.png", "unlitgeneric" )
local smeltbox = Material( "wos/crafting/recycle.png", "unlitgeneric" )

wOS.CraftMenuLibrary[ language.GetPhrase( "wos_info_constructor" ) ] = function()

	local cpos = wOS.CraftingCamera[ wOS.CraftingFocus ].origin
	local cang = wOS.CraftingCamera[ wOS.CraftingFocus ].angles
	
	local backbutt = tduiw.Create()
	backbutt.SizeX = 8
	backbutt.SizeY = 2
	backbutt.ScrollMin = 1
	backbutt.ScrollMax = 6
	backbutt.SortedList = table.Copy( sorted_list )
	backbutt.ShouldAcceptInputs = true
	backbutt.Renders = function( pan )
		local ww, hh = pan.SizeX, pan.SizeY
		local offset = -11
		local offsety = 0
		local bw, bh = ww*1.3, hh*7
		local x = offset - bw/2
		
		local image = craftbox
		pan:Rect( -3 - ww*1.5, 0, ww*2, bh, Color( 25, 25, 25, 245 ), color_unselected )
		pan:Mat( image, -3 - ww*1.5, 0, ww*2, bh )
		pan:Text( language.GetPhrase( "wos_info_forgem" ), "wOS.CraftTitles", -3 - ww*0.5, bh*1.05, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP )
		local _jp, _pr, _hov = pan:Button( "", "wOS.CraftTitles", -3 - ww*1.5, 0, ww*2, bh )
	    if _jp then
			surface.PlaySound( "buttons/button9.wav" )
	       	wOS.CraftingFocus = language.GetPhrase( "wos_info_forgem" )
			wOS:RebuildCraftingMenus()
	    elseif _hov then
			wOS:CheckButtonHover( pan, 0 )
		end
		
		local image = smeltbox
		pan:Rect( 5 + ww, 0, ww*2, bh, Color( 25, 25, 25, 245 ), color_unselected )
		pan:Mat( image, 5 + ww, 0, ww*2, bh )
		pan:Text( language.GetPhrase( "wos_info_smeltm" ), "wOS.CraftTitles", 5 + 2*ww, bh*1.05, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP )
		local _jp, _pr, _hov = pan:Button( "", "wOS.CraftTitles", 5 + ww, 0, ww*2, bh )
	    if _jp then
			surface.PlaySound( "buttons/button9.wav" )
	       	wOS.CraftingFocus = language.GetPhrase( "wos_info_smeltm" )
			wOS:RebuildCraftingMenus()
	    elseif _hov then
			wOS:CheckButtonHover( pan, 1 )
		end
		
		pan:Rect( 3, 17, ww, hh, Color( 25, 25, 25, 245 ), color_unselected )
		local _jp, _pr, _hov = pan:Button( "Back", "wOS.CraftTitles", 3, 17, ww, hh )
	    if _jp then
			surface.PlaySound( "buttons/combine_button2.wav" )
	       	wOS.CraftingFocus = "Overview"
			wOS:RebuildCraftingMenus()
	    elseif _hov then
			wOS:CheckButtonHover( pan, 0.2 )
		end

	end
	backbutt:SetUIScale( 100 )
	backbutt.Scaling = 0.01	
	backbutt.CamPos = cpos + Vector( 20, 20, 0 )
	backbutt.CamAng = cang
	table.insert( wOS.CraftingButtons, backbutt )

	wOS.CraftingCamera[ language.GetPhrase( "wos_info_forgem" ) ] = { origin = centerpoint - Vector( 100, 30, -15 ), angles = Angle( 20.840, -60.501, 0.000 )  }
	wOS.CraftingCamera[ language.GetPhrase( "wos_info_smeltm" ) ] = { origin = centerpoint - Vector( 100, 30, -15 ), angles = Angle( 20.840, -60.501, 0.000 )  }
	
	
end

wOS.CraftMenuLibrary[ language.GetPhrase( "wos_info_forgem" ) ] = function()

	
	local cang = wOS.CraftingCamera[ wOS.CraftingFocus ].angles
	local cpos = wOS.CraftingCamera[ wOS.CraftingFocus ].origin + cang:Forward()*25
	
	blueprint_selected = false
	local sorted_list = {}
	for name, data in pairs( wOS.SortedItemList[ WOSTYPE.BLUEPRINT ] ) do
		if wOS:GetSaberItemInInventory( wOS.SaberInventory, name ) then
			if !table.HasValue( sorted_list, name ) then
				sorted_list[ #sorted_list + 1 ] = name
			end
		end
	end
	if IsValid( wOS.blueprint_item ) then wOS.blueprint_item:Remove() end
	wOS.blueprint_floor = ClientsideModel( "models/gangwars/crafting/blup.mdl", RENDERGROUP_BOTH )
	wOS.blueprint_floor:SetPos( cpos + cang:Forward()*40 - cang:Up()*7 )
	
	wOS.blueprint_item = ClientsideModel( "models/heat/heat.mdl", RENDERGROUP_BOTH )
	wOS.blueprint_item:SetPos( wOS.blueprint_floor:GetPos() + Vector( 0, 0, 10 ) )
	wOS.blueprint_item:SetMaterial( "models/wireframe" )
	wOS.blueprint_item.Think = function( model )
		local ang = model:GetAngles()
		ang:RotateAroundAxis( ang:Up(), 0.1 )
		model:SetAngles( ang )
	end
	
	local selected = false
	
	local infobutt = tduiw.Create()
	infobutt.SizeX = 18
	infobutt.SizeY = 20
	infobutt.ShouldAcceptInputs = true
	infobutt.Renders = function( pan )
		if not blueprint_selected then return end
		local ww, hh = pan.SizeX, pan.SizeY
		local offset = -13
		local offsety = hh*0.035
		local bw, bh = ww*1.3, hh
		local x = 0
		pan:Rect( offset - ww/2, 0, ww, hh*0.84, Color( 25, 25, 25, 245 ), color_white )
		
		pan:Text( "Requirements", "wOS.CraftTitles", offset, offsety - hh*0.01, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP )	
		pan:Line( offset - ww/2, offsety + hh*0.07, offset + ww/2, offsety + hh*0.07 )
		offsety = offsety + hh*0.08
		for material, amount in pairs( blueprint_selected.Ingredients ) do
			pan:Text( material .. ": " .. amount, "wOS.CraftTitles", offset - ww*0.48, offsety, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP )	
			offsety = offsety + hh*0.08			
		end
		if blueprint_selected.Result then
			pan:Text( "Result: " .. blueprint_selected.Result, "wOS.CraftTitles", offset - ww*0.48, hh*0.76, Color( 0, 128, 255 ), TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP )
		end
		
		pan:Rect( offset - ww/2, hh*0.85, ww, hh*0.15, Color( 25, 25, 25, 245 ), color_unselected )
		local _jp, _pr, _hov = pan:Button( "Craft Blueprint", "wOS.CraftTitles", offset - ww/2, hh*0.85, ww, hh*0.15 )
	    if _jp then
			net.Start( "wOS.Crafting.CraftBlueprint" )
				net.WriteString( blueprint_selected.Name )
			net.SendToServer()
	    elseif _hov then
			wOS:CheckButtonHover( pan, 0 )
		end
		pan:BlockUseBind()
	end
	
	infobutt:SetUIScale( 100 )
	infobutt.Scaling = 0.01	
	infobutt.CamPos = cpos + cang:Up()*13 + cang:Right()*31 + cang:Forward()*10
	infobutt.CamAng = cang
	infobutt.OriginalAng = infobutt.CamAng
	table.insert( wOS.CraftingButtons, infobutt )	
	
	local backbutt = tduiw.Create()
	backbutt.SizeX = 8
	backbutt.SizeY = 2
	backbutt.ScrollMin = 1
	backbutt.ScrollMax = 6
	backbutt.SortedList = table.Copy( sorted_list )
	backbutt.ShouldAcceptInputs = true
	backbutt.Renders = function( pan )
		local ww, hh = pan.SizeX, pan.SizeY
		local offset = -11
		local offsety = 0
		local bw, bh = ww*1.3, hh
		local x = offset - bw/2		
		if #pan.SortedList > 0 then
			if #pan.SortedList > 6 then
				pan:Mat( upButton, offset + bw*0.6, 3, bh, bh )
				local _jp, _pr, _hov = pan:Button("", "wOS.CraftDescriptions", offset + bw*0.6, 3, bh, bh )
				if _jp then
					if pan.ScrollMin > 1 then
						surface.PlaySound( "buttons/lightswitch2.wav" )
						pan.ScrollMin = pan.ScrollMin - 1
						pan.ScrollMax = pan.ScrollMax - 1
					end
				elseif _hov then
					wOS:CheckButtonHover( pan, 0 )
				end
					
				pan:Mat( bufferBar, offset + bw*0.6, 3 + bh*1.2, bh, 2*bh )
				pan:Rect( offset + bw*0.6, 3 + bh*1.2, bh, 2*bh, Color( 0, 0, 0, 0 ), color_white )		

				pan:Mat( downButton, offset + bw*0.6, 3 + bh*1.4 + 2*bh, bh, bh )
				local _jp2, _pr2, _hov2 = pan:Button("", "wOS.CraftDescriptions", offset + bw*0.6, 3 + bh*1.4 + 2*bh, bh, bh )
				if _jp2 then
					if pan.ScrollMax < #pan.SortedList then
						surface.PlaySound( "buttons/lightswitch2.wav" )
						pan.ScrollMin = pan.ScrollMin + 1
						pan.ScrollMax = pan.ScrollMax + 1
					end
				elseif _hov2 then
					wOS:CheckButtonHover( pan, 0.1 )
				end	
			end
			for i = pan.ScrollMin, pan.ScrollMax do
				local data = wOS.SortedItemList[ WOSTYPE.BLUEPRINT ][ pan.SortedList[ i ] ]
				if not data then continue end
				pan:Rect( x, offsety, bw, bh, Color( 25, 25, 25, 245 ), color_white )
				local col = color_white
				pan:Text( data.Name, "wOS.CraftDescriptions", x + bw*0.01, offsety + bh*0.05, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP )
				pan:Text( data.Description, "wOS.CraftMinors", x + bw*0.01, offsety + bh*0.62, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP )
				if data.BurnOnUse then
					pan:Text( "BURNED ON USE", "wOS.CraftMinors", x + bw*0.98, offsety + bh*0.05, Color( 255, 0, 0 ), TEXT_ALIGN_RIGHT, TEXT_ALIGN_TOP )			
				end
				local _jp, _pr, _hov = pan:Button("", "wOS.CraftDescriptions", x, offsety, bw, bh )
				if _jp then
					surface.PlaySound( "buttons/button9.wav" )
					blueprint_selected = wOS.SortedItemList[ WOSTYPE.BLUEPRINT ][ pan.SortedList[ i ] ]
					local item = blueprint_selected.Result
					if item then
						item = wOS.ItemList[ item ]
						if item then
							if item.Model then
								wOS.blueprint_item:SetModel( item.Model )
							end
						end
					end
				elseif _hov then
					wOS:CheckButtonHover( pan, i + 30 )
				end
				offsety = offsety + bh + 0.25
			end			
		else
			pan:Rect( x - bw*0.25, offsety, bw*1.5, bh*7, Color( 0, 0, 0, 0 ), color_white )
			pan:Text( "NO BLUEPRINTS AVAILABLE", "wOS.CraftTitles", x + bw*0.5, offsety + bh*3.5, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )	
		end
		
		pan:Rect( offset - ww/2, 15, ww, hh, Color( 25, 25, 25, 245 ), color_unselected )
		local _jp, _pr, _hov = pan:Button( "Back", "wOS.CraftTitles", offset - ww/2, 15, ww, hh )
	    if _jp then
			surface.PlaySound( "buttons/combine_button2.wav" )
			wOS.blueprint_floor:Remove()
			wOS.blueprint_item:Remove()
			wOS.blueprint_floor = nil
			wOS.blueprint_item = nil
	       	wOS.CraftingFocus = language.GetPhrase( "wos_info_constructor" )
			wOS:RebuildCraftingMenus() 
	    elseif _hov then
			wOS:CheckButtonHover( pan, 0.2 )
		end
		pan:BlockUseBind()
		
	end
	backbutt:SetUIScale( 100 )
	backbutt.Scaling = 0.01	
	backbutt.CamPos = cpos + cang:Up()*10 - cang:Right()*4
	backbutt.CamAng = cang
	table.insert( wOS.CraftingButtons, backbutt )		
	
end

wOS.CraftMenuLibrary[ language.GetPhrase( "wos_info_smeltm" ) ] = function()

	
	local cang = wOS.CraftingCamera[ wOS.CraftingFocus ].angles
	local cpos = wOS.CraftingCamera[ wOS.CraftingFocus ].origin + cang:Forward()*25
	
	blueprint_selected = false
	local sorted_list = {}
	for slot, data in pairs( wOS.SaberInventory ) do
		local name = data
		local amount = 1
		if istable( data ) then
			name = data.Name
			amount = data.Amount or 1
		end
		if name == "Empty" then continue end
		local dat = wOS.ItemList[ name ]
		if not dat then continue end
		if not dat.DismantleParts then continue end
		sorted_list[ #sorted_list + 1 ] = name
	end
	
	if IsValid( wOS.blueprint_item ) then wOS.blueprint_item:Remove() end
	wOS.blueprint_floor = ClientsideModel( "models/props_lab/tpplugholder_single.mdl", RENDERGROUP_BOTH )
	wOS.blueprint_floor:SetPos( cpos + cang:Forward()*60 - cang:Up()*7 )
	wOS.blueprint_floor:SetAngles( Angle( -90, 0, 0 ) )
	
	wOS.blueprint_item = ClientsideModel( "models/props_phx/gears/bevel9.mdl", RENDERGROUP_BOTH )
	wOS.blueprint_item:SetPos( wOS.blueprint_floor:GetPos() + Vector( 0, 0, 1 ) - cang:Forward()*18 + cang:Right()*2 )
	wOS.blueprint_item.Think = function( model )
		local ang = model:GetAngles()
		ang:RotateAroundAxis( ang:Up(), 0.1 )
		model:SetAngles( ang )
	end
	
	wOS.blueprint_smelter = ClientsideModel( "wos_blank_model.mdl", RENDERGROUP_BOTH )
	wOS.blueprint_smelter:SetPos( wOS.blueprint_floor:GetPos() + Vector( 0, 0, 10 ) - cang:Forward()*18 + cang:Right()*2 )
	wOS.blueprint_smelter.Reset = function( model )
		model:SetModel( "wos_blank_model.mdl" )
	end
	wOS.blueprint_smelter.Think = function( model )
		if model:GetModel() == "wos_blank_model.mdl" then 
			model:SetNoDraw( true )
		else
			model:SetNoDraw( false )
		end
		local ang = model:GetAngles()
		ang:RotateAroundAxis( ang:Up(), -0.1 )
		model:SetAngles( ang )
	end
	
	local selected = false
	
	local infobutt = tduiw.Create()
	infobutt.SizeX = 18
	infobutt.SizeY = 20
	infobutt.ShouldAcceptInputs = true
	infobutt.Renders = function( pan )
		if not blueprint_selected then return end
		local ww, hh = pan.SizeX, pan.SizeY
		local offset = -13
		local offsety = hh*0.035
		local bw, bh = ww*1.3, hh
		local x = 0
		pan:Rect( offset - ww/2, 0, ww, hh*0.84, Color( 25, 25, 25, 245 ), color_white )
		
		pan:Text( "Salvaged Components", "wOS.CraftTitles", offset, offsety - hh*0.01, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP )	
		pan:Line( offset - ww/2, offsety + hh*0.07, offset + ww/2, offsety + hh*0.07 )
		offsety = offsety + hh*0.08
		for material, amount in pairs( blueprint_selected.DismantleParts ) do
			pan:Text( material .. ": " .. amount, "wOS.CraftTitles", offset - ww*0.48, offsety, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP )	
			offsety = offsety + hh*0.08			
		end
		
		pan:Rect( offset - ww/2, hh*0.85, ww, hh*0.15, Color( 25, 25, 25, 245 ), color_unselected )
		local _jp, _pr, _hov = pan:Button( "Smelt Item", "wOS.CraftTitles", offset - ww/2, hh*0.85, ww, hh*0.15 )
	    if _jp then
			net.Start( "wOS.Crafting.SmeltItem" )
				net.WriteString( blueprint_selected.Name )
			net.SendToServer()
	    elseif _hov then
			wOS:CheckButtonHover( pan, 0 )
		end
		pan:BlockUseBind()
	end
	
	infobutt:SetUIScale( 100 )
	infobutt.Scaling = 0.01	
	infobutt.CamPos = cpos + cang:Up()*13 + cang:Right()*31 + cang:Forward()*10
	infobutt.CamAng = cang
	infobutt.OriginalAng = infobutt.CamAng
	table.insert( wOS.CraftingButtons, infobutt )	
	
	local backbutt = tduiw.Create()
	backbutt.SizeX = 8
	backbutt.SizeY = 2
	backbutt.ScrollMin = 1
	backbutt.ScrollMax = 6
	backbutt.SortedList = table.Copy( sorted_list )
	backbutt.ShouldAcceptInputs = true
	backbutt.Renders = function( pan )
		local ww, hh = pan.SizeX, pan.SizeY
		local offset = -11
		local offsety = 0
		local bw, bh = ww*1.3, hh
		local x = offset - bw/2		
		if #pan.SortedList > 0 then
			if #pan.SortedList > 6 then
				pan:Mat( upButton, offset + bw*0.6, 3, bh, bh )
				local _jp, _pr, _hov = pan:Button("", "wOS.CraftDescriptions", offset + bw*0.6, 3, bh, bh )
				if _jp then
					if pan.ScrollMin > 1 then
						surface.PlaySound( "buttons/lightswitch2.wav" )
						pan.ScrollMin = pan.ScrollMin - 1
						pan.ScrollMax = pan.ScrollMax - 1
					end
				elseif _hov then
					wOS:CheckButtonHover( pan, 0 )
				end
					
				pan:Mat( bufferBar, offset + bw*0.6, 3 + bh*1.2, bh, 2*bh )
				pan:Rect( offset + bw*0.6, 3 + bh*1.2, bh, 2*bh, Color( 0, 0, 0, 0 ), color_white )		

				pan:Mat( downButton, offset + bw*0.6, 3 + bh*1.4 + 2*bh, bh, bh )
				local _jp2, _pr2, _hov2 = pan:Button("", "wOS.CraftDescriptions", offset + bw*0.6, 3 + bh*1.4 + 2*bh, bh, bh )
				if _jp2 then
					if pan.ScrollMax < #pan.SortedList then
						surface.PlaySound( "buttons/lightswitch2.wav" )
						pan.ScrollMin = pan.ScrollMin + 1
						pan.ScrollMax = pan.ScrollMax + 1
					end
				elseif _hov2 then
					wOS:CheckButtonHover( pan, 0.1 )
				end		
			end
			for i = pan.ScrollMin, pan.ScrollMax do
				local data = wOS.ItemList[ pan.SortedList[ i ] ]
				if not data then continue end
				pan:Rect( x, offsety, bw, bh, Color( 25, 25, 25, 245 ), color_white )
				local col = color_white
				pan:Text( data.Name, "wOS.CraftDescriptions", x + bw*0.01, offsety + bh*0.05, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP )
				pan:Text( data.Description, "wOS.CraftMinors", x + bw*0.01, offsety + bh*0.62, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP )
				local _jp, _pr, _hov = pan:Button("", "wOS.CraftDescriptions", x, offsety, bw, bh )
				if _jp then
					surface.PlaySound( "buttons/button9.wav" )
					blueprint_selected = wOS.ItemList[ pan.SortedList[ i ] ]
					if blueprint_selected.Model then
						wOS.blueprint_smelter:SetModel( blueprint_selected.Model )
					else
						wOS.blueprint_smelter:Reset()
					end
				elseif _hov then
					wOS:CheckButtonHover( pan, i + 30 )
				end
				offsety = offsety + bh + 0.25
			end			
		else
			pan:Rect( x - bw*0.25, offsety, bw*1.5, bh*7, Color( 0, 0, 0, 0 ), color_white )
			pan:Text( "NO ITEMS AVAILABLE", "wOS.CraftTitles", x + bw*0.5, offsety + bh*3.5, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )	
		end
		
		pan:Rect( offset - ww/2, 15, ww, hh, Color( 25, 25, 25, 245 ), color_unselected )
		local _jp, _pr, _hov = pan:Button( "Back", "wOS.CraftTitles", offset - ww/2, 15, ww, hh )
	    if _jp then
			surface.PlaySound( "buttons/combine_button2.wav" )
			wOS.blueprint_floor:Remove()
			wOS.blueprint_item:Remove()
			wOS.blueprint_smelter:Remove()
			wOS.blueprint_floor = nil
			wOS.blueprint_item = nil
			wOS.blueprint_smelter = nil
	       	wOS.CraftingFocus = language.GetPhrase( "wos_info_constructor" )
			wOS:RebuildCraftingMenus() 
	    elseif _hov then
			wOS:CheckButtonHover( pan, 0.2 )
		end
		pan:BlockUseBind()
		
	end
	backbutt:SetUIScale( 100 )
	backbutt.Scaling = 0.01	
	backbutt.CamPos = cpos + cang:Up()*10 - cang:Right()*4
	backbutt.CamAng = cang
	table.insert( wOS.CraftingButtons, backbutt )		
	
end


local slot_selected = false
local DefaultEmpty = {
	Name = "Empty",
	Description = "No mod on this slot",
}
wOS.CraftMenuLibrary[ language.GetPhrase( "wos_info_miscitem" ) ] = function()

	local cpos = wOS.CraftingCamera[ wOS.CraftingFocus ].origin
	local cang = wOS.CraftingCamera[ wOS.CraftingFocus ].angles
	
	slot_selected = false
	local sorted_list = {}
	sorted_list[1] = "Empty"
	for name, data in pairs( wOS.SortedItemList[ WOSTYPE.MISC1 ] ) do
		if wOS:GetSaberItemInInventory( wOS.SaberInventory, name ) then
			if !table.HasValue( sorted_list, name ) then
				sorted_list[ #sorted_list + 1 ] = name
			end
		end
	end
	
	for name, data in pairs( wOS.SortedItemList[ WOSTYPE.MISC2 ] ) do
		if wOS:GetSaberItemInInventory( wOS.SaberInventory, name ) then
			if !table.HasValue( sorted_list, name ) then
				sorted_list[ #sorted_list + 1 ] = name
			end
		end
	end
	
	wOS.blueprint_item = ClientsideModel( "models/heat/heat.mdl", RENDERGROUP_BOTH )
	wOS.blueprint_item:SetPos( cpos + Vector( 40, 25, -20 ) )
	wOS.blueprint_item.Think = function( model )
		local ang = model:GetAngles()
		ang:RotateAroundAxis( ang:Up(), 0.1 )
		model:SetAngles( ang )
	end
	
	local selected = false
	
	local infobutt = tduiw.Create()
	infobutt.SizeX = 8
	infobutt.SizeY = 2
	infobutt.ScrollMin = 1
	infobutt.ScrollMax = 6
	infobutt.SortedList = table.Copy( sorted_list )
	infobutt.ShouldAcceptInputs = true
	infobutt.Renders = function( pan )
		if not slot_selected then return end
		local ww, hh = pan.SizeX, pan.SizeY
		local offset = -11
		local offsety = 0
		local bw, bh = ww*1.3, hh*0.7
		local x = offset - bw/2		
		if #pan.SortedList > 6 then
			pan:Mat( upButton, offset + bw*0.7, 3, bh, bh )
			local _jp, _pr, _hov = pan:Button("", "wOS.CraftDescriptions", offset + bw*0.7, 3, bh, bh )
			if _jp then
				if pan.ScrollMin > 6 then
					surface.PlaySound( "buttons/lightswitch2.wav" )
					pan.ScrollMin = pan.ScrollMin - 1
					pan.ScrollMax = pan.ScrollMax - 1
				end
			elseif _hov then
				wOS:CheckButtonHover( pan, 0 )
			end
				
			pan:Mat( bufferBar, offset + bw*0.7, 3 + bh*1.2, bh, 2*bh )
			pan:Rect( offset + bw*0.7, 3 + bh*1.2, bh, 2*bh, Color( 0, 0, 0, 0 ), color_white )		

			pan:Mat( downButton, offset + bw*0.7, 3 + bh*1.4 + 2*bh, bh, bh )
			local _jp2, _pr2, _hov2 = pan:Button("", "wOS.CraftDescriptions", offset + bw*0.7, 3 + bh*1.4 + 2*bh, bh, bh )
			if _jp2 then
				if pan.ScrollMax < #pan.SortedList then
					surface.PlaySound( "buttons/lightswitch2.wav" )
					pan.ScrollMin = pan.ScrollMin + 1
					pan.ScrollMax = pan.ScrollMax + 1
				end
			elseif _hov2 then
				wOS:CheckButtonHover( pan, 0.1 )
			end	
		end

		for i = pan.ScrollMin, pan.ScrollMax do
			local name = pan.SortedList[ i ]
			if not name then continue end
			local item = wOS.ItemList[ name ]
			if not item then item = DefaultEmpty end
			pan:Rect( x, offsety, bw, bh, Color( 25, 25, 25, 245 ), color_white )
			local col = color_white
			pan:Text( name, "wOS.CraftDescriptions", x + bw*0.01, offsety + bh*0.05, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP )
			pan:Text( item.Description, "wOS.CraftMinors", x + bw*0.01, offsety + bh*0.62, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP )
			if table.KeyFromValue( wOS.SaberMiscSlots, name ) != slot_selected and table.HasValue( wOS.SaberMiscSlots, name ) then
				pan:Rect( x, offsety, bw, bh, Color( 0, 0, 0, 0 ), Color( 255, 0, 0 ) )	
			else
				if wOS.SaberMiscSlots[ slot_selected ] == name then
					pan:Rect( x, offsety, bw, bh, Color( 0, 0, 0, 0 ), Color( 0, 128, 255 ) )	
				else
					local _jp, _pr, _hov = pan:Button("", "wOS.CraftDescriptions", x, offsety, bw, bh )
					if _jp then
						surface.PlaySound( "buttons/button9.wav" )
						if name == "Empty" then wOS.SaberMiscSlots[ slot_selected ] = nil return end
						wOS.SaberMiscSlots[ slot_selected ] = name
						if item.Model then
							wOS.blueprint_item:SetModel( item.Model )
						end
					elseif _hov then
						wOS:CheckButtonHover( pan, i + 30 )
					end
				end
			end
			offsety = offsety + bh + 0.25
		end

		pan:BlockUseBind()
	end
	infobutt:SetUIScale( 100 )
	infobutt.Scaling = 0.01	
	infobutt.CamPos = cpos + cang:Right()*25 + cang:Forward()*25 + cang:Up()*8
	infobutt.CamAng = cang
	table.insert( wOS.CraftingButtons, infobutt )

	local slots = math.floor( LocalPlayer():GetNW2Int( "wOS.ProficiencyLevel", 0 )/wOS.ALCS.Config.Crafting.LevelPerSlot )
	local slotlist = {}
	for i=1, slots do
		slotlist[ i ] = "Slot " .. i
	end
	
	local backbutt = tduiw.Create()
	backbutt.SizeX = 8
	backbutt.SizeY = 2
	backbutt.ScrollMin = 1
	backbutt.ScrollMax = 6
	backbutt.SortedList = table.Copy( slotlist )
	backbutt.ShouldAcceptInputs = true
	backbutt.Renders = function( pan )
		local ww, hh = pan.SizeX, pan.SizeY
		local offset = -11
		local offsety = 0
		local bw, bh = ww*1.3, hh*0.7
		local x = offset - bw/2		
		if #pan.SortedList > 0 then
			if #pan.SortedList > 6 then
				pan:Mat( upButton, offset + bw*0.7, 3, bh, bh )
				local _jp, _pr, _hov = pan:Button("", "wOS.CraftDescriptions", offset + bw*0.7, 3, bh, bh )
				if _jp then
					if pan.ScrollMin > 1 then
						surface.PlaySound( "buttons/lightswitch2.wav" )
						pan.ScrollMin = pan.ScrollMin - 1
						pan.ScrollMax = pan.ScrollMax - 1
					end
				elseif _hov then
					wOS:CheckButtonHover( pan, 0 )
				end
					
				pan:Mat( bufferBar, offset + bw*0.7, 3 + bh*1.2, bh, 2*bh )
				pan:Rect( offset + bw*0.7, 3 + bh*1.2, bh, 2*bh, Color( 0, 0, 0, 0 ), color_white )		

				pan:Mat( downButton, offset + bw*0.7, 3 + bh*1.4 + 2*bh, bh, bh )
				local _jp2, _pr2, _hov2 = pan:Button("", "wOS.CraftDescriptions", offset + bw*0.7, 3 + bh*1.4 + 2*bh, bh, bh )
				if _jp2 then
					if pan.ScrollMax < #pan.SortedList then
						surface.PlaySound( "buttons/lightswitch2.wav" )
						pan.ScrollMin = pan.ScrollMin + 1
						pan.ScrollMax = pan.ScrollMax + 1
					end
				elseif _hov2 then
					wOS:CheckButtonHover( pan, 0.1 )
				end		
			end
			for i = pan.ScrollMin, pan.ScrollMax do
				local data = pan.SortedList[ i ]
				if not data then continue end
				pan:Rect( x, offsety, bw, bh, Color( 25, 25, 25, 245 ), color_white )
				pan:Rect( x, offsety, bw*0.2, bh, Color( 0, 0, 0, 0 ), color_white )
				local col = color_white
				pan:Text( i, "wOS.CraftTitles", x + bw*0.1, offsety + bh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
				if wOS.SaberMiscSlots[ i ] then
					pan:Text( wOS.SaberMiscSlots[ i ], "wOS.CraftDescriptions", x + bw*0.22, offsety + bh*0.5, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
				else
					pan:Text( "Empty", "wOS.CraftDescriptions", x + bw*0.22, offsety + bh*0.5, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
				end
				if slot_selected == i then
					pan:Rect( x, offsety, bw, bh, Color( 0, 0, 0, 0 ), Color( 0, 128, 255 ) )	
				else
					local _jp, _pr, _hov = pan:Button("", "wOS.CraftDescriptions", x, offsety, bw, bh )
					if _jp then
						surface.PlaySound( "buttons/button9.wav" )
						slot_selected = i
						local item = wOS.SaberMiscSlots[i]
						if item then
							item = wOS.ItemList[ item ]
							if item then
								if item.Model then
									wOS.blueprint_item:SetModel( item.Model )
								end
							end
						end
					elseif _hov then
						wOS:CheckButtonHover( pan, i + 30 )
					end
				end
				offsety = offsety + bh + 0.25
			end
		else
			pan:Rect( x - bw*0.27, offsety, bw*1.54, bh*7, Color( 0, 0, 0, 0 ), color_white )
			pan:Text( "PROFICIENCY SLOTS UNAVAILABLE", "wOS.CraftTitles", x + bw*0.5, offsety + bh*3.2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )	
			pan:Text( "UNLOCKED AT PROFICIENCY " .. wOS.ALCS.Config.Crafting.LevelPerSlot, "wOS.CraftTitles", x + bw*0.5, offsety + bh*3.8, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )	
		end
		pan:Rect( offset - ww/2, 15, ww, hh, Color( 25, 25, 25, 245 ), color_unselected )
		local _jp, _pr, _hov = pan:Button( "Back", "wOS.CraftTitles", offset - ww/2, 15, ww, hh )
	    if _jp then
			surface.PlaySound( "buttons/combine_button2.wav" )
			wOS.blueprint_item:Remove()
			wOS.blueprint_item = nil
	       	wOS.CraftingFocus = "Overview"
			wOS:RebuildCraftingMenus() 
	    elseif _hov then
			wOS:CheckButtonHover( pan, 0.2 )
		end
		pan:BlockUseBind()
	end
	backbutt:SetUIScale( 100 )
	backbutt.Scaling = 0.01	
	backbutt.CamPos = cpos - cang:Right()*2 + cang:Forward()*25 + cang:Up()*8
	backbutt.CamAng = cang
	table.insert( wOS.CraftingButtons, backbutt )		
	
end

hook.Add( "Think", "wOS.Crafting.HUDTraces", function()
	--Code taken from Toxsin X. Nice to have this handy again!
	local tr = util.TraceLine( util.GetPlayerTrace( LocalPlayer() ) )
	local item = tr.Entity
	if !IsValid( item ) then lookingat = nil return end
	if item:GetClass() != "wos_item_base" and !item:IsPlayer() then lookingat = nil return end
	local dist = item:GetPos():Distance( LocalPlayer():GetPos() )
	if item:GetClass() == "wos_item_base" then
		if dist < 150 then
			if !lookingat or lookingat.Item:IsPlayer() then
				lookingat = tduiw.Create()
				lookingat.SizeX = 16
				lookingat.SizeY = 2
				lookingat.ShouldAcceptInputs = true
				lookingat.Renders = function( pan )
					if not IsValid( pan.Item ) then pan = nil return end
					local ww, hh = pan.SizeX, pan.SizeY
					pan:Line( 0, 0, 1, -2.5 )
					pan:Line( 1, -2.5, 3, -5 + hh/2 )					
					pan:Rect( 3, -5, ww, hh, Color( 25, 25, 25, 245 ), color_white )
					pan:Rect( 3, -5, hh, hh, Color( 0, 0, 0, 0 ), color_white )		
					local typ = pan.Item:GetItemType()
					if ItemTable[ typ ] then
						local b = hh*0.9
						pan:Mat( ItemTable[ typ ], 3 + ( hh - b )*0.5, -5 + ( hh - b )*0.5, b, b ) 
					end
					local title_text = pan.Item:GetItemName()
					if typ == WOSTYPE.RAWMATERIAL then
						local amt = pan.Item:GetAmount()
						if amt > 1 then
							title_text = title_text .. " ( x" .. amt .. " )"
						end
					end
					pan:Text( title_text, "wOS.ItemTitles", hh + 3 + ww*0.01, -5 + hh*0.2, pan.Item:GetRarityColor(), TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP )
					pan:Text( pan.Item:GetRarityName(), "wOS.ItemTitles", 3 + ww*0.99, -5 + hh*0.5, pan.Item:GetRarityColor(), TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER )
					pan:Text( pan.Item:GetItemDescription(), "wOS.ItemDescriptions", hh + 3 + ww*0.01, -5 + hh*0.5, pan.Item:GetRarityColor(), TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP )				
				end
				lookingat:SetUIScale( 200 )	
			end
			lookingat.Scaling = math.max( dist / 5000, 0.015 )
			lookingat.CamPos = item:GetPos()
			lookingat.CamAng = LocalPlayer():GetAimVector():Angle()
			lookingat.Item = item
		else
			lookingat = nil 
		end
	elseif item:IsPlayer() and wOS.ALCS.Config.Skills.MountLevelToPlayer then
		if dist < 175 then
			if !lookingat then
				lookingat = tduiw.Create()
				lookingat.SizeX = 4
				lookingat.SizeY = 1
				lookingat.ShouldAcceptInputs = true
				lookingat.Renders = function( pan )
					if not IsValid( pan.Item ) then pan = nil return end
					local ww, hh = pan.SizeX, pan.SizeY
					pan:Text( "Combat Level: " .. pan.Item:GetSkillLevel(), "wOS.ItemTitles", 0, 0, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )			
				end
				lookingat:SetUIScale( 200 )	
			end
			lookingat.Scaling = math.max( dist / 2500, 0.03 )
			lookingat.CamPos = item:EyePos() + Vector( 0, 0, 14 )
			lookingat.CamAng = LocalPlayer():GetAimVector():Angle()
			lookingat.Item = item
		else
			lookingat = nil 
		end		
	end
end )

hook.Add( "PreDrawHalos", "wOS.Crafting.ItemClose", function()
	if not lookingat then return end
	local item = lookingat.Item
	if not IsValid( item ) then return end
	if item:IsPlayer() then return end
	halo.Add( { item }, item:GetRarityColor(), 1, 1, 6, true, false )	
end )
--addons/wos-grandmaster-einf/lua/wos/advswl/skills/core/cl_new_core.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2020
	
	Contact: www.wiltostech.com
		----------------------------------------]]--








































































wOS = wOS or {}
wOS.ALCS = wOS.ALCS or {}
wOS.ALCS.Skills = wOS.ALCS.Skills or {}

wOS.ALCS.Skills.MagiCOSTime = os.time()

local w,h = ScrW(), ScrH()
local wallMat = Material( "wos/debug/debugblack", "unlitgeneric" )
local upButton = Material( "wos/crafting/gui/up.png", "unlitgeneric" )
local downButton = Material( "wos/crafting/gui/down.png", "unlitgeneric" )
local bufferBar = Material( "wos/crafting/gui/buffer.png", "unlitgeneric" )
local boxTop = Material( "phoenix_storms/metalset_1-2", "unlitgeneric" )

local centerpoint = wOS.ALCS.Config.Crafting.CraftingCamLocation
local color_unselected = Color( 0, 0, 0, 100 )
local LastCamOrigin = vector_origin
local LastCamAng = Angle( 0, 0, 0 )

function wOS.ALCS.Skills:PrecacheIcon( name, png )

	local mat = Material( png )
	local actualmat = CreateMaterial( name, "unlitgeneric", 
		{
		 ["$model"] = 1,
		}
	)
	actualmat:SetTexture( "$basetexture", mat:GetTexture("$basetexture") )
	return actualmat
	
end

wOS.ALCS.Skills.Camera = wOS.ALCS.Skills.Camera or {}

wOS.ALCS.Skills.SkillRenders = wOS.ALCS.Skills.SkillRenders or {}

wOS.ALCS.Runes = wOS.ALCS.Runes or {}
local letters = { "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z" }
for i=1, #letters do
	wOS.ALCS.Runes[ letters[i] ] = Material( "wos/runes/" .. letters[i] .. ".png", "unlitgeneric" )
end 

function wOS.ALCS.Skills:CreateCubeMat( pos, mat, normal, size, static )

	if not pos then return end
	normal = normal or vector_up
	size = size or 16
	
	local tim = static or ( CurTime() * 50 ) % 360
	
	render.SetMaterial( mat )
	for i = 0, 3 do
		local dir = normal:Angle()
		dir:RotateAroundAxis( normal, tim + i*90 )
		local right = dir:Right()
		render.DrawQuadEasy( pos + normal * size/2 + right*size/2, right, size, size, color_white, 180 )
	end

	render.SetMaterial( boxTop )
	render.DrawQuadEasy( pos, normal*-1, size, size, color_white, tim*-1 )
	render.DrawQuadEasy( pos + normal*size, normal, size, size, color_white, tim )
	
end

function wOS.ALCS.Skills:CreateCubeModel( pos, mat )
	local CubeModel = ClientsideModel( "models/wos/lct/props/woscube.mdl", RENDERGROUP_OPAQUE )
	CubeModel:SetPos( pos )
	local ang = CubeModel:GetAngles()
	ang:RotateAroundAxis( ang:Right(), 180 )
	CubeModel:SetAngles( ang )
	CubeModel:SetColor( Color( 255, 255, 255 ) )
	CubeModel:SetSubMaterial( 0, "!" .. mat )
	CubeModel:SetSubMaterial( 1, "phoenix_storms/metalset_1-2" )
	CubeModel:SetNoDraw( true )
	return CubeModel
end

hook.Add( "PostDrawOpaqueRenderables", "wOS.ALCS.SkillsBox", function()
	if !IsValid( wOS.ALCS.Skills.Menu ) then return end
	if !wOS.ALCS.Skills.Menu:IsVisible() then return end
	if !wOS.ALCS.Skills.Menu.RenderNow and !wOS.ALCS.Skills.Menu.FullScreen then return end
	if !wOS.ALCS.Skills.Menu:IsVisible() then return end

	local pos = Vector( centerpoint ) 
	local angle = Angle(0, 0, 0)
    local scale = 100
    local size = 5
    local center = pos
	render.SetMaterial(wallMat)
	render.DrawQuadEasy(center + Vector(0, 0, size*scale/2), Vector(0, 0, -1), size*scale, size*scale, 0, Color(255, 0, 0), 0)
	render.DrawQuadEasy(center - Vector(0, size*scale/2, 0), Vector(0, 1, 0), size*scale, size*scale, 0, Color(255, 0, 0), 0)
	render.DrawQuadEasy(center - Vector(size*scale/2, 0, 0), Vector(1, 0, 0), size*scale, size*scale, 0, Color(255, 0, 0), 0)
	render.DrawQuadEasy(center - Vector(0, -size*scale/2, 0), Vector(0, -1, 0), size*scale, size*scale, 0, Color(255, 0, 0), 0)
	render.DrawQuadEasy(center - Vector(-size*scale/2, 0, 0), Vector(-1, 0, 0), size*scale, size*scale, 0, Color(255, 0, 0), 0)
	render.DrawQuadEasy(center, Vector(0, 0, 1), size*scale, size*scale, 0, Color(0, 0, 0 ), 0)	
	
end )

hook.Add( "PreDrawTranslucentRenderables", "wOS.ALCS.SkillsRenders", function()

	if not wOS.ALCS.Skills.Menu then return end
	if not wOS.ALCS.Skills.Menu.VGUI then return end
	if !wOS.ALCS.Skills.Menu.RenderNow and !wOS.ALCS.Skills.Menu.FullScreen then return end
	if !wOS.ALCS.Skills.Menu:IsVisible() then return end
	
	if IsValid( wOS.ALCS.Skills.Menu.Player ) then
		wOS.ALCS.Skills.Menu.Player:DrawModel()
	end
	
	if wOS.ALCS.Skills.CubeModels then
		if #wOS.ALCS.Skills.CubeModels > 0 then
			for _, model in ipairs( wOS.ALCS.Skills.CubeModels ) do
				model:DrawModel()
			end
		end
	end
		
end )

hook.Add( "PostDrawTranslucentRenderables", "wOS.ALCS.SkillsRenders", function()

	if not wOS.ALCS.Skills.Menu then return end
	if not wOS.ALCS.Skills.Menu.VGUI then return end
	if !wOS.ALCS.Skills.Menu.RenderNow and !wOS.ALCS.Skills.Menu.FullScreen then return end
	if !wOS.ALCS.Skills.Menu:IsVisible() then return end
	
	render.SuppressEngineLighting( true )
	for _, frame in ipairs( wOS.ALCS.Skills.Menu.VGUI ) do
		frame:Renders()
		frame:Render( frame.CamPos, frame.CamAng, frame.Scaling or 0.1 )
		if frame.PostRenders then
			frame:PostRenders()
		end
	end
	render.SuppressEngineLighting( false )
	
end )

hook.Add( "wOS.ALCS.ShouldDisableCam", "wOS.ALCS.Skills.Prevent3rdPerson", function()
	if !IsValid( wOS.ALCS.Skills.Menu ) then return end
	if !wOS.ALCS.Skills.Menu:IsVisible() then return end
	return true
end )

hook.Add( "CalcView", "wOS.ALCS.Skills.Camera", function( ply, pos, ang )
	if ( !IsValid( ply ) or !ply:Alive() or ply:InVehicle() or ply:GetViewEntity() != ply ) then return end
	if !IsValid( wOS.ALCS.Skills.Menu ) then return end
	if !wOS.ALCS.Skills.Menu.RenderNow and !wOS.ALCS.Skills.Menu.FullScreen then return end
	if !wOS.ALCS.Skills.Menu:IsVisible() then return end
	if wOS.ALCS.Config.CameraAnimationSpeed then
		LastCamOrigin = ( LastCamOrigin == wOS.ALCS.Skills.Camera[ wOS.ALCS.Skills.CamFocus ].origin and wOS.ALCS.Skills.Camera[ wOS.ALCS.Skills.CamFocus ].origin ) or Lerp( FrameTime()*wOS.ALCS.Config.CameraAnimationSpeed, LastCamOrigin, wOS.ALCS.Skills.Camera[ wOS.ALCS.Skills.CamFocus ].origin )
		LastCamAng = ( LastCamAng == wOS.ALCS.Skills.Camera[ wOS.ALCS.Skills.CamFocus ].angles and wOS.ALCS.Skills.Camera[ wOS.ALCS.Skills.CamFocus ].angles ) or Lerp( FrameTime()*wOS.ALCS.Config.CameraAnimationSpeed, LastCamAng, wOS.ALCS.Skills.Camera[ wOS.ALCS.Skills.CamFocus ].angles )
	else
		LastCamOrigin = wOS.ALCS.Skills.Camera[ wOS.ALCS.Skills.CamFocus ].origin
		LastCamAng = wOS.ALCS.Skills.Camera[ wOS.ALCS.Skills.CamFocus ].angles	
	end
	local amod = wOS.ALCS.Skills.Menu.AngleMod
	amod = LastCamAng:Right()*amod.x + LastCamAng:Up()*amod.y
	return  { 
				origin = LastCamOrigin + amod,
				angles = LastCamAng,
				drawviewer = false,
		    }
	
end )

function wOS.ALCS.Skills:CleanAllMenus( button )

	if self.CubeModels then
		for i = 1, #self.CubeModels do
			if self.CubeModels[i] then
				self.CubeModels[i]:Remove()
			end
		end
		self.CubeModels = {}
	end

	if not button then
		if IsValid( self.Menu.Player ) then 
			self.Menu.Player:Remove()
		end
		self.Menu.RenderNow = false
		self.Menu:Remove()
		self.Menu = nil
		if self.SkillInfoPanel then
			self.SkillInfoPanel:Remove()
			self.SkillInfoPanel = nil
		end
		gui.EnableScreenClicker( false )
	end
	
	if not self.Menu then return end
	self.Menu.VGUI = {}
	
end

function wOS.ALCS.Skills:CloseSkillsMenu()
	self:CleanAllMenus()
	gui.EnableScreenClicker( false )
end

hook.Add( "PostRenderVGUI", "wOS.ALCS.Skills.CreateRenderWindow", function()
	if !IsValid( wOS.ALCS.Skills.Menu ) then return end
	if not wOS.ALCS.Skills.Menu:IsVisible() then return end
	wOS.ALCS.Skills.Menu.DrawRender = true
		wOS.ALCS.Skills.Menu:Paint() 
	if not wOS.ALCS.Skills.Menu then return end
	wOS.ALCS.Skills.Menu.DrawRender = false
end )

function wOS.ALCS.Skills:OpenSkillsMenu()

	if self.Menu then 
		wOS.ALCS.Skills:CloseSkillsMenu()
		return
	end
	
	if wOS.InventoryPanel then
		wOS:ViewInventory()
	end
	
	gui.EnableScreenClicker( true )

	self.Menu = vgui.Create( "DFrame" )
	self.Menu:SetDraggable( true )
	self.Menu:ShowCloseButton( false )
	self.Menu:SetTitle( "" )
	self.Menu:SetSize( ScrW()*0.8, ScrH()*0.8 )
	self.Menu:Center()
	self.Menu.SpawnTime = CurTime()
	self.Menu.VGUI = {}
	self.Menu.PosData = { x = -1, y = -1 }
	self.Menu.AngleMod = Vector( 0, 0, 0 )
	self.Menu.SetAngle = function( pan, pit, yaw )
		pan.AngleMod = Vector( pit or 0, yaw or 0, 0 )
	end
	self.Menu.AddAngleYaw = function( pan, pit, max )
		max = max or 0
		pan.AngleMod.x = math.Clamp( pan.AngleMod.x + pit, -0.5*max, 0.5*max )
	end
	self.Menu.AddAnglePitch = function( pan, yaw, max, min )
		pan.AngleMod.y = math.Clamp( pan.AngleMod.y + yaw, min or 0, max or 0 )
	end
	
	local mw, mh = self.Menu:GetSize()
	
	local button = vgui.Create( "DButton", self.Menu )
	button:SetSize( mw*0.015, mh*0.02 )
	button:SetPos( mw*0.985, 0 )
	button:SetText( "" )
	button.DoClick = function()
		self:CleanAllMenus()
	end	
	button.Paint = nil
	
	self.Menu.Paint = function( pan )
		if not pan.DrawRender then return end
		local ww, hh = pan:GetSize()
		local px, py = pan:GetPos()
		pan.PosData.x, pan.PosData.y = pan:CursorPos()
		
		if !pan.ModEnabled then
			pan:SetAngle( 0, 0 )
		end
		
		pan.RenderNow = true	
			draw.RoundedBox( 0, px, py, ww*0.985, hh*0.02, Color( 255, 255, 255, 155 ) )
			draw.RoundedBox( 0, px + ww*0.985, py, ww*0.015, hh*0.02, Color( 255, 0, 0 ) )
			local tbl = hook.Call( "CalcView", GAMEMODE, LocalPlayer() )
			tbl.w = ww
			tbl.h = hh*0.98
			tbl.x = px
			tbl.y = py + hh*0.02
			tbl.fov = 85
			render.RenderView( tbl )
		pan.RenderNow = false
		
		if wOS.ALCS.Skills.SkillInfoPanel then
			wOS.ALCS.Skills.SkillInfoPanel:Paint()
		end
		
	end
	self.Menu.OnMouseWheeled = function( pan, del )
		if not pan.ModEnabled then return end
		if LocalPlayer():KeyDown( IN_SPEED ) then
			pan:AddAngleYaw( del, pan.MaxW )
		else
			pan:AddAnglePitch( del, pan.MaxH, pan.MinH )
		end
	end
	
	self.Menu.Cycle = 0
	self.Menu.LastPaint = CurTime()
	local p_think = self.Menu.Think
	self.Menu.Think = function( pan )
		p_think( pan )
		if not vgui.CursorVisible() then
			gui.EnableScreenClicker( true )
		end
		if not LocalPlayer():Alive() or input.IsKeyDown( KEY_BACKSPACE ) then
			wOS.ALCS.Skills:CloseSkillsMenu()
			return
		end
		if pan.Player then
			pan.Player:FrameAdvance( ( RealTime() - pan.LastPaint ) )
			pan.LastPaint = CurTime()
			if pan.Player:GetCycle() >= 0.99 then
				pan.Player:SetCycle( 0 )
			end
		end

	end
	
	self.SkillInfoPanel = vgui.Create( "DPanel" )
	self.SkillInfoPanel:SetSize( mw*0.26, mh*0.08 )
	self.SkillInfoPanel:SetPos( w, h )
	self.SkillInfoPanel.Data = false
	self.SkillInfoPanel.TimeShow = 0
	self.SkillInfoPanel.Paint = function( pan, ww, hh )	
		if pan.TimeShow < CurTime() then return end
		local ww, hh = pan:GetSize()
		local px, py = pan:GetPos()
		draw.RoundedBox( 3, px, py, ww, hh, Color( 25, 25, 25, 255 ) )
		surface.SetDrawColor( color_white )
		surface.DrawOutlinedRect( px + ww*0.01, py + hh*0.01, ww*0.98, hh*0.98 )
		
		if pan.Data then
			draw.SimpleText( pan.Data.Name, "wOS.TitleFont", px + ww*0.04, py + hh*0.25, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
			draw.SimpleText( pan.Data.Description, "wOS.DescriptionFont", px + ww*0.04, py + hh*0.5, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
			if not pan.Data.Prestige then
				if not wOS:HasSkillEquipped( pan.Data.Tree, pan.Data.Tier, pan.Data.Skill ) then
					if wOS:CanEquipSkill( pan.Data.Tree, pan.Data.Tier, pan.Data.Skill ) then
						draw.SimpleText( "Requires " .. pan.Data.PointsRequired .. " skill point(s)", "wOS.DescriptionFont", px + ww*0.04, py + hh*0.75, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
					else
						draw.SimpleText( "UNAVAILABLE", "wOS.DescriptionFont", px + ww*0.04, py + hh*0.75, Color( 255, 0, 0, 255 ), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
					end
				else
					draw.SimpleText( "EQUIPPED", "wOS.DescriptionFont", px + ww*0.04, py + hh*0.75, Color( 0, 128, 255, 255 ), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )			
				end
			else
				if not wOS.ALCS.Prestige.Data.Mastery[ pan.Data.Mastery ] then
					if wOS.ALCS.Prestige:CanEquipPrestige( pan.Data.Mastery ) then
						draw.SimpleText( "Requires " .. pan.Data.Cost.. " prestige token(s)", "wOS.DescriptionFont", px + ww*0.04, py + hh*0.75, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
					else
						draw.SimpleText( "UNAVAILABLE", "wOS.DescriptionFont", px + ww*0.04, py + hh*0.75, Color( 255, 0, 0, 255 ), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
					end
				else
					draw.SimpleText( "MASTERED", "wOS.DescriptionFont", px + ww*0.04, py + hh*0.75, Color( 0, 128, 255, 255 ), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )			
				end
			end
		end
		
	end
	self.SkillInfoPanel.Think = function( pan )
		pan:SetPos( gui.MouseX() + 15, gui.MouseY() + 15 )
	end

	
	self:BuildPlayerModel()
	LastCamOrigin = self.Menu.Player:GetPos() + Vector( 0, 0, 70 )
	LastCamAng = Angle( -15.840, 30.501, 0.000 )
	
	self:ChangeCamFocus( "Overview" )
	
end

function wOS.ALCS.Skills:BuildPlayerModel()

	if !IsValid( self.Menu ) then return end
	if IsValid( self.Menu.Player ) then 
		self.Menu.Player:Remove()
	end
	self.Menu.Player = ClientsideModel( LocalPlayer():GetModel(), RENDERGROUP_STATIC )
	self.Menu.Player:SetPos( centerpoint - Vector( -30, -25, -1 ) )
	self.Menu.Player:SetSkin( LocalPlayer():GetSkin() )
	self.Menu.Player:SetModelScale( LocalPlayer():GetModelScale() )
	
	local item = wOS.ALCS.Dueling.Spirits[ wOS.ALCS.Dueling.DuelData.DuelSpirit ]

	local anim = "idle_fist"

	if item and item.Sequence then
		local id = self.Menu.Player:LookupSequence(item.Sequence)
		if id != -1 then anim = id end
	end
	self.Menu.Player:SetSequence(anim)
	self.Menu.Player.SpawnTime = CurTime()

	local ang = self.Menu.Player:GetAngles()
	ang:RotateAroundAxis( ang:Up(), -120 )	
	self.Menu.Player:SetAngles( ang )
	self.Menu.Player:SetNoDraw( true )
end

function wOS.ALCS.Skills:ChangeCamFocus( focus )
	self:CleanAllMenus( true )
	self.CamFocus = focus
	self.MenuLibrary[ focus ]()
end

function wOS:HasSkillEquipped( tree, tier, skill )

	if not self.EquippedSkills[ tree ] then return false end
	if not self.EquippedSkills[ tree ][ tier ] then return false end
	
	return self.EquippedSkills[ tree ][ tier ][ skill ]
	
end

function wOS:CanEquipSkill( tree, tier, skill )
	local skilldata = self.SkillTrees[ tree ]
	if not skilldata then return false end
	skilldata = self.SkillTrees[ tree ].Tier[ tier ]
	if not skilldata then return false end
	skilldata = self.SkillTrees[ tree ].Tier[ tier ][ skill ]
	if not skilldata then return false end
	if table.Count( skilldata.Requirements ) < 1 then return true end

	if skilldata.LockOuts then
		if table.Count( skilldata.LockOuts ) > 0 then
			for tierr, sdata in pairs( skilldata.LockOuts ) do
				for _, skilll in pairs( sdata ) do
					if self:HasSkillEquipped( tree, tierr, skilll ) then return false end
				end
			end
		end
	end

	for tierr, sdata in pairs( skilldata.Requirements ) do
		for _, skilll in pairs( sdata ) do
			if not self:HasSkillEquipped( tree, tierr, skilll ) then return false end
		end
	end
	
	return true
	
end

function wOS:HasSkillPoints( tree, tier, skill )

	local skilldata = self.SkillTrees[ name ]
	if not skilldata then return false end
	skilldata = self.SkillTrees[ name ].Tier[ tier ]
	if not skilldata then return false end
	skilldata = self.SkillTrees[ name ].Tier[ tier ][ skill ]
	if not skilldata then return false end

	return LocalPlayer():GetNW2Int( "wOS.SkillPoints", 0 ) >= skilldata.PointsRequired
	
end

if wOS.ALCS.Config.Skills.MountLevelToHUD then

	hook.Add( "HUDPaint", "wOS.SkillTrees.MountHUD", function()
		local level = LocalPlayer():GetNW2Int( "wOS.SkillLevel", 0 )
		local xp = LocalPlayer():GetNW2Int( "wOS.SkillExperience", 0 )
		local reqxp = wOS.ALCS.Config.Skills.XPScaleFormula( level )
		local lastxp = 0
		if level > 0 then
			lastxp = wOS.ALCS.Config.Skills.XPScaleFormula( level - 1 )
		end
		local rat = ( xp - lastxp )/( reqxp - lastxp )
		if level == wOS.ALCS.Config.Skills.SkillMaxLevel then
			rat = 1
		end
		draw.RoundedBox( 3, ( w - w*0.43 )/2, 0, w*0.43, h*0.035, Color( 25, 25, 25, 245 ) )
		surface.SetDrawColor( color_white )
		surface.DrawOutlinedRect( ( w - w*0.33 )/2, h*0.005, w*0.33, h*0.02 )
		surface.DrawRect( (w - w*0.33 )/2, h*0.005, w*0.33*rat, h*0.02 )
		draw.SimpleText( ( level == wOS.ALCS.Config.Skills.SkillMaxLevel and "MAX" ) or lastxp, "wOS.DescriptionFont", ( w - w*0.33 )/2 - w*0.005, h*0.015, color_white, TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER )
		draw.SimpleText( ( level == wOS.ALCS.Config.Skills.SkillMaxLevel and "LEVEL" ) or reqxp, "wOS.DescriptionFont", ( w + w*0.33 )/2 + w*0.005, h*0.015, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )		
		draw.SimpleText( "Level " .. level, "wOS.DescriptionFont", w*0.5, h*0.015, Color( 0, 128, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )		
	end )
	
end
--addons/wos-grandmaster-einf/lua/wos/advswl/skills/core/cl_net.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2020
	
	Contact: www.wiltostech.com
		----------------------------------------]]--








































































wOS = wOS or {}
wOS.SkillTrees = wOS.SkillTrees or {}

local PLAYER = LocalPlayer()

net.Receive( "wOS.SkillTree.SendPlayerData", function()

	local equipped_skills = net.ReadTable()
	local localplayer = net.ReadBool()
	
	if localplayer then
		wOS.EquippedSkills = table.Copy( equipped_skills )
	else
		local ply = net.ReadEntity()
		ply.EquippedSkills = table.Copy( equipped_skills )
	end

end )

net.Receive( "wOS.SkillTree.SendWLData", function()

	local whitelist_trees = net.ReadTable()
	local localplayer = net.ReadBool()
	
	if localplayer then
		wOS.SkillTreeWhitelists = table.Copy( whitelist_trees )
	else
		local ply = net.ReadEntity()
		ply.WOS_SkillTreeWhitelists = table.Copy( whitelist_trees )
	end

end )

wOS.TreeIcons = {}
wOS.TreeIcons[ "Help Menu" ] = { MainIcon = Material( "wos/skilltrees/wiltos.png", "unlitgeneric" ) }

net.Receive( "wOS.SkillTree.SendTrees", function()

	local trees = net.ReadTable()

	for name, data in pairs( trees ) do
		wOS.SkillTrees[ name ] = data
		if not wOS.TreeIcons[ name ] then
			wOS.TreeIcons[ name ] = {}
			wOS.TreeIcons[ name ].MainIcon = wOS.ALCS.Skills:PrecacheIcon( "wos-alcs-treename-" .. name, data.TreeIcon )
			for tier, sdata in pairs( data.Tier ) do
				wOS.TreeIcons[ name ][ tier ] = {}
				for skill, info in pairs( sdata ) do
					if info.DummySkill then continue end
					wOS.TreeIcons[ name ][ tier ][ skill ] = {}
					wOS.TreeIcons[ name ][ tier ][ skill ].Icon = wOS.ALCS.Skills:PrecacheIcon( "wos-alcs-skillname-" .. name .. tier .. skill, info.Icon )
				end
			end
		end
	end

end )

net.Receive( "wOS.SkillTree.RefreshWeapon", function()

	local name = net.ReadString()
	local self = LocalPlayer():GetWeapon( name )
	if not IsValid( self ) then return end
	
	self.ForcePowerList = net.ReadTable()
	self.DevestatorList = net.ReadTable()
	
	self.ForcePowers = {}
	self.AvailablePowers = table.Copy( wOS.AvailablePowers )
	local breakoff = wOS.ALCS.Config.LightsaberHUD == WOS_ALCS.HUD.HYBRID
	for _, force in pairs( self.ForcePowerList ) do
		if not self.AvailablePowers[ force ] then continue end
		self.ForcePowers[ #self.ForcePowers + 1 ] = self.AvailablePowers[ force ]
		if !breakoff then continue end
		if #self.ForcePowers >= wOS.ALCS.Config.MaximumForceSlots then break end
	end
	
	self.Devestators = {}
	self.AvailableDevestators = table.Copy( wOS.AvailableDevestators )
	for _, dev in pairs( self.DevestatorList ) do
		if not self.AvailableDevestators[ dev ] then continue end
		self.Devestators[ #self.Devestators + 1 ] = self.AvailableDevestators[ dev ]
	end

end )

net.Receive( "wOS.SkillTree.RefreshForms", function()

	local name = net.ReadString()
	local self = LocalPlayer():GetWeapon( name )
	if not IsValid( self ) then return end
	
	self.Forms = net.ReadTable()
	self.Stances = net.ReadTable()
	self.UseForms = {}
	for _, form in pairs( self.Forms ) do
		self.UseForms[ form ] = true
	end

end )

net.Receive( "wOS.SkillTree.RefreshDualForms", function()

	local name = net.ReadString()
	local self = LocalPlayer():GetWeapon( name )
	if not IsValid( self ) then return end
	
	self.DualFormList = net.ReadTable()

end )
--addons/wos-alcs-custom/lua/wos/advswl/lightsaber/core/cl_hud.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2022
	
	Contact: www.wiltostech.com
		----------------------------------------]]--

		wOS = wOS or {}
		wOS.ALCS = wOS.ALCS or {}
		wOS.ALCS.LightsaberBase = wOS.ALCS.LightsaberBase or {}

local default_huds = {}
default_huds[1] = function( self )
	local icon = 52 * (ScrW() / 1920)
	local gap = 5 * (ScrW() / 1920)

	local bar = 4
	local bar2 = 16
	local rd = 7

	if ( self.ForceSelectEnabled ) then
		icon = 128 * (ScrW() / 1920)
		bar = 8
		bar2 = 20
		rd = 10
	end

	local ForcePowers = self.ForcePowers
	local w = #ForcePowers * icon + ( #ForcePowers - 1 ) * gap

	if #ForcePowers == 0 then
		w = 1 * icon + ( #ForcePowers - 1 ) * gap
	end

	self.Vars.ForceBar = math.min( self:GetMaxForce(), Lerp( 0.1, self.Vars.ForceBar, math.floor( self:GetForce() ) ) )
	self.Vars.DevBar = math.min( self:GetMaxStamina(), Lerp( 0.1, self.Vars.DevBar, math.floor( self:GetDevEnergy() ) ) )

	local h = bar2
	local x = math.floor( ScrW() / 2 - w / 2 )
	local y = ScrH() - gap - bar2
			
			draw.RoundedBox( rd, x, y, w, h, Color( 0, 0, 0, 128 ) )
			
			local barW = math.ceil( w * ( self.Vars.ForceBar / self:GetMaxForce() ) )
			if ( self:GetForce() <= 1 && barW <= 1 ) then barW = 0 end
			draw.RoundedBox( rd, x, y, barW, h, Color( 0, 128, 255, 255 ) )
			
	local barW2 = math.ceil( w * ( self.Vars.DevBar / 100 ) )
	if ( self:GetDevEnergy() <= 1 && barW2 <= 1 ) then barW2 = 0 end
	surface.SetMaterial( self.Vars.grad )
	surface.SetDrawColor( Color( 225, 0, 225, 175 - 175 * math.abs( math.sin( CurTime() ) ) ) )
	surface.DrawTexturedRect( x, y, barW2, h )
	draw.SimpleText( math.floor( self:GetForce() ) .. "%", "SelectedForceHUD", x + w / 2, y + h / 2, Color( 255, 255, 255 ), 1, 1 )

	if wOS.ALCS.Config.EnableStamina then
		------------------------------------- STAMINA BAR --------------------------------
		local stam = self:GetStamina()
				self.Vars.StaminaBar = (self.Vars.StaminaBar == stam and stam) or Lerp(0.1, self.Vars.StaminaBar, stam )
				x = math.floor( ScrW()/2 - w / 2 )
				y = ScrH() - 2*gap - 2*bar2
		
				draw.RoundedBox( rd, x, y, w, h, Color( 0, 0, 0, 128 ) )
				
				barW = math.ceil( w * ( self.Vars.StaminaBar / self:GetMaxStamina() ) )
				if ( self:GetStamina() <= 1 && barW <= 1 ) then barW = 0 end
				draw.RoundedBox( rd, x, y, barW, h, Color( 155, 155, 155, 255 ) )
		
		draw.SimpleText( "STAMINA: " .. math.floor( self:GetStamina() ) .. "%", "SelectedForceHUD", x + w / 2, y + h / 2, Color( 255, 255, 255 ), 1, 1 )
	end

	if ( #ForcePowers < 1 ) then return end

	local y = y - icon - gap
	local h = icon

			for id, t in pairs( ForcePowers ) do
				local should_cooldown = false
				local image = wOS.ForceIcons[ self.ForcePowers[ id ].name ]
				local x = x + ( id - 1 ) * ( h + gap )
				local x2 = math.floor( x + icon / 2 )
		local ogy = y + 0
		if ( self:GetForceType() == id ) then
			wOS.ALCS:CutCircle( x + h/2, y + h/2, h*0.55 )
				local cdn = self:GetForceCooldown()
				local cd = self.ForcePowers[ id ].cooldown or 1
				local div = ( cd > 0 and cd ) or 1
				local rat = math.Clamp( cdn/div, 0, 1 )
				draw.RoundedBox( 0, x, y, h, h, Color( 0, 255 - 128*math.abs( math.cos( 8*CurTime() ) ), 255, 255 ) )
			render.SetStencilEnable( false )
			should_cooldown = true
				end
				
				wOS.ALCS:CutCircle( x + h/2, y + h/2, h/2 )
		
				if image then
					surface.SetMaterial( image )
					surface.DrawTexturedRect( x, y, h, h )
				else
					surface.SetDrawColor( Color( 0, 0, 0, 128 ) )
					surface.DrawRect( x, y, w, h )
				end
				
				render.SetStencilEnable( false )
		
				if should_cooldown then
			wOS.ALCS:CutCircle( x + h/2, y + h/2, h/2 )
				local y = y + ( icon - bar )
				local cdn = self:GetForceCooldown()
				local cd = self.ForcePowers[ id ].cooldown or 1
				local div = ( cd > 0 and cd ) or 1
				local rat = math.Clamp( cdn/div, 0, 1 )
				draw.RoundedBox( 0, x, y - h + h*( 1 - rat), h, h*rat, Color( 255, 0, 0, 100 ) )
			render.SetStencilEnable( false )
				end
		
				draw.SimpleText( t.icon || "", "SelectedForceType", x2, math.floor( y + icon / 2 ), Color( 255, 255, 255 ), 1, 1 )
				if ( self.ForceSelectEnabled ) then
					draw.SimpleText( "Slot " .. ( input.LookupBinding( "slot" .. id ) || "<NOT BOUND>" ):upper(), "SelectedForceHUD", x + h/2, y - 3*gap, Color( 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
				end
			end
			
			if ( self.ForceSelectEnabled ) and #self.ForcePowers > 0 then
		
				surface.SetFont( "SelectedForceHUD" )
				local tW, tH = surface.GetTextSize( self.ForcePowers[ self:GetForceType() ].description || "" )
		
				/*local x = x + w + gap
				local y = y*/
				local x = ScrW() / 2 + gap// - tW / 2
				local y = y - tH - gap * 8
		
				self.Vars:DrawHUDBox( x, y, tW + gap * 2, tH + gap * 2 )
		
				for id, txt in pairs( string.Explode( "\n", self.ForcePowers[ self:GetForceType() ].description || "" ) ) do
					draw.SimpleText( txt, "SelectedForceHUD", x + gap, y + ( id - 1 ) * ScreenScale( 6 ) + gap, Color( 255, 255, 255 ) )
				end
		
				surface.SetFont( "SelectedForceType" )
				local txt = self.ForcePowers[ self:GetForceType() ].name or ""
				local tW2, tH2 = surface.GetTextSize( txt )
		
				local x = ScrW() / 2 + gap// - tW / 2
				local y = y - tH - gap * 8

		self.Vars:DrawHUDBox( x, y, tW2 + 10, tH2 )
		draw.SimpleText( txt, "SelectedForceType", x + gap, y, Color( 255, 255, 255 ) )
	end
end

		default_huds[2] = function( self )
			local icon = 52*(ScrW()/1920)
			local gap = 5*(ScrW()/1920)
			local bar = 4
			local bar2 = 16
			if ( self.ForceSelectEnabled ) then
				icon = 128*(ScrW()/1920)
				bar = 8
				bar2 = 24
			end
			local ForcePowers = self:GetActiveForcePowers()
			if ( #ForcePowers < 1 ) then return end
		
			----------------------------------- Force Bar -----------------------------------
		
			self.Vars.ForceBar = math.min( self:GetMaxForce(), Lerp( 0.1, self.Vars.ForceBar, math.floor( self:GetForce() ) ) )
			self.Vars.DevBar = math.min( self:GetMaxStamina(), Lerp( 0.1, self.Vars.DevBar, math.floor( self:GetDevEnergy() ) ) )
		
			local w = #ForcePowers * icon + ( #ForcePowers - 1 ) * gap
		
			local h = bar2
			local x = math.floor( ScrW() / 2 - w / 2 )
			local y = ScrH() - gap - bar2
		
			self.Vars:DrawHUDBox( x, y, w, h )
		
			local barW = math.ceil( w * ( self.Vars.ForceBar / self:GetMaxForce() ) )
			if ( self:GetForce() <= 1 && barW <= 1 ) then barW = 0 end
			draw.RoundedBox( 0, x, y, barW, h, Color( 0, 128, 255, 255 ) )
			
			local barW2 = math.ceil( w * ( self.Vars.DevBar / 100 ) )
			if ( self:GetDevEnergy() <= 1 && barW2 <= 1 ) then barW2 = 0 end
			draw.RoundedBox( 0, x, y, barW2, h, Color( 225, 0, 225, 125 ) )
		
			draw.SimpleText( math.floor( self:GetForce() ) .. "%", "SelectedForceHUD", x + w / 2, y + h / 2, Color( 255, 255, 255 ), 1, 1 )
			if wOS.ALCS.Config.EnableStamina then
				------------------------------------- STAMINA BAR --------------------------------
				local stam = self:GetStamina()
				self.Vars.StaminaBar = (self.Vars.StaminaBar == stam and stam) or Lerp(0.1, self.Vars.StaminaBar, stam )
				x = math.floor( ScrW()/2 - w / 2 )
				y = ScrH() - gap - bar2 - bar2
		
				self.Vars:DrawHUDBox( x, y, w, h )
		
				barW = math.ceil( w * ( self.Vars.StaminaBar / self:GetMaxStamina() ) )
				if ( self:GetStamina() <= 1 && barW <= 1 ) then barW = 0 end
				draw.RoundedBox( 0, x, y, barW, h, Color( 155, 155, 155, 255 ) )
		
				draw.SimpleText( "STAMINA: " .. math.floor( self:GetStamina() ) .. "%", "SelectedForceHUD", x + w / 2, y + h / 2, Color( 255, 255, 255 ), 1, 1 )
			end
		
				y = y - icon - gap
				h = icon
		
				for id, t in pairs( ForcePowers ) do
					local x = x + ( id - 1 ) * ( h + gap )
					local x2 = math.floor( x + icon / 2 )
		
					local image = wOS.ForceIcons[ self.ForcePowers[ id ].name ]
					self.Vars:DrawHUDBox( x, y, h, h, self:GetForceType() == id )
					if !wOS.ALCS.Config.DisableForceIcons then
						if image then
							surface.SetMaterial( image )
							surface.SetDrawColor( Color(255, 255, 255, 255) );
							surface.DrawTexturedRect( x, y, h, h )
						end
					end
					draw.SimpleText( t.icon or "", "SelectedForceType", x2, math.floor( y + icon / 2 ), Color( 255, 255, 255 ), 1, 1 )
					if ( self.ForceSelectEnabled ) then
						draw.SimpleText( ( input.LookupBinding( "slot" .. id ) or "<NOT BOUND>" ):upper(), "SelectedForceHUD", x + gap, y + gap, Color( 255, 255, 255 ) )
					end
			if ( self:GetForceType() == id ) then

				local cdn = self:GetForceCooldown()
				local cd = self.ForcePowers[ id ].cooldown or 1
				local div = ( cd > 0 and cd ) or 1
				local rat = math.Clamp( cdn/div, 0, 1 )
				draw.RoundedBox( 0, x, y + h*( 1 - rat), h, h*rat, Color( 255, 0, 0, 100 ) )

						local y = y + ( icon - bar )
						surface.SetDrawColor( 0, 128, 255, 255 )
						draw.NoTexture()
						surface.DrawPoly( {
							{ x = x2 - bar, y = y },
							{ x = x2, y = y - bar },
							{ x = x2 + bar, y = y }
						} )
						draw.RoundedBox( 0, x, y, h, bar, Color( 0, 128, 255, 255 ) )
					end
				end
			
			local selectedForcePower = self:GetActiveForcePowerType( self:GetForceType() )
		
			if ( selectedForcePower && self.ForceSelectEnabled ) then
		
				surface.SetFont( "SelectedForceHUD" )
				local tW, tH = surface.GetTextSize( selectedForcePower.description or "" )
		
				--[[local x = x + w + gap
				local y = y]]
				local x = ScrW() / 2 + gap-- - tW / 2
				local y = y - tH - gap * 3
		
				self.Vars:DrawHUDBox( x, y, tW + gap * 2, tH + gap * 2 )
		
				for id, txt in pairs( string.Explode( "\n", selectedForcePower.description or "" ) ) do
					draw.SimpleText( txt, "SelectedForceHUD", x + gap, y + ( id - 1 ) * ScreenScale( 6 ) + gap, Color( 255, 255, 255 ) )
				end
		
			end
			
			if ( !self.ForceSelectEnabled ) then
				surface.SetFont( "SelectedForceHUD" )
				local txt = "Press " .. ( input.LookupBinding( "impulse 100" ) or "<NOT BOUND>" ):upper() .. " to toggle Force selection"
				local tW, tH = surface.GetTextSize( txt )
		
				local x = x + w / 2
				local y = y - tH - gap
		
				self.Vars:DrawHUDBox( x - tW / 2 - 5, y, tW + 10, tH )
				draw.SimpleText( txt, "SelectedForceHUD", x, y, Color( 255, 255, 255 ), 1 )
		
				local isGood = hook.Call( "PlayerBindPress", nil, LocalPlayer(), "this_bind_doesnt_exist", true )
				if ( isGood == true ) then
					local txt = "Some addon is breaking the PlayerBindPress hook. Send a screenshot of this error to the mod page!"
					for name, func in pairs( hook.GetTable()[ "PlayerBindPress" ] ) do txt = txt .. "\n" .. tostring( name ) end
					local tW, tH = surface.GetTextSize( txt )
		
					y = y - tH - gap
		
					local id = 1
					self.Vars:DrawHUDBox( x - tW / 2 - 5, y, tW + 10, tH )
					draw.SimpleText( string.Explode( "\n", txt )[ 1 ], "SelectedForceHUD", x, y + 0, Color( 255, 230, 230 ), 1 )
		
					for str, func in pairs( hook.GetTable()[ "PlayerBindPress" ] ) do
						local clr = Color( 255, 255, 128 )
						if ( ( isstring( str ) && func( LocalPlayer(), "this_bind_doesnt_exist", true ) == true ) or ( !isstring( str ) && func( str, LocalPlayer(), "this_bind_doesnt_exist", true ) == true ) ) then
							clr = Color( 255, 128, 128 )
						end
						if ( !isstring( str ) ) then str = tostring( str ) end
						if ( str == "" ) then str = "<empty string hook>" end
						local _, lineH = surface.GetTextSize( str )
						draw.SimpleText( str, "SelectedForceHUD", x, y + id * lineH, clr, 1 )
						id = id + 1
					end
				end
			end
		
			if ( selectedForcePower && self.ForceSelectEnabled ) then
				surface.SetFont( "SelectedForceType" )
				local txt = selectedForcePower.name or ""
				local tW2, tH2 = surface.GetTextSize( txt )
		
				local x = x + w / 2 - tW2 - gap * 2 --+ w / 2
				local y = y + gap - tH2 - gap * 2
		
				self.Vars:DrawHUDBox( x, y, tW2 + 10, tH2 )
				draw.SimpleText( txt, "SelectedForceType", x + gap, y, Color( 255, 255, 255 ) )
			end
		end
		
		default_huds[3] = function( self )
			local icon = 52*(ScrW()/1920)
			local gap = 5*(ScrW()/1920)
		
			local bar = 4
			local bar2 = 16
		
			local ForcePowers = self:GetActiveForcePowers()
		
			if ( #ForcePowers < 1 ) then return end
		
			self.Vars.ForceBar = math.min( self:GetMaxForce(), Lerp( 0.1, self.Vars.ForceBar, math.floor( self:GetForce() ) ) )
	self.Vars.DevBar = math.min( self:GetMaxStamina(), Lerp( 0.1, self.Vars.DevBar, math.floor( self:GetDevEnergy() ) ) )

	local w = 9* icon + 8 * gap
	local h = bar2
	local x = math.floor( ScrW() / 2 - w / 2 )
	local y = ScrH() - gap - bar2
		
			self.Vars:DrawHUDBox( x, y, w, h )
		
			local barW = math.ceil( w * ( self.Vars.ForceBar / self:GetMaxForce() ) )
			if ( self:GetForce() <= 1 && barW <= 1 ) then barW = 0 end
			draw.RoundedBox( 0, x, y, barW, h, Color( 0, 128, 255, 255 ) )
			
			local barW2 = math.ceil( w * ( self.Vars.DevBar / 100 ) )
			if ( self:GetDevEnergy() <= 1 && barW2 <= 1 ) then barW2 = 0 end
			draw.RoundedBox( 0, x, y, barW2, h, Color( 225, 0, 225, 125 ) )
		
			draw.SimpleText( math.floor( self:GetForce() ) .. "%", "SelectedForceHUD", x + w / 2, y + h / 2, Color( 255, 255, 255 ), 1, 1 )
			if wOS.ALCS.Config.EnableStamina then
			
				local stam = self:GetStamina()
				self.Vars.StaminaBar = (self.Vars.StaminaBar == stam and stam) or Lerp(0.1, self.Vars.StaminaBar, stam )
				x = math.floor( ScrW()/2 - w / 2 )
				y = ScrH() - gap - bar2 - bar2
		
				self.Vars:DrawHUDBox( x, y, w, h )
		
				barW = math.ceil( w * ( self.Vars.StaminaBar / self:GetMaxStamina() ) )
				if ( self:GetStamina() <= 1 && barW <= 1 ) then barW = 0 end
				draw.RoundedBox( 0, x, y, barW, h, Color( 155, 155, 155, 255 ) )
		
				draw.SimpleText( "STAMINA: " .. math.floor( self:GetStamina() ) .. "%", "SelectedForceHUD", x + w / 2, y + h / 2, Color( 255, 255, 255 ), 1, 1 )
			end
		
			local selectedForcePower = self:GetActiveForcePowerType( self:GetForceType() )
		
			surface.SetFont( "SelectedForceType" )
			local txt = selectedForcePower.name or ""
			local tW2, tH2 = surface.GetTextSize( txt )
		
			local x = x + w / 2 - tW2/2 - 5
			local y = y - tH2 - gap * 5 
			
			self.Vars:DrawHUDBox( x, y, tW2 + 10, tH2 )
	draw.SimpleText( txt, "SelectedForceType", x + gap, y, Color( 255, 255, 255 ) )
	
	local cdn = self:GetForceCooldown()
	local cd = selectedForcePower.cooldown or 1
	local div = ( cd > 0 and cd ) or 1
	local rat = math.Clamp( cdn/div, 0, 1 )

	draw.RoundedBox( 0, x, y, ( tW2 + 10 )*rat, tH2, Color( 255, 0, 0, 100 ) )

end

default_huds[4] = function( self )
	local ForcePowers = self.ForcePowers

	local icon = ScrW() * 0.035
	local gap = ScrW() * 0.004

	local bar = 4
	local bar2 = 16
	local rd = 7


	if (self.ForceSelectEnabled) then
		icon = ScrW() * 0.06
		bar = 8
		bar2 = 20
		rd = 10
	end

	self.Vars.ForceBar = math.min(self:GetMaxForce(), Lerp( 0.1, self.Vars.ForceBar, math.floor(self:GetForce())))
	self.Vars.DevBar = math.min(100, Lerp( 0.1, self.Vars.DevBar, math.floor(self:GetDevEnergy())))

	local w = #ForcePowers * icon + (#ForcePowers - 1) * gap
	if #ForcePowers < 5 then
		w = 5 * icon + (#ForcePowers - 1) * gap
	end

	local h = bar2
	local x = math.floor( ScrW() / 2 - w / 2 )
	local y = ScrH() * 0.92

	draw.RoundedBox(7, x, y, w, h, GetColor("darkgray", 100))

	local barW = math.ceil( w * ( self.Vars.ForceBar / self:GetMaxForce()))

	if (self:GetForce() <= 1 and barW <= 1) then
		barW = 0
	end

	draw.RoundedBox(7, x, y, barW, h, GetColor("yellow", 200))

	local barW2 = math.ceil(w * (self.Vars.DevBar / 100))
	if (self:GetDevEnergy() <= 1 && barW2 <= 1 ) then barW2 = 0 end
	surface.SetMaterial(self.Vars.grad)
	surface.SetDrawColor(Color(225, 0, 225, 175 - 175 * math.abs(math.sin(CurTime()))))
	surface.DrawTexturedRect(x, y, barW2, h)
	draw.SimpleText("Macht: " .. math.floor(self:GetForce()) .. "%", "SelectedForceHUD", x + w / 2, y + h / 2, GetColor("white"), 1, 1)

	--Stamina
	if wOS.ALCS.Config.EnableStamina then
		local stam = self:GetStamina()
		self.Vars.StaminaBar = (self.Vars.StaminaBar == stam and stam) or Lerp(0.1, self.Vars.StaminaBar, stam)

		x = math.floor(ScrW() / 2 - w / 2)
		y = ScrH() * 0.895

		draw.RoundedBox(rd, x, y, w, h, Color(0, 0, 0, 128))

		barW = math.ceil(w * (self.Vars.StaminaBar / self:GetMaxStamina()))
		if (self:GetStamina() <= 1 && barW <= 1) then barW = 0 end
		draw.RoundedBox(rd, x, y, barW, h, Color(155, 155, 155, 255))
		draw.SimpleText("Ausdauer: " .. math.floor(self:GetStamina()) .. "%", "SelectedForceHUD", x + w / 2, y + h / 2, Color(255, 255, 255), 1, 1)
	end

	if (#ForcePowers < 1) or wOS.ALCS.ForceMenu then return end

	y = y - icon - gap
	h = icon

	for id, t in pairs( ForcePowers ) do
		local should_cooldown = false
		local image = wOS.ForceIcons[ self.ForcePowers[ id ].name ]
		local x = x + ( id - 1 ) * ( h + gap )
		local x2 = math.floor( x + icon / 2 )

		if (self:GetForceType() == id) then
			wOS.ALCS:CutCircle(x + h / 2, y + h / 2, h * 0.55)

			draw.RoundedBox(0, x, y, h, h, Color(0, 255 - 128 * math.abs(math.cos(8 * CurTime())), 255, 255))
			render.SetStencilEnable(false)

			should_cooldown = true
		end

		wOS.ALCS:CutCircle(x + h / 2, y + h / 2, h / 2)

		if image then
			surface.SetMaterial(image)
			surface.DrawTexturedRect(x, y, h, h)
		else
			surface.SetDrawColor(Color(0, 0, 0, 128))
			surface.DrawRect(x, y, w, h)
		end

		render.SetStencilEnable(false)

		if should_cooldown then
			wOS.ALCS:CutCircle( x + h / 2, y + h / 2, h / 2 )
			local y = y + ( icon - bar )
			local cdn = self:GetForceCooldown()
			local cd = self.ForcePowers[ id ].cooldown or 1
			local div = ( cd > 0 and cd ) or 1
			local rat = math.Clamp( cdn / div, 0, 1 )

			draw.RoundedBox(0, x, y - h + h * ( 1 - rat), h, h * rat, GetColor("red", 100))
			render.SetStencilEnable(false)
		end

		draw.SimpleText( t.icon || "", "SelectedForceType", x2, math.floor( y + icon / 2 ), Color( 255, 255, 255 ), 1, 1)

		if (self.ForceSelectEnabled) then
			draw.SimpleText( "Slot " .. (input.LookupBinding( "slot" .. id ) || "<NICHT GEBINDET>"):upper(), "SelectedForceHUD", x + h / 2, y - 3 * gap, Color( 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
		end
	end

	if self.ForceSelectEnabled and #self.ForcePowers > 0 then
		surface.SetFont( "SelectedForceHUD" )
		local dat = self.ForcePowers[ self:GetForceType() ]
		if dat then
			local tW, tH = surface.GetTextSize( dat.description || "" )

			x = ScrW() * 0.5 - (tW * 0.5)
			y = y - tH - gap * 8

			self.Vars:DrawHUDBox( x, y, tW + gap * 2, tH + gap * 2 )

			for id, txt in pairs(string.Explode( "\n", dat.description || "" )) do
				draw.SimpleText(txt, "SelectedForceHUD", x + gap, y + ( id - 1 ) * ScreenScale( 6 ) + gap, Color(255, 255, 255))
			end

			surface.SetFont( "SelectedForceType" )

			local txt = dat.name || ""
			local tW2, tH2 = surface.GetTextSize( txt )

			x = ScrW() * 0.5 - (tW2 * 0.5)
			y = y - tH - gap * 8

			self.Vars:DrawHUDBox( x, y, tW2 + 10, tH2 )
			draw.SimpleText( txt, "SelectedForceType", x + gap, y, Color( 255, 255, 255 ) )
		end
	end
end

function wOS.ALCS.LightsaberBase:HandleHUD( wep )
	local overwrite = hook.Call( "wOS.ALCS.DrawLightsaberHUD", nil, wep )
	if overwrite then return end

	local hud = ( wOS.ALCS.Config.LightsaberHUD <= table.Count( WOS_ALCS.HUD ) and wOS.ALCS.Config.LightsaberHUD ) or WOS_ALCS.HUD.NEWAGE
	local func = default_huds[hud]
	if func then
		default_huds[hud]( wep )
	end

	wOS.ALCS.LightsaberBase:HandleTarget( wep )
end

function wOS.ALCS.LightsaberBase:HandleTarget(wep)
	local powerdata = wep.ForcePowers[wep:GetForceType()]

	if not powerdata then return end

	local ply = wep.Owner

	if not powerdata.target then return end
	if not ply:KeyDown(IN_USE) then return end

	local targets = wep:GetTargetEntity(powerdata.dist or 512, powerdata.target)

	for _, target in ipairs(targets) do
		if not target:IsValid() then return end
		if hook.Run("wOS.Lightsaber.DisableTargetting", target) then continue end
		local maxs = target:OBBMaxs()
		local p = target:GetPos()
		p.z = p.z + maxs.z
		local pos = p:ToScreen()
		local x, y = pos.x, pos.y
		local size = 16
		surface.SetDrawColor(220 + math.cos(CurTime() * 10) * 35, 0, 0, 255)
		draw.NoTexture()

		surface.DrawPoly({
			{
				x = x - size,
				y = y - size
			},
			{
				x = x + size,
				y = y - size
			},
			{
				x = x,
				y = y
			}
		})
	end
end
--addons/wos-grandmaster-einf/lua/wos/advswl/dueling/core/cl_net.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2020
	
	Contact: www.wiltostech.com
		----------------------------------------]]--








































































wOS = wOS or {}
wOS.ALCS = wOS.ALCS or {}
wOS.ALCS.Dueling = wOS.ALCS.Dueling or {}
wOS.ALCS.Dueling.Spirits = wOS.ALCS.Dueling.Spirits or {}

net.Receive( "wOS.ALCS.Dueling.SendPlayerData", function( len )

	local spirit = net.ReadBool()
	
	if !spirit then
		wOS.ALCS.Dueling.DuelData = net.ReadTable()
	else
		wOS.ALCS.Dueling.SpiritData = net.ReadTable()
	end

end )

net.Receive( "wOS.ALCS.Dueling.SendSpirits", function( len )

	local newtbl = net.ReadTable()

	wOS.ALCS.Dueling.Spirits = wOS.ALCS.Dueling.Spirits or {}
	table.Merge( wOS.ALCS.Dueling.Spirits, newtbl )
	
end )

net.Receive( "wOS.ALCS.Dueling.SendSpiritResults", function()

	local results = net.ReadTable()
	if table.Count( results ) < 1 then return end

	results.time = CurTime()
	wOS.ALCS.Dueling.Results = table.Copy( results )

end )

net.Receive( "wOS.ALCS.Dueling.RefreshSacrifices", function( len )

	wOS.SaberInventory = net.ReadTable()
	wOS.ALCS.Skills:ChangeCamFocus( "Duel-ViewSacrifices" )

end )

net.Receive( "wOS.ALCS.Dueling.CreateDuel", function( len )

	local ply = net.ReadEntity()
	if not IsValid( ply ) then return end
	
	local data = net.ReadTable()
	data.Defender = ply
	
	wOS.ALCS.Dueling:CreateChallengeMenu( data )
	
end )

net.Receive( "wOS.ALCS.Dueling.DuelRequest", function( len )


	local challenger = net.ReadEntity()
	if not challenger then return end
	
	local settings = net.ReadTable()
	local data = net.ReadTable()
	data.Challenger = challenger
	
	wOS.ALCS.Dueling:AddChallenge( data, settings )
		
end )

net.Receive( "wOS.ALCS.Dueling.DuelFinish", function( len )


	wOS.ALCS.Dueling.Opponent = nil
	wOS.ALCS.Dueling.IntroSlot = nil
	wOS.ALCS.Dueling.IntroTime = nil
	wOS.ALCS.Dueling.FadeThrough = CurTime() + 1

	local result = net.ReadInt( 32 )
	local resultpan = vgui.Create( "DPanel" )
	resultpan:SetSize( ScrW()*0.5, ScrH()*0.1 )
	resultpan:SetPos( ScrW()*0.25, ScrH()*0.02 )	
	
	if result == WOS_ALCS.DUEL.WON then
		resultpan.Paint = function( pan, ww, hh )
			draw.SimpleText( "DUEL WON! You have been awarded your wager.", "wOS.MegaDuelFont", ww/2, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		end
	elseif result == WOS_ALCS.DUEL.LOST then
		resultpan.Paint = function( pan, ww, hh )
			draw.SimpleText( "DUEL LOST! Your wager has been deducted.", "wOS.MegaDuelFont", ww/2, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		end
	else
		resultpan.Paint = function( pan, ww, hh )
			draw.SimpleText( "NOBODY WINS! The duel was a draw.", "wOS.MegaDuelFont", ww/2, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		end
	end
	
	resultpan.CoolDown = CurTime() + 5
	
	resultpan.Think = function( self )
		if self.CoolDown < CurTime() then
			self:Remove()
		end
	end

end )

net.Receive( "wOS.ALCS.Dueling.DuelDecline", function( len )
	
	local resultpan = vgui.Create( "DPanel" )
	resultpan:SetSize( ScrW()*0.5, ScrH()*0.1 )
	resultpan:SetPos( ScrW()*0.25, ScrH()*0.02 )	
	resultpan.ply = net.ReadEntity()
	resultpan.Paint = function( pan, ww, hh )
		if pan.ply:IsValid() then
			draw.SimpleText( pan.ply:Nick() .. " has declined your request.", "wOS.MegaDuelFont", ww/2, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		end
	end	
	resultpan.CoolDown = CurTime() + 5
	resultpan.Think = function( self )
		if self.CoolDown < CurTime() or not self.ply:IsValid() then
			self:Remove()
		end
	end
	
end )

net.Receive( "wOS.ALCS.Dueling.StartDuelCam", function( len )
	
	local opponent = net.ReadEntity()
	if not opponent then return end
	
	wOS.ALCS.Dueling.Opponent = opponent
	
	local data = net.ReadTable()
	if not data then return end
	
	wOS.ALCS.Dueling.Opponent.DuelData = table.Copy( data )
	
	wOS.ALCS.Dueling.IntroSlot = 1
	wOS.ALCS.Dueling.IntroTime = CurTime() + 5
	
	wOS.ALCS.Dueling.FadeThrough = CurTime() + 1
	
end )

properties.Add( "Challenge to Duel", {
	MenuLabel = "#Challenge to Duel", -- Name to display on the context menu
	Order = 1, -- The order to display this property relative to other properties
	MenuIcon = "icon16/comments_delete.png", -- The icon to display next to the property
	Filter = function( self, ent, ply ) -- A function that determines whether an entity is valid for this property
		if ( !IsValid( ent ) ) then return false end
		if ( !ent:IsPlayer() ) then return false end
		return true
	end,
	Action = function( self, ent ) -- The action to perform upon using the property ( Clientside )
		self:MsgStart()
			net.WriteEntity( ent )
		self:MsgEnd()
	end,
} )
--addons/wos-grandmaster-einf/lua/wos/advswl/dueling/core/cl_menu_library.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2020
	
	Contact: www.wiltostech.com
		----------------------------------------]]--








































































wOS = wOS or {}
wOS.ALCS = wOS.ALCS or {}
wOS.ALCS.Skills = wOS.ALCS.Skills or {}
wOS.ALCS.Skills.Camera = wOS.ALCS.Skills.Camera or {}

local w,h = ScrW(), ScrH()
local pi = math.pi

local upButton = Material( "wos/crafting/gui/up.png", "unlitgeneric" )
local downButton = Material( "wos/crafting/gui/down.png", "unlitgeneric" )
local leftButton = Material( "wos/crafting/gui/left.png", "unlitgeneric" )
local rightButton = Material( "wos/crafting/gui/right.png", "unlitgeneric" )
local bufferBar = Material( "wos/crafting/gui/buffer.png", "unlitgeneric" )
local boxTop = Material( "phoenix_storms/metalset_1-2", "unlitgeneric" )

local wireFrame = Material( "trails/plasma" )

local DuelBlock = Material( "wos/advswl/duel_holocron.png", "unlitgeneric" )

local centerpoint = wOS.ALCS.Config.Crafting.CraftingCamLocation
local color_unselected = Color( 0, 0, 0, 100 )
local grad = Material( "gui/gradient_up" )

wOS.ALCS.Skills.CubeModels = wOS.ALCS.Skills.CubeModels or {}

wOS.ALCS.Skills.MenuLibrary = wOS.ALCS.Skills.MenuLibrary or {}
wOS.ALCS.Skills.Camera[ "Duel-Overview" ] = { origin = centerpoint - Vector( 45, -35, -30 ), angles = Angle( 0, 90.501, 0.000 ) }
wOS.ALCS.Skills.MenuLibrary[ "Duel-Overview" ] = function()
	
	local leftpane = tduiw.Create()
	leftpane.SizeX = 8
	leftpane.SizeY = 35
	leftpane.ShouldAcceptInputs = true
	leftpane.Renders = function( pan )
	
		local ww, hh = pan.SizeX, pan.SizeY	
		local x = -30
		local y = -hh*0.4
		local bh = hh/7
		
		pan:Line( 0, -hh/2, x + ww, y + bh/2 )
		
		local lst = 0
		image = wOS.ALCS.Runes[ "d" ]
		pan:Mat( image, x, y, ww, bh )	
		local _jp, _pr, _hov = pan:Button( "", "wOS.TitleFont", x, y, ww, bh, color_white, color_white )
	    if _hov then
			local speed = 0.1
			if not pan.SlideTimes then 
				pan.SlideTimes = CurTime() + speed
				surface.PlaySound( "wos/alcs/ui_slideout.wav" )
			end
			if pan.LastButt != lst then
				surface.PlaySound( "wos/alcs/ui_rollover.wav" )
				pan.LastButt = lst
			end
			local rat = math.Clamp( pan.SlideTimes - CurTime(), 0, speed )/speed
			pan:Rect( x, y, ww*-3*( 1 - rat  ), bh, Color( 10, 10, 10, 255 ), color_white )
			pan:Text( "VIEW DUELING SPIRITS", "wOS.TitleFont", x + ww*-2.7*( 1 - rat  ), y + bh/2, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )

			pan.LastHover = CurTime() + 0.01
	    end							
		if _jp then
			wOS.ALCS.Skills:ChangeCamFocus( "Duel-SelectSpirit" )
		end
		
		if pan.SlideTimes and pan.LastHover < CurTime() then
			pan.SlideTimes	= nil
			pan.LastButt = nil
		end
	
	end
	leftpane:SetUIScale( 10 )
	leftpane.Scaling = 0.025
	
	leftpane.CamPos = wOS.ALCS.Skills.Camera[ wOS.ALCS.Skills.CamFocus ].origin + Vector( 0, 20, -2 )
	leftpane.CamAng = wOS.ALCS.Skills.Camera[ wOS.ALCS.Skills.CamFocus ].angles + Angle( 0, 30, 0 )
	table.insert( wOS.ALCS.Skills.Menu.VGUI, leftpane )
	
	local frontpane = tduiw.Create()
	frontpane.SizeX = 8
	frontpane.SizeY = 35
	frontpane.ShouldAcceptInputs = true
	frontpane.Renders = function( pan )
		local ww, hh = pan.SizeX, pan.SizeY
		
		local x = 0 - ww/2
		local y = 10
		local bh = hh/7
		
		local data = wOS.ALCS.Dueling.DuelData
		
		pan:Text( "WON: " .. ( data.Wins or 0 ) .. "      |      LOST: " .. ( data.Losses or 0 ), "wOS.CraftDescriptions", 0, -hh*1.1, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )

		local item = wOS.ALCS.Dueling.Spirits[ data.DuelSpirit ]
		if item then
			pan:Text( "[ " .. item.Name .. " ]", "wOS.TitleFont", 0, -hh*0.95, item.RarityColor or color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
			local xp = ( wOS.ALCS.Dueling.SpiritData[ data.DuelSpirit ] and wOS.ALCS.Dueling.SpiritData[ data.DuelSpirit ].experience ) or 0
			if xp >= item.MaxEnergy then
				local rate = math.abs( math.cos( CurTime()*5 ) )
				pan:Text( "THIS SPIRIT MAY BE ASCENDED", "wOS.DescriptionFont", 0, -hh*0.9, Color( 255*rate, 255 - 255*rate, 255 - 255*rate, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP )
			end
		end
		
		pan:Line( 0, -3, 3, 3 )
		pan:Line( 3, 3, 0, 10 )
		
		local lst = 0
		image = wOS.ALCS.Runes[ "x" ]
		pan:Mat( image, x, y, ww, bh )	
		local _jp, _pr, _hov = pan:Button( "", "wOS.TitleFont", x, y, ww, bh, color_white, color_white )
		if _jp then
			wOS.ALCS.Skills:ChangeCamFocus( "Overview" )
	    elseif _hov then
			local speed = 0.1
			if not pan.SlideTimes then 
				pan.SlideTimes = CurTime() + speed
				surface.PlaySound( "wos/alcs/ui_slideout.wav" )
			end
			if pan.LastButt != lst then
				surface.PlaySound( "wos/alcs/ui_rollover.wav" )
				pan.LastButt = lst
			end
			local rat = math.Clamp( pan.SlideTimes - CurTime(), 0, speed )/speed
			pan:Rect( x + ww, y, ww*( 3 - 3*rat  ), bh, Color( 10, 10, 10, 255 ), color_white )
			pan:Text( "GO BACK", "wOS.TitleFont", x + ww*2.1*( 1 - rat  ), y + bh/2, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
			pan.LastHover = CurTime() + 0.01
	    end							
		lst = lst + 1
		
		local _jp, _pr, _hov = pan:Button( "", "wOS.TitleFont", -hh*0.7/2, -hh*0.7, hh*0.7, hh*0.7, Color( 0, 0, 0, 0 ), Color( 0, 0, 0, 0 ) )
	    if _hov then
			local speed = 0.1
			if not pan.SlideTimes then 
				pan.SlideTimes = CurTime() + speed
			end
			if pan.LastButt != lst then
				surface.PlaySound( "wos/alcs/ui_rollover.wav" )
				pan.LastButt = lst
			end
			local rat = math.Clamp( pan.SlideTimes - CurTime(), 0, speed )/speed
			pan:Text( "USE THE RUNES TO REFLECT ON YOUR ABILITIES", "wOS.CraftDescriptions", 0, y + bh*2*( 1.5 + rat ), color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
			pan.LastHover = CurTime() + 0.01
	    end		
		lst = lst + 1
		
		if pan.SlideTimes and pan.LastHover < CurTime() then
			pan.SlideTimes	= nil
			pan.LastButt = nil
		end
	
	end
	frontpane.PostRenders = function( pan )
		wOS.ALCS.Skills:CreateCubeMat( pan.CamPos, DuelBlock, nil, 6 )
	end
	frontpane:SetUIScale( 10 )
	frontpane.Scaling = 0.025
	
	frontpane.CamPos = wOS.ALCS.Skills.Camera[ wOS.ALCS.Skills.CamFocus ].origin + Vector( 0, 20, -2 )
	frontpane.CamAng = wOS.ALCS.Skills.Camera[ wOS.ALCS.Skills.CamFocus ].angles + Angle( 0, 0, 0 )
	table.insert( wOS.ALCS.Skills.Menu.VGUI, frontpane )
	
	
	local rightpane = tduiw.Create()
	rightpane.SizeX = 8
	rightpane.SizeY = 35
	rightpane.ShouldAcceptInputs = true
	rightpane.Renders = function( pan )
	
		local ww, hh = pan.SizeX, pan.SizeY	
		local x = 20
		local y = -hh*0.6
		local bh = hh/7
		
		pan:Line( x/2, y + hh*0.15, x, y + bh/2 )
		
		local lst = 0
		image = wOS.ALCS.Runes[ "a" ]
		pan:Mat( image, x, y, ww, bh )	
		local _jp, _pr, _hov = pan:Button( "", "wOS.TitleFont", x, y, ww, bh, color_white, color_white )
		if _jp then
			wOS.ALCS.Skills:ChangeCamFocus( "Duel-AscendSpirit" )
	    elseif _hov then
			local speed = 0.1
			if not pan.SlideTimes then 
				pan.SlideTimes = CurTime() + speed
				surface.PlaySound( "wos/alcs/ui_slideout.wav" )
			end
			if pan.LastButt != lst then
				surface.PlaySound( "wos/alcs/ui_rollover.wav" )
				pan.LastButt = lst
			end
			local rat = math.Clamp( pan.SlideTimes - CurTime(), 0, speed )/speed
			pan:Rect( x + ww, y, ww*( 3 - 3*rat  ), bh, Color( 10, 10, 10, 255 ), color_white )
			pan:Text( "MANAGE ASCENSION", "wOS.TitleFont", x + ww*1.4*( 1 - rat  ), y + bh/2, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
			pan.LastHover = CurTime() + 0.01
	    end							
		lst = lst + 1
		
		y = y + hh*0.4
		pan:Line( x/2, y - hh*0.05, x, y + bh/2 )
		image = wOS.ALCS.Runes[ "s" ]
		pan:Mat( image, x, y, ww, bh )	
		local _jp, _pr, _hov = pan:Button( "", "wOS.TitleFont", x, y, ww, bh, color_white, color_white )
		if _jp then
			wOS.ALCS.Skills:ChangeCamFocus( "Duel-ViewSacrifices" )
	    elseif _hov then
			local speed = 0.1
			if not pan.SlideTimes then 
				pan.SlideTimes = CurTime() + speed
				surface.PlaySound( "wos/alcs/ui_slideout.wav" )
			end
			if pan.LastButt != lst then
				surface.PlaySound( "wos/alcs/ui_rollover.wav" )
				pan.LastButt = lst
			end
			local rat = math.Clamp( pan.SlideTimes - CurTime(), 0, speed )/speed
			pan:Rect( x + ww, y, ww*( 3 - 3*rat  ), bh, Color( 10, 10, 10, 255 ), color_white )
			pan:Text( "VIEW SACRIFICES", "wOS.TitleFont", x + ww*1.7*( 1 - rat  ), y + bh/2, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
			pan.LastHover = CurTime() + 0.01
	    end							
		lst = lst + 1
		
		if pan.SlideTimes and pan.LastHover < CurTime() then
			pan.SlideTimes	= nil
			pan.LastButt = nil
		end
	
	end
	rightpane:SetUIScale( 10 )
	rightpane.Scaling = 0.025
	
	rightpane.CamPos = wOS.ALCS.Skills.Camera[ wOS.ALCS.Skills.CamFocus ].origin + Vector( 0, 20, -2 )
	rightpane.CamAng = wOS.ALCS.Skills.Camera[ wOS.ALCS.Skills.CamFocus ].angles + Angle( 0, -30, 0 )
	table.insert( wOS.ALCS.Skills.Menu.VGUI, rightpane )
	
end

wOS.ALCS.Skills.Camera[ "Duel-SelectSpirit" ] = { origin = centerpoint - Vector( 65, -45, -30 ), angles = Angle( 0, 180, 0.000 ) }
wOS.ALCS.Skills.MenuLibrary[ "Duel-SelectSpirit" ] = function()

	local frontpane = tduiw.Create()
	frontpane.SizeX = 8
	frontpane.SizeY = 35
	frontpane.LeftCount = 1
	frontpane.RightCount = 5	
	frontpane.ShouldAcceptInputs = true
	frontpane.LastScrollSlot = 0
	frontpane.ScrollSlot = 0
	frontpane.Selected = 1
	frontpane.TestSkills = {}
	
	for name, data in pairs( wOS.ALCS.Dueling.Spirits ) do
		if data.UserGroups then
			if not table.HasValue( data.UserGroups, LocalPlayer():GetUserGroup() ) then continue end
		end
		local leveldata = wOS.ALCS.Dueling.SpiritData[ name ]
		if not leveldata then continue end
		local model = ClientsideModel( data.SpiritModel or LocalPlayer():GetModel(), RENDERGROUP_OPAQUE )
		model.LevelData = table.Copy( leveldata )
		model.SpiritData = table.Copy( data )
		local anim = "idle_fist"
		if data.Sequence then
			local id = model:LookupSequence(data.Sequence)
			if id != -1 then anim = id end
		end
		model:SetSequence( anim )
		model:SetCycle( 0.1 )
		table.insert( wOS.ALCS.Skills.CubeModels, model )
		table.insert( frontpane.TestSkills, name )
	end
	
	frontpane.Renders = function( pan )
		local ww, hh = pan.SizeX, pan.SizeY
		
		local x = 0 - ww/2
		local y = 10
		local bh = hh/7

		local spirit = pan.TestSkills[ pan.Selected ] or ""
		if wOS.ALCS.Dueling.Spirits[ spirit ] then
			local data = wOS.ALCS.Dueling.Spirits[ spirit ]
			pan:Text( spirit, "wOS.CraftTitles", 0, -hh*1.1, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
			pan:Text( data.Description, "wOS.CraftDescriptions", 0, -hh*0.85, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )	
			pan:Text( data.RarityName or "Dueling Spirit", "wOS.TitleFont", 0, -hh*0.75, data.RarityColor or color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )			
			pan:Text( "Starting Roll: " .. ( data.StartingRoll or 0 ), "wOS.TitleFont", -ww*5, -hh*0.65, data.RarityColor or color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )						
			pan:Text( "Energy Threshold: " .. ( data.MaxEnergy or 500 ), "wOS.TitleFont", ww*5, -hh*0.65, data.RarityColor or color_white, TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER )						
		end
		
		local lst = 0
		image = wOS.ALCS.Runes[ "x" ]
		pan:Mat( image, x, y + bh*2.5, ww, bh )	
		local _jp, _pr, _hov = pan:Button( "", "wOS.TitleFont", x, y + bh*2.5, ww, bh, color_white, color_white )
		if _jp then
			wOS.ALCS.Skills:ChangeCamFocus( "Duel-Overview" )
	    elseif _hov then
			local speed = 0.1
			if not pan.SlideTimes then 
				pan.SlideTimes = CurTime() + speed
				surface.PlaySound( "wos/alcs/ui_slideout.wav" )
			end
			if pan.LastButt != lst then
				surface.PlaySound( "wos/alcs/ui_rollover.wav" )
				pan.LastButt = lst
			end
			local rat = math.Clamp( pan.SlideTimes - CurTime(), 0, speed )/speed
			pan:Rect( x + ww, y + bh*2.5, ww*( 3 - 3*rat  ), bh, Color( 10, 10, 10, 255 ), color_white )
			pan:Text( "GO BACK", "wOS.TitleFont", x + ww*2.1*( 1 - rat  ), y + bh*2.5 + bh/2, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
			pan.LastHover = CurTime() + 0.01
	    end							
		lst = lst + 1
		
		local _jp, _pr, _hov = pan:Button( "", "wOS.TitleFont", -hh*0.55/2, -hh*0.65, hh*0.55, hh*1.05, Color( 0, 0, 0, 0 ), Color( 0, 0, 0, 0 ) )
	    if _jp then
			if !wOS.ALCS.Dueling.Spirits[ spirit ] then return end
			net.Start( "wOS.ALCS.Dueling.SelectSpirit" )
				net.WriteString( spirit )
			net.SendToServer()
		elseif _hov then
			local speed = 0.1
			if not pan.SlideTimes then 
				pan.SlideTimes = CurTime() + speed
			end
			if pan.LastButt != lst then
				surface.PlaySound( "wos/alcs/ui_rollover.wav" )
				pan.LastButt = lst
			end
			local rat = math.Clamp( pan.SlideTimes - CurTime(), 0, speed )/speed
			pan:Text( "SELECT THE SPIRIT TO EMBODY IT", "wOS.CraftDescriptions", 0, y + bh*2*( 2.25 + rat ), color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
			pan.LastHover = CurTime() + 0.01
	    end		
		lst = lst + 1
		
		pan:Mat( leftButton, x - ww*2, y + bh*1.2, ww, bh )	
		local _jp, _pr, _hov = pan:Button( "", "wOS.TitleFont", x - ww*2, y + bh*1.2, ww, bh, color_white, color_white )
		if _jp then
			//Keep incrementing it who am I to stop you
			//Your PC will regret it, not me
			pan.ScrollSlot = pan.ScrollSlot - 1
			pan.Selected = math.Round( pan.ScrollSlot % #pan.TestSkills ) + 1
	    elseif _hov then
			local speed = 0.1
			if pan.LastButt != lst then
				surface.PlaySound( "wos/alcs/ui_rollover.wav" )
				pan.LastButt = lst
			end
			pan.LastHover = CurTime() + 0.01
	    end							
		lst = lst + 1
		
		pan:Mat( rightButton, x + ww*2, y + bh*1.2, ww, bh )	
		local _jp, _pr, _hov = pan:Button( "", "wOS.TitleFont", x + ww*2, y + bh*1.2, ww, bh, color_white, color_white )
		if _jp then
			//Keep incrementing it who am I to stop you
			//Your PC will regret it, not me
			pan.ScrollSlot = pan.ScrollSlot + 1
			pan.Selected = math.Round( pan.ScrollSlot % #pan.TestSkills ) + 1
	    elseif _hov then
			local speed = 0.1
			if pan.LastButt != lst then
				surface.PlaySound( "wos/alcs/ui_rollover.wav" )
				pan.LastButt = lst
			end
			pan.LastHover = CurTime() + 0.01
	    end							
		lst = lst + 1
		
		if pan.SlideTimes and pan.LastHover < CurTime() then
			pan.SlideTimes	= nil
			pan.LastButt = nil
		end
	
	end
	frontpane.PostRenders = function( pan )
		local radius = 7.7
		pan.LastScrollSlot = math.Approach( pan.LastScrollSlot, pan.ScrollSlot, 0.01 )
		local offset = pi*5/10 + pi*2/#pan.TestSkills*pan.LastScrollSlot
		local basesize = 1.3 * ( 1 - 0.04*(#pan.TestSkills/15) )
		for i = 1, #pan.TestSkills do
			local j = i - 1
			local x, y = math.sin( offset - pi*j*2/#pan.TestSkills ), math.cos( offset - pi*j*2/#pan.TestSkills )
			local setpos = pan.CamPos - Vector( 8, 0, 0 ) + Vector( radius*x, radius*y, -3 )
			local size = 40/setpos:DistToSqr( wOS.ALCS.Skills.Camera[ wOS.ALCS.Skills.CamFocus ].origin )	//Clinically proven to be the number
			if not wOS.ALCS.Skills.CubeModels[i] then continue end
			wOS.ALCS.Skills.CubeModels[i]:SetPos( setpos )
			wOS.ALCS.Skills.CubeModels[i]:SetModelScale( basesize*size )
			if wOS.ALCS.Skills.CubeModels[i].SpiritData.Name == wOS.ALCS.Dueling.DuelData.DuelSpirit then
				halo.Add( { wOS.ALCS.Skills.CubeModels[i] }, Color( 255, 255, 255, 5 ), 5, 5, 1 )
			end
			if i == pan.Selected then
				wOS.ALCS.Skills.CubeModels[i]:FrameAdvance( 1 )
				if wOS.ALCS.Skills.CubeModels[i]:GetCycle() >= 0.99 then
					wOS.ALCS.Skills.CubeModels[i]:SetCycle( 0 )
				end
			end
		end
	end
	frontpane:SetUIScale( 10 )
	frontpane.Scaling = 0.025
	
	frontpane.CamPos = wOS.ALCS.Skills.Camera[ wOS.ALCS.Skills.CamFocus ].origin + Vector( -20, 0, 0 )
	frontpane.CamAng = wOS.ALCS.Skills.Camera[ wOS.ALCS.Skills.CamFocus ].angles + Angle( 0, 0, 0 )
	table.insert( wOS.ALCS.Skills.Menu.VGUI, frontpane )
	
end

wOS.ALCS.Skills.Camera[ "Duel-AscendSpirit" ] = { origin = centerpoint - Vector( 45, 10, -30 ), angles = Angle( 0, 270, 0.000 ) }
wOS.ALCS.Skills.MenuLibrary[ "Duel-AscendSpirit" ] = function()
	
	wOS.ALCS.Dueling.Results = nil
	
	local forward = wOS.ALCS.Skills.Camera[ wOS.ALCS.Skills.CamFocus ].angles:Forward()
	local right = wOS.ALCS.Skills.Camera[ wOS.ALCS.Skills.CamFocus ].angles:Right()
	local up = wOS.ALCS.Skills.Camera[ wOS.ALCS.Skills.CamFocus ].angles:Up()
	
	local backbutt = tduiw.Create()
	backbutt.SizeX = 50
	backbutt.SizeY = 25
	backbutt.ShouldAcceptInputs = true
	
	local frontpane = tduiw.Create()
	frontpane.SizeX = 8
	frontpane.SizeY = 35
	frontpane.LeftCount = 1
	frontpane.RightCount = 5	
	frontpane.ShouldAcceptInputs = true
	frontpane.LastScrollSlot = 0
	frontpane.ScrollSlot = 0
	frontpane.Selected = 1
	frontpane.Offset = 0
	
	frontpane.Data = wOS.ALCS.Dueling.Spirits[ wOS.ALCS.Dueling.DuelData.DuelSpirit ]
	frontpane.Artifacts = {}
	frontpane.Renders = function( pan )
		local ww, hh = pan.SizeX, pan.SizeY
		local bh = hh/7
		local pady = bh*0.05
		local x = 40 - ww*4
		local y = -22
		local lst = 0
		
		pan:Rect( x, y + bh, ww*4, bh*2 + pady*3, Color( 0, 0, 0, 0 ), color_white )
		pan:Rect( x, y, ww*4, bh, Color( 0, 0, 0, 0 ), color_white )
		pan:Text( wOS.ALCS.Dueling.DuelData.DuelSpirit or "Duelist", "wOS.TitleFont", x + ww*2, y + bh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )	
		
		local data = wOS.ALCS.Dueling.SpiritData[ wOS.ALCS.Dueling.DuelData.DuelSpirit ]
		local bonus = ( data.experience > pan.Data.MaxEnergy and " [ " .. data.experience - pan.Data.MaxEnergy .. " ]" ) or ""
		pan:Text( "Current Energy: " .. data.experience .. bonus, "wOS.TitleFont", x + ww*0.1, y + bh + bh/2, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )	
		
		local strength = ( data.level < data.lastlevel and "DRAINED" ) or "HEALTHY"
		pan:Text( "Spirit Strength: " .. strength, "wOS.TitleFont", x + ww*0.1, y + bh*2 + bh/2, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )			
				
		if wOS.ALCS.Dueling.Results then
			local result = wOS.ALCS.Dueling.Results
			local offset = y + bh*3.5 + pady*4
			pan:Text( "ASCENSION RESULTS", "wOS.TitleFont", x + ww*2, offset, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
			offset = offset + bh/2
			pan:Text( "Artifact: " .. result.artifact, "wOS.DescriptionFont", x + ww*2, offset, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )				
			offset = offset + bh/2
			
			local width = 0
			local text = ""
			if CurTime() - result.time >= 0 then
				local rat = math.min( 3, CurTime() - result.time )/3
				width = width + rat*result.start
				text = text .. "Starting Strength: " .. math.Round( rat*result.start )
			end

			if CurTime() - result.time >= 3 then
				local rat = math.min( 3, CurTime() - result.time - 3 )/3
				width = width + rat*result.mod
				text = text .. "  |  Modifier: " .. math.Round( rat*result.mod )
			end
			
			if CurTime() - result.time >= 6 then
				local rat = math.min( 3, CurTime() - result.time - 6 )/3
				width = width + rat*result.roll
				text = text .. "  |  Ascension Roll: " .. math.Round( rat*result.roll )
			end
			
			pan:Text( text, "wOS.DescriptionFont", x + ww*2, offset, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )				
			offset = offset + bh/2
			
			local frat = math.min( width / result.required, 1 )
			if CurTime() - result.time >= 9 then
				local rat = math.min( 1, CurTime() - result.time - 9 )
				pan:Text( ( frat == 1 and "[ ARTIFACT AWARDED ]" ) or "[ ARTIFACT LOST ]", "wOS.DescriptionFont", x + ww*2, offset, ( frat == 1 and Color( 0, 255, 0, 255*rat ) ) or Color( 255, 0, 0, 255*rat ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )				
			end
			
			offset = offset + bh/2
			pan:Rect( x, offset, ww*4, bh/2, Color( 0,0,0,0 ), color_white )
			pan:Mat( grad, x, offset, ww*4*frat, bh/2, Color( 148, 0, 211, 175 ) )
		end
		
		y = -18 + bh*6 + pady*8
		
		local image = wOS.ALCS.Runes[ "a" ]
		pan:Mat( image, x, y, ww, bh )	
		local _jp, _pr, _hov = pan:Button( "", "wOS.TitleFont", x, y, ww, bh, color_white, color_white )
		if _jp then
			net.Start( "wOS.ALCS.Dueling.AscendSpirit" )
			net.SendToServer()
	    elseif _hov then
			local speed = 0.1
			if not pan.SlideTimes then 
				pan.SlideTimes = CurTime() + speed
				surface.PlaySound( "wos/alcs/ui_slideout.wav" )
			end
			if pan.LastButt != lst then
				surface.PlaySound( "wos/alcs/ui_rollover.wav" )
				pan.LastButt = lst
			end
			local rat = math.Clamp( pan.SlideTimes - CurTime(), 0, speed )/speed
			pan:Rect( x + ww, y, ww*( 3 - 3*rat  ), bh, Color( 10, 10, 10, 255 ), color_white )
			pan:Text( "ASCEND SPIRIT", "wOS.TitleFont", x + ww*1.8*( 1 - rat  ), y + bh/2, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
			pan.LastHover = CurTime() + 0.01
	    end							
		lst = lst + 1
		
		y = y + bh + pady
		image = wOS.ALCS.Runes[ "x" ]
		pan:Mat( image, x, y, ww, bh )	
		local _jp, _pr, _hov = pan:Button( "", "wOS.TitleFont", x, y, ww, bh, color_white, color_white )
		if _jp then
			wOS.ALCS.Skills:ChangeCamFocus( "Duel-Overview" )
	    elseif _hov then
			local speed = 0.1
			if not pan.SlideTimes then 
				pan.SlideTimes = CurTime() + speed
				surface.PlaySound( "wos/alcs/ui_slideout.wav" )
			end
			if pan.LastButt != lst then
				surface.PlaySound( "wos/alcs/ui_rollover.wav" )
				pan.LastButt = lst
			end
			local rat = math.Clamp( pan.SlideTimes - CurTime(), 0, speed )/speed
			pan:Rect( x + ww, y, ww*( 3 - 3*rat  ), bh, Color( 10, 10, 10, 255 ), color_white )
			pan:Text( "GO BACK", "wOS.TitleFont", x + ww*2.1*( 1 - rat  ), y + bh/2, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
			pan.LastHover = CurTime() + 0.01
	    end							
		lst = lst + 1
		
		if pan.SlideTimes and pan.LastHover < CurTime() then
			pan.SlideTimes	= nil
			pan.LastButt = nil
		end
	
	end
	frontpane:SetUIScale( 10 )
	frontpane.Scaling = 0.025
	
	frontpane.CamPos = wOS.ALCS.Skills.Camera[ wOS.ALCS.Skills.CamFocus ].origin + forward*15
	frontpane.CamAng = wOS.ALCS.Skills.Camera[ wOS.ALCS.Skills.CamFocus ].angles + Angle( 0, -27, 0 )
	table.insert( wOS.ALCS.Skills.Menu.VGUI, frontpane )
	
	wOS.ALCS.Skills.CubeModels[1] = ClientsideModel( frontpane.Data.SpiritModel or LocalPlayer():GetModel() )
	wOS.ALCS.Skills.CubeModels[1]:SetPos( frontpane.CamPos + forward*100 - up*30 - right*40 )
	wOS.ALCS.Skills.CubeModels[1]:SetAngles( Angle( 0, 90, 0 ) )
	wOS.ALCS.Skills.CubeModels[1]:SetSequence( "pose_standing_01" )
	frontpane.PostRenders = function( pan )
		if not IsValid( wOS.ALCS.Skills.CubeModels[1] ) then return end
		wOS.ALCS.Skills.CubeModels[1]:FrameAdvance( 1 )
		if wOS.ALCS.Skills.CubeModels[1]:GetCycle() >= 0.99 and not pan.Ascending then
			wOS.ALCS.Skills.CubeModels[1]:SetCycle( 0 )
		end
	end
	
	

	backbutt.Renders = function( pan )
		local data = wOS.ALCS.Dueling.SpiritData[ wOS.ALCS.Dueling.DuelData.DuelSpirit ]
		if not data then return end
		local ww, hh = pan.SizeX, pan.SizeY
		local x = 10
		local y = -50
		
		local level = data.level
		local xp = data.experience
		local reqxp = frontpane.Data.MaxEnergy
		local lastxp = 0
		
		local rat = math.min( 1, xp/reqxp )

		pan:Text( "SPIRIT ENERGY", "wOS.CraftTitles", x, y, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP )
		
		y = y + hh*0.23
		
		pan:Mat( grad, x, y, ww*rat, hh*0.12, Color( 148, ( xp > reqxp and 25 + 25*math.sin( CurTime()*10 ) ) or 0, 211, 175 ) )
		pan:Rect( x, y, ww, hh*0.12, Color( 0,0,0,0 ), color_white )
		
		y = y + hh*0.06
		local text = lastxp
		pan:Text( " " .. text, "wOS.CraftDescriptions", x, y, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
	
		text = reqxp
		pan:Text( text .. " ", "wOS.CraftDescriptions", x + ww, y, color_white, TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER )
		pan:Text( "|", "wOS.CraftDescriptions", x + ww/2, y, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		
		y = y + hh*0.06
		pan:Text( "ASCENSION LEVEL " .. level, "wOS.CraftDescriptions", x, y, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP )
		
		pan:BlockUseBind()
	end
	backbutt:SetUIScale( 20 )
	backbutt.Scaling = 0.05
	
	local spos = wOS.ALCS.Skills.CubeModels[1]:GetPos()
	backbutt.CamPos = spos - wOS.ALCS.Skills.CubeModels[1]:GetRight()*30 + wOS.ALCS.Skills.CubeModels[1]:GetForward()*20 
	backbutt.CamAng = wOS.ALCS.Skills.Camera[ wOS.ALCS.Skills.CamFocus ].angles + Angle( 0, 0, -90 )
	table.insert( wOS.ALCS.Skills.Menu.VGUI, backbutt )		
	
end

wOS.ALCS.Skills.Camera[ "Duel-ViewSacrifices" ] = { origin = centerpoint - Vector( 45, 10, -30 ), angles = Angle( 0, 270, 0.000 ) }
wOS.ALCS.Skills.MenuLibrary[ "Duel-ViewSacrifices" ] = function()
	
	local forward = wOS.ALCS.Skills.Camera[ wOS.ALCS.Skills.CamFocus ].angles:Forward()
	local right = wOS.ALCS.Skills.Camera[ wOS.ALCS.Skills.CamFocus ].angles:Right()
	local up = wOS.ALCS.Skills.Camera[ wOS.ALCS.Skills.CamFocus ].angles:Up()
	
	local frontpane = tduiw.Create()
	frontpane.SizeX = 8
	frontpane.SizeY = 35
	frontpane.LeftCount = 1
	frontpane.RightCount = 5	
	frontpane.ShouldAcceptInputs = true
	frontpane.LastScrollSlot = 0
	frontpane.ScrollSlot = 0
	frontpane.Selected = 1
	frontpane.Offset = 0
	
	frontpane.Inventory = {}
	
	for slot, data in pairs( wOS.SaberInventory ) do
		local name = data
		local amount = 1
		if istable( data ) then
			name = data.Name
			amount = data.Amount or 1
		end
		if not wOS.ItemList[ name ] then continue end
		table.insert( frontpane.Inventory, { name = name, amount = amount, slot = slot } )
	end

	frontpane.Renders = function( pan )
		local ww, hh = pan.SizeX, pan.SizeY
		local bh = hh/7
		local pady = bh*0.05
		local x = 40 - ww*4
		local y = -26
		local lst = 0
		
		if #pan.Inventory > 6 then
			pan:Mat( upButton, x - ww*1.1, y, ww, hh*0.25 )
			local _jp, _pr, _hov = pan:Button( "", "wOS.TitleFont", x - ww*1.1, y, ww, hh*0.25, color_white, color_white )
			if _jp then
				if pan.Offset <= 0 then return end
				pan.Offset = pan.Offset - 1
				surface.PlaySound( "buttons/lightswitch2.wav" )
			elseif _hov then
				local speed = 0.1
				if pan.LastButt != lst then
					surface.PlaySound( "wos/alcs/ui_rollover.wav" )
					pan.LastButt = lst
				end
				pan.LastHover = CurTime() + 0.01
			end					
			pan:Mat( bufferBar, x - ww*1.1, y + hh*0.3, ww, hh*0.3 )	
			pan:Rect( x - ww*1.1, y + hh*0.3, ww, hh*0.3, Color( 0, 0, 0, 0 ), color_white )			
			pan:Mat( downButton, x - ww*1.1, y + hh*0.65, ww, hh*0.25 )
			local _jp, _pr, _hov = pan:Button( "", "wOS.TitleFont", x - ww*1.1, y + hh*0.65, ww, hh*0.25, color_white, color_white )			
			if _jp then
				if pan.Offset + 6 >= #pan.Inventory then return end
				pan.Offset = pan.Offset + 1
				surface.PlaySound( "buttons/lightswitch2.wav" )
			elseif _hov then
				local speed = 0.1
				if pan.LastButt != lst then
					surface.PlaySound( "wos/alcs/ui_rollover.wav" )
					pan.LastButt = lst
				end
				pan.LastHover = CurTime() + 0.01
			end							
		end
		
		for i = 1, 6 do
			local slot = i + pan.Offset
			if slot > #pan.Inventory then break end
			local dat = pan.Inventory[slot]
			local col = color_white

			pan:Text( dat.name, "wOS.TitleFont", x + ww*0.1, y + bh/2, col, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
			if dat.amount > 1 then
				pan:Text( "x" .. dat.amount, "wOS.TitleFont", x + ww*3.9, y + bh/2, col, TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER )
			end
			local _jp, _pr, _hov = pan:Button( "", "wOS.TitleFont", x, y, ww*4, bh, col, color_white )
			if _jp then
				pan.Selected = slot
			elseif _hov then
				local speed = 0.1
				if pan.LastButt != lst then
					surface.PlaySound( "wos/alcs/ui_rollover.wav" )
					pan.LastButt = lst
				end
				pan.LastHover = CurTime() + 0.01
			end	
			lst = lst + 1
			y = y + bh + pady			
		end
		
		if #pan.Inventory < 1 then
			pan:Rect( x, y, ww*4, bh*6 + pady*5, Color( 0, 0, 0, 0 ), color_white )
			pan:Text( "NO ITEMS AVAILABLE", "wOS.TitleFont", x + ww*2, y + bh*3 + pady*2.5, col, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )	
		end
		
		y = -26 + bh*6 + pady*6	
		
		image = wOS.ALCS.Runes[ "x" ]
		pan:Mat( image, x, y, ww, bh )	
		local _jp, _pr, _hov = pan:Button( "", "wOS.TitleFont", x, y, ww, bh, color_white, color_white )
		if _jp then
			wOS.ALCS.Skills:ChangeCamFocus( "Duel-Overview" )
	    elseif _hov then
			local speed = 0.1
			if not pan.SlideTimes then 
				pan.SlideTimes = CurTime() + speed
				surface.PlaySound( "wos/alcs/ui_slideout.wav" )
			end
			if pan.LastButt != lst then
				surface.PlaySound( "wos/alcs/ui_rollover.wav" )
				pan.LastButt = lst
			end
			local rat = math.Clamp( pan.SlideTimes - CurTime(), 0, speed )/speed
			pan:Rect( x + ww, y, ww*( 3 - 3*rat  ), bh, Color( 10, 10, 10, 255 ), color_white )
			pan:Text( "GO BACK", "wOS.TitleFont", x + ww*2.1*( 1 - rat  ), y + bh/2, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
			pan.LastHover = CurTime() + 0.01
	    end							
		lst = lst + 1
		
		if pan.SlideTimes and pan.LastHover < CurTime() then
			pan.SlideTimes	= nil
			pan.LastButt = nil
		end
	
	end
	frontpane:SetUIScale( 10 )
	frontpane.Scaling = 0.018
	
	frontpane.CamPos = wOS.ALCS.Skills.Camera[ wOS.ALCS.Skills.CamFocus ].origin + forward*15
	frontpane.CamAng = wOS.ALCS.Skills.Camera[ wOS.ALCS.Skills.CamFocus ].angles + Angle( 0, -27, 0 )
	table.insert( wOS.ALCS.Skills.Menu.VGUI, frontpane )
	
	local infopane = tduiw.Create()
	infopane.SizeX = 90
	infopane.SizeY = 35
	infopane.LeftCount = 1
	infopane.RightCount = 5	
	infopane.ShouldAcceptInputs = true
	infopane.Renders = function( pan )
		local ww, hh = pan.SizeX, pan.SizeY
		local x = 0
		local y = -hh*8
		local bh = hh*1.5

		pan:Text( "ENERGY COLLECTED", "wOS.TitleFont", -ww*2, hh*7, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_BOTTOM )
		pan:Text( wOS.ALCS.Dueling.DuelData.Sacrifices or 0, "wOS.TitleFont", -ww*1.9, hh*7 + bh/4, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )	
		pan:Text( wOS.ALCS.Config.Dueling.SacrificeRoll, "wOS.TitleFont", -ww*2 + ww*3.9, hh*7 + bh/4, color_white, TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER )
		pan:Text( ( wOS.ALCS.Config.Dueling.SacrificeRoll - ( wOS.ALCS.Dueling.DuelData.Sacrifices or 0 ) ) .. " UNTIL SUMMON", "wOS.TitleFont", ww*2, hh*7 + bh/2, color_white, TEXT_ALIGN_RIGHT, TEXT_ALIGN_TOP )
		local frat = math.min( wOS.ALCS.Dueling.DuelData.Sacrifices / wOS.ALCS.Config.Dueling.SacrificeRoll, 1 )
		pan:Rect( -ww*2, hh*7, ww*4, bh/2, Color( 0,0,0,0 ), color_white )
		pan:Mat( grad, -ww*2, hh*7, ww*4*frat, bh/2, Color( 148, 0, 211, 175 ) )
		
		local item = frontpane.Inventory[ frontpane.Selected ]
		if not item then return end
		local dat = wOS.ItemList[ item.name ]
		if not dat then return end
		pan:Text( dat.Name, "wOS.CraftDescriptions", x, y, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		pan:Text( dat.RarityName or "Common", "wOS.TitleFont", x, y + hh*0.7, dat.RarityColor or color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP )
		local rare = "No"
		if dat.Rarity then
			rare = ( dat.Rarity > 0 and ( 1 / ( dat.Rarity ) ) * 10 ) or "No"
		end
		pan:Text( rare .. " Sacrificial Energy", "wOS.TitleFont", x, y + hh*1.8, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )	
		
		y = hh*4
		local size = ww*4
		x = -size/2
		local lst = 0

		local image = wOS.ALCS.Runes[ "k" ]
		pan:Rect( x + size - ww, y, ww, bh, Color( 10, 10, 10, 255 ), Color( 0, 0, 0, 0 ) )
		pan:Mat( image, x + size - ww, y, ww, bh )	
		local _jp, _pr, _hov = pan:Button( "", "wOS.TitleFont", x + size - ww, y, ww, bh, color_white, color_white )
		if _jp then
			net.Start( "wOS.ALCS.Dueling.SacrificeItem" )
				net.WriteString( dat.Name )
			net.SendToServer()
		elseif _hov then
			local speed = 0.1
			if not pan.SlideTimes then 
				pan.SlideTimes = CurTime() + speed
				surface.PlaySound( "wos/alcs/ui_slideout.wav" )
			end
			if pan.LastButt != lst then
				surface.PlaySound( "wos/alcs/ui_rollover.wav" )
				pan.LastButt = lst
			end
			local rat = math.Clamp( pan.SlideTimes - CurTime(), 0, speed )/speed
			pan:Rect( x + size - ww, y, -1*size*0.5*( 1 - rat  ), bh, Color( 10, 10, 10, 255 ), color_white )
			pan:Text( "SACRIFICE", "wOS.TitleFont", x + size - size*0.5*( 1 - rat  ), y + bh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
			pan:Text( "REMOVES ITEM FROM INVENTORY", "wOS.DescriptionFont", x + size - size*0.5, y + bh*1.1*( 1 + rat ), Color( 255, 0, 0 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP )
			pan.LastHover = CurTime() + 0.01
	    end
		lst = lst + 1

		if pan.SlideTimes and pan.LastHover < CurTime() then
			pan.SlideTimes	= nil
			pan.LastButt = nil
		end
		
	end
	infopane.CamPos = wOS.ALCS.Skills.Camera[ wOS.ALCS.Skills.CamFocus ].origin + forward*70 - right*30
	infopane.CamAng = wOS.ALCS.Skills.Camera[ wOS.ALCS.Skills.CamFocus ].angles + Angle( 0, 0, 0 )
	table.insert( wOS.ALCS.Skills.Menu.VGUI, infopane )
	
	wOS.ALCS.Skills.CubeModels[1] = ClientsideModel( "models/props_lab/huladoll.mdl" )
	wOS.ALCS.Skills.CubeModels[1]:SetPos( frontpane.CamPos + forward*80 - up*5 - right*40 )
	frontpane.PostRenders = function( pan )
		local model = "models/props_lab/huladoll.mdl"
		if pan.Inventory[ pan.Selected ] then
			local name = pan.Inventory[ pan.Selected ].name
			if name then
				local item = wOS.ItemList[ name ]
				if item then
					if item.Model then
						model = item.Model
					end
				end
			end
		end
		local display = wOS.ALCS.Skills.CubeModels[1]
		if not IsValid( display ) then return end
		if display:GetModel() != model then
			display:SetModel( model )
		end
		local ang = display:GetAngles()
		ang:RotateAroundAxis( ang:Up(), FrameTime()*40 )
		display:SetAngles( ang )
	end
	
end
--addons/wos-grandmaster-einf/lua/wos/advswl/dueling/artsys/cl_net.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2020
	
	Contact: www.wiltostech.com
		----------------------------------------]]--








































































wOS = wOS or {}
wOS.ALCS = wOS.ALCS or {}
wOS.ALCS.Dueling = wOS.ALCS.Dueling or {}
wOS.ALCS.Dueling.Artifact = wOS.ALCS.Dueling.Artifact or {}
wOS.ALCS.Dueling.Artifact.List = wOS.ALCS.Dueling.Artifact.List or {}
wOS.ALCS.Dueling.Artifact.Backpack = wOS.ALCS.Dueling.Artifact.Backpack or {}

net.Receive( "wOS.ALCS.Dueling.SendPlayerArtifacts", function( len )

	local newtbl = net.ReadTable()
	wOS.ALCS.Dueling.Artifact.Backpack = wOS.ALCS.Dueling.Artifact.Backpack or {}
	table.Merge( wOS.ALCS.Dueling.Artifact.Backpack, newtbl )
	
end )

net.Receive( "wOS.ALCS.Dueling.SendArtifacts", function( len )

	local newtbl = net.ReadTable()

	wOS.ALCS.Dueling.Artifact.List = wOS.ALCS.Dueling.Artifact.List or {}
	table.Merge( wOS.ALCS.Dueling.Artifact.List, newtbl )
	
end )
--addons/wos-grandmaster-einf/lua/wos/advswl/execsys/loader/cl_loader.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2020
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--

wOS = wOS or {}
wOS.ALCS = wOS.ALCS or {}
wOS.ALCS.ExecSys = wOS.ALCS.ExecSys or {}

local dir = "wos/advswl/execsys"

include( dir .. "/core/cl_core.lua" )
include( dir .. "/core/cl_player_funcs.lua" )
include( dir .. "/core/cl_net.lua" )


--addons/wos-grandmaster-einf/lua/wos/advswl/storage/core/cl_core.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2020
	
	Contact: www.wiltostech.com
		----------------------------------------]]--

wOS = wOS or {}
wOS.ALCS = wOS.ALCS or {}
wOS.ALCS.Storage = wOS.ALCS.Storage or {}


--addons/wos-grandmaster-einf/lua/wos/advswl/storage/core/cl_net.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2020
	
	Contact: www.wiltostech.com
		----------------------------------------]]--








































































wOS = wOS or {}
wOS.ALCS = wOS.ALCS or {}
wOS.ALCS.Storage = wOS.ALCS.Storage or {}																																																																										

net.Receive( "wOS.ALCS.Storage.SendPlayerData", function()

	wOS.ALCS.Storage.Data = net.ReadTable()
	
end )

net.Receive( "wOS.ALCS.Storage.Refresh", function( len )

	wOS.ALCS.Skills:ChangeCamFocus( "Storage-ViewDeck" )

end )
--addons/wos-grandmaster-einf/lua/wos/advswl/trade/core/sh_core.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2020
	
	Contact: www.wiltostech.com
		----------------------------------------]]--

wOS = wOS or {}
wOS.ALCS = wOS.ALCS or {}
wOS.ALCS.GTN = wOS.ALCS.GTN or {}

--addons/wos-grandmaster-einf/lua/wos/advswl/trade/core/cl_core.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2020
	
	Contact: www.wiltostech.com
		----------------------------------------]]--

wOS = wOS or {}
wOS.ALCS = wOS.ALCS or {}
wOS.ALCS.GTN = wOS.ALCS.GTN or {}
wOS.ALCS.GTN.Modes = {}
wOS.ALCS.GTN.Modes.AUCTIONS = 0
wOS.ALCS.GTN.Modes.TRADES = 1
wOS.ALCS.GTN.Modes.MYLISTINGS = 3

local blur = Material 'pp/blurscreen'
local function blurpanel (panel, amount )
    local x, y = panel:LocalToScreen(0, 0)
    surface.SetDrawColor(255, 255, 255)
    surface.SetMaterial(blur)
    for i = 1, 3 do
        blur:SetFloat('$blur', (i / 3) * (amount or 6))
        blur:Recompute()
        render.UpdateScreenEffectTexture()
        surface.DrawTexturedRect(x * -1, y * -1, ScrW(), ScrH())
    end
end

function wOS.ALCS.GTN:CreateGTNPanel( mode )
	if self.Menu then
		self.Menu:Remove()
		self.Menu = nil
	end
	
	gui.EnableScreenClicker( true )

	self.Menu = vgui.Create( "DFrame" )
	self.Menu:SetDraggable( true )
	self.Menu:ShowCloseButton( false )
	self.Menu:SetTitle( "" )
	local sx, sy = wOS.ALCS.Skills.Menu:GetSize()
	self.Menu:SetSize( sx, sy )
	local px, py = wOS.ALCS.Skills.Menu:GetPos()
	self.Menu:SetPos( px, py )
	self.Menu.Paint = function( pan, ww, hh )
		draw.RoundedBox( 0, 0, 0, ww*0.985, hh*0.02, Color( 255, 255, 255, 155 ) )
		draw.RoundedBox( 0, ww*0.985, 0, ww*0.015, hh*0.02, Color( 255, 0, 0 ) )
	end	


	local mw, mh = self.Menu:GetSize()
	
	local button = vgui.Create( "DButton", self.Menu )
	button:SetSize( mw*0.015, mh*0.02 )
	button:SetPos( mw*0.985, 0 )
	button:SetText( "" )
	button.DoClick = function()
		wOS.ALCS.Skills:CleanAllMenus()
		self.Menu:Remove()
		self.Menu = nil
	end	
	button.Paint = nil

	local p_think = self.Menu.Think
	self.Menu.Think = function( pan )
		p_think( pan )
		if not vgui.CursorVisible() then
			gui.EnableScreenClicker( true )
		end
		if not LocalPlayer():Alive() then
			button:DoClick()
			return
		end
	end

	self.DataTab = vgui.Create( "DPanel", self.Menu )
	self.DataTab:SetPos( 0, mh*0.02 )
	self.DataTab:SetSize( mw, mh*0.98 )
	self.DataTab.Paint = function( pan, ww, hh )
		blurpanel( pan )
		draw.RoundedBox( 3, 0, 0, ww, hh, Color( 25, 25, 25, 245 ) )
	end

	if mode == wOS.ALCS.GTN.Modes.AUCTIONS then
		self:ShowAuctionHouse()
	elseif mode == wOS.ALCS.GTN.Modes.TRADES then
		self:ShowTradeHouse()
	else
		self:ShowMyListings()
	end

end

local creation_panel
local function OpenCreationPanel()

	if IsValid( creation_panel ) then
		creation_panel:Remove()
		creation_panel = nil
	end

	creation_panel = vgui.Create( "DPanel" )
	creation_panel:SetSize( ScrW()*0.4, ScrH()*0.4 )
	creation_panel:Center()
	creation_panel.Paint = function( pan ,ww, hh )
		blurpanel( pan )
		draw.RoundedBox( 3, 0, 0, ww, hh, Color( 25, 25, 25, 245 ) )
		surface.SetDrawColor( color_white )
		surface.DrawOutlinedRect(0,0,ww,hh) 	
		surface.DrawOutlinedRect(ww*0.38, hh*0.02, ww*0.6, hh*0.47 ) 
		surface.DrawOutlinedRect(ww*0.38, hh*0.51, ww*0.6, hh*0.47 ) 			
	end
	creation_panel.Think = function( pan )
		if not IsValid( wOS.ALCS.GTN.Menu ) or not IsValid( wOS.ALCS.GTN.DataTab ) then
			pan:Remove()
		end
	end

	local cw, ch = creation_panel:GetSize()

	local InvenList = vgui.Create( "DListView", creation_panel )
	InvenList:SetMultiSelect( false )
	InvenList:AddColumn( "Slot" )
	InvenList:AddColumn( "Item" )
	InvenList:AddColumn( "Amount" )
	InvenList:SetPos( cw*0.02, ch*0.02 )
	InvenList:SetSize( cw*0.34, ch*0.84 )
	for i=1, wOS.ALCS.Config.Crafting.MaxInventorySlots do
		local dat = wOS.SaberInventory[i]
		if not dat then continue end
		if dat.Type == WOSTYPE.RAWMATERIAL then continue end
		local name = dat
		local amount = 1
		if istable( dat ) then
			name = dat.Name
			amount = dat.Amount or 1
		end
		if name == "Empty" then continue end
		InvenList:AddLine( i, name, amount )
	end

	local close = vgui.Create( "DButton", creation_panel )
	close:SetPos( cw*0.02, ch*0.88 )
	close:SetSize( cw*0.34, ch*0.08 )
	close:SetText( "" )
	close.Paint = function( pan, ww, hh )
		draw.RoundedBox( 5, 0, 0, ww, hh, ( pan:IsDown() and Color( 0, 55, 155, 155 ) ) or Color( 155, 155, 155, 155 ) )
		draw.SimpleText( "CANCEL CREATION", "wOS.ALCS.DescFont", ww/2, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	close.DoClick = function( pan )
		creation_panel:Remove()
		creation_panel = nil
	end		

	local dock1 = vgui.Create( "DPanel",creation_panel )
	dock1:SetPos( cw*0.4, ch*0.04 )
	dock1:SetSize( cw*0.56, ch*0.43 )
	dock1.Paint = nil

	local dw, dh = dock1:GetSize()

	local InvenList2 = vgui.Create( "DListView", dock1 )
	InvenList2:SetMultiSelect( false )
	InvenList2:AddColumn( "Item" )
	InvenList2:SetPos( 0, 0 )
	InvenList2:SetSize( dw, dh*0.8 )
	local lst = {}
	for item, dat in pairs( wOS.ItemList ) do
		if dat.Type == WOSTYPE.RAWMATERIAL then continue end
		lst[ #lst + 1 ] = item
	end
	table.sort(lst)
	for _, item in pairs( lst ) do
		InvenList2:AddLine( item )
	end	

	local createt = vgui.Create( "DButton", dock1 )
	createt:SetPos( 0, dh*0.81 )
	createt:SetSize( dw, dh*0.19 )
	createt:SetText( "" )
	createt.Paint = function( pan, ww, hh )
		draw.RoundedBox( 5, 0, 0, ww, hh, ( pan:IsDown() and Color( 0, 55, 155, 155 ) ) or Color( 155, 155, 155, 155 ) )
		draw.SimpleText( "CREATE TRADE LISTING", "wOS.ALCS.DescFont", ww/2, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	createt.DoClick = function( pan )
		local sel = InvenList:GetSelectedLine()
		if not sel or sel < 1 then return end
		local dat = InvenList:GetLine( sel )
		if not dat then return end
		local slot = dat:GetColumnText( 1 )
		if not slot then return end

		local sel = InvenList2:GetSelectedLine()
		if not sel or sel < 1 then return end
		local dat = InvenList2:GetLine( sel )
		if not dat then return end
		local item = dat:GetColumnText( 1 )
		if not item or #item < 1 then return end

		net.Start( "wOS.ALCS.GTN.CreateTrade" )
			net.WriteInt( tonumber( slot ), 32 )
			net.WriteString( item )
		net.SendToServer()
		creation_panel:Remove()
	end		

	local dock2 = vgui.Create( "DPanel",creation_panel )
	dock2:SetPos( cw*0.4, ch*0.53 )
	dock2:SetSize( dw, dh )
	dock2.Paint = nil

	local cx, cy = creation_panel:GetPos()
	local dx, dy = dock2:GetPos()

	dx = cx + dx
	dy = cy + dy


	local StartBkd = vgui.Create( "DTextEntry", dock2 )
	StartBkd:MakePopup()
	StartBkd:SetPos( dx + dw*0.7, dy )
	StartBkd:SetSize( dw*0.3, dh*0.15 )
	StartBkd:SetText( wOS.ALCS.Config.GTN.MinimumStart )
	StartBkd:SetNumeric( true )
	
	local StartLabel = vgui.Create( "DLabel", dock2 )
	StartLabel:SetPos( 0, 0 )
	StartLabel:SetSize( dw*0.6, dh*0.15 )
	StartLabel:SetText( "Starting Bid:" )
	StartLabel:SetFont( "wOS.AdminMain" )

	local BuyBkd = vgui.Create( "DTextEntry", dock2 )
	BuyBkd:MakePopup()
	BuyBkd:SetPos( dx + dw*0.7, dy + dh*0.3 )
	BuyBkd:SetSize( dw*0.3, dh*0.15 )
	BuyBkd:SetText( wOS.ALCS.Config.GTN.MinimumStart )
	BuyBkd:SetNumeric( true )
	
	local BuyLabel = vgui.Create( "DLabel", dock2 )
	BuyLabel:SetPos( 0, dh*0.3 )
	BuyLabel:SetSize( dw*0.6, dh*0.15 )
	BuyLabel:SetText( "Buy Now Price:" )
	BuyLabel:SetFont( "wOS.AdminMain" )


	local BuyTog = vgui.Create( "DCheckBox", dock2 )
	BuyTog:SetPos( dw - dh*0.15, dh*0.6 )
	BuyTog:SetSize( dh*0.15, dh*0.15 )
	
	local TogLabel = vgui.Create( "DLabel", dock2 )
	TogLabel:SetPos( 0, dh*0.6 )
	TogLabel:SetSize( dw*0.6, dh*0.15 )
	TogLabel:SetText( "Enable Buy Now:" )
	TogLabel:SetFont( "wOS.AdminMain" )


	local createa = vgui.Create( "DButton", dock2 )
	createa:SetPos( 0, dh*0.81 )
	createa:SetSize( dw, dh*0.19 )
	createa:SetText( "" )
	createa.Paint = function( pan, ww, hh )
		draw.RoundedBox( 5, 0, 0, ww, hh, ( pan:IsDown() and Color( 0, 55, 155, 155 ) ) or Color( 155, 155, 155, 155 ) )
		draw.SimpleText( "CREATE AUCTION LISTING", "wOS.ALCS.DescFont", ww/2, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	createa.DoClick = function( pan )

		local sel = InvenList:GetSelectedLine()
		if not sel or sel < 1 then return end
		local dat = InvenList:GetLine( sel )
		if not dat then return end
		local slot = dat:GetColumnText( 1 )
		if not slot then return end

		local start = StartBkd:GetText()
		if #start < 1 then return end

		local buynow = BuyBkd:GetText()
		if #buynow < 1 then return end

		net.Start("wOS.ALCS.GTN.CreateAuction")
			net.WriteInt( slot, 32 )
			net.WriteInt( tonumber( start ), 32 )
			net.WriteBool( BuyTog:GetChecked() )
			net.WriteInt( tonumber( buynow ), 32 )
		net.SendToServer()
		creation_panel:Remove()
	end
	
end

function wOS.ALCS.GTN:ShowMyListings()
	net.Start( "wOS.ALCS.GTN.RequestMyListings" )
	net.SendToServer()
	self.DataTab:Clear()
 	self.DataTab.SelectedID = 0

	local mw, mh = self.DataTab:GetSize()
	local padx, pady = mh*0.025, mh*0.025 
	local toptab = vgui.Create( "DPanel", self.DataTab )
	toptab:SetPos( padx, pady )
	toptab:SetSize( mw*0.25, mh - 2*pady )
	toptab.Paint = function( pan, ww, hh )
		surface.SetDrawColor( color_white )
		surface.DrawOutlinedRect( ww*0.05, hh*0.075, ww*0.9, ww*0.9 )
		surface.DrawOutlinedRect( 0, 0, ww, hh )
		surface.DrawLine( ww*0.05, hh*0.83, ww*0.95, hh*0.83 )
		surface.DrawLine( ww*0.05, hh*0.74, ww*0.95, hh*0.74 )

		if self.DataTab.SelectedID > 0 then
			surface.DrawLine( ww*0.05, hh*0.535, ww*0.95, hh*0.535 )
			surface.DrawLine( ww*0.05, hh*0.645, ww*0.95, hh*0.645 )
			local tbl = ( self.DataTab.Trade and self.BufferInfo.Data.Trades ) or self.BufferInfo.Data.Auctions
			tbl = tbl or {}
			local text = ( self.DataTab.Trade and "TRADE" ) or "AUCTION"
			local dat = tbl[ self.DataTab.SelectedID ]
			if dat then
				draw.SimpleText( text .. " IDENTIFICATION " .. dat.ID, "wOS.AdminFont", ww/2, hh*0.01, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP )
				draw.SimpleText( "ENDS " .. dat.Expiration, "wOS.ALCS.DescFont", ww/2, hh*0.04, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP )
				if self.DataTab.Trade then
					local itemd = wOS.ItemList[ dat.Item ]
					draw.SimpleText( dat.Item, "wOS.ALCS.DescFont", ww/2, hh*0.47, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP )
					draw.SimpleText( ( itemd and itemd.Description ) or "ITEM DATA NOT FOUND", "wOS.ALCS.DescFont", ww/2, hh*0.5, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP )
					
					itemd = wOS.ItemList[ dat.RequestedItem ]
					draw.SimpleText( dat.RequestedItem, "wOS.ALCS.DescFont", ww/2, hh*0.565, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP )
					draw.SimpleText( ( itemd and itemd.Description ) or "ITEM DATA NOT FOUND", "wOS.ALCS.DescFont", ww/2, hh*0.595, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP )
				else
					local itemd = wOS.ItemList[ dat.Item ]
					draw.SimpleText( "FOR " .. dat.Item, "wOS.ALCS.DescFont", ww/2, hh*0.47, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP )
					draw.SimpleText( ( itemd and itemd.Description ) or "ITEM DATA NOT FOUND", "wOS.ALCS.DescFont", ww/2, hh*0.5, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP )

					local txt =  ( tonumber( dat.BuyNowPrice ) != 0 and dat.BuyNowPrice ) or "N/A"
					draw.SimpleText( "BUY NOW PRICE: " ..txt , "wOS.ALCS.DescFont", ww/2, hh*0.55, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP )
					draw.SimpleText( "CURRENT BID: " .. dat.CurrentBid, "wOS.ALCS.DescFont", ww/2, hh*0.58, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP )
					draw.SimpleText( "BIDDER ID: " .. dat.BidderSteamID, "wOS.ALCS.DescFont", ww/2, hh*0.61, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP )
				end
			else
				draw.SimpleText( text .. " IDENTIFICATION INVALID", "wOS.AdminFont", ww/2, hh*0.02, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP )
				draw.SimpleText( "ERROR", "wOS.ALCS.DescFont", ww/2, hh*0.47, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP )
				draw.SimpleText( "ERROR", "wOS.ALCS.DescFont", ww/2, hh*0.5, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP )
				draw.SimpleText( "ERROR", "wOS.ALCS.DescFont", ww/2, hh*0.55, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP )
				draw.SimpleText( "ERROR", "wOS.ALCS.DescFont", ww/2, hh*0.58, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP )
				draw.SimpleText( "ERROR", "wOS.ALCS.DescFont", ww/2, hh*0.61, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP )
			end
		else
			draw.SimpleText( "NO LISTING SELECTED", "wOS.AdminFont", ww/2, hh*0.02, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP )
		end

	end

	local tw, th = toptab:GetSize()

	local create = vgui.Create( "DButton", toptab )
	create:SetPos( tw*0.52, th*0.9 - tw*0.1 )
	create:SetSize( tw*0.43, th*0.05 )
	create:SetText( "" )
	create.Paint = function( pan, ww, hh )
		draw.RoundedBox( 5, 0, 0, ww, hh, ( pan:IsDown() and Color( 0, 55, 155, 155 ) ) or Color( 155, 155, 155, 155 ) )
		draw.SimpleText( "CREATE LISTING", "wOS.ALCS.DescFont", ww/2, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	create.DoClick = function( pan )
		OpenCreationPanel()
	end	

	local refresh = vgui.Create( "DButton", toptab )
	refresh:SetPos( tw*0.05, th*0.9 - tw*0.1 )
	refresh:SetSize( tw*0.43, th*0.05 )
	refresh:SetText( "" )
	refresh.Paint = function( pan, ww, hh )
		draw.RoundedBox( 5, 0, 0, ww, hh, ( pan:IsDown() and Color( 0, 55, 155, 155 ) ) or Color( 155, 155, 155, 155 ) )
		draw.SimpleText( "REFRESH LISTINGS", "wOS.ALCS.DescFont", ww/2, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	refresh.DoClick = function( pan )
		self:ShowMyListings()
	end	

	local close = vgui.Create( "DButton", toptab )
	close:SetPos( tw*0.05, th*0.95 - tw*0.05 )
	close:SetSize( tw*0.9, th*0.05 )
	close:SetText( "" )
	close.Paint = function( pan, ww, hh )
		draw.RoundedBox( 5, 0, 0, ww, hh, ( pan:IsDown() and Color( 0, 55, 155, 155 ) ) or Color( 155, 155, 155, 155 ) )
		draw.SimpleText( "CLOSE MENU", "wOS.ALCS.DescFont", ww/2, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	close.DoClick = function( pan )
		wOS.ALCS.Skills.Menu:SetVisible( true )
		self.Menu:Remove()
		self.Menu = nil
	end	

	local remove = vgui.Create( "DButton", toptab )
	remove:SetPos( tw*0.05, th*0.69 - tw*0.05 )
	remove:SetSize( tw*0.9, th*0.05 )
	remove:SetText( "" )
	remove.Paint = function( pan, ww, hh )
		draw.RoundedBox( 5, 0, 0, ww, hh, ( pan:IsDown() and Color( 0, 55, 155, 155 ) ) or Color( 155, 155, 155, 155 ) )
		draw.SimpleText( "REMOVE THIS LISTING", "wOS.ALCS.DescFont", ww/2, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	remove.DoClick = function( pan )
		if self.DataTab.SelectedID < 1 then return end
		local tbl = ( self.DataTab.Trade and self.BufferInfo.Data.Trades ) or self.BufferInfo.Data.Auctions
		tbl = tbl or {}
		local dat =  tbl[ self.DataTab.SelectedID ]
		if not dat then return end
		net.Start( "wOS.ALCS.GTN.RemoveListing" )
			net.WriteBool( self.DataTab.Trade )
			net.WriteInt( dat.ID, 32 )
		net.SendToServer()
	end	
	
	local modelpanel = vgui.Create( "DModelPanel", toptab )
	modelpanel:SetSize( tw*0.9, tw*0.9 )	
	modelpanel:SetPos( tw*0.05, th*0.075 )	

	function modelpanel.ApplyNewModel( pan, model )
		local Iconent = ClientsideModel("borealis/barrel.mdl")
		Iconent:SetAngles(Angle(0,0,0))
		Iconent:SetPos(Vector(0,0,0))
		Iconent:Spawn()
		Iconent:Activate()	
		Iconent:SetModel( model )
		local center = Iconent:OBBCenter()
		local dist = Iconent:BoundingRadius()*1.6		
		pan:SetModel( model )
		pan:SetLookAt( center )
		pan:SetCamPos( center + Vector( dist, dist, 0 ) )	
		Iconent:Remove()
	end			
	modelpanel:ApplyNewModel( "models/props_lab/huladoll.mdl" )

	toptab.Think = function( pan )
		if self.DataTab.SelectedID < 1 then 
			remove:SetVisible( false )
		else
			remove:SetVisible( true )
		end
	end

	local sidetab = vgui.Create( "DPanel", self.DataTab )
	sidetab:SetPos( 2*padx + mw*0.25, pady )
	sidetab:SetSize( mw*0.75 - 3*padx, mh - 2*pady )
	sidetab.Paint = function( pan, ww, hh )
		surface.SetDrawColor( color_white )
		surface.DrawOutlinedRect( 0, 0, ww, hh )
	end
	
	local sw, sh = sidetab:GetSize()

	local columns = vgui.Create( "DPanel", sidetab )
	columns:SetSize( sw, sh*0.07 )
	columns.Paint = function( pan, ww, hh )

		if not self.BufferInfo.Data then return end
		if not self.BufferInfo.Data.Trades then return end
		if self.BufferInfo.LastUpdated + 2 > CurTime() then return end

		surface.SetDrawColor( color_white )
		surface.DrawOutlinedRect( 0, 0, ww, hh )

		draw.SimpleText( "ID", "wOS.AdminFont", ww*0.05, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		surface.DrawLine( ww*0.1, 0, ww*0.1, hh )

		if self.DataTab.Trade then
			draw.SimpleText( "Offered Item Name", "wOS.AdminFont", ww*0.325, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
			surface.DrawLine( ww*0.55, 0, ww*0.55, hh )
			draw.SimpleText( "Requested Item Name", "wOS.AdminFont", ww*0.775, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		else
			draw.SimpleText( "Item Name", "wOS.AdminFont", ww*0.3, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
			surface.DrawLine( ww*0.5, 0, ww*0.5, hh )
			draw.SimpleText( "Buy Now Price", "wOS.AdminFont", ww*0.6, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
			surface.DrawLine( ww*0.7, 0, ww*0.7, hh )
			draw.SimpleText( "Current Bid", "wOS.AdminFont", ww*0.85, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		end

	end

	local listing_list = vgui.Create( "DScrollPanel", sidetab )
	listing_list:SetPos( 0, sh*0.07 )
	listing_list:SetSize( sw, sh*0.93 )
	listing_list.Paint = nil
	local sbar = listing_list:GetVBar()
	sbar.Paint = nil
	sbar.btnUp.Paint = nil
	sbar.btnDown.Paint = nil
	sbar.btnGrip.Paint = nil
	listing_list.Refresh = function( pan, tbl )
		pan:Clear()
		local offset = 0
		local color_shift = false
		local bh = pan:GetTall()*0.07
		
		for num, dat in ipairs( tbl ) do
			local info_panel = vgui.Create( "DButton", pan )
			info_panel:SetPos( 0, offset )
			info_panel:SetSize( sw, bh )
			info_panel:SetText( "" )
			info_panel.Selectable = num
			info_panel.Swap = color_shift
			info_panel.Paint = function( p, ww, hh )
				local col = ( p.Swap and Color( 125, 125, 125 ) ) or Color( 55, 55, 55 )
				if self.DataTab.SelectedID == p.Selectable then
					col = Color( 25, 25, 125 )
				end
				draw.RoundedBox( 0, 0, 0, ww, hh, col )

				surface.SetDrawColor( color_white )
				surface.DrawOutlinedRect(0, 0, ww, hh)

				draw.SimpleText( dat.ID, "wOS.ALCS.DescFont", ww*0.05, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
				surface.DrawLine( ww*0.1, 0, ww*0.1, hh )
				if self.DataTab.Trade then
					draw.SimpleText( dat.Item, "wOS.ALCS.DescFont", ww*0.325, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
					surface.DrawLine( ww*0.55, 0, ww*0.55, hh )
					draw.SimpleText( dat.RequestedItem, "wOS.ALCS.DescFont", ww*0.775, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
				else
					draw.SimpleText( dat.Item, "wOS.ALCS.DescFont", ww*0.3, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
					surface.DrawLine( ww*0.5, 0, ww*0.5, hh )
					draw.SimpleText( ( tonumber( dat.BuyNowPrice ) != 0 and dat.BuyNowPrice ) or "N/A", "wOS.ALCS.DescFont", ww*0.6, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
					surface.DrawLine( ww*0.7, 0, ww*0.7, hh )
					draw.SimpleText( dat.CurrentBid, "wOS.ALCS.DescFont", ww*0.85, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
				end
		
			end
			info_panel.DoClick = function( p )
				self.DataTab.SelectedID = p.Selectable
				local item_m = wOS.ItemList[ dat.Item ]
				local model = "models/props_lab/huladoll.mdl"
				if item_m then model = item_m.Model end
				modelpanel:ApplyNewModel( model )
			end
			color_shift = !color_shift
			offset = offset + bh
		end
		
	end

	local showtrade = vgui.Create( "DButton", toptab )
	showtrade:SetPos( tw*0.05, th*0.78 - tw*0.05 )
	showtrade:SetSize( tw*0.43, th*0.05 )
	showtrade:SetText( "" )
	showtrade.Paint = function( pan, ww, hh )
		if not self.BufferInfo.Data then return end
		if not self.BufferInfo.LastUpdated then return end
		if self.BufferInfo.LastUpdated + 2 > CurTime() then return end
		draw.RoundedBox( 5, 0, 0, ww, hh, ( pan:IsDown() and Color( 0, 55, 155, 155 ) ) or Color( 155, 155, 155, 155 ) )
		draw.SimpleText( "SHOW TRADES", "wOS.ALCS.DescFont", ww/2, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	showtrade.DoClick = function( pan )
		if not self.BufferInfo.Data then return end
		if not self.BufferInfo.LastUpdated then return end
		if self.BufferInfo.LastUpdated + 2 > CurTime() then return end
		self.DataTab.Trade = true
		self.DataTab.SelectedID = 0
		modelpanel:ApplyNewModel( "models/props_lab/huladoll.mdl" )
		listing_list:Refresh( self.BufferInfo.Data.Trades or {} )
	end	

	local showauct = vgui.Create( "DButton", toptab )
	showauct:SetPos( tw*0.52, th*0.78 - tw*0.05 )
	showauct:SetSize( tw*0.43, th*0.05 )
	showauct:SetText( "" )
	showauct.Paint = function( pan, ww, hh )
		if not self.BufferInfo.Data then return end
		if not self.BufferInfo.LastUpdated then return end
		if self.BufferInfo.LastUpdated + 2 > CurTime() then return end
		draw.RoundedBox( 5, 0, 0, ww, hh, ( pan:IsDown() and Color( 0, 55, 155, 155 ) ) or Color( 155, 155, 155, 155 ) )
		draw.SimpleText( "SHOW AUCTIONS", "wOS.ALCS.DescFont", ww/2, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	showauct.DoClick = function( pan )
		if not self.BufferInfo.Data then return end
		if not self.BufferInfo.LastUpdated then return end
		if self.BufferInfo.LastUpdated + 2 > CurTime() then return end

		self.DataTab.Trade = nil
		self.DataTab.SelectedID = 0
		modelpanel:ApplyNewModel( "models/props_lab/huladoll.mdl" )
		listing_list:Refresh( self.BufferInfo.Data.Auctions or {} )
	end	

	function self:RefreshMenu()
		modelpanel:ApplyNewModel( "models/props_lab/huladoll.mdl" )
		self.DataTab.SelectedID = 0
		if self.DataTab.Trade then
			listing_list:Refresh( self.BufferInfo.Data.Trades or {} )
		else
			listing_list:Refresh( self.BufferInfo.Data.Auctions or {} )
		end
	end

end

function wOS.ALCS.GTN:ShowAuctionHouse()
	net.Start( "wOS.ALCS.GTN.RequestAuctions" )
	net.SendToServer()
	self.DataTab:Clear()
 	self.DataTab.SelectedID = 0

	local mw, mh = self.DataTab:GetSize()
	local padx, pady = mh*0.025, mh*0.025 
	local toptab = vgui.Create( "DPanel", self.DataTab )
	toptab:SetPos( padx, pady )
	toptab:SetSize( mw*0.25, mh - 2*pady )
	toptab.Paint = function( pan, ww, hh )
		surface.SetDrawColor( color_white )
		surface.DrawOutlinedRect( ww*0.05, hh*0.075, ww*0.9, ww*0.9 )
		surface.DrawOutlinedRect( 0, 0, ww, hh )
		surface.DrawLine( ww*0.05, hh*0.83, ww*0.95, hh*0.83 )


		if self.DataTab.SelectedID > 0 then
			surface.DrawLine( ww*0.05, hh*0.74, ww*0.95, hh*0.74 )
			surface.DrawLine( ww*0.05, hh*0.535, ww*0.95, hh*0.535 )
			local tbl = self.BufferInfo.Data
			tbl = tbl or {}
			local text = "AUCTION"
			local dat = tbl[ self.DataTab.SelectedID ]
			if dat then
				draw.SimpleText( text .. " IDENTIFICATION " .. dat.ID, "wOS.AdminFont", ww/2, hh*0.01, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP )
				draw.SimpleText( "ENDS " .. dat.Expiration, "wOS.ALCS.DescFont", ww/2, hh*0.04, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP )
				local itemd = wOS.ItemList[ dat.Item ]
				draw.SimpleText( dat.Item, "wOS.ALCS.DescFont", ww/2, hh*0.47, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP )
				draw.SimpleText( ( itemd and itemd.Description ) or "ITEM DATA NOT FOUND", "wOS.ALCS.DescFont", ww/2, hh*0.5, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP )

				local txt =  ( tonumber( dat.BuyNowPrice ) != 0 and dat.BuyNowPrice ) or "N/A"
				draw.SimpleText( "BUY NOW PRICE: " ..txt , "wOS.ALCS.DescFont", ww/2, hh*0.55, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP )
				draw.SimpleText( "CURRENT BID: " .. dat.CurrentBid, "wOS.ALCS.DescFont", ww/2, hh*0.58, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP )
				draw.SimpleText( "BIDDER ID: " .. dat.BidderSteamID, "wOS.ALCS.DescFont", ww/2, hh*0.61, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP )

				if txt != "N/A" then
					surface.DrawLine( ww*0.05, hh*0.645, ww*0.95, hh*0.645 )
				end

			else
				draw.SimpleText( text .. " IDENTIFICATION INVALID", "wOS.AdminFont", ww/2, hh*0.02, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP )
				draw.SimpleText( "ERROR", "wOS.ALCS.DescFont", ww/2, hh*0.47, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP )
				draw.SimpleText( "ERROR", "wOS.ALCS.DescFont", ww/2, hh*0.5, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP )
				draw.SimpleText( "ERROR", "wOS.ALCS.DescFont", ww/2, hh*0.55, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP )
				draw.SimpleText( "ERROR", "wOS.ALCS.DescFont", ww/2, hh*0.58, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP )
				draw.SimpleText( "ERROR", "wOS.ALCS.DescFont", ww/2, hh*0.61, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP )
			end
		else
			draw.SimpleText( "NO LISTING SELECTED", "wOS.AdminFont", ww/2, hh*0.02, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP )
		end

	end

	local tw, th = toptab:GetSize()

	local refresh = vgui.Create( "DButton", toptab )
	refresh:SetPos( tw*0.05, th*0.9 - tw*0.1 )
	refresh:SetSize( tw*0.9, th*0.05 )
	refresh:SetText( "" )
	refresh.Paint = function( pan, ww, hh )
		draw.RoundedBox( 5, 0, 0, ww, hh, ( pan:IsDown() and Color( 0, 55, 155, 155 ) ) or Color( 155, 155, 155, 155 ) )
		draw.SimpleText( "REFRESH LISTINGS", "wOS.ALCS.DescFont", ww/2, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	refresh.DoClick = function( pan )
		self:ShowAuctionHouse()
	end	

	local close = vgui.Create( "DButton", toptab )
	close:SetPos( tw*0.05, th*0.95 - tw*0.05 )
	close:SetSize( tw*0.9, th*0.05 )
	close:SetText( "" )
	close.Paint = function( pan, ww, hh )
		draw.RoundedBox( 5, 0, 0, ww, hh, ( pan:IsDown() and Color( 0, 55, 155, 155 ) ) or Color( 155, 155, 155, 155 ) )
		draw.SimpleText( "CLOSE MENU", "wOS.ALCS.DescFont", ww/2, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	close.DoClick = function( pan )
		wOS.ALCS.Skills.Menu:SetVisible( true )
		self.Menu:Remove()
		self.Menu = nil
	end	
	
	local modelpanel = vgui.Create( "DModelPanel", toptab )
	modelpanel:SetSize( tw*0.9, tw*0.9 )	
	modelpanel:SetPos( tw*0.05, th*0.075 )	

	function modelpanel.ApplyNewModel( pan, model )
		local Iconent = ClientsideModel("borealis/barrel.mdl")
		Iconent:SetAngles(Angle(0,0,0))
		Iconent:SetPos(Vector(0,0,0))
		Iconent:Spawn()
		Iconent:Activate()	
		Iconent:SetModel( model )
		local center = Iconent:OBBCenter()
		local dist = Iconent:BoundingRadius()*1.6		
		pan:SetModel( model )
		pan:SetLookAt( center )
		pan:SetCamPos( center + Vector( dist, dist, 0 ) )	
		Iconent:Remove()
	end			
	modelpanel:ApplyNewModel( "models/props_lab/huladoll.mdl" )

	local sidetab = vgui.Create( "DPanel", self.DataTab )
	sidetab:SetPos( 2*padx + mw*0.25, pady )
	sidetab:SetSize( mw*0.75 - 3*padx, mh - 2*pady )
	sidetab.Paint = function( pan, ww, hh )
		surface.SetDrawColor( color_white )
		surface.DrawOutlinedRect( 0, 0, ww, hh )
	end
	
	local sw, sh = sidetab:GetSize()

	local columns = vgui.Create( "DPanel", sidetab )
	columns:SetSize( sw, sh*0.07 )
	columns.Paint = function( pan, ww, hh )

		if not self.BufferInfo.Data then return end
		if self.BufferInfo.LastUpdated + 2 >= CurTime() then return end

		surface.SetDrawColor( color_white )
		surface.DrawOutlinedRect( 0, 0, ww, hh )

		draw.SimpleText( "ID", "wOS.AdminFont", ww*0.05, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		surface.DrawLine( ww*0.1, 0, ww*0.1, hh )

		draw.SimpleText( "Item Name", "wOS.AdminFont", ww*0.25, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		surface.DrawLine( ww*0.4, 0, ww*0.4, hh )

		draw.SimpleText( "Buy Now Price", "wOS.AdminFont", ww*0.5, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		surface.DrawLine( ww*0.6, 0, ww*0.6, hh )

		draw.SimpleText( "Current Bid", "wOS.AdminFont", ww*0.675, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		surface.DrawLine( ww*0.75, 0, ww*0.75, hh )

		draw.SimpleText( "Auction Ends", "wOS.AdminFont", ww*0.875, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )

	end

	local listing_list = vgui.Create( "DScrollPanel", sidetab )
	listing_list:SetPos( 0, sh*0.07 )
	listing_list:SetSize( sw, sh*0.93 )
	listing_list.Paint = nil
	local sbar = listing_list:GetVBar()
	sbar.Paint = nil
	sbar.btnUp.Paint = nil
	sbar.btnDown.Paint = nil
	sbar.btnGrip.Paint = nil
	listing_list.Refresh = function( pan, tbl )
		pan:Clear()
		local offset = 0
		local color_shift = false
		local bh = pan:GetTall()*0.07
		
		for num, dat in ipairs( tbl ) do
			local info_panel = vgui.Create( "DButton", pan )
			info_panel:SetPos( 0, offset )
			info_panel:SetSize( sw, bh )
			info_panel:SetText( "" )
			info_panel.Selectable = num
			info_panel.Swap = color_shift
			info_panel.Paint = function( p, ww, hh )
				local col = ( p.Swap and Color( 125, 125, 125 ) ) or Color( 55, 55, 55 )
				if self.DataTab.SelectedID == p.Selectable then
					col = Color( 25, 25, 125 )
				end
				draw.RoundedBox( 0, 0, 0, ww, hh, col )

				surface.SetDrawColor( color_white )
				surface.DrawOutlinedRect(0, 0, ww, hh)

				draw.SimpleText( dat.ID, "wOS.ALCS.DescFont", ww*0.05, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
				surface.DrawLine( ww*0.1, 0, ww*0.1, hh )
				draw.SimpleText( dat.Item, "wOS.ALCS.DescFont", ww*0.25, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
				surface.DrawLine( ww*0.4, 0, ww*0.4, hh )

				draw.SimpleText( ( tonumber( dat.BuyNowPrice ) != 0 and dat.BuyNowPrice ) or "N/A", "wOS.ALCS.DescFont", ww*0.5, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
				surface.DrawLine( ww*0.6, 0, ww*0.6, hh )

				draw.SimpleText( dat.CurrentBid, "wOS.ALCS.DescFont", ww*0.675, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
				surface.DrawLine( ww*0.75, 0, ww*0.75, hh )

				draw.SimpleText( dat.Expiration, "wOS.ALCS.DescFont", ww*0.875, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )

			end
			info_panel.DoClick = function( p )
				self.DataTab.SelectedID = p.Selectable
				local item_m = wOS.ItemList[ dat.Item ]
				local model = "models/props_lab/huladoll.mdl"
				if item_m then model = item_m.Model end
				modelpanel:ApplyNewModel( model )
			end
			color_shift = !color_shift
			offset = offset + bh
		end
		
	end
	listing_list.Delay = CurTime() + 3
	listing_list.Think = function( pan )
		if pan.Delay > CurTime() then return end
		if not self.BufferInfo.Data then return end
		if self.BufferInfo.LastUpdated + 2 >= CurTime() then return end
		pan:Refresh( self.BufferInfo.Data )
		pan.Think = nil
	end

	local tx, ty = toptab:GetPos()
	local sx, sy = self.DataTab:GetPos()
	tx = sx + ty
	ty = sx + ty

	sx, sy = self.Menu:GetPos()
	tx = sx + ty
	ty = sx + ty

	local offertext = vgui.Create( "DTextEntry", toptab )
	offertext:MakePopup()
	offertext:SetPos( tx + tw*0.05, ty + th*0.725 - tw*0.05 )
	offertext:SetSize( tw*0.4, th*0.05 )
	offertext:SetText( "0" )
	offertext:SetNumeric( true )

	local offerbutton = vgui.Create( "DButton", toptab )
	offerbutton:SetPos( tw*0.5, th*0.785 - tw*0.05 )
	offerbutton:SetSize( tw*0.45, th*0.05 )
	offerbutton:SetText( "" )
	offerbutton.Paint = function( pan, ww, hh )
		draw.RoundedBox( 5, 0, 0, ww, hh, ( pan:IsDown() and Color( 0, 55, 155, 155 ) ) or Color( 155, 155, 155, 155 ) )
		draw.SimpleText( "BID AMOUNT", "wOS.ALCS.DescFont", ww/2, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	offerbutton.DoClick = function( pan )
		if self.DataTab.SelectedID < 1 then return end
		local tbl = self.BufferInfo.Data
		tbl = tbl or {}
		local dat =  tbl[ self.DataTab.SelectedID ]
		if not dat then return end
		local offer = tonumber( offertext:GetText() )
		if offer < 1 then return end
		if offer <= tonumber( dat.CurrentBid ) then return end
		net.Start( "wOS.ALCS.GTN.MakeAuctionOffer" )
			net.WriteInt( offer, 32 )
			net.WriteInt( dat.ID, 32 )
			net.WriteInt( dat.CharID, 32 )
			net.WriteString( dat.SteamID )
		net.SendToServer()
	end	


	local remove = vgui.Create( "DButton", toptab )
	remove:SetPos( tw*0.05, th*0.69 - tw*0.05 )
	remove:SetSize( tw*0.9, th*0.05 )
	remove:SetText( "" )
	remove.Paint = function( pan, ww, hh )
		draw.RoundedBox( 5, 0, 0, ww, hh, ( pan:IsDown() and Color( 0, 55, 155, 155 ) ) or Color( 155, 155, 155, 155 ) )
		draw.SimpleText( "BUY IT NOW", "wOS.ALCS.DescFont", ww/2, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	remove.DoClick = function( pan )
		if self.DataTab.SelectedID < 1 then return end
		local tbl = self.BufferInfo.Data
		tbl = tbl or {}
		local dat =  tbl[ self.DataTab.SelectedID ]
		if not dat then return end
		net.Start( "wOS.ALCS.GTN.BuyAuctionOut" )
			net.WriteInt( dat.ID, 32 )
			net.WriteInt( dat.CharID, 32 )
			net.WriteString( dat.SteamID )
		net.SendToServer()
	end	

	toptab.Think = function( pan )
		local vis = false
		local ovis = false
		if self.DataTab.SelectedID > 0 then 
			local dat = wOS.ALCS.GTN.BufferInfo.Data[ self.DataTab.SelectedID ]
			if dat then
				ovis = true
				if dat.BuyNowPrice and tonumber( dat.BuyNowPrice ) != 0 then
					vis = true 
				end
			end
		end
		remove:SetVisible( vis )
		offertext:SetVisible( ovis )
		offerbutton:SetVisible( ovis )
	end

	function self:RefreshMenu()

	end

end

function wOS.ALCS.GTN:ShowTradeHouse()
	net.Start( "wOS.ALCS.GTN.RequestTrades" )
	net.SendToServer()
	self.DataTab:Clear()
 	self.DataTab.SelectedID = 0

	local mw, mh = self.DataTab:GetSize()
	local padx, pady = mh*0.025, mh*0.025 
	local toptab = vgui.Create( "DPanel", self.DataTab )
	toptab:SetPos( padx, pady )
	toptab:SetSize( mw*0.25, mh - 2*pady )
	toptab.Paint = function( pan, ww, hh )
		surface.SetDrawColor( color_white )
		surface.DrawOutlinedRect( ww*0.05, hh*0.075, ww*0.9, ww*0.9 )
		surface.DrawOutlinedRect( 0, 0, ww, hh )
		surface.DrawLine( ww*0.05, hh*0.83, ww*0.95, hh*0.83 )


		if self.DataTab.SelectedID > 0 then
			surface.DrawLine( ww*0.05, hh*0.535, ww*0.95, hh*0.535 )
			local tbl = self.BufferInfo.Data
			tbl = tbl or {}
			local text = "AUCTION"
			local dat = tbl[ self.DataTab.SelectedID ]
			if dat then
				draw.SimpleText( text .. " IDENTIFICATION " .. dat.ID, "wOS.AdminFont", ww/2, hh*0.01, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP )
				draw.SimpleText( "ENDS " .. dat.Expiration, "wOS.ALCS.DescFont", ww/2, hh*0.04, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP )
				
				local itemd = wOS.ItemList[ dat.Item ]
				draw.SimpleText( dat.Item, "wOS.ALCS.DescFont", ww/2, hh*0.47, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP )
				draw.SimpleText( ( itemd and itemd.Description ) or "ITEM DATA NOT FOUND", "wOS.ALCS.DescFont", ww/2, hh*0.5, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP )

				itemd = wOS.ItemList[ dat.RequestedItem ]
				draw.SimpleText( dat.RequestedItem, "wOS.ALCS.DescFont", ww/2, hh*0.615, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP )
				draw.SimpleText( ( itemd and itemd.Description ) or "ITEM DATA NOT FOUND", "wOS.ALCS.DescFont", ww/2, hh*0.645, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP )

			else
				draw.SimpleText( text .. " IDENTIFICATION INVALID", "wOS.AdminFont", ww/2, hh*0.02, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP )
				draw.SimpleText( "ERROR", "wOS.ALCS.DescFont", ww/2, hh*0.47, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP )
				draw.SimpleText( "ERROR", "wOS.ALCS.DescFont", ww/2, hh*0.5, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP )
				draw.SimpleText( "ERROR", "wOS.ALCS.DescFont", ww/2, hh*0.55, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP )
				draw.SimpleText( "ERROR", "wOS.ALCS.DescFont", ww/2, hh*0.58, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP )
				draw.SimpleText( "ERROR", "wOS.ALCS.DescFont", ww/2, hh*0.61, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP )
			end
		else
			draw.SimpleText( "NO LISTING SELECTED", "wOS.AdminFont", ww/2, hh*0.02, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP )
		end

	end

	local tw, th = toptab:GetSize()

	local refresh = vgui.Create( "DButton", toptab )
	refresh:SetPos( tw*0.05, th*0.9 - tw*0.1 )
	refresh:SetSize( tw*0.9, th*0.05 )
	refresh:SetText( "" )
	refresh.Paint = function( pan, ww, hh )
		draw.RoundedBox( 5, 0, 0, ww, hh, ( pan:IsDown() and Color( 0, 55, 155, 155 ) ) or Color( 155, 155, 155, 155 ) )
		draw.SimpleText( "REFRESH LISTINGS", "wOS.ALCS.DescFont", ww/2, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	refresh.DoClick = function( pan )
		self:ShowTradeHouse()
	end	

	local close = vgui.Create( "DButton", toptab )
	close:SetPos( tw*0.05, th*0.95 - tw*0.05 )
	close:SetSize( tw*0.9, th*0.05 )
	close:SetText( "" )
	close.Paint = function( pan, ww, hh )
		draw.RoundedBox( 5, 0, 0, ww, hh, ( pan:IsDown() and Color( 0, 55, 155, 155 ) ) or Color( 155, 155, 155, 155 ) )
		draw.SimpleText( "CLOSE MENU", "wOS.ALCS.DescFont", ww/2, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	close.DoClick = function( pan )
		wOS.ALCS.Skills.Menu:SetVisible( true )
		self.Menu:Remove()
		self.Menu = nil
	end	
	
	local modelpanel = vgui.Create( "DModelPanel", toptab )
	modelpanel:SetSize( tw*0.9, tw*0.9 )	
	modelpanel:SetPos( tw*0.05, th*0.075 )	

	function modelpanel.ApplyNewModel( pan, model )
		local Iconent = ClientsideModel("borealis/barrel.mdl")
		Iconent:SetAngles(Angle(0,0,0))
		Iconent:SetPos(Vector(0,0,0))
		Iconent:Spawn()
		Iconent:Activate()	
		Iconent:SetModel( model )
		local center = Iconent:OBBCenter()
		local dist = Iconent:BoundingRadius()*1.6		
		pan:SetModel( model )
		pan:SetLookAt( center )
		pan:SetCamPos( center + Vector( dist, dist, 0 ) )	
		Iconent:Remove()
	end			
	modelpanel:ApplyNewModel( "models/props_lab/huladoll.mdl" )

	local sidetab = vgui.Create( "DPanel", self.DataTab )
	sidetab:SetPos( 2*padx + mw*0.25, pady )
	sidetab:SetSize( mw*0.75 - 3*padx, mh - 2*pady )
	sidetab.Paint = function( pan, ww, hh )
		surface.SetDrawColor( color_white )
		surface.DrawOutlinedRect( 0, 0, ww, hh )
	end
	
	local sw, sh = sidetab:GetSize()

	local columns = vgui.Create( "DPanel", sidetab )
	columns:SetSize( sw, sh*0.07 )
	columns.Paint = function( pan, ww, hh )

		if not self.BufferInfo.Data then return end
		if self.BufferInfo.LastUpdated + 2 >= CurTime() then return end

		surface.SetDrawColor( color_white )
		surface.DrawOutlinedRect( 0, 0, ww, hh )

		draw.SimpleText( "ID", "wOS.AdminFont", ww*0.05, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		surface.DrawLine( ww*0.1, 0, ww*0.1, hh )

		draw.SimpleText( "Offered Item", "wOS.AdminFont", ww*0.2625, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		surface.DrawLine( ww*0.425, 0, ww*0.425, hh )

		draw.SimpleText( "Requested Item", "wOS.AdminFont", ww*0.5875, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		surface.DrawLine( ww*0.75, 0, ww*0.75, hh )

		draw.SimpleText( "Auction Ends", "wOS.AdminFont", ww*0.875, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )

	end

	local listing_list = vgui.Create( "DScrollPanel", sidetab )
	listing_list:SetPos( 0, sh*0.07 )
	listing_list:SetSize( sw, sh*0.93 )
	listing_list.Paint = nil
	local sbar = listing_list:GetVBar()
	sbar.Paint = nil
	sbar.btnUp.Paint = nil
	sbar.btnDown.Paint = nil
	sbar.btnGrip.Paint = nil
	listing_list.Refresh = function( pan, tbl )
		pan:Clear()
		local offset = 0
		local color_shift = false
		local bh = pan:GetTall()*0.07
		
		for num, dat in ipairs( tbl ) do
			local info_panel = vgui.Create( "DButton", pan )
			info_panel:SetPos( 0, offset )
			info_panel:SetSize( sw, bh )
			info_panel:SetText( "" )
			info_panel.Selectable = num
			info_panel.Swap = color_shift
			info_panel.Paint = function( p, ww, hh )
				local col = ( p.Swap and Color( 125, 125, 125 ) ) or Color( 55, 55, 55 )
				if self.DataTab.SelectedID == p.Selectable then
					col = Color( 25, 25, 125 )
				end
				draw.RoundedBox( 0, 0, 0, ww, hh, col )

				surface.SetDrawColor( color_white )
				surface.DrawOutlinedRect(0, 0, ww, hh)

				draw.SimpleText( dat.ID, "wOS.ALCS.DescFont", ww*0.05, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
				surface.DrawLine( ww*0.1, 0, ww*0.1, hh )
				draw.SimpleText( dat.Item, "wOS.ALCS.DescFont", ww*0.2625, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
				surface.DrawLine( ww*0.425, 0, ww*0.425, hh )

				draw.SimpleText( dat.RequestedItem, "wOS.ALCS.DescFont", ww*0.5875, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
				surface.DrawLine( ww*0.75, 0, ww*0.75, hh )

				draw.SimpleText( dat.Expiration, "wOS.ALCS.DescFont", ww*0.875, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )

			end
			info_panel.DoClick = function( p )
				self.DataTab.SelectedID = p.Selectable
				local item_m = wOS.ItemList[ dat.Item ]
				local model = "models/props_lab/huladoll.mdl"
				if item_m then model = item_m.Model end
				modelpanel:ApplyNewModel( model )
			end
			color_shift = !color_shift
			offset = offset + bh
		end
		
	end
	listing_list.Delay = CurTime() + 3
	listing_list.Think = function( pan )
		if pan.Delay > CurTime() then return end
		if not self.BufferInfo.Data then return end
		if self.BufferInfo.LastUpdated + 2 >= CurTime() then return end
		pan:Refresh( self.BufferInfo.Data )
		pan.Think = nil
	end

	local remove = vgui.Create( "DButton", toptab )
	remove:SetPos( tw*0.05, th*0.74 - tw*0.05 )
	remove:SetSize( tw*0.9, th*0.05 )
	remove:SetText( "" )
	remove.Paint = function( pan, ww, hh )
		draw.RoundedBox( 5, 0, 0, ww, hh, ( pan:IsDown() and Color( 0, 55, 155, 155 ) ) or Color( 155, 155, 155, 155 ) )
		draw.SimpleText( "ACCEPT TRADE", "wOS.ALCS.DescFont", ww/2, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	remove.DoClick = function( pan )
		if self.DataTab.SelectedID < 1 then return end
		local tbl = self.BufferInfo.Data
		tbl = tbl or {}
		local dat =  tbl[ self.DataTab.SelectedID ]
		if not dat then return end
		net.Start( "wOS.ALCS.GTN.BuyTradeOut" )
			net.WriteInt( dat.ID, 32 )
			net.WriteInt( dat.CharID, 32 )
			net.WriteString( dat.SteamID )
		net.SendToServer()
	end	

	toptab.Think = function( pan )
		local vis = false
		if self.DataTab.SelectedID > 0 then 
			local dat = wOS.ALCS.GTN.BufferInfo.Data[ self.DataTab.SelectedID ]
			if dat then
				vis = true 
			end
		end
		remove:SetVisible( vis )
	end

	function self:RefreshMenu()

	end

end
--addons/wos-alcs-darkaspp/lua/wos/advswl/dark-ascension-files/core/cl_core.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2019
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--

hook.Add( "wOS.ALCS.GetSequenceOverride", "wOS.ALCS.DarkAscensionAnimations", function( ply, velocity )

	local wep = ply:GetActiveWeapon()
	if not IsValid( wep ) then return end
	if not wep.IsLightsaber then return end
	
	if wep:GetMeditateMode() == 3 then
        return -1, ply:LookupSequence( "judge_h_s2_charge" )
    end
	
end )
--addons/wos-grandmaster-einf/lua/wos/advswl/legacy-crafting/wos_craft.lua:
--[[-------------------------------------------------------------------
	Legacy Lightsaber Crafting System:
		If you build it, Sith will come
			Powered by
						  _ _ _    ___  ____  
				__      _(_) | |_ / _ \/ ___| 
				\ \ /\ / / | | __| | | \___ \ 
				 \ V  V /| | | |_| |_| |___) |
				  \_/\_/ |_|_|\__|\___/|____/ 
											  
 _____         _                 _             _           
|_   _|__  ___| |__  _ __   ___ | | ___   __ _(_) ___  ___ 
  | |/ _ \/ __| '_ \| '_ \ / _ \| |/ _ \ / _` | |/ _ \/ __|
  | |  __/ (__| | | | | | | (_) | | (_) | (_| | |  __/\__ \
  |_|\___|\___|_| |_|_| |_|\___/|_|\___/ \__, |_|\___||___/
                                         |___/             
----------------------------- Copyright 2019, David "King David" Wiltos ]]--[[
							  
	Lua Developer: King David
	Contact: http://steamcommunity.com/groups/wiltostech
		
-- Copyright 2019, David "King David" Wiltos ]]--

wOS = wOS or {}
wOS.ALCS = wOS.ALCS or {}
wOS.ALCS.Legacy = wOS.ALCS.Legacy or {}

language.Add( "wos_l_primary_saber", "PRIMARY" )
language.Add( "wos_l_secondary_saber", "SECONDARY" )
language.Add( "wos_l_primary_blade", "Primary Blade" )
language.Add( "wos_l_secondary_blade", "Secondary Blade" )
language.Add( "wos_l_dual_saber", "DUAL" )
language.Add( "wos_l_option_hilt", "Hilt" )
language.Add( "wos_l_option_color", "Crystal" )
language.Add( "wos_l_option_blade", "Blade" )
language.Add( "wos_l_option_misc", "Energizers" )
language.Add( "wos_l_advert_wiltos", "Powered by wiltOS Technologies" )
language.Add( "wos_l_select_primaryhilt", "Set as Primary Hilt" )
language.Add( "wos_l_select_secondaryhilt", "Set as Secondary Hilt" )
language.Add( "wos_l_info_bladel", "Blade Length:" )
language.Add( "wos_l_info_bladew", "Blade Width:" )
language.Add( "wos_l_info_dark", "Dark Inner Blade" )
language.Add( "wos_l_info_primcrystal", "Primary Crystal" )
language.Add( "wos_l_info_seccrystal", "Secondary Crystal" )
language.Add( "wos_l_info_igniter", "Crystal Activator:" )
language.Add( "wos_l_info_humsound", "Idle Regulator:" )
language.Add( "wos_l_info_swingsound", "Power Vortex Regulator:" )

local w,h = ScrW(), ScrH()

function wOS.ALCS.Legacy:OpenSaberCrafting()

	if self.SaberStation then return end
	gui.EnableScreenClicker( true )

	self.SaberStation = vgui.Create( "DPanel" )
	self.SaberStation:SetSize( w*0.5, h*0.5 )
	self.SaberStation:Center()
	self.SaberStation.Paint = function( pan, ww, hh )
		draw.RoundedBox( 3, 0, 0, ww, hh, Color( 25, 25, 25, 245 ) )
	end 
	self.SaberStation.CurrentButton = language.GetPhrase( "wos_l_option_hilt" )
	
	local fw, fh = self.SaberStation:GetSize()
	
	local button = vgui.Create( "DButton", self.SaberStation )
	button:SetSize( fw*0.04, fh*0.05 )
	button:SetPos( fw*0.95, fh*0.01 )
	button:SetText( "" )
	button.Paint = function( pan, ww, hh )
		surface.SetDrawColor( Color( 255, 0, 0, 255 ) )
		surface.DrawLine( 0, 0, ww, hh )
		surface.DrawLine( 0, hh, ww, 0 )
	end
	button.DoClick = function()
		self.SaberStation:Remove()
		self.SaberStation = nil
		gui.EnableScreenClicker( false )
	end
	
	local button1 = vgui.Create( "DButton", self.SaberStation )
	button1:SetSize( fw, fh*0.1 )
	button1:SetPos( 0, fh*0.9 )
	button1:SetText( "" )
	button1.Paint = function( pan, ww, hh )
		if pan:IsHovered() then
			draw.SimpleText( language.GetPhrase( "wos_l_advert_wiltos" ), "Trebuchet24", ww/2, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )		
		else
			draw.SimpleText( language.GetPhrase( "wos_l_advert_wiltos" ), "Trebuchet24", ww/2, hh/2, Color( 75, 75, 75, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		end
	end
	button1.DoClick = function()
		gui.OpenURL( "https://www.wiltostech.com" )
	end	
	
	local hiltbutt = vgui.Create( "DButton", self.SaberStation )
	hiltbutt:SetSize( fw*0.2, fh*0.05 )
	hiltbutt:SetPos( fw*0.055, fh*0.01 )
	hiltbutt:SetText( "" )
	hiltbutt.Paint = function( pan, ww, hh )
		local col = ( wOS.ALCS.Legacy.SaberStation.CurrentButton == "Hilt" and Color( 175, 175, 175, 255 ) ) or Color( 88, 88, 88, 255 )
		draw.RoundedBox( 5, 0, 0, ww, hh, col )
		draw.SimpleText( language.GetPhrase( "wos_l_option_hilt" ), "Trebuchet18", ww/2, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	hiltbutt.DoClick = function( pan )
		if wOS.ALCS.Legacy.SaberStation.CurrentButton == language.GetPhrase( "wos_l_option_hilt" ) then return end
		wOS.ALCS.Legacy.SaberStation.CurrentButton = language.GetPhrase( "wos_l_option_hilt" )
		wOS.ALCS.Legacy:CraftUpdateControlPanel()
	end
	
	local bladebutt = vgui.Create( "DButton", self.SaberStation )
	bladebutt:SetSize( fw*0.2, fh*0.05 )
	bladebutt:SetPos( fw*0.265, fh*0.01 )
	bladebutt:SetText( "" )
	bladebutt.Paint = function( pan, ww, hh )
		local col = ( wOS.ALCS.Legacy.SaberStation.CurrentButton == language.GetPhrase( "wos_l_option_blade" ) and Color( 175, 175, 175, 255 ) ) or Color( 88, 88, 88, 255 )
		draw.RoundedBox( 5, 0, 0, ww, hh, col )
		draw.SimpleText( language.GetPhrase( "wos_l_option_blade" ), "Trebuchet18", ww/2, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	bladebutt.DoClick = function( pan )
		if wOS.ALCS.Legacy.SaberStation.CurrentButton == language.GetPhrase( "wos_l_option_blade" ) then return end
		wOS.ALCS.Legacy.SaberStation.CurrentButton = language.GetPhrase( "wos_l_option_blade" )
		wOS.ALCS.Legacy:CraftUpdateControlPanel()
	end
	
	local crystalbutt = vgui.Create( "DButton", self.SaberStation )
	crystalbutt:SetSize( fw*0.2, fh*0.05 )
	crystalbutt:SetPos( fw*0.475, fh*0.01 )
	crystalbutt:SetText( "" )
	crystalbutt.Paint = function( pan, ww, hh )
		local col = ( wOS.ALCS.Legacy.SaberStation.CurrentButton == language.GetPhrase( "wos_l_option_color" ) and Color( 175, 175, 175, 255 ) ) or Color( 88, 88, 88, 255 )
		draw.RoundedBox( 5, 0, 0, ww, hh, col )
		draw.SimpleText( language.GetPhrase( "wos_l_option_color" ), "Trebuchet18", ww/2, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	crystalbutt.DoClick = function( pan )
		if wOS.ALCS.Legacy.SaberStation.CurrentButton == language.GetPhrase( "wos_l_option_color" ) then return end
		wOS.ALCS.Legacy.SaberStation.CurrentButton = language.GetPhrase( "wos_l_option_color" )
		wOS.ALCS.Legacy:CraftUpdateControlPanel()
	end
	
	local energybutt = vgui.Create( "DButton", self.SaberStation )
	energybutt:SetSize( fw*0.2, fh*0.05 )
	energybutt:SetPos( fw*0.685, fh*0.01 )
	energybutt:SetText( "" )
	energybutt.Paint = function( pan, ww, hh )
		local col = ( wOS.ALCS.Legacy.SaberStation.CurrentButton == language.GetPhrase( "wos_l_option_misc" ) and Color( 175, 175, 175, 255 ) ) or Color( 88, 88, 88, 255 )
		draw.RoundedBox( 5, 0, 0, ww, hh, col )
		draw.SimpleText( language.GetPhrase( "wos_l_option_misc" ), "Trebuchet18", ww/2, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	energybutt.DoClick = function( pan )
		if wOS.ALCS.Legacy.SaberStation.CurrentButton == language.GetPhrase( "wos_l_option_misc" ) then return end
		wOS.ALCS.Legacy.SaberStation.CurrentButton = language.GetPhrase( "wos_l_option_misc" )
		wOS.ALCS.Legacy:CraftUpdateControlPanel()
	end	
	
	self.ContentPanel = vgui.Create("DScrollPanel", self.SaberStation )
	self.ContentPanel:SetSize( fw*0.98, fh*0.83 )
	self.ContentPanel:SetPos( fw*0.01, fh*0.07 )
	self.ContentPanel.Paint = function( pan, ww, hh ) 
	end
	self.ContentPanel.VBar.Paint = function() end
	self.ContentPanel.VBar.btnUp.Paint = function() end
	self.ContentPanel.VBar.btnDown.Paint = function() end
	self.ContentPanel.VBar.btnGrip.Paint = function() end
	
	self:CraftUpdateControlPanel()
	
end

local function CalcSize( num, width )
	
	if width then
		num = 4 - 2*num
	else
		num = 32 + 32*num
	end
	
	return num
	
end

local function ReverseSize( num, width )
	
	if width then
		num = ( 4 - num )/2
	else
		num = ( num - 32 )/32
	end
	
	return num	
	
end

function wOS.ALCS.Legacy:CraftUpdateControlPanel()
	if not self.SaberStation then wOS.ALCS.Legacy:OpenSaberCrafting() return end
	if not self.ContentPanel then return end
	self.ContentPanel:Clear()
	
	local mode = self.SaberStation.CurrentButton
	local mw, mh = self.ContentPanel:GetSize()
	
	if mode == language.GetPhrase( "wos_l_option_hilt" ) then
		local padx, pady = mw*0.02, mh*0.05
		local bw, bh = mw*0.18, mw*0.15
		local offsetx, offsety = 0, 0
		local hilts = list.Get( "LightsaberModels" )
		for model, _ in pairs( hilts ) do
			if offsetx + bw >= mw then 
				offsetx = 0
				offsety = offsety + bh + pady
			end
			
			local datamask = vgui.Create( "DPanel", self.ContentPanel )
			datamask:SetSize( bw, bh )
			datamask:SetPos( offsetx, offsety )
			datamask.Paint = function() end
			
			local Iconent = ClientsideModel("borealis/barrel.mdl")
			Iconent:SetAngles(Angle(0,0,0))
			Iconent:SetPos(Vector(0,0,0))
			Iconent:Spawn()
			Iconent:Activate()	
			
			local ItemIcon = vgui.Create( "DModelPanel", datamask )
			ItemIcon:SetSize( bw, bh )
			ItemIcon:SetModel( model )
			Iconent:SetModel( model )
			
			local center = Iconent:OBBCenter()
			local dist = Iconent:BoundingRadius()*1.6
			ItemIcon:SetLookAt( center )
			ItemIcon:SetCamPos( center + Vector( dist, dist, 0 ) )	
			Iconent:Remove()
			
			local ItemButt = vgui.Create( "DButton", ItemIcon )
			ItemButt:SetSize( bw, bh )
			ItemButt:SetText( "" )
			ItemButt.Paint = function( pan, ww, hh ) 	
				local primary = GetConVar( "rb655_lightsaber_model" ):GetString() == model || GetConVar( "rb655_lightsaber_dual_model" ):GetString() == model
				local secondary = GetConVar( "rb655_lightsaber_dual_model_single" ):GetString() == model
				if primary and not secondary then
					surface.SetDrawColor( Color( 0, 100, 155, 255 ) )
					surface.DrawOutlinedRect( 0, 0, ww, hh )
					draw.SimpleText( language.GetPhrase( "wos_l_primary_saber" ), "Trebuchet18", ww/2, hh*0.02, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP )
				elseif secondary and not primary then
					surface.SetDrawColor( Color( 155, 100, 0, 255 ) )
					surface.DrawOutlinedRect( 0, 0, ww, hh )
					draw.SimpleText( language.GetPhrase( "wos_l_secondary_saber" ), "Trebuchet18", ww/2, hh*0.02, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP )
				elseif primary and secondary then
					surface.SetDrawColor( Color( 155, 200, 155, 255 ) )
					surface.DrawOutlinedRect( 0, 0, ww, hh )
					draw.SimpleText( language.GetPhrase( "wos_l_dual_saber" ), "Trebuchet18", ww/2, hh*0.02, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP )
				else
					surface.SetDrawColor( Color( 105, 105, 105, 255 ) )
					surface.DrawOutlinedRect( 0, 0, ww, hh )						
				end
			end
			ItemButt.DoClick = function( pan )
				if ItemButt.ItemIconOptions then ItemButt.ItemIconOptions:Remove() ItemButt.ItemIconOptions = nil end
				ItemButt.ItemIconOptions = DermaMenu( ItemIcon )
				ItemButt.ItemIconOptions:SetPos( gui.MouseX(), gui.MouseY() )
				ItemButt.ItemIconOptions.Think = function( self )
					if not wOS.ALCS.Legacy.SaberStation then self:Remove() return end
					if not ItemButt then self:Remove() return end
				end
				ItemButt.ItemIconOptions:AddOption( "Set as Primary Hilt", function() 
					LocalPlayer():ConCommand( "rb655_lightsaber_model " .. model )
					LocalPlayer():ConCommand( "rb655_lightsaber_dual_model " .. model  )
					surface.PlaySound( Sound( "buttons/button14.wav" ) )
				end )
				ItemButt.ItemIconOptions:AddOption( "Set as Secondary Hilt", function() 
					LocalPlayer():ConCommand( "rb655_lightsaber_dual_model_single " .. model )
					surface.PlaySound( Sound( "buttons/button14.wav" ) )
				end )
			end					
			offsetx = offsetx + bw + padx
		end
	elseif mode == language.GetPhrase( "wos_l_option_blade" ) then
		local infoframe = vgui.Create( "DPanel", self.ContentPanel )
		infoframe:SetSize( mw, mh )
		infoframe.Paint = function( pan, ww, hh ) 
			local tx, ty = draw.SimpleText( language.GetPhrase( "wos_l_primary_blade" ), "TreBuchet24", ww*0.245, hh*0.06, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM )
			surface.SetDrawColor( color_white )
			surface.DrawLine( ww*0.245 - tx*0.75, hh*0.06 + ty*0.03, ww*0.245 + tx*0.75, hh*0.06 + ty*0.03 )
			tx, ty = draw.SimpleText( language.GetPhrase( "wos_l_secondary_blade" ), "TreBuchet24", ww*0.755, hh*0.06, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM )
			surface.DrawLine( ww*0.755 - tx*0.75, hh*0.06 + ty*0.03, ww*0.755 + tx*0.75, hh*0.06 + ty*0.03 )
			draw.SimpleText( language.GetPhrase( "wos_l_info_bladel" ), "TreBuchet24", ww*0.11, hh*0.85, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP )
			draw.SimpleText( language.GetPhrase( "wos_l_info_bladew" ), "TreBuchet24", ww*0.11, hh*0.94, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP )
			draw.SimpleText( language.GetPhrase( "wos_l_info_bladel" ), "TreBuchet24", ww*0.62, hh*0.85, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP )
			draw.SimpleText( language.GetPhrase( "wos_l_info_bladew" ), "TreBuchet24", ww*0.62, hh*0.94, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP )
		end
		
		local primsize = vgui.Create( "DSlider", infoframe )
		primsize:SetSize( mw*0.49, mh*0.75 )
		primsize:SetPos( 0, mh*0.08 )
		primsize:SetLockX( false )
		primsize:SetLockY( false )
		primsize:SetNotches( true )
		primsize:SetBackground( "wos/utilities/saber_measurement_axis.png" )
		primsize.Paint = function( pan, ww, hh )
			draw.RoundedBox( 0, 0, 0, ww, hh, Color( 155, 155, 155, 105 ) )
		end	
		primsize:SetSlideX( ReverseSize( GetConVar( "rb655_lightsaber_bladel" ):GetInt() ) )
		primsize:SetSlideY( ReverseSize( GetConVar( "rb655_lightsaber_bladew" ):GetInt(), true ) )	
		
		local primlength = vgui.Create( "DNumberWang", infoframe )
		primlength:SetPos( mw*0.29, mh*0.85 )
		primlength:SetSize( mw*0.1, mh*0.06 )
		primlength:SetMin( 32 )
		primlength:SetMax( 64 )
		primlength.Think = function( pan )
			local val = CalcSize( primsize:GetSlideX() )
			pan:SetValue( val )
			LocalPlayer():ConCommand( "rb655_lightsaber_bladel " .. val )
			LocalPlayer():ConCommand( "rb655_lightsaber_dual_bladel " .. val )		
		end
		
		local primwidth = vgui.Create( "DNumberWang", infoframe )
		primwidth:SetPos( mw*0.29, mh*0.94 )
		primwidth:SetSize( mw*0.1, mh*0.06 )
		primwidth:SetMin( 2 )
		primwidth:SetMax( 4 )
		primwidth.Think = function( pan )
			local val = CalcSize( primsize:GetSlideY(), true )
			pan:SetValue( val )
			LocalPlayer():ConCommand( "rb655_lightsaber_bladew " .. val )
			LocalPlayer():ConCommand( "rb655_lightsaber_dual_bladew " .. val )		
		end
		
		local secsize = vgui.Create( "DSlider", infoframe )
		secsize:SetSize( mw*0.49, mh*0.75 )
		secsize:SetPos( mw*0.51, mh*0.08 )
		secsize:SetLockX( false )
		secsize:SetLockY( false )
		secsize:SetNotches( true )
		secsize:SetBackground( "wos/utilities/saber_measurement_axis.png" )
		secsize.Paint = function( pan, ww, hh )
			draw.RoundedBox( 0, 0, 0, ww, hh, Color( 155, 155, 155, 105 ) )
		end	
		secsize:SetSlideX( ReverseSize( GetConVar( "rb655_lightsaber_dual_bladel_single" ):GetInt() ) )
		secsize:SetSlideY( ReverseSize( GetConVar( "rb655_lightsaber_dual_bladew_single" ):GetInt(), true ) )	
		
		local seclength = vgui.Create( "DNumberWang", infoframe )
		seclength:SetPos( mw*0.8, mh*0.85 )
		seclength:SetSize( mw*0.1, mh*0.06 )
		seclength:SetMin( 32 )
		seclength:SetMax( 64 )
		seclength.Think = function( pan )
			local val = CalcSize( secsize:GetSlideX() )
			pan:SetValue( val )
			LocalPlayer():ConCommand( "rb655_lightsaber_dual_bladel_single " .. val )		
		end
		
		local secwidth = vgui.Create( "DNumberWang", infoframe )
		secwidth:SetPos( mw*0.8, mh*0.94 )
		secwidth:SetSize( mw*0.1, mh*0.06 )
		secwidth:SetMin( 2 )
		secwidth:SetMax( 4 )
		secwidth.Think = function( pan )
			local val = CalcSize( secsize:GetSlideY(), true )
			pan:SetValue( val )
			LocalPlayer():ConCommand( "rb655_lightsaber_dual_bladew_single " .. val )		
		end		
		
	elseif mode == language.GetPhrase( "wos_l_option_color" ) then
		local infoframe = vgui.Create( "DPanel", self.ContentPanel )
		infoframe:SetSize( mw, mh )
		infoframe.Paint = function( pan, ww, hh ) 
			local tx, ty = draw.SimpleText( language.GetPhrase( "wos_l_info_primcrystal" ), "TreBuchet24", ww*0.245, hh*0.06, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM )
			surface.SetDrawColor( color_white )
			surface.DrawLine( ww*0.245 - tx*0.75, hh*0.06 + ty*0.03, ww*0.245 + tx*0.75, hh*0.06 + ty*0.03 )
			tx, ty = draw.SimpleText( language.GetPhrase( "wos_l_info_seccrystal" ), "TreBuchet24", ww*0.755, hh*0.06, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM )
			surface.DrawLine( ww*0.755 - tx*0.75, hh*0.06 + ty*0.03, ww*0.755 + tx*0.75, hh*0.06 + ty*0.03 )
		end
		
		local primcolor = vgui.Create( "DColorMixer", infoframe )
		primcolor:SetSize( mw*0.49, mh*0.75 )
		primcolor:SetPos( 0, mh*0.08 )
		primcolor:SetPalette( true ) 	
		primcolor:SetAlphaBar( false )
		primcolor:SetWangs( false )			
		primcolor:SetColor( Color( GetConVar( "rb655_lightsaber_red" ):GetInt(), GetConVar( "rb655_lightsaber_green" ):GetInt(), GetConVar( "rb655_lightsaber_blue" ):GetInt(), 255 ) )	--Set the default color
		function primcolor:ValueChanged()
			local color = self:GetColor()
			LocalPlayer():ConCommand( "rb655_lightsaber_red " .. color.r )
			LocalPlayer():ConCommand( "rb655_lightsaber_green " .. color.g )
			LocalPlayer():ConCommand( "rb655_lightsaber_blue " .. color.b )		
			LocalPlayer():ConCommand( "rb655_lightsaber_dual_red " .. color.r )
			LocalPlayer():ConCommand( "rb655_lightsaber_dual_green " .. color.g )
			LocalPlayer():ConCommand( "rb655_lightsaber_dual_blue " .. color.b )		
		end
		
		local priminner = vgui.Create( "DButton", infoframe )
		priminner:SetSize( mw*0.49*0.66, mh*0.07 )
		priminner:SetPos( mw*0.49*0.33/2, mh*0.86 )
		priminner:SetText( "" )
		priminner.Activated = GetConVar( "rb655_lightsaber_dark" ):GetBool()
		priminner.DoClick = function( pan )
			priminner.Activated = !priminner.Activated
			local val = 0
			if priminner.Activated then
				val = 1
			end
			LocalPlayer():ConCommand( "rb655_lightsaber_dark " .. val )		
			LocalPlayer():ConCommand( "rb655_lightsaber_dual_dark " .. val )
			surface.PlaySound( "buttons/lightswitch2.wav" ) 
		end
		priminner.Paint = function( pan, ww, hh )
			local col = ( pan.Activated and Color( 0, 100, 155, 255 ) ) or Color( 88, 88, 88, 255 )
			draw.RoundedBox( 5, 0, 0, ww, hh, col )
			draw.SimpleText( language.GetPhrase( "wos_l_info_dark" ), "TreBuchet24", ww/2, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )		
		end

		local seccolor = vgui.Create( "DColorMixer", infoframe )
		seccolor:SetSize( mw*0.49, mh*0.75 )
		seccolor:SetPos( mw*0.51, mh*0.08 )
		seccolor:SetPalette( true ) 	
		seccolor:SetAlphaBar( false )
		seccolor:SetWangs( false )			
		seccolor:SetColor( Color( GetConVar( "rb655_lightsaber_dual_red_single" ):GetInt(), GetConVar( "rb655_lightsaber_dual_green_single" ):GetInt(), GetConVar( "rb655_lightsaber_dual_blue_single" ):GetInt(), 255 ) )	--Set the default color
		function seccolor:ValueChanged()
			local color = self:GetColor()
			LocalPlayer():ConCommand( "rb655_lightsaber_dual_red_single " .. color.r )
			LocalPlayer():ConCommand( "rb655_lightsaber_dual_green_single " .. color.g )
			LocalPlayer():ConCommand( "rb655_lightsaber_dual_blue_single " .. color.b )		
		end	
		
		local secinner = vgui.Create( "DButton", infoframe )
		secinner:SetSize( mw*0.49*0.66, mh*0.07 )
		secinner:SetPos( mw*0.51 + mw*0.49*0.33/2, mh*0.86 )
		secinner:SetText( "" )
		secinner.Activated = GetConVar( "rb655_lightsaber_dual_dark_single" ):GetBool()
		secinner.DoClick = function( pan )
			secinner.Activated = !secinner.Activated
			local val = 0
			if secinner.Activated then
				val = 1
			end
			LocalPlayer():ConCommand( "rb655_lightsaber_dual_dark_single " .. val )
			surface.PlaySound( "buttons/lightswitch2.wav" ) 
		end
		secinner.Paint = function( pan, ww, hh )
			local col = ( pan.Activated and Color( 0, 100, 155, 255 ) ) or Color( 88, 88, 88, 255 )
			draw.RoundedBox( 5, 0, 0, ww, hh, col )
			draw.SimpleText( language.GetPhrase( "wos_l_info_dark" ), "TreBuchet24", ww/2, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )		
		end
	else
		local infoframe = vgui.Create( "DPanel", self.ContentPanel )
		infoframe:SetSize( mw, mh )
		infoframe.Paint = function( pan, ww, hh ) 
			draw.SimpleText( language.GetPhrase( "wos_l_info_igniter" ), "TreBuchet24", ww*0.25, hh*0.03, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP )
			draw.SimpleText( language.GetPhrase( "wos_l_info_humsound" ), "TreBuchet24", ww*0.25, hh*0.35, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP )
			draw.SimpleText( language.GetPhrase( "wos_l_info_swingsound" ), "TreBuchet24", ww*0.25, hh*0.67, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP )
		end		
		
		local ignitions = vgui.Create( "DComboBox", infoframe )
		ignitions:SetPos( mw*0.55, mh*0.03 )
		ignitions:SetSize( mw*0.2, mh*0.05 )
		ignitions.Values = {}
		for name, data in pairs( list.Get( "rb655_LightsaberIgniteSounds" ) ) do
			ignitions.Values[ name ] = data
			ignitions:AddChoice( name )
			if GetConVar( "rb655_lightsaber_onsound" ):GetString() == data[ "rb655_lightsaber_onsound" ] then
				ignitions:SetValue( name )
			end
		end
		ignitions.OnSelect = function( pan, id, val )
			LocalPlayer():ConCommand( "rb655_lightsaber_onsound " .. pan.Values[val][ "rb655_lightsaber_onsound" ] )		
			LocalPlayer():ConCommand( "rb655_lightsaber_dual_onsound " .. pan.Values[val][ "rb655_lightsaber_onsound" ] )	
			LocalPlayer():ConCommand( "rb655_lightsaber_offsound " .. pan.Values[val][ "rb655_lightsaber_offsound" ] )		
			LocalPlayer():ConCommand( "rb655_lightsaber_dual_offsound " .. pan.Values[val][ "rb655_lightsaber_offsound" ] )				
		end

		local hums = vgui.Create( "DComboBox", infoframe )
		hums:SetPos( mw*0.55, mh*0.35 )
		hums:SetSize( mw*0.2, mh*0.05 )
		hums.Values = {}
		for name, data in pairs( list.Get( "rb655_LightsaberHumSounds" ) ) do
			hums.Values[ name ] = data
			hums:AddChoice( name )
			if GetConVar( "rb655_lightsaber_humsound" ):GetString() == data[ "rb655_lightsaber_humsound" ] then
				hums:SetValue( name )
			end
		end
		hums.OnSelect = function( pan, id, val )
			LocalPlayer():ConCommand( "rb655_lightsaber_humsound " .. pan.Values[val][ "rb655_lightsaber_humsound" ] )		
			LocalPlayer():ConCommand( "rb655_lightsaber_dual_humsound " .. pan.Values[val][ "rb655_lightsaber_humsound" ] )				
		end 
		
		local swings = vgui.Create( "DComboBox", infoframe )
		swings:SetPos( mw*0.55, mh*0.67 )
		swings:SetSize( mw*0.2, mh*0.05 )
		swings.Values = {}
		for name, data in pairs( list.Get( "rb655_LightsaberSwingSounds" ) ) do
			swings.Values[ name ] = data
			swings:AddChoice( name )
			if GetConVar( "rb655_lightsaber_swingsound" ):GetString() == data[ "rb655_lightsaber_swingsound" ] then
				swings:SetValue( name )
			end
		end
		swings.OnSelect = function( pan, id, val )
			LocalPlayer():ConCommand( "rb655_lightsaber_swingsound " .. pan.Values[val][ "rb655_lightsaber_swingsound" ] )		
			LocalPlayer():ConCommand( "rb655_lightsaber_dual_swingsound " .. pan.Values[val][ "rb655_lightsaber_swingsound" ] )				
		end 
		
	end
	
end 
--addons/bkeypads/lua/vgui/bkeypads_docked_image.lua:
local PANEL = {}

function PANEL:SetMaterial(mat)
	self.m_Material = mat
	self.m_Square = nil

	self.m_AspectRatio = self.m_Material:Height() / self.m_Material:Width()

	self._w, self._h = nil
end

function PANEL:SetSquareMaterial(mat)
	self.m_Material = mat
	self.m_Square = true
	self._w, self._h = nil
end

function PANEL:GetMaterial()
	return self.m_Material
end

function PANEL:SetAspectRatio(aspectRatio)
	self.m_AspectRatio = aspectRatio
	self._w, self._h = nil
end

function PANEL:Paint(w,h)
	if self.m_Material then
		surface.SetDrawColor(255, 255, 255)
		surface.SetMaterial(self.m_Material)
		if self.m_Square then
			surface.DrawTexturedRect(0, 0, w, w)
		else
			surface.DrawTexturedRect(0, 0, w, h)
		end

		if self._w ~= w or self._h ~= h then
			self._w, self._h = w, h
			self:SetTall(w * self.m_AspectRatio)
		end
	end
end

derma.DefineControl("bKeypads.DockedImage", nil, PANEL, "DPanel")
--addons/bkeypads/lua/vgui/bkeypads_smooth_scroll.lua:
--## bKeypads.SmoothScroll ##--

local PANEL = {}

local function VBar_PerformLayout(self)
	local Wide = self:GetWide()
	local BtnHeight = Wide
	if self:GetHideButtons() then BtnHeight = 0 end
	local Scroll = self:GetScroll() / self.CanvasSize
	local BarSize = math.max(self:BarScale() * (self:GetTall() - (BtnHeight * 2)), 10)
	local Track = self:GetTall() - (BtnHeight * 2) - BarSize
	Track = Track + 1

	Scroll = Scroll * Track

	self.TargetY = BtnHeight + Scroll
	self.btnGrip:SetSize(Wide, BarSize)

	if BtnHeight > 0 then
		self.btnUp:SetPos(0, 0, Wide, Wide)
		self.btnUp:SetSize(Wide, BtnHeight)

		self.btnDown:SetPos(0, self:GetTall() - BtnHeight)
		self.btnDown:SetSize(Wide, BtnHeight)
		
		self.btnUp:SetVisible(true)
		self.btnDown:SetVisible(true)
	else
		self.btnUp:SetVisible(false)
		self.btnDown:SetVisible(false)
		self.btnDown:SetSize(Wide, BtnHeight)
		self.btnUp:SetSize(Wide, BtnHeight)
	end
end

local function VBar_Think(self)
	self.CurrentY = Lerp(FrameTime() * 10, self.CurrentY, self.TargetY)
	self.btnGrip:SetPos(0, math.Round(self.CurrentY))
end

local function pnlCanvas_Think(self)
	self.CurrentOffset = Lerp(FrameTime() * 10, self.CurrentOffset, self.TargetOffset)
	self:SetPos(0, math.Round(self.CurrentOffset))
end

function PANEL:Init()
	self.CurrentOffset = 0
	self.TargetOffset = 0
	self.StartTime = 0
	self.EndTime = 0

	self.VBar.CurrentY = 0
	self.VBar.TargetY = 0
	self.VBar.PerformLayout = VBar_PerformLayout
	self.VBar.Think = VBar_Think

	self.pnlCanvas.CurrentOffset = 0
	self.pnlCanvas.TargetOffset = 0
	self.pnlCanvas.Think = pnlCanvas_Think
end

function PANEL:OnVScroll(offset)
	self.pnlCanvas.TargetOffset = offset
end

function PANEL:PerformLayoutInternal()
	local Tall = self.pnlCanvas:GetTall()
	local Wide = self:GetWide()
	local YPos = 0

	self:Rebuild()

	self.VBar:SetUp(self:GetTall(), self.pnlCanvas:GetTall())
	YPos = self.VBar:GetOffset()

	if self.VBar.Enabled then Wide = Wide - self.VBar:GetWide() end

	self.pnlCanvas:SetPos(0, YPos)
	self.pnlCanvas:SetWide(Wide)

	self:Rebuild()

	if Tall ~= self.pnlCanvas:GetTall() then
		self.VBar:SetScroll(self.VBar:GetScroll())
	end
end

derma.DefineControl("bKeypads.SmoothScroll", nil, PANEL, "DScrollPanel")

--## bKeypads.SmoothScroll.HideVBar ##--

local PANEL = {}

function PANEL:PerformLayout(w, h)
	self.VBar:SetWide(0)
	DScrollPanel.PerformLayout(self, w, h)
end

derma.DefineControl("bKeypads.SmoothScroll.HideVBar", nil, PANEL, "bKeypads.SmoothScroll")

--## bKeypads.SmoothScroll.CategoryList ##--

local PANEL = {}

function PANEL:Init()

	self.pnlCanvas:DockPadding( 2, 2, 2, 2 )

end

function PANEL:AddItem( item )

	item:Dock( TOP )
	DScrollPanel.AddItem( self, item )
	self:InvalidateLayout()

end

function PANEL:Add( name )

	local Category = vgui.Create( "DCollapsibleCategory", self )
	Category:SetLabel( name )
	Category:SetList( self )

	self:AddItem( Category )

	return Category

end

function PANEL:Paint( w, h )

	derma.SkinHook( "Paint", "CategoryList", self, w, h )
	return false

end

function PANEL:UnselectAll()

	for k, v in pairs( self:GetChildren() ) do

		if ( v.UnselectAll ) then
			v:UnselectAll()
		end

	end

end

function PANEL:GenerateExample( ClassName, PropertySheet, Width, Height )

	local ctrl = vgui.Create( ClassName )
	ctrl:SetSize( 300, 300 )

	local Cat = ctrl:Add( "Test category with text contents" )
	Cat:Add( "Item 1" )
	Cat:Add( "Item 2" )

	-- The contents can be any panel, even a DPanelList
	local Cat2 = ctrl:Add( "Test category with panel contents" )
	Cat2:SetTall( 100 )
	local Contents = vgui.Create( "DButton" )
	Contents:SetText( "This is the content of the category" )
	Cat2:SetContents( Contents )

	ctrl:InvalidateLayout( true )

	PropertySheet:AddSheet( ClassName, ctrl, nil, true, true )

end

derma.DefineControl( "bKeypads.SmoothScroll.CategoryList", "", PANEL, "bKeypads.SmoothScroll.HideVBar" )
--lua/vgui/dnumslider_legacy.lua:
--[[   _                                
    ( )                               
   _| |   __   _ __   ___ ___     _ _ 
 /'_` | /'__`\( '__)/' _ ` _ `\ /'_` )
( (_| |(  ___/| |   | ( ) ( ) |( (_| |
`\__,_)`\____)(_)   (_) (_) (_)`\__,_) 

	DNumberWang

--]]

local PANEL = {}

--[[---------------------------------------------------------
	
-----------------------------------------------------------]]
function PANEL:Init()

	--local TopPanel = vgui.Create( "Panel", self )
	--TopPanel:Dock( TOP )
	--TopPanel:SetHeight( 16 )

	self.Wang = vgui.Create ( "DNumberWang", self )
	self.Wang.OnValueChanged = function( wang, val ) self:ValueChanged( val ) end
	self.Wang:Dock( RIGHT )
	self.Wang:SetWidth( 50 )
	self.Wang:SetDrawBackground( false )
	self.Wang:HideWang()
	self.Wang:SetContentAlignment( 6 )
	
	self.Slider = vgui.Create( "DSlider", self )
	self.Slider:SetLockY( 0.5 )
	self.Slider.TranslateValues = function( slider, x, y ) return self:TranslateSliderValues( x, y ) end
	self.Slider:SetTrapInside( true )
	self.Slider:Dock( FILL )
	self.Slider:SetHeight( 16 )
	
	Derma_Hook( self.Slider, "Paint", "Paint", "NumSlider" )
	
	self.Label = vgui.Create ( "DLabel", self )
	self.Label:Dock( LEFT )
	self.Label:SetSize( 100 )
	
	self:SetTall( 32 )

	self:SetMin( 0 )
	self:SetMax( 1 )
	self:SetDecimals( 2 )
	self:SetText( "" )
	self:SetValue( 0.5 )

end

--[[---------------------------------------------------------
	SetMinMax
-----------------------------------------------------------]]
function PANEL:SetMinMax( min, max )
	self.Wang:SetMinMax( min, max )
	self:UpdateNotches()
end

function PANEL:SetDark( b )
	self.Label:SetDark( b )
end

--[[---------------------------------------------------------
	GetMin
-----------------------------------------------------------]]
function PANEL:GetMin()
	return self.Wang:GetMin()
end

--[[---------------------------------------------------------
	GetMin
-----------------------------------------------------------]]
function PANEL:GetMax()
	return self.Wang:GetMax()
end

--[[---------------------------------------------------------
	GetRange
-----------------------------------------------------------]]
function PANEL:GetRange()
	return self:GetMax() - self:GetMin()
end

--[[---------------------------------------------------------
	SetMin
-----------------------------------------------------------]]
function PANEL:SetMin( min )

	if ( !min ) then min = 0  end

	self.Wang:SetMin( min )
	self:UpdateNotches()
end

--[[---------------------------------------------------------
	SetMax
-----------------------------------------------------------]]
function PANEL:SetMax( max )

	if ( !max ) then max = 0  end

	self.Wang:SetMax( max )
	self:UpdateNotches()
end

--[[---------------------------------------------------------
   Name: SetConVar
-----------------------------------------------------------]]
function PANEL:SetValue( val )
	self.Wang:SetValue( val )
end

--[[---------------------------------------------------------
   Name: GetValue
-----------------------------------------------------------]]
function PANEL:GetValue()
	return self.Wang:GetValue()
end

--[[---------------------------------------------------------
   Name: SetDecimals
-----------------------------------------------------------]]
function PANEL:SetDecimals( d )
	self.Wang:SetDecimals( d )
	self:UpdateNotches()
end

--[[---------------------------------------------------------
   Name: GetDecimals
-----------------------------------------------------------]]
function PANEL:GetDecimals()
	return self.Wang:GetDecimals()
end


--[[---------------------------------------------------------
   Name: SetConVar
-----------------------------------------------------------]]
function PANEL:SetConVar( cvar )
	self.Wang:SetConVar( cvar )
end

--[[---------------------------------------------------------
   Name: SetText
-----------------------------------------------------------]]
function PANEL:SetText( text )
	self.Label:SetText( text )
end

--[[---------------------------------------------------------
   Name: ValueChanged
-----------------------------------------------------------]]
function PANEL:ValueChanged( val )

	self.Slider:SetSlideX( self.Wang:GetFraction( val ) )
	self:OnValueChanged( val )

end

--[[---------------------------------------------------------
   Name: OnValueChanged
-----------------------------------------------------------]]
function PANEL:OnValueChanged( val )

	
	-- For override

end

--[[---------------------------------------------------------

-----------------------------------------------------------]]
function PANEL:TranslateSliderValues( x, y )

	self.Wang:SetFraction( x )
	
	return self.Wang:GetFraction(), y

end

--[[---------------------------------------------------------
   Name: GetTextArea
-----------------------------------------------------------]]
function PANEL:GetTextArea()

	return self.Wang:GetTextArea()

end

function PANEL:UpdateNotches()

	local range = self:GetRange()
	self.Slider:SetNotches( nil )
	
	if ( range < self:GetWide()/4 ) then
		return self.Slider:SetNotches( range )
	else
		self.Slider:SetNotches( self:GetWide()/4 )
	end

end

--[[---------------------------------------------------------
   Name: GenerateExample
-----------------------------------------------------------]]
function PANEL:GenerateExample( ClassName, PropertySheet, Width, Height )

	local ctrl = vgui.Create( ClassName )
		ctrl:SetWide( 200 )
		ctrl:SetMin( 1 )
		ctrl:SetMax( 10 )
		ctrl:SetText( "Example Slider!" )
		ctrl:SetDecimals( 0 )
	
	PropertySheet:AddSheet( ClassName, ctrl, nil, true, true )

end

derma.DefineControl( "DNumSliderLegacy", "Menu Option Line", table.Copy(PANEL), "Panel" )

--addons/openpermissions/lua/vgui/openpermissions_horizontaldivider.lua:
local PANEL = {}

function PANEL:SetRightWidth(width)
	self.InitialRightWidth = width

	local oldpaint = self.Paint
	self.Paint = function(self, w, h)
		self:SetLeftWidth(w - self.InitialRightWidth)
		self.Paint = oldpaint
	end
end

function PANEL:BalanceWidths()
	local oldpaint = self.Paint
	self.Paint = function(self, w, h)
		self:SetLeftWidth((w - self:GetDividerWidth()) / 2)
		self.Paint = oldpaint
	end
end

derma.DefineControl("OpenPermissions.HorizontalDivider", nil, PANEL, "DHorizontalDivider")
--addons/openpermissions/lua/vgui/openpermissions_listview.lua:
local PANEL = {}

function PANEL:Init()
	self.CurrentOffset = 0
	self.TargetOffset = 0
	self.StartTime = 0
	self.EndTime = 0

	self.VBar:SetHideButtons(true)
	self.VBar:SetWide(5)
	self.VBar:DockMargin(3,3,3,3)

	function self.VBar:Paint() end
	function self.VBar.btnGrip:Paint(w,h)
		surface.SetDrawColor(0,0,0,150)
		surface.DrawRect(0,0,w,h)
	end

	self.VBar.CurrentY = 0
	self.VBar.TargetY = 0
	function self.VBar:PerformLayout()

		local Wide = self:GetWide()
		local BtnHeight = Wide
		if ( self:GetHideButtons() ) then BtnHeight = 0 end
		local Scroll = self:GetScroll() / self.CanvasSize
		local BarSize = math.max( self:BarScale() * ( self:GetTall() - ( BtnHeight * 2 ) ), 10 )
		local Track = self:GetTall() - ( BtnHeight * 2 ) - BarSize
		Track = Track + 1

		Scroll = Scroll * Track

		self.TargetY = BtnHeight + Scroll
		self.btnGrip:SetSize( Wide, BarSize )

		if ( BtnHeight > 0 ) then
			self.btnUp:SetPos( 0, 0, Wide, Wide )
			self.btnUp:SetSize( Wide, BtnHeight )

			self.btnDown:SetPos( 0, self:GetTall() - BtnHeight )
			self.btnDown:SetSize( Wide, BtnHeight )
			
			self.btnUp:SetVisible( true )
			self.btnDown:SetVisible( true )
		else
			self.btnUp:SetVisible( false )
			self.btnDown:SetVisible( false )
			self.btnDown:SetSize( Wide, BtnHeight )
			self.btnUp:SetSize( Wide, BtnHeight )
		end

	end

	function self.VBar:Think()
		self.CurrentY = Lerp(FrameTime() * 10, self.CurrentY, self.TargetY)
		self.btnGrip:SetPos(0, math.Round(self.CurrentY))
	end

	self.pnlCanvas.CurrentOffset = 0
	self.pnlCanvas.TargetOffset = 0
	function self.pnlCanvas:Think()
		self.CurrentOffset = Lerp(FrameTime() * 10, self.CurrentOffset, self.TargetOffset)
		self:SetPos(0, math.Round(self.CurrentOffset + self:GetParent():GetHeaderHeight()))
	end
end

function PANEL:OnVScroll(offset)
	self.pnlCanvas.TargetOffset = offset
end

function PANEL:PerformLayout()

	-- Do Scrollbar
	local Wide = self:GetWide()
	local YPos = 0

	if ( IsValid( self.VBar ) ) then

		self.VBar:SetPos( self:GetWide() - 5 - 3, 3 )
		self.VBar:SetSize( 5, self:GetTall() - 6 )
		self.VBar:SetUp( self.VBar:GetTall() - self:GetHeaderHeight(), self.pnlCanvas:GetTall() )
		YPos = self.VBar:GetOffset()

		if ( self.VBar.Enabled ) then Wide = Wide - 5 end

	end

	if ( self.m_bHideHeaders ) then
		self.pnlCanvas:SetPos( 0, YPos )
	else
		self.pnlCanvas:SetPos( 0, YPos + self:GetHeaderHeight() )
	end

	self.pnlCanvas:SetSize( Wide + self.VBar:GetWide(), self.pnlCanvas:GetTall() )

	self:FixColumnsLayout()

	--
	-- If the data is dirty, re-layout
	--
	if ( self:GetDirty() ) then

		self:SetDirty( false )
		local y = self:DataLayout()
		self.pnlCanvas:SetTall( y )

		-- Layout again, since stuff has changed..
		self:InvalidateLayout( true )

	end

end

derma.DefineControl("OpenPermissions.ListView", nil, PANEL, "DListView")
--lua/vgui/stackerpreseteditor.lua:
--[[--------------------------------------------------------------------------
-- 	Namespace Tables
--------------------------------------------------------------------------]]--

local PANEL = {}

--[[--------------------------------------------------------------------------
-- 	Localized Functions & Variables
--------------------------------------------------------------------------]]--

local vgui = vgui
local pairs = pairs
local AccessorFunc = AccessorFunc
local GetConVarString = GetConVarString

--[[--------------------------------------------------------------------------
--	Namespace Functions
--------------------------------------------------------------------------]]--

AccessorFunc( PANEL, "m_ConCommands", "ConCommands" )

--[[--------------------------------------------------------------------------
--
--	PANEL:Add()
--
--]]--
function PANEL:Add()
	if ( not self.m_ConVars ) then return end
	
	local ToName = self.txtName:GetValue()
	if ( not ToName or ToName == "" ) then return end
	
	-- Todo, Handle name collision
	local tabValues = {}
	
	for k, v in pairs( self.m_ConVars ) do
		tabValues[ v.CCmd ] = GetConVarString( v.CVar )
	end
		
	presets.Add( self.m_strType, ToName, tabValues )
	self:Update()
	self.PresetList:SelectByName( ToName )
	self.txtName:SetText( "" )
	
	if ( self.m_PresetControl ) then
		self.m_PresetControl:Update()
	end
end

vgui.Register( "StackerPresetEditor", PANEL, "PresetEditor" )
--addons/fusioncutter/lua/weapons/alydus_fusioncutter.lua:
--[[ 
	© Alydus.net
	Do not reupload lua to workshop without permission of the author

	Star Wars Fusion Cutter Repairer
	
	Alydus: (officialalydus@gmail.com | STEAM_0:1:57622640)
--]]

AddCSLuaFile()

if CLIENT then
	SWEP.PrintName = "F-187 Fusion Cutter [DEPRECATED]"
	SWEP.Slot = 1
	SWEP.SlotPos = 1
	SWEP.DrawAmmo = false
	SWEP.DrawCrosshair = false

	surface.CreateFont("Orbitron40", {font = "Orbitron Regular", size = 40})
end

SWEP.Instructions = "Outdated Fusion Cutter"
SWEP.Contact = ""
SWEP.Purpose = ""
SWEP.WorldModel = ""
SWEP.Spawnable = false
SWEP.AdminOnly = false
SWEP.Category = "SW:RP (Support)"

SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = true
SWEP.Primary.Ammo = "none"
SWEP.Primary.Delay = 0.5

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"
SWEP.Secondary.Delay = 0.5

SWEP.HoldType = "slam"
SWEP.ViewModelFOV = 70
SWEP.ViewModelFlip = false
SWEP.UseHands = false
SWEP.ViewModel = ""
SWEP.WorldModel = ""


function SWEP:PrimaryAttack()
	return false
end

function SWEP:SecondaryAttack()
	return false
end

function SWEP:Reload()
	return false
end

function SWEP:Initialize()
	self:SetHoldType("slam")
end

function SWEP:Holster()
	self:Remove()
end

function SWEP:OnRemove()
	self:Holster()
end

hook.Add("WeaponEquip", "RemoveOldFusioncutter", function(weapon, owner)
	if weapon:GetClass() == "alydus_fusioncutter" then
		weapon:Remove()
	end
end)
--lua/weapons/awhg_bobs_gun_base/cl_init.lua:
include('shared.lua')

SWEP.PrintName				= ""				// 'Nice' Weapon name (Shown on HUD)	
SWEP.Slot				= 4				// Slot in the weapon selection menu
SWEP.SlotPos				= 1				// Position in the slot
SWEP.DrawAmmo				= true				// Should draw the default HL2 ammo counter				// Should draw the default crosshair
SWEP.DrawWeaponInfoBox			= true			// Should draw the weapon info box
SWEP.BounceWeaponIcon   			= false				// Should the weapon icon bounce?
SWEP.CSMuzzleFlashes			= false


--addons/egm_tfa_weapons/lua/weapons/b2_gun.lua:
-- Written by Oninoni

SWEP.Base                   = "weapon_swrp_egm_base"

SWEP.PrintName              = "B2 Wrist Blaster"
SWEP.Category               = "SW:RP (Separatisten)"
SWEP.Type					= "Republic Heavy Blaster Rifle"
SWEP.Manufacturer           = "Baktoid Armor Workshop"
SWEP.Slot                   = 2
SWEP.SlotPos                = 0

SWEP.Spawnable = true

-- Model --

SWEP.ViewModel						= "models/weapons/synbf3/c_dlt19.mdl"
SWEP.WorldModel						= "models/weapons/synbf3/w_dlt19.mdl"

SWEP.VMPos = Vector(1.96, 0, -0.52)
SWEP.VMAng = Vector(0,0,0)

SWEP.HoldType 						= "pistol"
SWEP.ReloadHoldTypeOverride 		= "pistol"

SWEP.UseHands 						= false

SWEP.ShowWorldModel = false

SWEP.ViewModelBoneMods = {
	["v_dlt19_reference001"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) }
}

SWEP.VElements = {
	["b2"] = { type = "Model", model = "models/cs574/weapons/b2_hand.mdl", bone = "v_scoutblaster_reference001", rel = "", pos = Vector(0, 0, 0), angle = Angle(0, 0, 0), size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
}

SWEP.WElements = {
	["b2_gun"] = {  }
}

-- Tracer --

-- Tracer name
SWEP.TracerName 					= "rw_sw_laser_red"



-- Magazine --

-- Ammo per Magazine
SWEP.Primary.ClipSize				= 100
-- Magazine Count
SWEP.Primary.DefaultClip			= SWEP.Primary.ClipSize * 8
-- Ammo Type
SWEP.Primary.Ammo					= "ar2"
-- Ammo Consumption per shot
SWEP.Primary.AmmoConsumption 		= 2

-- Fire Modes --

-- Actual Fire Modes.
SWEP.FireModes = {
	"Automatic",
	"Single",
}

-- Automatic RPM
SWEP.Primary.RPM					= 380
-- Semi Automatic Fire RPM
SWEP.Primary.RPM_Semi				= 200

-- Burst Fire RPM
SWEP.Primary.RPM_Burst				= nil
-- Delay Between Bursts
SWEP.Primary.BurstDelay				= nil

-- Range --

-- Max Range of weapon
SWEP.Primary.Range 					= 4000

-- Shooting --

-- Number of bullets per shot (For Shotguns)
SWEP.Primary.NumShots				= 2
-- Damage per bullet
SWEP.Primary.Damage = 28

-- Aiming --

SWEP.data 							= {}
-- Enable Iron Sights
SWEP.data.ironsights				= 0
-- Iron Sights FOV
SWEP.Secondary.IronFOV				= 75 -- TODO

SWEP.ScopeReticule 					= "#sw/visor/sw_ret_redux_blue"
SWEP.Secondary.ScopeZoom 			= 7
SWEP.ScopeReticule_Scale 			= {1,1}

SWEP.Primary.Spread					= 0.03
SWEP.Primary.IronAccuracy 			= 0.01

SWEP.Primary.SpreadMultiplierMax 	= 2.5
SWEP.Primary.SpreadIncrement 		= 0.35

-- Holding Positions

-- Aiming
SWEP.IronSightsPos = Vector(-5.5, -5, 1)
SWEP.IronSightsAng = Vector(0, 0, 0)
-- Running
SWEP.RunSightsPos = Vector(5.226, -2, 0)
SWEP.RunSightsAng = Vector(-18, 36, -13.5)
-- Inspecting
SWEP.InspectPos = Vector(8, -4.8, -3)
SWEP.InspectAng = Vector(11.199, 38, 0)

-- Sounds --

-- Fire Sound
SWEP.Primary.Sound = Sound("w/b2_blaster.wav")
-- Reload Sound
SWEP.Primary.ReloadSound = Sound("w/b2_reload.wav")
--addons/bkeypads/lua/weapons/bkeycard/cl_init.lua:
include("shared.lua")

function SWEP:Reload()
	if IsFirstTimePredicted() and LocalPlayer():KeyPressed(IN_RELOAD) then
		if IsValid(bKeypads_Keycard_Inventory) then
			bKeypads_Keycard_Inventory:Remove()
			surface.PlaySound("weapons/smg1/switch_single.wav")
		elseif not self:GetBeingScanned() then
			local heldKeycards = bKeypads.Keycards.Inventory:GetHeldKeycards(LocalPlayer())
			if bKeypads.Config.Keycards.CanDropKeycard then
				if not self:GetWasPickedUp() or heldKeycards then
					bKeypads.Keycards.Inventory:Show()
				end
			else
				if heldKeycards and (not self:GetWasPickedUp() or next(heldKeycards, next(heldKeycards))) then
					bKeypads.Keycards.Inventory:Show()
				end
			end
		end
	end
	return true
end

do
	local WorldModelPos = Vector(5.5, -2.5, -1.5)
	local WorldModelAng = Angle(5, 0, 10)

	-- x = forward
	-- y = right
	-- z = down
	local KeycardSlotPosMins = Vector(-0.04, 0, 5.6)
	
	function SWEP:DrawWorldKeycard(keypad)
		if not IsValid(self.ClientWorldModel) then return end
		
		local ply = self:GetOwner()
		if IsValid(ply) then
			self.ClientWorldModel:SetOwner(ply)

			local pos, ang
			if keypad then
				pos = keypad:GetPos()
				ang = keypad:GetAngles()

				pos = keypad:LocalToWorld(KeycardSlotPosMins)

				ang:RotateAroundAxis(ang:Up(), 180)
				ang:RotateAroundAxis(ang:Right(), 90)

				self.ClientWorldModel:SetModelScale(0.74)
			else
				self.ClientWorldModel:SetModelScale(1)

				local boneID = ply:LookupBone("ValveBiped.Bip01_R_Hand")
				if not boneID then return end

				local boneMatrix = ply:GetBoneMatrix(boneID)
				if not boneMatrix then return end

				pos, ang = LocalToWorld(WorldModelPos, WorldModelAng, boneMatrix:GetTranslation(), boneMatrix:GetAngles())
			end

			self.ClientWorldModel:SetPos(pos)
			self.ClientWorldModel:SetAngles(ang)
			
			self.ClientWorldModel:DrawModel()
		else
			self.ClientWorldModel:SetOwner(NULL)

			self.ClientWorldModel:SetPos(self:GetPos())
			self.ClientWorldModel:SetAngles(self:GetAngles())

			self.ClientWorldModel:DrawModel()
		end

		self:DrawIdentification(self.ClientWorldModel)
		bKeypads.Keycards.Textures:Draw(bKeypads.Keycards.Textures.BOTH, self.ClientWorldModel, self)
	end
end

function SWEP:DrawWorldModel()
	if not self:GetBeingScanned() then
		self:DrawWorldKeycard()
	end
end
SWEP.DrawWorldModelTranslucent = SWEP.DrawWorldModel

function SWEP:ShouldDrawViewModel()
	return self:GetBeingScanned() ~= true
end

function SWEP:DoDrawCrosshair()
	return self:GetBeingScanned()
end

function SWEP:DrawIdentification(keycard)
	if not bKeypads.Config.Keycards.ShowID.AllowIndentification then return end
	if halo.RenderedEntity() == self or halo.RenderedEntity() == keycard or not IsValid(self:GetOwner()) then return end

	local alpha_3d2d = (bKeypads.Performance:Optimizing() and bKeypads.Performance:Alpha3D2D(EyePos():DistToSqr(keycard:LocalToWorld(keycard:OBBCenter()))) or 1) * 255
	if alpha_3d2d == 0 then return end

	if not self:GetBeingScanned() and (self:GetIdentifying() or (self.IdentifyingAnimEnd and SysTime() <= self.IdentifyingAnimEnd)) then
		self:DrawIdentificationBubble(alpha_3d2d, keycard)
	end
end

do
	surface.CreateFont("bKeypads.ID.Identification", {
		font = "Verdana",
		size = 100,
		weight = 700,
		shadow = true
	})

	local bubbleWorldOffset = Vector(0,0,1.5)
	local bubbleViewOffset  = Vector(1,1,1)

	local bubbleWidth, bubblePadding = 2250, 100
	local bubbleTailWidth, bubbleTailHeight, bubbleTailPoly = 100, 75, {{},{},{}}

	function SWEP:DrawIdentificationBubble(alpha_3d2d, keycard)
		if not self.IdentifyingAnimStart or not self.IdentifyingAnimEnd then return end

		local viewEnt = GetViewEntity()
		if not IsValid(viewEnt) then return end

		local viewOrigin = viewEnt:IsPlayer() and viewEnt:EyePos() or viewEnt:GetPos()

		local pos, ang, scale = keycard:LocalToWorld(keycard:OBBCenter())

		if keycard == self.ClientViewModel then
			scale = .005

			ang = EyeAngles()
			
			ang:RotateAroundAxis(ang:Forward(), 90)
			ang:RotateAroundAxis(ang:Right(), 90)
			ang:RotateAroundAxis(ang:Right(), -15)

			pos = pos - (ang:Right() * bubbleViewOffset)
		else
			scale = .01

			pos = pos + bubbleWorldOffset

			ang = (pos - viewOrigin):Angle()
			ang:RotateAroundAxis(ang:Forward(), 90)
			ang:RotateAroundAxis(ang:Right(), 90)
		end

		local dist = viewOrigin:DistToSqr(pos)
		local distFrac = math.Clamp(1 - (dist / bKeypads.Config.Keycards.ShowID.Distance), 0, 1)
		local animFrac = math.abs(self.IdentifyingAnim - math.min(math.TimeFraction(self.IdentifyingAnimStart, self.IdentifyingAnimEnd, SysTime()), 1))
		local borderFrac = distFrac * animFrac * math.Clamp(1 - (dist / 10000), 0.05, 1)

		local bubble_alpha = distFrac * animFrac * (alpha_3d2d / 255)
		if (bubble_alpha == 0) then return end

		cam.Start3D2D(pos, ang, scale)
			surface.SetAlphaMultiplier(bubble_alpha)

			draw.NoTexture()

			local txt = self:GetShowIDMessage()

			local w,h = txt:GetWidth(), txt:GetHeight()
			local totalW, totalH = w + bubblePadding, h + bubblePadding
			local centerOffset = totalW / 2

			surface.SetDrawColor(0,0,0,200)
			surface.DrawRect(-centerOffset, -totalH, totalW, totalH)

			bubbleTailPoly[1].x = -bubbleTailWidth / 2
			bubbleTailPoly[1].y = 0
			bubbleTailPoly[2].x = bubbleTailWidth / 2
			bubbleTailPoly[2].y = 0
			bubbleTailPoly[3].x = 0
			bubbleTailPoly[3].y = bubbleTailHeight
			surface.DrawPoly(bubbleTailPoly)

			txt:Draw((bubblePadding / 2) - centerOffset, (bubblePadding / 2) - totalH)

			surface.SetAlphaMultiplier(borderFrac)
			surface.SetDrawColor(keycard:GetKeycardColor())
			surface.DrawLine(-centerOffset, -totalH, totalW - centerOffset, -totalH)
			surface.DrawLine(-centerOffset, -totalH, -centerOffset, 0)
			surface.DrawLine(totalW - centerOffset, -totalH, totalW - centerOffset, 0)

			surface.DrawLine(-centerOffset, 0, bubbleTailPoly[1].x, 0)
			surface.DrawLine(bubbleTailPoly[2].x, 0, totalW - centerOffset, 0)
			surface.DrawLine(bubbleTailPoly[1].x, 0, 0, bubbleTailPoly[3].y)
			surface.DrawLine(0, bubbleTailPoly[3].y, bubbleTailPoly[2].x, 0)

			surface.SetAlphaMultiplier(1)
		cam.End3D2D()
	end

	do
		local markupSafeShowIDMessage
		local function escapeShowIDMessage()
			markupSafeShowIDMessage = bKeypads.Config.Keycards.ShowID.MessageMarkup and bKeypads.Config.Keycards.ShowID.Message or bKeypads.markup.Escape(bKeypads.Config.Keycards.ShowID.Message)
		end
		escapeShowIDMessage()
		hook.Add("bKeypads.ConfigUpdated", "bKeypads.ShowIDMessage", escapeShowIDMessage)

		local function getKeycardTeamName(ply, plyTeam)
			if DarkRP and RPExtraTeams and RPExtraTeams[plyTeam] and RPExtraTeams[plyTeam].KeycardIdentifiesAs ~= nil then
				return tostring(RPExtraTeams[plyTeam].KeycardIdentifiesAs)
			end
			return DarkRP and bKeypads.Config.Keycards.ShowCustomJobName and ply.getDarkRPVar and ply:getDarkRPVar("job") or team.GetName(plyTeam)
		end

		function SWEP:GetShowIDMessage()
			local ply = self:GetOwner()
			local plyTeam = ply:Team()
			local str = (
				markupSafeShowIDMessage
				:gsub("%%keycard%%",   "<color=" .. bKeypads.markup.Color(self:GetKeycardColor()) .. ">" .. bKeypads.markup.Escape(self:GetKeycardName()) .. "</color>")
				:gsub("%%level%%",     "<color=" .. bKeypads.markup.Color(self:GetKeycardColor()) .. ">" .. bKeypads.markup.Escape(self:GetPrimaryLevel()) .. "</color>")
				:gsub("%%name%%",      "<color=" .. bKeypads.markup.Color(team.GetColor(plyTeam)) .. ">" .. bKeypads.markup.Escape(ply:Nick()) .. "</color>")
				:gsub("%%team%%",      "<color=" .. bKeypads.markup.Color(team.GetColor(plyTeam)) .. ">" .. bKeypads.markup.Escape(getKeycardTeamName(ply, plyTeam)) .. "</color>")
				:gsub("%%usergroup%%", "<color=" .. bKeypads.markup.Color(self:GetKeycardColor()) .. ">" .. bKeypads.markup.Escape(ply:GetUserGroup()) .. "</color>")
			)
			if self.ShowIDMessage ~= str then
				self.ShowIDMessage = markup.Parse("<font=bKeypads.ID.Identification>" .. str .. "</font>", bubbleWidth)
			end
			return self.ShowIDMessage
		end
	end

	function SWEP:IdentifyingStatusChanged(_, __, isIdentifying)
		if not bKeypads.Config.Keycards.ShowID.AllowIndentification then return end
		if self:GetBeingScanned() then return end

		local viewEnt = GetViewEntity()
		if not IsValid(viewEnt) then return end

		local distFrac
		if viewEnt == LocalPlayer() or not IsValid(self.ClientWorldModel) then
			distFrac = 1
		else
			local viewOrigin = viewEnt:IsPlayer() and viewEnt:EyePos() or viewEnt:GetPos()

			local pos = self.ClientWorldModel:LocalToWorld(self.ClientWorldModel:OBBCenter()) + bubbleWorldOffset
			local dist = viewOrigin:DistToSqr(pos)
			distFrac = math.Clamp(1 - (dist / bKeypads.Config.Keycards.ShowID.Distance), 0, 1)
		end

		self:EmitSound(isIdentifying and "buttons/button9.wav" or "buttons/combine_button1.wav", nil, nil, distFrac)
		
		self.IdentifyingAnimStart = SysTime()
		self.IdentifyingAnimEnd = SysTime() + (isIdentifying and .1 or .5)
		self.IdentifyingAnim = isIdentifying and 0 or 1
	end
end

surface.CreateFont("bKeypads.ID.WeaponSelection.Level", {
	font = "Consolas",
	shadow = true,
	size = 22
})

surface.CreateFont("bKeypads.ID.WeaponSelection.Name", {
	font = "Consolas",
	weight = 700,
	bold = true,
	shadow = true,
	size = 24
})

local refresh = true
function SWEP:DrawWeaponSelection(x, y, w, h, alpha)
	if refresh then
		refresh = nil
		if IsValid(self.WeaponSelection) then
			self.WeaponSelection:Remove()
		end
	end
	if not IsValid(self.WeaponSelection) then
		self.WeaponSelection = vgui.Create("DModelPanel")
		self.WeaponSelection:SetMouseInputEnabled(false)
		self.WeaponSelection:SetPaintedManually(true)
		self.WeaponSelection:SetModel(bKeypads.MODEL.KEYCARD)

		local mn, mx = self.WeaponSelection.Entity:GetRenderBounds()
		local size = 0
		size = math.max(size, math.abs(mn.x) + math.abs(mx.x))
		size = math.max(size, math.abs(mn.y) + math.abs(mx.y))
		size = math.max(size, math.abs(mn.z) + math.abs(mx.z))

		self.WeaponSelection:SetFOV(60)
		self.WeaponSelection:SetCamPos(Vector(size, size, size))
		self.WeaponSelection:SetLookAt((mn + mx) * 0.5)

		self.WeaponSelection.Entity.bKeycard = true
		self.WeaponSelection.PreDrawModel = function()
			self.WeaponSelection.Entity.KeycardColor = self:GetKeycardColor()
			bKeypads.Keycards.Textures:Draw(bKeypads.Keycards.Textures.TOP, self.WeaponSelection.Entity, self)
		end
	end

	self.WeaponSelection:SetSize(w, h)
	self.WeaponSelection:SetPos(x, y)
	self.WeaponSelection:PaintManual()

	local levels = self:GetLevels()
	if #levels > 1 and #levels < 9 then
		surface.SetFont("bKeypads.ID.WeaponSelection.Level")
		local levels_x = x + (((((25 + 5) * #levels) - 5) + w) / 2)
		for i, level in ipairs(levels) do
			local level_x, level_y = levels_x - (i * 25) - ((i - 1) * 5), y + h - 25 - 30
			surface.SetDrawColor(0,0,0,150)
			surface.DrawRect(level_x, level_y, 25, 25)

			surface.SetTextColor(bKeypads.Keycards.Levels[level].Color or color_white)
			local txtW, txtH = surface.GetTextSize(tostring(level))
			surface.SetTextPos(level_x + ((25 - txtW) / 2), level_y + ((25 - txtH) / 2))
			surface.DrawText(level)
		end
	else
		local keycardMetadata = self:GetKeycardMetadata()
		local txt = keycardMetadata.Name or bKeypads.L("KeycardLevel"):format(tonumber(self:GetKeycardLevel()) or 1)
		surface.SetFont("bKeypads.ID.WeaponSelection.Name")
		surface.SetTextColor(keycardMetadata.Color)
		local txtW, txtH = surface.GetTextSize(txt)
		surface.SetTextPos(x + ((w / 2) - (txtW / 2)), y + h - txtH * 2 - 10)
		surface.DrawText(txt)
	end
	
	if self.Instructions ~= bKeypads.L("KeycardInstructions") then -- hacky fix for weapon info not handling language strings properly
		self.Instructions = bKeypads.L("KeycardInstructions")
		self.InfoMarkup = nil
	end
	self:PrintWeaponInfo(x + w + 20, y + h * 0.95, alpha)
end

local ViewModelPos = Vector(5.5,-1.4,-1.9)
function SWEP:PreDrawViewModel(vm, _, ply)
	if IsValid(self.ClientViewModel) then
		self.ClientViewModel:SetOwner(ply)
		
		local boneID = vm:LookupBone("ValveBiped.Bip01_R_Hand")
		if not boneID then return end

		local boneMatrix = vm:GetBoneMatrix(boneID)
		if not boneMatrix then return end

		local pos, ang = LocalToWorld(ViewModelPos, angle_zero, boneMatrix:GetTranslation(), boneMatrix:GetAngles())

		self.ClientViewModel:SetPos(pos)
		self.ClientViewModel:SetAngles(ang)
		self.ClientViewModel:DrawModel()

		self:DrawIdentification(self.ClientViewModel)
		
		bKeypads.Keycards.Textures:Draw(bKeypads.Keycards.Textures.BOTTOM, self.ClientViewModel, self)
	end
end

--addons/bkeypads/lua/weapons/bkeycard/shared.lua:
SWEP.Base = "weapon_base"

SWEP.Category = "Billy's Keypads"
SWEP.PrintName = "#bKeypads_Keycard"
SWEP.Instructions = "#bKeypads_KeycardInstructions"
SWEP.Purpose = nil
SWEP.Contact = nil
SWEP.Slot = 5
SWEP.SlotPos = 128
SWEP.DrawAmmo = false
SWEP.DrawCrosshair = true

SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = 0
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = ""

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = ""

SWEP.HoldType = "pistol"
SWEP.ViewModelFOV = 70
SWEP.ViewModelFlip = false
SWEP.UseHands = true
SWEP.ViewModel = "models/bkeypads/c_keycard.mdl"
SWEP.WorldModel = "models/bkeypads/keycard.mdl"
SWEP.ShowViewModel = true
SWEP.ShowWorldModel = true

SWEP.DisableDuplicator = true

SWEP.CanDrop = false
SWEP.Droppable = false

SWEP.RenderGroup = RENDERGROUP_TRANSLUCENT

function SWEP:ShouldDropOnDie() return false end
function SWEP:PrimaryAttack() return true end
function SWEP:SecondaryAttack() return true end
function SWEP:Reload() return true end
function SWEP:Holster() return true end
function SWEP:Deploy() return true end

function SWEP:Initialize()
	self.bKeycard = true
	self.CachedKeycardLevels = { [1] = true }
	self.CachedKeycardLevel = 1

	self:SetHoldType(self.HoldType)

	if CLIENT then
		self.ClientWorldModel = ClientsideModel(self.WorldModel, RENDERGROUP_OPAQUE)
		self.ClientWorldModel:SetParent(self)
		self.ClientWorldModel:SetNoDraw(true)
		self.ClientWorldModel.bKeycard = true
		self.ClientWorldModel.GetKeycardColor = function()
			if not IsValid(self) then
				return color_white
			else
				return self:GetKeycardColor()
			end
		end

		self.ClientViewModel = ClientsideModel(self.WorldModel, RENDERGROUP_VIEWMODEL)
		self.ClientViewModel:SetParent(self)
		self.ClientViewModel:SetNoDraw(true)
		self.ClientViewModel.bKeycard = true
		self.ClientViewModel.GetKeycardColor = function()
			if not IsValid(self) then
				return color_white
			else
				return self:GetKeycardColor()
			end
		end

		self.Identification = { Over = {}, Under = {} }
	else
		self:PhysicsInit(MOVETYPE_VPHYSICS)
		local phys = self:GetPhysicsObject()
		if IsValid(phys) then
			phys:Wake()
		end
	end
end

function SWEP:SetupDataTables()
	self:NetworkVar("Int", 0, "SelectedKeycard")

	self:NetworkVar("Bool", 0, "WasPickedUp")
	self:NetworkVar("Bool", 1, "BeingScanned")
	self:NetworkVar("Bool", 2, "Identifying")

	if CLIENT then
		self:NetworkVarNotify("Identifying", self.IdentifyingStatusChanged)
	end

	self:NetworkVarNotify("SelectedKeycard", self.SelectedKeycardChanged)
end

function SWEP:GetKeycardMetadata()
	return bKeypads.Keycards.Levels[self:GetPrimaryLevel()] or bKeypads.Keycards.Levels[1]
end

function SWEP:SelectedKeycardChanged(_, prev, selectedKeycard)
	self.m_iSelectedKeycardID = selectedKeycard

	if prev ~= selectedKeycard then
		self:EmitSound("weapons/smg1/switch_burst.wav", 55, 100, 1, CHAN_WEAPON)
	end
end

function SWEP:GetPlayerKeycardData()
	if IsValid(self:GetOwner()) then
		if not self.m_PlayerKeycardData_NextUpdate or (not self:GetOwner():IsDormant() and SysTime() >= self.m_PlayerKeycardData_NextUpdate) then
			self.m_PlayerKeycardData_NextUpdate = SysTime() + 2
			self.m_PlayerKeycardData = bKeypads.Keycards:GetKeycardData(self:GetOwner())
		end

		return self.m_PlayerKeycardData
	end
end

local defaultKeycardData = {
	PrimaryLevel = 1,
	Levels = {},
	LevelsDict = {}
}
function SWEP:GetSelectedKeycardData()
	self.m_iSelectedKeycardID = self.m_iSelectedKeycardID or self:GetSelectedKeycard()

	if self.m_iSelectedKeycardID ~= 0 then
		local keycardData = bKeypads.Keycards:GetByID(self.m_iSelectedKeycardID)
		if keycardData then
			return keycardData
		end
	end

	return self:GetPlayerKeycardData() or defaultKeycardData
end

function SWEP:GetLevels()
	return self:GetSelectedKeycardData().Levels
end

function SWEP:GetLevelsDictionary()
	return self:GetSelectedKeycardData().LevelsDict
end

function SWEP:GetPrimaryLevel()
	return self:GetSelectedKeycardData().PrimaryLevel
end

function SWEP:GetKeycardColor()
	return self:GetKeycardMetadata().Color
end

function SWEP:GetKeycardName()
	return self:GetKeycardMetadata().Name or (bKeypads.L"KeycardLevel"):format(self:GetKeycardLevel())
end

function SWEP:GetSteamID()
	return self:GetSelectedKeycardData().SteamID or ""
end

function SWEP:GetTeam()
	return self:GetSelectedKeycardData().Team or ""
end

function SWEP:GetPlayerModel()
	return self:GetSelectedKeycardData().PlayerModel or ""
end

function SWEP:GetHash()
	return util.CRC(self:GetSteamID() .. self:GetPlayerModel() .. (table.concat(self:GetLevels(), ",")) .. (IsValid(self:GetOwner()) and DarkRP and bKeypads.Config.Keycards.ShowCustomJobName and self:GetOwner().getDarkRPVar and self:GetOwner():getDarkRPVar("job") or (self:GetTeam() ~= 0 and self:GetTeam() or "")))
end
--addons/climb_swep_2/lua/weapons/climb_swep2/shared.lua:
SWEP.Author              = "Jonascone"
SWEP.Contact             = ""
SWEP.Purpose             = "A reiteration of the Climb SWEP."
SWEP.Instructions        = "Refer to the Workshop page!"

SWEP.Spawnable                  = true
SWEP.AdminSpawnable             = false

SWEP.ViewModel                  = "models/weapons/v_pistol.mdl"
SWEP.HoldType                   = "normal"

SWEP.Primary.ClipSize           = -1
SWEP.Primary.DefaultClip        = -1
SWEP.Primary.Automatic          = false
SWEP.Primary.Ammo               = "none"

SWEP.Secondary.ClipSize         = -1
SWEP.Secondary.DefaultClip      = -1
SWEP.Secondary.Automatic        = true
SWEP.Secondary.Ammo             = "none"

local HitPlayer = { Sound("npc/vort/foot_hit.wav"), Sound("npc/zombie/zombie_hit.wav") }
local MatList = { }
MatList[67] = "concrete"
MatList[68] = "dirt"
MatList[71] = "chainlink"
MatList[76] = "tile"
MatList[77] = "metal"
MatList[78] = "dirt"
MatList[84] = "tile"
MatList[86] = "duct"
MatList[87] = "wood"

function SWEP:DrawWorldModel() return false; end

function SWEP:Initialize()
	self:SetWeaponHoldType(self.HoldType)
	self.Weapon:DrawShadow(false)
	self.nextThink = 0
	self.Jumps = 0
	self.JumpSequence = 0
	self.EasterEgg = false
	self.Released = false
	self.MFC = "male"
	self.WallJumpTrace = nil
	self.CanWallRun = true
	self.WallRunAnim = 0
	return true
end
function SWEP:Deploy()
	self.Owner:DrawViewModel(false)
	if string.find(self.Owner:GetModel(), "female") or string.find(self.Owner:GetModel(), "alyx") or string.find(self.Owner:GetModel(), "mossman") then self.MFC = "female"
	elseif string.find(self.Owner:GetModel(), "combine") or string.find(self.Owner:GetModel(), "metro") then self.MFC = "combine"
	else self.MFC = "male" end

	self.Owner:SetNWBool("ClimbWallJump", false)
	self.Owner:SetNWBool("ClimbFalling", false)
	self.Owner:SetNWBool("ClimbWallRun", false)
	self.Released = false
	self.CanWallRun = true;		
	self.Parent = NULL;
end
function SWEP:Forget()

	if self.Grab then
		if self.Owner:GetMoveType() == MOVETYPE_NONE then self.Owner:SetMoveType(MOVETYPE_WALK) end
		self.Grab = false
		self.Parent = NULL;
	end
	return true

end
function SWEP:Think()

	if CLIENT or !IsValid(self.Owner) or !self.Owner:Alive() then return false end

	if self.Jumps != self.Owner:GetNWInt("ClimbJumps") then self.Owner:SetNWInt("ClimbJumps", self.Jumps) end
	if !self.Released and !self.Owner:KeyDown(IN_ATTACK2) then
		self.Released = true
	elseif self.Owner:OnGround() and (self.Jumps > 0 or !self.CanWallRun) or self.Owner:GetNWBool("ClimbFalling") then

		self.Jumps, self.JumpSequence = 0, 0
		self.EasterEgg = false
		self.CanWallRun = true
		self.Owner:SetNWBool("ClimbWallJump", false)
		self.Owner:SetNWBool("ClimbFalling", false)

	elseif self.Owner:GetNWBool("ClimbWallRun") and !self.Grab then
	
		local traceData = {};
		traceData.start = self.Owner:GetPos() + Vector(0, 0, 20);
		traceData.endpos = traceData.start + self.Owner:GetForward() * 70;
		traceData.filter = self.Owner;
		local trace = util.TraceLine(traceData);
		
		local vel = self.Owner:GetVelocity();
		if !self.Owner:OnGround() and trace.Hit and self.Owner:KeyDown(IN_FORWARD) and math.abs(vel:Length()) > 100 then
		
			local vel = self.Owner:GetVelocity() + self.Owner:GetForward();
			vel.z = 0;			
			if CurTime() > self.WallRunAnim then
			
				self.WallRunAnim = CurTime() + (0.2 - vel:Length() / 10000);
				self.Owner:ViewPunch(Angle(10, 0, 0));
				if trace.MatType == MAT_GLASS then self.Owner:EmitSound(Sound("physics/glass/glass_sheet_step"..math.random(1, 4)..".wav"), 75, math.random(95, 105))
				elseif trace.MatType and MatList[trace.MatType] then self.Owner:EmitSound(Sound("player/footsteps/"..MatList[trace.MatType]..math.random(1, 4)..".wav"), 75, math.random(95, 105)) end
				vel.z = -(100 + vel:Length());
				
			end
			self.Owner:SetLocalVelocity(vel);
			
		else 
			
			self.Owner:SetNWBool("ClimbWallRun", false); 
			self.CanWallRun = false;
			
		end
	elseif self.Owner:KeyDown(IN_FORWARD) then
		if self.Owner:KeyDown(IN_USE) and !self.Owner:OnGround() and self.CanWallRun and self.Jumps < GetConVarNumber("climbswep2_maxjumps") and !self.Grab then
	
			local traceData = {};
			traceData.start = self.Owner:GetPos();
			traceData.endpos = traceData.start - Vector(0, 0, GetConVarNumber("climbswep2_wallrun_minheight"));
			if !util.TraceLine(traceData).Hit then
			
				self.Owner:SetNWBool("ClimbWallRun", true);
				self.Jumps = self.Jumps + 1
				local vel = self.Owner:GetVelocity() + self.Owner:GetForward() * 100;
				vel.z = 0;
				self.Owner:SetLocalVelocity(vel);
			
			end
		end
	end

	if CurTime() < self.nextThink then return false end

	// For the lulz.
	if self.Owner:GetVelocity().z <= -900 and self.Owner:GetMoveType() == MOVETYPE_WALK then

		if !self.Owner:GetNWBool("ClimbFalling") then self.Owner:SetNWBool("ClimbFalling", true); self.Owner:SetNWBool("ClimbWallJump", false)
		elseif self.Owner:KeyDown(IN_JUMP) then

			self.nextThink = CurTime() + 2.5
			if self.MFC == "combine" then

				self.Owner:EmitSound("npc/metropolice/vo/help.wav", 125, math.random(90, 110))
				return true

			end
			self.Owner:EmitSound("vo/npc/"..self.MFC.."01/help01.wav", 125, math.random(90, 110))
			return true

		elseif !self.EasterEgg and math.random(1, 128) == 1 then

			self.EasterEgg = true
			if self.MFC == "combine" then self.Owner:EmitSound("npc/metropolice/vo/shit.wav", 100)
			else self.Owner:EmitSound("vo/npc/"..self.MFC.."01/gordead_ans19.wav", 100) end
			return true

		end

		return true

	elseif self.Owner:GetNWBool("ClimbFalling") then self.Owner:SetNWBool("ClimbFalling", false)
	end

	// Are we grabbing a ledge?
	if self.Grab then

		// Is it a prop?
		local physObj = NULL;
		if IsValid(self.Parent) then
			
			physObj = self.Parent:GetPhysicsObject();
			if physObj:IsMoveable() then 
				if math.abs(self.OldVelocity - self.Parent:GetVelocity():Length()) >= 500 then 
					return false;
				end
			end

		end
		if !self.Owner:KeyDown(IN_FORWARD) and !self.Owner:KeyDown(IN_MOVELEFT) and !self.Owner:KeyDown(IN_MOVERIGHT) then return false
		elseif self.Owner:KeyDown(IN_FORWARD) then

			if self.Owner:KeyDown(IN_JUMP) then

				self:Forget()
				self.Owner:EmitSound(Sound("npc/combine_soldier/gear"..math.random(1, 6)..".wav"), 75, math.random(95, 105))
				self.Owner:ViewPunch(Angle(-7.5, 0, 0))
				self.Owner:SetLocalVelocity(self.Owner:GetAimVector() * 400)
				return true

			end
			return true

		end

		local Predict
		local Shift = 0
		if self.Owner:KeyDown(IN_SPEED) then Shift = 0.15 end
		self.nextThink = CurTime() + (0.35 - Shift)

		if self.Owner:KeyDown(IN_MOVELEFT) then Predict = -self.Owner:GetRight() * 10
		elseif self.Owner:KeyDown(IN_MOVERIGHT) then Predict = self.Owner:GetRight() * 10 end

		local tracedata = {}
		tracedata.start = self.Owner:GetShootPos() + Predict
		tracedata.endpos = tracedata.start + self.Owner:GetForward() * 40
		tracedata.filter = self.Owner
		local trLo =  util.TraceLine(tracedata)

		local tracedata = {}
		tracedata.start = self.Owner:GetShootPos() + Vector(0, 0, 15) + Predict
		tracedata.endpos = tracedata.start + self.Owner:GetForward() * self.Owner:GetShootPos():Distance(trLo.HitPos)
		tracedata.filter = self.Owner
		local trHi =  util.TraceLine(tracedata)

		if !trHi.Hit and trLo.Hit then

			self.Owner:SetPos(self.Owner:GetPos() + Predict)
			if physObj != NULL then
				self.LocalPos = self.Parent:WorldToLocal(self.Owner:GetPos());
			end
			if trLo.MatType == MAT_GLASS then self.Owner:EmitSound(Sound("physics/glass/glass_sheet_step"..math.random(1, 4)..".wav"), 75, math.random(95, 105))
			elseif trLo.MatType and MatList[trLo.MatType] then self.Owner:EmitSound(Sound("player/footsteps/"..MatList[trLo.MatType]..math.random(1, 4)..".wav"), 75, math.random(95, 105)) end

			if self.Owner:KeyDown(IN_MOVELEFT) then self.Owner:ViewPunch(Angle(0, 0, -2.5))
			else self.Owner:ViewPunch(Angle(0, 0, 2.5)) end
			return true

		end

	end

	// Wall Jumping. (In Think due to HUD Implementation)
	if self.Jumps > 0 then

		// Are we actually against a wall?
		local tracedata = { }
		local ShootPos = self.Owner:GetShootPos()
		local AimVector = self.Owner:GetAimVector()
		tracedata.start = ShootPos
		tracedata.endpos = ShootPos - AimVector*45
		tracedata.filter = self.Owner

		local trace = util.TraceLine(tracedata)

		if trace.Hit and !trace.HitSky and !self.Owner:GetNWBool("ClimbWallJump") then

			self.Owner:SetNWBool("ClimbWallJump", true)

		end

	elseif self.Owner:GetNWBool("ClimbWallJump") then self.Owner:SetNWBool("ClimbWallJump", false)
	end

	return true

end
function SWEP:ShakeEffect()
	if self.JumpSequence == 0 then
		self.Owner:ViewPunch(Angle(0, 5, 0))
	elseif self.JumpSequence == 1 then
		self.Owner:ViewPunch(Angle(0, -5, 0))
	elseif self.JumpSequence == 2 then
		self.Owner:ViewPunch(Angle(-5, 0, 0))
	end
	self.JumpSequence = self.JumpSequence < 3 and self.JumpSequence + 1 or 0
end
function SWEP:PrimaryAttack()

	if CLIENT or self.Owner:GetNWBool("ClimbWallRun") then return true end

	// We'll use this trace for determining whether we're looking at a Wall!
	local tracedata = { }
	local ShootPos = self.Owner:GetShootPos()
	local AimVector = self.Owner:GetAimVector()
	tracedata.start = ShootPos
	tracedata.endpos = ShootPos + AimVector*45
	tracedata.filter = self.Owner
	local trace = util.TraceLine(tracedata)

	// We'll have to be off the ground to start climbing!
	if self.Owner:OnGround() then

		// General Melee Functionality

		self:SetNextPrimaryFire(CurTime() + 0.4)

		if !trace.Hit or trace.HitWorld or trace.HitSky then

			self.Owner:EmitSound(Sound("npc/fast_zombie/claw_miss"..math.random(1, 2)..".wav"), 75)
			return false

		end

		if IsValid(trace.Entity) then

			if !trace.Entity:IsWorld() then

				if GetConVarNumber("climbswep2_necksnaps") == 1 and (trace.Entity:IsPlayer() or trace.Entity:IsNPC()) and trace.Entity:GetAimVector():DotProduct(self.Owner:GetAimVector()) > 0.6 then

					if trace.Entity:IsPlayer() then

						if GetConVarNumber("sbox_playershurtplayers") <= 0 then return false end
						trace.Entity:Kill()
						self.Owner:AddFrags(1)
						self.Owner:EmitSound(Sound("physics/body/body_medium_break"..math.random(3, 4)..".wav"), 80, math.random(95, 105))
						return true

					else

						trace.Entity:TakeDamage(trace.Entity:Health(), self.Owner, self)
						self.Owner:AddFrags(1)
						self.Owner:EmitSound(Sound("physics/body/body_medium_break"..math.random(3, 4)..".wav"), 80, math.random(95, 105))
						return true

					end

					return true

				elseif trace.Entity:IsPlayer() then

					trace.Entity:ViewPunch(Angle(-25, 20, 0))
					if trace.Entity:GetActiveWeapon().Grab then trace.Entity:GetActiveWeapon().Grab = false end
					
				elseif trace.Entity:IsNPC() then
					trace.Entity:TakeDamage(10, self.Owner, self)
				end
				if (IsValid(trace.Entity:GetPhysicsObject())) then
					trace.Entity:GetPhysicsObject():ApplyForceOffset((trace.HitPos-self.Owner:EyePos())*128, trace.HitPos)
				end
				self.Owner:EmitSound(table.Random(HitPlayer), 80, math.random(95, 105))
				return true

			end

		end

		return false

	end

	// Are we grabbing?
	if self.Grab then

		// If so, we'll want to reset our variables!
		self:Forget()

		// Now, run up that wall!
		self.Owner:ViewPunch(Angle(-15, self.Owner:EyeAngles().yaw/32, 0))
		self.Owner:EmitSound(Sound("player/suit_sprint.wav"), 80, math.random(95, 105))
		self.Owner:SetVelocity(-self.Owner:GetVelocity() + Vector(0, 0, 250))
		self:SetNextPrimaryFire(CurTime() + 0.15)
		return true

	end

	// Wall Jumping. (Code in Think due to HUD Implementation)
	if self.Owner:GetNWBool("ClimbWallJump") then

		// We can Wall Jump!
		self.CanWallRun = true;
		self.Jumps = 0
		self.Owner:SetLocalVelocity(self.Owner:GetAimVector() * 300)
		self.Owner:EmitSound(Sound("npc/combine_soldier/gear"..math.random(1, 6)..".wav"), 75, math.random(95, 105))
		self.Owner:ViewPunch(Angle(-7.5, 0, 0))
		return true

	end

	// Are we close enough to start climbing?
	if ( (self.Jumps == 0 and trace.HitPos:Distance(ShootPos) > 40) or self.Jumps > (GetConVarNumber("climbswep2_maxjumps") - 1) or trace.HitSky) then return false end

	// If we've mysteriously lost the wall we'll want to stop climbing!
	if !trace.Hit then return false end

	if self.Owner:GetVelocity().z <= -750 then

		self:SetNextPrimaryFire(CurTime() + 1)
		self.Owner:EmitSound("ambient/levels/canals/toxic_slime_sizzle4.wav", 50, 200)

		if self.MFC == "combine" then self.Owner:EmitSound("npc/metropolice/knockout2.wav", 125)
		else self.Owner:EmitSound("vo/npc/"..self.MFC.."01/ow0"..math.random(1, 2)..".wav", 125) end

		return true

	end

	// Add some effects.
	if trace.MatType == MAT_GLASS then self.Owner:EmitSound(Sound("physics/glass/glass_sheet_step"..math.random(1, 4)..".wav"), 75, math.random(95, 105))
	elseif trace.MatType and MatList[trace.MatType] then self.Owner:EmitSound(Sound("player/footsteps/"..MatList[trace.MatType]..math.random(1, 4)..".wav"), 75, math.random(95, 105))
	else self.Owner:EmitSound(Sound("npc/fast_zombie/claw_miss"..math.random(1, 2)..".wav"), 75, math.random(95, 105)) end

	// Climb the wall and modify our jump count.

	local Vel = self.Owner:GetVelocity()
	self.Owner:SetVelocity(Vector(0, 0, 240 - 15 * 1 + self.JumpSequence - Vel.z))
	self:SetNextPrimaryFire(CurTime() + 0.15)
	self.Jumps = self.Jumps + 1
	self:ShakeEffect()
	return true

end
function SWEP:CanGrab() -- This too, but modified it somewhat.

	// We'll detect whether we can grab onto the ledge.
	local trace = {}
	trace.start = self.Owner:GetShootPos() + Vector( 0, 0, 15 )
	trace.endpos = trace.start + self.Owner:GetAimVector() * 30
	trace.filter = self.Owner

	local trHi = util.TraceLine(trace)

	local trace = {}
	trace.start = self.Owner:GetShootPos()
	trace.endpos = trace.start + self.Owner:GetAimVector() * 30
	trace.filter = self.Owner

	local trLo = util.TraceLine(trace)

	// Is the ledge actually grabbable?
	if trLo and trHi and trLo.Hit and !trHi.Hit then
		return {true, trLo}
	else
		return {false, trLo}
	end

end
function SWEP:SecondaryAttack()

	if CLIENT then return true end

	if !self.Released then return end

	if self.Owner:OnGround() then return false end // We don't want to grab onto a ledge if we're on the ground!

	// If we're already grabbing something, we want to let go!
	if self.Grab then
		self:Forget()
		self.Released = false
		return false
	end

	// Returns whether we can grab(boolean) and a traceres.
	local Grab = self:CanGrab()

	// If we can't grab we're done here.
	if !Grab[1] then 
		return false 
	end

	// Otherwise reset our jumps and enter ledge holding mode!
	self.Jumps = 0
	self.Grab  = true
	self.Released = false
	local VelZ = self.Owner:GetVelocity().z;
	self.Owner:ViewPunch(Angle(math.max(15, math.min(30, VelZ)) * (VelZ > 0 and 1 or -1), 0, 0));
	self.Owner:SetLocalVelocity(Vector(0, 0, 0))
	self.Owner:SetMoveType(MOVETYPE_NONE)
	self.Owner:EmitSound(Sound("physics/flesh/flesh_impact_hard"..math.random(1, 3)..".wav"), 75)
	
	// Are we looking at a valid entity?
	if IsValid(Grab[2].Entity) then

		// Does the prop/entity use valid prop-like behaviour?
		if Grab[2].Entity:GetMoveType() == MOVETYPE_VPHYSICS then

			// Then we can grab onto it!
			self.OldVelocity      = Grab[2].Entity:GetVelocity():Length()
			self.Parent           = Grab[2].Entity
			self.LocalPos      	= Grab[2].Entity:WorldToLocal(self.Owner:GetPos())
		end

	end

	local ClimbSwep = self
	local Ply = self.Owner;
	local Forget = function()
		self:Forget();
		hook.Remove("Think", "ClimbGrab"..Ply:UniqueID())
	end
	local IsOneHanded = function()

		if !IsValid(Ply:GetActiveWeapon()) then return false end

		local Weps = {climb_swep2 = true, weapon_pistol = true, weapon_357 = true, weapon_crowbar = true, weapon_frag = true}
		local HoldTypes = {pistol = true, grenade = true, knife = true}
		local Wep = Ply:GetActiveWeapon()
		if Weps[Wep:GetClass()] then return true
		elseif HoldTypes[Wep.HoldType] then return true end
		return false

	end


	local ThinkFunction = function()

		if !Ply:Alive() then hook.Remove("Think", "ClimbGrab"..Ply:UniqueID());
		elseif !ClimbSwep.Grab or Ply:GetMoveType() != MOVETYPE_NONE then Forget(); return
		elseif !IsOneHanded() then Forget(); 
			return
		elseif IsValid(ClimbSwep.Parent) then

			if ClimbSwep.Parent:GetPhysicsObject():IsMoveable() then
			
				if math.abs(ClimbSwep.OldVelocity - ClimbSwep.Parent:GetVelocity():Length()) >= 500 then Forget()
				else

					ClimbSwep.OldVelocity = ClimbSwep.Parent:GetVelocity():Length()
					Ply:SetLocalVelocity(Vector(0, 0, 0))
					Ply:SetPos(ClimbSwep.Parent:LocalToWorld(ClimbSwep.LocalPos))
					return

				end

			end

		end

	end
	hook.Add("Think", "ClimbGrab"..Ply:UniqueID(), ThinkFunction)
	return true

end
function SWEP:DrawHUD()

	if SERVER or GetConVarNumber("climbswep2_showhud") == 0 then return false end

	/*
		We can't make use of the variables the SERVER has indexed.
		Instead we'll make use of Networked Variables, available to both
		the CLIENT and the SERVER.
	*/

	local Jumps, MaxJumps = LocalPlayer():GetNWInt("ClimbJumps"), GetConVarNumber("climbswep2_maxjumps")
	local Width, Height = 256, 18


	// Draw Jump-Monitor
	draw.RoundedBox(4, ScrW() / 2 - Width / 2, ScrH() - Height * 6, Width, Height, Color(51, 181, 229, 122))
	if (MaxJumps - Jumps) > 0 then draw.RoundedBox(4, ScrW() / 2 - Width / 2, ScrH() - Height * 6, Width * (MaxJumps - Jumps) / MaxJumps, Height, Color(51, 181, 229, 255)) end
	draw.DrawText("Jumps: "..(MaxJumps - Jumps).." of "..GetConVarNumber("climbswep2_maxjumps"), "Default", ScrW() / 2, ScrH() - Height * 6 + 3, Color(255, 255, 255, 255), TEXT_ALIGN_CENTER)

	// Draw Custom HUD Icons
	if LocalPlayer():GetNWBool("ClimbWallJump") then

		surface.SetDrawColor(Color(51, 181, 229, 255))
		surface.DrawRect(ScrW() / 2 - 8, ScrH() - Height * 2 - 36, 8, 32)
		surface.SetTexture(surface.GetTextureID("gui/arrow.vmt"))
		surface.DrawTexturedRectRotated(ScrW() / 2 + 9, ScrH() - Height * 2 - 22, 30, 30, -60)
		surface.SetDrawColor(Color(255, 255, 255, 255))

	elseif LocalPlayer():GetNWBool("ClimbFalling") then

		surface.SetDrawColor(Color(51, 181, 229, 255))
		surface.DrawRect(ScrW() / 2 - 16, ScrH() - Height * 2 - 12, 32, 8)
		surface.SetTexture(surface.GetTextureID("gui/arrow.vmt"))
		surface.DrawTexturedRectRotated(ScrW() / 2, ScrH() - Height * 2 - 28, 30, 30, 180)
		surface.SetDrawColor(Color(255, 255, 255, 255))

	end

end
--addons/ballistic_shields/lua/weapons/deployable_shield/shared.lua:
if SERVER then
	include("ballistic_shields/sh_bs_util.lua")
	include("ballistic_shields/sv_bs_util.lua")
end

include("bs_config.lua")
include("ballistic_shields/sh_bs_lang.lua")

SWEP.PrintName = "Deployable Shield"
SWEP.Author	= "D3G"
SWEP.Instructions = "LMB - Deploy shield | RMB - Toggle visibility"
SWEP.Spawnable = false
SWEP.AdminOnly = false

SWEP.ViewModel = ""
SWEP.WorldModel = "models/bshields/dshield.mdl"

SWEP.HolsterOffset = Vector(7, 0, 8)
SWEP.HolsterAngle = Angle(-90, 0, 0)

SWEP.AutoSwitchTo = false
SWEP.AutoSwitchFrom	= false

SWEP.Slot = 1
SWEP.SlotPos = 6
SWEP.DrawAmmo = false
SWEP.DrawCrosshair = false

SWEP.Category = "SW:RP Shields"
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"

SWEP.CanVisToggle = true
SWEP.VisToggle = false
SWEP.HitDistance = 55

function SWEP:Initialize()
	self:SetHoldType("melee2")
end

function SWEP:DrawWorldModel()
	self:SetNoDraw(true)
end

local function bsGetHoldType(ply)
	if ply:LookupAttachment( "anim_attachment_RH" ) > 0 then
		return {1,"anim_attachment_RH"}
	end

	if ply:LookupAttachment( "forward" ) > 0 then
		return {2,"forward"}
	end

	return {3, "anim_attachment_head"}
end

local ShieldIcon = Material("bshields/ui/deployable_shield", "smooth")
local ShieldIconClosed = Material("bshields/ui/deployable_shield_closed", "smooth")
local BackgroundIcon = Material("bshields/ui/background")

function SWEP:DrawHUD()
	if bshields.config.disablehud then return end

	surface.SetDrawColor(255,255,255,200)
	surface.SetMaterial(BackgroundIcon)
	surface.DrawTexturedRect( ScrW() / 2 - ScrH() / 10, ScrH() / 2-ScrH() / 30 + ScrH() / 3, ScrH() / 5, ScrH() / 15)

	local aim = LocalPlayer():GetAimVector()
	local tr = util.TraceLine( {
		start  = LocalPlayer():GetShootPos() ,
		endpos = LocalPlayer():GetShootPos() + aim * 120,
		filter = LocalPlayer()
	})

	surface.SetDrawColor(255,255,255,125)

	if (tr.HitPos:DistToSqr(LocalPlayer():GetPos())) > 550 && tr.HitPos.z <= (LocalPlayer():GetPos().z + 30) && (tr.HitWorld || (IsValid(tr.Entity) && tr.Entity:GetClass() == "prop_physics")) then
		draw.SimpleTextOutlined( bshields.lang[bshields.config.language].dshieldprim, "bshields.HudFont", ScrW() / 2 - ScrH() / 32, ScrH() / 2 - ScrH() / 28 + ScrH() / 3 + ScrH() / 22, Color( 255, 255, 255, 255 ), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER, 1, Color(20,20,20,255))
		surface.SetMaterial(ShieldIcon)
	else
		draw.SimpleTextOutlined( bshields.lang[bshields.config.language].dshieldprim, "bshields.HudFont", ScrW() / 2-ScrH() / 32, ScrH() / 2 - ScrH() / 28 + ScrH() / 3 + ScrH() / 22, Color( 255, 255, 255, 25 ), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER, 1, Color(20,20,20,255))
		surface.SetMaterial(ShieldIconClosed)
	end

	surface.DrawTexturedRect( ScrW() / 2 - ScrH() / 10.2, ScrH() / 2-ScrH() / 32 + ScrH() / 3, ScrH() / 16, ScrH() / 16)

	if self.VisToggle then
		draw.SimpleTextOutlined( bshields.lang[bshields.config.language].sec, "bshields.HudFont", ScrW() / 2 - ScrH() / 32, ScrH() / 2-ScrH() / 28 + ScrH() / 3 + ScrH() / 48, Color( 255, 255, 255, 25 ), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER, 1, Color(20,20,20,255))
	else
		draw.SimpleTextOutlined( bshields.lang[bshields.config.language].sec, "bshields.HudFont", ScrW() / 2 - ScrH() / 32, ScrH() / 2-ScrH() / 28 + ScrH() / 3 + ScrH() / 48, Color( 255, 255, 255, 255 ), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER, 1, Color(20,20,20,255))
	end
end

function SWEP:Deploy()
	self.CanVisToggle = true
	self.VisToggle = false

	if SERVER then
		local owner = self:GetOwner()
		local holdtype = bsGetHoldType(owner)
		bshield_remove(owner)

		owner.bs_type = 2
		owner.bs_shield = ents.Create(self.shieldEnt)
		owner.bs_shield:SetCollisionGroup( COLLISION_GROUP_DEBRIS  )
		owner.bs_shield:SetMoveType(MOVETYPE_NONE)
		owner.bs_shield:SetPos(owner:GetPos())
		owner.bs_shield:SetParent(owner, owner:LookupAttachment(holdtype[2]))
		owner.bs_shield:SetLocalAngles(bshields.shields[holdtype[1]][2].angles)
		owner.bs_shield:SetLocalPos(bshields.shields[holdtype[1]][2].position)
		owner.bs_shield:Spawn()

		net.Start("bs_shield_info")
			net.WriteUInt(owner.bs_shield:EntIndex(), 16)
		net.Send(owner)
	end
end

function SWEP:PrimaryAttack()
	if SERVER then
		local owner = self:GetOwner()
		local aim = owner:GetAimVector()
		local tr = util.TraceLine( {
			start  = owner:GetShootPos() ,
			endpos = owner:GetShootPos() + aim * 120,
			filter = owner
		})

		if (tr.HitPos:DistToSqr(owner:GetPos())) > 550 && tr.HitPos.z <= (owner:GetPos().z + 30) && (tr.HitWorld || (IsValid(tr.Entity) && tr.Entity:GetClass() == "prop_physics")) then
			shield = ents.Create(self.deployShieldEnt)
			shield:SetPos(tr.HitPos + Vector(0,0,28.5) - aim * 10)
			shield:SetAngles(Angle(0,aim:Angle().y,0))
			shield:Spawn()
			shield:EmitSound("npc/combine_soldier/gear1.wav")
			shield.Owner = owner

			bshield_remove(owner)
			owner:StripWeapon(self:GetClass())

			table.insert(owner.bs_shields, shield)
			if table.Count(owner.bs_shields) > bshields.config.maxshields then
				if IsValid(owner.bs_shields[1]) then
					owner.bs_shields[1]:Remove()
				end

				table.remove(owner.bs_shields, 1)
			end
		end

		self:SetNextPrimaryFire( CurTime() + 0.5 )
	end
end

function SWEP:SecondaryAttack()
	if CLIENT then
		if !self.CanVisToggle then return end
		surface.PlaySound( "weapons/smg1/switch_single.wav" )

		if !self.VisToggle then
			Entity(LocalPlayer().bs_shieldIndex):SetColor(Color( 0, 0, 0, 180 ))
			self.VisToggle = true
		else
			Entity(LocalPlayer().bs_shieldIndex):SetColor(Color( 255, 255, 255 ))
			self.VisToggle = false
			self.VisToggle = false
		end

		self.CanVisToggle = false

		timer.Simple(0.1, function()
			self.CanVisToggle = true
		end)
	end
end

if CLIENT then return end

function SWEP:Holster()
	bshield_remove(self:GetOwner())

	return true
end

function SWEP:OnRemove()
	bshield_remove(self:GetOwner())

	return true
end

function SWEP:OnDrop()
	bshield_remove(self:GetOwner())

	return true
end

--addons/ballistic_shields/lua/ballistic_shields/sh_bs_util.lua:
bshields = bshields or {}
bshields.config = bshields.config or {}

bshields.shields = {
	{
		[1] = {
			["angles"] = Angle(4,6,-14),
			["position"] = Vector(5,10,-5)
		},
		[2] = {
			["angles"] = Angle(6,1,-15),
			["position"] = Vector(6,10,-5)
		},
		[3] = {
			["angles"] = Angle(4,6,-14),
			["position"] = Vector(5,10,-5)
		}
	},
	{
		[1] = {
			["angles"] = Angle(-12,0,0),
			["position"] = Vector(6,-4,-8)
		},
		[2] = {
			["angles"] = Angle(-12,0,0),
			["position"] = Vector(1,-3,-12)
		},
		[3] = {
			["angles"] = Angle(-12,0,0),
			["position"] = Vector(6,-3,-12)
		}
	},
	{
		[1] = {
			["angles"] = Angle(70,78,-16),
			["position"] = Vector(1,-7,-13)
		},
		[2] = {
			["angles"] = Angle(70,78,-16),
			["position"] = Vector(1,-6,-22)
		},
		[3] = {
			["angles"] = Angle(70,78,-16),
			["position"] = Vector(1,-8,-12)
		}
	}
}

--addons/ballistic_shields/lua/weapons/deployable_shield_st/shared.lua:
SWEP.Base = "deployable_shield"
SWEP.PrintName = "Aufstellbares Schild (ST)"
SWEP.Category = "SW:RP Shields"

SWEP.Author	= "GangsterDom, Deltaa"
SWEP.Instructions = "LMB - Schild aufstellen | RMB - Sichtbarkeit ein- und ausschalten"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.ViewModel = ""
SWEP.WorldModel = "models/bshields/egm_schild.mdl"

SWEP.WElements = {
	["placeholder"] = { type = "Model", model = "models/bshields/egm_schild.mdl", skin = 1, bodygroup = {} }
}

SWEP.shieldEnt = "bs_dshield_st"
SWEP.deployShieldEnt = "bs_shield_st"
--lua/weapons/dual_base/cl_init.lua:
include('shared.lua')

--lua/weapons/gmod_tool/stools/npctool_controller.lua:
TOOL.Category = "NPC Control"
TOOL.Name = "NPC Controller"
TOOL.Command = nil
TOOL.ConfigName = ""

if(CLIENT) then
	TOOL.ClientConVar["walk"] = 0
	TOOL.ClientConVar["showcircle"] = 1
	language.Add("tool.npctool_controller.name","NPC Controller")
	language.Add("tool.npctool_controller.desc","Control a NPC")
	language.Add("tool.npctool_controller.0","Left-Click to de/select a NPC, or make the selected NPC move to a position/attack a NPC; Right-Click to possess the selected NPC")
	
	function TOOL.BuildCPanel(pnl)
		pnl:AddControl("Header",{Text = "Controller",Description = [[Left-Click to de/select a NPC.
		Right-Click to make all selected NPCs attack a target or move to a position.
		]]})
		pnl:AddControl("CheckBox",{Label = "Walk to position",Command = "npctool_controller_walk"})
		pnl:AddControl("CheckBox",{Label = "Show circle",Command = "npctool_controller_showcircle"})
	end
	
	local tbSelected = {}
	cvars.AddChangeCallback("npctool_controller_showcircle",function(cvar,prev,new)
		if(tobool(new)) then
			for _,ent in ipairs(tbSelected) do // TODO: Don't do this if tool isn't equipped
				if(ent:IsValid()) then
					ent:StopParticles()
					ParticleEffectAttach("plate_green",PATTACH_ABSORIGIN_FOLLOW,ent,0)
				end
			end
			return
		end
		for _,ent in ipairs(tbSelected) do
			if(ent:IsValid()) then
				ent:StopParticles()
			end
		end
	end)
	
	local matMove = surface.GetTextureID("HUD/crosshairs/hlr_stool_commander_crosshair2")
	local matAttack = surface.GetTextureID("HUD/crosshairs/hlr_stool_commander_crosshair1")
	function TOOL:DrawHUD()
		local tr = util.TraceLine(util.GetPlayerTrace(LocalPlayer()))
		local mat
		if(tr.Entity:IsValid() && (tr.Entity:IsNPC() || tr.Entity:IsPlayer())) then
			if(table.HasValue(tbSelected,tr.Entity)) then return end
			mat = matAttack
		else mat = matMove end
		surface.SetTexture(mat)
		surface.SetDrawColor(255,0,0,255)
		surface.DrawTexturedRect(ScrW() *0.5 -12,ScrH() *0.5 -12,24,24)
	end
	
	net.Receive("npctool_contr_add",function(len)
		local ent = net.ReadEntity()
		if(!ent:IsValid()) then return end
		local bSelected = net.ReadUInt(1) == 1
		if(!bSelected) then
			ent:StopParticles()
			for _,entTgt in ipairs(tbSelected) do
				if(entTgt == ent) then
					table.remove(tbSelected,_)
					break
				end
			end
		else
			table.insert(tbSelected,ent)
			if(GetConVarNumber("npctool_controller_showcircle") != 0) then ParticleEffectAttach("plate_green",PATTACH_ABSORIGIN_FOLLOW,ent,0) end
		end
	end)
	
	net.Receive("npctool_controller_deploy",function(len)
		if(GetConVarNumber("npctool_controller_showcircle") == 0) then return end
		for _,ent in ipairs(tbSelected) do
			if(ent:IsValid()) then
				ParticleEffectAttach("plate_green",PATTACH_ABSORIGIN_FOLLOW,ent,0)
			end
		end
	end)
	
	net.Receive("npctool_controller_holster",function(len)
		for _,ent in ipairs(tbSelected) do
			if(ent:IsValid()) then ent:StopParticles() end
		end
	end)
else
	util.AddNetworkString("npctool_contr_add")
	util.AddNetworkString("npctool_controller_holster")
	util.AddNetworkString("npctool_controller_deploy")
	function TOOL:Deploy()
		net.Start("npctool_controller_deploy")
		net.Send(self:GetOwner())
	end
	function TOOL:StopControl(ent)
		for _,entTgt in ipairs(self.m_tbNPCs) do
			if(entTgt == ent) then
				table.remove(self.m_tbNPCs,_)
				break
			end
		end
		for entTgt,disp in pairs(self.m_tbDisp[ent]) do
			if(entTgt:IsValid()) then
				ent:AddEntityRelationship(entTgt,disp,100)
				if(self.m_tbDisp[entTgt] && self.m_tbDisp[entTgt][ent] && !entTgt.m_bControlled) then
					entTgt:AddEntityRelationship(ent,self.m_tbDisp[entTgt][ent],100)
					self.m_tbDisp[entTgt][ent] = nil
				elseif(entTgt:IsNPC()) then entTgt:AddEntityRelationship(ent,disp,100) end
			end
		end
		self.m_tbDisp[ent] = nil
		ent.m_bControlled = false
		net.Start("npctool_contr_add")
			net.WriteEntity(ent)
			net.WriteUInt(1,0)
		net.Send(self:GetOwner())
	end
	function TOOL:StartControl(ent)
		self.m_tbDisp = self.m_tbDisp || {}
		self.m_tbDisp[ent] = {}
		ent.m_bControlled = true
		for _,entTgt in ipairs(ents.GetAll()) do
			if(entTgt:IsNPC() || entTgt:IsPlayer()) then
				self.m_tbDisp[ent][entTgt] = ent:Disposition(entTgt)
				ent:AddEntityRelationship(entTgt,D_LI,100)
				if(entTgt:IsNPC()) then
					self.m_tbDisp[entTgt] = self.m_tbDisp[entTgt] || {}
					self.m_tbDisp[entTgt][ent] = entTgt:Disposition(ent)
					entTgt:AddEntityRelationship(ent,D_LI,100)
				end
			end
		end
		table.insert(self.m_tbNPCs,ent)
		net.Start("npctool_contr_add")
			net.WriteEntity(ent)
			net.WriteUInt(1,1)
		net.Send(self:GetOwner())
	end
end

function TOOL:LeftClick(tr)
	if(!tr.Entity:IsValid() || !tr.Entity:IsNPC()) then return false end
	if(CLIENT) then return true end
	self.m_tbNPCs = self.m_tbNPCs || {}
	if(table.HasValue(self.m_tbNPCs,tr.Entity)) then
		local l = "notification.AddLegacy(language.GetPhrase(\"#" .. tr.Entity:GetClass() .. "\") .. \" deselected.\",0,8);"
		l = l .. "surface.PlaySound(\"buttons/button14.wav\")"
		self:GetOwner():SendLua(l)
		self:StopControl(tr.Entity)
		return true
	elseif(tr.Entity.m_bControlled) then
		local l = "notification.AddLegacy(\"This NPC is already being controlled by someone else.\",1,8);"
		l = l .. "surface.PlaySound(\"buttons/button10.wav\")"
		self:GetOwner():SendLua(l)
		return false
	elseif(tr.Entity.IsPossessed && tr.Entity:IsPossessed()) then
		local l = "notification.AddLegacy(\"This NPC is already being possessed by someone.\",1,8);"
		l = l .. "surface.PlaySound(\"buttons/button10.wav\")"
		self:GetOwner():SendLua(l)
		return false
	end
	local l = "notification.AddLegacy(language.GetPhrase(\"#" .. tr.Entity:GetClass() .. "\") .. \" selected.\",0,8);"
	l = l .. "surface.PlaySound(\"buttons/button14.wav\")"
	self:GetOwner():SendLua(l)
	self:StartControl(tr.Entity)
	return true
end

function TOOL:RightClick(tr)
	if(CLIENT) then return false end
	self.m_tbNPCs = self.m_tbNPCs || {}
	for i = #self.m_tbNPCs,1,-1 do
		if(!self.m_tbNPCs[i]:IsValid()) then
			table.remove(self.m_tbNPCs,i)
		end
	end
	if(!self.m_tbNPCs[1]) then
		local l = "notification.AddLegacy(\"No npcs selected.\",1,8);"
		l = l .. "surface.PlaySound(\"buttons/button10.wav\")"
		self:GetOwner():SendLua(l)
		return false
	end
	if(tr.Entity:IsValid() && (tr.Entity:IsNPC() || tr.Entity:IsPlayer())) then
		for _,ent in ipairs(self.m_tbNPCs) do
			ent:AddEntityRelationship(tr.Entity,D_HT,100)
			ent:SetEnemy(tr.Entity)
			if(tr.Entity:IsNPC()) then tr.Entity:AddEntityRelationship(ent,D_HT,100) end
		end
		return true
	end
	local schd
	if(self:GetClientNumber("walk") == 1) then schd = SCHED_FORCED_GO
	else schd = SCHED_FORCED_GO_RUN end
	for _,ent in ipairs(self.m_tbNPCs) do
		ent:SetLastPosition(tr.HitPos)
		ent:SetSchedule(schd)
	end
	return true
end

function TOOL:Holster()
	if(CLIENT) then return end
	net.Start("npctool_controller_holster")
	net.Send(self:GetOwner())
end
--lua/weapons/gmod_tool/stools/npctool_follower.lua:
TOOL.Category = "NPC Control"
TOOL.Name = "NPC Follower"
TOOL.Command = nil
TOOL.ConfigName = ""

if(CLIENT) then
	language.Add("tool.npctool_follower.name","NPC Follower")
	language.Add("tool.npctool_follower.desc","Make a NPC follow an entity.")
	language.Add("tool.npctool_follower.0","Left-Click to select a NPC, Right-Click to make all selected NPCs follow a target, Reload to make them follow yourself.")
	
	function TOOL.BuildCPanel(pnl)
		pnl:AddControl("Header",{Text = "Notarget",Description = [[Left-Click to select a NPC.
		Right-Click to make all selected NPCs follow a target.
		Reload to make them follow yourself.
		]]})
	end
	
	local tbEntsSelected = {}
	net.Receive("npctool_follower_select",function(len)
		local ent = net.ReadEntity()
		if(!ent:IsValid()) then return end
		local bSelected = net.ReadUInt(1) == 1
		if(!bSelected) then
			notification.AddLegacy(language.GetPhrase("#" .. ent:GetClass()) .. " deselected.",0,8)
			ent:StopParticles()
			for _,entTgt in ipairs(tbEntsSelected) do
				if(ent == entTgt) then
					table.remove(tbEntsSelected,_)
					break
				end
			end
		else
			notification.AddLegacy(language.GetPhrase("#" .. ent:GetClass()) .. " selected.",0,8)
			ParticleEffectAttach("plate_green",PATTACH_ABSORIGIN_FOLLOW,ent,0)
			table.insert(tbEntsSelected,ent)
		end
	end)
	
	net.Receive("npctool_follower_start",function(len)
		local num = net.ReadUInt(8)
		local bLocal = net.ReadUInt(1) == 1
		if(bLocal) then
			if(num == 1) then notification.AddLegacy("1 NPC is now following you.",0,8)
			else notification.AddLegacy(num .. " NPCs are now following you.",0,8) end
			return
		end
		local ent = net.ReadEntity()
		if(!ent:IsValid()) then return end
		if(num == 1) then notification.AddLegacy("1 NPC is now following " .. language.GetPhrase("#" .. ent:GetClass()) .. ".",0,8)
		else notification.AddLegacy(num .. " NPCs are now following " .. language.GetPhrase("#" .. ent:GetClass()) .. ".",0,8) end
	end)
	
	net.Receive("npctool_follower_deploy",function(len)
		for _,ent in ipairs(tbEntsSelected) do
			if(ent:IsValid()) then
				ParticleEffectAttach("plate_green",PATTACH_ABSORIGIN_FOLLOW,ent,0)
			end
		end
	end)
	
	net.Receive("npctool_follower_holster",function(len)
		for _,ent in ipairs(tbEntsSelected) do
			if(ent:IsValid()) then ent:StopParticles() end
		end
	end)
else
	util.AddNetworkString("npctool_follower_select")
	util.AddNetworkString("npctool_follower_start")
	util.AddNetworkString("npctool_follower_holster")
	util.AddNetworkString("npctool_follower_deploy")
	function TOOL:Deploy()
		net.Start("npctool_follower_deploy")
		net.Send(self:GetOwner())
	end
end

function TOOL:StartFollowing(src,tgt)
	self:StopFollowing(src)
	self.m_tbDisp = self.m_tbDisp || {}
	local hk = "npctool_follower" .. src:EntIndex() .. tgt:EntIndex()
	self.m_tbDisp[src] = self.m_tbDisp[src] || {}
	self.m_tbDisp[src][tgt] = src:Disposition(tgt)
	if(tgt:IsNPC()) then
		self.m_tbDisp[tgt] = self.m_tbDisp[tgt] || {}
		self.m_tbDisp[tgt][src] = tgt:Disposition(src)
		tgt:AddEntityRelationship(src,D_LI,100)
	end
	if(tgt:IsNPC() || tgt:IsPlayer()) then src:AddEntityRelationship(tgt,D_LI,100) end
	if(src.bScripted) then src.fFollowDistance = 200; src:SetBehavior(1,tgt); return end
	local nextUpdate = CurTime()
	local last
	hook.Add("Think",hk,function()
		if(!src:IsValid() || !tgt:IsValid()) then hook.Remove("Think",hk)
		elseif(CurTime() >= nextUpdate) then
			nextUpdate = CurTime() +0.5
			local posSrc = src:GetPos()
			local posTgt = tgt:GetPos()
			if(!last || !src:IsCurrentSchedule(SCHED_FORCED_GO_RUN) || posTgt:Distance(last) > 200) then
				last = posTgt
				local d = math.max(posSrc:Distance(posTgt) -(src:OBBMaxs().x +tgt:OBBMaxs().x),0)
				local schd = SCHED_FORCED_GO_RUN
				if(d > 200) then
					src:SetLastPosition(posTgt)
					src:SetSchedule(schd)
				elseif(src:IsCurrentSchedule(schd)) then src:ClearSchedule(); src:StopMoving() end
			end
		end
	end)
end

function TOOL:StopFollowing(src)
	if(!self.m_tbDisp) then return end
	if(!self.m_tbDisp[src]) then return end
	for tgt,disp in pairs(self.m_tbDisp[src]) do
		if(tgt:IsValid()) then
			hook.Remove("Think","npctool_follower" .. src:EntIndex() .. tgt:EntIndex())
			src:AddEntityRelationship(tgt,disp,100)
			self.m_tbDisp[src][tgt] = nil
			if(!tgt:IsPlayer()) then
				if(self.m_tbDisp[tgt] && self.m_tbDisp[tgt][src]) then
					tgt:AddEntityRelationship(src,self.m_tbDisp[tgt][src],100)
					self.m_tbDisp[tgt][src] = nil
				else tgt:AddEntityRelationship(src,disp,100) end
			end
		end
	end
end

function TOOL:Holster()
	if(CLIENT) then return end
	net.Start("npctool_follower_holster")
	net.Send(self:GetOwner())
end

function TOOL:LeftClick(tr)
	if(CLIENT) then return true end
	if(tr.Entity:IsValid() && tr.Entity:IsNPC()) then
		self.m_tbNPCs = self.m_tbNPCs || {}
		local bExists
		for _,ent in ipairs(self.m_tbNPCs) do
			if(ent == tr.Entity) then
				table.remove(self.m_tbNPCs,_)
				bExists = true
				break
			end
		end
		if(!bExists) then
			table.insert(self.m_tbNPCs,tr.Entity)
		end
		net.Start("npctool_follower_select")
			net.WriteEntity(tr.Entity)
			net.WriteUInt(bExists && 0 || 1,1)
		net.Send(self:GetOwner())
		return true
	end
	return false
end

function TOOL:RightClick(tr)
	if(!self.m_tbNPCs) then return false end
	if(!tr.Entity:IsValid()) then return false end
	if(CLIENT) then return true end
	local num = 0
	for _,ent in ipairs(self.m_tbNPCs) do
		if(ent:IsValid()) then
			self:StartFollowing(ent,tr.Entity)
			num = num +1
		end
	end
	if(num > 0) then
		net.Start("npctool_follower_start")
			net.WriteUInt(num,8)
			net.WriteUInt(0,1)
			net.WriteEntity(tr.Entity)
		net.Send(self:GetOwner())
	end
	return false
end

function TOOL:Reload()
	if(CLIENT) then return end
	if(!self.m_tbNPCs) then return end
	local pl = self:GetOwner()
	local num = 0
	for _,ent in ipairs(self.m_tbNPCs) do
		if(ent:IsValid()) then
			num = num +1
			self:StartFollowing(ent,pl)
		end
	end
	if(num > 0) then
		net.Start("npctool_follower_start")
			net.WriteUInt(num,8)
			net.WriteUInt(1,1)
		net.Send(self:GetOwner())
	end
end
--lua/includes/modules/json.lua:
--[[

 JSON Encoder and Parser for Lua 5.1
 
 Copyright  2007 Shaun Brown (http://www.chipmunkav.com).
 All Rights Reserved.
 
 Permission is hereby granted, free of charge, to any person 
 obtaining a copy of this software to deal in the Software without 
 restriction, including without limitation the rights to use, 
 copy, modify, merge, publish, distribute, sublicense, and/or 
 sell copies of the Software, and to permit persons to whom the 
 Software is furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be 
 included in all copies or substantial portions of the Software.
 If you find this software useful please give www.chipmunkav.com a mention.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
 EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES 
 OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR 
 ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF 
 CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN 
 CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

 Usage:

 -- Lua script:
 local t = { 
	["name1"] = "value1",
	["name2"] = {1, false, true, 23.54, "a \021 string"},
	name3 = Json.Null() 
 }

 local json = Json.Encode (t)
 print (json) 
 --> {"name1":"value1","name3":null,"name2":[1,false,true,23.54,"a \u0015 string"]}

 local t = Json.Decode(json)
 print(t.name2[4])
 --> 23.54
 
 Notes:
 1) Encodable Lua types: string, number, boolean, table, nil
 2) Use Json.Null() to insert a null value into a Json object
 3) All control chars are encoded to \uXXXX format eg "\021" encodes to "\u0015"
 4) All Json \uXXXX chars are decoded to chars (0-255 byte range only)
 5) Json single line // and /* */ block comments are discarded during decoding
 6) Numerically indexed Lua arrays are encoded to Json Lists eg [1,2,3]
 7) Lua dictionary tables are converted to Json objects eg {"one":1,"two":2}
 8) Json nulls are decoded to Lua nil and treated by Lua in the normal way

--]]

local string = string
local math = math
local table = table
local error = error
local tonumber = tonumber
local tostring = tostring
local type = type
local setmetatable = setmetatable
local pairs = pairs
local ipairs = ipairs
local assert = assert
local Chipmunk = Chipmunk

module("Json")

local StringBuilder = {
	buffer = {}
}

function StringBuilder:New()
	local o = {}
	setmetatable(o, self)
	self.__index = self
	o.buffer = {}
	return o
end

function StringBuilder:Append(s)
	self.buffer[#self.buffer+1] = s
end

function StringBuilder:ToString()
	return table.concat(self.buffer)
end

local JsonWriter = {
	backslashes = {
		['\b'] = "\\b",
		['\t'] = "\\t",	
		['\n'] = "\\n", 
		['\f'] = "\\f",
		['\r'] = "\\r", 
		['"']  = "\\\"", 
		['\\'] = "\\\\", 
		['/']  = "\\/"
	}
}

function JsonWriter:New()
	local o = {}
	o.writer = StringBuilder:New()
	setmetatable(o, self)
	self.__index = self
	return o
end

function JsonWriter:Append(s)
	self.writer:Append(s)
end

function JsonWriter:ToString()
	return self.writer:ToString()
end

function JsonWriter:Write(o)
	local t = type(o)
	if t == "nil" then
		self:WriteNil()
	elseif t == "boolean" then
		self:WriteString(o)
	elseif t == "number" then
		self:WriteString(o)
	elseif t == "string" then
		self:ParseString(o)
	elseif t == "table" then
		self:WriteTable(o)
	elseif t == "function" then
		self:WriteFunction(o)
	elseif t == "thread" then
		self:WriteError(o)
	elseif t == "userdata" then
		self:WriteError(o)
	end
end

function JsonWriter:WriteNil()
	self:Append("null")
end

function JsonWriter:WriteString(o)
	self:Append(tostring(o))
end

function JsonWriter:ParseString(s)
	self:Append('"')
	self:Append(string.gsub(s, "[%z%c\\\"/]", function(n)
		local c = self.backslashes[n]
		if c then return c end
		return string.format("\\u%.4X", string.byte(n))
	end))
	self:Append('"')
end

function JsonWriter:IsArray(t)
	local count = 0
	local isindex = function(k) 
		if type(k) == "number" and k > 0 then
			if math.floor(k) == k then
				return true
			end
		end
		return false
	end
	for k,v in pairs(t) do
		if not isindex(k) then
			return false, '{', '}'
		else
			count = math.max(count, k)
		end
	end
	return true, '[', ']', count
end

function JsonWriter:WriteTable(t)
	local ba, st, et, n = self:IsArray(t)
	self:Append(st)	
	if ba then		
		for i = 1, n do
			self:Write(t[i])
			if i < n then
				self:Append(',')
			end
		end
	else
		local first = true;
		for k, v in pairs(t) do
			if not first then
				self:Append(',')
			end
			first = false;			
			self:ParseString(k)
			self:Append(':')
			self:Write(v)			
		end
	end
	self:Append(et)
end

function JsonWriter:WriteError(o)
	error(string.format(
		"Encoding of %s unsupported", 
		tostring(o)))
end

function JsonWriter:WriteFunction(o)
	if o == Null then 
		self:WriteNil()
	else
		self:WriteError(o)
	end
end

local StringReader = {
	s = "",
	i = 0
}

function StringReader:New(s)
	local o = {}
	setmetatable(o, self)
	self.__index = self
	o.s = s or o.s
	return o	
end

function StringReader:Peek()
	local i = self.i + 1
	if i <= #self.s then
		return string.sub(self.s, i, i)
	end
	return nil
end

function StringReader:Next()
	self.i = self.i+1
	if self.i <= #self.s then
		return string.sub(self.s, self.i, self.i)
	end
	return nil
end

function StringReader:All()
	return self.s
end

local JsonReader = {
	escapes = {
		['t'] = '\t',
		['n'] = '\n',
		['f'] = '\f',
		['r'] = '\r',
		['b'] = '\b',
	}
}

function JsonReader:New(s)
	local o = {}
	o.reader = StringReader:New(s)
	setmetatable(o, self)
	self.__index = self
	return o;
end

function JsonReader:Read()
	self:SkipWhiteSpace()
	local peek = self:Peek()
	if peek == nil then
		error(string.format(
			"Nil string: '%s'", 
			self:All()))
	elseif peek == '{' then
		return self:ReadObject()
	elseif peek == '[' then
		return self:ReadArray()
	elseif peek == '"' then
		return self:ReadString()
	elseif string.find(peek, "[%+%-%d]") then
		return self:ReadNumber()
	elseif peek == 't' then
		return self:ReadTrue()
	elseif peek == 'f' then
		return self:ReadFalse()
	elseif peek == 'n' then
		return self:ReadNull()
	elseif peek == '/' then
		self:ReadComment()
		return self:Read()
	else
		error(string.format(
			"Invalid input: '%s'", 
			self:All()))
	end
end
		
function JsonReader:ReadTrue()
	self:TestReservedWord{'t','r','u','e'}
	return true
end

function JsonReader:ReadFalse()
	self:TestReservedWord{'f','a','l','s','e'}
	return false
end

function JsonReader:ReadNull()
	self:TestReservedWord{'n','u','l','l'}
	return nil
end

function JsonReader:TestReservedWord(t)
	for i, v in ipairs(t) do
		if self:Next() ~= v then
			 error(string.format(
				"Error reading '%s': %s", 
				table.concat(t), 
				self:All()))
		end
	end
end

function JsonReader:ReadNumber()
        local result = self:Next()
        local peek = self:Peek()
        while peek ~= nil and string.find(
		peek, 
		"[%+%-%d%.eE]") do
            result = result .. self:Next()
            peek = self:Peek()
	end
	result = tonumber(result)
	if result == nil then
	        error(string.format(
			"Invalid number: '%s'", 
			result))
	else
		return result
	end
end

function JsonReader:ReadString()
	local result = ""
	assert(self:Next() == '"')
        while self:Peek() ~= '"' do
		local ch = self:Next()
		if ch == '\\' then
			ch = self:Next()
			if self.escapes[ch] then
				ch = self.escapes[ch]
			end
		end
                result = result .. ch
	end
        assert(self:Next() == '"')
	local fromunicode = function(m)
		return string.char(tonumber(m, 16))
	end
	return string.gsub(
		result, 
		"u%x%x(%x%x)", 
		fromunicode)
end

function JsonReader:ReadComment()
        assert(self:Next() == '/')
        local second = self:Next()
        if second == '/' then
            self:ReadSingleLineComment()
        elseif second == '*' then
            self:ReadBlockComment()
        else
            error(string.format(
		"Invalid comment: %s", 
		self:All()))
	end
end

function JsonReader:ReadBlockComment()
	local done = false
	while not done do
		local ch = self:Next()		
		if ch == '*' and self:Peek() == '/' then
			done = true
                end
		if not done and 
			ch == '/' and 
			self:Peek() == "*" then
                    error(string.format(
			"Invalid comment: %s, '/*' illegal.",  
			self:All()))
		end
	end
	self:Next()
end

function JsonReader:ReadSingleLineComment()
	local ch = self:Next()
	while ch ~= '\r' and ch ~= '\n' do
		ch = self:Next()
	end
end

function JsonReader:ReadArray()
	local result = {}
	assert(self:Next() == '[')
	local done = false
	if self:Peek() == ']' then
		done = true;
	end
	while not done do
		local item = self:Read()
		result[#result+1] = item
		self:SkipWhiteSpace()
		if self:Peek() == ']' then
			done = true
		end
		if not done then
			local ch = self:Next()
			if ch ~= ',' then
				error(string.format(
					"Invalid array: '%s' due to: '%s'", 
					self:All(), ch))
			end
		end
	end
	assert(']' == self:Next())
	return result
end

function JsonReader:ReadObject()
	local result = {}
	assert(self:Next() == '{')
	local done = false
	if self:Peek() == '}' then
		done = true
	end
	while not done do
		local key = self:Read()
		if type(key) ~= "string" then
			error(string.format(
				"Invalid non-string object key: %s", 
				key))
		end
		self:SkipWhiteSpace()
		local ch = self:Next()
		if ch ~= ':' then
			error(string.format(
				"Invalid object: '%s' due to: '%s'", 
				self:All(), 
				ch))
		end
		self:SkipWhiteSpace()
		local val = self:Read()
		result[key] = val
		self:SkipWhiteSpace()
		if self:Peek() == '}' then
			done = true
		end
		if not done then
			ch = self:Next()
                	if ch ~= ',' then
				error(string.format(
					"Invalid array: '%s' near: '%s'", 
					self:All(), 
					ch))
			end
		end
	end
	assert(self:Next() == "}")
	return result
end

function JsonReader:SkipWhiteSpace()
	local p = self:Peek()
	while p ~= nil and string.find(p, "[%s/]") do
		if p == '/' then
			self:ReadComment()
		else
			self:Next()
		end
		p = self:Peek()
	end
end

function JsonReader:Peek()
	return self.reader:Peek()
end

function JsonReader:Next()
	return self.reader:Next()
end

function JsonReader:All()
	return self.reader:All()
end

function Encode(o)
	local writer = JsonWriter:New()
	writer:Write(o)
	return writer:ToString()
end

function Decode(s)
	local reader = JsonReader:New(s)
	return reader:Read()
end

function Null()
	return Null
end


--lua/weapons/gmod_tool/stools/rb655_easy_animation.lua:

TOOL.Category = "Robotboy655"
TOOL.Name = "#tool.rb655_easy_animation.name"
TOOL.AnimationArray = {}

TOOL.ClientConVar[ "anim" ] = ""
TOOL.ClientConVar[ "speed" ] = "1.0"
TOOL.ClientConVar[ "delay" ] = "0"
TOOL.ClientConVar[ "nohide" ] = "0"
TOOL.ClientConVar[ "loop" ] = "0"
TOOL.ClientConVar[ "noglow" ] = "0"

TOOL.ServerConVar[ "nobbox_sv" ] = "0"
CreateConVar( "rb655_easy_animation_nobbox_sv", "0", FCVAR_ARCHIVE )

local function MakeNiceName( str )
	local newname = {}
	for _, s in pairs( string.Explode( "_", string.Replace( str, " ", "_" ) ) ) do
		if ( string.len( s ) == 0 ) then continue end
		if ( string.len( s ) == 1 ) then table.insert( newname, string.upper( s ) ) continue end
		table.insert( newname, string.upper( string.Left( s, 1 ) ) .. string.Right( s, string.len( s ) - 1 ) ) -- Ugly way to capitalize first letters.
	end

	return table.concat( newname, " " )
end

local function IsEntValid( ent )
	if ( !IsValid( ent ) or ent:IsWorld() ) then return false end
	if ( table.Count( ent:GetSequenceList() or {} ) != 0 ) then return true end
	return false
end

local function PlayAnimationBase( ent, anim, speed )
	if ( !IsValid( ent ) ) then return end

	-- HACK: This is not perfect, but it will have to do
	if ( ent:GetClass() == "prop_dynamic" ) then
		ent:Fire( "SetAnimation", anim )
		ent:Fire( "SetPlaybackRate", math.Clamp( tonumber( speed ), 0.05, 3.05 ) )
		return
	end

	ent:ResetSequence( ent:LookupSequence( anim ) )
	ent:ResetSequenceInfo()
	ent:SetCycle( 0 )
	ent:SetPlaybackRate( math.Clamp( tonumber( speed ), 0.05, 3.05 ) )

end

local UniqueID = 0
function PlayAnimation( ply, ent, anim, speed, delay, loop, isPreview )
	if ( !IsValid( ent ) ) then return end

	delay = tonumber( delay ) or 0
	loop = tobool( loop ) or false

	UniqueID = UniqueID + 1
	local tid = "rb655_animation_loop_" .. ply:UniqueID() .. "-" .. UniqueID

	if ( isPreview ) then tid = "rb655_animation_loop_preview" .. ply:UniqueID() end

	timer.Create( tid, delay, 1, function()
		PlayAnimationBase( ent, anim, speed )
		if ( loop == true and IsValid( ent ) ) then
			timer.Adjust( tid, ent:SequenceDuration() / speed, 0, function()
				if ( !IsValid( ent ) ) then timer.Remove( tid ) return end
				PlayAnimationBase( ent, anim, speed )
			end )
		end
	end )
end

function TOOL:GetSelectedEntity()
	return self:GetWeapon():GetNWEntity( 1 )
end

function TOOL:SetSelectedEntity( ent )
	if ( IsValid( ent ) and ent:GetClass() == "prop_effect" ) then ent = ent.AttachedEntity end
	if ( !IsValid( ent ) ) then ent = NULL end

	if ( self:GetSelectedEntity() == ent ) then return end

	self:GetWeapon():SetNWEntity( 1, ent )
end

local gOldCVar1 = GetConVarNumber( "ai_disabled" )
local gOldCVar2 = GetConVarNumber( "rb655_easy_animation_nohide" )

local gLastSelectedEntity = NULL
function TOOL:Think()
	local ent = self:GetSelectedEntity()
	if ( !IsValid( ent ) ) then self:SetSelectedEntity( NULL ) end

	if ( CLIENT ) then
		if ( gOldCVar1 != GetConVarNumber( "ai_disabled" ) or gOldCVar2 != GetConVarNumber( "rb655_easy_animation_nohide" ) ) then
			gOldCVar1 = GetConVarNumber( "ai_disabled" )
			gOldCVar2 = GetConVarNumber( "rb655_easy_animation_nohide" )
			if ( IsEntValid( ent ) and ent:IsNPC() ) then self:UpdateControlPanel() end
		end
		if ( ent:EntIndex() == gLastSelectedEntity ) then return end
		gLastSelectedEntity = ent:EntIndex()
		self:UpdateControlPanel()
		RunConsoleCommand( "rb655_easy_animation_anim", "" )
	end
end

function TOOL:RightClick( trace )
	if ( SERVER ) then self:SetSelectedEntity( trace.Entity ) end
	return true
end

function TOOL:Reload( trace )
	if ( SERVER ) then
		if ( #self.AnimationArray <= 0 and IsValid( self:GetSelectedEntity() ) ) then
			self:GetSelectedEntity():SetPlaybackRate( 0 )
		elseif ( #self.AnimationArray > 0 ) then
			for id, t in pairs( self.AnimationArray ) do
				if ( IsValid( t.ent ) ) then t.ent:SetPlaybackRate( 0 ) end
			end
		end

		-- Destroy all timers.
		for i = 0, UniqueID do timer.Remove( "rb655_animation_loop_" .. self:GetOwner():UniqueID() .. "-" .. i ) UniqueID = 0 end
		timer.Remove( "rb655_animation_loop_preview" .. self:GetOwner():UniqueID() )
	end
	return true
end

if ( SERVER ) then
	util.AddNetworkString( "rb655_easy_animation_array" )

	function TOOL:LeftClick( trace )
		local ent = self:GetSelectedEntity()
		local anim = self:GetClientInfo( "anim" )

		for i = 0, UniqueID do timer.Remove( "rb655_animation_loop_" .. self:GetOwner():UniqueID() .. "-" .. i ) UniqueID = 0 end
		timer.Remove( "rb655_animation_loop_preview" .. self:GetOwner():UniqueID() )

		if ( #self.AnimationArray > 0 ) then
			for id, t in pairs( self.AnimationArray ) do
				if ( !IsEntValid( t.ent ) or string.len( string.Trim( t.anim ) ) == 0 ) then continue end
				PlayAnimation( self:GetOwner(), t.ent, t.anim, t.speed, t.delay, t.loop )
			end
		else
			if ( !IsEntValid( ent ) or string.len( string.Trim( anim ) ) == 0 ) then return end
			PlayAnimation( self:GetOwner(), ent, anim, self:GetClientInfo( "speed" ), self:GetClientInfo( "delay" ), self:GetClientInfo( "loop" ), true )
		end

		return true
	end

	concommand.Add( "rb655_easy_animation_anim_do", function( ply, cmd, args )
		local tool = ply:GetTool( "rb655_easy_animation" )
		if ( !tool ) then return end

		local ent = tool:GetSelectedEntity()
		if ( !IsEntValid( ent ) ) then return end

		for i = 0, UniqueID do timer.Remove( "rb655_animation_loop_" .. ply:UniqueID() .. "-" .. i ) UniqueID = 0 end
		timer.Remove( "rb655_animation_loop_preview" .. ply:UniqueID() )

		PlayAnimation( ply, ent, args[ 1 ] or "", ply:GetTool( "rb655_easy_animation" ):GetClientInfo( "speed" ), 0, ply:GetTool():GetClientInfo( "loop" ), true )
	end )

	concommand.Add( "rb655_easy_animation_set_pp", function( ply, cmd, args )
		local tool = ply:GetTool( "rb655_easy_animation" )
		if ( !tool ) then return end

		local ent = tool:GetSelectedEntity()
		if ( !IsEntValid( ent ) ) then return end

		local pp_name = ent:GetPoseParameterName( math.floor( tonumber( args[ 1 ] ) ) )
		if ( !pp_name ) then return end

		ent:SetPoseParameter( pp_name, tonumber( args[ 2 ] ) )
	end )

	concommand.Add( "rb655_easy_animation_add", function( ply, cmd, args )
		local tool = ply:GetTool( "rb655_easy_animation" )
		if ( !tool ) then return end
		local e = tool:GetSelectedEntity()
		local a = tool:GetClientInfo( "anim" )
		local s = tool:GetClientInfo( "speed" )
		local d = tool:GetClientInfo( "delay" )
		local l = tool:GetClientInfo( "loop" )
		if ( !IsEntValid( e ) or string.len( string.Trim( a ) ) == 0 ) then return end

		table.insert( tool.AnimationArray, {ent = e, anim = a, speed = s, delay = d, loop = l, ei = e:EntIndex()} )
		net.Start( "rb655_easy_animation_array" )
			net.WriteTable( tool.AnimationArray )
		net.Send( ply )
	end )

	concommand.Add( "rb655_easy_animation_rid", function( ply, cmd, args ) -- rid is for RemoveID
		local tool = ply:GetTool( "rb655_easy_animation" )
		if ( !tool.AnimationArray[ tonumber( args[ 1 ] ) ] ) then return end
		if ( tool.AnimationArray[ tonumber( args[ 1 ] ) ].ei != tonumber( args[ 2 ] ) and tonumber( args[ 2 ] ) != 0 ) then return end

		table.remove( tool.AnimationArray, tonumber( args[ 1 ] ) )
		net.Start( "rb655_easy_animation_array" )
			net.WriteTable( tool.AnimationArray )
		net.Send( ply )
	end )
end

if ( SERVER ) then return end

TOOL.Information = {
	{ name = "info", stage = 1 },
	{ name = "left" },
	{ name = "right" },
	{ name = "reload" },
}

language.Add( "tool.rb655_easy_animation.left", "Play all animations" )
language.Add( "tool.rb655_easy_animation.right", "Select an object to play animations on" )
language.Add( "tool.rb655_easy_animation.reload", "Pause currently playing animation(s)" )

language.Add( "tool.rb655_easy_animation.name", "Easy Animation Tool" )
language.Add( "tool.rb655_easy_animation.desc", "Easy animations for everyone" )
language.Add( "tool.rb655_easy_animation.1", "Use context menu to play animations" )

language.Add( "tool.rb655_easy_animation.animations", "Animations" )
language.Add( "tool.rb655_easy_animation.add", "Add current selection" )
language.Add( "tool.rb655_easy_animation.add.help", "\nIf you want to play animations on multiple entities at one:\n1) Select entity\n2) Select animation from the list, if the entity has any.\n3) Configure sliders to your desire.\n4) Click \"Add current selection\"\n5) Do 1-4 steps as many times as you wish.\n6) Left-click\n\nYou cannot play two animations on the same entity at the same time. The last animation will cut off the first one." )
language.Add( "tool.rb655_easy_animation.speed", "Animation Speed" )
language.Add( "tool.rb655_easy_animation.speed.help", "How fast the animation will play." )
language.Add( "tool.rb655_easy_animation.delay", "Delay" )
language.Add( "tool.rb655_easy_animation.delay.help", "The time between you left-click and the animation is played." )
language.Add( "tool.rb655_easy_animation.loop", "Loop Animation" )
language.Add( "tool.rb655_easy_animation.loop.help", "Play animation again when it ends." )
language.Add( "tool.rb655_easy_animation.nohide", "Do not filter animations" )
language.Add( "tool.rb655_easy_animation.nohide.help", "Enabling this option will show you the full list of animations available for selected entity. Please note, that this list can be so long, that GMod may freeze for a few seconds. For this reason we hide a bunch of animations deemed \"useless\" by default, such as gestures and other delta animations." )
language.Add( "tool.rb655_easy_animation.poseparam.help", "The sliders above are the Pose Parameters. They affect how certain animations look, for example the direction for Team Fortress 2 run animations, etc." )
language.Add( "tool.rb655_easy_animation.poseparam.badent", "Changing Pose Parameters is only supported on Animatable props!" )

language.Add( "tool.rb655_easy_animation.ai", "NPC is selected, but NPC thinking is not disabled! Without that the NPC will reset its animations every frame." )
language.Add( "tool.rb655_easy_animation.ragdoll", "Ragdolls cannot be animated! Open context menu (Hold C) > right click on ragdoll > Make Animatable" )
language.Add( "tool.rb655_easy_animation.prop", "Props cannot be animated properly! Open context menu (Hold C) > right click on entity > Make Animatable" )
language.Add( "tool.rb655_easy_animation.badent", "This entity does not have any animations." )
language.Add( "tool.rb655_easy_animation.noent", "No entity selected." )

language.Add( "tool.rb655_easy_animation.noglow", "Don't render glow/halo around models" )
language.Add( "tool.rb655_easy_animation.noglow.help", "Don't render glow/halo around models when they are selected, and don't draw bounding boxes below animated models. Bounding boxes are a helper for when animations make the ragdolls go outside of their bounding box making them unselectable.\n" )

language.Add( "tool.rb655_easy_animation.property", "Make Animatable" )
language.Add( "tool.rb655_easy_animation.property_bodyxy", "Animate Movement Pose Parameters" )
language.Add( "tool.rb655_easy_animation.property_damageragdoll", "Ragdoll/Gib on Damage" )
language.Add( "tool.rb655_easy_animation.property_ragdoll", "Make Ragdoll" )
language.Add( "prop_animatable", "Animatable Entity" )

function TOOL:GetStage()
	if ( IsValid( self:GetSelectedEntity() ) ) then return 1 end
	return 0
end

net.Receive( "rb655_easy_animation_array", function( len )
	local tool = LocalPlayer():GetTool( "rb655_easy_animation" )
	tool.AnimationArray = net.ReadTable()
	if ( CLIENT ) then tool:UpdateControlPanel() end
end )

function TOOL:UpdateControlPanel( index )
	local panel = controlpanel.Get( "rb655_easy_animation" )
	if ( !panel ) then MsgN( "Couldn't find rb655_easy_animation panel!" ) return end

	panel:ClearControls()
	self.BuildCPanel( panel, self:GetSelectedEntity() )
end

local clr_err = Color( 200, 0, 0 )
function TOOL.BuildCPanel( panel, ent )

	local tool = LocalPlayer() and LocalPlayer():GetTool( "rb655_easy_animation" )
	local nohide = false

	if ( tool ) then
		if ( !IsValid( ent ) ) then ent = tool:GetSelectedEntity() end
		nohide = tool:GetClientNumber( "nohide" ) != 0
	end

	if ( !IsValid( ent ) ) then

		panel:AddControl( "Label", { Text = "#tool.rb655_easy_animation.noent" } ):SetTextColor( clr_err )

	elseif ( IsEntValid( ent ) ) then

		local fine = true

		if ( GetConVarNumber( "ai_disabled" ) == 0 and ent:IsNPC() ) then panel:AddControl( "Label", {Text = "#tool.rb655_easy_animation.ai"} ):SetTextColor( clr_err ) fine = false end
		if ( ent:GetClass() == "prop_ragdoll" ) then panel:AddControl( "Label", { Text = "#tool.rb655_easy_animation.ragdoll" } ):SetTextColor( clr_err ) fine = false end
		if ( ent:GetClass() == "prop_physics" or ent:GetClass() == "prop_physics_multiplayer" or ent:GetClass() == "prop_physics_override" ) then panel:AddControl( "Label", { Text = "#tool.rb655_easy_animation.prop" } ):SetTextColor( clr_err ) end

		local t = {}
		local badBegginings = { "g_", "p_", "e_", "b_", "bg_", "hg_", "tc_", "aim_", "turn", "gest_", "pose_", "pose_", "auto_", "layer_", "posture", "bodyaccent", "a_" }
		local badStrings = { "gesture", "posture", "_trans_", "_rot_", "gest", "aim", "bodyflex_", "delta", "ragdoll", "spine", "arms" }
		for k, v in SortedPairsByValue( ent:GetSequenceList() ) do
			local isbad = false

			for i, s in pairs( badStrings ) do if ( string.find( string.lower( v ), s, 1, true ) != nil ) then isbad = true break end end
			if ( isbad == true and !nohide ) then continue end

			for i, s in pairs( badBegginings ) do if ( s == string.Left( string.lower( v ), string.len( s ) ) ) then isbad = true break end end
			if ( isbad == true and !nohide ) then continue end

			language.Add( "rb655_anim_" .. v, MakeNiceName( v ) )
			t[ "#rb655_anim_" .. v ] = { rb655_easy_animation_anim = v, rb655_easy_animation_anim_do = v }
		end

		if ( fine ) then
			local filter = panel:AddControl( "TextBox", { Label = "#spawnmenu.quick_filter_tool" } )
			filter:SetUpdateOnType( true )

			local animList = panel:AddControl( "ListBox", { Label = "#tool.rb655_easy_animation.animations", Options = t, Height = 225 } )

			-- patch the function to take into account visiblity
			function animList:DataLayout()
				local y = 0
				for k, Line in ipairs( self.Sorted ) do
					if ( !Line:IsVisible() ) then continue end

					Line:SetPos( 1, y )
					Line:SetSize( self:GetWide() - 2, self.m_iDataHeight )
					Line:DataLayout( self )

					Line:SetAltLine( k % 2 == 1 )

					y = y + Line:GetTall()
				end

				return y
			end

			filter.OnValueChange = function( s, txt )
				for id, pnl in pairs( animList:GetCanvas():GetChildren() ) do
					if ( !pnl:GetValue( 1 ):lower():find( txt:lower(), 1, true ) ) then
						pnl:SetVisible( false )
					else
						pnl:SetVisible( true )
					end
				end
				animList:SetDirty( true )
				animList:InvalidateLayout()
			end
		end

	elseif ( !IsEntValid( ent ) ) then

		panel:AddControl( "Label", { Text = "#tool.rb655_easy_animation.badent" } ):SetTextColor( clr_err )

	end

	if ( IsValid( ent ) and ent:GetClass() == "prop_animatable" ) then
		for k = 0, ent:GetNumPoseParameters() - 1 do
			local min, max = ent:GetPoseParameterRange( k )
			local name = ent:GetPoseParameterName( k )

			local ctrl = panel:NumSlider( name, nil, min, max, 2 )
			ctrl:SetHeight( 11 ) -- This makes the controls all bunched up like how we want
			ctrl:DockPadding( 0, -6, 0, -4 ) -- Try to make the lower part of the text visible
			ctrl:SetValue( math.Remap( ent:GetPoseParameter( name ), 0, 1, min, max ) )

			ctrl.OnValueChanged = function( self, value )
				RunConsoleCommand( "rb655_easy_animation_set_pp", k, value )

				--ent:SetPoseParameter( ent:GetPoseParameterName( k ), math.Remap( value, min, max, 0, 1 ) )
				ent:SetPoseParameter( ent:GetPoseParameterName( k ), value )
			end
		end

		if ( ent:GetNumPoseParameters() > 0 ) then
			panel:ControlHelp( "#tool.rb655_easy_animation.poseparam.help" ):DockMargin( 32, 8, 32, 8 )
		end

	elseif ( IsValid( ent ) and ent:GetClass() != "prop_animatable" and ent:GetNumPoseParameters() > 0 ) then
		local errlbl = panel:ControlHelp( "#tool.rb655_easy_animation.poseparam.badent" )
		errlbl:DockMargin( 32, 8, 32, 8 )
		errlbl:SetTextColor( clr_err )
	end

	local pnl = vgui.Create( "DPanelList" )
	pnl:SetHeight( 225 )
	pnl:EnableHorizontal( false )
	pnl:EnableVerticalScrollbar()
	pnl:SetSpacing( 2 )
	pnl:SetPadding( 2 )
	Derma_Hook( pnl, "Paint", "Paint", "Panel" ) -- Awesome GWEN background

	if ( tool and tool.AnimationArray ) then
		for i, d in pairs( tool.AnimationArray ) do
			local s = vgui.Create( "RAnimEntry" )
			s:SetInfo( i, d.ent, d.anim, d.speed, d.delay, d.loop )
			pnl:AddItem( s )
		end
	end

	panel:AddPanel( pnl )

	panel:AddControl( "Button", { Label = "#tool.rb655_easy_animation.add", Command = "rb655_easy_animation_add" } )
	panel:ControlHelp( "#tool.rb655_easy_animation.add.help" )
	panel:AddControl( "Slider", { Label = "#tool.rb655_easy_animation.speed", Type = "Float", Min = 0.05, Max = 3.05, Command = "rb655_easy_animation_speed", Help = true } )
	panel:AddControl( "Slider", { Label = "#tool.rb655_easy_animation.delay", Type = "Float", Min = 0, Max = 32, Command = "rb655_easy_animation_delay", Help = true } )
	panel:AddControl( "Checkbox", { Label = "#tool.rb655_easy_animation.loop", Command = "rb655_easy_animation_loop", Help = true } )
	panel:AddControl( "Checkbox", { Label = "#tool.rb655_easy_animation.nohide", Command = "rb655_easy_animation_nohide", Help = true } )
	panel:AddControl( "Checkbox", { Label = "#tool.rb655_easy_animation.noglow", Command = "rb655_easy_animation_noglow", Help = true } )
end

function TOOL:DrawHUD()
	local ent = self:GetSelectedEntity()
	if ( !IsValid( ent ) or tobool( self:GetClientNumber( "noglow" ) ) ) then return end

	local t = { ent }
	if ( ent.GetActiveWeapon ) then table.insert( t, ent:GetActiveWeapon() ) end
	halo.Add( t, HSVToColor( ( CurTime() * 3 ) % 360, math.abs( math.sin( CurTime() / 2 ) ), 1 ), 2, 2, 1 )
end

local PANEL = {}

function PANEL:Init()
	self.ent = nil
	self.anim = "attack01"
	self.id = 0
	self.eid = 0
	self.speed = 1
	self.delay = 0
	self.loop = false

	self.rem = vgui.Create( "DImageButton", self )
	self.rem:SetImage( "icon16/cross.png" )
	self.rem:SetSize( 16, 16 )
	self.rem:SetPos( 4, 4 )
	self.rem.DoClick = function()
		self:RemoveFull()
	end
end

function PANEL:RemoveFull()
	self.rem:Remove()
	self:Remove()
	RunConsoleCommand( "rb655_easy_animation_rid", self.id, self.eid )
end

function PANEL:Paint( w, h )
	draw.RoundedBox( 2, 0, 0, w, h, Color( 50, 50, 50, 225 ) )
	if ( !self.ent or !IsValid( self.ent ) ) then self:RemoveFull() return end

	surface.SetFont( "DermaDefault" )
	draw.SimpleText( "#" .. self.ent:GetClass(), "DermaDefault", 24, 0, Color( 255, 255, 255, 255 ) )
	draw.SimpleText( "#rb655_anim_" .. self.anim, "DermaDefault", 24, 10, Color( 255, 255, 255, 255 ) )

	local tW = surface.GetTextSize( "#" .. self.ent:GetClass() )
	draw.SimpleText( " #" .. self.ent:EntIndex(), "DermaDefault", 24 + tW, 0, Color( 255, 255, 255, 255 ) )

	local tW2 = surface.GetTextSize( "#rb655_anim_" .. self.anim )
	local t = " [ S: " .. self.speed .. ", D: " .. self.delay
	if ( self.loop ) then t = t .. ", Looping" end
	draw.SimpleText( t .. " ]", "DermaDefault", 24 + tW2, 10, Color( 255, 255, 255, 255 ) )
end

function PANEL:SetInfo( id, e, a, s, d, l )
	self.id = id
	self.eid = e:EntIndex()
	self.ent = e
	self.anim = a
	self.speed = s
	self.delay = d
	self.loop = tobool( l )
end

vgui.Register( "RAnimEntry", PANEL, "Panel" )

--lua/improvedstacker/improvedstacker.lua:
--[[--------------------------------------------------------------------------
	Improved Stacker Module
	
	Author:
		Mista-Tea ([IJWTB] Thomas)
	
	License:
		The MIT License (MIT)

		Copyright (c) 2014-2020 Mista-Tea

		Permission is hereby granted, free of charge, to any person obtaining a copy
		of this software and associated documentation files (the "Software"), to deal
		in the Software without restriction, including without limitation the rights
		to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
		copies of the Software, and to permit persons to whom the Software is
		furnished to do so, subject to the following conditions:

		The above copyright notice and this permission notice shall be included in all
		copies or substantial portions of the Software.

		THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
		IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
		FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
		AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
		LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
		OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
		SOFTWARE.
			
	Changelog:
----------------------------------------------------------------------------]]

local math = math
local hook = hook
local Angle = Angle
local Vector = Vector
local GetConVar = GetConVar
local duplicator = duplicator
local CreateConVar = CreateConVar

--[[--------------------------------------------------------------------------
-- 	Namespace Tables
--------------------------------------------------------------------------]]--

module( "improvedstacker", package.seeall )

--[[--------------------------------------------------------------------------
-- 	Localized Functions & Variables
--------------------------------------------------------------------------]]--

-- enums for determining stack relativity
MODE_WORLD = 1 -- stacking relative to the world
MODE_PROP  = 2 -- stacking relative to the prop

-- lookup table for validating relative values
Modes = {
	[MODE_WORLD] = true,
	[MODE_PROP]  = true,
}

-- enums for determining the direction to stack props
DIRECTION_FRONT = 1
DIRECTION_BACK  = 2
DIRECTION_RIGHT = 3
DIRECTION_LEFT  = 4
DIRECTION_UP    = 5
DIRECTION_DOWN  = 6

-- lookup table for validating direction values
Directions = {
	[DIRECTION_FRONT] = true,
	[DIRECTION_BACK]  = true,
	[DIRECTION_RIGHT] = true,
	[DIRECTION_LEFT]  = true,
	[DIRECTION_UP]    = true,
	[DIRECTION_DOWN]  = true,
}

-- constants used for when stacking relative to the World
ANGLE_ZERO   =  Angle( 0, 0, 0 )
VECTOR_FRONT  = ANGLE_ZERO:Forward()
VECTOR_RIGHT  = ANGLE_ZERO:Right()
VECTOR_UP     = ANGLE_ZERO:Up()
VECTOR_BACK   = -VECTOR_FRONT
VECTOR_LEFT   = -VECTOR_RIGHT
VECTOR_DOWN   = -VECTOR_UP

-- there has been a longstanding problem where stacked entities were an inch apart (figuratively), causing gaps everywhere.
-- as it turns out, fixing this issue is as easy as subtracting 0.5 from the forward component of the offset vector.
MAGIC_OFFSET = -0.5

--[[--------------------------------------------------------------------------
--	Namespace Functions
--------------------------------------------------------------------------]]--

if ( SERVER ) then
	
	-- the tables below are used internally and should only generally be interfaced with
	-- via the functions declared afterward.
	-- basically treat them as private, since they are only public for auto-refresh compatibility
	
	-- holds the current stacked entity count for every player
	m_EntCount  = m_EntCount  or {}
	-- holds the last stacker usage for every player
	m_StackTime = m_StackTime or {}
	-- holds every stacker entity created
	m_Ents      = m_Ents      or {}
		
	--[[--------------------------------------------------------------------------
	-- 	GetEntCount( player, number )
	--]]--
	function GetEntCount( ply, default )
		return m_EntCount[ ply:SteamID() ] or default
	end
	--[[--------------------------------------------------------------------------
	-- 	SetEntCount( player, number )
	--]]--
	function SetEntCount( ply, num )
		m_EntCount[ ply:SteamID() ] = num
	end
	--[[--------------------------------------------------------------------------
	-- 	IncrementEntCount( player, number )
	--]]--
	function IncrementEntCount( ply, num )
		m_EntCount[ ply:SteamID() ] = GetEntCount( ply, 0 ) + (num or 1)
	end
	--[[--------------------------------------------------------------------------
	-- 	DecrementEntCount( player, number )
	--]]--
	function DecrementEntCount( ply, num )
		m_EntCount[ ply:SteamID() ] = ( m_EntCount[ ply:SteamID() ] and m_EntCount[ ply:SteamID() ] - (num or 1) ) or 0
	end
	
	--[[--------------------------------------------------------------------------
	-- 	SetLastStackTime( player, number )
	--]]--
	function SetLastStackTime( ply, num )
		m_StackTime[ ply:SteamID() ] = num
	end
	--[[--------------------------------------------------------------------------
	-- 	GetLastStackTime( player, number )
	--]]--
	function GetLastStackTime( ply, default )
		return m_StackTime[ ply:SteamID() ] or default
	end
	
	--[[--------------------------------------------------------------------------
	--	Initialize( string )
	--
	--	This should be called immediately after including this file so that the follow
	--	variables/functions can use the stacker tool's mode (i.e., the name of the file itself
	--	and what is subsequently used in all of the cvars).
	--]]--
	function Initialize( mode )
		mode = mode or "stacker_improved"
		
		--[[--------------------------------------------------------------------------
		--  Hook :: PlayerInitialSpawn
		
		--	Sets the newly connected player's total stacker ents to 0.
		--	See TOOL:IsExceedingMax() for more details
		--]]--
		hook.Add( "PlayerInitialSpawn", mode.."_set_ent_count", function( ply )
			m_EntCount[ ply:SteamID() ] = 0
		end )
		--[[--------------------------------------------------------------------------
		--  Hook :: PlayerDisconnected
		--
		--	Removes the player from the table when they disconnect (for sanitation).
		--]]--
		hook.Add( "PlayerDisconnected", mode.."_remove_ent_count", function( ply )
			m_EntCount[ ply:SteamID() ] = nil
		end )
		
		--[[--------------------------------------------------------------------------
		-- 	MarkEntity( player, entity, table )
		--
		--	Marks the entity as a stacker entity. This allows the entity to be 
		--	collision-checked in GM.ShouldCollide.
		--]]--
		function MarkEntity( ply, ent, data )
			m_Ents[ ent ] = true
			duplicator.StoreEntityModifier( ent, mode, { StackerEnt = true } )
			ent:SetCustomCollisionCheck( true )
			
			-- when the entity is removed, sanitize our internal m_Ents array
			ent:CallOnRemove( mode, function( ent )
				ClearEntity( ent )
			end )
		end
		--duplicator.RegisterEntityModifier( mode, MarkEntity )
		--[[--------------------------------------------------------------------------
		-- 	ClearEntity( entity )
		--
		--	Removes the entity from the internal m_Ents array for sanitation purposes.
		--	This is called when an entity is just about to be removed.
		--]]--
		function ClearEntity( ent )
			if ( m_Ents[ ent ] ) then m_Ents[ ent ] = nil end
		end
		
		--[[--------------------------------------------------------------------------
		-- 	CanUnfreeze( player, entity, physObject )
		--]]--
		function CanUnfreeze( ply, ent, phys )
			if ( m_Ents[ ent ] ) then print("nope") return false end
		end
		--hook.Add( "CanPlayerUnfreeze", mode, CanUnfreeze )
		--hook.Add( "PhysgunPickup",     mode, CanUnfreeze )
		--hook.Remove( "CanPlayerUnfreeze", mode )
		--hook.Remove( "PhysgunPickup",     mode )
		
		local cvarNoCollideAll
		local cvarNoCollide
		--[[--------------------------------------------------------------------------
		-- 	ShouldCollide( entity, entity )
		--]]--
		function ShouldCollide( a, b )
			if ( not cvarNoCollideAll ) then cvarNoCollideAll = GetConVar( mode.."_force_nocollide_all" ) end
			if ( not cvarNoCollide )    then cvarNoCollide    = GetConVar( mode.."_force_nocollide" )     end
			
			if ( cvarNoCollideAll:GetBool() ) then
				if ( m_Ents[ a ] ) then
					if not ( b:IsPlayer() or b:IsWorld() or b:IsNPC() or b:IsVehicle() ) then return false end
				elseif ( m_Ents[ b ] ) then
					if not ( a:IsPlayer() or a:IsWorld() or b:IsNPC() or b:IsVehicle() ) then return false end
				end
			elseif ( cvarNoCollide:GetBool() ) then
				if ( m_Ents[ a ] and m_Ents[ b ] ) then return false end
			end
		end
		--hook.Add( "ShouldCollide", mode, ShouldCollide )
		--hook.Remove( "ShouldCollide", mode )
	end
	
elseif ( CLIENT ) then
	
	-- the table below is used internally and should only generally be interfaced with
	-- via the functions declared afterward.
	-- basically treat it as private, since it is only public for auto-refresh compatibility
	
	m_Ghosts    = m_Ghosts    or {}
	m_LookingAt = m_LookingAt or nil
	m_LookedAt  = m_LookedAt  or nil
	
	--[[--------------------------------------------------------------------------
	-- 	GetGhosts()
	--]]--
	function GetGhosts()
		return m_Ghosts
	end
	--[[--------------------------------------------------------------------------
	-- 	SetGhosts( table )
	--]]--
	function SetGhosts( tbl )
		m_Ghosts = tbl
	end
	
	--[[--------------------------------------------------------------------------
	-- 	GetLookingAt()
	--]]--
	function GetLookingAt()
		return m_LookingAt
	end
	--[[--------------------------------------------------------------------------
	-- 	SetLookingAt( entity )
	--]]--
	function SetLookingAt( ent )
		m_LookingAt = ent
	end
	
	--[[--------------------------------------------------------------------------
	-- 	GetLookedAt()
	--]]--
	function GetLookedAt()
		return m_LookedAt
	end
	--[[--------------------------------------------------------------------------
	-- 	SetLookedAt( entity )
	--]]--
	function SetLookedAt( ent )
		m_LookedAt = ent
	end
	
	--[[--------------------------------------------------------------------------
	-- 	ReleaseGhosts()
	--	
	--	Attempts to remove all ghosted props in the stack. 
	--	This occurs when the player stops looking at a prop with the stacker tool equipped.
	--]]--
	function ReleaseGhosts()
		if ( #m_Ghosts == 0 ) then return end
		
		for i = 1, #m_Ghosts do
			if ( not IsValid( m_Ghosts[ i ] ) ) then continue end
			SafeRemoveEntityDelayed( m_Ghosts[ i ], 0 )
			m_Ghosts[ i ] = nil
		end
	end
	
	--[[--------------------------------------------------------------------------
	--	Initialize( string )
	--
	--	This should be called immediately after including this file so that the follow
	--	variables/functions can use the stacker tool's mode (i.e., the name of the file itself
	--	and what is subsequently used in all of the cvars).
	--]]--
	function Initialize( mode )
		mode = mode or "stacker_improved"
		
		SETTINGS_DEFAULT = {
			[mode.."_set_max_per_player"]    = "-1",
			[mode.."_set_max_per_stack"]     = "15",
			[mode.."_set_delay"]             = "0.5",
			[mode.."_set_max_offsetx"]       = "200",
			[mode.."_set_max_offsety"]       = "200",
			[mode.."_set_max_offsetz"]       = "200",
			[mode.."_set_force_freeze"]      = "0",
			[mode.."_set_force_weld"]        = "0",
			[mode.."_set_force_nocollide"]   = "0",
			[mode.."_set_force_stayinworld"] = "1",
		}
		
		SETTINGS_SANDBOX = {
			[mode.."_set_max_per_player"]    = "-1",
			[mode.."_set_max_per_stack"]     = "30",
			[mode.."_set_delay"]             = "0.5",
			[mode.."_set_max_offsetx"]       = "1000",
			[mode.."_set_max_offsety"]       = "1000",
			[mode.."_set_max_offsetz"]       = "1000",
			[mode.."_set_force_freeze"]      = "0",
			[mode.."_set_force_weld"]        = "0",
			[mode.."_set_force_nocollide"]   = "0",
			[mode.."_set_force_stayinworld"] = "0",
		}
		
		SETTINGS_DARKRP = {
			[mode.."_set_max_per_player"]    = "50",
			[mode.."_set_max_per_stack"]     = "5",
			[mode.."_set_delay"]             = "1",
			[mode.."_set_max_offsetx"]       = "200",
			[mode.."_set_max_offsety"]       = "200",
			[mode.."_set_max_offsetz"]       = "200",
			[mode.."_set_force_freeze"]      = "1",
			[mode.."_set_force_weld"]        = "0",
			[mode.."_set_force_nocollide"]   = "1",
			[mode.."_set_force_stayinworld"] = "1",
		}
		
		SETTINGS_SINGLEPLAYER = {
			[mode.."_set_max_per_player"]    = "-1",
			[mode.."_set_max_per_stack"]     = "100",
			[mode.."_set_delay"]             = "0",
			[mode.."_set_max_offsetx"]       = "10000",
			[mode.."_set_max_offsety"]       = "10000",
			[mode.."_set_max_offsetz"]       = "10000",
			[mode.."_set_force_freeze"]      = "0",
			[mode.."_set_force_weld"]        = "0",
			[mode.."_set_force_nocollide"]   = "0",
			[mode.."_set_force_stayinworld"] = "0",
		}
	end
	
end

--
-- The functions below are used both serverside and clientside for properly orienting
-- and spacing props in a stack
--

-- Lookup table that holds functions related to determining the direction of a stack
DirectionFunctions = {
	[MODE_WORLD] = {
		[DIRECTION_FRONT] = function() return VECTOR_FRONT end,
		[DIRECTION_BACK]  = function() return VECTOR_BACK  end,
		[DIRECTION_RIGHT] = function() return VECTOR_RIGHT end,
		[DIRECTION_LEFT]  = function() return VECTOR_LEFT  end,
		[DIRECTION_UP]    = function() return VECTOR_UP    end,
		[DIRECTION_DOWN]  = function() return VECTOR_DOWN  end,
	},
	
	[MODE_PROP]  = {
		[DIRECTION_FRONT] = function( angle ) return  angle:Forward() end,
		[DIRECTION_BACK]  = function( angle ) return -angle:Forward() end,
		[DIRECTION_RIGHT] = function( angle ) return  angle:Right()   end,
		[DIRECTION_LEFT]  = function( angle ) return -angle:Right()   end,
		[DIRECTION_UP]    = function( angle ) return  angle:Up()      end,
		[DIRECTION_DOWN]  = function( angle ) return -angle:Up()      end,
	}
}

-- Lookup table that holds functions related to determining the distance to offset each prop in a stack
-- before applying the client's actual x/y/z offset values
DistanceFunctions = {
	[DIRECTION_FRONT] = function( min, max ) return math.abs(max.x - min.x) end,
	[DIRECTION_BACK]  = function( min, max ) return math.abs(max.x - min.x) end,
	[DIRECTION_RIGHT] = function( min, max ) return math.abs(max.y - min.y) end,
	[DIRECTION_LEFT]  = function( min, max ) return math.abs(max.y - min.y) end,
	[DIRECTION_UP]    = function( min, max ) return math.abs(max.z - min.z) end,
	[DIRECTION_DOWN]  = function( min, max ) return math.abs(max.z - min.z) end,
}

-- Lookup table that holds functions related to determining the distance to offset each prop in a stack
-- based on the client's x/y/z offset values
OffsetFunctions = {
	[DIRECTION_FRONT] = function( angle, offset ) return ( angle:Forward() * offset.x) + ( angle:Up()      * offset.z) + ( angle:Right()   * offset.y) end,
	[DIRECTION_BACK]  = function( angle, offset ) return (-angle:Forward() * offset.x) + ( angle:Up()      * offset.z) + (-angle:Right()   * offset.y) end,
	[DIRECTION_RIGHT] = function( angle, offset ) return ( angle:Right()   * offset.x) + ( angle:Up()      * offset.z) + (-angle:Forward() * offset.y) end,
	[DIRECTION_LEFT]  = function( angle, offset ) return (-angle:Right()   * offset.x) + ( angle:Up()      * offset.z) + ( angle:Forward() * offset.y) end,
	[DIRECTION_UP]    = function( angle, offset ) return ( angle:Up()      * offset.x) + (-angle:Forward() * offset.z) + ( angle:Right()   * offset.y) end,
	[DIRECTION_DOWN]  = function( angle, offset ) return (-angle:Up()      * offset.x) + ( angle:Forward() * offset.z) + ( angle:Right()   * offset.y) end,
}

RotationFunctions = {
	[DIRECTION_FRONT] = function( angle ) return  angle:Right(),   angle:Up(),       angle:Forward() end,
	[DIRECTION_BACK]  = function( angle ) return -angle:Right(),   angle:Up(),      -angle:Forward() end,
	[DIRECTION_RIGHT] = function( angle ) return -angle:Forward(), angle:Up(),       angle:Right()   end,
	[DIRECTION_LEFT]  = function( angle ) return  angle:Forward(), angle:Up(),      -angle:Right()   end,
	[DIRECTION_UP]    = function( angle ) return -angle:Right(),   angle:Forward(),  angle:Up()      end,
	[DIRECTION_DOWN]  = function( angle ) return  angle:Right(),   angle:Forward(), -angle:Up()      end,
}

--[[--------------------------------------------------------------------------
-- 	GetDirection( number, number, angle )
--
--	Calculates the direction to point the entity to by depending on whether the stack is
--	created relative to the world or the original prop, and the direction to stack in.
--]]--
function GetDirection( stackMode, stackDir, angle )
	return DirectionFunctions[ stackMode ][ stackDir ]( angle )
end

--[[--------------------------------------------------------------------------
-- 	GetDistance( number, number, entity )
--
--	Calculates the space occupied by the entity depending on the stack direction.
--	This represents the number of units to offset the stack entities so they appear
--	directly in front of the previous entity (depending on direction).
--]]--
function GetDistance( stackMode, stackDir, ent )
	if ( stackMode == MODE_WORLD ) then
		return DistanceFunctions[ stackDir ]( ent:WorldSpaceAABB() )
	elseif ( stackMode == MODE_PROP ) then
		return DistanceFunctions[ stackDir ]( ent:OBBMins(), ent:OBBMaxs() )
	end
end

--[[--------------------------------------------------------------------------
-- 	GetOffset( number, number, angle, vector )
--
--	Calculates a direction vector used for offsetting a stacked entity based on the facing angle of the previous entity.
--	This function uses a lookup table for added optimization as opposed to an if-else block.
--]]--
function GetOffset( stackMode, stackDir, angle, offset )
	-- if stacking relative to the world, apply the magic offset fix to the correct direction
	if ( stackMode == MODE_WORLD ) then
		local direction = DirectionFunctions[ stackMode ][ stackDir ]()
			  direction = direction * MAGIC_OFFSET
		return offset + direction
	-- if stacking relative to the prop, apply the magic offset only to the forward (x) component of the vector
	elseif ( stackMode == MODE_PROP ) then
		local trueOffset = Vector()
		      trueOffset:Set( offset )
			  trueOffset.x = trueOffset.x + MAGIC_OFFSET
		return OffsetFunctions[ stackDir ]( angle, trueOffset )
	end
end

--[[--------------------------------------------------------------------------
-- 	RotateAngle( angle, angle )
--
--	Rotates the first angle by the second angle. This ensures proper rotation
--	along all three axes and prevents various problems related to simply adding
--	two angles together. The first angle is modified directly by refence, so this does not
--	return anything.
--]]--
function RotateAngle( stackMode, stackDir, angle, rotation )
	local axisPitch, axisYaw, axisRoll = RotationFunctions[ stackDir ]( angle )

	angle:RotateAroundAxis( axisPitch,  rotation.p )
	angle:RotateAroundAxis( axisYaw,   -rotation.y )
	angle:RotateAroundAxis( axisRoll,   rotation.r )
end
--addons/ballistic_shields/lua/weapons/heavy_shield_st/shared.lua:
SWEP.Base = "heavy_shield"
SWEP.PrintName = "Schweres Schild (ST)"
SWEP.Category = "SW:RP Shields"

SWEP.Author	= "GangsterDom, Deltaa"
SWEP.Instructions = "LMB - Angreifen | RMB - Sichtbarkeit ein- und ausschalten"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.ViewModel = ""
SWEP.WorldModel = "models/bshields/egm_schild.mdl"

SWEP.WElements = {
	["placeholder"] = { type = "Model", model = "models/bshields/egm_schild_hit.mdl", skin = 1, bodygroup = {} }
}

SWEP.shieldEnt = "bs_hshield_st"
--lua/weapons/reciprocating_quad_blaster/shared.lua:
if ( SERVER ) then

	AddCSLuaFile( "shared.lua" )

end

if ( CLIENT ) then

	SWEP.PrintName			= "Reciprocating Quad Blaster"	

	SWEP.Author				= "Sim"

    SWEP.Instructions       = "Primary Attack: Fire, Secondary Attack: ADS, Safety: Reload over time"

	SWEP.ViewModelFOV      	= 70

	SWEP.Slot				= 3

	SWEP.SlotPos			= 2

	--SWEP.WepSelectIcon = surface.GetTextureID("HUD/killicons/DC15A")

	--killicon.Add( "weapon_752_dc15a", "HUD/killicons/DC15A", Color( 255, 80, 0, 255 ) )

end

SWEP.HoldType				= "duel"

SWEP.Base					= "tfa_swsft_base_servius"

SWEP.Category = "[TW] Heavy Weapons"

SWEP.Spawnable				= true

SWEP.AdminSpawnable			= false

SWEP.ViewModelFOV = 56

SWEP.ViewModelFlip = false

SWEP.ViewModel = "models/twcustom/weapons/v_reciprocating_quad_blaster.mdl"

SWEP.WorldModel = "models/twcustom/weapons/w_reciprocating_quad_blaster.mdl"

SWEP.ShowViewModel = true

SWEP.ShowWorldModel = true

SWEP.UseHands = false

--[[SWEP.ViewModelBoneMods = {

	["ValveBiped.Bip01_L_Clavicle"] = { scale = Vector(1, 1, 1), pos = Vector(0.736, 5.183, 1.149), angle = Angle(-1.825, 2.803, -0.527) },

	["v_weapon.awm_parent"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) }

}]]

SWEP.Primary.Sound = Sound ("weapons/dc15a/DC15A_fire.ogg");

SWEP.Primary.ReloadSound = Sound ("weapons/shared/standard_reload.ogg");

SWEP.Weight					= 5

SWEP.AutoSwitchTo			= false

SWEP.AutoSwitchFrom			= false

SWEP.Primary.Recoil			= 0.5

SWEP.Primary.Damage			= 50

SWEP.Primary.NumShots		= 1

-- Selective Fire Stuff

SWEP.SelectiveFire		= true --Allow selecting your firemode?

SWEP.DisableBurstFire	= false --Only auto/single?

SWEP.OnlyBurstFire		= false --No auto, only burst/single?

SWEP.DefaultFireMode 	= "Safe" --Default to auto or whatev

SWEP.FireModes = {

"Auto"

}

SWEP.FireModeName = nil --Change to a text value to override it

SWEP.Primary.Spread			= 0.0125

SWEP.Primary.IronAccuracy = .005	-- Ironsight accuracy, should be the same for shotguns

SWEP.Primary.SpreadMultiplierMax = 2 --How far the spread can expand when you shoot.

--Range Related

SWEP.Primary.Range = -1 -- The distance the bullet can travel in source units.  Set to -1 to autodetect based on damage/rpm.

SWEP.Primary.RangeFalloff = -1 -- The percentage of the range the bullet damage starts to fall off at.  Set to 0.8, for example, to start falling off after 80% of the range.

--Penetration Related

SWEP.MaxPenetrationCounter=1 --The maximum number of ricochets.  To prevent stack overflows.

SWEP.Primary.ClipSize		= 400

SWEP.Primary.RPM = 600

SWEP.Primary.DefaultClip	= 400*3

SWEP.Primary.Automatic		= true

SWEP.Primary.Ammo			= "ar2"

SWEP.TracerName = "effect_sw_laser_blue"

SWEP.Secondary.Automatic	= false

SWEP.Secondary.Ammo			= "none"

SWEP.Secondary.IronFOV = 70

SWEP.BlowbackEnabled                 = true
SWEP.BlowbackVector                 = Vector(0,-1,0)
SWEP.BlowbackCurrentRoot            = 0
SWEP.BlowbackCurrent                 = 0
SWEP.BlowbackBoneMods                 = nil
SWEP.Blowback_Only_Iron             = false
SWEP.Blowback_PistolMode             = false
SWEP.Blowback_Shell_Enabled         = false
SWEP.Blowback_Shell_Effect             = "None"

SWEP.DoProceduralReload = true

SWEP.ProceduralReloadTime = 2.5

SWEP.VMPos = Vector(0, 11, -5)
SWEP.VMAng = Vector(0, 0, 0)
SWEP.VMPos_Additive = false
SWEP.Sights_Mode = TFA.Enum.LOCOMOTION_HYBRID
SWEP.Idle_Mode = TFA.Enum.IDLE_BOTH
SWEP.Sprint_Mode = TFA.Enum.LOCOMOTION_ANI
SWEP.IronSightsPos = Vector(0.03, 11, -1.85)
SWEP.IronSightsAng = Vector(0.209, -0.138, 0)
SWEP.RunSightsPos = Vector(0, 11, -5)
SWEP.RunSightsAng = Vector(0, 0, 0)
SWEP.InspectPos = Vector(0, 20, -20)
SWEP.InspectAng = Vector(30, 0, 0)

SWEP.MoveSpeed                         = 0.8
SWEP.IronSightsMoveSpeed               = 0.7

SWEP.VElements = {

	["txt_ammo"] = { type = "Quad", bone = "main_gun", pos = Vector(1.8, -1, 8), angle = Angle(0, 0, 90), size = 0.0175, draw_func = nil, active = true},

}

SWEP.TopBarrel = true
SWEP.AnimTime = CurTime()

if CLIENT then
    function SWEP:PlaceHandsOnGun()
        local leftElbow = self:GetOwner():LookupBone("ValveBiped.Bip01_L_Forearm")
        self:GetOwner():ManipulateBoneAngles(leftElbow, Angle(20, -20, 0))

        local rightShoulder = self:GetOwner():LookupBone("ValveBiped.Bip01_R_UpperArm")
        self:GetOwner():ManipulateBoneAngles(rightShoulder, Angle(0, 15, 0))

        local rightElbow = self:GetOwner():LookupBone("ValveBiped.Bip01_R_Forearm")
        self:GetOwner():ManipulateBoneAngles(rightElbow, Angle(-30, -40, 0))
    end

    function SWEP:ResetBoneAngles()
        local leftElbow = self:GetOwner():LookupBone("ValveBiped.Bip01_L_Forearm")
        self:GetOwner():ManipulateBoneAngles(leftElbow, Angle(0, 0, 0))

        local rightShoulder = self:GetOwner():LookupBone("ValveBiped.Bip01_R_UpperArm")
        self:GetOwner():ManipulateBoneAngles(rightShoulder, Angle(0, 0, 0))

        local rightElbow = self:GetOwner():LookupBone("ValveBiped.Bip01_R_Forearm")
        self:GetOwner():ManipulateBoneAngles(rightElbow, Angle(0, 0, 0))
    end
end

function SWEP:Holster()
    if CLIENT then
        self:ResetBoneAngles()
    end
    return true
end

function SWEP:Deploy()
    if self:IsSafety() then
        self:GetOwner():GetViewModel():SendViewModelMatchingSequence(0)
    end
end

function SWEP:GetShootPos()
    if self.TopBarrel then
        self.TopBarrel = false
        return self:GetBonePosition(self:LookupBone("barrel_top_right")), self:GetBonePosition(self:LookupBone("barrel_top_left"))
    else
        self.TopBarrel = true
        return self:GetBonePosition(self:LookupBone("barrel_bottom_right")), self:GetBonePosition(self:LookupBone("barrel_bottom_left"))
    end
end

function SWEP:GetFireModeName()
	local fm = self:GetFireMode()
	local fmn = string.lower( self:GetStat("FireModes")[fm] )
	if fmn == "safe" or fmn == "holster" then return "Safety" end
	if self:GetStat("FireModeName") then return self:GetStat("FireModeName") end
	if fmn == "auto" or fmn == "automatic" then return "Full-Auto" end

	if fmn == "semi" or fmn == "single" then
		if self:GetStat("Revolver") then
			if (self:GetStat("BoltAction")) then
				return "Single-Action"
			else
				return "Double-Action"
			end
		else
			if (self:GetStat("BoltAction")) then
				return "Bolt-Action"
			else
				if (self.Shotgun and self:GetStat("Primary.RPM") < 250) then
					return "Pump-Action"
				else
					return "Semi-Auto"
				end
			end
		end
	end

	local bpos = string.find(fmn, "burst")
	if bpos then return string.sub(fmn, 1, bpos - 1) .. " Round Burst" end
	return ""
end

function SWEP:Anims() end

function SWEP:ReloadTicker()end

function SWEP:Reload()
    return
end

function SWEP:DrawWorldModel()
    if IsValid(self.Owner) then 
        self:SetPoseParameter("head_pitch", self.Owner:EyeAngles()[1])
        self:InvalidateBoneCache()
    end
    self:DrawModel()
end

function SWEP:Think()
    self.Anims()

    self.ReloadTicker()
    if CLIENT then
        if self:IronSights() then
            if self:Clip1() > self:GetMaxClip1()/2 then
                self.VElements["txt_ammo"].draw_func = function( weapon )
                    draw.SimpleText(""..weapon:Clip1().."/"..self.Primary.ClipSize, "Trebuchet18", 0, 0, Color(0, 90, 150, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)
                end
            end
            if self:Clip1() <= self:GetMaxClip1()/4 then
                self.VElements["txt_ammo"].draw_func = function( weapon )
                    draw.SimpleText(""..weapon:Clip1().."/"..self.Primary.ClipSize, "Trebuchet18", 0, 0, Color(0, 90, 255, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)
                end
            end
            if self:Clip1() <= self:GetMaxClip1()/20 then
                self.VElements["txt_ammo"].draw_func = function( weapon )
                    draw.SimpleText("0"..weapon:Clip1().."/"..self.Primary.ClipSize, "Trebuchet18", 0, 0, Color(191, 179, 0, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)
                end
            end
            if self:Clip1() == 0 then
                self.VElements["txt_ammo"].draw_func = function( weapon )
                    draw.SimpleText("000/"..self.Primary.ClipSize, "Trebuchet18", 0, 0, Color(255, 90, 0, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)
                end
            end
        else
            self.VElements["txt_ammo"].draw_func = function( weapon )
                draw.SimpleText("", "Trebuchet18", 0, 0, Color(255, 90, 0, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)
            end
        end
    end

    if SERVER then

        if self:GetOwner():KeyDown(IN_ATTACK) and not self:IsSafety() and CurTime() > self.AnimTime and self:Clip1() > 0 then
            self:SetSequence(5)
        end
        if self:GetOwner():KeyReleased(IN_ATTACK) and not self:IsSafety() and CurTime() > self.AnimTime or (self:Clip1() == 0 and not self:IsSafety())then
            self:SetSequence(1)
        end
        if self:GetSequence() == 5 then
            self:SetCycle( math.min(self:GetCycle() + 5*FrameTime(), 1))
        else
            self:SetCycle( math.min(self:GetCycle() + 0.5*FrameTime(), 1))
        end
        if self:GetCycle() >= 1 then
            if tonumber(self:GetSequence()) == 5 then
                self:SetCycle( 0 )
            end
        end
    end
end

function SWEP:CycleSafety()
    if not IsFirstTimePredicted() and !game.SinglePlayer() then return end
	local fm = self:GetFireMode()
	local fmt = self:GetStat("FireModes")
	if fm ~= #fmt then 
		self.LastFireMode = fm
		self:SetFireMode(#fmt)
	else
		self:SetFireMode(self.LastFireMode or 1)
	end
	self:EmitSound("Weapon_AR2.Empty")
	self.BurstCount = 0

    local vm = self:GetOwner():GetViewModel()

    if self:GetFireModeName() == "Safety" then
        if CLIENT then
            self:ResetBoneAngles()
        end
        self:SetHoldType("normal")
        self:SetSequence(3)
        self:SetCycle(0)
        vm:SendViewModelMatchingSequence(3)
        self.Anims = function()
            if CurTime() > self.AnimTime then
            self:SetSequence(0)
            vm:SendViewModelMatchingSequence(0)
            self.Anims = function()end
            end
        end
        self.ReloadWaitTime = CurTime()
        self.ReloadTicker = function()
            if self:IsSafety() then
                if CurTime() > self.ReloadWaitTime then
                    if self:Clip1() < self:GetMaxClip1() and self:GetOwner():GetAmmoCount(self:GetPrimaryAmmoType()) > 0 then
                        local ammo = math.Clamp(50, 0, self:GetOwner():GetAmmoCount(self:GetPrimaryAmmoType()))
                        ammo = math.min(ammo, self:GetMaxClip1()-self:Clip1())
                        self:SetClip1(math.Clamp(self:Clip1() + ammo, 0, self:GetMaxClip1()))
                        self:GetOwner():RemoveAmmo( ammo, self:GetPrimaryAmmoType() )
                        if self:Clip1() == self:GetMaxClip1() then
                            self.ReloadTicker = function()end
                        else
                            self.ReloadWaitTime = CurTime() + 0.5
                        end
                    end
                end
            else
                self.ReloadTicker = function()end
            end
        end
    else
        self.HoldType = "normal"
        self:SetSequence(2)
        self:SetCycle(0)
        vm:SendViewModelMatchingSequence(2)
        self.Anims = function()
            if CurTime() > self.AnimTime then
                self:SetSequence(1)
                self.HoldType = "duel"
                if CLIENT then
                    self:PlaceHandsOnGun()
                end
                vm:SendViewModelMatchingSequence(1)
                self.Anims = function()end
            end
        end
    end
    self.AnimTime = CurTime() + 1.5
    self:SetNextPrimaryFire(self.AnimTime)
    self:SetNextSecondaryFire(self.AnimTime)
end

local cv_forcemult = GetConVar("sv_tfa_force_multiplier")

function SWEP:ShootBullet(damage, recoil, num_bullets, aimcone, disablericochet, bulletoverride)
	if not IsFirstTimePredicted() and not game.SinglePlayer() then return end
	num_bullets = 1
	aimcone = aimcone or 0

    TracerName = self.TracerName

    local rightBarrel, leftBarrel = self:GetShootPos()

    self.MainBullet.Attacker = self:GetOwner()
    self.MainBullet.Inflictor = self
    self.MainBullet.Num = num_bullets
    self.MainBullet.Src = self:GetOwner():EyePos()
    self.MainBullet.Dir = self:GetOwner():GetAimVector()
    self.MainBullet.HullSize = self:GetStat("Primary.HullSize") or 0
    self.MainBullet.Spread.x = aimcone
    self.MainBullet.Spread.y = aimcone
    self.MainBullet.Tracer = self.TracerCount and self.TracerCount or 3
    self.MainBullet.TracerName = "nil"
    self.MainBullet.PenetrationCount = 0
    self.MainBullet.AmmoType = self:GetPrimaryAmmoType()
    self.MainBullet.Force = damage / 6 * math.sqrt(self:GetStat("Primary.KickUp") + self:GetStat("Primary.KickDown") + self:GetStat("Primary.KickHorizontal")) * cv_forcemult:GetFloat() * self:GetAmmoForceMultiplier()
    self.MainBullet.Damage = damage
    self.MainBullet.HasAppliedRange = false

    self:GetOwner():FireBullets(self.MainBullet)

    local data = EffectData()
    data:SetEntity(self)
    data:SetStart(rightBarrel)
    data:SetOrigin(self:GetOwner():GetEyeTrace().HitPos)
    util.Effect(TracerName, data)

    data = nil

    data = EffectData()
    data:SetEntity(self)
    data:SetStart(leftBarrel)
    data:SetOrigin(self:GetOwner():GetEyeTrace().HitPos)
    util.Effect(TracerName, data)

    data = nil
end

function SWEP:CanPrimaryAttack( )
	if self.Owner:IsNPC() then
		if SERVER then
			if CurTime() < self:GetNextPrimaryFire() then
				return false
			end
			return true
		end
	end
	stat = self:GetStatus()
	if not TFA.Enum.ReadyStatus[stat] and stat ~= TFA.Enum.STATUS_SHOOTING then
		if self.Shotgun and TFA.Enum.ReloadStatus[stat] then
			self:SetShotgunCancel( true )
		end
		return false
	end

	if self:IsSafety() then
		self:EmitSound("Weapon_AR2.Empty2")
		self.LastSafetyShoot = self.LastSafetyShoot or 0

		if CurTime() < self.LastSafetyShoot + 0.2 then
			self:CycleSafety()
			self:SetNextPrimaryFire(CurTime() + 1.5)
		end

		self.LastSafetyShoot = CurTime()

		return
	end

	if self:GetStat("Primary.ClipSize") <= 0 and self:Ammo1() < self:GetStat("Primary.AmmoConsumption") then
		return false
	end
	if self:GetSprinting() and not self.AllowSprintAttack then
		return false
	end
	if self:GetPrimaryClipSize(true) > 0 and self:Clip1() < self:GetStat("Primary.AmmoConsumption") then
		if self:GetOwner():KeyPressed(IN_ATTACK) then
			self:ChooseDryFireAnim()
		end
		if not self.HasPlayedEmptyClick then
			self:EmitSound("Weapon_Pistol.Empty2")

			self.HasPlayedEmptyClick = true
		end
		return false
	end
	if self.FiresUnderwater == false and self:GetOwner():WaterLevel() >= 3 then
		self:SetNextPrimaryFire(CurTime() + 0.5)
		self:EmitSound("Weapon_AR2.Empty")
		return false
	end

	self.HasPlayedEmptyClick = false

	if CurTime() < self:GetNextPrimaryFire() then return false end

	return true
end
--addons/ballistic_shields/lua/bs_config.lua:
include( "ballistic_shields/sh_bs_util.lua" )

--------------------- BALLISTIC SHIELDS V1.1.4 -------------------------

---- CONFIG ----
-- AVALAIBLE LANGUAGES - English
bshields.config.language = "German"
-- DISABLE HUD
bshields.config.disablehud = false
-- MINIMUM RIOT SHIELD DAMAGE
bshields.config.rshielddmgmin = 16
-- MAXIMUM RIOT SHIELD DAMAGE
bshields.config.rshielddmgmax = 25
-- HEAVY SHIELD EXPLOSION DAMAGE REDUCITON (IN %)
bshields.config.hshieldexpl = 25
-- HEAVY SHIELD MELEE DAMAGE REDUCTION (IN %)
bshields.config.hshieldmelee = 0
-- RIOT SHIELD MELEE DAMAGE REDUCTION (IN %)
bshields.config.rshieldmelee = 60
-- HEAVY SHIELD BREACH COOLDOWN (IN SECONDS)
bshields.config.hshieldcd = 20
-- DOOR RESPAWN TIMER (IN SECONDS)
bshields.config.doorrespawn = 60
-- MAXIMUM AMOUNT OF DEPLOYED SHIELDS
bshields.config.maxshields = 3
-- SHOULD FADING DOORS BE BREACHABLE?
bshields.config.breachfdoors = false
-- ALLOW BREACHING UNOWNED DOORS
bshields.config.breachudoors = false

-------- CUSTOM TEXTURES, LEAVE "" FOR DEFAULT "POLICE" TEXT. ----------
--- FOR EDITING USE THE 256x256 TEMPLATE INCLUDED IN THE MAIN FOLDER ---

-- HEAVY SHIELD
bshields.config.hShieldTexture = "https://i.imgur.com/afyGHiK.png"
-- RIOT SHIELD
bshields.config.rShieldTexture = "https://i.imgur.com/afyGHiK.png"
-- DEPLOYABLE SHIELD
bshields.config.dShieldTexture = "https://i.imgur.com/afyGHiK.png" 
-- PLAYERS MIGHT HAVE TO RECONNECT IN ORDER TO SEE THE NEW TEXTURES! ---

-- [CW2 ONLY] YOU NEED THIS ADDON: https://steamcommunity.com/sharedfiles/filedetails/?id=1771994451
-- SHOULD RIOT SHIELD BE BULLETPROOF? --
bshields.config.rshieldbp = true
--addons/mobile_ammunition/lua/weapons/rw_ammo_distributor.lua:
SWEP.Gun							= ("gun_base")
if (GetConVar(SWEP.Gun.."_allowed")) != nil then
	if not (GetConVar(SWEP.Gun.."_allowed"):GetBool()) then SWEP.Base = "tfa_blacklisted" SWEP.PrintName = SWEP.Gun return end
end

SWEP.Base							= "tfa_gun_base"
SWEP.Category						= "SW:RP (Sonstiges)"
SWEP.Manufacturer 					= ""
SWEP.Author							= "Summe"


SWEP.PrintName						= "Versorgungskit - Blaster"
SWEP.Type							= "This is a WIP swep, so you can throw 5 (default) crate of 750 (default) ammo and the swep will be deleted"
SWEP.Slot							= 3
SWEP.SlotPos						= 0

SWEP.VElements = {
	["carte"] = {
		type = "Model",
		model = "models/cs574/objects/ammo_box.mdl",
		bone = "v_scoutblaster_reference001",
		rel = "",
		pos = Vector(0, 0, -15),
		angle = Angle(0, 90, 0),
		size = Vector(1, 1, 1),
		color = Color(255, 255, 255, 255),
		surpresslightning = false,
		material = "",
		skin = 0,
		bodygroup = {}
	},
}

SWEP.WElements = {
	["carte"] = {
		type = "Model",
		model = "models/cs574/objects/ammo_box.mdl",
		bone = "ValveBiped.Bip01_R_Hand",
		rel = "",
		pos = Vector(-02, 10.5, -12),
		angle = Angle(0, -05, 06),
		size = Vector(1.15, 1.15, 1.15),
		color = Color(255, 255, 255, 255),
		surpresslightning = false,
		material = "",
		skin = 0,
		bodygroup = {} }
}

SWEP.HolsterOffset = Vector(5, -12, 7)
SWEP.HolsterAngle = Angle(-90, -90, 0)

function SWEP:Think()
	if (self:Clip1() <= 0) then
		if IsValid(self) and self:OwnerIsValid() and SERVER then
			self:GetOwner():StripWeapon(self:GetClass())
		end
	end
end

SWEP.DrawAmmo						= true
SWEP.data 							= {}
SWEP.data.ironsights				= 0
SWEP.Secondary.IronFOV				= 75
SWEP.FiresUnderwater 				= true
SWEP.Contact						= ""
SWEP.Spawnable						= true
SWEP.AdminSpawnable					= true
SWEP.DrawCrosshair					= false
SWEP.DrawCrosshairIS 				= false
SWEP.IronInSound 					= nil
SWEP.IronOutSound 					= nil
SWEP.CanBeSilenced					= false
SWEP.Silenced 						= false
SWEP.DoMuzzleFlash 					= false
SWEP.SelectiveFire					= false
SWEP.DisableBurstFire				= false
SWEP.OnlyBurstFire					= false
SWEP.DefaultFireMode 				= nil
SWEP.FireModeName 					= nil
SWEP.DisableChambering 				= true

SWEP.Primary.ClipSize				= GetConVar("rw_sw_dispencer_ammo_crate_number"):GetInt()
SWEP.Primary.DefaultClip			= GetConVar("rw_sw_dispencer_ammo_crate_number"):GetInt()
SWEP.Primary.RPM					= 200
SWEP.Primary.RPM_Burst				= 0
SWEP.Primary.Ammo					= "crate"
SWEP.Primary.AmmoConsumption 		= 1
SWEP.Primary.Range 					= 0
SWEP.Primary.RangeFalloff 			= 0
SWEP.Primary.NumShots				= 1
SWEP.Primary.Automatic				= false
SWEP.Primary.RPM_Semi				= 0
SWEP.Primary.BurstDelay				= 0
SWEP.Primary.Sound 					= nil
SWEP.Primary.ReloadSound 			= nil
SWEP.Primary.PenetrationMultiplier 	= 0
SWEP.Primary.Damage					= 0
SWEP.Primary.HullSize 				= 0
SWEP.DamageType 					= 0

SWEP.DoMuzzleFlash 					= false

SWEP.FireModes = {
	"none"
}

SWEP.IronRecoilMultiplier			= 0
SWEP.CrouchRecoilMultiplier			= 0
SWEP.JumpRecoilMultiplier			= 0
SWEP.WallRecoilMultiplier			= 0
SWEP.ChangeStateRecoilMultiplier	= 0
SWEP.CrouchAccuracyMultiplier		= 0
SWEP.ChangeStateAccuracyMultiplier	= 0
SWEP.JumpAccuracyMultiplier			= 0
SWEP.WalkAccuracyMultiplier			= 0
SWEP.NearWallTime 					= 0.25
SWEP.ToCrouchTime 					= 0.1
SWEP.WeaponLength 					= 35
SWEP.SprintFOVOffset 				= 12
SWEP.ProjectileVelocity 			= 300

SWEP.ProjectileEntity 				= "ammo_chargepack"
SWEP.ProjectileModel 				= nil

SWEP.ViewModel						= "models/bf2017/c_scoutblaster.mdl"
SWEP.WorldModel						= "models/bf2017/w_scoutblaster.mdl"
SWEP.ViewModelFOV					= 75
SWEP.ViewModelFlip					= false
SWEP.MaterialTable 					= nil
SWEP.UseHands 						= false
SWEP.HoldType 						= "duel"

SWEP.ShowWorldModel = false

SWEP.BlowbackEnabled 				= true
SWEP.BlowbackVector 				= Vector(0,0,0)
SWEP.BlowbackCurrentRoot			= 0
SWEP.BlowbackCurrent 				= 0
SWEP.BlowbackBoneMods 				= nil
SWEP.Blowback_Only_Iron 			= false
SWEP.Blowback_PistolMode 			= false
SWEP.Blowback_Shell_Enabled 		= false
SWEP.Blowback_Shell_Effect 			= "None"

SWEP.Tracer							= 0
SWEP.TracerName 					= nil
SWEP.TracerCount 					= 1
SWEP.TracerLua 						= false
SWEP.TracerDelay					= 0.01
SWEP.ImpactEffect 					= nil
SWEP.ImpactDecal 					= nil

SWEP.VMPos = Vector(-05, -10, -4)
SWEP.VMAng = Vector(0,0,0)

SWEP.IronSightTime 					= 0.5
SWEP.Primary.KickUp					= 0
SWEP.Primary.KickDown				= 0
SWEP.Primary.KickHorizontal			= 0
SWEP.Primary.StaticRecoilFactor 	= 0
SWEP.Primary.Spread					= 0
SWEP.Primary.IronAccuracy 			= 0
SWEP.Primary.SpreadMultiplierMax 	= 0
SWEP.Primary.SpreadIncrement 		= 0
SWEP.Primary.SpreadRecovery 		= 0
SWEP.DisableChambering 				= true
SWEP.MoveSpeed 						= 0.7
SWEP.RunSpeed						= 0.9
SWEP.IronSightsMoveSpeed 			= 0.7

SWEP.IronSightsPos = Vector(0, 0, 0)
SWEP.IronSightsAng = Vector(0, 0, 0)
SWEP.RunSightsPos = Vector(0, 0, 0)
SWEP.RunSightsAng = Vector(0, 0, 0)
SWEP.InspectPos = Vector(0, 0, 0)
SWEP.InspectAng = Vector(0, 0, 0)

SWEP.ViewModelBoneMods = {
	["v_scoutblaster_reference001"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, -0.3, 0), angle = Angle(0, 0, 0) }
}

SWEP.ThirdPersonReloadDisable		= false
SWEP.Primary.DamageType 			= DMG_BULLET
SWEP.DamageType 					= DMG_BULLET
SWEP.RTScopeAttachment				= -1
SWEP.Scoped_3D 						= false
SWEP.ScopeReticule 					= ""
SWEP.Secondary.ScopeZoom 			= 0
SWEP.ScopeReticule_Scale 			= {1,1}
if surface then
	SWEP.Secondary.ScopeTable = nil --[[
		{
			scopetex = surface.GetTextureID("scope/gdcw_closedsight"),
			reticletex = surface.GetTextureID("scope/gdcw_acogchevron"),
			dottex = surface.GetTextureID("scope/gdcw_acogcross")
		}
	]]--
end
DEFINE_BASECLASS( SWEP.Base )
--addons/mobile_ammunition/lua/weapons/rw_ammo_distributor_grenades.lua:
SWEP.Gun							= ("gun_base")
if (GetConVar(SWEP.Gun.."_allowed")) != nil then
	if not (GetConVar(SWEP.Gun.."_allowed"):GetBool()) then SWEP.Base = "tfa_blacklisted" SWEP.PrintName = SWEP.Gun return end
end

SWEP.Base							= "tfa_gun_base"
SWEP.Category						= "SW:RP (Sonstiges)"
SWEP.Manufacturer 					= ""
SWEP.Author							= "Summe"


SWEP.PrintName						= "Versorgungskit - Grenades"
SWEP.Type							= "This is a WIP swep, so you can throw 5 (default) crate of 750 (default) ammo and the swep will be deleted"
SWEP.Slot							= 3
SWEP.SlotPos						= 0

SWEP.VElements = {
	["carte"] = {
		type = "Model",
		model = "models/kingpommes/starwars/misc/imp_crate_single_closed.mdl",
		bone = "v_scoutblaster_reference001",
		rel = "",
		pos = Vector(0, 0, -15),
		angle = Angle(0, 90, 0),
		size = Vector(1, 1, 1),
		color = Color(255, 255, 255, 255),
		surpresslightning = false,
		material = "",
		skin = 0,
		bodygroup = {}
	},
}

SWEP.WElements = {
	["carte"] = {
		type = "Model",
		model = "models/kingpommes/starwars/misc/imp_crate_single_closed.mdl",
		bone = "ValveBiped.Bip01_R_Hand",
		rel = "",
		pos = Vector(-02, 10.5, -06),
		angle = Angle(180, -05, -4),
		size = Vector(0.6, 0.6, 0.6),
		color = Color(255, 255, 255, 255),
		surpresslightning = false,
		material = "",
		skin = 0,
		bodygroup = {} }
}

SWEP.HolsterOffset = Vector(8, 0, 10)
SWEP.HolsterAngle = Angle(0, 0, 0)

function SWEP:Think()
	if (self:Clip1() <= 0) then
		if IsValid(self) and self:OwnerIsValid() and SERVER then
			self:GetOwner():StripWeapon(self:GetClass())
		end
	end
end

SWEP.DrawAmmo						= true
SWEP.data 							= {}
SWEP.data.ironsights				= 0
SWEP.Secondary.IronFOV				= 75
SWEP.FiresUnderwater 				= true
SWEP.Contact						= ""
SWEP.Spawnable						= true
SWEP.AdminSpawnable					= true
SWEP.DrawCrosshair					= false
SWEP.DrawCrosshairIS 				= false
SWEP.IronInSound 					= nil
SWEP.IronOutSound 					= nil
SWEP.CanBeSilenced					= false
SWEP.Silenced 						= false
SWEP.DoMuzzleFlash 					= false
SWEP.SelectiveFire					= false
SWEP.DisableBurstFire				= false
SWEP.OnlyBurstFire					= false
SWEP.DefaultFireMode 				= nil
SWEP.FireModeName 					= nil
SWEP.DisableChambering 				= true

SWEP.Primary.ClipSize				= GetConVar("rw_sw_dispencer_ammo_crate_number"):GetInt()
SWEP.Primary.DefaultClip			= GetConVar("rw_sw_dispencer_ammo_crate_number"):GetInt()
SWEP.Primary.RPM					= 200
SWEP.Primary.RPM_Burst				= 0
SWEP.Primary.Ammo					= "crate"
SWEP.Primary.AmmoConsumption 		= 1
SWEP.Primary.Range 					= 0
SWEP.Primary.RangeFalloff 			= 0
SWEP.Primary.NumShots				= 1
SWEP.Primary.Automatic				= false
SWEP.Primary.RPM_Semi				= 0
SWEP.Primary.BurstDelay				= 0
SWEP.Primary.Sound 					= nil
SWEP.Primary.ReloadSound 			= nil
SWEP.Primary.PenetrationMultiplier 	= 0
SWEP.Primary.Damage					= 0
SWEP.Primary.HullSize 				= 0
SWEP.DamageType 					= 0

SWEP.DoMuzzleFlash 					= false

SWEP.FireModes = {
	"none"
}

SWEP.IronRecoilMultiplier			= 0
SWEP.CrouchRecoilMultiplier			= 0
SWEP.JumpRecoilMultiplier			= 0
SWEP.WallRecoilMultiplier			= 0
SWEP.ChangeStateRecoilMultiplier	= 0
SWEP.CrouchAccuracyMultiplier		= 0
SWEP.ChangeStateAccuracyMultiplier	= 0
SWEP.JumpAccuracyMultiplier			= 0
SWEP.WalkAccuracyMultiplier			= 0
SWEP.NearWallTime 					= 0.25
SWEP.ToCrouchTime 					= 0.1
SWEP.WeaponLength 					= 35
SWEP.SprintFOVOffset 				= 12
SWEP.ProjectileVelocity 			= 300

SWEP.ProjectileEntity 				= "ammo_chargepack_grenades"
SWEP.ProjectileModel 				= nil

SWEP.ViewModel						= "models/bf2017/c_scoutblaster.mdl"
SWEP.WorldModel						= "models/bf2017/w_scoutblaster.mdl"
SWEP.ViewModelFOV					= 75
SWEP.ViewModelFlip					= false
SWEP.MaterialTable 					= nil
SWEP.UseHands 						= false
SWEP.HoldType 						= "duel"

SWEP.ShowWorldModel = false

SWEP.BlowbackEnabled 				= true
SWEP.BlowbackVector 				= Vector(0,0,0)
SWEP.BlowbackCurrentRoot			= 0
SWEP.BlowbackCurrent 				= 0
SWEP.BlowbackBoneMods 				= nil
SWEP.Blowback_Only_Iron 			= false
SWEP.Blowback_PistolMode 			= false
SWEP.Blowback_Shell_Enabled 		= false
SWEP.Blowback_Shell_Effect 			= "None"

SWEP.Tracer							= 0
SWEP.TracerName 					= nil
SWEP.TracerCount 					= 1
SWEP.TracerLua 						= false
SWEP.TracerDelay					= 0.01
SWEP.ImpactEffect 					= nil
SWEP.ImpactDecal 					= nil

SWEP.VMPos = Vector(-05, -10, -4)
SWEP.VMAng = Vector(0,0,0)

SWEP.IronSightTime 					= 0.5
SWEP.Primary.KickUp					= 0
SWEP.Primary.KickDown				= 0
SWEP.Primary.KickHorizontal			= 0
SWEP.Primary.StaticRecoilFactor 	= 0
SWEP.Primary.Spread					= 0
SWEP.Primary.IronAccuracy 			= 0
SWEP.Primary.SpreadMultiplierMax 	= 0
SWEP.Primary.SpreadIncrement 		= 0
SWEP.Primary.SpreadRecovery 		= 0
SWEP.DisableChambering 				= true
SWEP.MoveSpeed 						= 0.7
SWEP.RunSpeed						= 0.9
SWEP.IronSightsMoveSpeed 			= 0.7

SWEP.IronSightsPos = Vector(0, 0, 0)
SWEP.IronSightsAng = Vector(0, 0, 0)
SWEP.RunSightsPos = Vector(0, 0, 0)
SWEP.RunSightsAng = Vector(0, 0, 0)
SWEP.InspectPos = Vector(0, 0, 0)
SWEP.InspectAng = Vector(0, 0, 0)

SWEP.ViewModelBoneMods = {
	["v_scoutblaster_reference001"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, -0.3, 0), angle = Angle(0, 0, 0) }
}

SWEP.ThirdPersonReloadDisable		= false
SWEP.Primary.DamageType 			= DMG_BULLET
SWEP.DamageType 					= DMG_BULLET
SWEP.RTScopeAttachment				= -1
SWEP.Scoped_3D 						= false
SWEP.ScopeReticule 					= ""
SWEP.Secondary.ScopeZoom 			= 0
SWEP.ScopeReticule_Scale 			= {1,1}
if surface then
	SWEP.Secondary.ScopeTable = nil --[[
		{
			scopetex = surface.GetTextureID("scope/gdcw_closedsight"),
			reticletex = surface.GetTextureID("scope/gdcw_acogchevron"),
			dottex = surface.GetTextureID("scope/gdcw_acogcross")
		}
	]]--
end
DEFINE_BASECLASS( SWEP.Base )
--addons/egm_tfa_grenades/lua/weapons/rw_sw_nade_emp.lua:
SWEP.Base						= "tfa_ins2_nade_base"
SWEP.Category					= "SW:RP (Granaten)"
SWEP.Author						= "Rezurektion & ChanceSphere574"
SWEP.Type						= "Explode and stun"
SWEP.PrintName					= "EMP Grenade"
SWEP.Slot						= 3
SWEP.SlotPos					= 100
SWEP.DrawAmmo					= true
SWEP.DrawWeaponInfoBox			= false
SWEP.BounceWeaponIcon   		= false
SWEP.DrawCrosshair				= false
SWEP.Weight						= 2
SWEP.AutoSwitchTo				= true
SWEP.AutoSwitchFrom				= true
SWEP.HoldType 					= "grenade"

SWEP.ViewModelFOV				= 70
SWEP.ViewModelFlip				= false
SWEP.ViewModel					= "models/weapons/tfa_ins2/v_f1.mdl"
SWEP.WorldModel					= "models/weapons/tfa_ins2/w_f1.mdl"
SWEP.ShowWorldModel				= false
SWEP.Spawnable					= true
SWEP.UseHands                   = true
SWEP.AdminSpawnable				= true

SWEP.Primary.Damage             = 10
SWEP.Primary.RPM				= 10
SWEP.Primary.ClipSize			= 1
SWEP.Primary.DefaultClip		= 1
SWEP.Primary.Automatic			= false
SWEP.DisableChambering 			= true
SWEP.Primary.Ammo				= "AlyxGun"
SWEP.Primary.Round 				= ("rw_sw_ent_nade_emp")
SWEP.Primary.Range 					= 950
SWEP.Velocity = 950
SWEP.Velocity_Underhand = 400
SWEP.Delay = 0.23
SWEP.DelayCooked = 0.24
SWEP.Delay_Underhand = 0.245
SWEP.CookStartDelay = 1
SWEP.UnderhandEnabled = true
SWEP.CookingEnabled = true
SWEP.CookTimer = 3.2
SWEP.Primary.Force = 0
SWEP.Primary.Knockback = 0

SWEP.ViewModelBoneMods = {
	["Spoon_F1"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	["Weapon_F1"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	["Pin_Pull"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	["Pin_2_F1"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	["Pin_F1"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	--["Weapon"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	--["Spoon"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
}

SWEP.VElements={
	["n"]={type="Model",model="models/weapons/tfa_starwars/w_thermal.mdl",bone="Weapon_F1",rel="",pos=Vector(-0.7,0.2,01.1),angle=Angle(0,105,0),size=Vector(0.7,0.7,0.7),color=Color(255,255,255,255),surpresslightning=false,material="",skin=0,bodygroup={}},
}

SWEP.WElements={
	["n"]={type="Model",model="models/weapons/tfa_starwars/w_thermal.mdl",bone="ValveBiped.Bip01_R_Hand",rel="",pos=Vector(03,02,0),angle=Angle(0,180,180),size=Vector(0.9,0.9,0.9),color=Color(255,255,255,255),surpresslightning=false,material="",skin=0,bodygroup={}}
}

SWEP.ProceduralHoslterEnabled   = true
SWEP.ProceduralHolsterTime      = 0.0
SWEP.ProceduralHolsterPos       = Vector(0, 0, 0)
SWEP.ProceduralHolsterAng       = Vector(0, 0, 0)

SWEP.Offset = {
		Pos = {
		Up = 0,
		Right = 1,
		Forward = 3,
		},
		Ang = {
		Up = -1,
		Right = -2,
		Forward = 178
		},
		Scale = 1
}

SWEP.InspectPos 				= Vector(-03,0,03)
SWEP.InspectAng 				= Vector(0,0,0)


SWEP.Sprint_Mode 				= TFA.Enum.LOCOMOTION_ANI
SWEP.SprintAnimation = {
	["loop"] = {
		["type"] = TFA.Enum.ANIMATION_SEQ,
		["value"] = "sprint",
		["is_idle"] = true
	}
}
--addons/egm_tfa_grenades/lua/weapons/rw_sw_nade_incendiary.lua:
SWEP.Base						= "tfa_ins2_nade_base"
SWEP.Category					= "SW:RP (Granaten)"
SWEP.Author						= "Gorka(Strasser) & ChanceSphere574"
SWEP.Type						= "Explode and create a fire zone"
SWEP.PrintName					= "Incendiary Grenade"
SWEP.Slot						= 3
SWEP.SlotPos					= 100
SWEP.DrawAmmo					= true
SWEP.DrawWeaponInfoBox			= false
SWEP.BounceWeaponIcon   		= false
SWEP.DrawCrosshair				= false
SWEP.Weight						= 2
SWEP.AutoSwitchTo				= true
SWEP.AutoSwitchFrom				= true
SWEP.HoldType 					= "grenade"

SWEP.ViewModelFOV				= 70
SWEP.ViewModelFlip				= false
SWEP.ViewModel					= "models/weapons/tfa_ins2/v_f1.mdl"
SWEP.WorldModel					= "models/weapons/tfa_ins2/w_f1.mdl"
SWEP.ShowWorldModel				= false
SWEP.Spawnable					= true
SWEP.UseHands                   = true
SWEP.AdminSpawnable				= true

SWEP.Primary.Damage             = 8
SWEP.Primary.RPM				= 10
SWEP.Primary.ClipSize			= 1
SWEP.Primary.DefaultClip		= 1
SWEP.Primary.Automatic			= false
SWEP.DisableChambering 			= true
SWEP.Primary.Ammo				= "AlyxGun"
SWEP.Primary.Round 				= ("rw_sw_ent_nade_incendiary")
SWEP.Primary.Range 					= 950
SWEP.Velocity = 950
SWEP.Velocity_Underhand = 400
SWEP.Delay = 0.23
SWEP.DelayCooked = 0.24
SWEP.Delay_Underhand = 0.245
SWEP.CookStartDelay = 1
SWEP.UnderhandEnabled = true
SWEP.CookingEnabled = false
SWEP.CookTimer = 3.2
SWEP.Primary.Force = 0
SWEP.Primary.Knockback = 0

SWEP.ViewModelBoneMods = {
	["Spoon_F1"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	["Weapon_F1"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	["Pin_Pull"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	["Pin_2_F1"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	["Pin_F1"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	--["Weapon"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	--["Spoon"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
}

SWEP.VElements = {
	["n"] = { type = "Model", model = "models/weapons/tfa_starwars/w_incendiary.mdl", bone = "Weapon_F1", rel = "", pos = Vector(-0.2, 0.3, 01.1), angle = Angle(-05, -160, 0), size = Vector(0.6, 0.6, 0.6), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
}

SWEP.WElements = {
	["n"] = { type = "Model", model = "models/weapons/tfa_starwars/w_incendiary.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(03, 02, 0), angle = Angle(10, 0, 0), size = Vector(0.9, 0.9, 0.9), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}

SWEP.ProceduralHoslterEnabled   = true
SWEP.ProceduralHolsterTime      = 0.0
SWEP.ProceduralHolsterPos       = Vector(0, 0, 0)
SWEP.ProceduralHolsterAng       = Vector(0, 0, 0)

SWEP.Offset = {
		Pos = {
		Up = 0,
		Right = 1,
		Forward = 3,
		},
		Ang = {
		Up = -1,
		Right = -2,
		Forward = 178
		},
		Scale = 1
}

SWEP.InspectPos 				= Vector(-03,0,03)
SWEP.InspectAng 				= Vector(0,0,0)


SWEP.Sprint_Mode 				= TFA.Enum.LOCOMOTION_ANI
SWEP.SprintAnimation = {
	["loop"] = {
		["type"] = TFA.Enum.ANIMATION_SEQ,
		["value"] = "sprint",
		["is_idle"] = true
	}
}
--addons/star_wars_detpack/lua/weapons/seal6-c4/shared.lua:

AddCSLuaFile( "shared.lua" )

SWEP.Author					= ""
SWEP.Instructions			= "Rechtsklick: Werfe den Detonator \nLinksklick: Zünde alle Detonatoren"

SWEP.Category 				= "SW:RP (Sonstiges)"
SWEP.Spawnable				= true
SWEP.AdminSpawnable			= true

SWEP.ViewModel				= "models/hoff/weapons/seal6_c4/v_c4.mdl"
SWEP.WorldModel				= "models/weapons/detpack/egm_detpack.mdl"
SWEP.ViewModelFOV 			= 70

SWEP.Primary.ClipSize		= 1
SWEP.Primary.DefaultClip	= 3
SWEP.Primary.Automatic		= false
SWEP.Primary.Ammo			= "rpg_round"
SWEP.Primary.Delay		 	= 1

SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Automatic	= false
SWEP.Secondary.Ammo			= "none"

SWEP.NextDeplace 			= 0

SWEP.Weight					= 5
SWEP.AutoSwitchTo			= false
SWEP.AutoSwitchFrom			= false

SWEP.PrintName				= "Detonator - Werfbar"
SWEP.Slot					= 4
SWEP.SlotPos				= 1
SWEP.DrawAmmo				= false
SWEP.DrawCrosshair			= false

SWEP.Offset = {
	Pos = {
		Up = 0,
		Right = -2,
		Forward = 0,
	},
	Ang = {
		Up = 0,
		Right = 0,
		Forward = -45,
	}
}

function SWEP:DrawWorldModel( )
	local hand, offset

	if not IsValid( self:GetOwner() ) then
		self:DrawModel( )
		return
	end

	if not self.Hand then
		self.Hand = self:GetOwner():LookupAttachment( "anim_attachment_rh" )
	end

	hand = self:GetOwner():GetAttachment( self.Hand )

	if not hand then
		self:DrawModel( )
		return
	end

	offset = hand.Ang:Right( ) * self.Offset.Pos.Right + hand.Ang:Forward( ) * self.Offset.Pos.Forward + hand.Ang:Up( ) * self.Offset.Pos.Up

	hand.Ang:RotateAroundAxis( hand.Ang:Right( ), self.Offset.Ang.Right )
	hand.Ang:RotateAroundAxis( hand.Ang:Forward( ), self.Offset.Ang.Forward )
	hand.Ang:RotateAroundAxis( hand.Ang:Up( ), self.Offset.Ang.Up )

	self:SetRenderOrigin( hand.Pos + offset )
	self:SetRenderAngles( hand.Ang )

	self:DrawModel( )
end

function SWEP:Deploy()
end

function SWEP:Equip(NewOwner)
	if self:GetOwner().C4s == nil then
		self:GetOwner().C4s = {}
	end
end

function SWEP:PrimaryAttack()
	if not IsFirstTimePredicted() then return end
	self:SendWeaponAnim(ACT_VM_PRIMARYATTACK)

	timer.Simple(0.1,function()
		if IsValid(self) then
			self:EmitSound("hoff/mpl/seal_c4/c4_click.wav")
		end
	end)

	if self:GetOwner():Alive() and self:GetOwner():IsValid() then
		local Owner = self:GetOwner()

		if SERVER then
			for k, v in pairs( Owner.C4s ) do
				timer.Simple( .05 * k, function()
					if IsValid( v ) then
						v:ActivateDetonator()
						table.remove( Owner.C4s, k )
						Owner.C4s[k] = null
					end
				end )
			end
		end
	end

	self:SetNextPrimaryFire(CurTime() + 1.1)
	self:SetNextSecondaryFire(CurTime() + 1.2)
end

function SWEP:SecondaryAttack()
	if not IsFirstTimePredicted() then return end

	if self:Clip1() <= 0 then
		self:DefaultReload( ACT_VM_RELOAD )
		return false
	end

	self:SendWeaponAnim(ACT_VM_THROW)
	self:EmitSound("hoff/mpl/seal_c4/whoosh_00.wav")
	self:TakePrimaryAmmo(1)

	if SERVER then
		self:GetOwner().C4s = self:GetOwner().C4s || {}

		local ent = ents.Create("cod-c4")
		ent:SetPos(self:GetOwner():GetShootPos())
		ent:SetAngles(Angle(0, 0, 0))
		ent:Spawn()
		ent.C4Owner = self:GetOwner()

		local phys = ent:GetPhysicsObject()
		phys:SetMass(0.6)
		phys:ApplyForceCenter(self:GetOwner():GetAimVector() * 500)

		local angvel = Vector(0,math.random(-5000,-2000),math.random(-100,-900))
		angvel:Rotate(-1 * ent:EyeAngles())
		angvel:Rotate(Angle(0,self:GetOwner():EyeAngles().y,0))
		phys:AddAngleVelocity(angvel)
		ent:SetGravity(100)

		table.insert( self:GetOwner().C4s, ent )
	end

	self:DefaultReload( ACT_VM_RELOAD )

	self:SetNextPrimaryFire(CurTime() + 1.1)
	self:SetNextSecondaryFire(CurTime() + 1.2)
end

function SWEP:ShouldDropOnDie()
	return false
end

function SWEP:OnRemove()
end

function SWEP:Reload()
	if self:Clip1() <= 0 then
		self:DefaultReload( ACT_VM_RELOAD )

		self:SetNextPrimaryFire(CurTime() + 4)
		self:SetNextSecondaryFire(CurTime() + 4)
		return
	end

	if self.NextDeplace >= CurTime() then return end

	self:DeplaceDetonator()

	self.NextDeplace = CurTime() + 5
end

function SWEP:DeplaceDetonator()
	local owner = self:GetOwner()

	self:SendWeaponAnim(ACT_VM_DRAW)
	owner:SetAnimation(PLAYER_ATTACK1)

	if SERVER then
		local tr = util.TraceLine({
			start = owner:GetShootPos(),
			endpos = owner:GetShootPos() + 115 * owner:GetAimVector(),
			filter = owner
		})

		if not IsValid(tr.Entity) then return end
		if tr.Entity:GetClass() == "cod-c4" then
			local detonator = tr.Entity

			owner:GiveAmmo(1, "rpg_round")
			detonator:Remove()

			timer.Simple(1, function()
				if IsValid(self) then
					self:SendWeaponAnim(ACT_VM_IDLE)
				end
			end)
		end
	end
end

function SWEP:DrawHUD()
	surface.SetDrawColor( 255, 255, 255, 255 )
	surface.SetMaterial( Material("models/hoff/weapons/seal6_c4/c4_reticle.png") )
	surface.DrawTexturedRect( ScrW() / 2 - 16, ScrH() / 2 - 16, 32, 32 )
end
--addons/tfa_base/lua/weapons/tfa_bow_base.lua:
if SERVER then
	AddCSLuaFile()
end

SWEP.IsBow = true

DEFINE_BASECLASS("tfa_gun_base")
--primary stats
SWEP.Primary.Spread = 0.001
SWEP.Primary.SpreadShake = 0.05 --when shaking
SWEP.Primary.Velocity = 64 --velocity in m/s
SWEP.Primary.Damage_Charge = {0.2, 1} --velocity/damage multiplier between min and max charge
SWEP.Primary.Shake = true --enable shaking
--options
SWEP.Secondary.Cancel = true --enable cancelling
--bow base shit
SWEP.ChargeRate = 30 / 75 --1 is fully charged
SWEP.ChargeThreshold = 0.75 --minimum charge percent to fire
SWEP.ShakeTime = 5 --minimum time to start shaking
SWEP.Secondary.IronSightsEnabled = false
--tfa ballistics integration
SWEP.UseBallistics = true
SWEP.BulletModel = "models/weapons/w_tfa_arrow.mdl"
SWEP.BulletTracer = ""

--animation
SWEP.BowAnimations = {
	["shake"] = {
		["type"] = TFA.Enum.ANIMATION_SEQ, --Sequence or act
		["value"] = "tiredloop",
		["enabled"] = true --Manually force a sequence to be enabled
	},
	["shoot"] = {
		["type"] = TFA.Enum.ANIMATION_SEQ, --Sequence or act
		["value"] = "fire_1",
		["enabled"] = true --Manually force a sequence to be enabled
	},
	["cancel"] = {
		["type"] = TFA.Enum.ANIMATION_SEQ, --Sequence or act
		["value"] = "cancelarrow",
		["enabled"] = true --Manually force a sequence to be enabled
	},
	["draw"] = {
		["type"] = TFA.Enum.ANIMATION_SEQ, --Sequence or act
		["value"] = "drawarrow",
		["enabled"] = true --Manually force a sequence to be enabled
	}
}

--["idle_charged"] = {["type"] = TFA.Enum.ANIMATION_SEQ, ["value"] = "idle_charged", ["enabled"] = true }
function SWEP:SetupDataTables(...)
	BaseClass.SetupDataTables(self, ...)

	self:NetworkVarTFA("Bool", "Shaking")
	self:NetworkVarTFA("Float", "Charge")
end

function SWEP:GetChargeTime()
	return self:GetCharge() / self.ChargeRate
end

function SWEP:ShouldShake()
	return self:GetChargeTime() >= self.ShakeTime
end

function SWEP:Deploy(...)
	self:SetCharge(0)
	self:SetShaking(false)

	return BaseClass.Deploy(self, ...)
end

function SWEP:Charge(t)
	self:SetCharge(self:GetCharge() + self.ChargeRate * t)
end

local sp = game.SinglePlayer()
local ft

function SWEP:Think2(...)
	ft = FrameTime()

	if self:GetStatus() == TFA.Enum.STATUS_BOW_CANCEL and self:GetStatusEnd() > CurTime() then
		self:SetCharge(0)
		self:SetShaking(false)
	end

	if TFA.Enum.ReadyStatus[self:GetStatus()] and self:CanPrimaryAttack() then
		if self:GetOwner():KeyDown(IN_ATTACK2) and self:GetCharge() > self.ChargeThreshold then
			self:PlayAnimation(self.BowAnimations.cancel)
			self:ScheduleStatus(TFA.Enum.STATUS_BOW_CANCEL, self:GetActivityLength())
		elseif self:GetOwner():KeyDown(IN_ATTACK) then
			if self:GetCharge() <= 0 then
				self:PlayAnimation(self.BowAnimations.draw)
				self:SetCharge(0.01)
				self:SetShaking(false)
			end

			self:Charge(ft)

			if self:ShouldShake() and not self:GetShaking() then
				self:SetShaking(true)
				self:PlayAnimation(self.BowAnimations.shake)
			end
		else
			local c = self:GetCharge()

			if c > self.ChargeThreshold then
				self:Shoot()
			elseif c > 0 then
				self:Charge(ft)
			end
		end
	elseif self:GetCharge() > 0 then
		if TFA.Enum.ReadyStatus[self:GetStatus()] then
			if self:GetCharge() > self.ChargeThreshold then
				self:PlayAnimation(self.BowAnimations.cancel)
				self:ScheduleStatus(TFA.Enum.STATUS_BOW_CANCEL, self:GetActivityLength())
			else
				self.Idle_ModeOld = self.Idle_Mode
				self:ClearStatCache("Idle_Mode")
				self.Idle_Mode = TFA.Enum.IDLE_BOTH
				self:ChooseIdleAnim()
				self.Idle_Mode = self.Idle_ModeOld
			end
		end

		self:SetCharge(0)
		self:SetShaking(false)
	end

	if IsFirstTimePredicted() or game.SinglePlayer() then
		self.Primary_TFA.SpreadBase = self.Primary_TFA.SpreadBase or self:GetStatL("Primary.Spread")
		local targ = self:GetShaking() and self.Primary_TFA.SpreadShake or self:GetStatL("Primary.SpreadBase")
		self.Primary_TFA.Spread = math.Approach(self.Primary_TFA.Spread, targ, (targ - self.Primary_TFA.Spread) * FrameTime() * 5)
		self:ClearStatCache("Primary.Spread")
	end

	BaseClass.Think2(self, ...)
end

function SWEP:Shoot()
	if self:GetStatL("Primary.Sound") and IsFirstTimePredicted()  and not ( sp and CLIENT ) then
		if self:GetStatL("Primary.SilencedSound") and self:GetSilenced() then
			self:EmitSound(self:GetStatL("Primary.SilencedSound")   )
		else
			self:EmitSound(self:GetStatL("Primary.Sound"))
		end
	end
	self:TakePrimaryAmmo(self:GetStatL("Primary.AmmoConsumption"))
	self:PlayAnimation(self.BowAnimations.shoot)
	self:ShootBulletInformation()
	self:SetCharge(0)
	self:SetShaking(false)
	self:ScheduleStatus(TFA.Enum.STATUS_BOW_SHOOT, 0.1)
end

function SWEP:ChooseIdleAnim(...)
	if self:GetShaking() then
		return self:PlayAnimation(self.BowAnimations.shake)
	elseif self:GetCharge() > 0 and self.BowAnimations["idle_charged"] then
		return self:PlayAnimation(self.BowAnimations.idle_charged)
	end

	return BaseClass.ChooseIdleAnim(self, ...)
end

function SWEP:PrimaryAttack()
end

function SWEP:SecondaryAttack()
end

SWEP.MainBullet = {}
SWEP.MainBullet.Spread = Vector()
local ballistics_distcv = GetConVar("sv_tfa_ballistics_mindist")

local function BallisticFirebullet(ply, bul, ovr)
	local wep = ply:GetActiveWeapon()

	if TFA.Ballistics and TFA.Ballistics:ShouldUse(wep) then
		if ballistics_distcv:GetInt() == -1 or ply:GetEyeTrace().HitPos:Distance(ply:GetShootPos()) > (ballistics_distcv:GetFloat() * TFA.Ballistics.UnitScale) then
			bul.SmokeParticle = bul.SmokeParticle or wep.BulletTracer or wep.TracerBallistic or wep.BallisticTracer or wep.BallisticsTracer

			if ovr then
				TFA.Ballistics:FireBullets(wep, bul, angle_zero, true)
			else
				TFA.Ballistics:FireBullets(wep, bul)
			end
		else
			ply:FireBullets(bul)
		end
	else
		ply:FireBullets(bul)
	end
end

--[[
Function Name:  ShootBulletInformation
Syntax: self:ShootBulletInformation().
Returns:   Nothing.
Notes:  Used to generate a self.MainBullet table which is then sent to self:ShootBullet, and also to call shooteffects.
Purpose:  Bullet
]]
--
local cv_dmg_mult = GetConVar("sv_tfa_damage_multiplier")
local cv_dmg_mult_min = GetConVar("sv_tfa_damage_mult_min")
local cv_dmg_mult_max = GetConVar("sv_tfa_damage_mult_max")
local dmg, con, rec

function SWEP:ShootBulletInformation()
	self:UpdateConDamage()
	self.lastbul = nil
	self.lastbulnoric = false
	self.ConDamageMultiplier = cv_dmg_mult:GetFloat()
	if not IsFirstTimePredicted() then return end
	con, rec = self:CalculateConeRecoil()
	local tmpranddamage = math.Rand(cv_dmg_mult_min:GetFloat(), cv_dmg_mult_max:GetFloat())
	local basedamage = self.ConDamageMultiplier * self:GetStatL("Primary.Damage")
	dmg = basedamage * tmpranddamage
	local ns = self:GetStatL("Primary.NumShots")
	local clip = (self:GetStatL("Primary.ClipSize") == -1) and self:Ammo1() or self:Clip1()
	ns = math.Round(ns, math.min(clip / self:GetStatL("Primary.NumShots"), 1))
	self:ShootBullet(dmg, rec, ns, con)
end

--[[
Function Name:  ShootBullet
Syntax: self:ShootBullet(damage, recoil, number of bullets, spray cone, disable ricochet, override the generated self.MainBullet table with this value if you send it).
Returns:   Nothing.
Notes:  Used to shoot a self.MainBullet.
Purpose:  Bullet
]]
--
local cv_forcemult = GetConVar("sv_tfa_force_multiplier")

local AttachArrowModel = function(a, b, c, wep)
	c:SetDamageType(bit.bor(DMG_NEVERGIB, DMG_CLUB))
	if CLIENT then return end
	if not IsValid(wep) then return end

	if b.HitWorld and not (IsValid(b.Entity) and not b.Entity:IsWorld()) then
		local arrowstuck = ents.Create("tfbow_arrow_stuck")
		arrowstuck:SetModel(wep:GetStatL("BulletModel"))
		arrowstuck.gun = wep:GetClass()
		arrowstuck:SetPos(b.HitPos)
		arrowstuck:SetAngles(b.Normal:Angle())
		arrowstuck:Spawn()
	else
		local arrowstuck = ents.Create("tfbow_arrow_stuck_clientside")
		arrowstuck:SetModel(wep:GetStatL("BulletModel"))
		arrowstuck:SetModel(wep:GetStatL("BulletModel"))
		arrowstuck.gun = wep:GetClass()
		arrowstuck:SetPos(b.HitPos)
		arrowstuck:SetAngles(b.Normal:Angle())
		arrowstuck.targent = b.Entity
		arrowstuck.targphysbone = b.PhysicsBone or -1
		arrowstuck:Spawn()
	end
end

function SWEP:AutoDetectForce()
	if self:GetStatRawL("Primary.Force") == -1 or not self:GetStatRawL("Primary.Force") then
		self:SetStatRawL("Primary.Force", self:GetStatRawL("Force") or self:GetStatRawL("Primary.Damage") / 6 * math.sqrt(self:GetStatRawL("Primary.KickUp") + self:GetStatRawL("Primary.KickDown") + self:GetStatRawL("Primary.KickHorizontal")))
	end
end

function SWEP:ShootBullet(damage, recoil, num_bullets, aimcone, disablericochet, bulletoverride)
	if not IsFirstTimePredicted() and not game.SinglePlayer() then return end
	local chargeTable = self:GetStatL("Primary.Damage_Charge")
	local mult = Lerp(math.Clamp(self:GetCharge() - self.ChargeThreshold, 0, 1 - self.ChargeThreshold) / (1 - self.ChargeThreshold), chargeTable[1], chargeTable[2])
	local unitScale = TFA.Ballistics.UnitScale or TFA.UnitScale or 40
	num_bullets = num_bullets or 1
	aimcone = aimcone or 0
	self.MainBullet.Attacker = self:GetOwner()
	self.MainBullet.Inflictor = self
	self.MainBullet.Num = num_bullets
	self.MainBullet.Src = self:GetOwner():GetShootPos()
	self.MainBullet.Dir = self:GetOwner():EyeAngles():Forward()
	self.MainBullet.HullSize = 0
	self.MainBullet.Spread.x = aimcone
	self.MainBullet.Spread.y = aimcone

	if self.TracerPCF then
		self.MainBullet.Tracer = 0
	else
		self.MainBullet.Tracer = self:GetStatL("TracerCount") or 3
	end

	self.MainBullet.PenetrationCount = 0
	self.MainBullet.AmmoType = self:GetPrimaryAmmoType()
	self.MainBullet.Force = self:GetStatL("Primary.Force") * cv_forcemult:GetFloat() * self:GetAmmoForceMultiplier() * mult
	self.MainBullet.Damage = damage * mult
	self.MainBullet.HasAppliedRange = false
	self.MainBullet.Velocity = self:GetStatL("Primary.Velocity") * mult * unitScale

	self.MainBullet.Callback = function(a, b, c)
		if IsValid(self) then
			c:SetInflictor(self)
		end

		if self.MainBullet.Callback2 then
			self.MainBullet.Callback2(a, b, c)
		end

		self:CallAttFunc("CustomBulletCallback", a, b, c)

		if SERVER and IsValid(a) and a:IsPlayer() and IsValid(b.Entity) and (b.Entity:IsPlayer() or b.Entity:IsNPC() or type(b.Entity) == "NextBot") then
			self:SendHitMarker(a, b, c)
		end

		AttachArrowModel(a, b, c, self)
	end

	BallisticFirebullet(self:GetOwner(), self.MainBullet)
end

TFA.FillMissingMetaValues(SWEP)

--lua/weapons/tfa_grapple_base/shared.lua:
SWEP.Base					= "tfa_gun_base"

-- [[ GRAPPLE ]]
	-- [ Variables ]
		SWEP.GrappleEnabled			= false
		SWEP.MaxGrappleDist			= 500

		SWEP.GrappleHookSound			= "weapons/rpg/shotdown.wav"
		SWEP.GrappleHookFleshSound		= Sound("TFA.BashFlesh")

		SWEP.GrappleMoveSound			= "weapons/tripwire/ropeshoot.wav"

-- [[ FUNCTIONS ]]
	-- [ Class ]
		DEFINE_BASECLASS( SWEP.Base )

	function SWEP:Initialize()
		hook.Add( "KeyRelease", self, self.ReleaseHook )
		hook.Add( "StartCommand", self, self.ButtonHook )
		hook.Add( "PlayerBindPress", self, self.PreventHook )

		self.RopeSounds = CreateSound( self, self:GetStat("GrappleMoveSound"))
		self.RopeSounds:PlayEx(0,100)

		BaseClass.Initialize(self)
	end

	function SWEP:SetupDataTables()
		self:NetworkVar( "Int", 30, "MWScrolling" )
		self:NetworkVar( "Int", 31, "ObjectRange" )

		self:NetworkVar( "Bool", 31, "HoldingGrab" )

		self:NetworkVar( "Entity", 31, "CapturedEntity" )

		BaseClass.SetupDataTables(self)
	end

	function SWEP.ButtonHook(ent, ply, ucmd)
		if ent:GetOwner() == ply then
			if ply:GetActiveWeapon() ~= ent then return end
			if !ent:GetStat("GrappleEnabled") then return end
			if !ent:IsValid() then return end
			if ent:GetHoldingGrab() then
				ent:SetObjectRange( math.max(ent:GetObjectRange()+ucmd:GetMouseWheel()*20, 0 ) )
				ent:SetMWScrolling( ucmd:GetMouseWheel() )
			end
		end	
	end

	function SWEP.PreventHook(ent, ply, bind, press)
		if ent:GetOwner() == ply then
			if !ent:GetStat("GrappleEnabled") then return end
			if ply:GetActiveWeapon() ~= ent then return end
			if !ent:IsValid() then return end
			if ent:GetHoldingGrab() then
				if ( string.find( bind, "invnext" ) ) then return true end
				if ( string.find( bind, "invprev" ) ) then return true end
			end
		end	
	end

	function SWEP.ReleaseHook(ent, ply, key )
		if ent:GetOwner() == ply and key == IN_ATTACK2 then
			if !ent:IsValid() then return end
			if ply:GetActiveWeapon() ~= ent then return end
			if !ent:GetStat("GrappleEnabled") then return end
			ent:LetGoGrapple()
		end	
	end

	function SWEP:SecondaryAttack()
		if self:GetStat("GrappleEnabled") then
			self:ShootGrapple()
		else
			BaseClass.SecondaryAttack(self)
		end
	end

	function SWEP:ShootGrapple()
		if !self:CanPrimaryAttack() then return false end
		local ply = self:GetOwner()

		local tr = util.TraceLine( {
			start = ply:EyePos(),
			endpos = ply:EyePos() + ply:EyeAngles():Forward() * self:GetStat("MaxGrappleDist"),
			filter = function( ent ) if ( ent ~= ply ) then return true end end
		})


		if tr.Hit then
			self:SetHoldingGrab(true)
			if !SERVER then return false end
			
			local ent = tr.Entity
			self.RopeAnchor = ents.Create("prop_physics")
			self.RopeAnchor:SetPos(tr.HitPos + (tr.HitNormal*5))
			self.RopeAnchor:SetAngles(tr.HitNormal:Angle()+Angle(90,0,90))
			self.RopeAnchor:SetModel("models/props_c17/TrapPropeller_Lever.mdl")
			self.RopeAnchor:Spawn()
			self.RopeAnchor:SetCollisionGroup(COLLISION_GROUP_IN_VEHICLE)
			self.RopeAnchor:DrawShadow(false)
			self.RopeAnchor:GetPhysicsObject():EnableMotion(false)
			self.RopeAnchor:SetSolid(SOLID_NONE)
			if ent:IsPlayer() or ent:IsNPC() then
				self:SetCapturedEntity(ent)
				self.RopeAnchor:SetParent(ent,tr.PhysicsBone)
			end

			if tr.MatType == MAT_FLESH or tr.MatType == MAT_ALIENFLESH then
				self.RopeAnchor:EmitSound( self:GetStat("GrappleHookFleshSound") )
			else
				self.RopeAnchor:EmitSound( self:GetStat("GrappleHookSound") )
			end

			self.PlayerKF = ents.Create("prop_physics")
			self.PlayerKF:SetModel("models/Combine_Helicopter/helicopter_bomb01.mdl")
			self.PlayerKF:Spawn()
			self.PlayerKF:SetCollisionGroup(COLLISION_GROUP_IN_VEHICLE)
			self.PlayerKF:SetRenderMode(RENDERMODE_NONE)
			self.PlayerKF:DrawShadow(false)
			self.PlayerKF:PointAtEntity(self.Owner)
			self.PlayerKF:SetSolid(SOLID_NONE)
			
			local vm = ply:GetViewModel(0)
			if ply == ply:GetViewEntity() then
				self.PlayerKF:SetPos(vm:GetAttachment(self:GetMuzzleAttachment()).Pos)
				self.PlayerKF:SetParent(vm,self:GetMuzzleAttachment())
			else
				local offsetVec = Vector( 5, -1, -5 )
				local offsetAng = Angle( 180, 90, 0 )
				
				local boneid = ply:LookupBone( "ValveBiped.Bip01_R_Hand" )
				local matrix = ply:GetBoneMatrix( boneid )
				local newpos = LocalToWorld( offsetVec, offsetAng, matrix:GetTranslation(), matrix:GetAngles() )

				self.PlayerKF:SetPos(newpos)
				self.PlayerKF:SetParent(ply,5)
			end

			self:SetObjectRange( (tr.HitPos-ply:GetPos()):Length() )
			self.DefaultLength = self:GetObjectRange()

			self.RopeC, self.RopeCC = constraint.Rope(self.PlayerKF, self.RopeAnchor, 0, 0, Vector(0,0,0), Vector(0,5,0), self:GetObjectRange(), 0, 0, 2, "cable/cable2", true)
			self.RopeCC:SetKeyValue( "Slack", 0 )
	
			local effectdata = EffectData()
			effectdata:SetOrigin( self.RopeAnchor:GetPos() )
			util.Effect( "cball_bounce", effectdata, false, true)
		end
	end

	function SWEP:PreHolster()
		if !self:IsValid() then return end
		self:LetGoGrapple()
	end

	function SWEP:OnDrop()
		if !self:IsValid() then return end
		self:PreHolster()
	end

	function SWEP:OnRemove()
		if !self:IsValid() then return end
		self:PreHolster()
	end

	function SWEP:OwnerChanged()
		if !self:IsValid() then return end
		self:PreHolster()
	end

	function SWEP:LetGoGrapple()
		self:SetHoldingGrab(false)

		self:SetObjectRange(0)
		
		if self.RopeSounds then
			self.RopeSounds:ChangeVolume(0)
		end
		
		if self.RopeAnchor and self.RopeAnchor:IsValid() then
			self.RopeAnchor:Remove()
		end
		if self.PlayerKF and self.PlayerKF:IsValid() then
			self.PlayerKF:Remove()
		end

		self:SetCapturedEntity(nil)
	end

	function SWEP:GrappleThink()
		local ply = self:GetOwner()
		local ranc = self.RopeAnchor

		if !self:GetHoldingGrab() then return false end
		if !ranc or !ranc:IsValid() then return false end

		local trendpos = ranc:GetPos() + (Vector(0,0,-1) * self:GetObjectRange())
		
		if self:GetCapturedEntity() and self:GetCapturedEntity():IsValid() then
			ply = self:GetCapturedEntity()
			ranc = self:GetOwner()
			trendpos = ranc:GetPos() + ((ply:GetPos()-ranc:GetPos()):GetNormal() * self:GetObjectRange())
		
			if ply:Health() <= 0 then
				self:LetGoGrapple()
			end
		end

		local plyp = ply:GetPhysicsObject()

		local tr = util.TraceLine({
			start = ranc:GetPos(),
			endpos = trendpos,
			filter = function(ent)
				if (ent == ent) or (ent == self.Owner) or (ent == ranc) then
					return false
				else
					return true
				end
			end
		})

		local objr = math.min(5000/(self:GetObjectRange()+10), 10)

		local objrd = math.max((self.DefaultLength - self:GetObjectRange())/200,0)

		local dist = math.Clamp(tr.HitPos:Distance(ply:GetPos())/10, 0, 15)

		local grup
		local grside

		if ply:IsPlayer() then
			if ply:OnGround() then
				grside = objrd
				grup = dist*3
			else
				grup = 1
				grside = 1
			end
		else
			if ply:OnGround() then
				grside = 2
				grup = 0.1
			else
				grup = 0.8
				grside = 1
			end
		end

		local futurvel = (tr.HitPos-ply:GetPos()):GetNormal() * (((objr + dist)/2)*grside)
		futurvel:Add(Vector(0,0,5*(grup)))
		futurvel:Sub( ply:GetVelocity()/(dist*25) )
		futurvel:Sub( Vector(0,0, ply:GetVelocity().z/(objr*25) ) )

		ply:SetVelocity( futurvel )

		self.RopeCC:SetKeyValue( "length", self:GetObjectRange()+50 )
	end

	function SWEP:Think()
		BaseClass.Think(self)

		if self.RopeSounds and self:GetObjectRange() ~= 0 then
			self.RopeSounds:ChangeVolume(math.abs(self:GetMWScrolling()), 0.4 and self:GetMWScrolling() > 0.5 or 0.1)
		end
		
		if self:GetStat("GrappleEnabled") then
			self:GrappleThink()
		end
	end
--addons/tfa_base/lua/weapons/tfa_gun_base/cl_init.lua:
TFA.SWEP_LOAD_COMPLETE = false

include("shared.lua")

include("common/ai_translations.lua")
include("common/anims.lua")
include("common/autodetection.lua")
include("common/utils.lua")
include("common/stat.lua")
include("common/attachments.lua")
include("common/bullet.lua")
include("common/effects.lua")
include("common/calc.lua")
include("common/akimbo.lua")
include("common/events.lua")
include("common/nzombies.lua")
include("common/ttt.lua")
include("common/viewmodel.lua")
include("common/skins.lua")

include("client/effects.lua")
include("client/viewbob.lua")
include("client/viewmodel.lua")
include("client/bobcode.lua")
include("client/hud.lua")
include("client/mods.lua")
include("client/laser.lua")
include("client/fov.lua")
include("client/flashlight.lua")

TFA.FillMissingMetaValues(SWEP)

--addons/tfa_base/lua/weapons/tfa_gun_base/common/anims.lua:
local sp = game.SinglePlayer()

SWEP.Locomotion_Data_Queued = nil

local ServersideLooped = {
	[ACT_VM_FIDGET] = true,
	[ACT_VM_FIDGET_EMPTY] = true
}

--[ACT_VM_IDLE] = true,
--[ACT_VM_IDLE_EMPTY] = true,
--[ACT_VM_IDLE_SILENCED] = true
local d, pbr

-- Override this after SWEP:Initialize, for example, in attachments
SWEP.BaseAnimations = {
	["draw_first"] = {
		["type"] = TFA.Enum.ANIMATION_ACT, --Sequence or act
		["value"] = ACT_VM_DRAW_DEPLOYED,
		["enabled"] = nil --Manually force a sequence to be enabled
	},
	["draw"] = {
		["type"] = TFA.Enum.ANIMATION_ACT, --Sequence or act
		["value"] = ACT_VM_DRAW
	},
	["draw_empty"] = {
		["type"] = TFA.Enum.ANIMATION_ACT, --Sequence or act
		["value"] = ACT_VM_DRAW_EMPTY
	},
	["draw_silenced"] = {
		["type"] = TFA.Enum.ANIMATION_ACT, --Sequence or act
		["value"] = ACT_VM_DRAW_SILENCED
	},
	["shoot1"] = {
		["type"] = TFA.Enum.ANIMATION_ACT, --Sequence or act
		["value"] = ACT_VM_PRIMARYATTACK
	},
	["shoot1_last"] = {
		["type"] = TFA.Enum.ANIMATION_ACT, --Sequence or act
		["value"] = ACT_VM_PRIMARYATTACK_EMPTY
	},
	["shoot1_empty"] = {
		["type"] = TFA.Enum.ANIMATION_ACT, --Sequence or act
		["value"] = ACT_VM_DRYFIRE
	},
	["shoot1_silenced"] = {
		["type"] = TFA.Enum.ANIMATION_ACT, --Sequence or act
		["value"] = ACT_VM_PRIMARYATTACK_SILENCED
	},
	["shoot1_silenced_empty"] = {
		["type"] = TFA.Enum.ANIMATION_ACT, --Sequence or act
		["value"] = ACT_VM_DRYFIRE_SILENCED or 0
	},
	["shoot1_is"] = {
		["type"] = TFA.Enum.ANIMATION_ACT, --Sequence or act
		["value"] = ACT_VM_PRIMARYATTACK_1
	},
	["shoot2"] = {
		["type"] = TFA.Enum.ANIMATION_ACT, --Sequence or act
		["value"] = ACT_VM_SECONDARYATTACK
	},
	["shoot2_last"] = {
		["type"] = TFA.Enum.ANIMATION_SEQ, --Sequence or act
		["value"] = "shoot2_last"
	},
	["shoot2_empty"] = {
		["type"] = TFA.Enum.ANIMATION_ACT, --Sequence or act
		["value"] = ACT_VM_DRYFIRE
	},
	["shoot2_silenced"] = {
		["type"] = TFA.Enum.ANIMATION_SEQ, --Sequence or act
		["value"] = "shoot2_silenced"
	},
	["shoot2_is"] = {
		["type"] = TFA.Enum.ANIMATION_ACT, --Sequence or act
		["value"] = ACT_VM_ISHOOT_M203
	},
	["idle"] = {
		["type"] = TFA.Enum.ANIMATION_ACT, --Sequence or act
		["value"] = ACT_VM_IDLE
	},
	["idle_empty"] = {
		["type"] = TFA.Enum.ANIMATION_ACT, --Sequence or act
		["value"] = ACT_VM_IDLE_EMPTY
	},
	["idle_silenced"] = {
		["type"] = TFA.Enum.ANIMATION_ACT, --Sequence or act
		["value"] = ACT_VM_IDLE_SILENCED
	},
	["reload"] = {
		["type"] = TFA.Enum.ANIMATION_ACT, --Sequence or act
		["value"] = ACT_VM_RELOAD
	},
	["reload_empty"] = {
		["type"] = TFA.Enum.ANIMATION_ACT, --Sequence or act
		["value"] = ACT_VM_RELOAD_EMPTY
	},
	["reload_silenced"] = {
		["type"] = TFA.Enum.ANIMATION_ACT, --Sequence or act
		["value"] = ACT_VM_RELOAD_SILENCED
	},
	["reload_shotgun_start"] = {
		["type"] = TFA.Enum.ANIMATION_ACT,
		["value"] = ACT_SHOTGUN_RELOAD_START
	},
	["reload_shotgun_finish"] = {
		["type"] = TFA.Enum.ANIMATION_ACT,
		["value"] = ACT_SHOTGUN_RELOAD_FINISH
	},
	["reload_is"] = {
		["type"] = TFA.Enum.ANIMATION_ACT,
		["value"] = ACT_VM_RELOAD_ADS
	},
	["reload_empty_is"] = {
		["type"] = TFA.Enum.ANIMATION_ACT,
		["value"] = ACT_VM_RELOAD_EMPTY_ADS
	},
	["reload_silenced_is"] = {
		["type"] = TFA.Enum.ANIMATION_ACT,
		["value"] = ACT_VM_RELOAD_SILENCED_ADS
	},
	["reload_shotgun_start_is"] = {
		["type"] = TFA.Enum.ANIMATION_ACT,
		["value"] = ACT_SHOTGUN_RELOAD_START_ADS
	},
	["reload_shotgun_finish_is"] = {
		["type"] = TFA.Enum.ANIMATION_ACT,
		["value"] = ACT_SHOTGUN_RELOAD_FINISH_ADS
	},
	["holster"] = {
		["type"] = TFA.Enum.ANIMATION_ACT, --Sequence or act
		["value"] = ACT_VM_HOLSTER
	},
	["holster_empty"] = {
		["type"] = TFA.Enum.ANIMATION_ACT, --Sequence or act
		["value"] = ACT_VM_HOLSTER_EMPTY
	},
	["holster_silenced"] = {
		["type"] = TFA.Enum.ANIMATION_ACT, --Sequence or act
		["value"] = ACT_VM_HOLSTER_SILENCED
	},
	["silencer_attach"] = {
		["type"] = TFA.Enum.ANIMATION_ACT, --Sequence or act
		["value"] = ACT_VM_ATTACH_SILENCER
	},
	["silencer_detach"] = {
		["type"] = TFA.Enum.ANIMATION_ACT, --Sequence or act
		["value"] = ACT_VM_DETACH_SILENCER
	},
	["rof"] = {
		["type"] = TFA.Enum.ANIMATION_ACT, --Sequence or act
		["value"] = ACT_VM_FIREMODE
	},
	["rof_is"] = {
		["type"] = TFA.Enum.ANIMATION_ACT, --Sequence or act
		["value"] = ACT_VM_IFIREMODE
	},
	["bash"] = {
		["type"] = TFA.Enum.ANIMATION_ACT, --Sequence or act
		["value"] = ACT_VM_HITCENTER
	},
	["bash_silenced"] = {
		["type"] = TFA.Enum.ANIMATION_ACT, --Sequence or act
		["value"] = ACT_VM_HITCENTER2
	},
	["bash_empty"] = {
		["type"] = TFA.Enum.ANIMATION_ACT, --Sequence or act
		["value"] = ACT_VM_MISSCENTER
	},
	["bash_empty_silenced"] = {
		["type"] = TFA.Enum.ANIMATION_ACT, --Sequence or act
		["value"] = ACT_VM_MISSCENTER2
	},
	["inspect"] = {
		["type"] = TFA.Enum.ANIMATION_ACT, --Sequence or act
		["value"] = ACT_VM_FIDGET
	},
	["inspect_empty"] = {
		["type"] = TFA.Enum.ANIMATION_ACT, --Sequence or act
		["value"] = ACT_VM_FIDGET_EMPTY
	},
	["inspect_silenced"] = {
		["type"] = TFA.Enum.ANIMATION_ACT, --Sequence or act
		["value"] = ACT_VM_FIDGET_SILENCED
	}
}

SWEP.Animations = {}

function SWEP:InitializeAnims()
	local self2 = self:GetTable()

	setmetatable(self2.Animations, {
		__index = function(t, k) return self2.BaseAnimations[k] end
	})
end

function SWEP:BuildAnimActivities()
	local self2 = self:GetTable()
	self2.AnimationActivities = self2.AnimationActivities or {}

	for k, v in pairs(self2.BaseAnimations) do
		if v.value then
			self2.AnimationActivities[v.value] = k
		end

		local kvt = self2.GetStatL(self, "Animations." .. k)

		if kvt.value then
			self2.AnimationActivities[kvt.value] = k
		end
	end

	for k, _ in pairs(self2.Animations) do
		local kvt = self2.GetStatL(self, "Animations." .. k)

		if kvt.value then
			self2.AnimationActivities[kvt.value] = k
		end
	end
end

function SWEP:GetActivityEnabled(act)
	local self2 = self:GetTable()
	local stat = self2.GetStatL(self, "SequenceEnabled." .. act)
	if stat then return stat end

	if not self2.AnimationActivities then
		self:BuildAnimActivities()
	end

	local keysel = self2.AnimationActivities[act] or ""
	local kv = self2.GetStatL(self, "Animations." .. keysel)
	if not kv then return false end

	if kv["enabled"] then
		return kv["enabled"]
	else
		return false
	end
end

function SWEP:ChooseAnimation(keyOrData)
	local self2 = self:GetTable()

	local data

	if isstring(keyOrData) then
		data = self2.GetStatL(self, "Animations." .. keyOrData)
	elseif istable(keyOrData) then
		data = keyOrData
	else
		error("Unknown value type " .. type(keyOrData) .. " passed!")
	end

	if not data then return 0, 0 end
	if not data["type"] then return 0, 0 end
	if not data["value"] then return 0, 0 end

	local retType, retValue = data["type"], data["value"]

	if self:Clip1() <= 0 and self2.GetStatL(self, "Primary.ClipSize") >= 0 then
		if data.value_empty then
			retValue = data.value_empty
			retType = data.type_empty or retType
		end
	end

	if self:Clip1() == 1 and self2.GetStatL(self, "Primary.ClipSize") >= 0 then
		if data.value_last then
			retValue = data.value_last
			retType = data.type_last or retType
		end
	end

	if self2.GetSilenced(self) then
		local previousRetType = retType

		if data.value_sil then
			retValue = data.value_sil
			retType = data.type_sil or previousRetType
		end

		if self:Clip1() <= 0 and self2.GetStatL(self, "Primary.ClipSize") >= 0 then
			if data.value_sil_empty then
				retValue = data.value_sil_empty
				retType = data.type_sil_empty or previousRetType
			end
		end
	end

	if self:GetIronSights() then
		local previousRetType = retType

		if data.value_is then
			retValue = data.value_is
			retType = data.type_is or previousRetType
		end

		if self:Clip1() <= 0 and self2.GetStatL(self, "Primary.ClipSize") >= 0 then
			if data.value_is_empty then
				retValue = data.value_is_empty
				retType = data.type_is_empty or previousRetType
			end
		end

		if self:Clip1() == 1 and self2.GetStatL(self, "Primary.ClipSize") >= 0 then
			if data.value_is_last then
				retValue = data.value_is_last
				retType = data.type_is_last or previousRetType
			end
		end

		if self2.GetSilenced(self) then
			if data.value_is_sil then
				retValue = data.value_is_sil
				retType = data.type_is_sil or previousRetType
			end

			if self:Clip1() <= 0 and self2.GetStatL(self, "Primary.ClipSize") >= 0 then
				if data.value_is_sil_empty then
					retValue = data.value_is_sil_empty
					retType = data.type_is_sil_empty or previousRetType
				end
			end

			if self:Clip1() == 1 and self2.GetStatL(self, "Primary.ClipSize") >= 0 then
				if data.value_is_sil_last then
					retValue = data.value_is_sil_last
					retType = data.type_is_sil_last or previousRetType
				end
			end
		end
	end

	if retType == TFA.Enum.ANIMATION_ACT and isstring(retValue) then
		retValue = tonumber(retValue) or -1
	elseif retType == TFA.Enum.ANIMATION_SEQ and isstring(retValue) then
		retValue = self2.OwnerViewModel:LookupSequence(retValue)
	end

	return retType, retValue
end

function SWEP:GetAnimationRate(ani, animationType)
	local self2 = self:GetTable()
	local rate = 1
	if not ani or ani < 0 or not self2.VMIV(self) then return rate end

	local nm

	if animationType == TFA.Enum.ANIMATION_ACT or animationType == nil then
		nm = self2.OwnerViewModel:GetSequenceName(self2.OwnerViewModel:SelectWeightedSequence(ani))
	elseif isnumber(ani) then
		nm = self2.OwnerViewModel:GetSequenceName(ani)
	elseif isstring(ani) then
		nm = ani
	else
		error("ani argument is typeof " .. type(ani))
	end

	local sqto = self2.GetStatL(self, "SequenceTimeOverride." .. nm) or self2.GetStatL(self, "SequenceTimeOverride." .. (ani or "0"))
	local sqro = self2.GetStatL(self, "SequenceRateOverride." .. nm) or self2.GetStatL(self, "SequenceRateOverride." .. (ani or "0"))

	if sqro then
		rate = rate * sqro
	elseif sqto then
		local t = self:GetActivityLengthRaw(ani, false)

		if t then
			rate = rate * t / sqto
		end
	end

	rate = hook.Run("TFA_AnimationRate", self, ani, rate) or rate

	return rate
end

function SWEP:SendViewModelAnim(act, rate, targ, blend)
	local self2 = self:GetTable()
	if not self2.VMIV(self) then return false, act end
	local vm = self2.OwnerViewModel

	if rate and not targ then
		rate = math.max(rate, 0.0001)
	end

	if not rate then
		rate = 1
	end

	if targ then
		rate = rate / self:GetAnimationRate(act)
	else
		rate = rate * self:GetAnimationRate(act)
	end

	if act < 0 then return false, act end
	local seq = vm:SelectWeightedSequenceSeeded(act, self:GetSeedIrradical())

	if seq < 0 then
		if act == ACT_VM_IDLE_EMPTY then
			seq = vm:SelectWeightedSequenceSeeded(ACT_VM_IDLE, self:GetSeedIrradical())
		elseif act == ACT_VM_PRIMARYATTACK_EMPTY then
			seq = vm:SelectWeightedSequenceSeeded(ACT_VM_PRIMARYATTACK, self:GetSeedIrradical())
		else
			return false, 0
		end

		if seq < 0 then return false, act end
	end

	local preLastActivity = self:GetLastActivity()
	--local preLastSequence = self:GetLastActivity()
	self:SetLastActivity(act)
	self:SetLastSequence(seq)
	self:ResetEvents()

	if preLastActivity == act and ServersideLooped[act] then
		self:ChooseIdleAnim()
		d = vm:SequenceDuration(seq)
		pbr = targ and (d / (rate or 1)) or (rate or 1)

		if IsValid(self) then
			if blend == nil then
				blend = self2.Idle_Smooth
			end

			self:SetNextIdleAnim(CurTime() + d / pbr - blend)
		end

		if IsFirstTimePredicted() then
			timer.Simple(0, function()
				vm:SendViewModelMatchingSequence(seq)
				d = vm:SequenceDuration()
				pbr = targ and (d / (rate or 1)) or (rate or 1)
				vm:SetPlaybackRate(pbr)

				if IsValid(self) then
					if blend == nil then
						blend = self2.Idle_Smooth
					end

					self:SetNextIdleAnim(CurTime() + d / pbr - blend)
					self:SetLastActivity(act)
				end
			end)
		end
	else
		if seq >= 0 then
			vm:SendViewModelMatchingSequence(seq)
		end

		d = vm:SequenceDuration()
		pbr = targ and (d / (rate or 1)) or (rate or 1)
		vm:SetPlaybackRate(pbr)

		if blend == nil then
			blend = self2.Idle_Smooth
		end

		self:SetNextIdleAnim(CurTime() + math.max(d / pbr - blend, self2.Idle_Smooth))
	end

	return true, act
end

function SWEP:SendViewModelSeq(seq, rate, targ, blend)
	local self2 = self:GetTable()
	local seqold = seq

	if not self2.VMIV(self) then return false, 0 end
	local vm = self2.OwnerViewModel

	if isstring(seq) then
		seq = vm:LookupSequence(seq) or 0
	end

	local act = vm:GetSequenceActivity(seq)

	if self2.SequenceRateOverride[seqold] then
		rate = self2.SequenceRateOverride[seqold]
		targ = false
	elseif self2.SequenceRateOverride[act] then
		rate = self2.SequenceRateOverride[act]
		targ = false
	elseif self2.SequenceTimeOverride[seqold] then
		rate = self2.SequenceTimeOverride[seqold]
		targ = true
	elseif self2.SequenceTimeOverride[act] then
		rate = self2.SequenceTimeOverride[act]
		targ = true
	end

	if not rate then
		rate = 1
	end

	if targ then
		rate = rate / self:GetAnimationRate(seq, TFA.Enum.ANIMATION_SEQ)
	else
		rate = rate * self:GetAnimationRate(seq, TFA.Enum.ANIMATION_SEQ)
	end

	if seq < 0 then return false, seq end

	local preLastActivity = self:GetLastActivity()
	--local preLastSequence = self:GetLastSequence()
	self:SetLastActivity(act)
	self:SetLastSequence(seq)
	self:ResetEvents()

	if preLastActivity == act and ServersideLooped[act] then
		vm:SendViewModelMatchingSequence(act == 0 and 1 or 0)
		vm:SetPlaybackRate(0)
		vm:SetCycle(0)
		self:SetNextIdleAnim(CurTime() + 0.03)

		if IsFirstTimePredicted() then
			timer.Simple(0, function()
				vm:SendViewModelMatchingSequence(seq)
				d = vm:SequenceDuration()
				pbr = targ and (d / (rate or 1)) or (rate or 1)
				vm:SetPlaybackRate(pbr)

				if IsValid(self) then
					if blend == nil then
						blend = self2.Idle_Smooth
					end

					self:SetNextIdleAnim(CurTime() + d / pbr - blend)
					self:SetLastActivity(act)
				end
			end)
		end
	else
		if seq >= 0 then
			vm:SendViewModelMatchingSequence(seq)
		end

		d = vm:SequenceDuration()
		pbr = targ and (d / (rate or 1)) or (rate or 1)
		vm:SetPlaybackRate(pbr)

		if IsValid(self) then
			if blend == nil then
				blend = self2.Idle_Smooth
			end

			self:SetNextIdleAnim(CurTime() + d / pbr - blend)
		end
	end

	return true, seq
end

function SWEP:PlayAnimation(data, fade, rate, targ)
	local self2 = self:GetTable()
	if not self2.VMIV(self) then return false, -1 end
	if not data then return false, -1 end

	local ttype, tval = self:ChooseAnimation(data)

	if ttype == TFA.Enum.ANIMATION_SEQ then
		local success, activityID = self:SendViewModelSeq(tval, rate or 1, targ, fade or (data.transition and self2.Idle_Blend or self2.Idle_Smooth))
		return success, activityID, TFA.Enum.ANIMATION_SEQ
	end

	local success, activityID = self:SendViewModelAnim(tval, rate or 1, targ, fade or (data.transition and self2.Idle_Blend or self2.Idle_Smooth))
	return success, activityID, TFA.Enum.ANIMATION_ACT
end

--[[
Function Name:  Locomote
Syntax: self:Locomote( flip ironsights, new is, flip sprint, new sprint, flip walk, new walk).
Returns:
Notes:
Purpose:  Animation / Utility
]]
local tldata

function SWEP:Locomote(flipis, is, flipsp, spr, flipwalk, walk, flipcust, cust)
	local self2 = self:GetTable()
	if not (flipis or flipsp or flipwalk or flipcust) then return end
	if not (self:GetStatus() == TFA.Enum.STATUS_IDLE or (self:GetStatus() == TFA.Enum.STATUS_SHOOTING and self:CanInterruptShooting())) then return end
	tldata = nil

	if flipis then
		if is and self2.GetStatL(self, "IronAnimation.in") then
			tldata = self2.GetStatL(self, "IronAnimation.in", tldata)
		elseif self2.GetStatL(self, "IronAnimation.out") and not flipsp then
			tldata = self2.GetStatL(self, "IronAnimation.out", tldata)
		end
	end

	if flipsp then
		if spr and self2.GetStatL(self, "SprintAnimation.in") then
			tldata = self2.GetStatL(self, "SprintAnimation.in", tldata)
		elseif self2.GetStatL(self, "SprintAnimation.out") and not flipis and not spr then
			tldata = self2.GetStatL(self, "SprintAnimation.out", tldata)
		end
	end

	if flipwalk and not is then
		if walk and self2.GetStatL(self, "WalkAnimation.in") then
			tldata = self2.GetStatL(self, "WalkAnimation.in", tldata)
		elseif self2.GetStatL(self, "WalkAnimation.out") and (not flipis and not flipsp and not flipcust) and not walk then
			tldata = self2.GetStatL(self, "WalkAnimation.out", tldata)
		end
	end

	if flipcust then
		if cust and self2.GetStatL(self, "CustomizeAnimation.in") then
			tldata = self2.GetStatL(self, "CustomizeAnimation.in", tldata)
		elseif self2.GetStatL(self, "CustomizeAnimation.out") and (not flipis and not flipsp and not flipwalk) and not cust then
			tldata = self2.GetStatL(self, "CustomizeAnimation.out", tldata)
		end
	end

	if tldata then
		return self:PlayAnimation(tldata)
	end

	return false, -1, TFA.Enum.ANIMATION_SEQ
end

function SWEP:LocomoteOrIdle(...)
	local success, animID, animType = self:Locomote(...)

	if not success then
		return self:SetNextIdleAnim(-1)
	end

	return success, animID, animType
end

--[[
Function Name:  ChooseDrawAnim
Syntax: self:ChooseDrawAnim().
Returns:  Could we successfully find an animation?  Which action?
Notes:  Requires autodetection or otherwise the list of valid anims.
Purpose:  Animation / Utility
]]
SWEP.IsFirstDeploy = true

local function PlayChosenAnimation(self, typev, tanim, ...)
	local fnName = typev == TFA.Enum.ANIMATION_SEQ and "SendViewModelSeq" or "SendViewModelAnim"
	local a, b = self[fnName](self, tanim, ...)
	return a, b, typev
end

SWEP.PlayChosenAnimation = PlayChosenAnimation

local success, tanim, typev

function SWEP:ChooseDrawAnim()
	local self2 = self:GetTable()
	if not self2.VMIV(self) then return false, 0 end
	--self:ResetEvents()
	tanim = ACT_VM_DRAW
	success = true

	local ct = CurTime()

	if self:GetIsFirstDeploy() and self:GetLastDeployAnim() >= 0 and ct > (self:GetLastDeployAnim() or ct) + 0.1 then
		self:SetIsFirstDeploy(false)
		self2.IsFirstDeploy = false
	end

	if self:GetActivityEnabled(ACT_VM_DRAW_EMPTY) and self:IsEmpty1() then
		typev, tanim = self:ChooseAnimation("draw_empty")
	elseif (self:GetActivityEnabled(ACT_VM_DRAW_DEPLOYED) or self2.GetStat(self, "FirstDeployEnabled", false)) and self:GetIsFirstDeploy() then
		typev, tanim = self:ChooseAnimation("draw_first")
	elseif self:GetActivityEnabled(ACT_VM_DRAW_SILENCED) and self2.GetSilenced(self) then
		typev, tanim = self:ChooseAnimation("draw_silenced")
	else
		typev, tanim = self:ChooseAnimation("draw")
	end

	self:SetLastDeployAnim(ct)
	self2.LastDeployAnim = ct

	return PlayChosenAnimation(self, typev, tanim)
end

function SWEP:ResetFirstDeploy()
	self.IsFirstDeploy = true
	self:SetIsFirstDeploy(true)

	self.LastDeployAnim = -1
	self:SetLastDeployAnim(-1)
end

--[[
Function Name:  ChooseInspectAnim
Syntax: self:ChooseInspectAnim().
Returns:  Could we successfully find an animation?  Which action?
Notes:  Requires autodetection or otherwise the list of valid anims.
Purpose:  Animation / Utility
]]
--

function SWEP:ChooseInspectAnim()
	local self2 = self:GetTable()
	if not self2.VMIV(self) then return false, 0 end

	if self:GetActivityEnabled(ACT_VM_FIDGET_SILENCED) and self2.GetSilenced(self) then
		typev, tanim = self:ChooseAnimation("inspect_silenced")
	elseif self:GetActivityEnabled(ACT_VM_FIDGET_EMPTY) and self:IsEmpty1() then
		typev, tanim = self:ChooseAnimation("inspect_empty")
	elseif self2.InspectionActions then
		tanim = self2.InspectionActions[self:SharedRandom(1, #self2.InspectionActions, "Inspect")]
	elseif self:GetActivityEnabled(ACT_VM_FIDGET) then
		typev, tanim = self:ChooseAnimation("inspect")
	else
		typev, tanim = self:ChooseAnimation("idle")
		success = false
	end

	return PlayChosenAnimation(self, typev, tanim)
end

--[[
Function Name:  ChooseHolsterAnim
Syntax: self:ChooseHolsterAnim().
Returns:  Could we successfully find an animation?  Which action?
Notes:  Requires autodetection or otherwise the list of valid anims.
Purpose:  Animation / Utility
]]
--
function SWEP:ChooseHolsterAnim()
	local self2 = self:GetTable()
	if not self2.VMIV(self) then return false, 0 end

	if self:GetActivityEnabled(ACT_VM_HOLSTER_SILENCED) and self2.GetSilenced(self) then
		typev, tanim = self:ChooseAnimation("holster_silenced")
	elseif self:GetActivityEnabled(ACT_VM_HOLSTER_EMPTY) and self:IsEmpty1() then
		typev, tanim = self:ChooseAnimation("holster_empty")
	elseif self:GetActivityEnabled(ACT_VM_HOLSTER) then
		typev, tanim = self:ChooseAnimation("holster")
	else
		return false, select(2, self:ChooseIdleAnim())
	end

	return PlayChosenAnimation(self, typev, tanim)
end

--[[
Function Name:  ChooseProceduralReloadAnim
Syntax: self:ChooseProceduralReloadAnim().
Returns:  Could we successfully find an animation?  Which action?
Notes:  Uses some holster code
Purpose:  Animation / Utility
]]
--
function SWEP:ChooseProceduralReloadAnim()
	local self2 = self:GetTable()
	if not self2.VMIV(self) then return false, 0 end

	if not self2.DisableIdleAnimations then
		self:SendViewModelAnim(ACT_VM_IDLE)
	end

	return true, ACT_VM_IDLE
end

--[[
Function Name:  ChooseReloadAnim
Syntax: self:ChooseReloadAnim().
Returns:  Could we successfully find an animation?  Which action?
Notes:  Requires autodetection or otherwise the list of valid anims.
Purpose:  Animation / Utility
]]
--
function SWEP:ChooseReloadAnim()
	local self2 = self:GetTable()
	if not self2.VMIV(self) then return false, 0 end
	if self2.GetStatL(self, "IsProceduralReloadBased") then return false, 0 end

	local ads = self:GetStatL("IronSightsReloadEnabled") and self:GetIronSightsDirect()

	if self:GetActivityEnabled(ACT_VM_RELOAD_SILENCED) and self2.GetSilenced(self) then
		typev, tanim = self:ChooseAnimation((ads and self:GetActivityEnabled(ACT_VM_RELOAD_SILENCED_ADS)) and "reload_silenced_is" or "reload_silenced")
	elseif self:GetActivityEnabled(ACT_VM_RELOAD_EMPTY) and (self:Clip1() == 0 or self:IsJammed()) and not self:GetStatL("LoopedReload") then
		typev, tanim = self:ChooseAnimation((ads and self:GetActivityEnabled(ACT_VM_RELOAD_EMPTY_ADS)) and "reload_empty_is" or "reload_empty")
	else
		typev, tanim = self:ChooseAnimation((ads and self:GetActivityEnabled(ACT_VM_RELOAD_ADS)) and "reload_is" or "reload")
	end

	local fac = 1

	if self:GetStatL("LoopedReload") and self:GetStatL("LoopedReloadInsertTime") then
		fac = self:GetStatL("LoopedReloadInsertTime")
	end

	return PlayChosenAnimation(self, typev, tanim, fac, fac ~= 1)
end

--[[
Function Name:  ChooseReloadAnim
Syntax: self:ChooseReloadAnim().
Returns:  Could we successfully find an animation?  Which action?
Notes:  Requires autodetection or otherwise the list of valid anims.
Purpose:  Animation / Utility
]]
--
function SWEP:ChooseShotgunReloadAnim()
	local self2 = self:GetTable()
	if not self2.VMIV(self) then return false, 0 end

	local ads = self:GetStatL("IronSightsReloadEnabled") and self:GetIronSightsDirect()

	if self:GetActivityEnabled(ACT_VM_RELOAD_SILENCED) and self2.GetSilenced(self) then
		typev, tanim = self:ChooseAnimation((ads and self:GetActivityEnabled(ACT_VM_RELOAD_SILENCED_ADS)) and "reload_silenced_is" or "reload_silenced")
	elseif self:GetActivityEnabled(ACT_VM_RELOAD_EMPTY) and self2.ShotgunEmptyAnim and (self:Clip1() == 0 or self:IsJammed()) then
		typev, tanim = self:ChooseAnimation((ads and self:GetActivityEnabled(ACT_VM_RELOAD_EMPTY_ADS)) and "reload_empty_is" or "reload_empty")
	elseif self:GetActivityEnabled(ACT_SHOTGUN_RELOAD_START) then
		typev, tanim = self:ChooseAnimation((ads and self:GetActivityEnabled(ACT_SHOTGUN_RELOAD_START_ADS)) and "reload_shotgun_start_is" or "reload_shotgun_start")
	else
		return false, select(2, self:ChooseIdleAnim())
	end

	return PlayChosenAnimation(self, typev, tanim)
end

function SWEP:ChooseShotgunPumpAnim()
	if not self:VMIV() then return false, 0 end

	typev, tanim = self:ChooseAnimation(
		(self:GetStatL("IronSightsReloadEnabled") and
		self:GetIronSightsDirect() and
		self:GetActivityEnabled(ACT_SHOTGUN_RELOAD_START_ADS)) and "reload_shotgun_finish_is" or "reload_shotgun_finish")

	return PlayChosenAnimation(self, typev, tanim)
end

--[[
Function Name:  ChooseIdleAnim
Syntax: self:ChooseIdleAnim().
Returns:  True,  Which action?
Notes:  Requires autodetection for full features.
Purpose:  Animation / Utility
]]
--
function SWEP:ChooseIdleAnim()
	local self2 = self:GetTable()
	if not self2.VMIV(self) then return false, 0 end
	--if self2.Idle_WithHeld then
	--  self2.Idle_WithHeld = nil
	--  return
	--end

	if TFA.Enum.ShootLoopingStatus[self:GetShootStatus()] and self:ShouldPlayLoopShootAnim() then
		return self:ChooseLoopShootAnim()
	end

	local idleMode = self2.GetStatL(self, "Idle_Mode")

	if idleMode ~= TFA.Enum.IDLE_BOTH and idleMode ~= TFA.Enum.IDLE_ANI then return end

	--self:ResetEvents()
	if self:GetIronSights() then
		local sightsMode = self2.GetStatL(self, "Sights_Mode")

		if sightsMode == TFA.Enum.LOCOMOTION_LUA then
			return self:ChooseFlatAnim()
		else
			return self:ChooseADSAnim()
		end
	elseif self:GetSprinting() and self2.GetStatL(self, "Sprint_Mode") ~= TFA.Enum.LOCOMOTION_LUA then
		return self:ChooseSprintAnim()
	elseif self:GetWalking() and self2.GetStatL(self, "Walk_Mode") ~= TFA.Enum.LOCOMOTION_LUA then
		return self:ChooseWalkAnim()
	elseif self:GetCustomizing() and self2.GetStatL(self, "Customize_Mode") ~= TFA.Enum.LOCOMOTION_LUA then
		return self:ChooseCustomizeAnim()
	end

	if self:GetActivityEnabled(ACT_VM_IDLE_SILENCED) and self2.GetSilenced(self) then
		typev, tanim = self:ChooseAnimation("idle_silenced")
	elseif self:IsEmpty1() then
		--self:GetActivityEnabled( ACT_VM_IDLE_EMPTY ) and (self:Clip1() == 0) then
		if self:GetActivityEnabled(ACT_VM_IDLE_EMPTY) then
			typev, tanim = self:ChooseAnimation("idle_empty")
		else --if not self:GetActivityEnabled( ACT_VM_PRIMARYATTACK_EMPTY ) then
			typev, tanim = self:ChooseAnimation("idle")
		end
	else
		typev, tanim = self:ChooseAnimation("idle")
	end

	--else
	--  return
	--end
	return PlayChosenAnimation(self, typev, tanim)
end

function SWEP:ChooseFlatAnim()
	local self2 = self:GetTable()
	if not self2.VMIV(self) then return false, 0 end
	--self:ResetEvents()
	typev, tanim = self:ChooseAnimation("idle")

	if self:GetActivityEnabled(ACT_VM_IDLE_SILENCED) and self2.GetSilenced(self) then
		typev, tanim = self:ChooseAnimation("idle_silenced")
	elseif self:GetActivityEnabled(ACT_VM_IDLE_EMPTY) and self:IsEmpty1() then
		typev, tanim = self:ChooseAnimation("idle_empty")
	end

	return PlayChosenAnimation(self, typev, tanim, 0.000001)
end

function SWEP:ChooseADSAnim()
	local self2 = self:GetTable()
	if not self2.VMIV(self) then return false, 0 end
	local a, b, c = self:PlayAnimation(self2.GetStatL(self, "IronAnimation.loop"))

	--self:SetNextIdleAnim(CurTime() + 1)
	if not a then
		local _
		_, b, c = self:ChooseFlatAnim()
		a = false
	end

	return a, b, c
end

function SWEP:ChooseSprintAnim()
	return self:PlayAnimation(self:GetStatL("SprintAnimation.loop"))
end

function SWEP:ChooseWalkAnim()
	return self:PlayAnimation(self:GetStatL("WalkAnimation.loop"))
end

function SWEP:ChooseLoopShootAnim()
	return self:PlayAnimation(self:GetStatL("ShootAnimation.loop"))
end

function SWEP:ChooseCustomizeAnim()
	return self:PlayAnimation(self:GetStatL("CustomizeAnimation.loop"))
end

--[[
Function Name:  ChooseShootAnim
Syntax: self:ChooseShootAnim().
Returns:  Could we successfully find an animation?  Which action?
Notes:  Requires autodetection or otherwise the list of valid anims.
Purpose:  Animation / Utility
]]
--
local shouldAnim, shouldBlowback
function SWEP:ChooseShootAnim(ifp)
	local self2 = self:GetTable()
	if ifp == nil then ifp = IsFirstTimePredicted() end
	if not self2.VMIV(self) then return false, 0 end

	if self2.GetStatL(self, "ShootAnimation.loop") and self2.ShouldPlayLoopShootAnim(self) then
		if self2.LuaShellEject and ifp then
			self:EventShell()
		end

		if TFA.Enum.ShootReadyStatus[self:GetShootStatus()] then
			self:SetShootStatus(TFA.Enum.SHOOT_START)

			local inan = self2.GetStatL(self, "ShootAnimation.in")

			if not inan then
				inan = self2.GetStatL(self, "ShootAnimation.loop")
			end

			return self:PlayAnimation(inan)
		end

		return
	end

	local sightsMode = self2.GetStatL(self, "Sights_Mode")

	if self:GetIronSights() and (sightsMode == TFA.Enum.LOCOMOTION_ANI or sightsMode == TFA.Enum.LOCOMOTION_HYBRID) and self2.GetStatL(self, "IronAnimation.shoot") then
		if self2.LuaShellEject and ifp then
			self:EventShell()
		end

		return self:PlayAnimation(self2.GetStatL(self, "IronAnimation.shoot"))
	end

	shouldBlowback = self2.GetStatL(self, "BlowbackEnabled") and (not self2.GetStatL(self, "Blowback_Only_Iron") or self:GetIronSights())
	shouldAnim = not shouldBlowback or self2.GetStatL(self, "BlowbackAllowAnimation")

	if shouldBlowback then
		if sp and SERVER then
			self:CallOnClient("BlowbackFull", "")
		end

		if ifp then
			self:BlowbackFull(ifp)
		end

		if self2.GetStatL(self, "Blowback_Shell_Enabled") and (ifp or sp) then
			self:EventShell()
		end
	end

	if shouldAnim then
		success = true

		if self2.LuaShellEject and (ifp or sp) then
			self:EventShell()
		end

		if self:GetActivityEnabled(ACT_VM_PRIMARYATTACK_SILENCED) and self2.GetSilenced(self) then
			typev, tanim = self:ChooseAnimation("shoot1_silenced")
		elseif self:Clip1() <= self2.Primary_TFA.AmmoConsumption and self:GetActivityEnabled(ACT_VM_PRIMARYATTACK_EMPTY) and self2.Primary_TFA.ClipSize >= 1 and not self2.ForceEmptyFireOff then
			typev, tanim = self:ChooseAnimation("shoot1_last")
		elseif self:Ammo1() <= self2.Primary_TFA.AmmoConsumption and self:GetActivityEnabled(ACT_VM_PRIMARYATTACK_EMPTY) and self2.Primary_TFA.ClipSize < 1 and not self2.ForceEmptyFireOff then
			typev, tanim = self:ChooseAnimation("shoot1_last")
		elseif self:Clip1() == 0 and self:GetActivityEnabled(ACT_VM_DRYFIRE) and not self2.ForceDryFireOff then
			typev, tanim = self:ChooseAnimation("shoot1_empty")
		elseif self2.GetStatL(self, "IsAkimbo") and self:GetActivityEnabled(ACT_VM_SECONDARYATTACK) and ((self:GetAnimCycle() == 0 and not self2.Akimbo_Inverted) or (self:GetAnimCycle() == 1 and self2.Akimbo_Inverted)) then
			typev, tanim = self:ChooseAnimation((self:GetIronSights() and self:GetActivityEnabled(ACT_VM_ISHOOT_M203)) and "shoot2_is" or "shoot2")
		elseif self:GetIronSights() and self:GetActivityEnabled(ACT_VM_PRIMARYATTACK_1) then
			typev, tanim = self:ChooseAnimation("shoot1_is")
		else
			typev, tanim = self:ChooseAnimation("shoot1")
		end

		return PlayChosenAnimation(self, typev, tanim)
	end

	self:SendViewModelAnim(ACT_VM_BLOWBACK)

	return true, ACT_VM_IDLE
end

SWEP.BlowbackRandomAngle = Angle(0, 0, 0) -- not cached, overwritten with each shot

SWEP.BlowbackRandomAngleMin = Angle(.1, -.5, -1)
SWEP.BlowbackRandomAngleMax = Angle(.2, .5, 1)

local minang, maxang

function SWEP:BlowbackFull()
	local self2 = self:GetTable()

	if IsValid(self) then
		self2.BlowbackCurrent = 1
		self2.BlowbackCurrentRoot = 1

		if CLIENT then
			minang, maxang = self2.GetStatL(self, "BlowbackRandomAngleMin"), self2.GetStatL(self, "BlowbackRandomAngleMax")

			self2.BlowbackRandomAngle = Angle(math.Rand(minang.p, maxang.p), math.Rand(minang.y, maxang.y), math.Rand(minang.r, maxang.r))
		end
	end
end

--[[
Function Name:  ChooseSilenceAnim
Syntax: self:ChooseSilenceAnim( true if we're silencing, false for detaching the silencer).
Returns:  Could we successfully find an animation?  Which action?
Notes:  Requires autodetection or otherwise the list of valid anims.  This is played when you silence or unsilence a gun.
Purpose:  Animation / Utility
]]
--
function SWEP:ChooseSilenceAnim(val)
	if not self:VMIV() then return false, 0 end
	--self:ResetEvents()
	typev, tanim = self:ChooseAnimation("idle_silenced")
	success = false

	if val then
		if self:GetActivityEnabled(ACT_VM_ATTACH_SILENCER) then
			typev, tanim = self:ChooseAnimation("silencer_attach")
			success = true
		end
	elseif self:GetActivityEnabled(ACT_VM_DETACH_SILENCER) then
		typev, tanim = self:ChooseAnimation("silencer_detach")
		success = true
	end

	if not success then
		return false, select(2, self:ChooseIdleAnim())
	end

	return PlayChosenAnimation(self, typev, tanim)
end

--[[
Function Name:  ChooseDryFireAnim
Syntax: self:ChooseDryFireAnim().
Returns:  Could we successfully find an animation?  Which action?
Notes:  Requires autodetection or otherwise the list of valid anims.  set SWEP.ForceDryFireOff to false to properly use.
Purpose:  Animation / Utility
]]
--
function SWEP:ChooseDryFireAnim()
	local self2 = self:GetTable()
	if not self2.VMIV(self) then return false, 0 end
	--self:ResetEvents()
	typev, tanim = self:ChooseAnimation("shoot1_empty")
	success = true

	if self:GetActivityEnabled(ACT_VM_DRYFIRE_SILENCED) and self2.GetSilenced(self) and not self2.ForceDryFireOff then
		typev, tanim = self:ChooseAnimation("shoot1_silenced_empty")
		--self:ChooseIdleAnim()
	else
		if self:GetActivityEnabled(ACT_VM_DRYFIRE) and not self2.ForceDryFireOff then
			typev, tanim = self:ChooseAnimation("shoot1_empty")
		else
			success = false
			local _
			_, tanim = nil, nil

			return success, tanim -- ???
		end
	end

	return PlayChosenAnimation(self, typev, tanim)
end

--[[
Function Name:  ChooseROFAnim
Syntax: self:ChooseROFAnim().
Returns:  Could we successfully find an animation?  Which action?
Notes:  Requires autodetection or otherwise the list of valid anims.  Called when we change the firemode.
Purpose:  Animation / Utility
]]
--
function SWEP:ChooseROFAnim()
	local self2 = self:GetTable()
	if not self2.VMIV(self) then return false, 0 end

	--self:ResetEvents()
	if self:GetIronSights() and self:GetActivityEnabled(ACT_VM_IFIREMODE) then
		typev, tanim = self2.ChooseAnimation(self, "rof_is")
		success = true
	elseif self:GetActivityEnabled(ACT_VM_FIREMODE) then
		typev, tanim = self2.ChooseAnimation(self, "rof")
		success = true
	else
		success = false
		local _
		_, tanim = nil, nil

		return success, tanim -- ???
	end

	return PlayChosenAnimation(self, typev, tanim)
end

--[[
Function Name:  ChooseBashAnim
Syntax: self:ChooseBashAnim().
Returns:  Could we successfully find an animation?  Which action?
Notes:  Requires autodetection or otherwise the list of valid anims.  Called when we bash.
Purpose:  Animation / Utility
]]
--
function SWEP:ChooseBashAnim()
	local self2 = self:GetTable()
	if not self2.VMIV(self) then return false, 0 end

	typev, tanim = nil, nil
	success = false

	local isempty = self2.GetStatL(self, "Primary.ClipSize") > 0 and self:Clip1() == 0

	if self2.GetSilenced(self) and self:GetActivityEnabled(ACT_VM_HITCENTER2) then
		if self:GetActivityEnabled(ACT_VM_MISSCENTER2) and isempty then
			typev, tanim = self:ChooseAnimation("bash_empty_silenced")
			success = true
		else
			typev, tanim = self:ChooseAnimation("bash_silenced")
			success = true
		end
	elseif self:GetActivityEnabled(ACT_VM_MISSCENTER) and isempty then
		typev, tanim = self:ChooseAnimation("bash_empty")
		success = true
	elseif self:GetActivityEnabled(ACT_VM_HITCENTER) then
		typev, tanim = self:ChooseAnimation("bash")
		success = true
	end

	if not success then
		return success, tanim
	end

	return PlayChosenAnimation(self, typev, tanim)
end

--[[THIRDPERSON]]
--These holdtypes are used in ironsights.  Syntax:  DefaultHoldType=NewHoldType
SWEP.IronSightHoldTypes = {
	pistol = "revolver",
	smg = "rpg",
	grenade = "melee",
	ar2 = "rpg",
	shotgun = "ar2",
	rpg = "rpg",
	physgun = "physgun",
	crossbow = "ar2",
	melee = "melee2",
	slam = "camera",
	normal = "fist",
	melee2 = "magic",
	knife = "fist",
	duel = "duel",
	camera = "camera",
	magic = "magic",
	revolver = "revolver"
}

--These holdtypes are used while sprinting.  Syntax:  DefaultHoldType=NewHoldType
SWEP.SprintHoldTypes = {
	pistol = "normal",
	smg = "passive",
	grenade = "normal",
	ar2 = "passive",
	shotgun = "passive",
	rpg = "passive",
	physgun = "normal",
	crossbow = "passive",
	melee = "normal",
	slam = "normal",
	normal = "normal",
	melee2 = "melee",
	knife = "fist",
	duel = "normal",
	camera = "slam",
	magic = "normal",
	revolver = "normal"
}

--These holdtypes are used in reloading.  Syntax:  DefaultHoldType=NewHoldType
SWEP.ReloadHoldTypes = {
	pistol = "pistol",
	smg = "smg",
	grenade = "melee",
	ar2 = "ar2",
	shotgun = "shotgun",
	rpg = "ar2",
	physgun = "physgun",
	crossbow = "crossbow",
	melee = "pistol",
	slam = "smg",
	normal = "pistol",
	melee2 = "pistol",
	knife = "pistol",
	duel = "duel",
	camera = "pistol",
	magic = "pistol",
	revolver = "revolver"
}

--These holdtypes are used in reloading.  Syntax:  DefaultHoldType=NewHoldType
SWEP.CrouchHoldTypes = {
	ar2 = "ar2",
	smg = "smg",
	rpg = "ar2"
}

SWEP.IronSightHoldTypeOverride = "" --This variable overrides the ironsights holdtype, choosing it instead of something from the above tables.  Change it to "" to disable.
SWEP.SprintHoldTypeOverride = "" --This variable overrides the sprint holdtype, choosing it instead of something from the above tables.  Change it to "" to disable.
SWEP.ReloadHoldTypeOverride = "" --This variable overrides the reload holdtype, choosing it instead of something from the above tables.  Change it to "" to disable.
local dynholdtypecvar = GetConVar("sv_tfa_holdtype_dynamic")
SWEP.mht_old = ""
local mht

function SWEP:IsOwnerCrouching()
	local ply = self:GetOwner()

	if not ply:IsPlayer() then return false end

	return (ply:Crouching() or self:KeyDown(IN_DUCK)) and ply:OnGround() and not ply:InVehicle()
end

function SWEP:ProcessHoldType()
	local self2 = self:GetTable()
	mht = self2.GetStatL(self, "HoldType", "ar2")

	if mht ~= self2.mht_old or not self2.DefaultHoldType then
		self2.DefaultHoldType = mht
		self2.SprintHoldType = nil
		self2.IronHoldType = nil
		self2.ReloadHoldType = nil
		self2.CrouchHoldType = nil
	end

	self2.mht_old = mht

	if not self2.SprintHoldType then
		self2.SprintHoldType = self2.SprintHoldTypes[self2.DefaultHoldType] or "passive"

		if self2.SprintHoldTypeOverride and self2.SprintHoldTypeOverride ~= "" then
			self2.SprintHoldType = self2.SprintHoldTypeOverride
		end
	end

	if not self2.IronHoldType then
		self2.IronHoldType = self2.IronSightHoldTypes[self2.DefaultHoldType] or "rpg"

		if self2.IronSightHoldTypeOverride and self2.IronSightHoldTypeOverride ~= "" then
			self2.IronHoldType = self2.IronSightHoldTypeOverride
		end
	end

	if not self2.ReloadHoldType then
		self2.ReloadHoldType = self2.ReloadHoldTypes[self2.DefaultHoldType] or "ar2"

		if self2.ReloadHoldTypeOverride and self2.ReloadHoldTypeOverride ~= "" then
			self2.ReloadHoldType = self2.ReloadHoldTypeOverride
		end
	end

	if not self2.SetCrouchHoldType then
		self2.SetCrouchHoldType = true
		self2.CrouchHoldType = self2.CrouchHoldTypes[self2.DefaultHoldType]

		if self2.CrouchHoldTypeOverride and self2.CrouchHoldTypeOverride ~= "" then
			self2.CrouchHoldType = self2.CrouchHoldTypeOverride
		end
	end

	local curhold, targhold, stat
	curhold = self:GetHoldType()
	targhold = self2.DefaultHoldType
	stat = self:GetStatus()

	if dynholdtypecvar:GetBool() then
		if self:OwnerIsValid() and self:IsOwnerCrouching() and self2.CrouchHoldType then
			targhold = self2.CrouchHoldType
		else
			if self:GetIronSights() then
				targhold = self2.IronHoldType
			end

			if TFA.Enum.ReloadStatus[stat] then
				targhold = self2.ReloadHoldType
			end
		end
	end

	if self:GetSprinting() or TFA.Enum.HolsterStatus[stat] or self:IsSafety() then
		targhold = self2.SprintHoldType
	end

	if targhold ~= curhold then
		self:SetHoldType(targhold)
	end
end
--addons/tfa_base/lua/weapons/tfa_gun_base/common/calc.lua:
TFA.GUESS_NPC_WALKSPEED = 160

local function l_Lerp(t, a, b) return a + (b - a) * t end
local function l_mathMin(a, b) return (a < b) and a or b end
local function l_mathMax(a, b) return (a > b) and a or b end
local function l_ABS(a) return (a < 0) and -a or a end
local function l_mathClamp(t, a, b)
	if a > b then return b end

	if t > b then
		return b
	end

	if t < a then
		return a
	end

	return t
end

local function l_mathApproach(a, b, delta)
	if a < b then
		return l_mathMin(a + l_ABS(delta), b)
	else
		return l_mathMax(a - l_ABS(delta), b)
	end
end

local sprint_cv = GetConVar("sv_tfa_sprint_enabled")
local sv_tfa_weapon_weight = GetConVar("sv_tfa_weapon_weight")

function SWEP:TFAFinishMove(ply, velocity, movedata)
	local ft = FrameTime()
	local self2 = self:GetTable()
	local isply = ply:IsPlayer()

	if CLIENT then
		self2.LastUnpredictedVelocity = velocity
	end

	local speedmult = Lerp(self:GetIronSightsProgress(), sv_tfa_weapon_weight:GetBool() and self:GetStatL("RegularMoveSpeedMultiplier") or 1, self:GetStatL("AimingDownSightsSpeedMultiplier"))

	local jr_targ = math.min(math.abs(velocity.z) / 500, 1)
	self:SetJumpRatio(l_mathApproach(self:GetJumpRatio(), jr_targ, (jr_targ - self:GetJumpRatio()) * ft * 20))
	self2.JumpRatio = self:GetJumpRatio()
	self:SetCrouchingRatio(l_mathApproach(self:GetCrouchingRatio(), (self:IsOwnerCrouching()) and 1 or 0, ft / self2.ToCrouchTime))
	self2.CrouchingRatio = self:GetCrouchingRatio()

	local status = self2.GetStatus(self)
	local oldsprinting, oldwalking = self:GetSprinting(), self:GetWalking()
	local vellen = velocity:Length2D()

	--if TFA.Enum.ReloadStatus[status] then
	--  self:SetSprinting(false)
	--elseif sprint_cv:GetBool() and not self:GetStatL("AllowSprintAttack", false) and movedata then
	if sprint_cv:GetBool() and not self:GetStatL("AllowSprintAttack", false) and movedata then
		self:SetSprinting(vellen > ply:GetRunSpeed() * 0.6 * speedmult and movedata:KeyDown(IN_SPEED) and ply:OnGround())
	else
		self:SetSprinting(false)
	end

	self:SetWalking(vellen > ((isply and ply:GetWalkSpeed() or TFA.GUESS_NPC_WALKSPEED) * (sv_tfa_weapon_weight:GetBool() and self:GetStatL("RegularMoveSpeedMultiplier", 1) or 1) * .75) and ply:GetNW2Bool("TFA_IsWalking") and ply:OnGround() and not self:GetSprinting() and not self:GetCustomizing())

	self2.walking_updated = oldwalking ~= self:GetWalking()
	self2.sprinting_updated = oldsprinting ~= self:GetSprinting()

	if self:GetCustomizing() and (self2.GetIronSights(self) or self:GetSprinting() or not TFA.Enum.ReadyStatus[status]) then
		self:ToggleCustomize()
	end

	local spr = self:GetSprinting()
	local walk = self:GetWalking()

	local sprt = spr and 1 or 0
	local walkt = walk and 1 or 0
	local adstransitionspeed = (spr or walk) and 7.5 or 12.5

	self:SetSprintProgress(l_mathApproach(self:GetSprintProgress(), sprt, (sprt - self:GetSprintProgress()) * ft * adstransitionspeed))
	self:SetWalkProgress(l_mathApproach(self:GetWalkProgress(), walkt, (walkt - self:GetWalkProgress()) * ft * adstransitionspeed))

	self:SetLastVelocity(vellen)
end

local sp = game.SinglePlayer()
local sv_tfa_recoil_legacy = GetConVar("sv_tfa_recoil_legacy")

function SWEP:CalculateRatios()
	local owent = self:GetOwner()
	--if not IsValid(owent) or not owent:IsPlayer() then return end
	if not IsValid(owent) then return end

	local self2 = self:GetTable()

	if self2.ratios_calc == nil then
		self2.ratios_calc = true
	end

	local ft = FrameTime()
	local time = CurTime()

	if ft <= 0 then return end

	local is = self2.GetIronSights(self)
	local spr = self2.GetSprinting(self)
	local walk = self2.GetWalking(self)

	local ist = is and 1 or 0
	local sprt = spr and 1 or 0

	local adstransitionspeed
	if is then
		adstransitionspeed = 12.5 / (self:GetStatL("IronSightTime") / 0.3)
	elseif spr or walk then
		adstransitionspeed = 7.5
	else
		adstransitionspeed = 12.5
	end
	adstransitionspeed = math.min(adstransitionspeed, 1000)

	if not owent:IsPlayer() then
		self:TFAFinishMove(owent, owent:GetVelocity())
	end

	local lastshoottime = self2.GetLastGunFire(self, -1)

	if lastshoottime < 0 or time >= (lastshoottime + self2.GetStatL(self, "Primary.SpreadRecoveryDelay")) then
		self:SetSpreadRatio(l_mathClamp(self:GetSpreadRatio() - self2.GetStatL(self, "Primary.SpreadRecovery") * ft, 1, self2.GetStatL(self, "Primary.SpreadMultiplierMax")))
	end

	self:SetIronSightsProgress(l_mathApproach(self:GetIronSightsProgress(), ist, (ist - self:GetIronSightsProgress()) * ft * adstransitionspeed))
	self:SetProceduralHolsterProgress(l_mathApproach(self:GetProceduralHolsterProgress(), sprt, (sprt - self:GetSprintProgress()) * ft * self2.ProceduralHolsterTime * 15))
	self:SetInspectingProgress(l_mathApproach(self:GetInspectingProgress(), self:GetCustomizing() and 1 or 0, ((self:GetCustomizing() and 1 or 0) - self:GetInspectingProgress()) * ft * 10))

	if self:GetRecoilThink() then
		if self:GetRecoilLoop() then
			-- loop or after loop

			if self:GetRecoilLoopWait() < time then
				self:SetRecoilOutProgress(l_mathMin(1, self:GetRecoilOutProgress() + ft / self2.Primary_TFA.RecoilLUT["out"].cooldown_speed))

				if self:GetRecoilOutProgress() == 1 then
					self:SetRecoilThink(false)
					self:SetRecoilLoop(false)
					self:SetRecoilLoopProgress(0)
					self:SetRecoilInProgress(0)
					self:SetRecoilOutProgress(0)
				end
			end
		else
			-- IN only

			if self:GetRecoilInWait() < time then
				self:SetRecoilInProgress(l_mathMax(0, self:GetRecoilInProgress() - ft / self2.Primary_TFA.RecoilLUT["in"].cooldown_speed))

				if self:GetRecoilInProgress() == 0 then
					self:SetRecoilThink(false)
				end
			end
		end
	end

	if not sv_tfa_recoil_legacy:GetBool() then
		ft = l_mathClamp(ft, 0, 1)
		self:SetViewPunchBuild(l_mathMax(0, self:GetViewPunchBuild() - self:GetViewPunchBuild() * ft))
		local build = l_mathMax(0, 4.5 - self:GetViewPunchBuild())
		ft = ft * build * build
		self:SetViewPunchP(self:GetViewPunchP() - self:GetViewPunchP() * ft)
		self:SetViewPunchY(self:GetViewPunchY() - self:GetViewPunchY() * ft)
	end

	self2.SpreadRatio = self:GetSpreadRatio()
	self2.IronSightsProgress = self:GetIronSightsProgress()
	self2.SprintProgress = self:GetSprintProgress()
	self2.WalkProgress = self:GetWalkProgress()
	self2.ProceduralHolsterProgress = self:GetProceduralHolsterProgress()
	self2.InspectingProgress = self:GetInspectingProgress()

	if sp and CLIENT then
		self2.Inspecting = self:GetCustomizing() --compatibility
	end

	self2.CLIronSightsProgress = self:GetIronSightsProgress() --compatibility
end

SWEP.Primary.IronRecoilMultiplier = 0.5 --Multiply recoil by this factor when we're in ironsights.  This is proportional, not inversely.
SWEP.CrouchRecoilMultiplier = 0.65 --Multiply recoil by this factor when we're crouching.  This is proportional, not inversely.
SWEP.JumpRecoilMultiplier = 1.3 --Multiply recoil by this factor when we're crouching.  This is proportional, not inversely.
SWEP.WallRecoilMultiplier = 1.1 --Multiply recoil by this factor when we're changing state e.g. not completely ironsighted.  This is proportional, not inversely.
SWEP.ChangeStateRecoilMultiplier = 1.3 --Multiply recoil by this factor when we're crouching.  This is proportional, not inversely.
SWEP.CrouchAccuracyMultiplier = 0.5 --Less is more.  Accuracy * 0.5 = Twice as accurate, Accuracy * 0.1 = Ten times as accurate
SWEP.ChangeStateAccuracyMultiplier = 1.5 --Less is more.  A change of state is when we're in the progress of doing something, like crouching or ironsighting.  Accuracy * 2 = Half as accurate.  Accuracy * 5 = 1/5 as accurate
SWEP.JumpAccuracyMultiplier = 2 --Less is more.  Accuracy * 2 = Half as accurate.  Accuracy * 5 = 1/5 as accurate
SWEP.WalkAccuracyMultiplier = 1.35 --Less is more.  Accuracy * 2 = Half as accurate.  Accuracy * 5 = 1/5 as accurate
SWEP.ToCrouchTime = 0.25

local mult_cvar = GetConVar("sv_tfa_spread_multiplier")
local dynacc_cvar = GetConVar("sv_tfa_dynamicaccuracy")
local ccon, crec

SWEP.JumpRatio = 0

function SWEP:CalculateConeRecoil()
	local dynacc = false
	local self2 = self:GetTable()
	local isr = self:GetIronSightsProgress()

	if dynacc_cvar:GetBool() and (self2.GetStatL(self, "Primary.NumShots") <= 1) then
		dynacc = true
	end

	local isr_1 = l_mathClamp(isr * 2, 0, 1)
	local isr_2 = l_mathClamp((isr - 0.5) * 2, 0, 1)
	local acv = self2.GetStatL(self, "Primary.Spread") or self2.GetStatL(self, "Primary.Accuracy")
	local recv = self2.GetStatL(self, "Primary.Recoil") * 5

	if dynacc then
		ccon = l_Lerp(isr_2, l_Lerp(isr_1, acv, acv * self2.GetStatL(self, "ChangeStateAccuracyMultiplier")), self2.GetStatL(self, "Primary.IronAccuracy"))
		crec = l_Lerp(isr_2, l_Lerp(isr_1, recv, recv * self2.GetStatL(self, "ChangeStateRecoilMultiplier")), recv * self2.GetStatL(self, "Primary.IronRecoilMultiplier"))
	else
		ccon = l_Lerp(isr, acv, self2.GetStatL(self, "Primary.IronAccuracy"))
		crec = l_Lerp(isr, recv, recv * self2.GetStatL(self, "Primary.IronRecoilMultiplier"))
	end

	local crc_1 = l_mathClamp(self:GetCrouchingRatio() * 2, 0, 1)
	local crc_2 = l_mathClamp((self:GetCrouchingRatio() - 0.5) * 2, 0, 1)

	if dynacc then
		ccon = l_Lerp(crc_2, l_Lerp(crc_1, ccon, ccon * self2.GetStatL(self, "ChangeStateAccuracyMultiplier")), ccon * self2.GetStatL(self, "CrouchAccuracyMultiplier"))
		crec = l_Lerp(crc_2, l_Lerp(crc_1, crec, self2.GetStatL(self, "Primary.Recoil") * self2.GetStatL(self, "ChangeStateRecoilMultiplier")), crec * self2.GetStatL(self, "CrouchRecoilMultiplier"))
	end

	local owner = self:GetOwner()
	local isply = owner:IsPlayer()
	local ovel

	if IsValid(owner) then
		if owner:IsPlayer() then
			ovel = self:GetLastVelocity()
		else
			ovel = owner:GetVelocity():Length2D()
		end
	else
		ovel = 0
	end

	local vfc_1 = l_mathClamp(ovel / (isply and owner:GetWalkSpeed() or TFA.GUESS_NPC_WALKSPEED), 0, 2)

	if dynacc then
		ccon = l_Lerp(vfc_1, ccon, ccon * self2.GetStatL(self, "WalkAccuracyMultiplier"))
		crec = l_Lerp(vfc_1, crec, crec * self2.GetStatL(self, "WallRecoilMultiplier"))
	end

	local jr = self:GetJumpRatio()

	if dynacc then
		ccon = l_Lerp(jr, ccon, ccon * self2.GetStatL(self, "JumpAccuracyMultiplier"))
		crec = l_Lerp(jr, crec, crec * self2.GetStatL(self, "JumpRecoilMultiplier"))
	end

	ccon = ccon * self:GetSpreadRatio()

	if mult_cvar then
		ccon = ccon * mult_cvar:GetFloat()
	end

	if not isply and IsValid(owner) then
		local prof = owner:GetCurrentWeaponProficiency()

		if prof == WEAPON_PROFICIENCY_POOR then
			ccon = ccon * 8
		elseif prof == WEAPON_PROFICIENCY_AVERAGE then
			ccon = ccon * 5
		elseif prof == WEAPON_PROFICIENCY_GOOD then
			ccon = ccon * 3
		elseif prof == WEAPON_PROFICIENCY_VERY_GOOD then
			ccon = ccon * 2
		elseif prof == WEAPON_PROFICIENCY_PERFECT then
			ccon = ccon * 1.5
		end
	end

	return ccon, crec
end

--addons/tfa_base/lua/weapons/tfa_gun_base/common/akimbo.lua:
SWEP.AnimCycle = SWEP.ViewModelFlip and 0 or 1

function SWEP:FixAkimbo()
	if not self:GetStatL("IsAkimbo") or self.Secondary_TFA.ClipSize <= 0 then return end

	self.Primary_TFA.ClipSize = self.Primary_TFA.ClipSize + self.Secondary_TFA.ClipSize
	self.Secondary_TFA.ClipSize = -1
	self.Primary_TFA.RPM = self.Primary_TFA.RPM * 2
	self.Akimbo_Inverted = self.ViewModelFlip
	self:ResetAnimCycle()
	self:ClearStatCache()

	timer.Simple(FrameTime(), function()
		timer.Simple(0.01, function()
			if IsValid(self) and self:OwnerIsValid() then
				self:SetClip1(self.Primary_TFA.ClipSize)
			end
		end)
	end)
end

function SWEP:ResetAnimCycle()
	self:SetAnimCycle(self.Akimbo_Inverted and 0 or 1)
	self.AnimCycle = self:GetAnimCycle()
end

function SWEP:ToggleAkimbo(arg1)
	if self:GetStatL("IsAkimbo") then
		self:SetAnimCycle(1 - self:GetAnimCycle())
		self.AnimCycle = self:GetAnimCycle()
	end
end

--addons/tfa_base/lua/weapons/tfa_gun_base/common/events.lua:
local lshift = bit.lshift
local band = bit.band
local bor = bit.bor

local sp = game.SinglePlayer()
local l_CT = CurTime

local is, spr, wlk, cst

--[[
Function Name:  ResetEvents
Syntax: self:ResetEvents()
Returns:  Nothing.
Purpose:  Cleans up events table.
]]--
function SWEP:ResetEvents()
	self:SetEventStatus1(0x00000000)
	self:SetEventStatus2(0x00000000)
	self:SetEventStatus3(0x00000000)
	self:SetEventStatus4(0x00000000)
	self:SetEventStatus5(0x00000000)
	self:SetEventStatus6(0x00000000)
	self:SetEventStatus7(0x00000000)
	self:SetEventStatus8(0x00000000)

	self:SetEventTimer(l_CT())
	-- self:SetFirstDeployEvent(false)

	if self.EventTable then
		for _, eventtable in pairs(self.EventTable) do
			for i = 1, #eventtable do
				eventtable[i].called = false
			end
		end
	end

	if self.event_table_overflow then
		local editcts = self.EventTableEdict

		if editcts[0] then
			editcts[0].called = false

			for i = 1, #editcts do
				editcts[i].called = false
			end
		end
	end

	if sp then
		self:CallOnClient("ResetEvents", "")
	end
end

function SWEP:GetEventPlayed(event_slot)
	if self.event_table_overflow then
		return assert(self.EventTableEdict[event_slot], string.format("Unknown event %d", event_slot)).called
	end

	local inner_index = event_slot % 32
	local outer_index = (event_slot - inner_index) / 32 + 1
	local lindex = lshift(1, inner_index)
	return band(self.get_event_status_lut[outer_index](self), lindex) ~= 0, inner_index, outer_index, lindex
end

function SWEP:SetEventPlayed(event_slot)
	if self.event_table_overflow then
		assert(self.EventTableEdict[event_slot], string.format("Unknown event %d", event_slot)).called = true
		return
	end

	local inner_index = event_slot % 32
	local outer_index = (event_slot - inner_index) / 32 + 1
	local lindex = lshift(1, inner_index)

	self.set_event_status_lut[outer_index](self, bor(self.get_event_status_lut[outer_index](self), lindex))
	return inner_index, outer_index, lindex
end

--[[
Function Name:  ProcessEvents
Syntax: self:ProcessEvents().
Returns:  Nothing.
Notes: Critical for the event table to function.
Purpose:  Main SWEP function
]]--

SWEP._EventSlotCount = 0
SWEP.EventTableEdict = {}

function SWEP:DispatchLuaEvent(arg)
	if not self.event_table_built then
		self:RebuildEventEdictTable()
	end

	local fn = assert(assert(self.EventTableEdict[tonumber(arg)], "No such event with edict " .. arg).value, "Event is missing a function to call")
	assert(isfunction(fn), "Event " .. arg .. " is not a Lua event")
	fn(self, self:VMIV(), true)
end

function SWEP:DispatchBodygroupEvent(arg)
	if not self.event_table_built then
		self:RebuildEventEdictTable()
	end

	local event = assert(self.EventTableEdict[tonumber(arg)], "No such event with edict " .. arg)
	assert(isstring(event.name), "Event " .. arg .. " is missing bodygroup name to set")
	assert(isstring(event.value), "Event " .. arg .. " is missing bodygroup value to set")

	if event.view then
		self.ViewModelBodygroups[event.name] = event.value
	end

	if event.world then
		self.WorldModelBodygroups[event.name] = event.value
	end
end

local isstring = isstring

local function eventtablesorter(a, b)
	local sa, sb = isstring(a), isstring(b)

	if sa and not sb or not sa and sb then
		if sa then
			return false
		end

		return true
	end

	return a < b
end

function SWEP:RebuildEventEdictTable()
	local self2 = self:GetTable()
	local slot = 0

	for i = #self2.EventTableEdict, 0, -1 do
		self2.EventTableEdict[i] = nil
	end

	self:ResetEvents()

	local eventtable = self2.EventTable
	eventtable.BaseClass = nil

	local keys = table.GetKeys(eventtable)
	table.sort(keys, eventtablesorter)

	for _, key in ipairs(keys) do
		local value = eventtable[key]

		if istable(value) then
			for _, event in SortedPairs(value) do
				if istable(event) then
					event.slot = slot
					slot = slot + 1

					if not event.autodetect then
						if event.type == "lua" then
							if event.server == nil then
								event.server = true
							end
						elseif event.type == "snd" or event.type == "sound" then
							if event.server == nil then
								event.server = false
							end
						elseif event.type == "bg" or event.type == "bodygroup" then
							if event.server == nil then event.server = true end
							if event.view == nil then event.view = true end
							if event.world == nil then event.world = true end
						end

						if event.client == nil then
							event.client = true
						end

						event.autodetect = true
					end

					event.called = false

					if slot > 256 and not self.event_table_warning then
						ErrorNoHalt("[TFA Base] Weapon " .. self:GetClass() .. " got too many events! 256 is maximum! Event table would NOT be properly predicted this time!\n")
						self.event_table_warning = true
					end

					self2.EventTableEdict[event.slot] = event
				end
			end
		end
	end

	self.event_table_overflow = slot > 256
	self._built_event_debug_string_fn = nil

	self._EventSlotCount = math.ceil(slot / 32)
	self._EventSlotNum = slot - 1
	self.event_table_built = true
end

function SWEP:ProcessEvents(firstprediction)
	local viewmodel = self:VMIVNPC()
	if not viewmodel then return end

	if not self.event_table_built then
		self:RebuildEventEdictTable()
	end

	if sp and CLIENT then return end
	if sp and SERVER then return self:ProcessEventsSP() end

	local ply = self:GetOwner()
	local isplayer = ply:IsPlayer()

	local evtbl = self.EventTable[self:GetLastActivity() or -1] or self.EventTable[viewmodel:GetSequenceName(viewmodel:GetSequence())]
	if not evtbl then return end

	local curtime = l_CT()
	local eventtimer = self:GetEventTimer()
	local is_local = CLIENT and ply == LocalPlayer()
	local animrate = self:GetAnimationRate(self:GetLastActivity() or -1)

	self.current_event_iftp = firstprediction
	self.processing_events = true

	for i = 1, #evtbl do
		local event = evtbl[i]
		if self:GetEventPlayed(event.slot) or curtime < eventtimer + event.time / animrate then goto CONTINUE end
		self:SetEventPlayed(event.slot)
		event.called = true

		if not event.autodetect then
			if event.type == "lua" then
				if event.server == nil then
					event.server = true
				end
			elseif event.type == "snd" or event.type == "sound" then
				if event.server == nil then
					event.server = false
				end
			elseif event.type == "bg" or event.type == "bodygroup" then
				if event.server == nil then event.server = true end
				if event.view == nil then event.view = true end
				if event.world == nil then event.world = true end
			end

			if event.client == nil then
				event.client = true
			end

			event.autodetect = true
		end

		if event.type == "lua" then
			if ((event.client and CLIENT and (not event.client_predictedonly or is_local)) or (event.server and SERVER)) and event.value then
				event.value(self, viewmodel, firstprediction)
			end
		elseif event.type == "snd" or event.type == "sound" then
			if SERVER then
				if event.client then
					if not isplayer and player.GetCount() ~= 0 then
						net.Start("tfaSoundEvent", true)
						net.WriteEntity(self)
						net.WriteString(event.value or "")
						net.WriteBool(event.shouldpause or false)
						net.SendPVS(self:GetPos())
					elseif isplayer then
						net.Start("tfaSoundEvent", true)
						net.WriteEntity(self)
						net.WriteString(event.value or "")
						net.WriteBool(event.shouldpause or false)
						net.SendOmit(ply)
					end
				elseif event.server and event.value and event.value ~= "" then
					self:EmitSound(event.value)
				end
			elseif event.client and is_local and not sp and event.value and event.value ~= "" then
				if firstprediction or firstprediction == nil then
					if event.time <= 0.01 then
						self:EmitSoundSafe(event.value)
					else
						self:EmitSound(event.value)
					end
				end
			end
		elseif event.type == "bg" or event.type == "bodygroup" then
			if ((event.client and CLIENT and (not event.client_predictedonly or is_local)) or
				(event.server and SERVER)) and (event.name and event.value and event.value ~= "") then

				if event.view then
					self.ViewModelBodygroups[event.name] = event.value
				end

				if event.world then
					self.WorldModelBodygroups[event.name] = event.value
				end
			end
		end

		::CONTINUE::
	end

	self.processing_events = false
	self.current_event_iftp = nil
end

-- This function is exclusively targeting singleplayer
function SWEP:ProcessEventsSP(firstprediction)
	local viewmodel = self:VMIVNPC()
	if not viewmodel then return end

	local evtbl = self.EventTable[self:GetLastActivity() or -1] or self.EventTable[viewmodel:GetSequenceName(viewmodel:GetSequence())]
	if not evtbl then return end

	local curtime = l_CT()
	local eventtimer = self:GetEventTimer()
	local is_local = self:GetOwner() == Entity(1)
	local animrate = self:GetAnimationRate(self:GetLastActivity() or -1)

	self.processing_events = true

	for i = 1, #evtbl do
		local event = evtbl[i]
		if self:GetEventPlayed(event.slot) or curtime < eventtimer + event.time / animrate then goto CONTINUE end
		self:SetEventPlayed(event.slot)
		event.called = true

		if not event.autodetect then
			if event.type == "lua" then
				if event.server == nil then
					event.server = true
				end
			elseif event.type == "snd" or event.type == "sound" then
				if event.server == nil then
					event.server = false
				end
			elseif event.type == "bg" or event.type == "bodygroup" then
				if event.server == nil then event.server = true end
				if event.view == nil then event.view = true end
				if event.world == nil then event.world = true end
			end

			if event.client == nil then
				event.client = true
			end

			event.autodetect = true
		end

		if event.type == "lua" then
			if event.value then
				if event.server then
					event.value(self, viewmodel, true)
				end

				if event.client and (not event.client_predictedonly or is_local) then
					self:CallOnClient("DispatchLuaEvent", tostring(event.slot))
				end
			end
		elseif event.type == "snd" or event.type == "sound" then
			if event.client then
				net.Start("tfaSoundEvent", true)
				net.WriteEntity(self)
				net.WriteString(event.value or "")
				net.WriteBool(event.shouldpause or false)
				net.Broadcast()
			elseif event.server and event.value and event.value ~= "" then
				self:EmitSound(event.value)
			end
		elseif event.type == "bg" or event.type == "bodygroup" then
			if event.name and event.value and event.value ~= "" then
				if event.server then
					if event.view then
						self.ViewModelBodygroups[event.name] = event.value
					end

					if event.world then
						self.WorldModelBodygroups[event.name] = event.value
					end
				end

				if event.client and (not event.client_predictedonly or is_local) then
					self:CallOnClient("DispatchBodygroupEvent", tostring(event.slot))
				end
			end
		end

		::CONTINUE::
	end

	self.processing_events = false
end

function SWEP:EmitSoundSafe(snd)
	timer.Simple(0, function()
		if IsValid(self) and snd then self:EmitSound(snd) end
	end)
end

local ct, stat, statend, finalstat, waittime, lact

function SWEP:ProcessStatus()
	local self2 = self:GetTable()

	is = self2.GetIronSightsRaw(self)
	spr = self2.GetSprinting(self)
	wlk = self2.GetWalking(self)
	cst = self2.GetCustomizing(self)

	local ply = self:GetOwner()
	local isplayer = ply:IsPlayer()

	if stat == TFA.Enum.STATUS_FIDGET and is then
		self:SetStatusEnd(0)

		self2.Idle_Mode_Old = self2.Idle_Mode
		self2.Idle_Mode = TFA.Enum.IDLE_BOTH
		self2.ClearStatCache(self, "Idle_Mode")
		self2.ChooseIdleAnim(self)

		if sp then
			self:CallOnClient("ChooseIdleAnim", "")
		end

		self2.Idle_Mode = self2.Idle_Mode_Old
		self2.ClearStatCache(self, "Idle_Mode")
		self2.Idle_Mode_Old = nil
		statend = -1
	end

	is = self:GetIronSights()
	stat = self:GetStatus()
	statend = self:GetStatusEnd()

	ct = l_CT()

	if stat ~= TFA.Enum.STATUS_IDLE and ct > statend then
		self:SetFirstDeployEvent(false)
		finalstat = TFA.Enum.STATUS_IDLE

		--Holstering
		if stat == TFA.Enum.STATUS_HOLSTER then
			finalstat = TFA.Enum.STATUS_HOLSTER_READY
			self:SetStatusEnd(ct)
		elseif stat == TFA.Enum.STATUS_HOLSTER_READY then
			self2.FinishHolster(self)
			finalstat = TFA.Enum.STATUS_HOLSTER_FINAL
			self:SetStatusEnd(ct + 0.6)
		elseif stat == TFA.Enum.STATUS_RELOADING_LOOP_START_EMPTY then
			--Shotgun Reloading from empty
			if not self2.IsJammed(self) then
				self2.InsertPrimaryAmmo(self, self2.GetStatL(self, "LoopedReloadInsertAmount", 1))
			end

			if self2.Ammo1(self) <= 0 or self:Clip1() >= self2.GetPrimaryClipSize(self) or self:GetReloadLoopCancel() then
				finalstat = TFA.Enum.STATUS_RELOADING_LOOP_END
				local _, tanim, ttype = self2.ChooseShotgunPumpAnim(self)
				self:SetStatusEnd(ct + self2.GetActivityLength(self, tanim, false, ttype))
				self:SetReloadLoopCancel(false)

				if not self:GetReloadLoopCancel() then
					self:SetJammed(false)
				end
			else
				lact = self:GetLastActivity()
				waittime = self2.GetActivityLength(self, lact, false) - self2.GetActivityLength(self, lact, true)

				if waittime > 0.01 then
					finalstat = TFA.Enum.STATUS_RELOADING_WAIT
					self:SetStatusEnd(ct + waittime)
				else
					finalstat = self2.LoadShell(self)
				end

				self:SetJammed(false)
				--finalstat = self:LoadShell()
				--self:SetStatusEnd( self:GetNextPrimaryFire() )
			end
		elseif stat == TFA.Enum.STATUS_RELOADING_LOOP_START then
			--Shotgun Reloading
			finalstat = self2.LoadShell(self)
		elseif stat == TFA.Enum.STATUS_RELOADING_LOOP then
			self2.InsertPrimaryAmmo(self, self2.GetStatL(self, "LoopedReloadInsertAmount", 1))
			lact = self:GetLastActivity()

			if self2.GetActivityLength(self, lact, true) < self2.GetActivityLength(self, lact, false) - 0.01 then
				local sht = self2.GetStatL(self, "LoopedReloadInsertTime")

				if sht then
					sht = sht / self2.GetAnimationRate(self, ACT_VM_RELOAD)
				end

				waittime = (sht or self2.GetActivityLength(self, lact, false)) - self2.GetActivityLength(self, lact, true)
			else
				waittime = 0
			end

			if waittime > 0.01 then
				finalstat = TFA.Enum.STATUS_RELOADING_WAIT
				self:SetStatusEnd(ct + waittime)
			else
				if self2.Ammo1(self) <= 0 or self:Clip1() >= self:GetPrimaryClipSize() or self:GetReloadLoopCancel() then
					finalstat = TFA.Enum.STATUS_RELOADING_LOOP_END
					local _, tanim, ttype = self2.ChooseShotgunPumpAnim(self)
					self:SetStatusEnd(ct + self2.GetActivityLength(self, tanim, false, ttype))
					self:SetReloadLoopCancel(false)
				else
					finalstat = self2.LoadShell(self)
				end
			end
		elseif stat == TFA.Enum.STATUS_RELOADING then
			self2.CompleteReload(self)
			lact = self:GetLastActivity()
			waittime = self2.GetActivityLength(self, lact, false) - self2.GetActivityLength(self, lact, true)

			if waittime > 0.01 then
				finalstat = TFA.Enum.STATUS_RELOADING_WAIT
				self:SetStatusEnd(ct + waittime)
			end
		elseif stat == TFA.Enum.STATUS_SILENCER_TOGGLE then
			--self:SetStatusEnd( self:GetNextPrimaryFire() )
			self:SetSilenced(not self:GetSilenced())
			self2.Silenced = self:GetSilenced()
		elseif stat == TFA.Enum.STATUS_RELOADING_WAIT and self:GetStatL("LoopedReload") then
			if self2.Ammo1(self) <= 0 or self:Clip1() >= self:GetPrimaryClipSize() or self:GetReloadLoopCancel() then
				finalstat = TFA.Enum.STATUS_RELOADING_LOOP_END
				local _, tanim, ttype = self2.ChooseShotgunPumpAnim(self)
				self:SetStatusEnd(ct + self2.GetActivityLength(self, tanim, false, ttype))
				--self:SetReloadLoopCancel( false )
			else
				finalstat = self2.LoadShell(self)
			end
		elseif stat == TFA.Enum.STATUS_RELOADING_LOOP_END and self:GetStatL("LoopedReload") then
			self:SetReloadLoopCancel(false)
		elseif self2.GetStatL(self, "PumpAction") and stat == TFA.Enum.STATUS_PUMP then
			self:SetReloadLoopCancel(false)
		elseif stat == TFA.Enum.STATUS_SHOOTING and self2.GetStatL(self, "PumpAction") then
			if self:Clip1() == 0 and self2.GetStatL(self, "PumpAction").value_empty then
				--finalstat = TFA.Enum.STATUS_PUMP_READY
				self:SetReloadLoopCancel(true)
			elseif (self2.GetStatL(self, "Primary.ClipSize") < 0 or self:Clip1() > 0) and self2.GetStatL(self, "PumpAction").value then
				--finalstat = TFA.Enum.STATUS_PUMP_READY
				self:SetReloadLoopCancel(true)
			end
		end

		--self:SetStatusEnd( math.huge )
		self:SetStatus(finalstat)

		local sightsMode = self2.GetStatL(self, "Sights_Mode")
		local sprintMode = self2.GetStatL(self, "Sprint_Mode")
		local walkMode = self2.GetStatL(self, "Walk_Mode")
		local customizeMode = self2.GetStatL(self, "Customize_Mode")

		local smi = sightsMode ~= TFA.Enum.LOCOMOTION_LUA
		local spi = sprintMode ~= TFA.Enum.LOCOMOTION_LUA
		local wmi = walkMode ~= TFA.Enum.LOCOMOTION_LUA
		local cmi = customizeMode ~= TFA.Enum.LOCOMOTION_LUA

		if
			not TFA.Enum.ReadyStatus[stat] and
			stat ~= TFA.Enum.STATUS_SHOOTING and
			stat ~= TFA.Enum.STATUS_PUMP and
			finalstat == TFA.Enum.STATUS_IDLE and
			((smi or spi) or (cst and cmi))
		then
			is = self2.GetIronSights(self, true)

			if (is and smi) or (spr and spi) or (wlk and wmi) or (cst and cmi) then
				local success, _ = self2.Locomote(self, is and smi, is, spr and spi, spr, wlk and wmi, wlk, cst and cmi, cst)

				if success == false then
					self:SetNextIdleAnim(-1)
				else
					self:SetNextIdleAnim(math.max(self:GetNextIdleAnim(), ct + 0.1))
				end
			end
		end

		self2.LastBoltShoot = nil

		if self:GetBurstCount() > 0 then
			if finalstat ~= TFA.Enum.STATUS_SHOOTING and finalstat ~= TFA.Enum.STATUS_IDLE then
				self:SetBurstCount(0)
			elseif self:GetBurstCount() < self:GetMaxBurst() and self:Clip1() > 0 then
				self:PrimaryAttack()
			else
				self:SetBurstCount(0)
				self:SetNextPrimaryFire(self2.GetNextCorrectedPrimaryFire(self, self2.GetBurstDelay(self)))
			end
		end
	end

	--if stat == TFA.Enum.STATUS_IDLE and self:GetReloadLoopCancel() and (self2.GetStatL(self, "AllowSprintAttack") or self:GetSprintProgress() < 0.1) then
	if stat == TFA.Enum.STATUS_IDLE and self:GetReloadLoopCancel() then
		if self2.GetStatL(self, "PumpAction") then
			if ct > self:GetNextPrimaryFire() and not self:KeyDown(IN_ATTACK) then
				self2.DoPump(self)
			end
		else
			self:SetReloadLoopCancel(false)
		end
	end
end

--addons/tfa_base/lua/weapons/tfa_gun_base/common/skins.lua:
SWEP.MaterialTable = {}
SWEP.MaterialTable_V = {}
SWEP.MaterialTable_W = {}

function SWEP:InitializeMaterialTable()
	if not self.HasSetMaterialMeta then
		setmetatable(self.MaterialTable_V, {
			["__index"] = function(t,k) return self:GetStatL("MaterialTable")[k] end
		})

		setmetatable(self.MaterialTable_W, {
			["__index"] = function(t,k) return self:GetStatL("MaterialTable")[k] end
		})

		self.HasSetMaterialMeta = true
	end
end

--if both nil then we can just clear it all
function SWEP:ClearMaterialCache(view, world)
	if view == nil and world == nil then
		self.MaterialCached_V = nil
		self.MaterialCached_W = nil
		self.MaterialCached = nil
		self.SCKMaterialCached_V = nil
		self.SCKMaterialCached_W = nil
	else
		if view then
			self.MaterialCached_V = nil
			self.SCKMaterialCached_V = nil
		end

		if world then
			self.MaterialCached_W = nil
			self.SCKMaterialCached_W = nil
		end
	end
end

if SERVER then TFA.SWEP_LOAD_COMPLETE = true end
--addons/tfa_base/lua/weapons/tfa_gun_base/client/hud.lua:
if IsValid(TFA.INSPECTIONPANEL) then TFA.INSPECTIONPANEL:Remove() end

local l_CT = CurTime

local CMIX_MULT = 1
local c1t = {}
local c2t = {}

local function ColorMix(c1, c2, fac, t)
	c1 = c1 or color_white
	c2 = c2 or color_white
	c1t.r = c1.r
	c1t.g = c1.g
	c1t.b = c1.b
	c1t.a = c1.a
	c2t.r = c2.r
	c2t.g = c2.g
	c2t.b = c2.b
	c2t.a = c2.a

	for k, v in pairs(c1t) do
		if t == CMIX_MULT then
			c1t[k] = Lerp(fac, v, (c1t[k] / 255 * c2t[k] / 255) * 255)
		else
			c1t[k] = Lerp(fac, v, c2t[k])
		end
	end

	return Color(c1t.r, c1t.g, c1t.b, c1t.a)
end



local cv_red_r, cv_red_g, cv_red_b = GetConVar("cl_tfa_hud_crosshair_color_enemy_r"), GetConVar("cl_tfa_hud_crosshair_color_enemy_g"), GetConVar("cl_tfa_hud_crosshair_color_enemy_b")
local c_red = Color(cv_red_r:GetInt(), cv_red_g:GetInt(), cv_red_b:GetInt(), 255)

local function UpdateEnemyTeamColor()
	c_red.r = cv_red_r:GetInt()
	c_red.g = cv_red_g:GetInt()
	c_red.b = cv_red_b:GetInt()
end
cvars.AddChangeCallback(cv_red_r:GetName(), UpdateEnemyTeamColor, "c_red")
cvars.AddChangeCallback(cv_red_g:GetName(), UpdateEnemyTeamColor, "c_red")
cvars.AddChangeCallback(cv_red_b:GetName(), UpdateEnemyTeamColor, "c_red")



local cv_grn_r, cv_grn_g, cv_grn_b = GetConVar("cl_tfa_hud_crosshair_color_friendly_r"), GetConVar("cl_tfa_hud_crosshair_color_friendly_g"), GetConVar("cl_tfa_hud_crosshair_color_friendly_b")
local c_grn = Color(cv_grn_r:GetInt(), cv_grn_g:GetInt(), cv_grn_b:GetInt(), 255)

local function UpdateFriendlyTeamColor()
	c_grn.r = cv_grn_r:GetInt()
	c_grn.g = cv_grn_g:GetInt()
	c_grn.b = cv_grn_b:GetInt()
end
cvars.AddChangeCallback(cv_grn_r:GetName(), UpdateFriendlyTeamColor, "c_grn")
cvars.AddChangeCallback(cv_grn_g:GetName(), UpdateFriendlyTeamColor, "c_grn")
cvars.AddChangeCallback(cv_grn_b:GetName(), UpdateFriendlyTeamColor, "c_grn")



local cl_xhair_teamcolorcvar, sv_xhair_showplayercvar, sv_xhair_showplayerteamcvar

local GetNPCDisposition = TFA.GetNPCDisposition
local GameModeTeamBased = GAMEMODE.TeamBased

function SWEP:GetTeamColor(ent)
	if not cl_xhair_teamcolorcvar then
		cl_xhair_teamcolorcvar = GetConVar("cl_tfa_hud_crosshair_color_team")
	end

	if not sv_xhair_showplayercvar then
		sv_xhair_showplayercvar = GetConVar("sv_tfa_crosshair_showplayer")
	end

	if not sv_xhair_showplayerteamcvar then
		sv_xhair_showplayerteamcvar = GetConVar("sv_tfa_crosshair_showplayerteam")
	end

	if not cl_xhair_teamcolorcvar:GetBool() then return color_white end

	local ply = LocalPlayer()
	if not IsValid(ply) then return color_white end

	if ent:IsPlayer() then
		if not sv_xhair_showplayercvar:GetBool() then return color_white end

		if GameModeTeamBased and sv_xhair_showplayerteamcvar:GetBool() then
			if ent:Team() == ply:Team() then
				return c_grn
			else
				return c_red
			end
		end

		return c_red
	end

	if ent:IsNPC() then
		local disp = GetNPCDisposition(ent) or ent:GetNW2Int("tfa_disposition", -1)

		if disp > 0 then
			if disp == (D_FR or 2) or disp == (D_HT or 1) then
				return c_red
			else
				return c_grn
			end
		end

		if IsFriendEntityName(ent:GetClass()) then
			return c_grn
		else
			return c_red
		end
	end

	return color_white
end

--[[
local function RoundDecimals(number, decimals)
	local decfactor = math.pow(10, decimals)

	return math.Round(tonumber(number) * decfactor) / decfactor
end
]]
--
--[[
Function Name:  DoInspectionDerma
Syntax: self:DoInspectionDerma().
Returns:  Nothing.
Notes:  Used to manage our Derma.
Purpose:  Used to manage our Derma.
]]
--
local TFA_INSPECTIONPANEL
local spacing = 64

local ScaleH = TFA.ScaleH

local DrawTextShadowed = TFA.DrawTextShadowed
local function TextShadowPaint(myself, w, h)
	if not myself.TextColor then
		myself.TextColor = ColorAlpha(color_white, 0)
	end

	DrawTextShadowed(myself.Text, myself.Font, myself.TextPosX or 0, myself.TextPosY or 0, myself.TextColor, ScaleH(2))
end
SWEP.TextShadowPaintFunc = TextShadowPaint

local cv_bars_exp = GetConVar("cl_tfa_inspect_newbars")
function SWEP:PaintStatPanel(w, h)
	if not IsValid(self) then return end
	if not IsValid(TFA_INSPECTIONPANEL) then return end
	if not IsValid(self.Weapon) then return end
	if not self.StatTable then return end

	if self.StatTable.bar then
		local bar = math.Clamp(self.StatTable.bar(self.Weapon), 0, 1)

		local xx, ww, blockw, padw
		xx = w - ScaleH(120)
		ww = w - xx

		local bgcol = ColorAlpha(TFA_INSPECTIONPANEL.BackgroundColor or color_white, (TFA_INSPECTIONPANEL.Alpha or 0) / 2)

		if cv_bars_exp and cv_bars_exp:GetBool() then
			draw.RoundedBox(4, xx + 1, 1, ww - 2, h - 2, bgcol)

			local w1, h1 = self:LocalToScreen(xx + 2, 2)
			local w2, h2 = self:LocalToScreen(xx - 2 + ww * bar, h - 2)

			render.SetScissorRect(w1, h1, w2, h2, true)
			draw.RoundedBox(4, xx + 2, 2, ww - 4, h - 4, TFA_INSPECTIONPANEL.SecondaryColor or color_white)
			render.SetScissorRect(0, 0, 0, 0, false)

			if self.StatTable.text then
				DrawTextShadowed(self.StatTable.text(self.Weapon), self.Font, 0, 0, TFA_INSPECTIONPANEL.SecondaryColor, ScaleH(2))
			end

			return
		end

		blockw = math.floor(ww / 15)
		padw = math.floor(ww / 10)

		self.Bars = math.Clamp(math.Round(bar * 10), 0, 10)

		surface.SetDrawColor(bgcol)
		for _ = 0, 9 do
			surface.DrawRect(xx, 2, blockw, h - 5)
			xx = math.floor(xx + padw)
		end

		xx = w - ScaleH(120)
		surface.SetDrawColor(TFA_INSPECTIONPANEL.BackgroundColor or color_white)

		for _ = 0, self.Bars - 1 do
			surface.DrawRect(xx + 1, 3, blockw, h - 5)
			xx = math.floor(xx + padw)
		end

		xx = w - ScaleH(120)
		surface.SetDrawColor(TFA_INSPECTIONPANEL.SecondaryColor or color_white)

		for _ = 0, self.Bars - 1 do
			surface.DrawRect(xx, 2, blockw, h - 5)
			xx = math.floor(xx + padw)
		end
	end

	if self.StatTable.text then
		DrawTextShadowed(self.StatTable.text(self.Weapon), self.Font, 0, 0, TFA_INSPECTIONPANEL.SecondaryColor, ScaleH(2))
	end
end

local function WrapTextLines(textlines, maxwidth, font)
	if type(textlines) == "string" then
		textlines = string.Split(textlines, "\n")
	end

	local lines = {}

	surface.SetFont(font)

	for _, text in ipairs(textlines) do
		local w, _ = surface.GetTextSize(text)

		if w > maxwidth then
			local line = ""

			for _, word in ipairs(string.Explode(" ", text)) do
				local added = line == "" and word or line .. " " .. word
				w, _ = surface.GetTextSize(added)

				if w > maxwidth then
					table.insert(lines, line)
					line = word
				else
					line = added
				end
			end

			if line ~= "" then
				table.insert(lines, line)
			end
		else
			table.insert(lines, text)
		end
	end

	return lines
end

local pad = 4
local infotextpad = "\t"
local INSPECTION_BACKGROUND = TFA.Attachments.Colors["background"]
local INSPECTION_ACTIVECOLOR = TFA.Attachments.Colors["active"]
local INSPECTION_PRIMARYCOLOR = TFA.Attachments.Colors["primary"]
local INSPECTION_SECONDARYCOLOR = TFA.Attachments.Colors["secondary"]


SWEP.AmmoTypeStrings = {
	["pistol"] = "tfa.ammo.pistol",
	["smg1"] = "tfa.ammo.smg1",
	["ar2"] = "tfa.ammo.ar2",
	["buckshot"] = "tfa.ammo.buckshot",
	["357"] = "tfa.ammo.357",
	["SniperPenetratedRound"] = "tfa.ammo.sniperpenetratedround"
}

SWEP.WeaponTypeStrings = {
	["weapon"] = "tfa.weptype.generic",
	["pistol"] = "tfa.weptype.pistol",
	["machine pistol"] = "tfa.weptype.machpistol",
	["revolver"] = "tfa.weptype.revolver",
	["sub-machine gun"] = "tfa.weptype.smg",
	["rifle"] = "tfa.weptype.rifle",
	["carbine"] = "tfa.weptype.carbine",
	["light machine gun"] = "tfa.weptype.lmg",
	["shotgun"] = "tfa.weptype.shotgun",
	["designated marksman rifle"] = "tfa.weptype.dmr",
	["sniper rifle"] = "tfa.weptype.sniper",
	["grenade"] = "tfa.weptype.grenade",
	["launcher"] = "tfa.weptype.launcher",
	["dual pistols"] = "tfa.weptype.pistol.dual",
	["dual revolvers"] = "tfa.weptype.revolver.dual",
	["dual sub-machine guns"] = "tfa.weptype.smg.dual",
	["dual guns"] = "tfa.weptype.generic.dual",
} -- if you have more generalized (and widely used) types that could be localized please let us know so that we can add them here!

local att_enabled_cv = GetConVar("sv_tfa_attachments_enabled")

SWEP.VGUIPaddingW = 32
SWEP.VGUIPaddingH = 80

function SWEP:InspectionVGUISideBars(mainpanel)
	local barleft = vgui.Create("DPanel", mainpanel)
	barleft:SetWidth(ScaleH(self.VGUIPaddingW))
	barleft:Dock(LEFT)

	barleft.Paint = function(myself, w, h)
		local mycol = mainpanel.SecondaryColor

		if not mycol then return end

		surface.SetDrawColor(mycol)
		surface.SetTexture(mainpanel.SideBar or 1)
		surface.DrawTexturedRect(0, 0, w, h)
	end

	local barright = vgui.Create("DPanel", mainpanel)
	barright:SetWidth(ScaleH(self.VGUIPaddingW))
	barright:Dock(RIGHT)

	barright.Paint = function(myself, w, h)
		local mycol = mainpanel.SecondaryColor

		if not mycol then return end

		surface.SetDrawColor(mycol)
		surface.SetTexture(mainpanel.SideBar or 1)
		surface.DrawTexturedRectUV(0, 0, w, h, 1, 0, 0, 1)
	end
end

function SWEP:InspectionVGUIMainInfo(contentpanel)
	if hook.Run("TFA_InspectVGUI_InfoStart", self, contentpanel) ~= false then
		local mainpanel = contentpanel:GetParent()

		local infopanel = contentpanel:Add("DSizeToContents")
		infopanel:SetName("Main Weapon Info")

		infopanel:SetSize(0, 0)
		infopanel:Dock(TOP)
		infopanel.Paint = function() end

		local titletext = infopanel:Add("DPanel")
		titletext:SetName("Name")
		titletext.Text = self.PrintName or "TFA Weapon"

		titletext.Think = function(myself)
			myself.TextColor = mainpanel.PrimaryColor
		end

		titletext.Font = "TFA_INSPECTION_TITLE"
		titletext:Dock(TOP)
		titletext:SetSize(ScrW() * .5, TFA.Fonts.InspectionHeightTitle)
		titletext.Paint = TextShadowPaint

		local typetext = infopanel:Add("DPanel")
		typetext:SetName("Type")

		local weptype = self:GetStatL("Type_Displayed") or self:GetType()
		typetext.Text = language.GetPhrase(self.WeaponTypeStrings[weptype:lower()] or weptype)

		typetext.Think = function(myself)
			myself.TextColor = mainpanel.PrimaryColor
		end

		typetext.Font = "TFA_INSPECTION_DESCR"
		typetext:Dock(TOP)
		typetext:SetSize(ScrW() * .5, TFA.Fonts.InspectionHeightDescription)
		typetext.Paint = TextShadowPaint

		--Space things out for block1
		local spacer = infopanel:Add("DPanel")
		spacer:SetName("Spacer")
		spacer:Dock(TOP)
		spacer:SetSize(ScrW() * .5, TFA.Fonts.InspectionHeightDescription)
		spacer.Paint = function() end

		--First stat block
		local categorytext = infopanel:Add("DPanel")
		categorytext:SetName("Category")
		categorytext.Text = self.Category or self.Base

		categorytext.Think = function(myself)
			myself.TextColor = mainpanel.SecondaryColor
		end

		categorytext.Font = "TFA_INSPECTION_SMALL"
		categorytext:Dock(TOP)
		categorytext:SetSize(ScrW() * .5, TFA.Fonts.InspectionHeightSmall)
		categorytext.Paint = TextShadowPaint

		if self.Author and string.Trim(self.Author) ~= "" then
			local authortext = infopanel:Add("DPanel")
			authortext:SetName("Author")
			authortext.Text = infotextpad .. language.GetPhrase("tfa.inspect.creator"):format(self.Author)

			authortext.Think = function(myself)
				myself.TextColor = mainpanel.SecondaryColor
			end

			authortext.Font = "TFA_INSPECTION_SMALL"
			authortext:Dock(TOP)
			authortext:SetSize(ScrW() * .5, TFA.Fonts.InspectionHeightSmall)
			authortext.Paint = TextShadowPaint
		end

		if self.Manufacturer and string.Trim(self.Manufacturer) ~= "" then
			local makertext = infopanel:Add("DPanel")
			makertext:SetName("Manufacturer")
			makertext.Text = infotextpad .. language.GetPhrase("tfa.inspect.manufacturer"):format(self.Manufacturer)

			makertext.Think = function(myself)
				myself.TextColor = mainpanel.SecondaryColor
			end

			makertext.Font = "TFA_INSPECTION_SMALL"
			makertext:Dock(TOP)
			makertext:SetSize(ScrW() * .5, TFA.Fonts.InspectionHeightSmall)
			makertext.Paint = TextShadowPaint
		end

		local clip = self:GetStatL("Primary.ClipSize")

		if clip > 0 then
			local capacitytext = infopanel:Add("DPanel")
			capacitytext:SetName("Capacity")
			capacitytext.Text = infotextpad .. language.GetPhrase("tfa.inspect.capacity"):format(clip .. (self:CanChamber() and (self:GetStatL("IsAkimbo") and " + 2" or " + 1") or ""))

			capacitytext.Think = function(myself)
				myself.TextColor = mainpanel.SecondaryColor
			end

			capacitytext.Font = "TFA_INSPECTION_SMALL"
			capacitytext:Dock(TOP)
			capacitytext:SetSize(ScrW() * .5, TFA.Fonts.InspectionHeightSmall)
			capacitytext.Paint = TextShadowPaint
		end

		local an = game.GetAmmoName(self:GetPrimaryAmmoType())

		if an and an ~= "" and string.len(an) > 1 then
			local ammotypetext = infopanel:Add("DPanel")
			ammotypetext:SetName("Ammo Type")
			ammotypetext.Text = infotextpad .. language.GetPhrase("tfa.inspect.ammotype"):format(language.GetPhrase(self.AmmoTypeStrings[an:lower()] or (an .. "_ammo")))

			ammotypetext.Think = function(myself)
				myself.TextColor = mainpanel.SecondaryColor
			end

			ammotypetext.Font = "TFA_INSPECTION_SMALL"
			ammotypetext:Dock(TOP)
			ammotypetext:SetSize(ScrW() * .5, TFA.Fonts.InspectionHeightSmall)
			ammotypetext.Paint = TextShadowPaint
		end

		local maxlinewidth = ScrW() * .5 - ScaleH(self.VGUIPaddingW) * 4

		if self.Purpose and string.Trim(self.Purpose) ~= "" then
			local lines = WrapTextLines(language.GetPhrase("tfa.inspect.purpose"):format(language.GetPhrase(self.Purpose)), maxlinewidth, "TFA_INSPECTION_SMALL")

			for _, line in pairs(lines) do
				local purposeline = infopanel:Add("DPanel")
				purposeline:SetName("Purpose")
				purposeline.Text = infotextpad .. line

				purposeline.Think = function(myself)
					myself.TextColor = mainpanel.SecondaryColor
				end

				purposeline.Font = "TFA_INSPECTION_SMALL"
				purposeline:Dock(TOP)
				purposeline:SetSize(ScrW() * .5, TFA.Fonts.InspectionHeightSmall)
				purposeline.Paint = TextShadowPaint
			end
		end

		if self.Description and string.Trim(self.Description) ~= "" then
			local lines = WrapTextLines(language.GetPhrase(self.Description), maxlinewidth, "TFA_INSPECTION_SMALL")

			for _, line in ipairs(lines) do
				local descline = infopanel:Add("DPanel")
				descline:SetName("Description")
				descline.Text = infotextpad .. line

				descline.Think = function(myself)
					myself.TextColor = mainpanel.SecondaryColor
				end

				descline.Font = "TFA_INSPECTION_SMALL"
				descline:Dock(TOP)
				descline:SetSize(ScrW() * .5, TFA.Fonts.InspectionHeightSmall)
				descline.Paint = TextShadowPaint
			end
		end

		hook.Run("TFA_InspectVGUI_InfoFinish", self, contentpanel, infopanel)
	end
end

local cv_display_moa = GetConVar("cl_tfa_inspect_spreadinmoa")
local sv_tfa_weapon_weight = GetConVar("sv_tfa_weapon_weight")

local AccuracyToDegrees = 1 / TFA.DegreesToAccuracy
local AccuracyToMOA = 1 / TFA.DegreesToAccuracy * 60

SWEP.InspectionVGUI_BestDamage = 100
SWEP.InspectionVGUI_BestRPM = 1200
SWEP.InspectionVGUI_WorstAccuracy = 0.045
SWEP.InspectionVGUI_WorstMove = 0.8
SWEP.InspectionVGUI_WorstRecoil = 1

SWEP.InspectionVGUIStatsTable = {
	{
		name = "bash",
		cond = function(wep) return wep.BashBase and wep:GetStatL("Secondary.CanBash") ~= false end,
		text = function(wep) return language.GetPhrase("tfa.inspect.stat.bashdamage"):format(math.Round(wep:GetStatL("Secondary.BashDamage", 0))) end,
		bar = function(wep) return wep:GetStatL("Secondary.BashDamage") / wep.InspectionVGUI_BestDamage end
	},
	{
		name = "stability",
		cond = function(wep) return true end,
		text = function(wep) return language.GetPhrase("tfa.inspect.stat.stability"):format(math.Clamp(math.Round((1 - math.abs(wep:GetStatL("Primary.KickUp") + wep:GetStatL("Primary.KickDown")) / 2 / 1) * 100), 0, 100)) end,
		bar = function(wep) return (1 - math.abs(wep:GetStatL("Primary.KickUp") + wep:GetStatL("Primary.KickDown")) / 2 / wep.InspectionVGUI_WorstRecoil) end
	},
	{
		name = "damage",
		cond = function(wep) return true end,
		text = function(wep)
			local dmgstr = language.GetPhrase("tfa.inspect.stat.damage"):format(math.Round(wep:GetStatL("Primary.Damage")))

			if wep:GetStatL("Primary.NumShots") ~= 1 then
				dmgstr = dmgstr .. "x" .. math.Round(wep:GetStatL("Primary.NumShots"))
			end

			return dmgstr
		end,
		bar = function(wep) return (wep:GetStatL("Primary.Damage") * math.Round(wep:GetStatL("Primary.NumShots") * 0.75)) / wep.InspectionVGUI_BestDamage end
	},
	{
		name = "mobility",
		cond = function(wep) return sv_tfa_weapon_weight:GetBool() end,
		text = function(wep) return language.GetPhrase("tfa.inspect.stat.mobility"):format(math.Round(wep:GetStatL("RegularMoveSpeedMultiplier") * 100)) end,
		bar = function(wep) return (wep:GetStatL("RegularMoveSpeedMultiplier") - wep.InspectionVGUI_WorstMove) / (1 - wep.InspectionVGUI_WorstMove) end
	},
	{
		name = "firerate",
		cond = function(wep) return true end,
		text = function(wep) return language.GetPhrase("tfa.inspect.stat.rpm"):format(wep:GetStatL("Primary.RPM_Displayed") or wep:GetStatL("Primary.RPM")) end,
		bar = function(wep) return (wep:GetStatL("Primary.RPM_Displayed") or wep:GetStatL("Primary.RPM")) / wep.InspectionVGUI_BestRPM end
	},
	{
		name = "spread_hip",
		cond = function(wep) return wep:GetStatL("Secondary.DisplaySpread", true) end,
		text = function(wep)
			local spread = wep:GetStatL("Primary.Spread")

			local spreadtext
			if cv_display_moa and cv_display_moa:GetBool() then
				spreadtext = language.GetPhrase("tfa.inspect.val.moa"):format(spread * AccuracyToMOA)
			else
				spreadtext = language.GetPhrase("tfa.inspect.val.degrees"):format(spread * AccuracyToDegrees)
			end

			return language.GetPhrase("tfa.inspect.stat.accuracy.hip"):format(spreadtext)
		end,
		bar = function(wep) return 1 - wep:GetStatL("Primary.Spread") / wep.InspectionVGUI_WorstAccuracy end
	},
	{
		name = "spread_iron",
		cond = function(wep) return wep:GetStatL("Secondary.IronSightsEnabled", false) and wep:GetStatL("Secondary.DisplayIronSpread", true) end,
		text = function(wep)
			local spread = wep:GetStatL("Primary.IronAccuracy")

			local spreadtext
			if cv_display_moa and cv_display_moa:GetBool() then
				spreadtext = language.GetPhrase("tfa.inspect.val.moa"):format(spread * AccuracyToMOA)
			else
				spreadtext = language.GetPhrase("tfa.inspect.val.degrees"):format(spread * AccuracyToDegrees)
			end

			return language.GetPhrase("tfa.inspect.stat.accuracy"):format(spreadtext)
		end,
		bar = function(wep) return 1 - wep:GetStatL("Primary.IronAccuracy") / wep.InspectionVGUI_WorstAccuracy end
	},
	{
		name = "condition",
		cond = function(wep) return wep:CanBeJammed() end,
		text = function(wep) return language.GetPhrase("tfa.inspect.condition"):format(math.Clamp(math.Round((1 - wep:GetJamFactor() * .01) * 100), 0, 100)) end,
		bar = function(wep) return 1 - wep:GetJamFactor() * .01 end
	},
}

function SWEP:InspectionVGUIStats(contentpanel)
	if hook.Run("TFA_InspectVGUI_StatsStart", self, contentpanel) ~= false then
		local mainpanel = contentpanel:GetParent()

		local statspanel = contentpanel:Add("DPanel")
		statspanel:SetName("Weapon Stats Container")

		local preferredWidth = math.min(ScaleH(400), ScrW() * .4)

		statspanel:SetSize(0, 0)
		statspanel:Dock(BOTTOM)
		statspanel:DockMargin(0, 0, ScrW() - preferredWidth - ScaleH(self.VGUIPaddingW) * 4, 0)
		statspanel.Paint = function() end

		statspanel.stats = {}
		for _, tbl in ipairs(self.InspectionVGUIStatsTable) do
			if not tbl.name or not tbl.text or not tbl.bar or statspanel.stats[tbl.name] then continue end
			if tbl.cond and not tbl.cond(self) then continue end

			statspanel:SetTall(statspanel:GetTall() + TFA.Fonts.InspectionHeightSmall)

			local statpanel = statspanel:Add("DPanel")

			statpanel:SetName("Stat Panel - " .. tbl.name)
			statpanel:SetSize(preferredWidth, TFA.Fonts.InspectionHeightSmall)

			statpanel.StatTable = tbl
			statpanel.Weapon = self
			statpanel.Font = "TFA_INSPECTION_SMALL"

			statpanel.Paint = self.PaintStatPanel
			statpanel:Dock(BOTTOM)

			statspanel.stats[tbl.name] = statpanel
		end

		hook.Run("TFA_InspectVGUI_StatsFinish", self, contentpanel, statspanel)
	end
end

function SWEP:InspectionVGUIAttachments(contentpanel)
	local mainpanel = contentpanel:GetParent()
	local scrollpanel, vbar

	if att_enabled_cv:GetBool() and hook.Run("TFA_InspectVGUI_AttachmentsStart", self, contentpanel) ~= false then
		if self.Attachments then
			scrollpanel = mainpanel:Add("DScrollPanel")
			scrollpanel:SetName("Attachments Container")

			scrollpanel:SetSize(ScrW() * .5 - ScaleH(self.VGUIPaddingW) * 2, mainpanel:GetTall() - ScaleH(self.VGUIPaddingH) * 2)
			scrollpanel:SetPos(ScrW() * .5, ScaleH(self.VGUIPaddingH))

			vbar = scrollpanel:GetVBar()

			vbar.Paint = function(myself, w, h)
				if not mainpanel or not mainpanel.BackgroundColor then return end
				surface.SetDrawColor(mainpanel.BackgroundColor.r, mainpanel.BackgroundColor.g, mainpanel.BackgroundColor.b, mainpanel.BackgroundColor.a / 2)
				surface.DrawRect(w * .65, 0, w * .35, h)
			end

			vbar.btnUp.Paint = function(myself, w, h)
				if not mainpanel or not mainpanel.PrimaryColor then return end
				surface.SetDrawColor(mainpanel.PrimaryColor.r, mainpanel.PrimaryColor.g, mainpanel.PrimaryColor.b, mainpanel.PrimaryColor.a)
				surface.DrawRect(w * .65, 0, w * .35, h)
			end

			vbar.btnDown.Paint = function(myself, w, h)
				if not mainpanel or not mainpanel.PrimaryColor then return end
				surface.SetDrawColor(mainpanel.PrimaryColor.r, mainpanel.PrimaryColor.g, mainpanel.PrimaryColor.b, mainpanel.PrimaryColor.a)
				surface.DrawRect(w * .65, 0, w * .35, h)
			end

			vbar.btnGrip.Paint = function(myself, w, h)
				if not mainpanel or not mainpanel.PrimaryColor then return end
				surface.SetDrawColor(mainpanel.PrimaryColor.r, mainpanel.PrimaryColor.g, mainpanel.PrimaryColor.b, mainpanel.PrimaryColor.a)
				surface.DrawRect(w * .65, 0, w * .35, h)
			end
		end

		self:GenerateVGUIAttachmentTable()
		local i = 0
		local prevCat
		local lineY = 0
		local scrollWide = scrollpanel:GetWide() - (IsValid(vbar) and vbar:GetTall() or 0)
		local lastTooltipPanel

		local iconsize = math.Round(ScaleH(TFA.Attachments.IconSize))
		local catspacing = math.Round(ScaleH(TFA.Attachments.CategorySpacing))
		local padding = math.Round(ScaleH(TFA.Attachments.UIPadding))

		for k, v in pairs(self.VGUIAttachments) do
			if k ~= "BaseClass" then
				if prevCat then
					local isContinuing = prevCat == (v.cat or k)
					lineY = lineY + (isContinuing and iconsize + padding or catspacing)

					if not isContinuing then
						lastTooltipPanel = nil
					end
				end

				prevCat = v.cat or k
				local testpanel = mainpanel:Add("TFAAttachmentPanel")
				testpanel:SetName("Attachment Category Container")
				testpanel:SetParent(scrollpanel)
				testpanel:SetContentPanel(scrollpanel)
				i = i + 1
				testpanel:SetWeapon(self)
				testpanel:SetAttachment(k)
				testpanel:SetCategory(v.cat or k)
				testpanel:Initialize()
				lastTooltipPanel = lastTooltipPanel or testpanel:InitializeTooltip()
				testpanel:SetupTooltip(lastTooltipPanel)
				testpanel:PopulateIcons()
				testpanel:SetPos(scrollWide - testpanel:GetWide(), lineY)
			end
		end

		hook.Run("TFA_InspectVGUI_AttachmentsFinish", self, contentpanel, scrollpanel)
	end

	if self.Primary.RangeFalloffLUTBuilt and self:GetStatL("Primary.DisplayFalloff") and hook.Run("TFA_InspectVGUI_FalloffStart", self, contentpanel) ~= false then
		local falloffpanel = vgui.Create("EditablePanel", mainpanel)
		falloffpanel:SetSize(ScrW() * .5 - ScaleH(self.VGUIPaddingW) * 2, mainpanel:GetTall() * 0.2)
		falloffpanel:SetPos(ScrW() * .5, mainpanel:GetTall() - falloffpanel:GetTall() - ScaleH(self.VGUIPaddingH))
		falloffpanel:SetName("Damage Falloff Graph")

		if scrollpanel then
			scrollpanel:SetTall(scrollpanel:GetTall() - falloffpanel:GetTall())
			falloffpanel:SetPos(ScrW() * .5, ScaleH(self.VGUIPaddingH) + scrollpanel:GetTall())
		end

		falloffpanel:NoClipping(true)

		local self2 = self
		local shadow_color = Color(0, 0, 0)

		-- it differ from function above
		local function shadowed_text(text, font, x, y, color, ...)
			draw.SimpleText(text, font, x + 2, y + 2, shadow_color, ...)
			draw.SimpleText(text, font, x, y, color, ...)
		end

		local function shadowed_line(x, y, x2, y2, color, color2)
			surface.SetDrawColor(color2)
			surface.DrawLine(x + 1, y + 1, x2 + 1, y2 + 1)
			surface.SetDrawColor(color)
			surface.DrawLine(x, y, x2, y2)
		end

		function falloffpanel.Paint(myself, w, h)
			if not IsValid(self2) or not IsValid(mainpanel) then return end

			local lut = self2.Primary.RangeFalloffLUTBuilt
			if not lut then return end
			local wepdmg = self2.Primary.Damage

			shadow_color.a = mainpanel.SecondaryColor.a

			shadowed_text("#tfa.inspect.damagedrop", "TFASleekSmall", 0, ScaleH(pad), mainpanel.SecondaryColor, TEXT_ALIGN_LEFT)

			local ax, ay = 0, TFA.Fonts.SleekHeightSmall + ScaleH(pad) * 2

			surface.SetDrawColor(mainpanel.SecondaryColor)

			local range = 0
			local div = 1

			for i, data in ipairs(lut) do
				if data[1] > range then
					range = data[1]
				end

				if data[2] > div then
					div = data[2]
				end
			end

			range = range * 1.337

			local rightpadding = 18

			for pos = 1, 4 do
				shadowed_line(ax + pos * (w - rightpadding) / 4, h - 2 - ay, ax + pos * (w - rightpadding) / 4, h - 12 - ay, mainpanel.SecondaryColor, mainpanel.BackgroundColor)
				shadowed_text(string.format("%dm", range * 0.0254 * pos / 4), "TFASleekSmall", ax + pos * (w - rightpadding) / 4, h - ay, mainpanel.SecondaryColor, TEXT_ALIGN_CENTER)
			end

			shadowed_line(ax + 1, ay + 1, 1, h - 2 - ay, mainpanel.SecondaryColor, mainpanel.BackgroundColor)
			shadowed_line(ax + 1, h - 2 - ay, w - rightpadding, h - 2 - ay, mainpanel.SecondaryColor, mainpanel.BackgroundColor)

			local lx, ly = myself:LocalToScreen(ax, 0)
			local mx, my = input.GetCursorPos()
			local rmx, rmy = mx, my
			mx = mx - lx
			my = my - ly

			local px, py

			local cirX, cirY, dmg, drange

			local progression = mx / (w - ax - rightpadding)

			for i, data in ipairs(lut) do
				local x, y = ax + data[1] / range * (w - ax - rightpadding), ay + (div - data[2]) * (h - ay * 2) / div

				if not px then
					px, py = x, y
				end

				shadowed_line(px, py, x, y, mainpanel.PrimaryColor, mainpanel.BackgroundColor)

				if x > mx and px < mx then
					local t = (mx - px) / (x - px)
					cirX, cirY = Lerp(t, px, x), Lerp(t, py, y)
					local ndmg = lut[i + 1] and lut[i + 1][2] or data[2]
					local deltadmg = ndmg - data[2]
					dmg = deltadmg * t + data[2]
				end

				px, py = x, y
			end

			shadowed_line(px, py, w - ax - 18, py, mainpanel.PrimaryColor, mainpanel.BackgroundColor)

			if mx > px and (w - ax - 18) > mx then
				cirX, cirY = mx, py
				dmg = lut[#lut][2]
			end

			if mx > 0 and my > 0 and mx < w and my < h and dmg then
				shadowed_line(mx, ay, mx, h - ay, mainpanel.PrimaryColor, mainpanel.BackgroundColor)

				if cirX then
					local Xsize = ScaleH(8)

					surface.SetDrawColor(mainpanel.BackgroundColor)
					surface.DrawLine(cirX - Xsize + 1, cirY - Xsize + 1, cirX + Xsize + 1, cirY + Xsize + 1)
					surface.DrawLine(cirX + Xsize + 1, cirY - Xsize + 1, cirX - Xsize + 1, cirY + Xsize + 1)

					surface.SetDrawColor(mainpanel.PrimaryColor)
					surface.DrawLine(cirX - Xsize, cirY - Xsize, cirX + Xsize, cirY + Xsize)
					surface.DrawLine(cirX + Xsize, cirY - Xsize, cirX - Xsize, cirY + Xsize)
				end

				shadowed_text(string.format("%dm", math.Round(range * progression * 0.0254)), "TFASleekSmall", mx - ScaleH(pad), my - TFA.Fonts.SleekHeightSmall, mainpanel.SecondaryColor, TEXT_ALIGN_RIGHT)
				shadowed_text(string.format("%ddmg", dmg * wepdmg), "TFASleekSmall", mx + ScaleH(pad), my - TFA.Fonts.SleekHeightSmall, mainpanel.SecondaryColor, TEXT_ALIGN_LEFT)
			end
		end

		hook.Run("TFA_InspectVGUI_FalloffFinish", self, contentpanel, falloffpanel)
	end
end

local cl_tfa_inspect_hide_in_screenshots = GetConVar("cl_tfa_inspect_hide_in_screenshots")
local cl_tfa_inspect_hide_hud = GetConVar("cl_tfa_inspect_hide_hud")
local cl_tfa_inspect_hide = GetConVar("cl_tfa_inspect_hide")
local cl_drawhud = GetConVar("cl_drawhud")

local blacklist = {
	CHudAmmo = false,
	CHudBattery = false,
	CHudHealth = false,
}

local function HUDShouldDraw(_, elem)
	return blacklist[elem]
end

function SWEP:GenerateInspectionDerma()
	if hook.Run("TFA_InspectVGUI_Start", self) == false then return end
	if cl_tfa_inspect_hide:GetBool() then return end

	TFA_INSPECTIONPANEL = vgui.Create("DPanel")
	TFA_INSPECTIONPANEL:SetSize(ScrW(), ScrH())
	TFA_INSPECTIONPANEL:DockPadding(ScaleH(self.VGUIPaddingW), ScaleH(self.VGUIPaddingH), ScaleH(self.VGUIPaddingW), ScaleH(self.VGUIPaddingH))
	TFA_INSPECTIONPANEL:SetRenderInScreenshots(not cl_tfa_inspect_hide_in_screenshots:GetBool())
	TFA_INSPECTIONPANEL:SetName("TFA Base Inspection Panel")

	TFA.INSPECTIONPANEL = TFA_INSPECTIONPANEL

	local function update_visible(status)
		if not cl_tfa_inspect_hide_hud:GetBool() or not DLib then return end

		if status then
			hook.DisableHook("HUDPaint")
			hook.DisableHook("HUDPaintBackground")
			hook.DisableHook("PreDrawHUD")
			hook.DisableHook("PostDrawHUD")
			hook.DisableHook("DrawDeathNotice")

			hook.Add("HUDShouldDraw", TFA_INSPECTIONPANEL, HUDShouldDraw)
		else
			hook.EnableHook("HUDPaint")
			hook.EnableHook("HUDPaintBackground")
			hook.EnableHook("PreDrawHUD")
			hook.EnableHook("PostDrawHUD")
			hook.EnableHook("DrawDeathNotice")

			hook.Remove("HUDShouldDraw", TFA_INSPECTIONPANEL, HUDShouldDraw)
		end
	end

	if not cl_drawhud:GetBool() then
		TFA_INSPECTIONPANEL:SetVisible(false)
	else
		update_visible(true)
	end

	cvars.AddChangeCallback("cl_drawhud", function()
		if not IsValid(TFA_INSPECTIONPANEL) then return end
		TFA_INSPECTIONPANEL:Think()
		if not IsValid(TFA_INSPECTIONPANEL) then return end
		TFA_INSPECTIONPANEL:SetVisible(cl_drawhud:GetBool())
		update_visible(cl_drawhud:GetBool())
	end, "TFA_INSPECTIONPANEL")

	local lastcustomizing = true

	function TFA_INSPECTIONPANEL.Think(myself, w, h)
		local ply = LocalPlayer()

		if not IsValid(ply) then
			myself:Remove()

			return
		end

		local wep = ply:GetActiveWeapon()

		if not IsValid(wep) or not wep.IsTFAWeapon or wep:GetInspectingProgress() <= 0.01 then
			myself:Remove()

			return
		end

		if cl_tfa_inspect_hide_hud:GetBool() and DLib then
			local customizing = wep:GetCustomizing()

			if customizing ~= lastcustomizing then
				lastcustomizing = customizing
				update_visible(customizing)
			end
		end

		myself.Player = ply
		myself.Weapon = wep
	end

	function TFA_INSPECTIONPANEL.OnRemove(myself)
		update_visible(false)
	end

	function TFA_INSPECTIONPANEL.Paint(myself, w, h)
		local wep = self

		if IsValid(wep) then
			myself.Alpha = wep:GetInspectingProgress() * 255
			myself.PrimaryColor = ColorAlpha(INSPECTION_PRIMARYCOLOR, TFA_INSPECTIONPANEL.Alpha)
			myself.SecondaryColor = ColorAlpha(INSPECTION_SECONDARYCOLOR, TFA_INSPECTIONPANEL.Alpha)
			myself.BackgroundColor = ColorAlpha(INSPECTION_BACKGROUND, TFA_INSPECTIONPANEL.Alpha)
			myself.ActiveColor = ColorAlpha(INSPECTION_ACTIVECOLOR, TFA_INSPECTIONPANEL.Alpha)

			if not myself.SideBar then
				myself.SideBar = surface.GetTextureID("vgui/inspectionhud/sidebar")
			end
		end
	end

	self:InspectionVGUISideBars(TFA_INSPECTIONPANEL)

	local contentpanel = vgui.Create("DPanel", TFA_INSPECTIONPANEL)
	contentpanel:Dock(FILL)
	local spad = ScaleH(pad)
	contentpanel:DockPadding(spad, spad, spad, spad)
	contentpanel:SetName("Inspection Content Panel")

	function contentpanel.Paint() end

	-- Top block (gun name and info)
	self:InspectionVGUIMainInfo(contentpanel)

	-- Bottom block (stats)
	self:InspectionVGUIStats(contentpanel)

	-- Attachments
	self:InspectionVGUIAttachments(contentpanel)

	hook.Run("TFA_InspectVGUI_Finish", self, TFA_INSPECTIONPANEL, contentpanel)
end

function SWEP:DoInspectionDerma()
	if not IsValid(TFA_INSPECTIONPANEL) and self:GetInspectingProgress() > 0.01 then
		self:GenerateInspectionDerma()
	end

	if not IsValid(TFA_INSPECTIONPANEL) then return end
	if not self:OwnerIsValid() then return end
end

cvars.AddChangeCallback("gmod_language", function(convar, oldvalue, newvalue)
	if oldvalue == newvalue then return end

	if IsValid(TFA_INSPECTIONPANEL) then
		TFA_INSPECTIONPANEL:Remove()
	end
end, "TFA_INSPECTIONPANEL_LANGCHECK")

local crosscol = Color(255, 255, 255, 255)
local crossa_cvar = GetConVar("cl_tfa_hud_crosshair_color_a")
local outa_cvar = GetConVar("cl_tfa_hud_crosshair_outline_color_a")
local crosscustomenable_cvar = GetConVar("cl_tfa_hud_crosshair_enable_custom")
local crossr_cvar = GetConVar("cl_tfa_hud_crosshair_color_r")
local crossg_cvar = GetConVar("cl_tfa_hud_crosshair_color_g")
local crossb_cvar = GetConVar("cl_tfa_hud_crosshair_color_b")
local crosslen_cvar = GetConVar("cl_tfa_hud_crosshair_length")
local crosshairwidth_cvar = GetConVar("cl_tfa_hud_crosshair_width")
local drawdot_cvar = GetConVar("cl_tfa_hud_crosshair_dot")
local clen_usepixels = GetConVar("cl_tfa_hud_crosshair_length_use_pixels")
local outline_enabled_cvar = GetConVar("cl_tfa_hud_crosshair_outline_enabled")
local outr_cvar = GetConVar("cl_tfa_hud_crosshair_outline_color_r")
local outg_cvar = GetConVar("cl_tfa_hud_crosshair_outline_color_g")
local outb_cvar = GetConVar("cl_tfa_hud_crosshair_outline_color_b")
local outlinewidth_cvar = GetConVar("cl_tfa_hud_crosshair_outline_width")
local hudenabled_cvar = GetConVar("cl_tfa_hud_enabled")
local hudfallback_cvar = GetConVar("cl_tfa_hud_fallback_enabled")
local cgapscale_cvar = GetConVar("cl_tfa_hud_crosshair_gap_scale")
local tricross_cvar = GetConVar("cl_tfa_hud_crosshair_triangular")

--[[
Function Name:  DrawHUD
Syntax: self:DrawHUD().
Returns:  Nothing.
Notes:  Used to draw the HUD.  Can you read?
Purpose:  HUD
]]
--
function SWEP:DrawHUD()
	-- Inspection Derma
	self:DoInspectionDerma()
	-- 3D2D Ammo
	self:DrawHUDAmmo() --so it's swappable easily

	self:DrawKeyBindHints()
end

function SWEP:DrawHUDBackground()
	--Scope Overlay
	if self:GetIronSightsProgress() > self:GetStatL("ScopeOverlayThreshold") and self:GetStatL("Scoped") then
		self:DrawScopeOverlay()
	end
end

function SWEP:DrawHUD3D2D()
end

local draw = draw
local cam = cam
local surface = surface
local render = render
local Vector = Vector
local Matrix = Matrix
local TFA = TFA
local math = math

local function ColorAlpha(color_in, new_alpha)
	if color_in.a == new_alpha then return color_in end
	return Color(color_in.r, color_in.g, color_in.b, new_alpha)
end

local targ, lactive = 0, -1
local targbool = false
local hudhangtime_cvar = GetConVar("cl_tfa_hud_hangtime")
local hudfade_cvar = GetConVar("cl_tfa_hud_ammodata_fadein")
local lfm, fm = 0, 0

SWEP.CLAmmoProgress = 0
SWEP.TextCol = Color(255, 255, 255, 255) --Primary text color
SWEP.TextColContrast = Color(32, 32, 32, 255) --Secondary Text Color (used for shadow)

local TFAHudHide = {
	CHudAmmo = true,
	CHudSecondaryAmmo = true
}

function SWEP:HUDShouldDraw(name)
	if (TFAHudHide[name] and hudenabled_cvar:GetBool()) then
		return false
	end
end

function SWEP:DrawFallbackHUD()
	if not hudfallback_cvar:GetBool() or hook.Run("HUDShouldDraw", "TFA_HUDFallback") == false then return end
	if self:GetMaxClip1() <= 0 then return end

	local fmn = string.upper(self:GetFireModeName() .. (#self:GetStatL("FireModes") > 2 and " | +" or ""))

	surface.SetFont("TFASleekSmall")
	local w, h = surface.GetTextSize(fmn)

	DrawTextShadowed(fmn, "TFASleekSmall", ScrW() * .5 - w * .5, ScaleH(1017), self.TextCol, ScaleH(2))
end

function SWEP:DrawHUDAmmo()
	local self2 = self:GetTable()
	local stat = self2.GetStatus(self)

	if self2.GetStatL(self, "BoltAction") then
		if stat == TFA.Enum.STATUS_SHOOTING then
			if not self2.LastBoltShoot then
				self2.LastBoltShoot = l_CT()
			end
		elseif self2.LastBoltShoot then
			self2.LastBoltShoot = nil
		end
	end

	if not hudenabled_cvar:GetBool() or hook.Run("HUDShouldDraw", "TFA_HUDAmmo") == false then
		self:DrawFallbackHUD()
		return
	end

	fm = self:GetFireMode()
	targbool = (not TFA.Enum.HUDDisabledStatus[stat]) or fm ~= lfm
	targbool = targbool or (stat == TFA.Enum.STATUS_SHOOTING and self2.LastBoltShoot and l_CT() > self2.LastBoltShoot + self2.GetStatL(self, "BoltTimerOffset"))
	targbool = targbool or (self2.GetStatL(self, "PumpAction") and (stat == TFA.Enum.STATUS_PUMP or (stat == TFA.Enum.STATUS_SHOOTING and self:Clip1() == 0)))
	targbool = targbool or (stat == TFA.Enum.STATUS_FIDGET)

	targ = targbool and 1 or 0
	lfm = fm

	if targ == 1 then
		lactive = RealTime()
	elseif RealTime() < lactive + hudhangtime_cvar:GetFloat() then
		targ = 1
	elseif self:GetOwner():KeyDown(IN_RELOAD) then
		targ = 1
	end

	self2.CLAmmoProgress = math.Approach(self2.CLAmmoProgress, targ, (targ - self2.CLAmmoProgress) * RealFrameTime() * 2 / hudfade_cvar:GetFloat())

	local myalpha = 225 * self2.CLAmmoProgress
	if myalpha < 1 then return end
	local amn = self2.GetStatL(self, "Primary.Ammo")
	if not amn then return end
	if amn == "none" or amn == "" then return end
	local mzpos = self:GetMuzzlePos()

	if self2.GetStatL(self, "IsAkimbo") then
		self2.MuzzleAttachmentRaw = self2.MuzzleAttachmentRaw2 or 1
	end

	if self2.GetHidden(self) then return end

	local xx, yy

	if mzpos and mzpos.Pos then
		local pos = mzpos.Pos
		local textsize = self2.textsize and self2.textsize or 1
		local pl = IsValid(self:GetOwner()) and self:GetOwner() or LocalPlayer()
		local ang = pl:EyeAngles() --(angpos.Ang):Up():Angle()
		ang:RotateAroundAxis(ang:Right(), 90)
		ang:RotateAroundAxis(ang:Up(), -90)
		ang:RotateAroundAxis(ang:Forward(), 0)
		pos = pos + ang:Right() * (self2.textupoffset and self2.textupoffset or -2 * (textsize / 1))
		pos = pos + ang:Up() * (self2.textfwdoffset and self2.textfwdoffset or 0 * (textsize / 1))
		pos = pos + ang:Forward() * (self2.textrightoffset and self2.textrightoffset or -1 * (textsize / 1))
		cam.Start3D()
		local postoscreen = pos:ToScreen()
		cam.End3D()
		xx = postoscreen.x
		yy = postoscreen.y
	else -- fallback to pseudo-3d if no muzzle
		xx, yy = ScrW() * .65, ScrH() * .6
	end

	local v, newx, newy, newalpha = hook.Run("TFA_DrawHUDAmmo", self, xx, yy, myalpha)
	if v ~= nil then
		if v then
			xx = newx or xx
			yy = newy or yy
			myalpha = newalpha or myalpha
		else
			return
		end
	end

	if self:GetInspectingProgress() < 0.01 and self2.GetStatL(self, "Primary.Ammo") ~= "" and self2.GetStatL(self, "Primary.Ammo") ~= 0 then
		local str, clipstr

		if self2.GetStatL(self, "Primary.ClipSize") and self2.GetStatL(self, "Primary.ClipSize") ~= -1 then
			clipstr = language.GetPhrase("tfa.hud.ammo.clip1")

			if self2.GetStatL(self, "IsAkimbo") and self2.GetStatL(self, "EnableAkimboHUD") ~= false then
				if self2.Akimbo_Inverted then
					str = clipstr:format(math.ceil(self:Clip1() / 2))

					if (self:Clip1() > self2.GetStatL(self, "Primary.ClipSize")) then
						str = clipstr:format(math.ceil(self:Clip1() / 2) - 1 .. " + " .. (math.ceil(self:Clip1() / 2) - math.ceil(self2.GetStatL(self, "Primary.ClipSize") / 2)))
					end
				else
					str = clipstr:format(math.floor(self:Clip1() / 2))

					if (math.floor(self:Clip1() / 2) > math.floor(self2.GetStatL(self, "Primary.ClipSize") / 2)) then
						str = clipstr:format(math.floor(self:Clip1() / 2) - 1 .. " + " .. (math.floor(self:Clip1() / 2) - math.floor(self2.GetStatL(self, "Primary.ClipSize") / 2)))
					end
				end
			else
				str = clipstr:format(self:Clip1())

				if (self:Clip1() > self2.GetStatL(self, "Primary.ClipSize")) then
					str = clipstr:format(self2.GetStatL(self, "Primary.ClipSize") .. " + " .. (self:Clip1() - self2.GetStatL(self, "Primary.ClipSize")))
				end
			end

			draw.DrawText(str, "TFASleek", xx + 1, yy + 1, ColorAlpha(self2.TextColContrast, myalpha), TEXT_ALIGN_RIGHT)
			draw.DrawText(str, "TFASleek", xx, yy, ColorAlpha(self2.TextCol, myalpha), TEXT_ALIGN_RIGHT)
			str = language.GetPhrase("tfa.hud.ammo.reserve1"):format(self2.Ammo1(self))
			yy = yy + TFA.Fonts.SleekHeight
			xx = xx - TFA.Fonts.SleekHeight / 3
			draw.DrawText(str, "TFASleekMedium", xx + 1, yy + 1, ColorAlpha(self2.TextColContrast, myalpha), TEXT_ALIGN_RIGHT)
			draw.DrawText(str, "TFASleekMedium", xx, yy, ColorAlpha(self2.TextCol, myalpha), TEXT_ALIGN_RIGHT)
			yy = yy + TFA.Fonts.SleekHeightMedium
			xx = xx - TFA.Fonts.SleekHeightMedium / 3
		else
			str = language.GetPhrase("tfa.hud.ammo1"):format(self2.Ammo1(self))
			draw.DrawText(str, "TFASleek", xx + 1, yy + 1, ColorAlpha(self2.TextColContrast, myalpha), TEXT_ALIGN_RIGHT)
			draw.DrawText(str, "TFASleek", xx, yy, ColorAlpha(self2.TextCol, myalpha), TEXT_ALIGN_RIGHT)
			yy = yy + TFA.Fonts.SleekHeightMedium
			xx = xx - TFA.Fonts.SleekHeightMedium / 3
		end

		str = string.upper(self:GetFireModeName() .. (#self2.GetStatL(self, "FireModes") > 2 and " | +" or ""))

		if self:IsJammed() then
			str = str .. "\n" .. language.GetPhrase("tfa.hud.jammed")
		end

		draw.DrawText(str, "TFASleekSmall", xx + 1, yy + 1, ColorAlpha(self2.TextColContrast, myalpha), TEXT_ALIGN_RIGHT)
		draw.DrawText(str, "TFASleekSmall", xx, yy, ColorAlpha(self2.TextCol, myalpha), TEXT_ALIGN_RIGHT)
		yy = yy + TFA.Fonts.SleekHeightSmall
		xx = xx - TFA.Fonts.SleekHeightSmall / 3

		if self2.GetStatL(self, "IsAkimbo") and self2.GetStatL(self, "EnableAkimboHUD") ~= false then
			local angpos2 = self:GetOwner():ShouldDrawLocalPlayer() and self:GetAttachment(2) or self2.OwnerViewModel:GetAttachment(2)

			if angpos2 then
				local pos2 = angpos2.Pos
				local ts2 = pos2:ToScreen()

				xx, yy = ts2.x, ts2.y
			else
				xx, yy = ScrW() * .35, ScrH() * .6
			end

			if self2.GetStatL(self, "Primary.ClipSize") and self2.GetStatL(self, "Primary.ClipSize") ~= -1 then
				clipstr = language.GetPhrase("tfa.hud.ammo.clip1")

				if self2.Akimbo_Inverted then
					str = clipstr:format(math.floor(self:Clip1() / 2))

					if (math.floor(self:Clip1() / 2) > math.floor(self2.GetStatL(self, "Primary.ClipSize") / 2)) then
						str = clipstr:format(math.floor(self:Clip1() / 2) - 1 .. " + " .. (math.floor(self:Clip1() / 2) - math.floor(self2.GetStatL(self, "Primary.ClipSize") / 2)))
					end
				else
					str = clipstr:format(math.ceil(self:Clip1() / 2))

					if (self:Clip1() > self2.GetStatL(self, "Primary.ClipSize")) then
						str = clipstr:format(math.ceil(self:Clip1() / 2) - 1 .. " + " .. (math.ceil(self:Clip1() / 2) - math.ceil(self2.GetStatL(self, "Primary.ClipSize") / 2)))
					end
				end

				draw.DrawText(str, "TFASleek", xx + 1, yy + 1, ColorAlpha(self2.TextColContrast, myalpha), TEXT_ALIGN_RIGHT)
				draw.DrawText(str, "TFASleek", xx, yy, ColorAlpha(self2.TextCol, myalpha), TEXT_ALIGN_RIGHT)
				str = language.GetPhrase("tfa.hud.ammo.reserve1"):format(self2.Ammo1(self))
				yy = yy + TFA.Fonts.SleekHeight
				xx = xx - TFA.Fonts.SleekHeight / 3
				draw.DrawText(str, "TFASleekMedium", xx + 1, yy + 1, ColorAlpha(self2.TextColContrast, myalpha), TEXT_ALIGN_RIGHT)
				draw.DrawText(str, "TFASleekMedium", xx, yy, ColorAlpha(self2.TextCol, myalpha), TEXT_ALIGN_RIGHT)
				yy = yy + TFA.Fonts.SleekHeightMedium
				xx = xx - TFA.Fonts.SleekHeightMedium / 3
			else
				str = language.GetPhrase("tfa.hud.ammo1"):format(self2.Ammo1(self))
				draw.DrawText(str, "TFASleek", xx + 1, yy + 1, ColorAlpha(self2.TextColContrast, myalpha), TEXT_ALIGN_RIGHT)
				draw.DrawText(str, "TFASleek", xx, yy, ColorAlpha(self2.TextCol, myalpha), TEXT_ALIGN_RIGHT)
				yy = yy + TFA.Fonts.SleekHeightMedium
				xx = xx - TFA.Fonts.SleekHeightMedium / 3
			end

			str = string.upper(self:GetFireModeName() .. (#self2.FireModes > 2 and " | +" or ""))
			draw.DrawText(str, "TFASleekSmall", xx + 1, yy + 1, ColorAlpha(self2.TextColContrast, myalpha), TEXT_ALIGN_RIGHT)
			draw.DrawText(str, "TFASleekSmall", xx, yy, ColorAlpha(self2.TextCol, myalpha), TEXT_ALIGN_RIGHT)
		end

		if self2.GetStatL(self, "Secondary.Ammo") and self2.GetStatL(self, "Secondary.Ammo") ~= "" and self2.GetStatL(self, "Secondary.Ammo") ~= "none" and self2.GetStatL(self, "Secondary.Ammo") ~= 0 and not self2.GetStatL(self, "IsAkimbo") then
			if self2.GetStatL(self, "Secondary.ClipSize") and self2.GetStatL(self, "Secondary.ClipSize") ~= -1 then
				clipstr = language.GetPhrase("tfa.hud.ammo.clip2")
				str = (self:Clip2() > self2.GetStatL(self, "Secondary.ClipSize")) and clipstr:format(self2.GetStatL(self, "Secondary.ClipSize") .. " + " .. (self:Clip2() - self2.GetStatL(self, "Primary.ClipSize"))) or clipstr:format(self:Clip2())
				draw.DrawText(str, "TFASleekSmall", xx + 1, yy + 1, ColorAlpha(self2.TextColContrast, myalpha), TEXT_ALIGN_RIGHT)
				draw.DrawText(str, "TFASleekSmall", xx, yy, ColorAlpha(self2.TextCol, myalpha), TEXT_ALIGN_RIGHT)
				str = language.GetPhrase("tfa.hud.ammo.reserve2"):format(self2.Ammo2(self))
				yy = yy + TFA.Fonts.SleekHeightSmall
				xx = xx - TFA.Fonts.SleekHeightSmall / 3
				draw.DrawText(str, "TFASleekSmall", xx + 1, yy + 1, ColorAlpha(self2.TextColContrast, myalpha), TEXT_ALIGN_RIGHT)
				draw.DrawText(str, "TFASleekSmall", xx, yy, ColorAlpha(self2.TextCol, myalpha), TEXT_ALIGN_RIGHT)
			else
				str = language.GetPhrase("tfa.hud.ammo2"):format(self2.Ammo2(self))
				draw.DrawText(str, "TFASleekSmall", xx + 1, yy + 1, ColorAlpha(self2.TextColContrast, myalpha), TEXT_ALIGN_RIGHT)
				draw.DrawText(str, "TFASleekSmall", xx, yy, ColorAlpha(self2.TextCol, myalpha), TEXT_ALIGN_RIGHT)
			end
		end
	end
end

local sv_tfa_recoil_legacy = GetConVar("sv_tfa_recoil_legacy")
local cl_tfa_hud_crosshair_pump = GetConVar("cl_tfa_hud_crosshair_pump")
local sv_tfa_fixed_crosshair = GetConVar("sv_tfa_fixed_crosshair")

local crosshairMatrix = Matrix()
local crosshairMatrixLeft = Matrix()
local crosshairMatrixRight = Matrix()
local crosshairRotation = Angle()

local pixelperfectshift = Vector(-0.5)

function SWEP:CalculateCrosshairConeRecoil()
	return self:GetStatL("CrosshairConeRecoilOverride", false) or self:CalculateConeRecoil()
end

function SWEP:DoDrawCrosshair()
	local self2 = self:GetTable()
	local x, y

	if not self2.ratios_calc or not self2.DrawCrosshairDefault then return true end
	if self2.GetHolding(self) then return true end

	local stat = self2.GetStatus(self)

	if not crosscustomenable_cvar:GetBool() then
		return TFA.Enum.ReloadStatus[stat] or math.min(1 - (self2.IronSightsProgressUnpredicted2 or self:GetIronSightsProgress()), 1 - self:GetSprintProgress(), 1 - self:GetInspectingProgress()) <= 0.5
	end

	self2.clrelp = self2.clrelp or 0
	self2.clrelp = math.Approach(
		self2.clrelp,
		TFA.Enum.ReloadStatus[stat] and 0 or 1,
		((TFA.Enum.ReloadStatus[stat] and 0 or 1) - self2.clrelp) * RealFrameTime() * 7)

	local crossa = crossa_cvar:GetFloat() *
		math.pow(math.min(1 - (((self2.IronSightsProgressUnpredicted2 or self:GetIronSightsProgress()) and
			not self2.GetStatL(self, "DrawCrosshairIronSights")) and (self2.IronSightsProgressUnpredicted2 or self:GetIronSightsProgress()) or 0),
			1 - self:GetSprintProgress(),
			1 - self:GetInspectingProgress(),
			self2.clrelp),
		2)

	local outa = outa_cvar:GetFloat() *
		math.pow(math.min(1 - (((self2.IronSightsProgressUnpredicted2 or self:GetIronSightsProgress()) and
			not self2.GetStatL(self, "DrawCrosshairIronSights")) and (self2.IronSightsProgressUnpredicted2 or self:GetIronSightsProgress()) or 0),
			1 - self:GetSprintProgress(),
			1 - self:GetInspectingProgress(),
			self2.clrelp),
		2)

	local ply = LocalPlayer()
	if not ply:IsValid() or self:GetOwner() ~= ply then return false end

	if not ply.interpposx then
		ply.interpposx = ScrW() / 2
	end

	if not ply.interpposy then
		ply.interpposy = ScrH() / 2
	end

	local tr = {}
	tr.start = ply:GetShootPos()
	tr.endpos = tr.start + ply:GetAimVector() * 0x7FFF
	tr.filter = ply
	tr.mask = MASK_SHOT
	local traceres = util.TraceLine(tr)
	local targent = traceres.Entity

	-- If we're drawing the local player, draw the crosshair where they're aiming
	-- instead of in the center of the screen.
	if self:GetOwner():ShouldDrawLocalPlayer() and not ply:GetNW2Bool("ThirtOTS", false) then
		local coords = traceres.HitPos:ToScreen()
		coords.x = math.Clamp(coords.x, 0, ScrW())
		coords.y = math.Clamp(coords.y, 0, ScrH())
		ply.interpposx = math.Approach(ply.interpposx, coords.x, (ply.interpposx - coords.x) * RealFrameTime() * 7.5)
		ply.interpposy = math.Approach(ply.interpposy, coords.y, (ply.interpposy - coords.y) * RealFrameTime() * 7.5)
		x, y = ply.interpposx, ply.interpposy
		-- Center of screen
	elseif sv_tfa_fixed_crosshair:GetBool() then
		x, y = ScrW() / 2, ScrH() / 2
	else
		tr.endpos = tr.start + self:GetAimAngle():Forward() * 0x7FFF
		local pos = util.TraceLine(tr).HitPos:ToScreen()
		x, y = pos.x, pos.y
	end

	TFA.LastCrosshairPosX, TFA.LastCrosshairPosY = x, y

	local v = hook.Run("TFA_DrawCrosshair", self, x, y)

	if v ~= nil then
		return v
	end

	local s_cone = self:CalculateCrosshairConeRecoil()

	if not self2.selftbl then
		self2.selftbl = {ply, self}
	end

	local crossr, crossg, crossb, crosslen, crosshairwidth, drawdot, teamcol
	teamcol = self2.GetTeamColor(self, targent)
	crossr = crossr_cvar:GetFloat()
	crossg = crossg_cvar:GetFloat()
	crossb = crossb_cvar:GetFloat()
	crosslen = crosslen_cvar:GetFloat() * 0.01
	crosscol.r = crossr
	crosscol.g = crossg
	crosscol.b = crossb
	crosscol.a = crossa
	crosscol = ColorMix(crosscol, teamcol, 1, CMIX_MULT)
	crossr = crosscol.r
	crossg = crosscol.g
	crossb = crosscol.b
	crossa = crosscol.a
	crosshairwidth = crosshairwidth_cvar:GetFloat()
	drawdot = drawdot_cvar:GetBool()
	local scale = (s_cone * 90) / self:GetOwner():GetFOV() * ScrH() / 1.44 * cgapscale_cvar:GetFloat()

	if self:GetSprintProgress() >= 0.1 and not self:GetStatL("AllowSprintAttack", false) then
		scale = scale * (1 + TFA.Cubic(self:GetSprintProgress() - 0.1) * 6)
	end

	if self2.clrelp < 0.9 then
		scale = scale * Lerp(TFA.Cubic(0.9 - self2.clrelp) * 1.111, 1, 8)
	end

	local gap = math.Round(scale / 2) * 2
	local length

	if not clen_usepixels:GetBool() then
		length = gap + ScrH() * 1.777 * crosslen
	else
		length = gap + crosslen * 100
	end

	local extraRotation = 0
	local cPos = Vector(x, y)

	if stat == TFA.Enum.STATUS_PUMP and cl_tfa_hud_crosshair_pump:GetBool() then
		if tricross_cvar:GetBool() then
			extraRotation =  TFA.Quintic(self:GetStatusProgress(true))
			local mul = 360
			extraRotation = extraRotation * mul
		else
			extraRotation = TFA.Quintic(TFA.Cosine(self:GetStatusProgress(true)))
			local mul = -180

			if extraRotation < 0.5 then
				extraRotation = extraRotation * mul
			else
				extraRotation = (1 - extraRotation) * mul
			end
		end
	end

	extraRotation = extraRotation - EyeAngles().r

	crosshairMatrix:Identity()
	crosshairMatrix:Translate(cPos)
	crosshairRotation.y = extraRotation
	crosshairMatrix:Rotate(crosshairRotation)

	if tricross_cvar:GetBool() then
		crosshairMatrixLeft:Identity()
		crosshairMatrixRight:Identity()

		crosshairMatrixLeft:Translate(cPos)
		crosshairMatrixRight:Translate(cPos)

		crosshairRotation.y = extraRotation + 135
		crosshairMatrixRight:SetAngles(crosshairRotation)
		crosshairRotation.y = extraRotation - 135
		crosshairMatrixLeft:SetAngles(crosshairRotation)

		if crosshairwidth % 2 ~= 0 then
			crosshairMatrixLeft:Translate(pixelperfectshift)
			crosshairMatrixRight:Translate(pixelperfectshift)
		end
	end

	DisableClipping(true)

	render.PushFilterMag(TEXFILTER.ANISOTROPIC)
	render.PushFilterMin(TEXFILTER.ANISOTROPIC)

	--Outline
	if outline_enabled_cvar:GetBool() then
		local outr, outg, outb, outlinewidth
		outr = outr_cvar:GetFloat()
		outg = outg_cvar:GetFloat()
		outb = outb_cvar:GetFloat()
		outlinewidth = outlinewidth_cvar:GetFloat()

		cam.PushModelMatrix(crosshairMatrix)
		surface.SetDrawColor(outr, outg, outb, outa)

		local tHeight = math.Round(length - gap + outlinewidth * 2) + crosshairwidth

		local tX, tY, tWidth =
			math.Round(-outlinewidth) - crosshairwidth / 2,
			-gap * self:GetStatL("Primary.SpreadBiasPitch") - tHeight + outlinewidth,
			math.Round(outlinewidth * 2) + crosshairwidth

		-- Top
		surface.DrawRect(tX, tY, tWidth, tHeight)
		cam.PopModelMatrix()

		if tricross_cvar:GetBool() then
			tY = -gap - tHeight

			cam.PushModelMatrix(crosshairMatrixLeft)
			surface.DrawRect(tX, tY + outlinewidth, tWidth, tHeight)
			cam.PopModelMatrix()

			cam.PushModelMatrix(crosshairMatrixRight)
			surface.DrawRect(tX, tY + outlinewidth, tWidth, tHeight)
			cam.PopModelMatrix()
		else
			cam.PushModelMatrix(crosshairMatrix)

			local width = math.Round(length - gap + outlinewidth * 2) + crosshairwidth
			local realgap = math.Round(gap * self:GetStatL("Primary.SpreadBiasYaw") - outlinewidth) - crosshairwidth / 2

			-- Left
			surface.DrawRect(
				-realgap - width,
				math.Round(-outlinewidth) - crosshairwidth / 2,
				width,
				math.Round(outlinewidth * 2) + crosshairwidth)

			-- Right
			surface.DrawRect(
				realgap,
				math.Round(-outlinewidth) - crosshairwidth / 2,
				width,
				math.Round(outlinewidth * 2) + crosshairwidth)

			-- Bottom
			surface.DrawRect(
				math.Round(-outlinewidth) - crosshairwidth / 2,
				math.Round(gap * self:GetStatL("Primary.SpreadBiasPitch") - outlinewidth) - crosshairwidth / 2,
				math.Round(outlinewidth * 2) + crosshairwidth,
				math.Round(length - gap + outlinewidth * 2) + crosshairwidth)

			cam.PopModelMatrix()
		end

		if drawdot then
			cam.PushModelMatrix(crosshairMatrix)
			surface.DrawRect(-math.Round((crosshairwidth - 1) / 2) - math.Round(outlinewidth), -math.Round((crosshairwidth - 1) / 2) - math.Round(outlinewidth), math.Round(outlinewidth * 2) + crosshairwidth, math.Round(outlinewidth * 2) + crosshairwidth) --dot
			cam.PopModelMatrix()
		end
	end

	--Main Crosshair
	cam.PushModelMatrix(crosshairMatrix)
	surface.SetDrawColor(crossr, crossg, crossb, crossa)

	local tHeight = math.Round(length - gap) + crosshairwidth

	local tX, tY, tWidth =
		-crosshairwidth / 2,
		math.Round(-gap * self:GetStatL("Primary.SpreadBiasPitch") - tHeight),
		crosshairwidth

	-- Top
	surface.DrawRect(tX, tY, tWidth, tHeight)
	cam.PopModelMatrix()

	if tricross_cvar:GetBool() then
		local xhl = math.Round(length - gap) + crosshairwidth

		tY = math.Round(-gap - tHeight)

		cam.PushModelMatrix(crosshairMatrixLeft)
		surface.DrawRect(tX, tY, tWidth, tHeight)
		cam.PopModelMatrix()

		cam.PushModelMatrix(crosshairMatrixRight)
		surface.DrawRect(tX, tY, tWidth, tHeight)
		cam.PopModelMatrix()
	else
		cam.PushModelMatrix(crosshairMatrix)

		local width = math.Round(length - gap) + crosshairwidth
		local realgap = math.Round(gap * self:GetStatL("Primary.SpreadBiasYaw")) - crosshairwidth / 2

		-- Left
		surface.DrawRect(
			-realgap - width,
			-crosshairwidth / 2,
			width,
			crosshairwidth)

		-- Right
		surface.DrawRect(
			realgap,
			-crosshairwidth / 2,
			width,
			crosshairwidth)

		-- Bottom
		surface.DrawRect(
			-crosshairwidth / 2,
			math.Round(gap * self:GetStatL("Primary.SpreadBiasPitch")) - crosshairwidth / 2,
			crosshairwidth,
			math.Round(length - gap) + crosshairwidth)

		cam.PopModelMatrix()
	end

	render.PopFilterMag()
	render.PopFilterMin()

	if drawdot then
		cam.PushModelMatrix(crosshairMatrix)
		surface.DrawRect(-math.Round((crosshairwidth - 1) / 2), -math.Round((crosshairwidth - 1) / 2), crosshairwidth, crosshairwidth) --dot
		cam.PopModelMatrix()
	end

	DisableClipping(false)

	return true
end

function SWEP:DrawScopeOverlay()
	if hook.Run("TFA_DrawScopeOverlay", self) == true then return end
	local self2 = self:GetTable()

	local tbl

	if self2.GetStatL(self, "Secondary.UseACOG") then
		tbl = TFA_SCOPE_ACOG
	end

	if self2.GetStatL(self, "Secondary.UseMilDot") then
		tbl = TFA_SCOPE_MILDOT
	end

	if self2.GetStatL(self, "Secondary.UseSVD") then
		tbl = TFA_SCOPE_SVD
	end

	if self2.GetStatL(self, "Secondary.UseParabolic") then
		tbl = TFA_SCOPE_PARABOLIC
	end

	if self2.GetStatL(self, "Secondary.UseElcan") then
		tbl = TFA_SCOPE_ELCAN
	end

	if self2.GetStatL(self, "Secondary.UseGreenDuplex") then
		tbl = TFA_SCOPE_GREENDUPLEX
	end

	if self2.GetStatL(self, "Secondary.UseAimpoint") then
		tbl = TFA_SCOPE_AIMPOINT
	end

	if self2.GetStatL(self, "Secondary.UseMatador") then
		tbl = TFA_SCOPE_MATADOR
	end

	if self2.GetStatL(self, "Secondary.ScopeTable") then
		tbl = self2.GetStatL(self, "Secondary.ScopeTable")
	end

	if not tbl then
		tbl = TFA_SCOPE_MILDOT
	end

	local w, h = ScrW(), ScrH()

	for k, v in pairs(tbl) do
		local dimension = h

		if k == "ScopeBorder" then
			if istable(v) then
				surface.SetDrawColor(v)
			else
				surface.SetDrawColor(color_black)
			end

			surface.DrawRect(0, 0, w / 2 - dimension / 2, dimension)
			surface.DrawRect(w / 2 + dimension / 2, 0, w / 2 - dimension / 2, dimension)
		elseif k == "ScopeMaterial" then
			surface.SetMaterial(v)
			surface.SetDrawColor(255, 255, 255, 255)
			surface.DrawTexturedRect(w / 2 - dimension / 2, (h - dimension) / 2, dimension, dimension)
		elseif k == "ScopeOverlay" then
			surface.SetMaterial(v)
			surface.SetDrawColor(255, 255, 255, 255)
			surface.DrawTexturedRect(0, 0, w, h)
		elseif k == "ScopeCrosshair" then
			local t = type(v)

			if t == "IMaterial" then
				surface.SetMaterial(v)
				surface.SetDrawColor(255, 255, 255, 255)
				surface.DrawTexturedRect(w / 2 - dimension / 4, h / 2 - dimension / 4, dimension / 2, dimension / 2)
			elseif t == "table" then
				if not v.cached then
					v.cached = true
					v.r = v.r or v.x or v[1] or 0
					v.g = v.g or v.y or v[2] or v[1] or 0
					v.b = v.b or v.z or v[3] or v[1] or 0
					v.a = v.a or v[4] or 255
					v.s = v.Scale or v.scale or v.s or 0.25
				end

				surface.SetDrawColor(v.r, v.g, v.b, v.a)

				if v.Material then
					surface.SetMaterial(v.Material)
					surface.DrawTexturedRect(w / 2 - dimension * v.s / 2, h / 2 - dimension * v.s / 2, dimension * v.s, dimension * v.s)
				elseif v.Texture then
					surface.SetTexture(v.Texture)
					surface.DrawTexturedRect(w / 2 - dimension * v.s / 2, h / 2 - dimension * v.s / 2, dimension * v.s, dimension * v.s)
				else
					surface.DrawRect(w / 2 - dimension * v.s / 2, h / 2, dimension * v.s, 1)
					surface.DrawRect(w / 2, h / 2 - dimension * v.s / 2, 1, dimension * v.s)
				end
			end
		else
			if k == "scopetex" then
				dimension = dimension * self:GetStatL("ScopeScale") ^ 2 * TFA_SCOPE_SCOPESCALE
			elseif k == "reticletex" then
				dimension = dimension * (self:GetStatL("ReticleScale") and self:GetStatL("ReticleScale") or 1) ^ 2 * (TFA_SCOPE_RETICLESCALE and TFA_SCOPE_RETICLESCALE or 1)
			else
				dimension = dimension * self:GetStatL("ReticleScale") ^ 2 * TFA_SCOPE_DOTSCALE
			end

			surface.SetDrawColor(255, 255, 255, 255)
			surface.SetTexture(v)
			surface.DrawTexturedRect(w / 2 - dimension / 2, (h - dimension) / 2, dimension, dimension)
		end
	end
end

SWEP.KeyNameOverrides = {
	["MOUSE1"] = "tfa.keys.lmb",
	["MOUSE2"] = "tfa.keys.rmb",
	["MOUSE3"] = "tfa.keys.mmb",
}

function SWEP:GetKeyBind(binds, altbind)
	if type(binds) == "string" then
		binds = {binds}
	end

	if altbind then
		local cvar = GetConVar("cl_tfa_keys_" .. altbind)

		if cvar and cvar:GetInt() > 0 then
			local key = input.GetKeyName(cvar:GetInt())

			return language.GetPhrase(self.KeyNameOverrides[key] or key:upper())
		end
	end

	local result = {}
	for _,bind in ipairs(binds) do
		local binding = input.LookupBinding(bind, true) or input.LookupBinding(bind)

		table.insert(result, binding and language.GetPhrase(self.KeyNameOverrides[binding] or binding:upper()) or bind)
	end

	return result
end

local cv_cm = GetConVar("sv_tfa_cmenu")
local cv_cm_key = GetConVar("sv_tfa_cmenu_key")
local cv_ironsights = GetConVar("sv_tfa_ironsights_enabled")

function SWEP:PrePopulateKeyBindHints(keys)
	return keys
end

function SWEP:PostPopulateKeyBindHints(keys)
	return keys
end

function SWEP:PopulateKeyBindHints(keys)
	keys = keys or {}

	keys = self:PrePopulateKeyBindHints(keys) or keys

	local CanAim = cv_ironsights:GetInt() and self:GetStatL("Secondary.IronSightsEnabled")
	if CanAim then
		table.insert(keys, {
			label = language.GetPhrase("tfa.hint.keys.ironsights"),
			keys = {self:GetKeyBind({"+attack2"})}
		})
	end

	if self.BashBase then
		if self:GetStatL("Secondary.CanBash") ~= false then
			table.insert(keys, {
				label = language.GetPhrase("tfa.hint.keys.meleebash"),
				keys = {CanAim and self:GetKeyBind({"+zoom"}, "bash") or self:GetKeyBind("+attack2")}
			})
		end
	elseif self.AltAttack then
		table.insert(keys, {
			label = language.GetPhrase("tfa.hint.keys.altattack"),
			keys = {CanAim and self:GetKeyBind({"+zoom"}, "bash") or self:GetKeyBind("+attack2")}
		})
	end

	if cv_cm:GetBool() and cv_cm_key:GetInt() ~= 0 then
		local kcode = cv_cm_key:GetInt()
		table.insert(keys, {
			label = language.GetPhrase("tfa.hint.keys.customize"),
			keys = {kcode > 0 and language.GetPhrase(input.GetKeyName(kcode)):upper() or self:GetKeyBind({"+menu_context"}, "customize")}
		})
	end

	if self:GetActivityEnabled(ACT_VM_FIDGET) or self.InspectionActions then
		table.insert(keys, {
			label = language.GetPhrase("tfa.hint.keys.inspect"),
			keys = {self:GetKeyBind({"+reload"}, "inspect")}
		})
	end

	if self:GetStatL("SelectiveFire") then
		table.insert(keys, {
			label = language.GetPhrase("tfa.hint.keys.firemode"),
			keys = {self:GetKeyBind({"+use", "+reload"}, "firemode")}
		})
	end

	if not self.IsMelee and not self.IsBow and not self.IsKnife then
		table.insert(keys, {
			label = language.GetPhrase("tfa.hint.keys.safety"),
			keys = {self:GetKeyBind({"+speed"}), self:GetKeyBind({"+use", "+reload"}, "firemode")}
		})
	end

	if self:GetStatL("FlashlightAttachmentName") ~= nil or self:GetStatL("FlashlightAttachment", 0) > 0 then
		table.insert(keys, {
			label = language.GetPhrase("tfa.hint.keys.flashlight"),
			keys = {self:GetKeyBind({"impulse 100"})}
		})
	end

	if self:GetStatRawL("CanBeSilenced") then
		table.insert(keys, {
			label = language.GetPhrase("tfa.hint.keys.silencer"),
			keys = {self:GetKeyBind({"+use", "+attack"}, "silencer")}
		})
	end

	keys = self:PostPopulateKeyBindHints(keys) or keys
	keys = hook.Run("TFA_PopulateKeyBindHints", self, keys) or keys

	if #keys > 0 then
		table.insert(keys, {
			label = language.GetPhrase("tfa.hint.keys.showkeys"),
			keys = {self:GetKeyBind({"+showscores"})}
		})
	end

	return keys
end

local GradientMaterial = Material("gui/gradient")
-- SWEP.KeyBindHintAlphaLastUpdate = -1

local lastwep_kb
function SWEP:ResetKeyBindHintAlpha(force)
	if (not force or force == "") and lastwep_kb == self then return end
	lastwep_kb = self

	self.KeyBindHintAlphaLastUpdate = CurTime()
end

local cv_hint_enabled = GetConVar("cl_tfa_hud_keybindhints_enabled")
local cv_hint_solidtime = GetConVar("cl_tfa_hud_keybindhints_solidtime")
local cv_hint_fadeintime = GetConVar("cl_tfa_hud_keybindhints_fadeintime")
local cv_hint_fadeouttime = GetConVar("cl_tfa_hud_keybindhints_fadeouttime")

local HintAlpha = 0
function SWEP:DrawKeyBindHints()
	if self:GetOwner():KeyDown(IN_SCORE) or not self.KeyBindHintAlphaLastUpdate then
		self:ResetKeyBindHintAlpha(true)
	end

	local fadeout =  CurTime() >= self.KeyBindHintAlphaLastUpdate + cv_hint_solidtime:GetFloat()
	HintAlpha = math.Clamp(HintAlpha + (fadeout and FrameTime() * -1000 / cv_hint_fadeouttime:GetFloat() or FrameTime() * 1000 / cv_hint_fadeintime:GetFloat()), 0, 255)

	if not cv_hint_enabled:GetBool() or cv_hint_solidtime:GetFloat() <= 0 then return end

	local a = HintAlpha
	if self:GetInspectingProgress() > 0 then
		a = a * (1 - self:GetInspectingProgress())
	end

	if a <= 0 then return end

	local maincol, bgcol = ColorAlpha(INSPECTION_PRIMARYCOLOR, a), INSPECTION_BACKGROUND
	local textfont = "TFA_INSPECTION_SMALL"
	local textheight = TFA.Fonts.InspectionHeightSmall

	local x, y = ScrW() - ScaleH(80), ScrH() * .5
	local bgpad = ScaleH(8)

	local keystbl = self:PopulateKeyBindHints({})
	if #keystbl <= 0 then return end

	local keystr = {}
	local TargetWidth = 0
	surface.SetFont(textfont)
	for _, tbl in ipairs(keystbl) do
		local key = ""
		for k, v in ipairs(tbl.keys) do
			tbl.keys[k] = type(v) == "table" and table.concat(v, " + ") or v
		end

		local keytext = string.format("[%s] - %s", table.concat(tbl.keys, " + "), tbl.label)

		local tw, _ = surface.GetTextSize(keytext)
		TargetWidth = math.max(tw, TargetWidth)

		table.insert(keystr, keytext)
	end
	x = x - TargetWidth
	y = y - textheight * #keystr * .5

	if hook.Run("TFA_PreDrawKeyBindHint", self, x, y, a, keystbl, keystr) == true then return end

	surface.SetDrawColor(bgcol.r, bgcol.g, bgcol.b, a)
	surface.SetMaterial(GradientMaterial)
	surface.DrawTexturedRectUV(x - bgpad, y - bgpad, TargetWidth + bgpad * 2, textheight * #keystr + bgpad * 2, 1, 0, 0, 1)

	for i, key in ipairs(keystr) do
		TextShadowPaint({Text = key, Font = textfont, TextColor = maincol, TextPosX = x, TextPosY = y + (i - 1) * textheight})
	end

	hook.Run("TFA_PostDrawKeyBindHint", self, x, y, a, keystbl, keystr)
end


local fsin, icon
local matcache = {}

function SWEP:DrawWeaponSelection(x, y, wide, tall, alpha)
	local self2 = self:GetTable()

	surface.SetDrawColor(255, 255, 255, alpha)

	icon = self2.GetStatL(self, "WepSelectIcon_Override", self2.WepSelectIcon)

	if not icon then
		self2.IconFix(self)

		return
	end

	local ticon = type(icon)

	if ticon == "IMaterial" then
		surface.SetMaterial(icon)
	elseif ticon == "string" then
		if not matcache[icon] then
			matcache[icon] = Material(icon, "smooth noclamp")
		end

		surface.SetMaterial(matcache[icon])
	else
		surface.SetTexture(icon)
	end

	fsin = self2.BounceWeaponIcon and math.sin( RealTime() * 10 ) * 5 or 0

	-- Borders
	y = y + 10
	x = x + 10
	wide = wide - 20

	surface.DrawTexturedRect(x + fsin, y - fsin, wide - fsin * 2, wide / 2 + fsin)

	self2.PrintWeaponInfo(self, x + wide + 20, y + tall * 0.95, alpha)
end

--addons/tfa_base/lua/weapons/tfa_gun_base/client/fov.lua:
local LocalPlayer = LocalPlayer
local math = math

local function GetScreenAspectRatio()
	return ScrW() / ScrH()
end

local function ScaleFOVByWidthRatio(fovDegrees, ratio)
	local halfAngleRadians = fovDegrees * (0.5 * math.pi / 180.0)
	local t = math.tan(halfAngleRadians)
	t = t * ratio
	local retDegrees = (180.0 / math.pi) * math.atan(t)

	return retDegrees * 2.0
end

local default_fov_cv = GetConVar("default_fov")

function SWEP:GetTrueFOV()
	local fov = TFADUSKFOV or default_fov_cv:GetFloat()
	local ply = LocalPlayer()

	if not ply:IsValid() then return fov end

	if ply:GetFOV() < ply:GetDefaultFOV() - 1 then
		fov = ply:GetFOV()
	end

	if TFADUSKFOV_FINAL then
		fov = TFADUSKFOV_FINAL
	end

	return fov
end

function SWEP:GetViewModelFinalFOV()
	local fov_default = default_fov_cv:GetFloat()
	local fov = self:GetTrueFOV()
	local flFOVOffset = fov_default - fov
	local fov_vm = self.ViewModelFOV - flFOVOffset
	local aspectRatio = GetScreenAspectRatio() * 0.75 -- (4/3)
	--local final_fov = ScaleFOVByWidthRatio( fov,  aspectRatio )
	local final_fovViewmodel = ScaleFOVByWidthRatio(fov_vm, aspectRatio)

	return final_fovViewmodel
end

--addons/tfa_base/lua/weapons/tfa_melee_base/cl_init.lua:
include("shared.lua")

--lua/weapons/tfa_swsft_base/cl_init.lua:
include('shared.lua')

SWEP.PrintName				= ""				// 'Nice' Weapon name (Shown on HUD)	
SWEP.Slot				= 4				// Slot in the weapon selection menu
SWEP.SlotPos				= 1				// Position in the slot
SWEP.DrawAmmo				= true				// Should draw the default HL2 ammo counter				// Should draw the default crosshair
SWEP.DrawWeaponInfoBox			= true			// Should draw the weapon info box
SWEP.BounceWeaponIcon   			= false				// Should the weapon icon bounce?
SWEP.CSMuzzleFlashes			= false


--addons/wiltos_animation_base/lua/weapons/weapon_base/sh_anim.lua:
local ActIndex = {
	[ "pistol" ] 		= ACT_HL2MP_IDLE_PISTOL,
	[ "smg" ] 			= ACT_HL2MP_IDLE_SMG1,
	[ "grenade" ] 		= ACT_HL2MP_IDLE_GRENADE,
	[ "ar2" ] 			= ACT_HL2MP_IDLE_AR2,
	[ "shotgun" ] 		= ACT_HL2MP_IDLE_SHOTGUN,
	[ "rpg" ]	 		= ACT_HL2MP_IDLE_RPG,
	[ "physgun" ] 		= ACT_HL2MP_IDLE_PHYSGUN,
	[ "crossbow" ] 		= ACT_HL2MP_IDLE_CROSSBOW,
	[ "melee" ] 		= ACT_HL2MP_IDLE_MELEE,
	[ "slam" ] 			= ACT_HL2MP_IDLE_SLAM,
	[ "normal" ]		= ACT_HL2MP_IDLE,
	[ "fist" ]			= ACT_HL2MP_IDLE_FIST,
	[ "melee2" ]		= ACT_HL2MP_IDLE_MELEE2,
	[ "passive" ]		= ACT_HL2MP_IDLE_PASSIVE,
	[ "knife" ]			= ACT_HL2MP_IDLE_KNIFE,
	[ "duel" ]			= ACT_HL2MP_IDLE_DUEL,
	[ "camera" ]		= ACT_HL2MP_IDLE_CAMERA,
	[ "magic" ]			= ACT_HL2MP_IDLE_MAGIC,
	[ "revolver" ]		= ACT_HL2MP_IDLE_REVOLVER
}

--[[---------------------------------------------------------
   Name: SetWeaponHoldType
   Desc: Sets up the translation table, to translate from normal 
			standing idle pose, to holding weapon pose.
-----------------------------------------------------------]]
function SWEP:SetWeaponHoldType( t )

	t = string.lower( t )
	local index = ActIndex[ t ]
	
	if ( index == nil ) and !wOS.AnimExtension.TranslateHoldType[ t ] then
		Msg( "SWEP:SetWeaponHoldType - ActIndex[ \""..t.."\" ] isn't set! (defaulting to normal)\n" )
		t = "normal"
		index = ActIndex[ t ]		
	end
	
	if wOS.AnimExtension.TranslateHoldType[ t ] then 
		self.ActivityTranslate = table.Copy( wOS.AnimExtension.TranslateHoldType[ t ]:GetActivityList() )
	else
		self.ActivityTranslate = {}
		self.ActivityTranslate [ ACT_MP_STAND_IDLE ] 				= index
		self.ActivityTranslate [ ACT_MP_WALK ] 						= index+1
		self.ActivityTranslate [ ACT_MP_RUN ] 						= index+2
		self.ActivityTranslate [ ACT_MP_CROUCH_IDLE ] 				= index+3
		self.ActivityTranslate [ ACT_MP_CROUCHWALK ] 				= index+4
		self.ActivityTranslate [ ACT_MP_ATTACK_STAND_PRIMARYFIRE ] 	= index+5
		self.ActivityTranslate [ ACT_MP_ATTACK_CROUCH_PRIMARYFIRE ] = index+5
		self.ActivityTranslate [ ACT_MP_RELOAD_STAND ]		 		= index+6
		self.ActivityTranslate [ ACT_MP_RELOAD_CROUCH ]		 		= index+6
		self.ActivityTranslate [ ACT_MP_JUMP ] 						= index+7
		self.ActivityTranslate [ ACT_RANGE_ATTACK1 ] 				= index+8
		self.ActivityTranslate [ ACT_MP_SWIM ] 						= index+9	
	end
	
	-- "normal" jump animation doesn't exist
	if t == "normal" then
		self.ActivityTranslate [ ACT_MP_JUMP ] = ACT_HL2MP_JUMP_SLAM
	end

	self:SetupWeaponHoldTypeForAI( t )

end

-- Default hold pos is the pistol
SWEP:SetWeaponHoldType( "pistol" )

--[[---------------------------------------------------------
   Name: weapon:TranslateActivity( )
   Desc: Translate a player's Activity into a weapon's activity
		 So for example, ACT_HL2MP_RUN becomes ACT_HL2MP_RUN_PISTOL
		 Depending on how you want the player to be holding the weapon
-----------------------------------------------------------]]
function SWEP:TranslateActivity( act )

	if ( self.Owner:IsNPC() ) then
		if ( self.ActivityTranslateAI[ act ] ) then
			return self.ActivityTranslateAI[ act ]
		end
		return -1
	end

	if ( self.ActivityTranslate[ act ] != nil ) then
		return self.ActivityTranslate[ act ]
	end

	return -1

end
--lua/weapons/weapon_chemlight_purple/cl_init.lua:
include('shared.lua')

SWEP.Slot			= 4; 
SWEP.SlotPos		= 8; 
SWEP.Spawnable		= true
SWEP.AdminSpawnable	= true
SWEP.WepSelectIcon	= surface.GetTextureID( "vgui/entities/glowstick2" )
--lua/weapons/weapon_chemlight_rgb/cl_init.lua:
include('shared.lua')

SWEP.Slot			= 4; 
SWEP.SlotPos		= 8; 
SWEP.Spawnable		= true
SWEP.AdminSpawnable	= true
SWEP.WepSelectIcon	= surface.GetTextureID( "vgui/entities/glowstick2" )
--lua/weapons/weapon_chemlight_rgb/shared.lua:
if ( CLIENT ) then
	language.Add ("ent_chemlight", "Chemlight")
	language.Add ("glowsticks_ammo", "Glow Sticks")
	language.Add ("cleanup_glowsticks", "Chemlight")
	language.Add ("cleaned_glowsticks", "Chemlight is gone!")
  	SWEP.DrawAmmo			= true
	SWEP.DrawCrosshair		= true
	SWEP.ViewModelFOV		= 67
	SWEP.ViewModelFlip		= false
	SWEP.CSMuzzleFlashes	= false
	SWEP.HoldType			= "slam"	
	SWEP.PrintName			= "Chemlight RGB"
	SWEP.Author				= "Patrick Hunt"
end
SWEP.IronSightsPos  = Vector(0, -16, -56)
SWEP.IronSightsAng  = Vector(0, 0, 0)

function SWEP:GetViewModelPosition(EyePos, EyeAng)
	local Mul = 1.0

	local Offset = self.IronSightsPos

	if (self.IronSightsAng) then
        EyeAng = EyeAng * 1
        
		EyeAng:RotateAroundAxis(EyeAng:Right(), 	self.IronSightsAng.x * Mul)
		EyeAng:RotateAroundAxis(EyeAng:Up(), 		self.IronSightsAng.y * Mul)
		EyeAng:RotateAroundAxis(EyeAng:Forward(),   self.IronSightsAng.z * Mul)
	end

	local Right 	= EyeAng:Right()
	local Up 		= EyeAng:Up()
	local Forward 	= EyeAng:Forward()

	EyePos = EyePos + Offset.x * Right * Mul
	EyePos = EyePos + Offset.y * Forward * Mul
	EyePos = EyePos + Offset.z * Up * Mul
	
	return EyePos, EyeAng
end

SWEP.Author					= "Patrick Hunt"
SWEP.Contact				= ""
SWEP.Purpose				= ""
SWEP.Instructions			= "Use primary attack to throw a glowstick and secondary to drop."
SWEP.HoldType				= "slam"
SWEP.Category				= "Chemlight"

SWEP.Spawnable				= true
SWEP.AdminSpawnable			= true

--SWEP.ViewModel				= "models/weapons/c_glowstick.mdl"
--SWEP.WorldModel				= "models/glowstick/glowstick.mdl"
SWEP.UseHands				= true
SWEP.BounceWeaponIcon		= false
SWEP.DrawWeaponInfoBox		= false

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= 5
SWEP.Primary.Automatic		= false
SWEP.Primary.Ammo			= "glowsticks"
SWEP.Primary.Delay			= 1

SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Automatic	= false
SWEP.Secondary.Ammo			= "none"
SWEP.Secondary.Delay		= 1


function SWEP:Initialize()
	util.PrecacheSound("glowstick/glowstick_snap.wav");
	util.PrecacheSound("glowstick/glowstick_shake.wav");
	self:SetWeaponHoldType( self.HoldType )
	
if GetGlobalBool( "global_Cheml_oldmodel" ) then 
self.ViewModel				= "models/weapons/c_chemstick_antic.mdl"
self.WorldModel				= "models/glowstick/chemstick_antic.mdl"
elseif GetGlobalBool( "global_Cheml_oldmodel" ) == false then
self.ViewModel				= "models/weapons/c_chemstick.mdl" 
self.WorldModel				= "models/glowstick/chemstick.mdl"
end

self.rgbr = 255
self.rgbg = 0
self.rgbb = 0
end

function SWEP:Think()

if  self.rgbg == 0 		and self.rgbb == 0 		then self.rgbr = 255 end
if  self.rgbr >= 255 	and self.rgbg == 0 		then self.rgbb = self.rgbb + 0.5 end
if  self.rgbb >= 255 	then self.rgbr = self.rgbr - 0.5 end
if  self.rgbr <= 0 		and self.rgbb >= 255 	then self.rgbg = self.rgbg + 0.5 end
if  self.rgbg >= 255 	and self.rgbr <= 0 		then self.rgbb = self.rgbb - 0.5 end
if  self.rgbb <= 0 		and self.rgbg == 255 	then self.rgbr = self.rgbr + 0.5 end
if  self.rgbr >= 255 	and self.rgbb <= 0 		then self.rgbg = self.rgbg - 0.5 end

if self.rgbr <= 0 		then self.rgbr = 0 		end if self.rgbg <= 0 		then self.rgbg = 0 		end if self.rgbb <= 0 		then self.rgbb = 0 end
if self.rgbr >= 255 	then self.rgbr = 255 	end if self.rgbg >= 255 	then self.rgbg = 255 	end if self.rgbb >= 255 	then self.rgbb = 255 end

self.Owner.navachemlightcolorcache = Color(self.rgbr, self.rgbg, self.rgbb, 255)
self.Owner:SetNW2Vector( "navachemlightcolorcache", Vector(self.rgbr/255, self.rgbg/255, self.rgbb/255) )

	if self.Owner:IsBot() then self:SetColor(Color(255,255,0,255)) else -- Bots create a shipload of errors since they don't have any client vars on them so let's set them all green (or i'm just stupid)
	self:SetColor(self.Owner.navachemlightcolorcache) -- Paints world model in real time

	if IsValid(self.Owner) then
		if CLIENT then
		local dlight = DynamicLight(self:EntIndex()+66, true)
			if dlight then
				dlight.pos = self.Owner:EyePos() - (self.Owner:GetAimVector() * 16)
				dlight.r = self.rgbr
				dlight.g = self.rgbg
				dlight.b = self.rgbb
				dlight.brightness = 6
				dlight.Decay = 1
				dlight.Size = 64
				--dlight.DieTime = CurTime() + 10
				
			end
		end
	end
	end
end


function SWEP:Deploy()
	self:SetColor(Color(255,255,0,255))
	if !self.Owner:IsBot() then
	self.Weapon:SendWeaponAnim(ACT_VM_DRAW);
	self.Weapon:SetNextPrimaryFire(CurTime() + 0.55)
	self.Weapon:SetNextSecondaryFire(CurTime() + 0.55)
	timer.Remove( "weapon_chemlight_rgb"..self.Owner:EntIndex() )
	timer.Create( "weapon_chemlight_rgb"..self.Owner:EntIndex(), 1.5, 1, function() self.Weapon:SendWeaponAnim( ACT_VM_IDLE ) end ) end
	if SERVER then
	
	-------------------------------------------------
	
			local matrix = self.Owner:GetBoneMatrix(1)
			local chempos = matrix:GetTranslation()

	local worldmodel = ents.FindInSphere(chempos,15)
	for k, v in pairs(worldmodel) do 
		if v:GetClass() == "ent_chemlight_glow_rgb" and v:GetOwner() == self.Owner and SERVER then
			v:Remove()
	end
	end
	
	-------------------------------------------------

	local glow = ents.Create("ent_chemlight_glow_rgb")
		glow:SetOwner(self.Owner) 
		glow:FollowBone( self.Owner, 1 )
		glow:SetLocalPos(Vector(0,0,0))
		if self.Owner:IsBot() then self:SetColor(Color(255,255,0,255)) else
		glow:SetColor(Color(self.rgbr, self.rgbg, self.rgbb, 255))
		end
		//glow:SetMaterial(self.Owner:GetMaterial())
		glow:Spawn()
		self.chemlightindex = glow:EntIndex()
	end
   return true
end


local cooldown = 0.5
local cooldown2 = 2
local lastReloadTime=0;
function SWEP:Reload()
if self.Owner:GetNW2Int( "chemlnavareloadtogglevar" ) == 0 then
if ((CurTime()-lastReloadTime)>cooldown) and SERVER then
		if (self.Owner:GetNW2Bool( "chemlightattachmentusage", false ) != true) then --create if there is no 
		if GetGlobalBool( "global_Cheml_Ammo", 1 ) == true then
		if ( self.Weapon:Ammo1() <= 0 ) then return end
		self:TakePrimaryAmmo(1)
		end
			timer.Simple( 0.6, function()
			local glow = ents.Create("ent_chemlight_for_attachment")
			glow:SetOwner(self.Owner)
			glow:SetModelScale( 0.01, 0 )
			glow:FollowBone( self.Owner, 3 )
			glow:SetLocalPos(Vector(10,10,3))
			glow:SetLocalAngles(Angle(-15,180,0))
			glow:SetNotSolid( true )
			if self.Owner:IsBot() then self:SetColor(Color(255,255,255,255)) else
			self.Owner:SetNW2Int( "chemlightattachmenRGB_R", self.rgbr )
			self.Owner:SetNW2Int( "chemlightattachmenRGB_G", self.rgbg )
			self.Owner:SetNW2Int( "chemlightattachmenRGB_B", self.rgbb )
			glow:SetColor(Color(self.Owner:GetNW2Int( "chemlightattachmenRGB_R", 0 ),self.Owner:GetNW2Int( "chemlightattachmenRGB_G", 0 ) ,self.Owner:GetNW2Int( "chemlightattachmenRGB_B", 0 ) , 255))
			glow:SetMaterial("Models/effects/vol_light001")
			glow:DrawShadow( false )
			end			
			glow:Spawn()
			--glow:SetNoDraw(true)

			self.Owner:SetNW2Int( "chemlightattachmentindex", glow:EntIndex() )
			sound.Play( "glowstick/carbiner.wav", glow:GetPos(), 75, math.random( 90, 110 ), math.Clamp( 0.5, 0.2, 0.7 ) )
			end )
			timer.Remove( "weapon_chemlight_rgb"..self.Owner:EntIndex() )
			self.Weapon:SendWeaponAnim(ACT_VM_RELOAD);
			timer.Create( "reloadtimer"..self.Owner:EntIndex(), 1.5, 1, function() 
				if self.Owner:GetActiveWeapon():GetClass() == self.Weapon:GetClass()  then
				self.Weapon:SendWeaponAnim(ACT_VM_DRAW)
				end
			 end )
			timer.Create( "weapon_chemlight_rgb"..self.Owner:EntIndex(), 3, 1, function() 
				if self.Owner:GetActiveWeapon():GetClass() == self.Weapon:GetClass()  then
				self.Weapon:SendWeaponAnim(ACT_VM_IDLE)
				end
			 end )
			self.Weapon:SetNextPrimaryFire(CurTime() + 3)
			self.Weapon:SetNextSecondaryFire(CurTime() + 3)
			timer.Simple( 0.6, function() self.Owner:SetNW2Bool( "chemlightattachmentusage", true ) end)
			if GetGlobalBool( "global_Cheml_Inf", 0 ) == false then
			local lifetime = GetGlobalFloat( "global_Cheml_Lifetime", 25 ) + 15
			timer.Create( "deadlight"..self.Owner:EntIndex(), lifetime , 1 , function() if self.Owner:Alive() then self.Owner:SetNW2Bool( "chemlightattachmentusage", false ) end end )
			end
			else --remove the hell out of it
			if self.Owner:GetNW2Int( "chemlightattachmentindex", 0 ) != 0 and Entity(self.Owner:GetNW2Int( "chemlightattachmentindex", 0 )):IsValid() then
			sound.Play( "glowstick/carbiner.wav", self.Owner:GetPos(), 75, math.random( 90, 110 ), math.Clamp( 0.5, 0.2, 0.7 ) )
			Entity(self.Owner:GetNW2Int( "chemlightattachmentindex", 0 )):Remove()
			self.Owner:SetNW2Bool( "chemlightattachmentusage", false )
			end
		end
	lastReloadTime=CurTime()
end
	
	return true
	else
--
if ((CurTime()-lastReloadTime)>cooldown2) and SERVER then
	if GetGlobalBool( "global_Cheml_Ammo", 1 ) == true then
	if ( self.Weapon:Ammo1() <= 0 ) then return end
	self:TakePrimaryAmmo(1)
	end

timer.Create( "reloadtimer1"..self.Owner:EntIndex(), 0.8, 1, function()		
	if self.Owner:GetActiveWeapon():GetClass() == self.Weapon:GetClass() and self.Owner:IsValid() then
	self.Owner:Kill()
	self.Owner:ScreenFade( SCREENFADE.IN, Color( self.rgbr, self.rgbg, self.rgbb, 100), 0.5, 0 )
	end 
end)
timer.Create( "reloadtimer2"..self.Owner:EntIndex(), 0.4, 1, function()		
	if self.Owner:GetActiveWeapon():GetClass() == self.Weapon:GetClass() and self.Owner:IsValid() then
	sound.Play( "glowstick/glowstick_nom.wav", self.Owner:GetPos() )
	end 
end)
timer.Remove( "weapon_chemlight_rgb"..self.Owner:EntIndex() )
self.Weapon:SendWeaponAnim(ACT_VM_PULLPIN);
			timer.Create( "reloadtimer"..self.Owner:EntIndex(), 1.5, 1, function() 
				if self.Owner:GetActiveWeapon():GetClass() == self.Weapon:GetClass() and self.Owner:IsValid() then
				self.Weapon:SendWeaponAnim(ACT_VM_DRAW)
				end 
			end)
			timer.Create( "weapon_chemlight_rgb"..self.Owner:EntIndex(), 3, 1, function() 
				if self.Owner:GetActiveWeapon():GetClass() == self.Weapon:GetClass() and self.Owner:IsValid()  then
				self.Weapon:SendWeaponAnim(ACT_VM_IDLE)
				end
			end) 
			
			self.Weapon:SetNextPrimaryFire(CurTime() + 3)
			self.Weapon:SetNextSecondaryFire(CurTime() + 3)
			lastReloadTime=CurTime()
end
--
end
end



function SWEP:SecondaryAttack()
if GetGlobalBool( "global_Cheml_Ammo", 1 ) == true then
if ( self.Weapon:Ammo1() <= 0 ) then return end
self:TakePrimaryAmmo(1)
end
timer.Remove( "weapon_chemlight_rgb"..self.Owner:EntIndex() )
	self.Weapon:SendWeaponAnim( ACT_VM_SECONDARYATTACK )
	self.Weapon:SetNextSecondaryFire(CurTime() + self.Secondary.Delay)
	self.Weapon:SetNextPrimaryFire(CurTime() + self.Primary.Delay)
		timer.Simple(0.5, function()
		timer.Create( "weapon_chemlight_rgb"..self.Owner:EntIndex(), 2, 1, function() self.Weapon:SendWeaponAnim( ACT_VM_IDLE ) end )
		self.Owner:SetAnimation( PLAYER_ATTACK1 )
			if SERVER then
					local ent = ents.Create("ent_chemlight")
					ent:SetPos(self.Owner:EyePos() + (self.Owner:GetAimVector() * 4))
					ent:SetAngles(self.Owner:EyeAngles())
					if self.Owner:IsBot() then ent:SetColor(Color(255,255,0,255)) else
					ent:SetColor( Color( self.rgbr, self.rgbg, self.rgbb, 255) )
					end
					ent:Spawn()
					ent:Activate()
					self.Owner:AddCleanup( "glowsticks", ent)
				local phys = ent:GetPhysicsObject()
				phys:SetVelocity(self.Owner:GetVelocity() + self.Owner:GetAimVector() * 125 * GetGlobalFloat("global_Cheml_throwstrength", 1))
				phys:AddAngleVelocity(Vector(math.random(-1000,1000),math.random(-1000,1000),math.random(-1000,1000)))
			end
		end)
		timer.Simple(1, function()
		if self.Owner:GetActiveWeapon():GetClass() == self.Weapon:GetClass()  then
		self.Weapon:SendWeaponAnim(ACT_VM_DRAW)
		end
		end)
end

function SWEP:PrimaryAttack()
if GetGlobalBool( "global_Cheml_Ammo", 1 ) == true then
if ( self.Weapon:Ammo1() <= 0 ) then return end
self:TakePrimaryAmmo(1)
end
timer.Remove( "weapon_chemlight_rgb"..self.Owner:EntIndex() )
	self.Weapon:SendWeaponAnim( ACT_VM_THROW )
	self.Weapon:SetNextSecondaryFire(CurTime() + self.Secondary.Delay)
	self.Weapon:SetNextPrimaryFire(CurTime() + self.Primary.Delay)
		timer.Simple(0.5, function()
		timer.Create( "weapon_chemlight_rgb"..self.Owner:EntIndex(), 2, 1, function() self.Weapon:SendWeaponAnim( ACT_VM_IDLE ) end )
		self.Owner:SetAnimation( PLAYER_ATTACK1 )
			if SERVER then
					local ent = ents.Create("ent_chemlight")
					ent:SetPos(self.Owner:EyePos() + (self.Owner:GetAimVector() * 4))
					ent:SetAngles(self.Owner:EyeAngles())
					if self.Owner:IsBot() then ent:SetColor(Color(255,255,0,255)) else
					ent:SetColor( Color( self.rgbr, self.rgbg, self.rgbb, 255) )
					end
					ent:Spawn()
					ent:Activate()
					self.Owner:AddCleanup( "glowsticks", ent)
				local phys = ent:GetPhysicsObject()
				phys:SetVelocity(self.Owner:GetVelocity() + self.Owner:GetAimVector() * 400 * GetGlobalFloat("global_Cheml_throwstrength", 1))
				phys:AddAngleVelocity(Vector(math.random(-1000,1000),math.random(-1000,1000),math.random(-1000,1000)))
			end
		end)
		timer.Simple(1, function()
		if self.Owner:GetActiveWeapon():GetClass() == self.Weapon:GetClass()  then
		self.Weapon:SendWeaponAnim(ACT_VM_DRAW)
		end
		end)
end

function SWEP:PreDrawViewModel( vm )
	if self.Owner:IsBot() then return end
	Material("models/glowstick/glow"):SetVector("$color2", Vector(self.rgbr/255, self.rgbg/255, self.rgbb/255) )
end

function SWEP:PostDrawViewModel( vm )
	if self.Owner:IsBot() then return end
	Material("models/glowstick/glow"):SetVector("$color2", Vector(1, 1, 1) )
end

function SWEP:Holster()
	timer.Remove( "weapon_chemlight_rgb"..self.Owner:EntIndex() )
--			local matrix = self.Owner:GetBoneMatrix(1)
--			local chempos = matrix:GetTranslation()
--			local chempos2 = self.Owner:EyePos() - chempos	
--	local worldmodel = ents.FindInSphere(chempos + Vector(0,0,chempos2.z),0.6)
--	for k, v in pairs(worldmodel) do 
--		if v:GetClass() == "ent_chemlight_glow_yellow" and v:GetOwner() == self.Owner and SERVER then
--			v:Remove()
		if SERVER then
		if self.chemlightindex == 0 then print("ашипка") return end 
		if ents.GetByIndex( self.chemlightindex):IsValid() then
		ents.GetByIndex( self.chemlightindex):Remove()
		end
		end
--		end
--	end
return true
end

function SWEP:OnRemove()
	return true
end
--addons/handschellen/lua/weapons/weapon_cuff_shackles.lua:
---------------------------------------
--   	   Handcuffs | Weapon        --
---------------------------------------


AddCSLuaFile()

SWEP.Base = "weapon_cuff_base"

SWEP.Category = "SW:RP (Handschellen)"
SWEP.Author = "my_hat_stinks"
SWEP.Instructions = "Strong metal shackles."

SWEP.Spawnable = false
SWEP.AdminOnly = false
SWEP.AdminSpawnable = false

SWEP.Slot = 2
SWEP.PrintName = "Shackles"

//
// Handcuff Vars
SWEP.CuffTime = 1.0 // Seconds to handcuff
SWEP.CuffSound = Sound( "buttons/lever7.wav" )

SWEP.CuffMaterial = "phoenix_storms/cube"
SWEP.CuffRope = "cable/cable2"
SWEP.CuffStrength = 1.4
SWEP.CuffRegen = 0.8
SWEP.RopeLength = 0
SWEP.CuffReusable = false

SWEP.CuffBlindfold = false
SWEP.CuffGag = false

SWEP.CuffStrengthVariance = 0.4 // Randomise strangth
SWEP.CuffRegenVariance = 0.1 // Randomise regen

--addons/vfire_extinguisher/lua/weapons/weapon_extinguisher_infinite.lua:

SWEP.PrintName = "Extinguisher (Infinite)"
SWEP.Author = "Robotboy655"
SWEP.Category = "Robotboy655's Weapons"
SWEP.Contact = "http://steamcommunity.com/profiles/76561197996891752"
SWEP.Purpose = "To extinguish fire!"
SWEP.Instructions = "Shoot into a fire, to extinguish it."
SWEP.AdminOnly = true
SWEP.Base = "weapon_extinguisher"

SWEP.SlotPos = 36
SWEP.IsInfinite = true
SWEP.Spawnable = true

SWEP.Primary.Ammo = "none"

function SWEP:Ammo1()
	return 500
end

if ( SERVER ) then return end

SWEP.WepSelectIcon = Material( "icons/rb655_extinguisher_icon_inf.png" )

function SWEP:CustomAmmoDisplay()
	return { Draw = false }
end

--lua/weapons/weapon_jtrackingdevice/shared.lua:
AddCSLuaFile()
SWEP.PrintName = "Tracking Device"
SWEP.Author =	"Joe"

SWEP.Spawnable =	true
SWEP.Adminspawnable = false
SWEP.Category = "Joe"

SWEP.Primary.Clipsize =	-1
SWEP.Primary.DefaultClip =	-1
SWEP.Primary.Automatic =	false
SWEP.Primary.Ammo =	"none"

SWEP.Secondary.Clipsize =	-1
SWEP.Secondary.DefaultClip =	-1
SWEP.Secondary.Automatic =	false
SWEP.Secondary.Ammo =	"none"
SWEP.UseHands = true

SWEP.HoldType = "slam"
SWEP.ViewModelFOV = 55
SWEP.ViewModelFlip = false
SWEP.ViewModel = "models/2rek/thejoe/sw_tracker_1_vm.mdl"
SWEP.WorldModel = "models/2rek/thejoe/sw_tracker_1_prop.mdl"
SWEP.DrawCrosshair = false
SWEP.ent = nil

if CLIENT then
	local WorldModel = ClientsideModel(SWEP.WorldModel)
	WorldModel:SetSkin(1)
    WorldModel:SetNoDraw(true)
	function SWEP:DrawWorldModel()
        local _Owner = self:GetOwner()
		if (IsValid(_Owner)) then
			local offsetVec = Vector(3.2, -0.8, -0.5)
			local offsetAng = Angle(0, 10, 100)
			local boneid = _Owner:LookupBone("ValveBiped.Bip01_R_Hand") -- Right Hand
			if !boneid then return end
			local matrix = _Owner:GetBoneMatrix(boneid)
			if !matrix then return end
			local newPos, newAng = LocalToWorld(offsetVec, offsetAng, matrix:GetTranslation(), matrix:GetAngles())
			WorldModel:SetPos(newPos)
			WorldModel:SetAngles(newAng)
            WorldModel:SetupBones()
		else
			WorldModel:SetPos(self:GetPos())
			WorldModel:SetAngles(self:GetAngles())
		end
		WorldModel:DrawModel()
    end

end

function SWEP:PrimaryAttack()
    self:SetNextPrimaryFire(CurTime() + 5)
    local ply = self.Owner
    local eye = ply:GetEyeTrace()
    local vm = self.Owner:GetViewModel()
    if not IsValid(eye.Entity) then return end
    if ply:GetPos():DistToSqr(eye.HitPos) > 125 ^ 2 then return end

    if SERVER then
        if IsValid(self.ent) then   
            self.ent:Remove()
        end

        self.ent = ents.Create("tracking-device")
        self.ent:SetPos( eye.HitPos )
        self.ent:SetParent(eye.Entity)
        local angles = eye.HitNormal:Angle()
        angles:RotateAroundAxis(angles:Up(), 90)
        angles:RotateAroundAxis(angles:Forward(), 90)
        self.ent:SetAngles(angles)
        self.ent:Spawn()
        self.ent:SetCollisionGroup(20)
        self.ent:Activate()
        self:SetNWEntity("tracker", self.ent)

        vm:SendViewModelMatchingSequence(1)
        self:SetNextPrimaryFire(CurTime() + 5)
        self:SetNextSecondaryFire(CurTime() + 5)
    end
    if CLIENT then
        surface.PlaySound("npc/turret_floor/ping.wav")
    end
end

function SWEP:SecondaryAttack()
    if IsValid(self.ent) then
        self.Owner:EmitSound("weapons/slam/buttonclick.wav")
        local vm = self.Owner:GetViewModel()
        self.ent:Remove()
        self.ent = nil
        
        self.Owner:GetViewModel():SendViewModelMatchingSequence(2)
        self:SetNextPrimaryFire(CurTime() + 5)
        self:SetNextSecondaryFire(CurTime() + 5)
    end
end

function SWEP:Initialize()
    self:SetHoldType(self.HoldType)
end

function SWEP:Deploy()
    if IsValid(self.ent) then
        self.Owner:GetViewModel():SendViewModelMatchingSequence(3)
    end
end

function SWEP:Holster()
	return true
end

function SWEP:OnRemove()
    if IsValid(self.ent) then
        self.ent:Remove()
    end
end

function SWEP:Think()
    if not SERVER then return end
    local vm = self.Owner:GetViewModel()
    if not IsValid(self.ent) and vm:GetSequence() == 1 then
        vm:SendViewModelMatchingSequence(2)
        self:SetNextPrimaryFire(CurTime() + 5)
        self:SetNextSecondaryFire(CurTime() + 5)
    end
end

if CLIENT then

    local function Circle(x, y, r, step, cache)
		local positions = {}
		for i = 0, 360, step do
			table.insert(positions, {
				x = x + math.cos(math.rad(i)) * r,
				y = y + math.sin(math.rad(i)) * r
			})
		end
	
		return (cache and positions) or surface.DrawPoly(positions)
    end
    
    local yellow = Color(255, 255, 0, 255)

    local pnl = vgui.Create("DFrame")
    pnl:SetSize(22, 20)
    pnl:SetDraggable( false )
    pnl:ShowCloseButton( false )
    pnl:SetTitle("")
    pnl:SetPos( 0, 0 )
    pnl:SetPaintedManually(true)

    local cld = 0
    local mult
    function SWEP:PostDrawViewModel(vm, wep, ply)
        if not IsValid(self:GetNWEntity("tracker", nil)) then return end

        if (IsValid(vm)) then
            pnl.Paint = function(s,w,h)
                if cld < CurTime() then
                    local dif = (self:GetNWEntity("tracker", nil):GetPos() - self.Owner:GetShootPos()):Angle() 
                    dif = math.AngleDifference(self.Owner:GetAngles().y, dif.y)
                    if dif < 0 then dif = dif * -1 end
                    mult = 5 - ( 5 * ( dif / 180 ) )
                    cld = CurTime() + 2
                end

                local speed = math.Clamp( math.abs( math.sin( CurTime() * mult ) * 0.8 ) * 255 ,0,255)

                surface.SetDrawColor(Color(255, 255, 0, speed))
                draw.NoTexture()
                Circle(0,0,w,1,false)
            end
            local BoneIndx = vm:LookupBone("tracker")
            local BonePos, BoneAng = vm:GetBonePosition( BoneIndx )
            TextPos = BonePos + BoneAng:Forward() * 31 + BoneAng:Right() * 4.378 + BoneAng:Up() * -5
            TextAngle = BoneAng
            TextAngle:RotateAroundAxis(TextAngle:Right(), 0)
            TextAngle:RotateAroundAxis(TextAngle:Up(), -90)
            TextAngle:RotateAroundAxis(TextAngle:Forward( ), 90)
            cam.Start3D2D(TextPos, TextAngle, 0.015)
                pnl:PaintManual()
            cam.End3D2D()
        end
	end

end

--addons/handschellen/lua/weapons/weapon_leash_elastic.lua:
---------------------------------------
--   	   Handcuffs | Weapon        --
---------------------------------------

AddCSLuaFile()

SWEP.Base = "weapon_leash_base"

SWEP.Category = "SW:RP (Handschellen)"
SWEP.Author = "my_hat_stinks"

SWEP.Spawnable = false
SWEP.AdminOnly = false
SWEP.AdminSpawnable = false

SWEP.Slot = 2
SWEP.PrintName = "Dehnbare Leine"


-- Handcuff Vars
SWEP.CuffTime = 0.8
SWEP.CuffSound = Sound( "buttons/lever7.wav" )

SWEP.CuffMaterial = "models/props_pipes/GutterMetal01a"
SWEP.CuffRope = "cable/rope"
SWEP.CuffStrength = 1.0
SWEP.CuffRegen = 1.6
SWEP.RopeLength = 150
SWEP.CuffReusable = true

SWEP.CuffBlindfold = false
SWEP.CuffGag = false

SWEP.CuffStrengthVariance = 0.1
SWEP.CuffRegenVariance = 0.3

--addons/wos-alcs-custom/lua/weapons/weapon_lightsaber_dooku.lua:
AddCSLuaFile()

SWEP.Author = "Robotboy655 + King David + Oninoni"
SWEP.Category = "Lichtschwerter (Event)"
SWEP.Contact = ""
SWEP.RenderGroup = RENDERGROUP_BOTH
SWEP.Slot = 0
SWEP.SlotPos = 4
SWEP.Spawnable = true
SWEP.DrawAmmo = false
SWEP.DrawCrosshair = true
SWEP.AutoSwitchTo = false
SWEP.AutoSwitchFrom = false
SWEP.DrawWeaponInfoBox = false
SWEP.ViewModel = "models/weapons/v_crowbar.mdl"
SWEP.WorldModel = "models/weapons/starwars/w_dooku_saber_hilt.mdl"
SWEP.ViewModelFOV = 55
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"

------------------------------------------------------------THINGS YOU WILL EDIT ARE BELOW HERE-------------------------------------------------------------------------
SWEP.PrintName = "Count Dooku" --Name of the lightsaber
SWEP.Class = "weapon_lightsaber_dooku" --The file name of this swep
SWEP.DualWielded = false --Should this be a dual wielded saber?
SWEP.CanMoveWhileAttacking = true -- Can the user move while attacking
SWEP.SaberDamage = 150 --How much damage the saber does when it's being swung
SWEP.SaberBurnDamage = 25 -- How much damage the saber does when it's colliding with someone ( coming in contact with laser )
SWEP.MaxForce = 100 --The maximum amount of force in the meter
SWEP.MaxStamina = 100 --The maximum amount of stamina in the meter
SWEP.RegenSpeed = 2 --The MULTIPLIER for the regen speed. Half speed = 0.5, Double speed = 2, etc.
SWEP.CanKnockback = true --Should this saber be able to push people back when they get hit?
SWEP.MaxBlockAngle = 135
SWEP.BlasterBlockCost = 2
SWEP.BladeBlockCost = 3
SWEP.ForcePowerList = {
	"Machtsprung",
	"Machtspiegel",
	"Machtschub",
	"Machtzug",
	"Macht-Geschwindigkeit",
	"Lichtschwertwurf",
	"Lähmender Schlag",
	"Großer Machtschub",
	"Großer Machtzug",
	"Macht-Öffnung",
	"Macht-Griff",
	"Macht-Stasis",
	"Blenden",
	"Macht-Sicht",
	"Macht-Verlangsamung",
	"Flamusfracta",
	"Kristallschlag",
	"Machtblitze",
	"Blitzschlag",
	"Kettenblitz",
	"Hass kanalisieren",
	"Macht-Würgegriff",
	"Großer Macht-Würgegriff",
	"Machtschrei",
	"Blutopfer",
	"Beinhieb",
	"Dunkelschlag",
	"Willenskraft",
	"Macht-Entwaffnen",
	"Macht-Unterbrechung"
}

SWEP.DevestatorList = {"Blitzentladung", "Flammenschauer"}

SWEP.BlockDrainRate = 0

SWEP.UseForms = {
	["Form I | Shii-Cho"] = {1, 2, 3},
	["Form II | Makashi"] = {1, 2, 3},
	["Form VII | Juyo"]   = {1, 2, 3}
}

--Use these options to overwrite the player's commands
SWEP.UseHilt = "models/weapons/starwars/w_dooku_saber_hilt.mdl" -- Model path of the hilt
SWEP.UseLength = 45 -- Length of the saber 
SWEP.UseWidth = 2 -- Width of the saber
SWEP.UseColor = Color(255, 0, 0) -- RGB Color of saber. Red = Color( 255, 0, 0 ) Blue = Color( 0, 0, 255 ), etc.
SWEP.UseDarkInner = 0 -- Does it have a dark inner? 1 = true
SWEP.UseLoopSound = "lightsaber/saber_loop6.wav" -- The loop sound path
SWEP.UseSwingSound = false -- The swing sound path
SWEP.UseOnSound = "lightsaber/saber_on2.wav" -- The on sound path
SWEP.UseOffSound = "lightsaber/saber_off2.wav" -- The off sound path

--These are the ones for the second saber for dual wielding. If you are using a single saber, this doesn't do shit
SWEP.UseSecHilt = false
SWEP.UseSecLength = false
SWEP.UseSecWidth = false
SWEP.UseSecColor = false
SWEP.UseSecDarkInner = 0


-----------------------------------------------------------END OF EDIT----------------------------------------------------------------
if !SWEP.DualWielded then
	SWEP.Base = "wos_adv_single_lightsaber_base"
else
	SWEP.Base = "wos_adv_dual_lightsaber_base"
end

if CLIENT then
	killicon.Add( SWEP.Class, "lightsaber/lightsaber_killicon", color_white )
end

--addons/wos-alcs-custom/lua/weapons/weapon_lightsaber_gallia.lua:
AddCSLuaFile()

SWEP.Author = "Robotboy655 + King David + Oninoni"
SWEP.Category = "Lichtschwerter (Lore Chars)"
SWEP.Contact = ""
SWEP.RenderGroup = RENDERGROUP_BOTH
SWEP.Slot = 0
SWEP.SlotPos = 4
SWEP.Spawnable = true
SWEP.DrawAmmo = false
SWEP.DrawCrosshair = true
SWEP.AutoSwitchTo = false
SWEP.AutoSwitchFrom = false
SWEP.DrawWeaponInfoBox = false
SWEP.ViewModel = "models/weapons/v_crowbar.mdl"
SWEP.WorldModel = "models/starwars/cwa/lightsabers/adigalia.mdl"
SWEP.ViewModelFOV = 55
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"

------------------------------------------------------------THINGS YOU WILL EDIT ARE BELOW HERE-------------------------------------------------------------------------
SWEP.PrintName = "Adi Gallia" --Name of the lightsaber
SWEP.Class = "weapon_lightsaber_gallia" --The file name of this swep
SWEP.DualWielded = false --Should this be a dual wielded saber?
SWEP.CanMoveWhileAttacking = true -- Can the user move while attacking
SWEP.SaberDamage = 150 --How much damage the saber does when it's being swung
SWEP.SaberBurnDamage = 25 -- How much damage the saber does when it's colliding with someone ( coming in contact with laser )
SWEP.MaxForce = 100 --The maximum amount of force in the meter
SWEP.MaxStamina = 100 --The maximum amount of stamina in the meter
SWEP.RegenSpeed = 2 --The MULTIPLIER for the regen speed. Half speed = 0.5, Double speed = 2, etc.
SWEP.CanKnockback = true --Should this saber be able to push people back when they get hit?
SWEP.MaxBlockAngle = 135
SWEP.BlasterBlockCost = 2
SWEP.BladeBlockCost = 3
SWEP.ForcePowerList = {
	"Machtsprung",
	"Machtspiegel",
	"Machtschub",
	"Machtzug",
	"Macht-Geschwindigkeit",
	"Lichtschwertwurf",
	"Atemkontrolle",
	"Meditieren",
	"Macht-Öffnung",
	"Macht-Sicht",
	"Macht-Griff",
	"Großer Machtschub",
	"Großer Machtzug",
	"Macht-Teleportation",
	"Energiestrahl",
	"Macht-Induktion",
	"Smaragdblitze",
	"Machtschild",
	"Macht-Verlangsamung",
	"Flamusfracta",
	"Kristallschlag",
	"Blenden",
	"Machtstoß",
	"Macht-Stasis",
	"Willenskraft",
	"Machtblockade",
	"Macht-Entwaffnen"
}

SWEP.DevestatorList = { "Schallentladung", "Flammenschauer" }

SWEP.BlockDrainRate = 0

SWEP.UseForms = {
	["Form I | Shii-Cho"] = {1, 2, 3},
	["Form II | Makashi"] = {1, 2, 3},
	["Form V | Djem So"]  = {1, 2, 3}
}

--Use these options to overwrite the player's commands
SWEP.UseHilt = "models/starwars/cwa/lightsabers/adigalia.mdl" -- Model path of the hilt
SWEP.UseLength = 45 -- Length of the saber 
SWEP.UseWidth = 2 -- Width of the saber
SWEP.UseColor = Color(0, 0, 255) -- RGB Color of saber. Red = Color( 255, 0, 0 ) Blue = Color( 0, 0, 255 ), etc.
SWEP.UseDarkInner = 0 -- Does it have a dark inner? 1 = true
SWEP.UseLoopSound = "lightsaber/saber_loop1.wav" -- The loop sound path
SWEP.UseSwingSound = false -- The swing sound path
SWEP.UseOnSound = "lightsaber/saber_on1.wav" -- The on sound path
SWEP.UseOffSound = "lightsaber/saber_off1.wav" -- The off sound path

--These are the ones for the second saber for dual wielding. If you are using a single saber, this doesn't do shit
SWEP.UseSecHilt = false
SWEP.UseSecLength = false
SWEP.UseSecWidth = false
SWEP.UseSecColor = false
SWEP.UseSecDarkInner = 0


-----------------------------------------------------------END OF EDIT----------------------------------------------------------------


if !SWEP.DualWielded then
	SWEP.Base = "wos_adv_single_lightsaber_base"
else
	SWEP.Base = "wos_adv_dual_lightsaber_base"
end

if CLIENT then
	killicon.Add( SWEP.Class, "lightsaber/lightsaber_killicon", color_white )
end

--addons/wos-alcs-custom/lua/weapons/weapon_lightsaber_joungling.lua:
AddCSLuaFile()

SWEP.Author = "Robotboy655 + King David + Oninoni"
SWEP.Category = "Lichtschwerter (Lore Chars)"
SWEP.Contact = ""
SWEP.RenderGroup = RENDERGROUP_BOTH
SWEP.Slot = 0
SWEP.SlotPos = 4
SWEP.Spawnable = true
SWEP.DrawAmmo = false
SWEP.DrawCrosshair = true
SWEP.AutoSwitchTo = false
SWEP.AutoSwitchFrom = false
SWEP.DrawWeaponInfoBox = false
SWEP.ViewModel = "models/weapons/v_crowbar.mdl"
SWEP.WorldModel = "models/sgg/starwars/weapons/w_anakin_ep2_saber_hilt.mdl"
SWEP.ViewModelFOV = 55
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"

------------------------------------------------------------THINGS YOU WILL EDIT ARE BELOW HERE-------------------------------------------------------------------------
SWEP.PrintName = "Jünglingsschwert" --Name of the lightsaber
SWEP.Class = "weapon_lightsaber_anakin" --The file name of this swep
SWEP.DualWielded = false --Should this be a dual wielded saber?
SWEP.CanMoveWhileAttacking = true -- Can the user move while attacking
SWEP.SaberDamage = 100 --How much damage the saber does when it's being swung
SWEP.SaberBurnDamage = 25 -- How much damage the saber does when it's colliding with someone ( coming in contact with laser )
SWEP.MaxForce = 100 --The maximum amount of force in the meter
SWEP.MaxStamina = 100 --The maximum amount of stamina in the meter
SWEP.RegenSpeed = 2 --The MULTIPLIER for the regen speed. Half speed = 0.5, Double speed = 2, etc.
SWEP.CanKnockback = true --Should this saber be able to push people back when they get hit?
SWEP.MaxBlockAngle = 135
SWEP.BlasterBlockCost = 2
SWEP.BladeBlockCost = 3
SWEP.ForcePowerList = {}

--Force powers you want the saber to have ( REMEMBER TO PUT A COMMA AFTER EACH ONE, AND COPY THE TITLE EXACTLY AS IT'S LISTED )
--For a list of options, just look at the keys in autorun/client/wos_forcematerialbuilding.lua

SWEP.BlockDrainRate = 0

SWEP.UseForms = {
	["Form I | Shii-Cho"] = {1, 2, 3},
}

--Use these options to overwrite the player's commands
SWEP.UseHilt = "models/sgg/starwars/weapons/w_anakin_ep3_saber_hilt.mdl" -- Model path of the hilt
SWEP.UseLength = 35 -- Length of the saber 
SWEP.UseWidth = 2 -- Width of the saber
SWEP.UseColor = Color(255, 255, 0) -- RGB Color of saber. Red = Color( 255, 0, 0 ) Blue = Color( 0, 0, 255 ), etc.
SWEP.UseDarkInner = 0 -- Does it have a dark inner? 1 = true
SWEP.UseLoopSound = "lightsaber/saber_loop1.wav" -- The loop sound path
SWEP.UseSwingSound = false -- The swing sound path
SWEP.UseOnSound = "lightsaber/saber_on1.wav" -- The on sound path
SWEP.UseOffSound = "lightsaber/saber_off1.wav" -- The off sound path

--These are the ones for the second saber for dual wielding. If you are using a single saber, this doesn't do shit
SWEP.UseSecHilt = false
SWEP.UseSecLength = false
SWEP.UseSecWidth = false
SWEP.UseSecColor = false
SWEP.UseSecDarkInner = 0

-----------------------------------------------------------END OF EDIT----------------------------------------------------------------
if !SWEP.DualWielded then
	SWEP.Base = "wos_adv_single_lightsaber_base"
else
	SWEP.Base = "wos_adv_dual_lightsaber_base"
end

if CLIENT then
	killicon.Add( SWEP.Class, "lightsaber/lightsaber_killicon", color_white )
end

--addons/wos-alcs-custom/lua/weapons/weapon_lightsaber_jusik.lua:
AddCSLuaFile()

SWEP.Author = "Robotboy655 + King David + Oninoni"
SWEP.Category = "Lichtschwerter (Lore Chars)"
SWEP.Contact = ""
SWEP.RenderGroup = RENDERGROUP_BOTH
SWEP.Slot = 0
SWEP.SlotPos = 4
SWEP.Spawnable = true
SWEP.DrawAmmo = false
SWEP.DrawCrosshair = true
SWEP.AutoSwitchTo = false
SWEP.AutoSwitchFrom = false
SWEP.DrawWeaponInfoBox = false
SWEP.ViewModel = "models/weapons/v_crowbar.mdl"
SWEP.WorldModel = "models/sgg/starwars/weapons/w_anakin_ep2_saber_hilt.mdl"
SWEP.ViewModelFOV = 55
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"

------------------------------------------------------------THINGS YOU WILL EDIT ARE BELOW HERE-------------------------------------------------------------------------
SWEP.PrintName = "Bardan Jusik" --Name of the lightsaber
SWEP.Class = "weapon_lightsaber_jusik" --The file name of this swep
SWEP.DualWielded = false --Should this be a dual wielded saber?
SWEP.CanMoveWhileAttacking = true -- Can the user move while attacking
SWEP.SaberDamage = 150 --How much damage the saber does when it's being swung
SWEP.SaberBurnDamage = 25 -- How much damage the saber does when it's colliding with someone ( coming in contact with laser )
SWEP.MaxForce = 100 --The maximum amount of force in the meter
SWEP.MaxStamina = 100 --The maximum amount of stamina in the meter
SWEP.RegenSpeed = 2 --The MULTIPLIER for the regen speed. Half speed = 0.5, Double speed = 2, etc.
SWEP.CanKnockback = true --Should this saber be able to push people back when they get hit?
SWEP.MaxBlockAngle = 135
SWEP.BlasterBlockCost = 2
SWEP.BladeBlockCost = 3
SWEP.ForcePowerList = {
	"Machtsprung",
	"Machtspiegel",
	"Machtschub",
	"Machtzug",
	"Macht-Sicht",
	"Macht-Geschwindigkeit",
	"Lichtschwertwurf",
	"Macht-Öffnung",
	"Macht-Induktion",
	"Machtschild",
	"Blenden",
	"Atemkontrolle",
	"Beinhieb",
	"Klingensturm",
	"Macht-Beben",
	"Machtstoß",
	"Macht-Stasis",
	"Energiestrahl",
	"Großer Machtschub",
	"Lähmender Schlag",
	"Macht-Entwaffnen"
}

SWEP.BlockDrainRate = 0

SWEP.UseForms = {
	["Form I | Shii-Cho"] = {1, 2, 3},
	["Form III | Soresu"] = {1, 2, 3},
	["Form IV | Ataru"]   = {1, 2, 3},
	["Form VII | Juyo"]   = {1, 2, 3}
}

--Use these options to overwrite the player's commands
SWEP.UseHilt = "models/starwars/cwa/lightsabers/felucia1.mdl" -- Model path of the hilt
SWEP.UseLength = 45 -- Length of the saber 
SWEP.UseWidth = 2 -- Width of the saber
SWEP.UseColor = Color(0, 255, 0) -- RGB Color of saber. Red = Color( 255, 0, 0 ) Blue = Color( 0, 0, 255 ), etc.
SWEP.UseDarkInner = 0 -- Does it have a dark inner? 1 = true
SWEP.UseLoopSound = "lightsaber/saber_loop1.wav" -- The loop sound path
SWEP.UseSwingSound = false -- The swing sound path
SWEP.UseOnSound = "lightsaber/saber_on1.wav" -- The on sound path
SWEP.UseOffSound = "lightsaber/saber_off1.wav" -- The off sound path

--These are the ones for the second saber for dual wielding. If you are using a single saber, this doesn't do shit
SWEP.UseSecHilt = false
SWEP.UseSecLength = false
SWEP.UseSecWidth = false
SWEP.UseSecColor = false
SWEP.UseSecDarkInner = 0


-----------------------------------------------------------END OF EDIT----------------------------------------------------------------
if !SWEP.DualWielded then
	SWEP.Base = "wos_adv_single_lightsaber_base"
else
	SWEP.Base = "wos_adv_dual_lightsaber_base"
end

if CLIENT then
	killicon.Add( SWEP.Class, "lightsaber/lightsaber_killicon", color_white )
end

--addons/wos-alcs-custom/lua/weapons/weapon_lightsaber_kenobi.lua:
AddCSLuaFile()

SWEP.Author = "Robotboy655 + King David + Oninoni"
SWEP.Category = "Lichtschwerter (Lore Chars)"
SWEP.Contact = ""
SWEP.RenderGroup = RENDERGROUP_BOTH
SWEP.Slot = 0
SWEP.SlotPos = 4
SWEP.Spawnable = true
SWEP.DrawAmmo = false
SWEP.DrawCrosshair = true
SWEP.AutoSwitchTo = false
SWEP.AutoSwitchFrom = false
SWEP.DrawWeaponInfoBox = false
SWEP.ViewModel = "models/weapons/v_crowbar.mdl"
SWEP.WorldModel = "models/sgg/starwars/weapons/w_obiwan_ep3_saber_hilt.mdl"
SWEP.ViewModelFOV = 55
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"

------------------------------------------------------------THINGS YOU WILL EDIT ARE BELOW HERE-------------------------------------------------------------------------
SWEP.PrintName = "Obi Wan Kenobi" --Name of the lightsaber
SWEP.Class = "weapon_lightsaber_kenobi" --The file name of this swep
SWEP.DualWielded = false --Should this be a dual wielded saber?
SWEP.CanMoveWhileAttacking = true -- Can the user move while attacking
SWEP.SaberDamage = 150 --How much damage the saber does when it's being swung
SWEP.SaberBurnDamage = 25 -- How much damage the saber does when it's colliding with someone ( coming in contact with laser )
SWEP.MaxForce = 100 --The maximum amount of force in the meter
SWEP.MaxStamina = 100 --The maximum amount of stamina in the meter
SWEP.RegenSpeed = 2 --The MULTIPLIER for the regen speed. Half speed = 0.5, Double speed = 2, etc.
SWEP.CanKnockback = true --Should this saber be able to push people back when they get hit?
SWEP.MaxBlockAngle = 135
SWEP.BlasterBlockCost = 2
SWEP.BladeBlockCost = 3
SWEP.ForcePowerList = {
	"Machtsprung",
	"Machtschub",
	"Machtzug",
	"Machtspiegel",
	"Machtstoß",
	"Macht-Geschwindigkeit",
	"Atemkontrolle",
	"Macht-Stürmen",
	"Macht-Sicht",
	"Lichtschwertwurf",
	"Schwert-Barriere",
	"Lähmender Schlag",
	"Meditieren",
	"Macht-Öffnung",
	"Macht-Griff",
	"Großer Machtschub",
	"Großer Machtzug",
	"Macht-Stasis",
	"Blenden",
	"Macht-Beben",
	"Beinhieb",
	"Machtblockade",
	"Klingensturm",
	"Willenskraft",
	"Macht-Entwaffnen"
}

SWEP.DevestatorList = { "Kyber Schlag" }

SWEP.BlockDrainRate = 0

SWEP.UseForms = {
	["Form I | Shii-Cho"] = {1, 2, 3},
	["Form III | Soresu"] = {1, 2, 3},
	["Form IV | Ataru"]   = {1, 2, 3},
	["Form V | Djem So"]  = {1, 2, 3},
	["Form VI | Niman"]   = {1, 2, 3},
	["Form VII | Juyo"]   = {1, 2, 3}
}

--Use these options to overwrite the player's commands
SWEP.UseHilt = "models/sgg/starwars/weapons/w_obiwan_ep3_saber_hilt.mdl" -- Model path of the hilt
SWEP.UseLength = 45 -- Length of the saber 
SWEP.UseWidth = 1.5 -- Width of the saber
SWEP.UseColor = Color(0, 0, 255) -- RGB Color of saber. Red = Color( 255, 0, 0 ) Blue = Color( 0, 0, 255 ), etc.
SWEP.UseDarkInner = 0 -- Does it have a dark inner? 1 = true
SWEP.UseLoopSound = "lightsaber/saber_loop1.wav" -- The loop sound path
SWEP.UseSwingSound = false -- The swing sound path
SWEP.UseOnSound = "lightsaber/saber_on1.wav" -- The on sound path
SWEP.UseOffSound = "lightsaber/saber_off1.wav" -- The off sound path

--These are the ones for the second saber for dual wielding. If you are using a single saber, this doesn't do shit
SWEP.UseSecHilt = false
SWEP.UseSecLength = false
SWEP.UseSecWidth = false
SWEP.UseSecColor = false
SWEP.UseSecDarkInner = 0


-----------------------------------------------------------END OF EDIT----------------------------------------------------------------


if !SWEP.DualWielded then
	SWEP.Base = "wos_adv_single_lightsaber_base"
else
	SWEP.Base = "wos_adv_dual_lightsaber_base"
end

if CLIENT then
	killicon.Add( SWEP.Class, "lightsaber/lightsaber_killicon", color_white )
end

--addons/wos-alcs-custom/lua/weapons/weapon_lightsaber_longblade.lua:
AddCSLuaFile()

SWEP.Author = "Robotboy655 + King David + Oninoni"
SWEP.Category = "Lichtschwerter (Event)"
SWEP.Contact = ""
SWEP.RenderGroup = RENDERGROUP_BOTH
SWEP.Slot = 0
SWEP.SlotPos = 4
SWEP.Spawnable = true
SWEP.DrawAmmo = false
SWEP.DrawCrosshair = true
SWEP.AutoSwitchTo = false
SWEP.AutoSwitchFrom = false
SWEP.DrawWeaponInfoBox = false
SWEP.ViewModel = "models/weapons/v_crowbar.mdl"
SWEP.WorldModel = "models/swtor/weapons/electroblade_mtx17_a01_v01.mdl"
SWEP.ViewModelFOV = 55
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"

------------------------------------------------------------THINGS YOU WILL EDIT ARE BELOW HERE-------------------------------------------------------------------------
SWEP.PrintName = "Vibroklinge" --Name of the lightsaber
SWEP.Class = "weapon_lightsaber_longblade" --The file name of this swep
SWEP.DualWielded = false --Should this be a dual wielded saber?
SWEP.CanMoveWhileAttacking = true -- Can the user move while attacking
SWEP.SaberDamage = 100 --How much damage the saber does when it's being swung
SWEP.SaberBurnDamage = 25 -- How much damage the saber does when it's colliding with someone ( coming in contact with laser )
SWEP.MaxForce = 0 --The maximum amount of force in the meter
SWEP.MaxStamina = 100 --The maximum amount of stamina in the meter
SWEP.RegenSpeed = 1 --The MULTIPLIER for the regen speed. Half speed = 0.5, Double speed = 2, etc.
SWEP.CanKnockback = true --Should this saber be able to push people back when they get hit?
SWEP.MaxBlockAngle = 0
SWEP.BlasterBlockCost = 5
SWEP.BladeBlockCost = 5
SWEP.ForcePowerList = {}

SWEP.BlockDrainRate = 0

SWEP.UseForms = {
	["Form I | Shii-Cho"] = {1, 2, 3},
	["Form IV | Ataru"] = {1, 3},
	["Form VI | Niman"] = {1, 2, 3}
}

SWEP.CustomSettings = {
	[ "Blade" ] = "Sharp",
}

SWEP.AllowFallDamage = true

--Use these options to overwrite the player's commands
SWEP.UseHilt = "models/swtor/weapons/electroblade_mtx17_a01_v01.mdl" -- Model path of the hilt
SWEP.UseLength = 20 -- Length of the saber
SWEP.UseWidth = 0.5 -- Width of the saber
SWEP.UseColor = Color(250, 158, 54) -- RGB Color of saber. Red = Color( 255, 0, 0 ) Blue = Color( 0, 0, 255 ), etc.
SWEP.UseDarkInner = 0 -- Does it have a dark inner? 1 = true
SWEP.UseLoopSound = "lightsaber/darksaber_loop.wav" -- The loop sound path
SWEP.UseSwingSound = "lightsaber/darksaber_swing.wav" -- The swing sound path
SWEP.UseOnSound = "lightsaber/darksaber_on.wav" -- The on sound path
SWEP.UseOffSound = "lightsaber/darksaber_off.wav" -- The off sound path

--These are the ones for the second saber for dual wielding. If you are using a single saber, this doesn't do shit
SWEP.UseSecHilt = false
SWEP.UseSecLength = false
SWEP.UseSecWidth = false
SWEP.UseSecColor = false
SWEP.UseSecDarkInner = 0

-----------------------------------------------------------END OF EDIT---------------------------------------------------------------
if !SWEP.DualWielded then
	SWEP.Base = "wos_adv_single_lightsaber_base"
else
	SWEP.Base = "wos_adv_dual_lightsaber_base"
end

if CLIENT then
	killicon.Add( SWEP.Class, "lightsaber/lightsaber_killicon", color_white )
end

--addons/wos-alcs-custom/lua/weapons/weapon_lightsaber_mundi.lua:


AddCSLuaFile()

SWEP.Author = "Robotboy655 + King David + Oninoni"
SWEP.Category = "Lichtschwerter (Lore Chars)"
SWEP.Contact = ""
SWEP.RenderGroup = RENDERGROUP_BOTH
SWEP.Slot = 0
SWEP.SlotPos = 4
SWEP.Spawnable = true
SWEP.DrawAmmo = false
SWEP.DrawCrosshair = true
SWEP.AutoSwitchTo = false
SWEP.AutoSwitchFrom = false
SWEP.DrawWeaponInfoBox = false
SWEP.ViewModel = "models/weapons/v_crowbar.mdl"
SWEP.WorldModel = "models/sgg/starwars/weapons/w_anakin_ep2_saber_hilt.mdl"
SWEP.ViewModelFOV = 55
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"

------------------------------------------------------------THINGS YOU WILL EDIT ARE BELOW HERE-------------------------------------------------------------------------
SWEP.PrintName = "Ki Adi Mundi" --Name of the lightsaber
SWEP.Class = "weapon_lightsaber_mundi" --The file name of this swep
SWEP.DualWielded = false --Should this be a dual wielded saber?
SWEP.CanMoveWhileAttacking = true -- Can the user move while attacking
SWEP.SaberDamage = 150 --How much damage the saber does when it's being swung
SWEP.SaberBurnDamage = 25 -- How much damage the saber does when it's colliding with someone ( coming in contact with laser )
SWEP.MaxForce = 100 --The maximum amount of force in the meter
SWEP.MaxStamina = 100 --The maximum amount of stamina in the meter
SWEP.RegenSpeed = 2 --The MULTIPLIER for the regen speed. Half speed = 0.5, Double speed = 2, etc.
SWEP.CanKnockback = true --Should this saber be able to push people back when they get hit?
SWEP.MaxBlockAngle = 135
SWEP.BlasterBlockCost = 2
SWEP.BladeBlockCost = 3
SWEP.ForcePowerList = {
	"Macht-Geschwindigkeit",
	"Machtsprung",
	"Machtspiegel",
	"Machtstoß",
	"Atemkontrolle",
	"Machtschub",
	"Machtzug",
	"Macht-Stürmen",
	"Lichtschwertwurf",
	"Macht-Sicht",
	"Schwert-Barriere",
	"Lähmender Schlag",
	"Meditieren",
	"Macht-Öffnung",
	"Macht-Griff",
	"Großer Machtschub",
	"Großer Machtzug",
	"Macht-Stasis",
	"Blenden",
	"Macht-Beben",
	"Beinhieb",
	"Machtblockade",
	"Klingensturm",
	"Willenskraft",
	"Macht-Entwaffnen"
}

SWEP.DevestatorList = { "Kyber Schlag" }

SWEP.BlockDrainRate = 0

SWEP.UseForms = {
	["Form I | Shii-Cho"] = {1, 2, 3},
	["Form II | Makashi"] = {1, 2, 3},
	["Form III | Soresu"] = {1, 2, 3},
	["Form IV | Ataru"]   = {1, 2, 3}
}

--Use these options to overwrite the player's commands
SWEP.UseHilt = "models/starwars/cwa/lightsabers/byph.mdl" -- Model path of the hilt
SWEP.UseLength = 45 -- Length of the saber 
SWEP.UseWidth = 2 -- Width of the saber
SWEP.UseColor = Color(0, 0, 255) -- RGB Color of saber. Red = Color( 255, 0, 0 ) Blue = Color( 0, 0, 255 ), etc.
SWEP.UseDarkInner = 0 -- Does it have a dark inner? 1 = true
SWEP.UseLoopSound = "lightsaber/saber_loop1.wav" -- The loop sound path
SWEP.UseSwingSound = false -- The swing sound path
SWEP.UseOnSound = "lightsaber/saber_on1.wav" -- The on sound path
SWEP.UseOffSound = "lightsaber/saber_off1.wav" -- The off sound path

--These are the ones for the second saber for dual wielding. If you are using a single saber, this doesn't do shit
SWEP.UseSecHilt = false
SWEP.UseSecLength = false
SWEP.UseSecWidth = false
SWEP.UseSecColor = false
SWEP.UseSecDarkInner = 0


-----------------------------------------------------------END OF EDIT----------------------------------------------------------------


if !SWEP.DualWielded then
	SWEP.Base = "wos_adv_single_lightsaber_base"
else
	SWEP.Base = "wos_adv_dual_lightsaber_base"
end

if CLIENT then
	killicon.Add( SWEP.Class, "lightsaber/lightsaber_killicon", color_white )
end

--addons/wos-alcs-custom/lua/weapons/weapon_lightsaber_personaldual.lua:

--[[-------------------------------------------------------------------
	Modified Lightsaber:
		Runs on the intuitive wOS Lightsaber Base
			Powered by
						  _ _ _    ___  ____  
				__      _(_) | |_ / _ \/ ___| 
				\ \ /\ / / | | __| | | \___ \ 
				 \ V  V /| | | |_| |_| |___) |
				  \_/\_/ |_|_|\__|\___/|____/ 
											  
 _____         _                 _             _           
|_   _|__  ___| |__  _ __   ___ | | ___   __ _(_) ___  ___ 
  | |/ _ \/ __| '_ \| '_ \ / _ \| |/ _ \ / _` | |/ _ \/ __|
  | |  __/ (__| | | | | | | (_) | | (_) | (_| | |  __/\__ \
  |_|\___|\___|_| |_|_| |_|\___/|_|\___/ \__, |_|\___||___/
                                         |___/             
----------------------------- Copyright 2017, David "King David" Wiltos ]]--[[
							  
	Lua Developer: King David
	Contact: www.wiltostech.com
		
-- Copyright 2017, David "King David" Wiltos ]]--

AddCSLuaFile()


SWEP.Author = "Robotboy655 + King David"
SWEP.Category = "Lichtschwerter"
SWEP.Contact = ""
SWEP.RenderGroup = RENDERGROUP_BOTH
SWEP.Slot = 0
SWEP.SlotPos = 4
SWEP.Spawnable = true
SWEP.DrawAmmo = false
SWEP.DrawCrosshair = false
SWEP.AutoSwitchTo = false
SWEP.AutoSwitchFrom = false
SWEP.DrawWeaponInfoBox = false
SWEP.ViewModel = "models/weapons/v_crowbar.mdl"
SWEP.WorldModel = "models/sgg/starwars/weapons/w_anakin_ep2_saber_hilt.mdl"
SWEP.ViewModelFOV = 55
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"
SWEP.TrainingLightsaber = true

------------------------------------------------------------THINGS YOU WILL EDIT ARE BELOW HERE-------------------------------------------------------------------------
SWEP.PrintName = "Lichtschwert (Dual)" --Name of the lightsaber
SWEP.Class = "weapon_lightsaber_personaldual" --The file name of this swep
SWEP.DualWielded = true --Should this be a dual wielded saber?
SWEP.CanMoveWhileAttacking = true -- Can the user move while attacking
SWEP.SaberDamage = 50 --How much damage the saber does when it's being swung
SWEP.SaberBurnDamage = 25 -- How much damage the saber does when it's colliding with someone ( coming in contact with laser )
SWEP.MaxForce = 100 --The maximum amount of force in the meter
SWEP.MaxStamina = 100 --The maximum amount of stamina in the meter
SWEP.RegenSpeed = 2 --The MULTIPLIER for the regen speed. Half speed = 0.5, Double speed = 2, etc.
SWEP.CanKnockback = true --Should this saber be able to push people back when they get hit?
SWEP.MaxBlockAngle = 135
SWEP.BlasterBlockCost = 2
SWEP.BladeBlockCost = 3
SWEP.ForcePowerList = {}
--Force powers you want the saber to have ( REMEMBER TO PUT A COMMA AFTER EACH ONE, AND COPY THE TITLE EXACTLY AS IT'S LISTED )
--For a list of options, just look at the keys in autorun/client/wos_forcematerialbuilding.lua

SWEP.UseSkills = true
SWEP.PersonalLightsaber = true

SWEP.CustomSettings = {}

--[[ Use this to overwrite the ULX Forms/Stances for this particular swep ( [ "FORMNAME" ] = { STANCENUM1, STANCENUM2, STANCENUM3 } )
	Example:
	SWEP.UseForms = {
	["Aggressive"] = { 1, 3 }, 
	["Defensive"] = { 2 }, 
}
]]--

SWEP.UseForms = {}

--Use these options to overwrite the player's commands
SWEP.UseHilt = false -- Model path of the hilt
SWEP.UseLength = false -- Length of the saber 
SWEP.UseWidth = false -- Width of the saber
SWEP.UseColor = false -- RGB Color of saber. Red = Color( 255, 0, 0 ) Blue = Color( 0, 0, 255 ), etc.
SWEP.UseDarkInner = false -- Does it have a dark inner? 1 = true
SWEP.UseLoopSound = "lightsaber/saber_loop1.wav" -- The loop sound path
SWEP.UseSwingSound = false -- The swing sound path
SWEP.UseOnSound = "lightsaber/saber_on1.wav" -- The on sound path
SWEP.UseOffSound = "lightsaber/saber_off1.wav" -- The off sound path

--These are the ones for the second saber for dual wielding. If you are using a single saber, this doesn't do shit
SWEP.UseSecHilt = false
SWEP.UseSecLength = false
SWEP.UseSecWidth = false
SWEP.UseSecColor = false
SWEP.UseSecDarkInner = false

-----------------------------------------------------------END OF EDIT---------------------------------------------------------------
if !SWEP.DualWielded then
	SWEP.Base = "wos_adv_single_lightsaber_base"
else
	SWEP.Base = "wos_adv_dual_lightsaber_base"
end

if CLIENT then
	killicon.Add( SWEP.Class, "lightsaber/lightsaber_killicon", color_white )
end
--addons/wos-alcs-custom/lua/weapons/weapon_lightsaber_reus.lua:


AddCSLuaFile()

SWEP.Author = "Robotboy655 + King David + Oninoni"
SWEP.Category = "Lichtschwerter (Lore Chars)"
SWEP.Contact = ""
SWEP.RenderGroup = RENDERGROUP_BOTH
SWEP.Slot = 0
SWEP.SlotPos = 4
SWEP.Spawnable = true
SWEP.DrawAmmo = false
SWEP.DrawCrosshair = true
SWEP.AutoSwitchTo = false
SWEP.AutoSwitchFrom = false
SWEP.DrawWeaponInfoBox = false
SWEP.ViewModel = "models/weapons/v_crowbar.mdl"
SWEP.WorldModel = "models/sgg/starwars/weapons/w_anakin_ep2_saber_hilt.mdl"
SWEP.ViewModelFOV = 55
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"

------------------------------------------------------------THINGS YOU WILL EDIT ARE BELOW HERE-------------------------------------------------------------------------
SWEP.PrintName = "Keelyvine Reus" --Name of the lightsaber
SWEP.Class = "weapon_lightsaber_reus" --The file name of this swep
SWEP.DualWielded = false --Should this be a dual wielded saber?
SWEP.CanMoveWhileAttacking = true -- Can the user move while attacking
SWEP.SaberDamage = 150 --How much damage the saber does when it's being swung
SWEP.SaberBurnDamage = 25 -- How much damage the saber does when it's colliding with someone ( coming in contact with laser )
SWEP.MaxForce = 100 --The maximum amount of force in the meter
SWEP.MaxStamina = 100 --The maximum amount of stamina in the meter
SWEP.RegenSpeed = 2 --The MULTIPLIER for the regen speed. Half speed = 0.5, Double speed = 2, etc.
SWEP.CanKnockback = true --Should this saber be able to push people back when they get hit?
SWEP.MaxBlockAngle = 135
SWEP.BlasterBlockCost = 2
SWEP.BladeBlockCost = 3
SWEP.ForcePowerList = {
	"Machtsprung",
	"Atemkontrolle",
	"Machtzug",
	"Machtschub",
	"Macht-Geschwindigkeit",
	"Lichtschwertwurf",
	"Schwert-Barriere",
	"Macht-Öffnung",
	"Macht-Stürmen",
	"Machtspiegel",
	"Beinhieb",
	"Macht-Beben",
	"Lähmender Schlag",
	"Macht-Entwaffnen"
}

SWEP.BlockDrainRate = 0

SWEP.UseForms = {
	["Form I | Shii-Cho"] = {1, 2, 3},
	["Form II | Makashi"] = {1, 2, 3},
	["Form IV | Ataru"] = {1, 2, 3}
}

--Use these options to overwrite the player's commands
SWEP.UseHilt = "models/starwars/cwa/lightsabers/lightsideaffiliation.mdl" -- Model path of the hilt
SWEP.UseLength = 45 -- Length of the saber 
SWEP.UseWidth = 2 -- Width of the saber
SWEP.UseColor = Color(33,240, 0) -- RGB Color of saber. Red = Color( 255, 0, 0 ) Blue = Color( 0, 0, 255 ), etc.
SWEP.UseDarkInner = 0 -- Does it have a dark inner? 1 = true
SWEP.UseLoopSound = "lightsaber/saber_loop1.wav" -- The loop sound path
SWEP.UseSwingSound = false -- The swing sound path
SWEP.UseOnSound = "lightsaber/saber_on1.wav" -- The on sound path
SWEP.UseOffSound = "lightsaber/saber_off1.wav" -- The off sound path

--These are the ones for the second saber for dual wielding. If you are using a single saber, this doesn't do shit
SWEP.UseSecHilt = false
SWEP.UseSecLength = false
SWEP.UseSecWidth = false
SWEP.UseSecColor = false
SWEP.UseSecDarkInner = 0


-----------------------------------------------------------END OF EDIT----------------------------------------------------------------


if !SWEP.DualWielded then
	SWEP.Base = "wos_adv_single_lightsaber_base"
else
	SWEP.Base = "wos_adv_dual_lightsaber_base"
end

if CLIENT then
	killicon.Add( SWEP.Class, "lightsaber/lightsaber_killicon", color_white )
end

--addons/wos-alcs-custom/lua/weapons/weapon_lightsaber_secura.lua:
AddCSLuaFile()

SWEP.Author = "Robotboy655 + King David + Oninoni"
SWEP.Category = "Lichtschwerter (Lore Chars)"
SWEP.Contact = ""
SWEP.RenderGroup = RENDERGROUP_BOTH
SWEP.Slot = 0
SWEP.SlotPos = 4
SWEP.Spawnable = true
SWEP.DrawAmmo = false
SWEP.DrawCrosshair = true
SWEP.AutoSwitchTo = false
SWEP.AutoSwitchFrom = false
SWEP.DrawWeaponInfoBox = false
SWEP.ViewModel = "models/weapons/v_crowbar.mdl"
SWEP.WorldModel = "models/starwars/cwa/lightsabers/aaylasecura.mdl"
SWEP.ViewModelFOV = 55
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"

------------------------------------------------------------THINGS YOU WILL EDIT ARE BELOW HERE-------------------------------------------------------------------------
SWEP.PrintName = "Aayla Secura" --Name of the lightsaber
SWEP.Class = "weapon_lightsaber_secura" --The file name of this swep
SWEP.DualWielded = false --Should this be a dual wielded saber?
SWEP.CanMoveWhileAttacking = true -- Can the user move while attacking
SWEP.SaberDamage = 150 --How much damage the saber does when it's being swung
SWEP.SaberBurnDamage = 25 -- How much damage the saber does when it's colliding with someone ( coming in contact with laser )
SWEP.MaxForce = 100 --The maximum amount of force in the meter
SWEP.MaxStamina = 100 --The maximum amount of stamina in the meter
SWEP.RegenSpeed = 2 --The MULTIPLIER for the regen speed. Half speed = 0.5, Double speed = 2, etc.
SWEP.CanKnockback = true --Should this saber be able to push people back when they get hit?
SWEP.MaxBlockAngle = 135
SWEP.BlasterBlockCost = 2
SWEP.BladeBlockCost = 3
SWEP.ForcePowerList = {
	"Macht-Geschwindigkeit",
	"Machtsprung",
	"Machtspiegel",
	"Machtschub",
	"Machtzug",
	"Lichtschwertwurf",
	"Macht-Stürmen",
	"Macht-Sicht",
	"Macht-Öffnung",
	"Schwert-Barriere",
	"Macht-Beben",
	"Klingensturm",
	"Beinhieb",
	"Lähmender Schlag",
	"Macht-Entwaffnen"
}

SWEP.BlockDrainRate = 0

SWEP.UseForms = {
	["Form I | Shii-Cho"] = {1, 2, 3},
	["Form IV | Ataru"]   = {1, 2, 3},
	["Form VI | Niman"]   = {1, 2, 3}
}

--Use these options to overwrite the player's commands
SWEP.UseHilt = "models/starwars/cwa/lightsabers/aaylasecura.mdl" -- Model path of the hilt
SWEP.UseLength = 45 -- Length of the saber 
SWEP.UseWidth = 2 -- Width of the saber
SWEP.UseColor = Color(0, 0, 255) -- RGB Color of saber. Red = Color( 255, 0, 0 ) Blue = Color( 0, 0, 255 ), etc.
SWEP.UseDarkInner = 0 -- Does it have a dark inner? 1 = true
SWEP.UseLoopSound = "lightsaber/saber_loop1.wav" -- The loop sound path
SWEP.UseSwingSound = false -- The swing sound path
SWEP.UseOnSound = "lightsaber/saber_on1.wav" -- The on sound path
SWEP.UseOffSound = "lightsaber/saber_off1.wav" -- The off sound path

--These are the ones for the second saber for dual wielding. If you are using a single saber, this doesn't do shit
SWEP.UseSecHilt = false
SWEP.UseSecLength = false
SWEP.UseSecWidth = false
SWEP.UseSecColor = false
SWEP.UseSecDarkInner = 0


-----------------------------------------------------------END OF EDIT----------------------------------------------------------------
if !SWEP.DualWielded then
	SWEP.Base = "wos_adv_single_lightsaber_base"
else
	SWEP.Base = "wos_adv_dual_lightsaber_base"
end

if CLIENT then
	killicon.Add( SWEP.Class, "lightsaber/lightsaber_killicon", color_white )
end

--addons/wos-alcs-custom/lua/weapons/weapon_lightsaber_xebec.lua:
AddCSLuaFile()

SWEP.Author = "Robotboy655 + King David + Oninoni"
SWEP.Category = "Lichtschwerter (Lore Chars)"
SWEP.Contact = ""
SWEP.RenderGroup = RENDERGROUP_BOTH
SWEP.Slot = 0
SWEP.SlotPos = 4
SWEP.Spawnable = true
SWEP.DrawAmmo = false
SWEP.DrawCrosshair = true
SWEP.AutoSwitchTo = false
SWEP.AutoSwitchFrom = false
SWEP.DrawWeaponInfoBox = false
SWEP.ViewModel = "models/weapons/v_crowbar.mdl"
SWEP.WorldModel = "models/starwars/cwa/lightsabers/petro.mdl"
SWEP.ViewModelFOV = 55
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"

------------------------------------------------------------THINGS YOU WILL EDIT ARE BELOW HERE-------------------------------------------------------------------------
SWEP.PrintName = "Tyzen Xebec" --Name of the lightsaber
SWEP.Class = "weapon_lightsaber_xebec" --The file name of this swep
SWEP.DualWielded = false --Should this be a dual wielded saber?
SWEP.CanMoveWhileAttacking = true -- Can the user move while attacking
SWEP.SaberDamage = 150 --How much damage the saber does when it's being swung
SWEP.SaberBurnDamage = 25 -- How much damage the saber does when it's colliding with someone ( coming in contact with laser )
SWEP.MaxForce = 100 --The maximum amount of force in the meter
SWEP.MaxStamina = 100 --The maximum amount of stamina in the meter
SWEP.RegenSpeed = 2 --The MULTIPLIER for the regen speed. Half speed = 0.5, Double speed = 2, etc.
SWEP.CanKnockback = true --Should this saber be able to push people back when they get hit?
SWEP.MaxBlockAngle = 135
SWEP.BlasterBlockCost = 2
SWEP.BladeBlockCost = 3
SWEP.ForcePowerList = {
	"Machtsprung",
	"Machtschub",
	"Machtzug",
	"Machtspiegel",
	"Atemkontrolle",
	"Macht-Stürmen",
	"Macht-Geschwindigkeit",
	"Lichtschwertwurf",
	"Macht-Entwaffnen"
}

SWEP.BlockDrainRate = 0

SWEP.UseForms = {
	["Form I | Shii-Cho"] = {1, 2, 3},
	["Form II | Makashi"]  = {1, 2, 3},
	["Form IV | Ataru"]   = {1, 2, 3},
	["Form VI | Niman"]   = {1}
}

--Use these options to overwrite the player's commands
SWEP.UseHilt = "models/starwars/cwa/lightsabers/petro.mdl" -- Model path of the hilt
SWEP.UseLength = 45 -- Length of the saber 
SWEP.UseWidth = 2 -- Width of the saber
SWEP.UseColor = Color( 0, 63, 255 ) -- RGB Color of saber. Red = Color( 255, 0, 0 ) Blue = Color( 0, 0, 255 ), etc.
SWEP.UseDarkInner = 0 -- Does it have a dark inner? 1 = true
SWEP.UseLoopSound = "lightsaber/saber_loop1.wav" -- The loop sound path
SWEP.UseSwingSound = false -- The swing sound path
SWEP.UseOnSound = "lightsaber/saber_on1.wav" -- The on sound path
SWEP.UseOffSound = "lightsaber/saber_off1.wav" -- The off sound path

--These are the ones for the second saber for dual wielding. If you are using a single saber, this doesn't do shit
SWEP.UseSecHilt = false
SWEP.UseSecLength = false
SWEP.UseSecWidth = false
SWEP.UseSecColor = false
SWEP.UseSecDarkInner = 0

-----------------------------------------------------------END OF EDIT----------------------------------------------------------------


if !SWEP.DualWielded then
	SWEP.Base = "wos_adv_single_lightsaber_base"
else
	SWEP.Base = "wos_adv_dual_lightsaber_base"
end

if CLIENT then
	killicon.Add( SWEP.Class, "lightsaber/lightsaber_killicon", color_white )
end

--addons/wos-alcs-custom/lua/weapons/weapon_lightsaber_yoda.lua:
AddCSLuaFile()

SWEP.Author = "Robotboy655 + King David + Oninoni"
SWEP.Category = "Lichtschwerter (Lore Chars)"
SWEP.Contact = ""
SWEP.RenderGroup = RENDERGROUP_BOTH
SWEP.Slot = 0
SWEP.SlotPos = 4
SWEP.Spawnable = true
SWEP.DrawAmmo = false
SWEP.DrawCrosshair = true
SWEP.AutoSwitchTo = false
SWEP.AutoSwitchFrom = false
SWEP.DrawWeaponInfoBox = false
SWEP.ViewModel = "models/weapons/v_crowbar.mdl"
SWEP.WorldModel = "models/sgg/starwars/weapons/w_yoda_saber_hilt.mdl"
SWEP.ViewModelFOV = 55
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"

------------------------------------------------------------THINGS YOU WILL EDIT ARE BELOW HERE-------------------------------------------------------------------------
SWEP.PrintName = "Yoda" --Name of the lightsaber
SWEP.Class = "weapon_lightsaber_yoda" --The file name of this swep
SWEP.DualWielded = false --Should this be a dual wielded saber?
SWEP.CanMoveWhileAttacking = true -- Can the user move while attacking
SWEP.SaberDamage = 150 --How much damage the saber does when it's being swung
SWEP.SaberBurnDamage = 25 -- How much damage the saber does when it's colliding with someone ( coming in contact with laser )
SWEP.MaxForce = 100 --The maximum amount of force in the meter
SWEP.MaxStamina = 100 --The maximum amount of stamina in the meter
SWEP.RegenSpeed = 2 --The MULTIPLIER for the regen speed. Half speed = 0.5, Double speed = 2, etc.
SWEP.CanKnockback = true --Should this saber be able to push people back when they get hit?
SWEP.MaxBlockAngle = 135
SWEP.BlasterBlockCost = 2
SWEP.BladeBlockCost = 3
SWEP.ForcePowerList = {
	"Macht-Geschwindigkeit",
	"Machtsprung",
	"Machtspiegel",
	"Machtschub",
	"Machtzug",
	"Lichtschwertwurf",
	"Atemkontrolle",
	"Machtheilung",
	"Gruppenheilung",
	"Selbstheilung",
	"Meditieren",
	"Macht-Öffnung",
	"Macht-Griff",
	"Großer Machtschub",
	"Großer Machtzug",
	"Macht-Teleportation",
	"Energiestrahl",
	"Macht-Sicht",
	"Machtstoß",
	"Macht-Induktion",
	"Smaragdblitze",
	"Machtschild",
	"Macht-Verlangsamung",
	"Flamusfracta",
	"Kristallschlag",
	"Macht-Stasis",
	"Blenden",
	"Macht-Beben",
	"Beinhieb",
	"Klingensturm",
	"Machtblockade",
	"Willenskraft",
	"Macht-Entwaffnen",
	"Macht-Reflektion"
}
--Force powers you want the saber to have ( REMEMBER TO PUT A COMMA AFTER EACH ONE, AND COPY THE TITLE EXACTLY AS IT'S LISTED )
--For a list of options, just look at the keys in autorun/client/wos_forcematerialbuilding.lua

SWEP.DevestatorList = {"Kyber Schlag", "Schallentladung", "Flammenschauer"}

SWEP.BlockDrainRate = 0

SWEP.UseForms = {
	["Form I | Shii-Cho"] = {1, 2, 3},
	["Form III | Soresu"] = {1, 2, 3},
	["Form IV | Ataru"]   = {1, 2, 3},
	["Form VI | Niman"]   = {1, 2, 3}
}

--Use these options to overwrite the player's commands
SWEP.UseHilt = "models/sgg/starwars/weapons/w_yoda_saber_hilt.mdl" -- Model path of the hilt
SWEP.UseLength = 32 -- Length of the saber 
SWEP.UseWidth = 2 -- Width of the saber
SWEP.UseColor = Color(0, 255, 0) -- RGB Color of saber. Red = Color( 255, 0, 0 ) Blue = Color( 0, 0, 255 ), etc.
SWEP.UseDarkInner = 0 -- Does it have a dark inner? 1 = true
SWEP.UseLoopSound = "lightsaber/saber_loop1.wav" -- The loop sound path
SWEP.UseSwingSound = false -- The swing sound path
SWEP.UseOnSound = "lightsaber/saber_on1.wav" -- The on sound path
SWEP.UseOffSound = "lightsaber/saber_off1.wav" -- The off sound path

--These are the ones for the second saber for dual wielding. If you are using a single saber, this doesn't do shit
SWEP.UseSecHilt = false
SWEP.UseSecLength = false
SWEP.UseSecWidth = false
SWEP.UseSecColor = false
SWEP.UseSecDarkInner = 0


-----------------------------------------------------------END OF EDIT----------------------------------------------------------------
if !SWEP.DualWielded then
	SWEP.Base = "wos_adv_single_lightsaber_base"
else
	SWEP.Base = "wos_adv_dual_lightsaber_base"
end

if CLIENT then
	killicon.Add( SWEP.Class, "lightsaber/lightsaber_killicon", color_white )
end

--addons/egm_tfa_mines/lua/weapons/weapon_mine_base/shared.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--              Mines            	 --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--        Mines | Base Weapon        --
---------------------------------------

SWEP.Base 					= "weapon_swrp_egm_base"

SWEP.PrintName 				= "Minen - Base"
SWEP.Author					= "Deltaa"
SWEP.Purpose				= "Linksklick: Platziere eine Mine \nRechtsklick: Hebe deine Mine wieder auf"
SWEP.Instructions 			= "Linksklick: Platziere eine Mine \nRechtsklick: Hebe deine Mine wieder auf"

SWEP.Type					= "Mine"

SWEP.Slot 					= 1
SWEP.SlotPos 				= 1

SWEP.Spawnable				= false
SWEP.AdminSpawnable 		= false

SWEP.ViewModel 				= "models/bf2017/c_scoutblaster.mdl"
SWEP.WorldModel 			= "models/bf2017/w_scoutblaster.mdl"
SWEP.ViewModelFOV			= 75
SWEP.ViewModelFlip			= false

SWEP.UseHands				= true
SWEP.HoldType				= "slam"

SWEP.Primary.ClipSize 		= 1
SWEP.Primary.DefaultClip 	= 1
SWEP.Primary.Ammo			= "AlyxGun"

SWEP.Mine 					= "mine_antiperson"
SWEP.Skin 					= 1

SWEP.data 					= {}
SWEP.data.ironsights 		= 0

SWEP.WElements = {
	["mine"] = {
		type = "Model",
		model = "models/bf2/Landmine.mdl",
		bone = "ValveBiped.Bip01_R_Hand",
		rel = "",
		pos = Vector(3.635, 2.596, -0.519),
		angle = Angle(-75.974, 0, 0),
		size = Vector(0.5, 0.5, 0.5),
		color = Color(255, 255, 255, 255),
		surpresslightning = true,
		material = "",
		skin = SWEP.Skin,
		bodygroup = {}
	}
}

SWEP.VElements = {
	["mine"] = {
		type = "Model",
		model = "models/bf2/Landmine.mdl",
		bone = "ValveBiped.Bip01_R_Hand",
		rel = "",
		pos = Vector(1.557, 4.675, -1.558),
		angle = Angle(-38.571, 0, 0),
		size = Vector(0.5, 0.5, 0.5),
		color = Color(255, 255, 255, 255),
		surpresslightning = true,
		material = "",
		skin = SWEP.Skin,
		bodygroup = {}
	}
}

function SWEP:PrimaryAttack()
	if not IsFirstTimePredicted() then return end

	self:SetNextPrimaryFire(CurTime() + 1)

	if self:Clip1() < 1 then
		return
	end

	if SERVER then
		self:GetOwner():LagCompensation(true)
		local trace = self:GetOwner():GetEyeTrace()
		local hitAngle = trace.HitNormal:Angle()
		self:GetOwner():LagCompensation(false)

		if IsValid(trace.Entity) then return end

		if self:GetOwner():GetPos():DistToSqr(trace.HitPos) > 10000 then return end

		local mine = ents.Create(self.Mine)
		mine:SetPos(trace.HitPos)
		mine:SetAngles(Angle(0,0,0))
		mine:SetLocalAngles(mine:WorldToLocalAngles(hitAngle) + Angle(90,0,0))
		mine:Spawn()

		if (mine:GetLocalAngles().x > 45 or mine:GetLocalAngles().z > 45) then
			mine:Remove()
		else
			local ply = self:GetOwner()

			mine.Owner = ply

			mine:EmitSound("npc/roller/blade_cut.wav")

			if ply:IsPlayer() then
				ply:StripWeapon(self:GetClass())
			end
		end
	end
end

function SWEP:SecondaryAttack()
	if not IsFirstTimePredicted() then return end

	self:SetNextSecondaryFire(CurTime() + 5)

	if SERVER then
		self:GetOwner():LagCompensation(true)
		local tr = self:GetOwner():GetEyeTrace()
		local mine = tr.Entity
		self:GetOwner():LagCompensation(false)

		if self:GetOwner():GetPos():DistToSqr(mine:GetPos()) > 10000 then return end

		if not mine.IsMine then return end
		if not mine.Owner or mine.Owner != self:GetOwner() then return end

		if mine.IsDetonated then return end
		mine:EmitSound("npc/roller/blade_in.wav")

		self:GetOwner():GiveAmmo(1, "rpg_round", true)

		SafeRemoveEntityDelayed(mine, 1)
	end
end

if CLIENT then
	SWEP.PreviewModel = ClientsideModel("models/bf2/Landmine.mdl")
	SWEP.PreviewModel:SetNoDraw(true)
	SWEP.PreviewModel:SetMaterial("models/wireframe")

	function SWEP:DrawHUD()
		if self:GetOwner():Alive() and not self:GetOwner():InVehicle() then
			local trace = self:GetOwner():GetEyeTrace()

			self.PreviewModel:SetPos(trace.HitPos)
			self.PreviewModel:SetAngles(Angle(0,0,0))

			local hitAngle = trace.HitNormal:Angle()
			self.PreviewModel:SetLocalAngles(self.PreviewModel:WorldToLocalAngles(hitAngle) + Angle(90,0,0))

			if (self.PreviewModel:GetLocalAngles().x > 45 or self.PreviewModel:GetLocalAngles().z > 45) then
				render.SetColorModulation(255,0,0)
			else
				render.SetColorModulation(0,0,255 / 0, 0 / 255)
			end

			self.PreviewModel:DrawModel()
			render.SetColorModulation(0,0,0)
		end
	end
end

--gamemodes/starwarsrp/entities/weapons/weapon_swrp_breathingswep/shared.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
-- Copyright © 2020 Pascal Sthamer,  --
--      Konstantin Zisiadis und      --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--          Breathing SWEP           --
---------------------------------------

SWEP.Author = "Deltaa"
SWEP.Contact = "https://einfach-gaming.de"
SWEP.Purpose = "Eine Waffe für den SW:RP Spielmodus" -- A weapon for the swrp gamemode
SWEP.Instructions = "Klicke um das Atemgerät zu aktivieren/deaktivieren." -- Klick to use

SWEP.Category = "SW:RP (Sonstiges)"

SWEP.PrintName = "Modernes Atemgerät" -- Breathing Device

SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.ViewModelFOV = 70
SWEP.Slot = 3
SWEP.SlotPos = 1

SWEP.ViewModel = ""
SWEP.WorldModel = ""

SWEP.Primary = {}
SWEP.Primary.ClipSize       = -1
SWEP.Primary.DefaultClip    = -1
SWEP.Primary.Automatic      = false
SWEP.Primary.Ammo           = "none"

SWEP.Secondary = {}
SWEP.Secondary.ClipSize     = -1
SWEP.Secondary.DefaultClip  = -1
SWEP.Secondary.Automatic    = false
SWEP.Secondary.Ammo         = "none"

SWEP.MaxOxygen = 300
SWEP.OPS = 1

SWEP.DrawAmmo       = false
SWEP.DrawCrosshair  = false

function SWEP:Initialize()
	self:SetHoldType("normal")

	if SERVER then
		self:SetNWInt("Breathing.Oxygen", self.MaxOxygen)
	end
end

function SWEP:Reload()
	return
end

function SWEP:GetOxygen()
	return self:GetNWInt("Breathing.Oxygen", self.MaxOxygen)
end
--addons/egm_tfa_weapons/lua/weapons/weapon_swrp_dc15a.lua:
-- Written by Oninoni

SWEP.Base                   = "weapon_swrp_egm_base"

SWEP.PrintName              = "DC-15A"
SWEP.Category               = "SW:RP (Republik)"
SWEP.Type					= "Republic Heavy Blaster Rifle"
SWEP.Manufacturer           = "BlasTech Industries"
SWEP.Slot                   = 0
SWEP.SlotPos                = 0

SWEP.Spawnable = true

-- Model --

SWEP.ViewModel						= "models/weapons/synbf3/c_dlt19.mdl"
SWEP.WorldModel						= "models/weapons/synbf3/w_dlt19.mdl"

SWEP.VMPos = Vector(0, -2, -1.5)
SWEP.VMAng = Vector(0, 0, 0)

SWEP.HoldType 						= "ar2"
SWEP.ReloadHoldTypeOverride 		= "ar2"

SWEP.UseHands 						= true

SWEP.ShowWorldModel = false

SWEP.ViewModelBoneMods = {
	["v_dlt19_reference001"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) }
}

SWEP.VElements = {
	["dc15a"] = { type = "Model", model = "models/sw_battlefront/weapons/dc15a_rifle.mdl", bone = "v_dlt19_reference001", rel = "", pos = Vector(0.75, -1.5, 2.5), angle = Angle(0, -90, 0), size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}

SWEP.WElements = {
	["dc15a"] = { type = "Model", model = "models/sw_battlefront/weapons/dc15a_rifle.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(3, 0.4, -2), angle = Angle(-13, 0, 180), size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}

SWEP.HolsterOffset = Vector(12, 0, 0)
SWEP.HolsterAngle = Angle(0, 180, 0)

SWEP.Attachments = {
	[1] = { offset = { 0, 0 }, atts = { "swrp_am_training", "swrp_am_stun_lite" }, order = 1 },
}



-- Tracer --

-- Tracer name
SWEP.TracerName 					= "rw_sw_laser_blue"


-- Magazine --

-- Ammo per Magazine
SWEP.Primary.ClipSize				= 100
-- Magazine Count
SWEP.Primary.DefaultClip			= SWEP.Primary.ClipSize * 8
-- Ammo Type
SWEP.Primary.Ammo					= "ar2"
-- Ammo Consumption per shot
SWEP.Primary.AmmoConsumption 		= 1

-- Fire Modes --

-- Actual Fire Modes.
SWEP.FireModes = {
	"Automatic",
	"Single",
}

-- Automatic RPM
SWEP.Primary.RPM					= 285
-- Semi Automatic Fire RPM
SWEP.Primary.RPM_Semi				= 140

-- Burst Fire RPM
SWEP.Primary.RPM_Burst				= nil
-- Delay Between Bursts
SWEP.Primary.BurstDelay				= nil

-- Range --

-- Max Range of weapon
SWEP.Primary.Range 					= 8000

-- Shooting --

-- Number of bullets per shot (For Shotguns)
SWEP.Primary.NumShots				= 1
-- Damage per bullet
SWEP.Primary.Damage = 30

-- Aiming --

SWEP.data 							= {}
-- Enable Iron Sights
SWEP.data.ironsights				= 1
-- Iron Sights FOV
SWEP.Secondary.IronFOV				= 75 -- TODO

SWEP.ScopeReticule 					= "#sw/visor/sw_ret_redux_blue"
SWEP.Secondary.ScopeZoom 			= 7
SWEP.ScopeReticule_Scale 			= {1,1}

SWEP.Primary.Spread					= 0.012
SWEP.Primary.IronAccuracy 			= 0.004

SWEP.Primary.SpreadMultiplierMax 	= 2.5
SWEP.Primary.SpreadIncrement 		= 0.35

-- Holding Positions

-- Aiming
SWEP.IronSightsPos = Vector(-2.83, -6, 0)
SWEP.IronSightsAng = Vector(0, 0, 0)
-- Running
SWEP.RunSightsPos = Vector(5.226, -2, 0)
SWEP.RunSightsAng = Vector(-18, 36, -13.5)
-- Inspecting
SWEP.InspectPos = Vector(8, -4.8, -3)
SWEP.InspectAng = Vector(11.199, 38, 0)

-- Sounds --

-- Fire Sound
SWEP.Primary.Sound 					= Sound("weapons/dc15a_blaster_rifle/dc15a_fire.ogg")
-- Reload Sound
SWEP.Primary.ReloadSound 			= Sound("w/heavy.wav")

DEFINE_BASECLASS( SWEP.Base )
--addons/egm_tfa_weapons/lua/weapons/weapon_swrp_dc15s_stun.lua:
-- Written by Oninoni & Fazor

SWEP.Base                   = "weapon_swrp_egm_base"

SWEP.PrintName              = "DC-15S Stun"
SWEP.Category               = "SW:RP (Republik)"
SWEP.Type					= "Republic Blaster Carbine"
SWEP.Manufacturer           = "BlasTech Industries"
SWEP.Slot                   = 0
SWEP.SlotPos                = 0

SWEP.Spawnable = true

-- Model --

SWEP.ViewModel						= "models/bf2017/c_e11.mdl"
SWEP.WorldModel						= "models/bf2017/w_e11.mdl"

SWEP.VMPos = Vector(1.96, 0, -0.52)
SWEP.VMAng = Vector(0,0,0)

SWEP.HoldType 						= "smg"
SWEP.ReloadHoldTypeOverride 		= "smg"

SWEP.UseHands 						= true

SWEP.ShowWorldModel = false

SWEP.ViewModelBoneMods = {
	["v_e11_reference001"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(-3, 0, 0), angle = Angle(0, 0, 0) }
}

SWEP.VElements = {
	["dc15s"] = { type = "Model", model = "models/sw_battlefront/weapons/dc15s_carbine.mdl", bone = "v_e11_reference001", rel = "", pos = Vector(-1.1, 2.2, 0), angle = Angle(0, -90, 0), size = Vector(1.3, 1.3, 1.3), color = Color(255, 255, 255, 255), surpresslightning = false, material = "models/sw_battlefront/weapons/dc15s/t_dc15a_cs", skin = 0, bodygroup = {} },
}

SWEP.WElements = {
	["dc15s"] = { type = "Model", model = "models/sw_battlefront/weapons/dc15s_carbine.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(3, 0.4, -0.5), angle = Angle(-13, 0, 180), size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "models/sw_battlefront/weapons/dc15s/t_dc15a_cs", skin = 0, bodygroup = {} }
}

SWEP.HolsterOffset = Vector(11, 0, 0)
SWEP.HolsterAngle = Angle(0, 180, 0)

SWEP.Attachments = {
	[1] = { offset = { 0, 0 }, atts = { "swrp_am_training", "swrp_am_stun" }, order = 1 },
}



-- Tracer --

-- Tracer name
SWEP.TracerName 					= "rw_sw_laser_blue"


-- Magazine --

-- Ammo per Magazine
SWEP.Primary.ClipSize				= 200
-- Magazine Count
SWEP.Primary.DefaultClip			= SWEP.Primary.ClipSize * 5
-- Ammo Type
SWEP.Primary.Ammo					= "ar2"
-- Ammo Consumption per shot
SWEP.Primary.AmmoConsumption 		= 1

-- Fire Modes --

-- Actual Fire Modes.
SWEP.FireModes = {
	"Automatic",
	"Single",
}

-- Automatic RPM
SWEP.Primary.RPM					= 444
-- Semi Automatic Fire RPM
SWEP.Primary.RPM_Semi				= 222

-- Burst Fire RPM
SWEP.Primary.RPM_Burst				= nil
-- Delay Between Bursts
SWEP.Primary.BurstDelay				= nil

-- Range --

-- Max Range of weapon
SWEP.Primary.Range 					= 4000

-- Shooting --

-- Number of bullets per shot (For Shotguns)
SWEP.Primary.NumShots				= 1
-- Damage per bullet
SWEP.Primary.Damage = 28

-- Aiming --

SWEP.data 							= {}
-- Enable Iron Sights
SWEP.data.ironsights				= 1
-- Iron Sights FOV
SWEP.Secondary.IronFOV				= 75 -- TODO

SWEP.ScopeReticule 					= "#sw/visor/sw_ret_redux_blue"
SWEP.Secondary.ScopeZoom 			= 7
SWEP.ScopeReticule_Scale 			= {1,1}

SWEP.Primary.Spread					= 0.0185
SWEP.Primary.IronAccuracy 			= 0.0065

SWEP.Primary.SpreadMultiplierMax 	= 2.5
SWEP.Primary.SpreadIncrement 		= 0.35

-- Holding Positions

-- Aiming
SWEP.IronSightsPos = Vector(-5, -8, 3.2)
SWEP.IronSightsAng = Vector(0, 0, 0)
-- Running
SWEP.RunSightsPos = Vector(5.226, -2, 0)
SWEP.RunSightsAng = Vector(-18, 36, -13.5)
-- Inspecting
SWEP.InspectPos = Vector(8, -4.8, -3)
SWEP.InspectAng = Vector(11.199, 38, 0)

-- Sounds --

-- Fire Sound
SWEP.Primary.Sound 					= Sound("weapons/dc15s_blaster_carbine/dc15s_fire.ogg")
-- Reload Sound
SWEP.Primary.ReloadSound 			= Sound("w/heavy.wav")

DEFINE_BASECLASS( SWEP.Base )
--addons/egm_tfa_weapons/lua/weapons/weapon_swrp_dc15sa.lua:
-- Written by Oninoni & Fazor

SWEP.Base                   = "weapon_swrp_egm_base"

SWEP.PrintName              = "DC-15SA"
SWEP.Category               = "SW:RP (Republik)"
SWEP.Type					= "Republic Blaster Pistole"
SWEP.Manufacturer           = "BlasTech Industries"
SWEP.Slot                   = 1
SWEP.SlotPos                = 0

SWEP.Spawnable = true

-- Model --

SWEP.ViewModel						= "models/bf2017/c_scoutblaster.mdl"
SWEP.WorldModel						= "models/bf2017/w_scoutblaster.mdl"

SWEP.VMPos = Vector(1.96, -8, -2.5)
SWEP.VMAng = Vector(0,0,0)

SWEP.HoldType 						= "pistol"
SWEP.ReloadHoldTypeOverride 		= "pistol"

SWEP.UseHands 						= true

SWEP.ShowWorldModel = false

SWEP.ViewModelBoneMods = {
	["v_scoutblaster_reference001"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) }
}

SWEP.VElements = {
	["hunter"] = { type = "Model", model = "models/rcremastered/w_dc15pistol.mdl", bone = "v_scoutblaster_reference001", rel = "", pos = Vector(0, -2, 2.5), angle = Angle(0, 180, 0), size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}

SWEP.WElements = {
	["hunter"] = { type = "Model", model = "models/rcremastered/w_dc15pistol.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(5.5, 1, -4), angle = Angle(0, -90, 175), size = Vector(1.1, 1.1, 1.1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}

SWEP.HolsterOffset = Vector(0, -0.5, 0)
SWEP.HolsterAngle = Angle(180, 90, -180)

SWEP.Animations = { --Override this after SWEP:Initialize, for example, in attachments
	["reload"] = {
		["type"] = TFA.Enum.ANIMATION_ACT, --Sequence or act
		["value"] = ACT_VM_RELOAD_EMPTY,
		["enabled"] = true
	},
	["reload_empty"] = {
		["type"] = TFA.Enum.ANIMATION_ACT, --Sequence or act
		["value"] = ACT_VM_RELOAD_EMPTY
	},
	["reload_silenced"] = {
		["type"] = TFA.Enum.ANIMATION_ACT, --Sequence or act
		["value"] = ACT_VM_RELOAD_EMPTY,
		["enabled"] = true
	},
}

SWEP.Attachments = {
	[1] = { offset = { 0, 0 }, atts = { "swrp_am_training", "swrp_am_stun_lite" }, order = 1 },
}



-- Tracer --

-- Tracer name
SWEP.TracerName 					= "rw_sw_laser_blue"

-- Magazine --

-- Ammo per Magazine
SWEP.Primary.ClipSize				= 100
-- Magazine Count
SWEP.Primary.DefaultClip			= SWEP.Primary.ClipSize * 5
-- Ammo Type
SWEP.Primary.Ammo					= "ar2"
-- Ammo Consumption per shot
SWEP.Primary.AmmoConsumption 		= 1

-- Fire Modes --

-- Actual Fire Modes.
SWEP.FireModes = {
	"Single",
}

-- Automatic RPM
SWEP.Primary.RPM					= nil
-- Semi Automatic Fire RPM
SWEP.Primary.RPM_Semi				= 300

-- Burst Fire RPM
SWEP.Primary.RPM_Burst				= nil
-- Delay Between Bursts
SWEP.Primary.BurstDelay				= nil

-- Range --

-- Max Range of weapon
SWEP.Primary.Range 					= 2040

-- Shooting --

-- Number of bullets per shot (For Shotguns)
SWEP.Primary.NumShots				= 1
-- Damage per bullet
SWEP.Primary.Damage = 35

-- Aiming --

SWEP.data 							= {}
-- Enable Iron Sights
SWEP.data.ironsights				= 1
-- Iron Sights FOV
SWEP.Secondary.IronFOV				= 75 -- TODO

SWEP.ScopeReticule 					= "#sw/visor/sw_ret_redux_blue"
SWEP.Secondary.ScopeZoom 			= 7
SWEP.ScopeReticule_Scale 			= {1,1}

SWEP.Primary.Spread					= 0.0145
SWEP.Primary.IronAccuracy 			= 0.0048

SWEP.Primary.SpreadMultiplierMax 	= 4
SWEP.Primary.SpreadIncrement 		= 0.35

-- Holding Positions

-- Aiming
SWEP.IronSightsPos = Vector(-5.9, -5.5, 3.6)
SWEP.IronSightsAng = Vector(0, 0, 0)
-- Running
SWEP.RunSightsPos = Vector(5.226, -2, 0)
SWEP.RunSightsAng = Vector(-18, 36, -13.5)
-- Inspecting
SWEP.InspectPos = Vector(8, -4.8, -3)
SWEP.InspectAng = Vector(11.199, 38, 0)

-- Sounds --

-- Fire Sound
SWEP.Primary.Sound 					= Sound("weapons/bf3/dc15sa_quiet.ogg")
-- Reload Sound
SWEP.Primary.ReloadSound 			= Sound("w/heavy.wav")

DEFINE_BASECLASS( SWEP.Base )
--addons/egm_tfa_weapons/lua/weapons/weapon_swrp_dc17.lua:
-- Written by Oninoni

SWEP.Base                   = "weapon_swrp_egm_base"

SWEP.PrintName              = "DC-17"
SWEP.Category               = "SW:RP (Republik)"
SWEP.Type					= "Republic Blaster Pistol"
SWEP.Manufacturer           = "BlasTech Industries"
SWEP.Slot                   = 1
SWEP.SlotPos                = 0

SWEP.Spawnable = true

-- Model --

SWEP.ViewModel						= "models/bf2017/c_scoutblaster.mdl"
SWEP.WorldModel						= "models/bf2017/w_scoutblaster.mdl"

SWEP.VMPos = Vector(0.88, -4, -0.240)
SWEP.VMAng = Vector(0,0,0)

SWEP.HoldType 						= "pistol"
SWEP.ReloadHoldTypeOverride 		= "pistol"

SWEP.UseHands 						= true

SWEP.ShowWorldModel = false

SWEP.ViewModelBoneMods = {
	["v_scoutblaster_reference001"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, -0.3, 0), angle = Angle(0, 0, 0) }
}

SWEP.VElements = {
	["dc17"] = { type = "Model", model = "models/fisher/extendeddc17/extendeddc17.mdl", bone = "v_scoutblaster_reference001", rel = "", pos = Vector(-0.35, 0, 0.2), angle = Angle(0, 180, 0), size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
}

SWEP.WElements = {
	["dc17"] = { type = "Model", model = "models/fisher/extendeddc17/extendeddc17.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(3.5, 1.5, -1.5), angle = Angle(0, -90, 180), size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}

SWEP.HolsterOffset = Vector(2.5, 0.2, -2)
SWEP.HolsterAngle = Angle(0, -90, 0)

SWEP.Animations = { --Override this after SWEP:Initialize, for example, in attachments
	["reload"] = {
		["type"] = TFA.Enum.ANIMATION_ACT, --Sequence or act
		["value"] = ACT_VM_RELOAD_EMPTY,
		["enabled"] = true
	},
	["reload_empty"] = {
		["type"] = TFA.Enum.ANIMATION_ACT, --Sequence or act
		["value"] = ACT_VM_RELOAD_EMPTY
	},
	["reload_silenced"] = {
		["type"] = TFA.Enum.ANIMATION_ACT, --Sequence or act
		["value"] = ACT_VM_RELOAD_EMPTY,
		["enabled"] = true
	},
}

SWEP.Attachments = {
	[1] = { offset = { 0, 0 }, atts = { "swrp_am_training", "swrp_am_stun_lite" }, order = 1 },
}



-- Tracer --

-- Tracer name
SWEP.TracerName 					= "rw_sw_laser_blue"


-- Magazine --

-- Ammo per Magazine
SWEP.Primary.ClipSize				= 100
-- Magazine Count
SWEP.Primary.DefaultClip			= SWEP.Primary.ClipSize * 8
-- Ammo Type
SWEP.Primary.Ammo					= "ar2"
-- Ammo Consumption per shot
SWEP.Primary.AmmoConsumption 		= 1

-- Fire Modes --

-- Actual Fire Modes.
SWEP.FireModes = {
	"Single",
}

-- Automatic RPM
SWEP.Primary.RPM					= nil
-- Semi Automatic Fire RPM
SWEP.Primary.RPM_Semi				= 250

-- Burst Fire RPM
SWEP.Primary.RPM_Burst				= nil
-- Delay Between Bursts
SWEP.Primary.BurstDelay				= nil

-- Range --

-- Max Range of weapon
SWEP.Primary.Range 					= 2040

-- Shooting --

-- Number of bullets per shot (For Shotguns)
SWEP.Primary.NumShots				= 1
-- Damage per bullet
SWEP.Primary.Damage = 35

-- Aiming --

SWEP.data 							= {}
-- Enable Iron Sights
SWEP.data.ironsights				= 1
-- Iron Sights FOV
SWEP.Secondary.IronFOV				= 75 -- TODO

SWEP.ScopeReticule 					= "scope/gdcw_elcanreticle"
SWEP.Secondary.ScopeZoom 			= 1
SWEP.ScopeReticule_Scale 			= {1.1,1.1}

SWEP.Primary.Spread					= 0.0145
SWEP.Primary.IronAccuracy 			= 0.0048

SWEP.Primary.SpreadMultiplierMax 	= 4
SWEP.Primary.SpreadIncrement 		= 0.3

-- Holding Positions

-- Aiming
SWEP.IronSightsPos = Vector(-4.8, -6, 1.5)
SWEP.IronSightsAng = Vector(0, 0, 0)
-- Running
SWEP.RunSightsPos = Vector(2, -9.5, -15)
SWEP.RunSightsAng = Vector(39, -0.5, -2)
-- Inspecting
SWEP.InspectPos = Vector(8, -4.8, -3)
SWEP.InspectAng = Vector(11.199, 38, 0)

-- Sounds --

-- Fire Sound
SWEP.Primary.Sound 					= Sound ("weapons/dc17_blaster_pistol/dc17_fire.ogg");
-- Reload Sound
SWEP.Primary.ReloadSound 			= Sound ("weapons/bf3/pistols.wav");

DEFINE_BASECLASS( SWEP.Base )
--addons/egm_tfa_weapons/lua/weapons/weapon_swrp_dc17_stundual.lua:
-- Written by Oninoni and Meredin

SWEP.Base                   = "weapon_swrp_dc17dual"

SWEP.PrintName              = "DC-17 Dual (Stun Compatible)"
SWEP.Category               = "SW:RP (Republik)"
SWEP.Type					= "Republic Blaster Pistol"
SWEP.Manufacturer           = "BlasTech Industries"
SWEP.Slot                   = 1
SWEP.SlotPos                = 0

SWEP.Spawnable = true

SWEP.Attachments = {
	[1] = { offset = { 0, 0 }, atts = { "swrp_am_training", "swrp_am_stun" }, order = 1 },
}

DEFINE_BASECLASS( SWEP.Base )
--addons/egm_tfa_weapons/lua/weapons/weapon_swrp_dc17dual.lua:
-- Written by Oninoni and Meredin

SWEP.Base                   = "weapon_swrp_egm_base"

SWEP.PrintName              = "DC-17 Dual"
SWEP.Category               = "SW:RP (Republik)"
SWEP.Type					= "Republic Blaster Pistol"
SWEP.Manufacturer           = "BlasTech Industries"
SWEP.Slot                   = 1
SWEP.SlotPos                = 0

SWEP.Spawnable = true

-- Model --

SWEP.ViewModel						= "models/strasser/weapons/c_ddeagle.mdl"
SWEP.WorldModel						= "models/bf2017/w_scoutblaster.mdl"

SWEP.VMPos = Vector(0.88, -4, -0.240)
SWEP.VMAng = Vector(0,0,0)

SWEP.HoldType 						= "duel"
SWEP.ReloadHoldTypeOverride 		= "pistol"

SWEP.UseHands 						= true

SWEP.ShowWorldModel = false

SWEP.ViewModelBoneMods = {
}

SWEP.VElements = {
	["dc17"] = { type = "Model", model = "models/fisher/extendeddc17/extendeddc17.mdl", bone = "LeftHand_1stP", rel = "", pos = Vector(4, 1.5, -1), angle = Angle(78, -2, 90), size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["dc17+"] = { type = "Model", model = "models/fisher/extendeddc17/extendeddc17.mdl", bone = "RightHand_1stP", rel = "", pos = Vector(-4, -1.5, 1), angle = Angle(98, 178, 90), size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}

SWEP.WElements = {
	["dc17"] = { type = "Model", model = "models/fisher/extendeddc17/extendeddc17.mdl", bone = "ValveBiped.Bip01_L_Hand", rel = "", pos = Vector(4, 1.5, 1.3), angle = Angle(0, 90-5, 0), size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["dc17+"] = { type = "Model", model = "models/fisher/extendeddc17/extendeddc17.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(4, 1.5, -1.3), angle = Angle(0, -90-5, 180), size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}

SWEP.ProceduralHolsterPos = Vector(0,-8,-8)
SWEP.ProceduralHolsterAng = Vector(37.5,0,0)
SWEP.DoProceduralReload = true
SWEP.ProceduralReloadTime = 2.3

SWEP.Akimbo = true
SWEP.Primary.DoMuzzleFlash 			= true
SWEP.Secondary.DoMuzzleFlash 		= true
SWEP.Blowback_Shell_Enabled 		= true
SWEP.Blowback_Shell_Effect 			= "None"

SWEP.Attachments = {
	[1] = { offset = { 0, 0 }, atts = { "swrp_am_training", "swrp_am_stun_lite" }, order = 1 },
}

-- Tracer --

-- Tracer name
SWEP.TracerName 					= "rw_sw_dual_laser_blue"


-- Magazine --

-- Ammo per Magazine
SWEP.Primary.ClipSize				= 100 * 2
-- Magazine Count
SWEP.Primary.DefaultClip			= SWEP.Primary.ClipSize * 8
-- Ammo Type
SWEP.Primary.Ammo					= "ar2"
-- Ammo Consumption per shot
SWEP.Primary.AmmoConsumption 		= 1

-- Fire Modes --

-- Actual Fire Modes.
SWEP.FireModes = {
	"Single",
}

-- Automatic RPM
SWEP.Primary.RPM					= nil
-- Semi Automatic Fire RPM
SWEP.Primary.RPM_Semi				= 500

-- Burst Fire RPM
SWEP.Primary.RPM_Burst				= nil
-- Delay Between Bursts
SWEP.Primary.BurstDelay				= nil

-- Range --

-- Max Range of weapon
SWEP.Primary.Range 					= 2040

-- Shooting --

-- Number of bullets per shot (For Shotguns)
SWEP.Primary.NumShots				= 1
-- Damage per bullet
SWEP.Primary.Damage = 35

-- Aiming --

SWEP.data 							= {}
-- Enable Iron Sights
SWEP.data.ironsights				= 0
-- Iron Sights FOV
SWEP.Secondary.IronFOV				= 75 -- TODO

SWEP.ScopeReticule 					= "scope/gdcw_elcanreticle"
SWEP.Secondary.ScopeZoom 			= 1
SWEP.ScopeReticule_Scale 			= {1.1,1.1}

SWEP.Primary.Spread					= 0.0075
SWEP.Primary.IronAccuracy 			= 0

SWEP.Primary.SpreadMultiplierMax 	= 4
SWEP.Primary.SpreadIncrement 		= 0.3

-- Holding Positions

-- Aiming
SWEP.IronSightsPos = Vector(0, -5, 0)
SWEP.IronSightsAng = Vector(0, 0, 0)
-- Running
SWEP.RunSightsPos = Vector(0, -7.5, -10)
SWEP.RunSightsAng = Vector(37.5, 0, 0)
-- Inspecting
SWEP.InspectPos = Vector(0, -5, -5)
SWEP.InspectAng = Vector(37.5,0,0)


-- Sounds --

-- Fire Sound
SWEP.Primary.Sound 					= Sound("weapons/dc17_blaster_pistol/dc17_fire.ogg")
-- Reload Sound
SWEP.Primary.ReloadSound 			= Sound ("weapons/bf3/pistols.wav")

DEFINE_BASECLASS( SWEP.Base )
--addons/egm_tfa_weapons/lua/weapons/weapon_swrp_dc17m_br.lua:
SWEP.Base				   = "weapon_swrp_egm_3dscoped_base"

SWEP.PrintName		        = "DC-17m"
SWEP.Category		        = "SW:RP (Republik)"
SWEP.Type					= "Republic Elite Weapons System"
SWEP.Manufacturer		    = "BlasTech Industries"
SWEP.Slot			        = 0
SWEP.SlotPos				= 0

SWEP.Spawnable = true

-- Model --

SWEP.ViewModel						= "models/weapons/synbf3/c_dlt19.mdl"
SWEP.WorldModel						= "models/weapons/synbf3/w_dlt19.mdl"

SWEP.VMPos = Vector(2.02, 0, -4.82)
SWEP.VMAng = Vector(0,0,0)

SWEP.HoldType 						= "ar2"
SWEP.ReloadHoldTypeOverride 		= "ar2"

SWEP.UseHands 						= true

SWEP.ShowWorldModel = false

SWEP.Attachments = {
	[1] = { offset = { 0, 0 }, atts = {"swrp_dc17m_sniper","swrp_dc17m_rocket"}, order = 1 },
	[2] = { offset = { 0, 0 }, atts = { "swrp_am_training" }, order = 2 },
}
SWEP.AttachmentTableOverride = {}

SWEP.ViewModelBoneMods = {
	["v_dlt19_reference001"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 1), angle = Angle(0, 0, 0) }
}

SWEP.VElements = {
	["dc17m"] = { type = "Model", model = "models/cs574/dc17m/dc17m_base.mdl", bone = "v_dlt19_reference001", rel = "", pos = Vector(0, 0, 2), angle = Angle(0, 0, 0), size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {},},
	["rifle_module"] = { type = "Model", model = "models/cs574/dc17m/dc17m_rifle.mdl", bone = "", rel = "dc17m", pos = Vector(0, 0, 0), angle = Angle(0, 0, 0), size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {}, active = true  },
	["rifle_mag"] = { type = "Model", model = "models/cs574/dc17m/dc17m_mag.mdl", bone = "", rel = "dc17m", pos = Vector(0, 0, 0), angle = Angle(0, 0, 0), size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {}, active = true  },
	["rocket_module"] = { type = "Model", model = "models/cs574/dc17m/dc17m_rocket.mdl", bone = "", rel = "dc17m", pos = Vector(0, 0, 0), angle = Angle(0, 0, 0), size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {}, active = false  },
	["sniper_module"] = { type = "Model", model = "models/cs574/dc17m/dc17m_sniper.mdl", bone = "", rel = "dc17m", pos = Vector(0, 0, 0), angle = Angle(0, 0, 0), size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {}, active = false  },
	["sniper_module_hp1"] = { type = "Model", model = "models/squad/sf_plates/sf_plate1x1.mdl", bone = "", rel = "sniper_module", pos = Vector(-0.62, 17.175, 8.7), angle = Angle(90, -90, 0), size = Vector(0.11, 0.11, 0), color = Color(0, 200, 255, 255), surpresslightning = false, material = "cs574/scopes/dc17msniperret", skin = 0, bodygroup = {}, active = false  },
	["sniper_module_hp2"] = { type = "Model", model = "models/squad/sf_plates/sf_plate1x1.mdl", bone = "", rel = "sniper_module", pos = Vector(-0.62, 08.85, 8.7), angle = Angle(90, -90, 0), size = Vector(0.11, 0.11, 0), color = Color(0, 200, 255, 255), surpresslightning = false, material = "cs574/scopes/dc17msniperret", skin = 0, bodygroup = {}, active = false  },
	["sniper_module_scope"] = { type = "Model", model = "models/rtcircle.mdl", bone = "", rel = "sniper_module_hp2", pos = Vector(0.66, -0.66, 0), angle = Angle(90, 180, 0), size = Vector(0.33, 0.33, 0.33), color = Color(255, 255, 255, 255), surpresslightning = true, material = "!tfa_rtmaterial", skin = 0, bodygroup = {}, active = false  },
	["sniper_mag"] = { type = "Model", model = "models/cs574/dc17m/dc17m_snipermag.mdl", bone = "", rel = "dc17m", pos = Vector(0, 0, 0), angle = Angle(0, 0, 0), size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {}, active = false  },
	["dc17m_ironsight"] = { type = "Model", model = "models/cs574/dc17m/dc17m_ironsight.mdl", bone = "", rel = "dc17m", pos = Vector(0, 0, 0), angle = Angle(0, 0, 0), size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {}, active = true  },
	["dc17m_ammo"] = { type = "Quad", bone = "", rel = "dc17m", pos = Vector(0.8, 06.35, 04.175), angle = Angle(0, -270, 62.5), size = 0.0045, draw_func = nil},
	["rocket_module_scope"] = { type = "Model", model = "models/rtcircle.mdl", bone = "", rel = "rocket_module", pos = Vector(0.66, -0.66, 0), angle = Angle(90, 180, 0), size = Vector(0.33, 0.33, 0.33), color = Color(255, 255, 255, 255), surpresslightning = true, material = "!tfa_rtmaterial", skin = 0, bodygroup = {}, active = false  },
}

SWEP.WElements = {
	["dc17m"] = { type = "Model", model = "models/cs574/dc17m/dc17m_base.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(3, 1, -1.5), angle = Angle(0, -90, 165), size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {},},
	["rifle_module"] = { type = "Model", model = "models/cs574/dc17m/dc17m_rifle.mdl", bone = "", rel = "dc17m", pos = Vector(0, 0, 0), angle = Angle(0, 0, 0), size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {}, active = true  },
	["rifle_mag"] = { type = "Model", model = "models/cs574/dc17m/dc17m_mag.mdl", bone = "", rel = "dc17m", pos = Vector(0, 0, 0), angle = Angle(0, 0, 0), size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {}, active = true  },
	["rocket_module"] = { type = "Model", model = "models/cs574/dc17m/dc17m_rocket.mdl", bone = "", rel = "dc17m", pos = Vector(0, 0, 0), angle = Angle(0, 0, 0), size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {}, active = false  },
	["sniper_module"] = { type = "Model", model = "models/cs574/dc17m/dc17m_sniper.mdl", bone = "", rel = "dc17m", pos = Vector(0, 0, 0), angle = Angle(0, 0, 0), size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {}, active = false  },
	["sniper_module_hp1"] = { type = "Model", model = "models/squad/sf_plates/sf_plate1x1.mdl", bone = "", rel = "dc17m", pos = Vector(-0.62, 17.175, 8.7), angle = Angle(90, -90, 0), size = Vector(0.11, 0.11, 0), color = Color(0, 200, 255, 255), surpresslightning = false, material = "cs574/scopes/dc17msniperret", skin = 0, bodygroup = {}, active = false  },
	["sniper_module_hp2"] = { type = "Model", model = "models/squad/sf_plates/sf_plate1x1.mdl", bone = "", rel = "dc17m", pos = Vector(-0.62, 08.85, 8.7), angle = Angle(90, -90, 0), size = Vector(0.11, 0.11, 0), color = Color(0, 200, 255, 255), surpresslightning = false, material = "cs574/scopes/dc17msniperret", skin = 0, bodygroup = {}, active = false  },
	["sniper_mag"] = { type = "Model", model = "models/cs574/dc17m/dc17m_snipermag.mdl", bone = "", rel = "dc17m", pos = Vector(0, 0, 0), angle = Angle(0, 0, 0), size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {}, active = false  },
	["dc17m_ironsight"] = { type = "Model", model = "models/cs574/dc17m/dc17m_ironsight.mdl", bone = "", rel = "dc17m", pos = Vector(0, 0, 0), angle = Angle(0, 0, 0), size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {}, active = true  },
}

SWEP.HolsterOffset = Vector(11, 0, 0)
SWEP.HolsterAngle = Angle(0, -90, 0)



-- Tracer --

-- Tracer name
SWEP.TracerName 					= "rw_sw_laser_blue"


-- Magazine --

-- Ammo per Magazine
SWEP.Primary.ClipSize				= 100
-- Magazine Count
SWEP.Primary.DefaultClip			= SWEP.Primary.ClipSize * 8
-- Ammo Type
SWEP.Primary.Ammo					= "ar2"
SWEP.Secondary.Ammo			        = "smg1_grenade"
-- Ammo Consumption per shot
SWEP.Primary.AmmoConsumption 		= 1

-- Fire Modes --

-- Actual Fire Modes.
SWEP.FireModes = {
	"Auto",
	"Single"
}

-- Automatic RPM
SWEP.Primary.RPM					= 500
-- Semi Automatic Fire RPM
SWEP.Primary.RPM_Semi				= 120

-- Range --

-- Max Range of weapon
SWEP.Primary.Range 					= 4080

-- Shooting --

-- Number of bullets per shot (For Shotguns)
SWEP.Primary.NumShots				= 1
-- Damage per bullet
SWEP.Primary.Damage = 38

-- Aiming --

SWEP.data 							= {}
-- Enable Iron Sights
SWEP.data.ironsights				= 1
-- Iron Sights FOV
SWEP.Secondary.IronFOV				= 75 -- TODO

SWEP.RTScopeAttachment				= -1
SWEP.Scoped_3D 						= false
SWEP.ScopeReticule 					= "#sw/visor/sw_ret_redux_blue"
SWEP.Secondary.ScopeZoom 			= 4
SWEP.ScopeReticule_Scale 			= {1.1,1.1}
SWEP.IronSightsSensitivity		  = 0.25

SWEP.RTBGBlur = false

SWEP.Primary.Spread					= 0.014
SWEP.Primary.IronAccuracy 			= 0.002

SWEP.Primary.SpreadMultiplierMax 	= 2.5
SWEP.Primary.SpreadIncrement 		= 0.35

SWEP.ZoomLevels = {
	2,
	4,
	7,
	15,
	30
}

-- Holding Positions

-- Aiming
SWEP.IronSightsPos = Vector(-5.65, -3.2, 1.8)
SWEP.IronSightsAng = Vector(0, 0, 0)

SWEP.ScopeHoloPos = Vector(-5.65, -3.2, 1.5)
SWEP.ScopeHoloAng = Vector(0, 0, 0)

SWEP.Scope1Pos = Vector(-5.612, -15, 0.485)
SWEP.ScopeSgPos = Vector(-5.612, -8, 0.485)

-- Running
SWEP.RunSightsPos = Vector(5.226, 0, -3)
SWEP.RunSightsAng = Vector(-22, 35, -22)
-- Inspecting
SWEP.InspectPos = Vector(8, -4.8, -3)
SWEP.InspectAng = Vector(11.199, 38, 0)

-- Sounds --

-- Fire Sound
SWEP.Primary.Sound 					= Sound("w/dc17m.wav")
-- Reload Sound
SWEP.Primary.ReloadSound 			= Sound("w/reload_fast.wav")

SWEP.CurrentHeat = 0
SWEP.NextHeatThink = CurTime()
SWEP.LastHeatThink = CurTime()

DEFINE_BASECLASS( SWEP.Base )

local EntToSWEP = {
	["rw_sw_ent_nade_impact"] = "weapon_swrp_dc17m_br",

	["rw_sw_ent_nade_heal"] = "rw_sw_nade_bacta",
	["rw_sw_ent_nade_incendiary"] = "rw_sw_nade_incendiary",
	["rw_sw_ent_nade_poison"] = "rw_sw_nade_dioxis",
	["rw_sw_ent_nade_poison_stun"] = "rw_sw_nade_dioxis_stun",
	["rw_sw_ent_nade_smoke"] = "rw_sw_nade_smoke",
	["rw_sw_ent_nade_stun"] = "rw_sw_nade_stun",
	["rw_sw_ent_nade_thermal"] = "rw_sw_nade_thermal",
	["rw_sw_ent_nade_train"] = "rw_sw_nade_training",
	["rw_sw_ent_nade_flash"] = "rw_sw_nade_flash",
	["rw_sw_ent_nade_emp"] = "rw_sw_nade_emp",
}

if CLIENT then
	surface.CreateFont( "DC17mAurebesh", {font = "Aurebesh",extended = false,size = 200,weight = 0,blursize = 0,scanlines = 0,antialias = false,underline = false,italic = false,strikeout = false,symbol = false,rotary = false,shadow = false,additive = false,outline = false,})
end

function SWEP:Think(...)
	BaseClass.Think(self, ...)
	if CLIENT then
		if self:IronSights() then self.VElements["sniper_module_scope"].color = Color(255, 255, 255, 255) else self.VElements["sniper_module_scope"].color = Color(255,255,255,0) end
		if self:Clip1() > 99 then self.VElements["dc17m_ammo"].draw_func = function(weapon) draw.SimpleText("" .. weapon:Clip1(),"DC17mAurebesh",0,0,Color(0,120,180,255),TEXT_ALIGN_CENTER,TEXT_ALIGN_TOP) end end
		if self:Clip1() <= 99 then self.VElements["dc17m_ammo"].draw_func = function(weapon) draw.SimpleText("0" .. weapon:Clip1(),"DC17mAurebesh",0,0,Color(0,120,180,255),TEXT_ALIGN_CENTER,TEXT_ALIGN_TOP) end end
		if self:Clip1() <= 9 then self.VElements["dc17m_ammo"].draw_func = function(weapon) draw.SimpleText("00" .. weapon:Clip1(),"DC17mAurebesh",0,0,Color(0,120,180,255),TEXT_ALIGN_CENTER,TEXT_ALIGN_TOP) end end
		if self:Clip1() == 0 then self.VElements["dc17m_ammo"].draw_func = function(weapon) draw.SimpleText("000","DC17mAurebesh",0,0,Color(0,120,180,255),TEXT_ALIGN_CENTER,TEXT_ALIGN_TOP) end end
		if self:Clip1() == 5 then self.VElements["sniper_mag"].pos = Vector(0,0,0) end
		if self:Clip1() == 4 then self.VElements["sniper_mag"].pos = Vector(-0.72,0,0) end
		if self:Clip1() == 3 then self.VElements["sniper_mag"].pos = Vector(-1.3,0,0) end
		if self:Clip1() == 2 then self.VElements["sniper_mag"].pos = Vector(-1.87,0,0) end
		if self:Clip1() == 1 then self.VElements["sniper_mag"].pos = Vector(-2.45,0,0) end
		if self:Clip1() == 0 then self.VElements["sniper_mag"].pos = Vector(-2.9,0,0) end
	end
end

-- function SWEP:ShootBullet(...)
-- 	if self:IsAttached("swrp_dc17m_rocket") and IsFirstTimePredicted() then
-- 		if SERVER then
-- 			timer.Simple(0, function()
-- 				local ent = ents.Create("rw_sw_ent_nade_impact")
-- 				local dir
-- 				local owner = self:GetOwner()
-- 				if IsValid(owner) then
-- 					local ang = owner:EyeAngles()
-- 					rec, aimcone = self:CalculateConeRecoil()
-- 					dir = ang:Forward()
-- 					ang:RotateAroundAxis(ang:Right(), - aimcone / 2)
-- 					if !self:GetIronSights( issighting ) then
-- 						ent:SetPos(owner:GetShootPos() + ang:Forward() * 10 + ang:Right() * 13 + ang:Up() * -10)
-- 					end
-- 					if self:GetIronSights( issighting ) then
-- 						ent:SetPos(owner:GetShootPos() + ang:Forward() * 25 + ang:Right() + ang:Up() * -25)
-- 					end
-- 					ent:SetOwner(owner)
-- 					ent:Spawn()
-- 					ent:SetVelocity(dir * 1500)
-- 					local phys = ent:GetPhysicsObject()
-- 					if IsValid(phys) then
-- 						phys:SetVelocity(dir * 1500)
-- 						phys:EnableGravity( true )
-- 						phys:EnableDrag(false)
-- 					end
-- 				end
-- 			end)
-- 		end
-- 		return
-- 	end

-- 	return BaseClass.ShootBullet(self,...)
-- end

function SWEP:GetFireModeName()
	local fm = self:GetFireMode()
	local fmn = string.lower(self:GetStat("FireModes")[fm])

	if fmn == "rw_sw_ent_nade_impact" then return "Impact" end
	if fmn == "rw_sw_ent_nade_heal" then return "Bacta" end
	if fmn == "rw_sw_ent_nade_incendiary" then return "Fire" end
	if fmn == "rw_sw_ent_nade_poison" then return "Poison" end
	if fmn == "rw_sw_ent_nade_poison_stun" then return "Symoxin" end
	if fmn == "rw_sw_ent_nade_smoke" then return "Smoke" end
	if fmn == "rw_sw_ent_nade_stun" then return "Stun" end
	if fmn == "rw_sw_ent_nade_thermal" then return "Thermal" end
	if fmn == "rw_sw_ent_nade_train" then return "Training" end
	if fmn == "rw_sw_ent_nade_flash" then return "Flash" end
	if fmn == "rw_sw_ent_nade_emp" then return "EMP" end

	return BaseClass.GetFireModeName(self)
end


function SWEP:CycleFireMode()
	if self:IsAttached("swrp_dc17m_rocket") and IsFirstTimePredicted() then
		local fm = self:GetFireMode()

		local fireModes = self:GetStat("FireModes")
		local fmCount = #fireModes
		for i = 1, fmCount, 1 do
			local newFm = ((fm + i - 1) % fmCount) + 1

			local grenadeType = fireModes[newFm]
			if grenadeType == "Safe" then continue end
			local swepType = EntToSWEP[grenadeType]
			local owner = self:GetOwner()
			if owner:HasWeapon(swepType) or owner:HasWeapon("store_" .. swepType) then
				fm = newFm
				break
			end
		end

		self:SetFireMode(fm)
		local a = self:ChooseROFAnim()

		if a then
			self:SetNextPrimaryFire(CurTime() + self:GetActivityLength())
		else
			self:EmitSound("Weapon_AR2.Empty")
			self:SetNextPrimaryFire(CurTime() + math.max(self:GetFireDelay(), 0.25))
		end

		self.BurstCount = 0
		self:SetStatus(TFA.GetStatus("firemode"))
		self:SetStatusEnd(self:GetNextPrimaryFire())

		self.Primary.Automatic = self:GetStat("FireModesAutomatic." .. self:GetStat("FireModes." .. fm)) ~= nil
		return
	end

	return BaseClass.CycleFireMode(self)
end
--addons/egm_tfa_weapons/lua/weapons/weapon_swrp_dc17silenceddual.lua:
-- Written by Oninoni and Meredin

SWEP.Base                   = "weapon_swrp_egm_base"

SWEP.PrintName              = "DC-17 Dual Silenced"
SWEP.Category               = "SW:RP (Republik)"
SWEP.Type					= "Republic Blaster Pistol"
SWEP.Manufacturer           = "BlasTech Industries"
SWEP.Slot                   = 1
SWEP.SlotPos                = 0

SWEP.Spawnable = true

-- Model --

SWEP.ViewModel						= "models/strasser/weapons/c_ddeagle.mdl"
SWEP.WorldModel						= "models/bf2017/w_scoutblaster.mdl"

SWEP.VMPos = Vector(0.88, -4, -0.240)
SWEP.VMAng = Vector(0,0,0)

SWEP.HoldType 						= "duel"
SWEP.ReloadHoldTypeOverride 		= "pistol"

SWEP.UseHands 						= true

SWEP.ShowWorldModel = false

SWEP.ViewModelBoneMods = {
}

SWEP.VElements = {

	["dc17s"] = { type = "Model", model = "models/fisher/dc17s/dc17s.mdl", bone = "LeftHand_1stP", rel = "", pos = Vector(8, 3.5, -1.5), angle = Angle(82, -2, 90), size = Vector(0.85, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {[1] = 1} },
	["dc17s+"] = { type = "Model", model = "models/fisher/dc17s/dc17s.mdl", bone = "RightHand_1stP", rel = "", pos = Vector(-8, -3.5, 2), angle = Angle(98, 178, 90), size = Vector(0.85, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {[1] = 1} },
}

SWEP.WElements = {
	["dc17"] = { type = "Model", model = "models/fisher/dc17s/dc17s.mdl", bone = "ValveBiped.Bip01_L_Hand", rel = "", pos = Vector(8.8, 01.8, 2.8), angle = Angle(0, 80, 0), size = Vector(0.9, 0.9, 0.9), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["dc17s"] = { type = "Model", model = "models/fisher/dc17s/dc17s.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(8.5, 01.8, -3.2), angle = Angle(0, -97.5, 175), size = Vector(0.9, 0.9, 0.9), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
}

SWEP.Attachments = {
	[1] = { offset = { 0, 0 }, atts = { "swrp_am_training", "swrp_am_stun_lite" }, order = 1 },
}

SWEP.ProceduralHolsterPos = Vector(0,-8,-8)
SWEP.ProceduralHolsterAng = Vector(37.5,0,0)
SWEP.DoProceduralReload = true
SWEP.ProceduralReloadTime = 2.3

SWEP.Akimbo = true
SWEP.Primary.DoMuzzleFlash 			= true
SWEP.Secondary.DoMuzzleFlash 		= true
SWEP.Blowback_Shell_Enabled 		= true
SWEP.Blowback_Shell_Effect 			= "None"

-- Tracer --

-- Tracer name
SWEP.TracerName 					= "rw_sw_dual_laser_blue"


-- Magazine --

-- Ammo per Magazine
SWEP.Primary.ClipSize				= 100 * 2
-- Magazine Count
SWEP.Primary.DefaultClip			= SWEP.Primary.ClipSize * 8
-- Ammo Type
SWEP.Primary.Ammo					= "ar2"
-- Ammo Consumption per shot
SWEP.Primary.AmmoConsumption 		= 1

-- Fire Modes --

-- Actual Fire Modes.
SWEP.FireModes = {
	"Single",
}

-- Automatic RPM
SWEP.Primary.RPM					= nil
-- Semi Automatic Fire RPM
SWEP.Primary.RPM_Semi				= 300 * 1.5

-- Burst Fire RPM
SWEP.Primary.RPM_Burst				= nil
-- Delay Between Bursts
SWEP.Primary.BurstDelay				= nil

-- Range --

-- Max Range of weapon
SWEP.Primary.Range 					= 2040

-- Shooting --

-- Number of bullets per shot (For Shotguns)
SWEP.Primary.NumShots				= 1
-- Damage per bullet
SWEP.Primary.Damage = 35

-- Aiming --

SWEP.data 							= {}
-- Enable Iron Sights
SWEP.data.ironsights				= 0
-- Iron Sights FOV
SWEP.Secondary.IronFOV				= 75 -- TODO

SWEP.ScopeReticule 					= "scope/gdcw_elcanreticle"
SWEP.Secondary.ScopeZoom 			= 1
SWEP.ScopeReticule_Scale 			= {1.1,1.1}

SWEP.Primary.Spread					= 0.0075
SWEP.Primary.IronAccuracy 			= 0

SWEP.Primary.SpreadMultiplierMax 	= 4
SWEP.Primary.SpreadIncrement 		= 0.3

-- Holding Positions

-- Aiming
SWEP.IronSightsPos = Vector(0, -5, 0)
SWEP.IronSightsAng = Vector(0, 0, 0)
-- Running
SWEP.RunSightsPos = Vector(0, -7.5, -10)
SWEP.RunSightsAng = Vector(37.5, 0, 0)
-- Inspecting
SWEP.InspectPos = Vector(0, -5, -5)
SWEP.InspectAng = Vector(37.5,0,0)

-- Sounds --

-- Fire Sound
SWEP.Primary.Sound 					= Sound ("w/dc19.wav")
-- Reload Sound
SWEP.Primary.ReloadSound 			= Sound ("weapons/bf3/pistols.wav")

DEFINE_BASECLASS( SWEP.Base )

--addons/egm_tfa_weapons/lua/weapons/weapon_swrp_deathwatchdual.lua:
-- Written by Oninoni and Meredin

SWEP.Base                   = "weapon_swrp_egm_base"

SWEP.PrintName              = "Westar 35 Dual"
SWEP.Category               = "SW:RP (Event)"
SWEP.Type					= "Deathwatch Blaster Pistol"
SWEP.Manufacturer           = "Concordian Crescent Technology"
SWEP.Slot                   = 1
SWEP.SlotPos                = 0

SWEP.Spawnable = true

-- Model --

SWEP.ViewModel						= "models/strasser/weapons/c_ddeagle.mdl"
SWEP.WorldModel						= "models/bf2017/w_scoutblaster.mdl"

SWEP.VMPos = Vector(0.88, -4, -0.240)
SWEP.VMAng = Vector(0,0,0)

SWEP.HoldType 						= "duel"
SWEP.ReloadHoldTypeOverride 		= "pistol"

SWEP.UseHands 						= true

SWEP.ShowWorldModel = false

SWEP.ViewModelBoneMods = {
}

SWEP.VElements = {
	["deathwatch"] = { type = "Model", model = "models/sw_battlefront/weapons/westar_35_pistol.mdl", bone = "LeftHand_1stP", rel = "", pos = Vector(4, 2, -1), angle = Angle(80, -2, 90), size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["deathwatch+"] = { type = "Model", model = "models/sw_battlefront/weapons/westar_35_pistol.mdl", bone = "RightHand_1stP", rel = "", pos = Vector(-4, -2, 1), angle = Angle(95, 178, 90), size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}


SWEP.WElements = {
	["deathwatch"] = { type = "Model", model = "models/sw_battlefront/weapons/westar_35_pistol.mdl", bone = "ValveBiped.Bip01_L_Hand", rel = "", pos = Vector(04.2, 01.5, 1.5), angle = Angle(0, 80, 2), size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["deathwatch+"] = { type = "Model", model = "models/sw_battlefront/weapons/westar_35_pistol.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(04.2, 01.5, -1.25), angle = Angle(0, -100, 180), size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}

SWEP.ProceduralHolsterPos = Vector(0,-8,-8)
SWEP.ProceduralHolsterAng = Vector(37.5,0,0)
SWEP.DoProceduralReload = true
SWEP.ProceduralReloadTime = 2.3

SWEP.Akimbo = true
SWEP.Primary.DoMuzzleFlash 			= true
SWEP.Secondary.DoMuzzleFlash 		= true
SWEP.Blowback_Shell_Enabled 		= true
SWEP.Blowback_Shell_Effect 			= "None"
-- Tracer --

-- Tracer name
SWEP.TracerName 					= "rw_sw_dual_laser_yellow"


-- Magazine --

-- Ammo per Magazine
SWEP.Primary.ClipSize				= 100 * 2
-- Magazine Count
SWEP.Primary.DefaultClip			= SWEP.Primary.ClipSize * 8
-- Ammo Type
SWEP.Primary.Ammo					= "ar2"
-- Ammo Consumption per shot
SWEP.Primary.AmmoConsumption 		= 1

-- Fire Modes --

-- Actual Fire Modes.
SWEP.FireModes = {
	"Single",
}

-- Automatic RPM
SWEP.Primary.RPM					= nil
-- Semi Automatic Fire RPM
SWEP.Primary.RPM_Semi				= 280 * 1.5

-- Burst Fire RPM
SWEP.Primary.RPM_Burst				= nil
-- Delay Between Bursts
SWEP.Primary.BurstDelay				= nil

-- Range --

-- Max Range of weapon
SWEP.Primary.Range 					= 2040

-- Shooting --

-- Number of bullets per shot (For Shotguns)
SWEP.Primary.NumShots				= 1
-- Damage per bullet
SWEP.Primary.Damage = 28

-- Aiming --

SWEP.data 							= {}
-- Enable Iron Sights
SWEP.data.ironsights				= 0
-- Iron Sights FOV
SWEP.Secondary.IronFOV				= 75 -- TODO

SWEP.ScopeReticule 					= "scope/gdcw_elcanreticle"
SWEP.Secondary.ScopeZoom 			= 1
SWEP.ScopeReticule_Scale 			= {1.1,1.1}

SWEP.Primary.Spread					= 0.0125
SWEP.Primary.IronAccuracy 			= 0.0042

SWEP.Primary.SpreadMultiplierMax 	= 1.6
SWEP.Primary.SpreadIncrement 		= 0.3

-- Holding Positions

-- Aiming
SWEP.IronSightsPos = Vector(0, -5, 0)
SWEP.IronSightsAng = Vector(0, 0, 0)
-- Running
SWEP.RunSightsPos = Vector(0, -7.5, -10)
SWEP.RunSightsAng = Vector(37.5, 0, 0)
-- Inspecting
SWEP.InspectPos = Vector(0, -5, -5)
SWEP.InspectAng = Vector(37.5,0,0)

-- Sounds --

-- Fire Sound
SWEP.Primary.Sound 					= Sound ("weapons/dwrifle_fire.wav");
-- Reload Sound
SWEP.Primary.ReloadSound 			= Sound ("weapons/dwrifle_reload.ogg");

DEFINE_BASECLASS( SWEP.Base )
--gamemodes/starwarsrp/entities/weapons/weapon_swrp_flickzeug/shared.lua:
-- Written by Oninoni

SWEP.Base = "weapon_swrp_egm_base"

SWEP.PrintName              = "Flickzeug"
SWEP.Category               = "SW:RP (Support)"
SWEP.Type                   = "Medical Supply Equipment"
SWEP.Manufacturer           = "Bac-Tech Industries"
SWEP.Slot = 5
SWEP.SlotPos = 0

SWEP.Spawnable = true

SWEP.Purpose = "Kann durch Reperatur die Rüstung eines Soldaten wiederherstellen."
SWEP.Instructions = "Linksklick zum Reparieren der Rüstung\nRechtsklick zum Reparieren der eigenen Rüstung"

-- Model --

SWEP.ViewModel                        = "models/bf2017/c_scoutblaster.mdl"
SWEP.WorldModel                       = "models/bf2017/w_scoutblaster.mdl"

SWEP.HoldType = "slam"

SWEP.UseHands                         = true

SWEP.ShowWorldModel = false

SWEP.ViewModelBoneMods = {
	["v_scoutblaster_reference001"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, -0.3, 0), angle = Angle(0, 0, 0) }
}

SWEP.VElements = {
	["flickzeug"] = {
		type = "Model",
		model = "models/props/starwars/weapons/fusion_cutter.mdl",
		bone = "v_scoutblaster_reference001",
		rel = "",
		pos = Vector(0, 0, -5),
		angle = Angle(0, 90, 0),
		size = Vector(0.95, 0.95, 0.95),
		color = Color(255, 255, 255, 255),
		surpresslightning = false,
		material = "",
		skin = 0,
		bodygroup = {}
	}
}

SWEP.WElements = {
	["flickzeug"] = {type = "Model", model = "models/props/starwars/weapons/fusion_cutter.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(5, 4, -0.05), angle = Angle(-10, -50, 180), size = Vector(1,1,1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {}}
}

-- Enable Default Firemode, to not start secured.
SWEP.DefaultFireMode = "Normal"

-- Disable Weapon Functions --

SWEP.Primary.ClipSize = 0
SWEP.Primary.DefaultClip = 0
SWEP.Primary.Ammo = "none"

SWEP.Primary.Automatic = false
SWEP.Primary.NumShots = 0
SWEP.Primary.Damage = 0

SWEP.data = {}
SWEP.data.ironsights = 0

-- Aiming
SWEP.IronSightsPos = Vector(-4.8, -6, 1.5)
SWEP.IronSightsAng = Vector(0, 0, 0)
-- Running
SWEP.RunSightsPos = Vector(2, -9.5, -15)
SWEP.RunSightsAng = Vector(39, -0.5, -2)
-- Inspecting
SWEP.InspectPos = Vector(8, -4.8, -3)
SWEP.InspectAng = Vector(11.199, 38, 0)

SWEP.Attachments = {}

SWEP.Primary.Delay = 1.5
SWEP.ArmorRate = 40

function SWEP:GiveArmorToPlayer(ply)
	local owner = self:GetOwner()

	if IsValid(ply) and ply:IsPlayer() and ply:Alive() and owner:GetPos():Distance(ply:GetPos()) < 85 then
		local maxArmor = ply:GetMaxArmor()
		if SERVER and ply:Armor() < maxArmor then
			ply:SetArmor(math.min(ply:Armor() + self.ArmorRate, maxArmor))

			self:EmitSound("weapons/physcannon/physcannon_pickup.wav")
		end
	end
end

function SWEP:PrimaryAttack()
	if SERVER then
		if self:GetNextPrimaryFire() > CurTime() then return end

		local owner = self:GetOwner()
		if not IsValid(owner) then return end

		self:GiveArmorToPlayer(owner:GetEyeTrace().Entity)

		self:SetNextPrimaryFire(CurTime() + self.Primary.Delay)
	end
end

function SWEP:SecondaryAttack()
	if SERVER then
		if self:GetNextPrimaryFire() > CurTime() then return end

		local owner = self:GetOwner()
		if not IsValid(owner) then return end

		self:GiveArmorToPlayer(owner)

		self:SetNextPrimaryFire(CurTime() + self.Primary.Delay)
	end
end

function SWEP:Reload()
end

function SWEP:ProcessFireMode()
end

function SWEP:IronSights()
end

function SWEP:DrawHUDAmmo()
	return false
end

function SWEP:DrawHUD()
	local ply = LocalPlayer()

	if IsValid(ply) and ply:Alive() then
		local ent = ply:GetEyeTrace().Entity

		if IsValid(ent) and ent:IsPlayer() and ent:Alive() and ply:GetPos():DistToSqr(ent:GetPos()) <= 5000 then
			draw.RoundedBox(0, ScrW() / 2- 80, ScrH() / 2 + 5, 160, 60, UI.BackgroundColor)
			draw.SimpleText("Rüstung", "EGMText8", ScrW() / 2, ScrH() / 2 + 13, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)
			draw.SimpleText(ent:Armor() , "EGMText8", ScrW() / 2, ScrH() / 2 + 30, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)
		end
	end
end
--addons/egm_tfa_weapons/lua/weapons/weapon_swrp_grenadelauncher.lua:
-- Written by Mattzi

SWEP.Base                   = "weapon_swrp_egm_base"

SWEP.PrintName              = "Grenade Launcher"
SWEP.Category               = "SW:RP (Republik)"
SWEP.Type					= "Grenade Launcher"
SWEP.Manufacturer           = "BlasTech Industries"
SWEP.Slot                   = 2
SWEP.SlotPos                = 2

SWEP.Spawnable 				= true
SWEP.IsGrenadelauncher		= true

-- Model --

SWEP.ViewModel						= "models/bf2017/c_e11.mdl"
SWEP.WorldModel						= "models/bf2017/w_e11.mdl"

SWEP.VMPos = Vector(0.99, -06, -1.03)
SWEP.VMAng = Vector(0,0,0)

SWEP.HoldType 						= "smg"
SWEP.ReloadHoldTypeOverride 		= "smg"

SWEP.UseHands 						= true

SWEP.ShowWorldModel = false

SWEP.ViewModelBoneMods = {
	["v_e11_reference001"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(-3, 0, 0), angle = Angle(0, 0, 0) }
}

SWEP.VElements = {
	["pl"] = { type = "Model", model = "models/sw_battlefront/weapons/pinglauncher.mdl", bone = "v_e11_reference001", rel = "", pos = Vector(-1.8, 1.8, -5), angle = Angle(0, -90, 0), size = Vector(1.3, 1.3, 1.3), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
}

SWEP.WElements = {
	["pl"] = { type = "Model", model = "models/sw_battlefront/weapons/pinglauncher.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(2.5, 1.1, 2.8), angle = Angle(-12, 0, 180), size = Vector(1.1, 1.1, 1.1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}

SWEP.HolsterOffset = Vector(8, 0, -4)
SWEP.HolsterAngle = Angle(0, 180, 0)



-- Tracer --

-- Tracer name
SWEP.TracerName 					= "rw_sw_laser_blue"


-- Magazine --

-- Ammo per Magazine
SWEP.Primary.ClipSize				= 1
-- Magazine Count
SWEP.Primary.DefaultClip			= 1
-- Ammo Type
SWEP.Primary.Ammo					= "smg1_grenade"
-- Ammo Consumption per shot
SWEP.Primary.AmmoConsumption 		= 1

-- Fire Modes --

-- Actual Fire Modes.
SWEP.FireModes = {
	"rw_sw_ent_nade_impact",
	"rw_sw_ent_nade_heal",
	"rw_sw_ent_nade_incendiary",
	"rw_sw_ent_nade_poison",
	"rw_sw_ent_nade_poison_stun",
	"rw_sw_ent_nade_smoke",
	"rw_sw_ent_nade_stun",
	"rw_sw_ent_nade_thermal",
	"rw_sw_ent_nade_train",
	"rw_sw_ent_nade_flash",
	"rw_sw_ent_nade_emp",
}

local EntToSWEP = {
	["rw_sw_ent_nade_impact"] = "weapon_swrp_grenadelauncher",

	["rw_sw_ent_nade_heal"] = "rw_sw_nade_bacta",
	["rw_sw_ent_nade_incendiary"] = "rw_sw_nade_incendiary",
	["rw_sw_ent_nade_poison"] = "rw_sw_nade_dioxis",
	["rw_sw_ent_nade_poison_stun"] = "rw_sw_nade_dioxis_stun",
	["rw_sw_ent_nade_smoke"] = "rw_sw_nade_smoke",
	["rw_sw_ent_nade_stun"] = "rw_sw_nade_stun",
	["rw_sw_ent_nade_thermal"] = "rw_sw_nade_thermal",
	["rw_sw_ent_nade_train"] = "rw_sw_nade_training",
	["rw_sw_ent_nade_flash"] = "rw_sw_nade_flash",
	["rw_sw_ent_nade_emp"] = "rw_sw_nade_emp",
}

-- Automatic RPM
SWEP.Primary.RPM					= nil
-- Semi Automatic Fire RPM
SWEP.Primary.RPM_Semi				= 120

-- Burst Fire RPM
SWEP.Primary.RPM_Burst				= nil
-- Delay Between Bursts
SWEP.Primary.BurstDelay				= nil

-- Range --

-- Max Range of weapon
SWEP.Primary.Range 					= 80000000

-- Shooting --

-- Number of bullets per shot (For Shotguns)
SWEP.Primary.NumShots				= 1
-- Damage per bullet
SWEP.Primary.Damage = 0

-- Aiming --

SWEP.data 							= {}
-- Enable Iron Sights
SWEP.data.ironsights				= 1
-- Iron Sights FOV
SWEP.Secondary.IronFOV				= 75 -- TODO


SWEP.RTScopeAttachment				= -1
SWEP.Scoped_3D 						= false
SWEP.ScopeReticule 					= "#sw/visor/sw_ret_redux_blue"
SWEP.Secondary.ScopeZoom 			= 5
SWEP.ScopeReticule_Scale 			= {1.1,1.1}
SWEP.IronSightsSensitivity          = 0.8

SWEP.Primary.Spread					= 0.05
SWEP.Primary.IronAccuracy 			= 0.05

SWEP.Primary.SpreadMultiplierMax 	= 1
SWEP.Primary.SpreadIncrement 		= 0

SWEP.Primary.Projectile = "zeus_explosivegrenade" -- Entity to shoot

SWEP.ProjectileVelocity = 3000 --Entity to shoot's velocity

-- Holding Positions

-- Aiming
SWEP.IronSightsPos = Vector(-4.78, -5, 02.85)
SWEP.IronSightsAng = Vector(0, 0, 0)
-- Running
SWEP.RunSightsPos = Vector(5.226, -2, 0)
SWEP.RunSightsAng = Vector(-18, 36, -13.5)
-- Inspecting
SWEP.InspectPos = Vector(8, -4.8, -3)
SWEP.InspectAng = Vector(11.199, 38, 0)

-- Sounds --

-- Fire Sound
SWEP.Primary.Sound = Sound ("w/launcher.wav")
-- Reload Sound
SWEP.Primary.ReloadSound = Sound ("w/pistols.wav")

SWEP.CurrentHeat = 0
SWEP.NextHeatThink = CurTime()
SWEP.LastHeatThink = CurTime()

function SWEP:GetFireModeName()
	local fm = self:GetFireMode()
	local fmn = string.lower(self:GetStat("FireModes")[fm])

	if fmn == "rw_sw_ent_nade_impact" then return "Impact" end
	if fmn == "rw_sw_ent_nade_heal" then return "Bacta" end
	if fmn == "rw_sw_ent_nade_incendiary" then return "Fire" end
	if fmn == "rw_sw_ent_nade_poison" then return "Poison" end
	if fmn == "rw_sw_ent_nade_poison_stun" then return "Symoxin" end
	if fmn == "rw_sw_ent_nade_smoke" then return "Smoke" end
	if fmn == "rw_sw_ent_nade_stun" then return "Stun" end
	if fmn == "rw_sw_ent_nade_thermal" then return "Thermal" end
	if fmn == "rw_sw_ent_nade_train" then return "Training" end
	if fmn == "rw_sw_ent_nade_flash" then return "Flash" end
	if fmn == "rw_sw_ent_nade_emp" then return "EMP" end

	return self.BaseClass.GetFireModeName(self)
end

function SWEP:CycleFireMode()
	local fm = self:GetFireMode()

	local fireModes = self:GetStat("FireModes")
	local fmCount = #fireModes
	for i = 1, fmCount, 1 do
		local newFm = ((fm + i - 1) % fmCount) + 1

		local grenadeType = fireModes[newFm]
		if grenadeType == "Safe" then continue end
		local swepType = EntToSWEP[grenadeType]
		local owner = self:GetOwner()
		if owner:HasWeapon(swepType) or owner:HasWeapon("store_" .. swepType) then
			fm = newFm
			break
		end
	end

	self:SetFireMode(fm)
	local a = self:ChooseROFAnim()

	if a then
		self:SetNextPrimaryFire(CurTime() + self:GetActivityLength())
	else
		self:EmitSound("Weapon_AR2.Empty")
		self:SetNextPrimaryFire(CurTime() + math.max(self:GetFireDelay(), 0.25))
	end

	self.BurstCount = 0
	self:SetStatus(TFA.GetStatus("firemode"))
	self:SetStatusEnd(self:GetNextPrimaryFire())

	self.Primary.Automatic = self:GetStat("FireModesAutomatic." .. self:GetStat("FireModes." .. fm)) ~= nil
end

hook.Add("TFA_GetStat", "GrenadeLauncher.Override", function(self, stat, finalReturn)
	if self.IsGrenadelauncher then
		local fm = self:GetFireMode()

		if stat == "Primary.Projectile" then return string.lower(self:GetStat("FireModes")[fm]) end
	end
end)

DEFINE_BASECLASS( SWEP.Base )
--gamemodes/starwarsrp/entities/weapons/weapon_swrp_jedihands/shared.lua:
--[[-------------------------------------------------------------------------
SW:RP Weapon: Jedi Hands
---------------------------------------------------------------------------]]

SWEP.Author = "P4sca1 & Oninoni"
SWEP.Contact = "https://einfach-gaming.de"
SWEP.Purpose = "Eine Waffe für den SW:RP Spielmodus"
SWEP.Instructions = "Linksklick um ein Prop zu bewegen"

SWEP.Category = "SW:RP (Sonstiges)"

SWEP.PrintName = "Hände der Macht"

SWEP.Base = "weapon_base"

SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.ViewModelFOV = 50
SWEP.Slot = 3
SWEP.SlotPos = 0
SWEP.Primary.DefaultClip = 0
SWEP.Primary.ClipSize = 0

SWEP.DefaultHoldType = "magic"

SWEP.ViewModel = "models/weapons/c_arms.mdl"
SWEP.WorldModel	= ""

function SWEP:Initialize()
	self:SetHoldType(self.DefaultHoldType)
end

function SWEP:PrimaryAttack()
	if SERVER and IsFirstTimePredicted() and self:GetNextPrimaryFire() <= CurTime() then
		local owner = self:GetOwner()

		local ent = owner:GetEyeTrace().Entity

		if IsValid(ent) and !ent:IsPlayer() and ent:GetMoveType() == MOVETYPE_VPHYSICS then
			drive.PlayerStartDriving(owner, ent, "drive_jedihands")
		end

		self:SetNextPrimaryFire(CurTime() + 1)
	end
end

function SWEP:SecondaryAttack()
end

function SWEP:Reload()
end

function SWEP:DrawWorldModel()
end
--gamemodes/starwarsrp/entities/weapons/weapon_swrp_pad_blanko/shared.lua:
--[[-------------------------------------------------------------------------
SW:RP Weapon: Education Datapad
---------------------------------------------------------------------------]]

SWEP.Author = "Summe"
SWEP.Contact = "https://einfach-gaming.de"
SWEP.Purpose = "Startet die Ausbildung"
SWEP.Instructions = "Linksklick/Rechtsklick zum Benutzen"

SWEP.Category = "SW:RP (Datapads)"

SWEP.PrintName = "Education Datapad"

SWEP.Base = "weapon_swrp_egm_base"

SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.ViewModelFOV = 60
SWEP.Slot = 4
SWEP.SlotPos = 0

SWEP.HoldType = "slam"
SWEP.UseHands = true


SWEP.Primary.Automatic = false
SWEP.Primary.Delay = 0.8

SWEP.DefaultFireMode = "Normal"

SWEP.ViewModel = "models/weapons/c_bugbait.mdl"
SWEP.WorldModel = "models/weapons/w_datapad.mdl"

function SWEP:PreDrawViewModel()
	render.SetBlend(0)
end

if CLIENT then
	local swep_cooldown = false
end

SWEP.VElements = {
	["element_scope"] = { 
		type = "Model", 
		model = "models/weapons/w_datapad.mdl", 
		bone = "ValveBiped.Bip01_R_Hand", 
		rel = "", 
		pos = Vector(1, 4, 1), 
		angle = Angle(-160, -160, -45), 
		size = Vector(1.2, 1.2, 1.2), 
		color = Color(255, 255, 255, 255), 
		surpresslightning = false, 
		material = "", 
		skin = 0, 
		bodygroup = {} 
	}
}

SWEP.Info = {}

if CLIENT then
	SWEP.WepSelectIcon = surface.GetTextureID("hud/killicons/pad")
end

function SWEP:GetTrace()
	local tracedata = {}
	local ShootPos = self.Owner:GetShootPos()
	local AimVector = self.Owner:GetAimVector()
	tracedata.start = ShootPos
	tracedata.endpos = ShootPos + AimVector * self.Primary.Range
	tracedata.filter = self.Owner
	return util.TraceLine(tracedata)
end

function SWEP:PrimaryAttack()
	if CLIENT then
		if swep_cooldown == true then
		
		else
			swep_cooldown = true
			Education:OpenTutorial()
			timer.Simple(2, function() swep_cooldown = false end)
		end
	end
end

function SWEP:SecondaryAttack()
end

function SWEP:Reload()
end

function SWEP:ProcessFireMode()
end
function SWEP:IronSights()
end
function SWEP:DrawHUDAmmo()
	return false
end
--addons/shieldgenerator/lua/weapons/weapon_swrp_portable_shield.lua:

SWEP.Category = "SW:RP (Sonstiges)"

SWEP.PrintName = "Mobiler Schildgenerator"

SWEP.Author = "Mattzi & Summe"
SWEP.Contact = "https://einfach-gaming.de"
SWEP.Purpose = "Platzierbarer Squad-Schildgenerator schützt vor Blasterschüssen."
SWEP.Instructions = "Linksklick zum platzieren des Generators"

SWEP.Base = "weapon_swrp_egm_base"


SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.ViewModelFOV = 70
SWEP.Slot = 3
SWEP.SlotPos = 0

SWEP.HoldType = "slam"

SWEP.Scope = true
SWEP.ScopeFOV = 20

SWEP.ViewModel = "models/shells/pellet.mdl"
SWEP.WorldModel = "models/shells/pellet.mdl"
SWEP.DrawViewModel = false
SWEP.ShowWorldModel = false
SWEP.DrawAmmo = false

function SWEP:PreDrawViewModel()
	render.SetBlend(0)
end

SWEP.Primary.Ammo = "none"

SWEP.Primary.Automatic = false
SWEP.Primary.Delay = 1.5
SWEP.Primary.NumShots = 0
SWEP.Primary.Damage = 0

SWEP.Primary.Cone = 0.15
SWEP.Primary.Recoil = 0

SWEP.data = {}
SWEP.data.ironsights				= 0

SWEP.ArmorRate = 40

SWEP.SprintSafePos = Vector(0, 0, 0)
SWEP.SprintSafeAng = Angle(0, 0, 0)

SWEP.InspectPos = Vector(0, 0, 0)
SWEP.InspectAng = Angle(0, 0, 0)

SWEP.Info = {}

SWEP.VElements = {
	["carte"] = {
		type = "Model",
		model = "models/lordtrilobite/starwars/props/hyperfuelbarrel01.mdl",
		bone = "v_scoutblaster_reference001",
		rel = "",
		pos = Vector(20, 20, 10),
		angle = Angle(0, 180, 90),
		size = Vector(0.5, 0.5, 0.5),
		color = Color(255, 255, 255, 255),
		surpresslightning = false,
		material = "",
		skin = 0,
		bodygroup = {}
	},
}

SWEP.WElements = {
	["carte"] = {
		type = "Model",
		model = "models/lordtrilobite/starwars/props/hyperfuelbarrel01.mdl",
		bone = "ValveBiped.Bip01_R_Hand",
		rel = "",
		pos = Vector(5, 7, 10),
		angle = Angle(180, -05, -4),
		size = Vector(0.6, 0.6, 0.6),
		color = Color(255, 255, 255, 255),
		surpresslightning = false,
		material = "",
		skin = 0,
		bodygroup = {} }
}

SWEP.HolsterOffset = Vector(-1, 0, 5)
SWEP.HolsterAngle = Angle(90, 0, 0)

function SWEP:SpawnShieldGen()
	--if self:GetOwner():GetNWBool("shieldgenerator_cooldown") == false then

	local cd_time = math.Round(self.Owner:GetNWInt('swrp_shieldgen_cd') - CurTime(), 0)

	if self.Owner:GetNWInt('swrp_shieldgen_cd') ~= 0 and CurTime() < self.Owner:GetNWInt('swrp_shieldgen_cd') then
	 Notify:Info(self.Owner,"Bitte warte", "Dein Schildgenerator lädt noch ".. cd_time.." Sekunden auf!")
	return end
		local trace = self:GetOwner():GetEyeTrace()
		if trace.Hit then
			local endpos = trace.HitPos
			local distance = self:GetOwner():GetPos():DistToSqr(endpos)

			if distance <= 40000 then
				local shieldgenerator = ents.Create("portable_shield_gen")
				if IsValid(shieldgenerator) then
					shieldgenerator:SetPos(endpos + Vector(0, 0, 8))
					shieldgenerator:Spawn()
					shieldgenerator:Activate()
					shieldgenerator.owner = self:GetOwner()

					self:GetOwner():StripWeapon("weapon_swrp_portable_shield")
				end
			end
		end
	--else
	 --   print("Bitte warte noch")
	--end
end

function SWEP:PrimaryAttack()
	if self:GetNextPrimaryFire() > CurTime() and !IsValid(self.Owner) then return end

	if SERVER then
		self:SpawnShieldGen()
	end

	self:SetNextPrimaryFire(CurTime() + self.Primary.Delay)
end

function SWEP:SecondaryAttack()
	if self:GetNextPrimaryFire() > CurTime() and !IsValid(self.Owner) then return end

	if SERVER then
		self:SpawnShieldGen()
	end

	self:SetNextPrimaryFire(CurTime() + self.Primary.Delay)
end

function SWEP:Reload()
end

hook.Add('HUDPaint','ShieldGen_Hud',function()
	--[[

		local swep = LocalPlayer():GetActiveWeapon()
		if swep:IsValid() and swep:GetClass() == "weapon_swrp_portable_shield" then
			local cooldown = LocalPlayer():GetNWInt('swrp_shieldgen_cd',CurTime())-CurTime()
				draw.RoundedBox(5, ScrW() * 0.90, ScrH() * 1.03 - ScrW() * 0.1, ScrH() * 0.1, ScrW() * 0.03, GetColor("darkgray", 200))
				draw.DrawText("Status", "EGMText8", ScrW() * 0.928, ScrH() * 1.03 - ScrW() * 0.1, Color(255,255,255,255), TEXT_ALIGN_CENTER)

				if cooldown <= 1000 and cooldown > 0 then
					draw.DrawText(math.Round(cooldown,0).." Sek", "EGMText8", ScrW() * 0.928, ScrH() * 1.055 - ScrW() * 0.1, Color(0, 144, 201,255), TEXT_ALIGN_CENTER)
				else
					draw.DrawText("Bereit", "EGMText8", ScrW() * 0.928, ScrH() * 1.055 - ScrW() * 0.1, Color(0, 201, 64,255), TEXT_ALIGN_CENTER)
				end
		end

		]]
end)
--addons/egm_tfa_weapons/lua/weapons/weapon_swrp_pulserifle.lua:
-- Written by Oninoni and Meredin

SWEP.Base					= "weapon_swrp_egm_3dscoped_base"

SWEP.PrintName				= "Pulse Rifle"
SWEP.Category               = "SW:RP (Event)"
SWEP.Type					= "Beskar Steel Factory"
SWEP.Manufacturer 			= "Handmade"
SWEP.Slot                   = 0
SWEP.SlotPos                = 0

SWEP.Spawnable = true
SWEP.AdminOnly = false

-- Model --

SWEP.ViewModel						= "models/weapons/synbf3/c_dlt19.mdl"
SWEP.WorldModel						= "models/weapons/synbf3/w_dlt19.mdl"
SWEP.ViewModelFOV					= 65

SWEP.VMPos = Vector(3.03, -2, -01.944)
SWEP.VMAng = Vector(0, 0, 0)

SWEP.HoldType 						= "ar2"
SWEP.ReloadHoldTypeOverride 		= "ar2"

SWEP.UseHands 						= true

SWEP.ShowWorldModel = false

SWEP.ViewModelBoneMods = {
	["v_dlt19_reference001"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) }
}

SWEP.VElements = {
	["tcr"] = { type = "Model", model = "models/weapons/twcustom/mando_sniper/mando_sniper.mdl", bone = "v_dlt19_reference001", rel = "", pos = Vector(0, 14, -3), angle = Angle(0, -90, 0), size = Vector(1.2, 1.1, 1.2), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["scope"] = { type = "Model", model = "models/rtcircle.mdl", bone = "v_dlt19_reference001", rel = "tcr", pos = Vector(-8.4, -1.23, 7.58), angle = Angle(0, 180, 0), size = Vector(0.18, 0.18, 0.18), color = Color(255, 255, 255, 255), surpresslightning = false, material = "!tfa_rtmaterial", skin = 0, bodygroup = {} },
}

SWEP.WElements = {
	["tcr"] = { type = "Model", model = "models/weapons/twcustom/mando_sniper/mando_sniper.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(14, 0.4, 0), angle = Angle(-12, 0, 172), size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}

SWEP.HolsterOffset = Vector(2, -0.2, -3)
SWEP.HolsterAngle = Angle(0, 180, 0)



-- Tracer --

-- Tracer name
SWEP.TracerName 					= "rw_sw_laser_yellow"


-- Magazine --

-- Ammo per Magazine
SWEP.Primary.ClipSize				= 60
-- Magazine Count
SWEP.Primary.DefaultClip			= SWEP.Primary.ClipSize * 10
-- Ammo Type
SWEP.Primary.Ammo					= "ar2"
-- Ammo Consumption per shot
SWEP.Primary.AmmoConsumption 		= 20

-- Fire Modes --

-- Actual Fire Modes.
SWEP.FireModes = {
	"Single",
}

-- Automatic RPM
SWEP.Primary.RPM					= nil
-- Semi Automatic Fire RPM
SWEP.Primary.RPM_Semi				= 120

-- Burst Fire RPM
SWEP.Primary.RPM_Burst				= nil
-- Delay Between Bursts
SWEP.Primary.BurstDelay				= nil

-- Range --

-- Max Range of weapon
SWEP.Primary.Range 					= 8000

-- Shooting --

-- Number of bullets per shot (For Shotguns)
SWEP.Primary.NumShots				= 1
-- Damage per bullet
SWEP.Primary.Damage = 150


-- Aiming --

SWEP.data 							= {}
-- Enable Iron Sights
SWEP.data.ironsights				= 1
-- Iron Sights FOV
SWEP.Secondary.IronFOV				= 75 -- TODO

SWEP.RTScopeAttachment				= -1
SWEP.Scoped_3D 						= false
SWEP.ScopeReticule 					= "#sw/visor/sw_ret_redux_yellow"
SWEP.Secondary.ScopeZoom 			= 4
SWEP.ScopeReticule_Scale 			= {1,1}
SWEP.IronSightsSensitivity          = 0.25

SWEP.Primary.Spread					= 0.2
SWEP.Primary.IronAccuracy 			= 0.0005

SWEP.Primary.SpreadMultiplierMax 	= 5
SWEP.Primary.SpreadIncrement 		= 1

SWEP.ZoomLevels = {
	2,
	4,
	7,
	15,
	30
}

-- Holding Positions

-- Aiming
SWEP.IronSightsPos = Vector(-5.46, -10, 3.5)
SWEP.IronSightsAng = Vector(0, 0, 0)
-- Running
SWEP.RunSightsPos = Vector(5.226, -2, 0)
SWEP.RunSightsAng = Vector(-18, 36, -13.5)
-- Inspecting
SWEP.InspectPos = Vector(8, -4.8, -3)
SWEP.InspectAng = Vector(11.199, 38, 0)

-- Sounds --

-- Fire Sound
SWEP.Primary.Sound 					= Sound ("w/dt29-3.wav");
-- Reload Sound
SWEP.Primary.ReloadSound 			= Sound ("w/heavy.wav");

if surface then
	SWEP.Secondary.ScopeTable = {
		["ScopeMaterial"] =  Material("#sw/visor/sw_ret_redux_yellow.png", "smooth"),
		["ScopeBorder"] = color_black,
		["ScopeCrosshair"] = { ["r"] = 0, ["g"]  = 0, ["b"] = 0, ["a"] = 0, ["s"] = 1 }
	}
end


DEFINE_BASECLASS( SWEP.Base )
--addons/lvs_base/lua/weapons/weapon_swrp_rps6.lua:
SWEP.Base = "tfa_3dscoped_base"
SWEP.Author = "ChanceSphere574"
SWEP.Contact = ""
SWEP.Spawnable = true
SWEP.DrawCrosshair = true
SWEP.PrintName = "RPS-6"
SWEP.Slot = 2
SWEP.SlotPos = 100
SWEP.DrawAmmo = true

SWEP.ViewModel = "models/bf2017/c_dlt19.mdl"
SWEP.WorldModel = "models/bf2017/w_dlt19.mdl"
SWEP.ViewModelFOV = 50
SWEP.ViewModelFlip = false

SWEP.Category = "SW:RP (Republik)"
SWEP.Manufacturer = "Baktoid Armor Workshop"
SWEP.AdminSpawnable = true
SWEP.Type = "Republikanischer Raketenwerfer"
SWEP.data = {}
SWEP.data.ironsights = 1
SWEP.Secondary.IronFOV = 75
SWEP.DoMuzzleFlash = true
SWEP.SelectiveFire = true
SWEP.DisableChambering = true
SWEP.Primary.ClipSize = 1
SWEP.Primary.DefaultClip = SWEP.Primary.ClipSize * 8
SWEP.Primary.RPM = 120
SWEP.Primary.Ammo = "rpg_round"
SWEP.Primary.AmmoConsumption = 1
SWEP.Primary.Range = 30000
SWEP.Primary.RangeFalloff = -1
SWEP.Primary.NumShots = 1
SWEP.Primary.Automatic = false
SWEP.Primary.BurstDelay = 0.2
SWEP.Primary.Sound = Sound("weapons/rps6_fire.mp3")
SWEP.Primary.ReloadSound = Sound("weapons/rps6_reload.wav")
SWEP.Primary.Damage = 9000

SWEP.Primary.RangeFalloffLUT = {
	bezier = false,
	range_func = "quintic",
	units = "meters",
	lut = {
		{
			range = 30000 / 52.495,
			damage = 1
		},
		{
			range = (30000 + 50) / 52.495,
			damage = 0
		},
	}
}

SWEP.DoMuzzleFlash = false

SWEP.FireModes = {"Single"}
SWEP.AutoSwitchFrom = false
SWEP.AutoSwitchTo = false
SWEP.DefaultFireMode = "Safe"

SWEP.IronRecoilMultiplier = 0.5
SWEP.CrouchRecoilMultiplier = 0.25
SWEP.JumpRecoilMultiplier = 1.3
SWEP.WallRecoilMultiplier = 1.1
SWEP.ChangeStateRecoilMultiplier = 1.3
SWEP.CrouchAccuracyMultiplier = 0.81
SWEP.ChangeStateAccuracyMultiplier = 1.18
SWEP.JumpAccuracyMultiplier = 2
SWEP.WalkAccuracyMultiplier = 1.18
SWEP.NearWallTime = 0.25
SWEP.ToCrouchTime = 0.25
SWEP.WeaponLength = 35
SWEP.SprintFOVOffset = 12
SWEP.ProjectileVelocity = 8
SWEP.ProjectileEntity = "ent_rw_rocket_mods"
SWEP.UseHands = false
SWEP.HoldType = "rpg"
SWEP.ReloadHoldTypeOverride = "rpg"
SWEP.ShowWorldModel = false
SWEP.Tracer = 0
SWEP.TracerName = nil
SWEP.TracerCount = 1
SWEP.TracerLua = false
SWEP.TracerDelay = 0.01
SWEP.ImpactDecal = "FadingScorch"
SWEP.VMPos = Vector(2, 1, -2)
SWEP.VMAng = Vector(0, 0, 0)
SWEP.IronSightTime = 0.7
SWEP.Primary.KickUp = 0.35
SWEP.Primary.KickDown = 0.30
SWEP.Primary.KickHorizontal = 0.30
SWEP.Primary.StaticRecoilFactor = 1.2
SWEP.Primary.Spread = 0.01
SWEP.Primary.IronAccuracy = 0.005
SWEP.Primary.SpreadMultiplierMax = 2.5
SWEP.Primary.SpreadIncrement = 0.22
SWEP.Primary.SpreadRecovery = 0.8
SWEP.MoveSpeed = 0.7
SWEP.IronSightsMoveSpeed = 0.75
SWEP.IronSightsPos = Vector(-1.48, -8.5, 1)
SWEP.IronSightsAng = Vector(0, 0, 0)
SWEP.RunSightsPos = Vector(0.0, 0, 07)
SWEP.RunSightsAng = Vector(-40, 0, 0)
SWEP.InspectPos = Vector(8, 4.8, -3)
SWEP.InspectAng = Vector(11.199, 38, 0)
SWEP.ProceduralHolsterPos = Vector(0, 0, 7)
SWEP.ProceduralHolsterAng = Vector(-40, 0, 0)
SWEP.DoProceduralReload = true
SWEP.ProceduralReloadTime = 3.5

SWEP.ViewModelBoneMods = {
	["v_dlt19_reference001"] = {
		scale = Vector(0.009, 0.009, 0.009),
		pos = Vector(0, 0, 1),
		angle = Angle(0, 0, 0)
	}
}

SWEP.VElements = {
	["rocketlauncher"] = {
		type = "Model",
		model = "models/rps6/Zl_RPS-6.mdl",
		bone = "v_dlt19_reference001",
		rel = "",
		pos = Vector(1, -7, 3),
		angle = Angle(0, -90, -90),
		size = Vector(1.25, 1.25, 1.25),
		color = Color(255, 255, 255, 255),
		surpresslightning = false,
		material = "",
		skin = 0,
		bodygroup = {}
	},
	["scope"] = {
		type = "Model",
		model = "models/rtcircle.mdl",
		bone = "v_dlt19_reference001",
		rel = "",
		pos = Vector(4.19, 3.8, 6.158),
		angle = Angle(0, 90, 0),
		size = Vector(0.22, 0.22, 0.22),
		color = Color(255, 255, 255, 255),
		surpresslightning = false,
		material = "!tfa_rtmaterial",
		skin = 0,
		bodygroup = {}
	},
}

SWEP.WElements = {
	["rocketlauncher"] = {
		type = "Model",
		model = "models/rps6/Zl_RPS-6.mdl",
		bone = "ValveBiped.Bip01_R_Hand",
		rel = "",
		pos = Vector(-6, 2, -3.5),
		angle = Angle(-7, 0, 90),
		size = Vector(1.5, 1.5, 1.5),
		color = Color(255, 255, 255, 255),
		surpresslightning = false,
		material = "",
		skin = 0,
		bodygroup = {}
	},
}

SWEP.HolsterOffset = Vector(4, 0, 0)
SWEP.HolsterAngle = Angle(0, 180, -90)

SWEP.LuaShellEject = false
SWEP.LuaShellEffect = ""
SWEP.ThirdPersonReloadDisable = false
SWEP.Primary.DamageType = DMG_BULLET
SWEP.DamageType = DMG_BULLET
SWEP.RTScopeAttachment = -1
SWEP.Scoped_3D = true
SWEP.ScopeReticule = "#sw/visor/sw_ret_redux_blue"
SWEP.Secondary.ScopeZoom = 2

SWEP.ScopeReticule_Scale = {1.05, 1.05}

if surface then
	SWEP.Secondary.ScopeTable = nil
end

SWEP.Attachments = {
	[1] = {
		header = "Modes",
		atts = {"rocket_mod_pointing", "rocket_mod_tracking", "rocket_mod_control"}
	},
}

DEFINE_BASECLASS(SWEP.Base)
SWEP.trackedent = nil
SWEP.tracktime = 0
SWEP.cld = 0
SWEP.cld2 = 0

if CLIENT then
	surface.CreateFont("Test", {
		font = "Aurebesh",
		extended = false,
		size = 200,
		weight = 0,
		blursize = 0,
		scanlines = 0,
		antialias = false,
		underline = false,
		italic = false,
		strikeout = false,
		symbol = false,
		rotary = false,
		shadow = false,
		additive = false,
		outline = false,
	})
end

function SWEP:ProcessFireMode()
	if self:OwnerIsValid() and self:GetStatus() == TFA.Enum.STATUS_IDLE and (SERVER or not sp) then
		if self:GetOwner():KeyPressed(IN_USE) and self:GetOwner():KeyDown(IN_SPEED) then
			self:CycleSafety()
			return
		end

		if self:GetOwner():KeyPressed(IN_RELOAD) and not self:GetOwner():KeyDown(IN_SPEED) and self:GetOwner():KeyDown(IN_USE) then
			self:CycleFireMode()
			return
		end
	end
end

function SWEP:Think(...)
	BaseClass.Think(self, ...)

	if self:Clip1() > 0 then
		if not self:IsAttached("rocket_mod_tracking") then return end
		if CurTime() < self.cld then return end

		if IsValid(self.trackedent) then
			local ent = self.trackedent
			local ownerang = self:GetOwner():GetAngles()
			local data = (ent:GetPos() - self:EyePos()):Angle()
			local dify = math.AngleDifference(ownerang.y, data.y)

			if dify < 0 then
				dify = -dify
			end

			if dify > 5 then
				self.trackedent = nil
				self.tracktime = 0

				return
			end

			local difp = math.AngleDifference(ownerang.p, data.p)

			if difp < 0 then
				difp = -difp
			end

			if difp > 5 then
				self.trackedent = nil
				self.tracktime = 0

				return
			end

			self.tracktime = self.tracktime + 1
			self.cld = CurTime() + 1
		else
			self.tracktime = 0
			self.trackedent = NULL

			for k, v in pairs(ents.GetAll()) do
				if not v:IsPlayer() and not v:IsNPC() and not v:IsVehicle() and not v.LVS then continue end
				if v == self:GetOwner() then continue end
				local ownerang = self:GetOwner():GetAngles()
				local data = (v:GetPos() - self:EyePos()):Angle()
				local dify = math.AngleDifference(ownerang.y, data.y)

				if dify < 0 then
					dify = -dify
				end

				if dify > 5 then continue end
				local difp = math.AngleDifference(ownerang.p, data.p)

				if difp < 0 then
					difp = -difp
				end

				if difp > 5 then continue end
				self.trackedent = v
			end
		end
	else
		timer.Simple(0, function()
			if not IsValid(self) then return end
			self.tracktime = 0
			self.trackedent = nil
		end)
	end

	if not CLIENT then return end

	if self.tracktime >= 3 then
		self:EmitSound("w/rocket/rocket_lock_confirmed.wav", 75, 100, 1, CHAN_AUTO)
	elseif self.tracktime == 2 then
		self:EmitSound("w/rocket/rocket_lock_start.wav", 75, 100, 1, CHAN_AUTO)
	elseif self.tracktime == 1 then
		self:EmitSound("w/rocket/rocket_lock_start.wav", 75, 100, 1, CHAN_AUTO)
	end
end

function SWEP:DrawHUD()
	BaseClass.DrawHUD(self)

	if self:IsAttached("rocket_mod_tracking") then
		local target = self.trackedent

		if IsValid(target) then
			local pos = (target:GetPos() + target:OBBCenter()):ToScreen()
			local w = ScrW() / 40

			if self.tracktime >= 3 then
				surface.SetDrawColor(255, 0, 0)
			elseif self.tracktime >= 2 then
				surface.SetDrawColor(255, 255, 0)
			elseif self.tracktime >= 1 then
				surface.SetDrawColor(0, 255, 0)
			end

			surface.DrawOutlinedRect(pos.x - (w / 2), pos.y - (w / 2), w, w)
		end
	end
end

function SWEP:CanPrimaryAttack()
	local self2 = self:GetTable()
	stat = self:GetStatus()

	if not TFA.Enum.ReadyStatus[stat] and stat ~= TFA.Enum.STATUS_SHOOTING then
		if self2.Shotgun and TFA.Enum.ReloadStatus[stat] then
			self:SetReloadLoopCancel(true)
		end

		return false
	end

	if self:IsSafety() then
		if IsFirstTimePredicted() then
			self:EmitSound(self:GetStat("Primary.Sound_DrySafety"))
		end

		if CurTime() < self:GetLastSafetyShoot() + 0.2 then
			self:CycleSafety()
		end

		self:SetLastSafetyShoot(CurTime() + 0.2)

		return
	end

	if not self:GetOwner():Crouching() then return false end
	if self:GetStat("Primary.ClipSize") <= 0 and self:Ammo1() < self:GetStat("Primary.AmmoConsumption") then return false end

	if self:GetPrimaryClipSize(true) > 0 and self:Clip1() < self:GetStat("Primary.AmmoConsumption") then
		if not self2.HasPlayedEmptyClick then
			self2.HasPlayedEmptyClick = true

			if self:GetOwner():IsNPC() or self:KeyPressed(IN_ATTACK) then
				local enabled, tanim, ttype = self:ChooseDryFireAnim()

				if enabled then
					self:SetNextPrimaryFire(CurTime() + self:GetStat("Primary.DryFireDelay", self:GetActivityLength(tanim, true, ttype)))

					return false
				end
			end

			self:EmitSound(self:GetStat("Primary.Sound_DryFire"))
		end

		return false
	end

	if self2.FiresUnderwater == false and self:GetOwner():WaterLevel() >= 3 then
		self:SetNextPrimaryFire(CurTime() + 0.5)
		self:EmitSound(self:GetStat("Primary.Sound_Blocked"))

		return false
	end

	self2.HasPlayedEmptyClick = false
	if CurTime() < self:GetNextPrimaryFire() then return false end

	return true
end


function SWEP:SecondaryAttack()
	if not CLIENT then return end
	local ent = self:GetNWEntity("control_rocket")
	if not IsValid(ent) then return end

	if hook.GetTable()["CalcView"]["Joe_CalcView"] then
		hook.Remove("CalcView", "Joe_CalcView")
	else
		hook.Add("CalcView", "Joe_CalcView", function(ply, pos, angles, fov)
			if not IsValid(ent) or not ply:Alive() or not IsValid(self) then
				hook.Remove("CalcView", "Joe_CalcView")

				return
			end

			local view = {
				origin = ent:GetPos() + (self:GetForward() * 8) + (self:GetUp() * 0),
				angles = ent:GetAngles(),
				fov = fov,
				drawviewer = true
			}

			return view
		end)
	end
end

function SWEP:ShootBullet(...)
	if IsFirstTimePredicted() then
		if SERVER then
			timer.Simple(0, function()
				local ent = ents.Create("ent_rw_rocket_mods")
				ent.Owner = self:GetOwner()
				ent.RocketDamage = self.Primary.Damage

				if self:IsAttached("rocket_mod_tracking") and self.trackedent and self.tracktime >= 3 then
					ent.trackingmode = "track"
					ent.trackedent = self.trackedent
					self.tracktime = 0
					self.trackedent = nil
				end

				if self:IsAttached("rocket_mod_pointing") then
					ent.trackingmode = "point"
				end

				if self:IsAttached("rocket_mod_control") then
					ent.trackingmode = "control"
					self:SetNWEntity("control_rocket", ent)
				end

				local ang = self:GetOwner():EyeAngles()
				ent:SetPos(self:GetOwner():GetShootPos() + ang:Forward() * 25 + ang:Right() * 10 + ang:Up() * -2)
				ent:SetAngles(ang)
				ent:Spawn()
			end)
		end

		return
	end

	return BaseClass.ShootBullet(self, ...)
end
--addons/egm_tfa_weapons/lua/weapons/weapon_swrp_verpinengewehr_dissolve.lua:
-- Written by Oninoni and Meredin

SWEP.Base                   = "weapon_swrp_verpinengewehr"

SWEP.PrintName              = "Verpinengewehr Disruptor"
SWEP.Category               = "SW:RP (Event)"
SWEP.Type					= "Sniper Rifle"
SWEP.Manufacturer           = "Verpine Industries"
SWEP.Slot                   = 0
SWEP.SlotPos                = 0

SWEP.Spawnable = true
SWEP.AdminOnly = true


-- Let the target be dissolved after killing
SWEP.Primary.DamageType             = DMG_DISSOLVE
SWEP.DamageType                     = DMG_DISSOLVE

-- Ammo per Magazine
SWEP.Primary.ClipSize				= 200
SWEP.Primary.DefaultClip			= SWEP.Primary.ClipSize * 5
SWEP.Primary.AmmoConsumption 		= 200

SWEP.Primary.Damage					= 300

SWEP.Attachments = {
	[1] = { offset = { 0, 0 }, atts = { "nil" }, order = 0 },
	[2] = { offset = { 0, 0 }, atts = { "nil" }, order = 0 },
}

DEFINE_BASECLASS( SWEP.Base )
--addons/tracking_device_egm/lua/weapons/weapon_trackingdevice_funk/shared.lua:
AddCSLuaFile()
SWEP.PrintName = "Tracking Device (Funk)"
SWEP.Author =	"Joe/Sven"

SWEP.Spawnable =	true
SWEP.Adminspawnable = false
SWEP.Category = "Joe"

SWEP.Primary.Clipsize =	-1
SWEP.Primary.DefaultClip =	-1
SWEP.Primary.Automatic =	false
SWEP.Primary.Ammo =	"none"

SWEP.Secondary.Clipsize =	-1
SWEP.Secondary.DefaultClip =	-1
SWEP.Secondary.Automatic =	false
SWEP.Secondary.Ammo =	"none"
SWEP.UseHands = true

SWEP.HoldType = "slam"
SWEP.ViewModelFOV = 55
SWEP.ViewModelFlip = false
SWEP.ViewModel = "models/2rek/thejoe/sw_tracker_1_vm.mdl"
SWEP.WorldModel = "models/2rek/thejoe/sw_tracker_1_prop.mdl"
SWEP.DrawCrosshair = false

function SWEP:SetupDataTables()
	self:NetworkVar("Bool", 0, "FoundTarget")
	self:NetworkVar("Vector", 0, "TrackedPosition")
end

function SWEP:PrimaryAttack()
	if SERVER then self:SetNextPrimaryFire(CurTime() + 2) end
	if not IsFirstTimePredicted() then return end

	if CLIENT then
		self:DrawGUI()
	end
end

function SWEP:SecondaryAttack()
	if CLIENT then return end

	self:SetNextSecondaryFire(CurTime() + 2)
	local owner = self:GetOwner()
	if IsValid(self.TrackerTarget)  then
		owner:ChatPrint("Du trackst gerade: " .. self.TrackerTarget:GetCurrentCharacterFullName())
	else
		owner:ChatPrint( "Du trackst noch niemanden ")
	end
end

if CLIENT then
	function SWEP:DrawGUI()
		local owner = self:GetOwner()

		local frame = vgui.Create("DFrame")
		frame:SetPos(500, 100)
		frame:SetSize(900, 900)
		frame:MakePopup()
		frame:ShowCloseButton(true)
		frame:SetTitle("Wähle ein Ziel aus")
		frame.Paint = function(_, w, h)
			draw.RoundedBox(0,0,0,w,h,Color(0,0,0,200))
		end

		local playerList = vgui.Create("DListView", frame)
		playerList:Dock( FILL )
		playerList:SetMultiSelect( false )
		playerList:AddColumn( "Spieler" )
		playerList:SetVisible(true)

		for _, ply in pairs(player.GetAll()) do
			if ply == owner then continue end

			local line = playerList:AddLine(ply:GetCurrentCharacterFullName())
			line.Player = ply
		end

		function playerList:DoDoubleClick( lineID, line )
			net.Start("Tracker_Funk.TargetEntity")
				net.WriteEntity(line.Player)
			net.SendToServer()

			frame:Close()
			owner:ChatPrint( "Du trackst jetzt: " .. line.Player:GetCurrentCharacterFullName() )
		end
	end
end

function SWEP:Initialize()
	self:SetHoldType(self.HoldType)
	self:SetFoundTarget(false)
end

function SWEP:Holster()
	return true
end

function SWEP:Think()
end

if CLIENT then
	local WorldModel = ClientsideModel(SWEP.WorldModel)
	WorldModel:SetSkin(1)
	WorldModel:SetNoDraw(true)
	function SWEP:DrawWorldModel()
		local _Owner = self:GetOwner()
		if (IsValid(_Owner)) then
			local offsetVec = Vector(3.2, -0.8, -0.5)
			local offsetAng = Angle(0, 10, 100)
			local boneid = _Owner:LookupBone("ValveBiped.Bip01_R_Hand") -- Right Hand
			if not boneid then return end
			local matrix = _Owner:GetBoneMatrix(boneid)
			if not matrix then return end
			local newPos, newAng = LocalToWorld(offsetVec, offsetAng, matrix:GetTranslation(), matrix:GetAngles())
			WorldModel:SetPos(newPos)
			WorldModel:SetAngles(newAng)
			WorldModel:SetupBones()
		else
			WorldModel:SetPos(self:GetPos())
			WorldModel:SetAngles(self:GetAngles())
		end
		WorldModel:DrawModel()
	end
end

if CLIENT then
	local function Circle(x, y, r, step, cache)
		local positions = {}
		for i = 0, 360, step do
			table.insert(positions, {
				x = x + math.cos(math.rad(i)) * r,
				y = y + math.sin(math.rad(i)) * r
			})
		end

		return (cache and positions) or surface.DrawPoly(positions)
	end

	local pnl = vgui.Create("DFrame")
	pnl:SetSize(22, 20)
	pnl:SetDraggable( false )
	pnl:SetVisible( true )
	pnl:ShowCloseButton( false )
	pnl:SetTitle("")
	pnl:SetPos( 0, 0 )
	pnl:SetPaintedManually(true)

	local cld = 0
	local mult

	function SWEP:PostDrawViewModel(vm, wep, ply)
		local owner = self:GetOwner()
		if not self:GetFoundTarget() then return end
		local  trackertargetposition = self:GetTrackedPosition()

		if IsValid(vm) then
			pnl.Paint = function(s,w,h)
				if 0 == 0 then
					local dif = ( trackertargetposition - owner:GetShootPos()):Angle() -- aufrufen der Peilsenderposition
					dif = math.AngleDifference(owner:GetAngles().y, dif.y)

					if dif < 0 then dif = dif * -1 end

					multl = 5 - ( 5 * ( dif / 180 ) )

					farbwechsel = multl * 51
				end

				if cld < CurTime() then
					local dif = ( trackertargetposition - owner:GetShootPos()):Angle() -- aufrufen der Peilsenderposition
					dif = math.AngleDifference(owner:GetAngles().y, dif.y)

					if dif < 0 then dif = dif * -1 end

					mult = 5 - ( 5 * ( dif / 180 ) )

					cld = CurTime() + 2
				end

				local speed = math.Clamp( math.abs( math.sin( CurTime() * mult ) * 0.8 ) * 255 ,0,255) -- Blink geschwindigkeit

				surface.SetDrawColor(Color(255 - farbwechsel, farbwechsel, 0, speed))  --Aufleuchten
				draw.NoTexture()
				Circle(0,0,w,1,false)
			end

			local BoneIndx = vm:LookupBone("tracker")
			local BonePos, BoneAng = vm:GetBonePosition( BoneIndx )
			TextPos = BonePos + BoneAng:Forward() * 31 + BoneAng:Right() * 4.378 + BoneAng:Up() * -5
			TextAngle = BoneAng
			TextAngle:RotateAroundAxis(TextAngle:Right(), 0)
			TextAngle:RotateAroundAxis(TextAngle:Up(), -90)
			TextAngle:RotateAroundAxis(TextAngle:Forward( ), 90)
			cam.Start3D2D(TextPos, TextAngle, 0.015)
				pnl:PaintManual()
			cam.End3D2D()
		end
	end
end

if SERVER then
	util.AddNetworkString("Tracker_Funk.TargetEntity")
	net.Receive("Tracker_Funk.TargetEntity", function(len, ply)
		local target = net.ReadEntity()

		hook.Run("Tracker_Funk.TargetEntity", ply, target)

		local wep = ply:GetWeapon("weapon_trackingdevice_funk")
		if IsValid(wep) then
			if wep.TrackerTarget == target then return end

			wep.TrackerTarget = target
			wep:SetFoundTarget(false)
		end
	end)

	hook.Add("EGMRP.Loaded", "Tracker_Funk.InitLogs", function()
		EventLog:AddEvent("Tracking Device", "Tracker_Funk.TargetEntity", function(ply, target)
			local char = ply:GetCurrentCharacter()
			local targetChar = target:GetCurrentCharacter()

			if char and targetChar then
				return string.format("%s (%s | %s) hat begonnen die Funkfrequenz von %s (%s | %s) zu überwachen.", char:GetFullName(), ply:Name(), ply:SteamID64(), targetChar:GetFullName(), target:Name(), target:SteamID64())
			end
		end)

		EventLog:AddEvent("Tracking Device", "Tracker_Funk.TrackEntity", function(ply, target)
			local char = ply:GetCurrentCharacter()
			local targetChar = target:GetCurrentCharacter()

			if char and targetChar then
				return string.format("%s (%s | %s) hat %s (%s | %s) über einen Funk geortet.", char:GetFullName(), ply:Name(), ply:SteamID64(), targetChar:GetFullName(), target:Name(), target:SteamID64())
			end
		end)
	end)
end

local validCommands = {
	["/advert"] = true,
	["/funk"] = true,
	["/radvert"] = true,
	["/rfunk"] = true,
	["/ladvert"] = true,
	["/lfunk"] = true,
	["/la"] = true,
}

hook.Add("PlayerSay", "FunkenEmpfangen_Funk", function (ply, text)
	local textTable = string.Split(text, " ")
	if validCommands[string.lower(textTable[1])] or validCommands[string.upper(textTable[1])] then
		for _, tracker in pairs(ents.FindByClass( "weapon_trackingdevice_funk" )) do
			local target = tracker.TrackerTarget
			if IsValid(target) and ply == target then
				hook.Run("Tracker_Funk.TrackEntity", tracker:GetOwner(), target)

				tracker:SetFoundTarget(true)
				tracker:SetTrackedPosition(target:GetPos())
			end
		end
	end
end)
--addons/bkeypads/lua/entities/bkeypad/cl_init.lua:
include("shared.lua")

local bkeypads_fullbright = CreateConVar("bkeypads_fullbright", 0, FCVAR_CHEAT)

local wireframe = Material("models/wireframe")
local matFaceID = Material("bkeypads/face_id")

local KeypadID = 0

local scale_3d2d = 0.02

function ENT:ClientInitialize()
	KeypadID = KeypadID + 1
	self.KeypadID = KeypadID
	
	self.BackgroundColor = Color(bKeypads.COLOR.SLATE:Unpack())
	self.ForegroundColor = Color(bKeypads.COLOR.WHITE:Unpack())

	self.Face = matFaceID

	self:SetLEDColor(false)

	self.AnimStart = CurTime()
	self.AnimEnd = CurTime() + .5

	self.ColorAnimStart = CurTime()
	self.ColorAnimEnd = CurTime() + (.5 * .56)

	self:CheckModel()

	self:BackgroundColorChanged(nil, nil, self:GetBackgroundColor())
	self:KeypadCrackableChanged()
	self:OnShieldChanged(nil, nil, self:GetShield())
	self:OnKeypadLinked()

	self.SparksTimer = "bKeypads.Sparks." .. self.KeypadID .. ":" .. self:GetCreationTime()
	timer.Create(self.SparksTimer, 3, 0, function()
		if not IsValid(self) then
			timer.Remove(SparksTimer)
		elseif not IsValid(self.m_eDeployedCracker) then
			self:Sparks()
		end
	end)
	timer.Stop(self.SparksTimer)
end

function ENT:TutorialInitialize()
	self:SetModel(bKeypads.MODEL.KEYPAD)
end

function ENT:ClientOnRemove()
	local SparksTimer = self.SparksTimer
	local KeypadPropertiesPanel = self.m_pKeypadProperties
	
	bKeypads:nextTick(function()
		if not IsValid(self) then
			if bKeypads.LOCKED_KEYPAD == self then
				bKeypads.LOCKED_KEYPAD = nil
				gui.EnableScreenClicker(false)
			end

			if SparksTimer then
				timer.Remove(SparksTimer)
			end

			if IsValid(KeypadPropertiesPanel) then
				KeypadPropertiesPanel:Remove()
			end
			
			bKeypads.KeypadsRegistry[self] = nil
			table.RemoveByValue(bKeypads.Keypads, self)
		end
	end)
end

function ENT:BackgroundColorChanged()
	self.CustomBackgroundColor = bKeypads:IntToColor(self:GetBackgroundColor())

	if self:GetScanningStatus() ~= bKeypads.SCANNING_STATUS.LOADING then
		self.BackgroundTargetColor = self:LinkProxy():GetAuthMode() == bKeypads.AUTH_MODE.PIN and Color(32, 32, 32) or self.CustomBackgroundColor

		self:CalculateForegroundColor()
		
		self.BackgroundAnimFrom = Color(self.BackgroundColor:Unpack())
		self.ForegroundAnimFrom = Color(self.ForegroundColor:Unpack())

		self.ColorAnimStart = CurTime()
		self.ColorAnimEnd = CurTime() + (.5 * .56)
	end
end

function ENT:ScanningStatusChanged(_, prevScanStatus, scanStatus)
	local authMode = self:LinkProxy():GetAuthMode()

	if scanStatus == bKeypads.SCANNING_STATUS.LOADING then
		
		self:SetLEDColor(false)
		self.BackgroundTargetColor = bKeypads.COLOR.SLATE

	elseif scanStatus == bKeypads.SCANNING_STATUS.IDLE then

		self:SetLEDColor(false)
		self.BackgroundTargetColor = authMode == bKeypads.AUTH_MODE.PIN and bKeypads.COLOR.SLATE or self.CustomBackgroundColor

		self.ForegroundTargetAlpha = 1

	elseif scanStatus == bKeypads.SCANNING_STATUS.SCANNING then

		self:SetLEDColor(bKeypads.Config.Appearance.LEDColors.Scanning)
		self.BackgroundTargetColor = bKeypads.Config.Appearance.ScreenColors.Scanning

		if authMode == bKeypads.AUTH_MODE.FACEID then
			self.ScanStart = CurTime()
		end

		self.GrantedDenied = nil

	elseif scanStatus == bKeypads.SCANNING_STATUS.GRANTED then

		self:SetLEDColor(bKeypads.Config.Appearance.LEDColors.Granted)
		self.BackgroundTargetColor = bKeypads.Config.Appearance.ScreenColors.Granted
		self.GrantedDenied = bKeypads.SCANNING_STATUS.GRANTED

	elseif scanStatus == bKeypads.SCANNING_STATUS.DENIED then

		self:SetLEDColor(bKeypads.Config.Appearance.LEDColors.Denied)
		self.BackgroundTargetColor = bKeypads.Config.Appearance.ScreenColors.Denied
		self.GrantedDenied = bKeypads.SCANNING_STATUS.DENIED

	end

	self:CalculateForegroundColor()

	self.AnimStart = CurTime()
	self.AnimEnd = CurTime() + .5

	self.ColorAnimStart = CurTime()
	self.ColorAnimEnd = CurTime() + (.5 * .56)

	self.ForegroundAnimFrom = Color(self.ForegroundColor:Unpack())
	self.BackgroundAnimFrom = Color(self.BackgroundColor:Unpack())
end

function ENT:HasRainbowBackground()
	return self:GetBackgroundColor() == bKeypads.STOOL.RainbowBackgroundColor
end

function ENT:CalculateForegroundColor()
	if self:HasRainbowBackground() then
		self.ForegroundColor = bKeypads.COLOR.SLATE
		self.GrantedForegroundColor = bKeypads.COLOR.SLATE
		self.DeniedForegroundColor = bKeypads.COLOR.SLATE
	else
		if self.CustomBackgroundColor then
			self.ForegroundColor = bKeypads:DarkenForeground(self.CustomBackgroundColor) and bKeypads.COLOR.SLATE or bKeypads.COLOR.WHITE
		end
		self.GrantedForegroundColor = bKeypads:DarkenForeground(bKeypads.Config.Appearance.ScreenColors.Granted) and bKeypads.COLOR.SLATE or bKeypads.COLOR.WHITE
		self.DeniedForegroundColor = bKeypads:DarkenForeground(bKeypads.Config.Appearance.ScreenColors.Denied) and bKeypads.COLOR.SLATE or bKeypads.COLOR.WHITE
	end

	self.ForegroundHackedColor = bKeypads:DarkenForeground(bKeypads.Config.Appearance.ScreenColors.Hacked) and bKeypads.COLOR.SLATE or bKeypads.COLOR.WHITE
end

function ENT:GetScreenColor()
	return self:LinkProxy():GetAuthMode() ~= bKeypads.AUTH_MODE.PIN and (self.BackgroundColor or self.BackgroundTargetColor or self.CustomBackgroundColor) or bKeypads.COLOR.SLATE
end

function ENT:SetLEDColor(col)
	if col == false then
		if self:LinkProxy():GetAuthMode() == bKeypads.AUTH_MODE.PIN then
			self:ShowTopLED(true)
			self.LEDColor = bKeypads.COLOR.LCDSCREEN
		else
			self:ShowTopLED(false)
		end
		self:ShowBottomLED(false)
	else
		self:ShowTopLED(true)
		self:ShowBottomLED(true)
		self.LEDColor = col
	end
end

function ENT:GetLEDColor()
	return self.LEDColor
end

function ENT:Emote(face, time)
	self.Face = bKeypads.Emotes[face]
	self.FaceTime = CurTime() + time
end

do
	local matBeam = Material("effects/lamp_beam")
	local matLight = Material("sprites/light_ignorez")

	local matFaceIDSad = Material("bkeypads/face_id_sad")
	local matKeycard = Material("bkeypads/keycard")

	local matLoading = Material("bkeypads/loading")
	local matTick = Material("bkeypads/tick")
	local matCross = Material("bkeypads/cross")

	--[[local function print_flags(flags)
		print("Flags = ", flags)
		print("STUDIO_RENDER", bit.band(flags, STUDIO_RENDER) ~= 0)
		print("STUDIO_VIEWXFORMATTACHMENTS", bit.band(flags, STUDIO_VIEWXFORMATTACHMENTS) ~= 0)
		print("STUDIO_DRAWTRANSLUCENTSUBMODELS", bit.band(flags, STUDIO_DRAWTRANSLUCENTSUBMODELS) ~= 0)
		print("STUDIO_TWOPASS", bit.band(flags, STUDIO_TWOPASS) ~= 0)
		print("STUDIO_STATIC_LIGHTING", bit.band(flags, STUDIO_STATIC_LIGHTING) ~= 0)
		print("STUDIO_WIREFRAME", bit.band(flags, STUDIO_WIREFRAME) ~= 0)
		print("STUDIO_ITEM_BLINK", bit.band(flags, STUDIO_ITEM_BLINK) ~= 0)
		print("STUDIO_NOSHADOWS", bit.band(flags, STUDIO_NOSHADOWS) ~= 0)
		print("STUDIO_WIREFRAME_VCOLLIDE", bit.band(flags, STUDIO_WIREFRAME_VCOLLIDE) ~= 0)
		print("STUDIO_GENERATE_STATS", bit.band(flags, STUDIO_GENERATE_STATS) ~= 0)
		print("STUDIO_SSAODEPTHTEXTURE", bit.band(flags, STUDIO_SSAODEPTHTEXTURE) ~= 0)
		print("STUDIO_SHADOWDEPTHTEXTURE", bit.band(flags, STUDIO_SHADOWDEPTHTEXTURE) ~= 0)
		print("STUDIO_TRANSPARENCY", bit.band(flags, STUDIO_TRANSPARENCY) ~= 0)
	end]]
	
	function ENT:Draw(flags)
		--print_flags(flags)

		if self:GetBroken() and not self:GetHacked() then
			if self:GetSlanted() then
				self.ResetRenderAngles = true
				self:SetRenderAngles(nil)

				if not self.HackedAngle then
					self.HackedAngle = math.random(1,2) == 1 and math.random(-5, -2) or math.random(2, 5)
				end

				local ang = self:GetAngles()
				ang:RotateAroundAxis(ang:Forward(), -self.HackedAngle)
				self:SetRenderAngles(ang)
			end
		elseif self.ResetRenderAngles then
			self.ResetRenderAngles = nil
			self.HackedAngle = nil
			self:SetRenderAngles(nil)
		end
		
		if bit.band(flags, STUDIO_TRANSPARENCY) == 0 or bit.band(flags, STUDIO_TWOPASS) == 0 then
			local scanStatus = self:GetScanningStatus()

			render.SuppressEngineLighting(
				self.m_ForceSupressEngineLighting or
				bkeypads_fullbright:GetBool() or
				not bKeypads.Config.AlwaysEngineLighting and (
					bKeypads.LOCKED_KEYPAD == self or
					(scanStatus ~= bKeypads.SCANNING_STATUS.IDLE and scanStatus ~= bKeypads.SCANNING_STATUS.LOADING)
				)
			)
			
			if not self.m_DrawFallbackModel then
				self:DrawModel()
			end

			if self.RenderCable then
				self:RenderCable(flags)
			end

			if scanStatus == bKeypads.SCANNING_STATUS.SCANNING and self:LinkProxy():GetAuthMode() == bKeypads.AUTH_MODE.KEYCARD then
				local keycard = self:GetScanningEntity()
				if keycard.bKeycard then
					keycard:DrawWorldKeycard(self)
				end
			end

			render.SuppressEngineLighting(false)

			local IgnoreZ = bKeypads.cam.IgnoreZ(false)
				self:Draw3D2DUI(flags)
			bKeypads.cam.IgnoreZ(IgnoreZ)
		end
	end

	function ENT:DrawTranslucent(flags)
		self:Draw(flags)

		if self.DrawShield then self:DrawShield(scale_3d2d) end

		local didDraw = self:DrawPayment3D2DUI()
		self:DrawKeypadLabel(didDraw)

		self:DrawScanningBeam()
	end

	local ui_w, ui_h = 370, 537
	local ui_w_half = ui_w / 2

	-- x = forward
	-- y = right
	-- z = down
	local mdl_ui_pos_mins = Vector(.33, -3.705, 5.415)
	local mdl_ui_pos_maxs = Vector(mdl_ui_pos_mins.x, mdl_ui_pos_mins.y + (ui_w * scale_3d2d), mdl_ui_pos_mins.z - (ui_h * scale_3d2d))

	local mdl_keypad_led_pos_mins = Vector(0.65, -1.410797, 5.31)
	local mdl_keypad_led_pos_maxs = Vector(0.65, 1.410797, 4.8)
	local led_w, led_h = (mdl_keypad_led_pos_maxs.y - mdl_keypad_led_pos_mins.y) / scale_3d2d, -(mdl_keypad_led_pos_maxs.z - mdl_keypad_led_pos_mins.z) / scale_3d2d
	local asterisk_offset = 2

	local scan_method_w, scan_method_h = 256, 256
	local scan_method_x, scan_method_y = (ui_w - scan_method_w) / 2, (ui_h - scan_method_h) / 2

	local keypad_btn_size = 85
	local keypad_btn_spacing = 10
	local keypad_btn_p_size = keypad_btn_size + keypad_btn_spacing
	local keypad_btn_p_frac = keypad_btn_size / keypad_btn_p_size

	local keypad_btn_cross_size = 40
	local keypad_btn_tick_size = 50

	local keypad_btn_cross_pos = (keypad_btn_size - keypad_btn_cross_size) / 2
	local keypad_btn_tick_pos = (keypad_btn_size - keypad_btn_tick_size) / 2

	local keypad_w, keypad_h = (keypad_btn_p_size * 2) + keypad_btn_size, (keypad_btn_p_size * 3) + keypad_btn_size
	
	local keypad_top_left_x, keypad_top_left_y = (ui_w - keypad_w) / 2, ((ui_h - keypad_h) / 2)
	local keypad_top_right_x = keypad_top_left_x + (keypad_btn_p_size * 2) + keypad_btn_size
	local keypad_bottom_left_x = keypad_top_left_y + (keypad_btn_p_size * 3) + keypad_btn_size

	local keypad_slide_offset = (ui_h + keypad_h) / 2

	local keypad_btn_hovered_col = Color(255,255,255)
	local keypad_btn_col = Color(100,100,100)

	local keypad_matrix_translate = { {7,8,9}, {4,5,6}, {1,2,3}, {10,0,11} }
	local keypad_numpad_translate = { KEY_PAD_0, KEY_PAD_1, KEY_PAD_2, KEY_PAD_3, KEY_PAD_4, KEY_PAD_5, KEY_PAD_6, KEY_PAD_7, KEY_PAD_8, KEY_PAD_9 }
	
	local paymentPolyHeight = 80

	local paymentPoly = {
		{ x = 0,				y = 0 },
		{ x = ui_w,				y = 0 },
		{ x = ui_w,				y = paymentPolyHeight },
		{ x = 0,				y = paymentPolyHeight },
	}

	local paymentPolyLeft = {
		{ x = ui_w_half,		y = paymentPolyHeight },
		{ x = ui_w_half,		y = paymentPolyHeight + 20 },
		{ x = ui_w_half - 20,	y = paymentPolyHeight }
	}

	local paymentPolyRight = {
		{ x = ui_w_half,		y = paymentPolyHeight },
		{ x = ui_w_half + 20,	y = paymentPolyHeight },
		{ x = ui_w_half,		y = paymentPolyHeight + 20 }
	}

	ENT.PaymentPolyHeight = ((paymentPolyHeight + 20) * scale_3d2d) + .5

	local function initRainbow()
		local function ang2D(P11, P12, P21, P22)
			return math.deg(math.atan((P22 - P12) / (P21 - P11)))
		end
		
		local function DrawTexturedRectRotatedPoint(x, y, w, h, rot, x0, y0)
			local c = math.cos(math.rad(rot))
			local s = math.sin(math.rad(rot))
			local newx = y0 * s - x0 * c
			local newy = y0 * c + x0 * s
			surface.DrawTexturedRectRotated(x + newx, y + newy, w, h, rot)
		end
		
		local screenLength = math.floor(math.sqrt((ui_h ^ 2) + (ui_w ^ 2)))

		local RT = GetRenderTargetEx("bKeypads_RainbowBackground", screenLength, screenLength, RT_SIZE_NO_CHANGE, MATERIAL_RT_DEPTH_NONE, 32768, CREATERENDERTARGETFLAGS_HDR, IMAGE_FORMAT_DEFAULT)

		local RTRainbow = CreateMaterial("bKeypads.Rainbow", "UnlitGeneric", {
			["$basetexture"] = RT:GetName(),
			["$translucent"] = 1,
			["$vertexalpha"] = 1
		})

		local RenderRainbow = false
		local RainbowRendered
		local RainbowWidth
		hook.Add("PostRender", "bKeypads.RenderRainbow", function()
			if render.GetRenderTarget() ~= nil and (not bKeypads.Tutorial.SCENE_RT or render.GetRenderTarget():GetName() ~= bKeypads.Tutorial.SCENE_RT:GetName()) then return end
			if RainbowRendered == FrameNumber() then return end

			if not RenderRainbow then return end
			RenderRainbow = false

			RainbowRendered = FrameNumber()
			RainbowWidth = 0

			render.PushRenderTarget(RT)
			cam.Start2D()

				render.OverrideAlphaWriteEnable(true, true)
				render.OverrideColorWriteEnable(true, true)
				render.Clear(0, 0, 0, 255)
				render.SetWriteDepthToDestAlpha(false)
				render.OverrideAlphaWriteEnable(true, false)

				local timeStep = ((CurTime() / 4) % 2) * math.pi
				local barWidth = Lerp(((math.sin((CurTime() % 2) * math.pi) + 1) / 2), 15, 50)
				local barNum = math.ceil((screenLength / barWidth / 2) * math.pi)
				local frequency = (1 / (barNum * bKeypads.phi)) * math.pi

				for i = 1, barNum - 1 do
					local thicc = math.sin((i / barNum) * math.pi) * barWidth
					
					surface.SetDrawColor(bKeypads:Rainbow((-i * frequency) + timeStep))
					surface.DrawRect(RainbowWidth - 1, 0, thicc + 2, screenLength)
					
					RainbowWidth = RainbowWidth + thicc
				end

				render.OverrideAlphaWriteEnable(false)
				render.OverrideColorWriteEnable(false)

			cam.End2D()
			render.PopRenderTarget()
		end)
		if bKeypads then
			function bKeypads:DrawRainbow(w, h)
				RenderRainbow = true

				local size = w and h and math.sqrt((w ^ 2) + (h ^ 2)) or screenLength

				surface.SetDrawColor(255, 255, 255, 255)
				surface.SetMaterial(RTRainbow)
				DrawTexturedRectRotatedPoint(0, 0, size, size, ang2D(0, 0, h or ui_h, w or ui_w), 0, size / 2)
			end
		end
	end
	initRainbow() hook.Add("bKeypads.Ready", "bKeypads.RainbowInit", initRainbow)

	local function GetViewData()
		local mouseX, mouseY = gui.MouseX(), gui.MouseY()
		if bKeypads.Settings:Get("pin_input_mode") == "look" and mouseX == 0 and mouseY == 0 then
			return bKeypads.FakeAngles:GetEyeData()
		end
		return LocalPlayer():EyePos(), gui.ScreenToVector(mouseX, mouseY)
	end

	local cursorPosTr = {}
	function ENT:GetCursorPos(mouseMode)
		if LocalPlayer():KeyDown(IN_ATTACK) then return end
		
		local ply = LocalPlayer()
		if not IsValid(ply) then return end

		local EyePos, AimVector = GetViewData()

		cursorPosTr.start = EyePos
		cursorPosTr.endpos = EyePos + AimVector * 65
		cursorPosTr.filter = ply
		local tr = util.TraceLine(cursorPosTr)
		if tr.Entity ~= self then return end

		local pos, ang = self:_LocalToWorld(mdl_ui_pos_mins), self:GetAngles()
		ang:RotateAroundAxis(self:GetUp(), 90)
		ang:RotateAroundAxis(self:GetRight(), -90)
		if self.HackedAngle then
			ang:RotateAroundAxis(self:GetRight(), -self.HackedAngle)
			ang:RotateAroundAxis(self:GetForward(), -self.HackedAngle)
		end

		local intersection = util.IntersectRayWithPlane(EyePos, AimVector, pos, self:GetForward())
		if not intersection then return end

		local localIntersection = WorldToLocal(intersection, angle_zero, pos, self:GetAngles())
		local x, y = localIntersection.y / scale_3d2d, -localIntersection.z / scale_3d2d
		if x > 0 and y > 0 and x <= ui_w and y <= ui_h then
			return x, y
		end
	end

	function ENT:ClearInput()
		if self:GetPINDigitsInput() ~= 0 then
			net.Start("bKeypads.PIN.InputKey")
				net.WriteEntity(self)
				net.WriteUInt(10, 4)
			net.SendToServer()
		end
	end

	function ENT:StartInteraction()
		if self:LinkProxy():GetAuthMode() == bKeypads.AUTH_MODE.PIN then
			bKeypads.LOCKED_KEYPAD = self
			
			gui.EnableScreenClicker(true)
		end
	end

	function ENT:FinishInteraction()
		bKeypads.LOCKED_KEYPAD = nil

		gui.EnableScreenClicker(false)
		self:ClearInput()
	end

	function ENT:NetworkPINInput()
		local pressed = self.PINNumpadPressed or self.PINButtonPressed
		if (pressed ~= 10 and pressed ~= 11) or self:GetPINDigitsInput() ~= 0 then
			net.Start("bKeypads.PIN.InputKey")
				net.WriteEntity(self)
				net.WriteUInt(pressed, 4)
			net.SendToServer()
		end
	end

	local CanDraw3D2D, CanDraw3D2DAlpha, CanDraw3D2DFrame
	function ENT:CanDraw3D2D()
		if halo.RenderedEntity() == self then return end
		if CanDraw3D2DFrame ~= FrameNumber() then
			local entPos = self:GetPos()
			CanDraw3D2D = entPos:ToScreen().visible
			if CanDraw3D2D then
				CanDraw3D2DAlpha = surface.GetAlphaMultiplier() * (self:EntIndex() == -1 and 1 or (bKeypads.Performance:Optimizing() and bKeypads.ease.InOutSine(bKeypads.Performance:Alpha3D2D(entPos:DistToSqr(LocalPlayer():GetPos()))) or 1))
				CanDraw3D2D = CanDraw3D2D and CanDraw3D2DAlpha > 0
			end
		end
		return CanDraw3D2D, CanDraw3D2DAlpha
	end

	do
		local keypadImageEasterEggs = {
			["2148855444"] = "https://i.imgur.com/5cN1cgq.png"
		}
		local keypadImageEasterEgg, keypadImageEasterEggEnd
		function ENT:GetImageURLEasterEgg()
			if keypadImageEasterEgg and keypadImageEasterEggEnd and CurTime() < keypadImageEasterEggEnd then
				return keypadImageEasterEgg
			else
				return self:GetImageURL()
			end
		end

		hook.Add("OnPlayerChat", "bKeypads.PlayerChat.EasterEgg", function(ply, text)
			if ply ~= LocalPlayer() then return end
			
			local egg = keypadImageEasterEggs[util.CRC(text:lower())]
			if egg then
				keypadImageEasterEgg = egg
				keypadImageEasterEggEnd = CurTime() + 20

				local fx = EffectData()
				for _, ent in ipairs(ents.GetAll()) do
					if ent.bKeypad then
						ent:EmitSound("garrysmod/save_load1.wav", 60)

						fx:SetEntity(ent)
						util.Effect("entity_remove", fx)
					end
				end
			end
		end)
	end

	local requiresPaymentFocus
	function ENT:Draw3D2DUI()
		local authMode = self:LinkProxy():GetAuthMode()
		if authMode ~= self._authMode then
			if self._authMode ~= nil then
				self:ScanningStatusChanged(nil, nil, scanStatus)
			end
			self._authMode = authMode
		end

		local isFaceID        = authMode == bKeypads.AUTH_MODE.FACEID
		local isPIN           = authMode == bKeypads.AUTH_MODE.PIN
		--local isKeycard       = authMode == bKeypads.AUTH_MODE.KEYCARD

		local isBroken  = self:GetBroken()
		local isHacked  = self:GetHacked()

		local isRainbow = not isPIN and (not isBroken and not isHacked) and self:HasRainbowBackground()

		local r, g, b
		if isRainbow then
			r, g, b = bKeypads:Rainbow((((CurTime() - 1) / 4) % 2) * math.pi)
		end

		local canDraw, ui_alpha = self:CanDraw3D2D()
		if not canDraw then return end

		if self:GetBodygroup(bKeypads.BODYGROUP.PANEL) == 1 then return end

		if not self.CustomBackgroundColor then
			self:BackgroundColorChanged(nil, nil, self:GetBackgroundColor())
		end
		
		local playerLooking = LocalPlayer():GetEyeTrace().Entity == self
		
		local scanStatus = self:GetScanningStatus()

		local isIdle          = scanStatus == bKeypads.SCANNING_STATUS.IDLE
		local isScanning      = scanStatus == bKeypads.SCANNING_STATUS.SCANNING
		local isLoading       = scanStatus == bKeypads.SCANNING_STATUS.LOADING
		local isAccessGranted = scanStatus == bKeypads.SCANNING_STATUS.GRANTED
		local isAccessDenied  = scanStatus == bKeypads.SCANNING_STATUS.DENIED
		local displayAccess   = isAccessGranted or isAccessDenied
		
		local mouseMode       = isPIN and bKeypads.Settings:Get("pin_input_mode") == "mouse"

		local imageURL = self:GetImageURLEasterEgg()
		if imageURL and #imageURL > 0 and bKeypads.KeypadImages:VerifyURL(imageURL) then
			if (self.ImageURLLoaded == nil or (isnumber(self.ImageURLLoaded) and os.time() > self.ImageURLLoaded) or imageURL ~= self.ImageURLLoaded) then
				local loading = imageURL
				self.ImageURLLoaded = loading
				self.CustomImage = nil
				bKeypads.KeypadImages:GetImage(loading, function(success, mat, retry)
					if imageURL ~= loading then return end
					if success then
						self.CustomImage = mat
					else
						self.ImageURLLoaded = retry
						bKeypads:print("Failed to get custom image for keypad #" .. self:EntIndex() .. " - \"" .. mat .. "\"", bKeypads.PRINT_TYPE_BAD, "ERROR")
					end
				end)
			end
		else
			self.CustomImage = nil
			self.ImageURLLoaded = nil
		end

		local plyBehind = self:IsPlayerBehind(LocalPlayer())
		
		local AnimFrac = math.Clamp(math.TimeFraction(self.AnimStart, self.AnimEnd, CurTime()), 0, 1)
		local ColorAnimFrac = math.Clamp(math.TimeFraction(self.ColorAnimStart, self.ColorAnimEnd, CurTime()), 0, 1)

		local AnimFracEaseBack = bKeypads.ease.OutBack(AnimFrac)
		local AnimFracEaseBackInverse = 1 - AnimFracEaseBack

		local displayAccessAnim = displayAccess and AnimFracEaseBackInverse or AnimFracEaseBack

		local pos, pos_max = self:_LocalToWorld(mdl_ui_pos_mins)--, self:_LocalToWorld(mdl_ui_pos_maxs)

		local ang = self:GetAngles()
		ang:RotateAroundAxis(self:GetUp(), 90)
		ang:RotateAroundAxis(self:GetRight(), -90)
		if self.HackedAngle then
			ang:RotateAroundAxis(self:GetRight(), -self.HackedAngle)
			ang:RotateAroundAxis(self:GetForward(), -self.HackedAngle)
		end
		
		self.Start3D2D(pos, ang, scale_3d2d)
			self:Scissor2D(ui_w, ui_h)

			if self.m_bPlayTVAnimation and (not self.m_tTVAnimation or CurTime() < self.m_tTVAnimation.Start + 0.15) then
				bKeypads:TVAnimation(self, 0.15, ui_w, ui_h)
			else
				self.m_bPlayTVAnimation = nil
				self.m_tTVAnimation = nil
				self.m_bTVAnimation = nil
			end

			local mouseX, mouseY
			if isPIN then
				mouseX, mouseY = self:GetCursorPos(mouseMode)
				if bKeypads.LOCKED_KEYPAD == self and not mouseX and not mouseY then
					self:FinishInteraction()
				end
			end

			surface.SetAlphaMultiplier(ui_alpha)

			if isPIN and not isBroken then
				surface.SetDrawColor(bKeypads.COLOR.SLATE)
				surface.DrawRect(0, 0, ui_w, ui_h)
			elseif isRainbow then
				if bKeypads.Performance:Optimizing() then
					surface.SetDrawColor(r, g, b)
					surface.DrawRect(0, 0, ui_w, ui_h)
				else
					local rainbow_alpha = self:EntIndex() == -1 and 1 or bKeypads.ease.InOutSine(bKeypads.Performance:Alpha3D2D(self:WorldSpaceCenter():DistToSqr(LocalPlayer():GetPos())))
					if rainbow_alpha < 1 then
						surface.SetDrawColor(r, g, b)
						surface.DrawRect(0, 0, ui_w, ui_h)
					end

					surface.SetAlphaMultiplier(math.min(ui_alpha, rainbow_alpha))
						surface.SetDrawColor(bKeypads.COLOR.SLATE)
						surface.DrawRect(0, 0, ui_w, ui_h)

						bKeypads:DrawRainbow()
					surface.SetAlphaMultiplier(ui_alpha)
				end
			else
				surface.SetDrawColor(self.BackgroundColor)
				surface.DrawRect(0, 0, ui_w, ui_h)
			end

			if self.SlideText and CurTime() <= self.SlideText.finish then
				local slideFrac = math.min(math.TimeFraction(self.SlideText.start, self.SlideText.finish, CurTime()), 1)

				surface.SetFont("bKeypads.SlideTextFont")
				surface.SetTextColor(self.ForegroundColor)

				local text_w, text_h = surface.GetTextSize(self.SlideText.text)
				local slide_x = (-ui_w * (self.SlideText.index - 1)) + (ui_w * #self.SlideText.keypads) - ((text_w + (ui_w * #self.SlideText.keypads)) * slideFrac)
				surface.SetTextPos(slide_x, (ui_h - text_h) / 2)

				surface.DrawText(self.SlideText.text)
			else
				if isBroken or (not isPIN and isScanning) then
					surface.SetAlphaMultiplier(ui_alpha / 2)
					if not self.Matrix then
						self.Matrix = bKeypads_Matrix("KEYPAD", ui_w, ui_h)
						self.Matrix:SetRainSize(24)
					end
					self.Matrix:Draw(ui_w, ui_h)
					surface.SetAlphaMultiplier(ui_alpha)
				end

				local slideOffset = scan_method_y + scan_method_h

				if isLoading or not self.GrantedDenied then
					local slide = (displayAccess and -1 or 1) * ((isScanning or isLoading) and AnimFracEaseBackInverse or AnimFracEaseBack)
					surface.SetDrawColor(isRainbow and bKeypads.COLOR.SLATE or bKeypads.COLOR.WHITE)
					surface.SetMaterial(matLoading)
					surface.DrawTexturedRectRotated(scan_method_x + (scan_method_w / 2), scan_method_y + (scan_method_h / 2) - (slideOffset * slide), scan_method_w * .75, scan_method_h * .75, (SysTime() * 100) % 360)
				end

				if not isLoading then
					if isBroken then
						surface.SetDrawColor(self.ForegroundColor)
						surface.SetMaterial(isHacked and matTick or (isFaceID and matFaceIDSad or matCross))
						surface.DrawTexturedRect(scan_method_x, scan_method_y, scan_method_w, scan_method_h)
					else
						if not isPIN then
							local slide = displayAccess and 1 or (isScanning and AnimFracEaseBack or AnimFracEaseBackInverse)
							if (self.CustomImage ~= nil) then
								surface.SetDrawColor(255,255,255)
								surface.SetMaterial(self.CustomImage)
							else
								surface.SetDrawColor(self.ForegroundColor)
								surface.SetMaterial(isFaceID and ((not self.FaceTime or CurTime() > self.FaceTime) and bKeypads.Emotes["default"] or self.Face) or matKeycard)
							end
							surface.DrawTexturedRect(scan_method_x, scan_method_y + (slideOffset * slide), scan_method_w, scan_method_h)
						else
							local slide = self.GrantedDenied and 0 or AnimFracEaseBackInverse
							local pin_y = keypad_top_left_y + (keypad_slide_offset * slide)

							local hoveredKey
							if playerLooking and vgui.GetKeyboardFocus() == nil and not gui.IsConsoleVisible() and not gui.IsGameUIVisible() then
								-- Only make these calculations when:
								-- * The player is looking at the keypad
								-- * They are not focused on any text boxes
								-- * The console is not open
								-- * The escape menu is not open

								local USE_KEY_DOWN = LocalPlayer():KeyDown(IN_USE) and not LocalPlayer():KeyDown(IN_ATTACK)

								-- Figure out if player has +use on the keypad and lock them into it
								if bKeypads.Settings:Get("pin_input_mode") == "mouse" and LocalPlayer():GetUseEntity() == self then
									if not self.USE_KEY_HELD and USE_KEY_DOWN then
										self.USE_KEY_HELD = true
										if LocalPlayer():KeyDown(IN_ATTACK) and IsValid(LocalPlayer():GetActiveWeapon()) and LocalPlayer():GetActiveWeapon():GetClass() == "weapon_physgun" then
											self.USE_KEY_PHYSGUN_BLOCK = true
										end
									elseif self.USE_KEY_HELD and not USE_KEY_DOWN then
										self.USE_KEY_HELD = false
										
										if bKeypads.LOCKED_KEYPAD ~= self then
											if not plyBehind and not self.USE_KEY_PHYSGUN_BLOCK then
												self:StartInteraction()
											end
										else
											self:FinishInteraction()
										end

										self.USE_KEY_PHYSGUN_BLOCK = nil
									end
								end

								-- Calculate which PIN button is hovered by the mouse
								if isIdle and (mouseX and mouseY) and (mouseX >= keypad_top_left_x and mouseX <= keypad_top_right_x) and (mouseY >= pin_y and mouseY <= keypad_bottom_left_x) then
									local column = 1 + ((mouseX - keypad_top_left_x) / keypad_btn_p_size)
									local row = 1 + ((mouseY - pin_y) / keypad_btn_p_size)
									if column % 1 < keypad_btn_p_frac and row % 1 < keypad_btn_p_frac then
										column = math.floor(column)
										row = math.floor(row)
										if keypad_matrix_translate[row] and keypad_matrix_translate[row][column] then
											hoveredKey = keypad_matrix_translate[row][column]
										end
									end
								end

								-- PIN button pressing logic
								if hoveredKey then
									local pressedKey
									if mouseMode or (gui.MouseX() ~= 0 and gui.MouseY() ~= 0) then
										pressedKey = input.IsMouseDown(MOUSE_LEFT)
									else
										pressedKey = USE_KEY_DOWN
									end
									if pressedKey then
										if self.PINButtonPressed == nil then
											self.PINButtonPressed = hoveredKey
											self:NetworkPINInput()
										end
									else
										self.PINButtonPressed = nil
									end
								else
									self.PINButtonPressed = false
								end

								-- Numpad button pressing logic
								if not self.PINButtonPressed then
									if input.IsButtonDown(KEY_PAD_ENTER) then
										if self.PINNumpadPressed == nil then
											self.PINNumpadPressed = 11
											self:NetworkPINInput()
										end
									elseif input.IsButtonDown(KEY_PAD_DECIMAL) or input.IsButtonDown(KEY_PAD_MINUS) then
										if self.PINNumpadPressed == nil then
											self.PINNumpadPressed = 10
											self:ClearInput()
										end
									else
										local btn_down
										for matrix_key, numpad_key in ipairs(keypad_numpad_translate) do
											if input.IsButtonDown(numpad_key) then
												btn_down = true
												if self.PINNumpadPressed == nil then
													self.PINNumpadPressed = matrix_key - 1

													if self:GetPINDigitsInput() < 6 then
														self:NetworkPINInput()
													end
												end
												break
											end
										end
										if btn_down == nil then
											self.PINNumpadPressed = nil
										end
									end
								end
							end

							-- If access has been granted to the keypad, unlock the player
							if isAccessGranted and bKeypads.LOCKED_KEYPAD == self then
								self:FinishInteraction()
							end
						
							surface.SetFont("bKeypads.PINBtn")
							for i=0,11 do
								local isHovered = hoveredKey == i
								if i <= 9 then
									local x, y
									if i == 0 then
										x, y = keypad_top_left_x + keypad_btn_p_size, pin_y + (keypad_btn_p_size * 3)
									else
										x = keypad_top_left_x + (((i - 1) % 3) * keypad_btn_p_size)
										y = pin_y + (math.ceil(2 - ((i - 1) / 3)) * keypad_btn_p_size)
									end
									if isHovered then
										surface.SetDrawColor(keypad_btn_hovered_col)
										if self.PINButtonPressed == i then
											surface.DrawRect(x + 5, y + 5, keypad_btn_size - 10, keypad_btn_size - 10)
										else
											surface.DrawRect(x, y, keypad_btn_size, keypad_btn_size)
										end
									else
										surface.SetDrawColor(keypad_btn_col)
										surface.DrawRect(x, y, keypad_btn_size, keypad_btn_size)
									end
								
									draw.SimpleText(i, "bKeypads.PINBtn", x + (keypad_btn_size / 2), y + (keypad_btn_size / 2), bKeypads.COLOR.SLATE, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
								else
									local x,y
									if i == 10 then
										x,y = keypad_top_left_x, pin_y + (keypad_btn_p_size * 3)
										if isHovered then
											surface.SetDrawColor(255, 0, 0)
										else
											surface.SetDrawColor(120, 25, 25)
										end
									else
										x,y = keypad_top_left_x + (keypad_btn_p_size * 2), pin_y + (keypad_btn_p_size * 3)
										if isHovered then
											surface.SetDrawColor(0, 225, 0)
										else
											surface.SetDrawColor(25, 120, 25)
										end
									end
									if self.PINButtonPressed == i then
										surface.DrawRect(x + 5, y + 5, keypad_btn_size - 10, keypad_btn_size - 10)
									else
										surface.DrawRect(x, y, keypad_btn_size, keypad_btn_size)
									end

									local icon = i == 10 and matCross or matTick
									local iconPos = i == 10 and keypad_btn_cross_pos or keypad_btn_tick_pos
									local iconSize = i == 10 and keypad_btn_cross_size or keypad_btn_tick_size
									surface.SetDrawColor(255, 255, 255)
									surface.SetMaterial(icon)
									surface.DrawTexturedRect(x + iconPos, y + iconPos, iconSize, iconSize)
								end
							end
						end

						if self.GrantedDenied then
							local slide = isScanning and 1 or displayAccessAnim

							if isPIN then
								surface.SetDrawColor(self.BackgroundColor)
								surface.DrawRect(0, math.min(-ui_h * slide, 0), ui_w, ui_h)
							end

							surface.SetDrawColor(self.GrantedDenied == bKeypads.SCANNING_STATUS.GRANTED and self.GrantedForegroundColor or self.DeniedForegroundColor)
							surface.SetMaterial(self.GrantedDenied == bKeypads.SCANNING_STATUS.GRANTED and matTick or matCross)
							if isPIN then
								surface.DrawTexturedRect(scan_method_x, (-ui_h * slide) + ((ui_h - scan_method_h) / 2), scan_method_w, scan_method_h)
							else
								surface.DrawTexturedRect(scan_method_x, scan_method_y - (slideOffset * slide), scan_method_w, scan_method_h)
							end
						end
					end
				end
			end

			surface.SetAlphaMultiplier(1)

			--[[
			if mouseX and mouseY then
				print(mouseX, mouseY)

				surface.SetDrawColor(255,0,255)
				surface.DrawLine(mouseX, mouseY, mouseX, mouseY + 5) -- ^
				surface.DrawLine(mouseX, mouseY, mouseX + 5, mouseY) -- ->
				surface.DrawLine(mouseX, mouseY, mouseX - 5, mouseY) -- <-
				surface.DrawLine(mouseX, mouseY, mouseX, mouseY - 5) -- V
			end
			]]
			
			bKeypads:TVAnimation(self)
			self:Scissor2D()
		self.End3D2D()

		local pin_digits_num = self:GetPINDigitsInput()
		if isPIN and isIdle and pin_digits_num > 0 then
			self.Start3D2D(self:_LocalToWorld(mdl_keypad_led_pos_mins), ang, scale_3d2d)
				surface.SetAlphaMultiplier(ui_alpha)

				local pin_digits = pin_digits_num == 1 and "*" or ("* "):rep(pin_digits_num - 1) .. "*"

				surface.SetTextColor(bKeypads.COLOR.WHITE)
				surface.SetFont("bKeypads.PINAsterisk")
				local x,y = surface.GetTextSize(pin_digits)
				surface.SetTextPos((led_w - x) / 2, ((led_h - y) / 2) - asterisk_offset)
				surface.DrawText(pin_digits)

				--surface.SetDrawColor(255, 0, 0, 50)
				--surface.DrawRect(0, 0, led_w, led_h)
				
				surface.SetAlphaMultiplier(1)
			self.End3D2D()
		end

		if not isLoading and self.ColorAnimEnd then
			local hacked = (isBroken and not isHacked)
			if hacked or not isRainbow then
				local BackgroundTargetColor = hacked and bKeypads.Config.Appearance.ScreenColors.Hacked or self.BackgroundTargetColor
				if CurTime() <= self.ColorAnimEnd then
					self.BackgroundColor:SetUnpacked(
						Lerp(ColorAnimFrac, self.BackgroundAnimFrom.r, BackgroundTargetColor.r),
						Lerp(ColorAnimFrac, self.BackgroundAnimFrom.g, BackgroundTargetColor.g),
						Lerp(ColorAnimFrac, self.BackgroundAnimFrom.b, BackgroundTargetColor.b)
					)
				else
					self.BackgroundColor:SetUnpacked(
						BackgroundTargetColor.r,
						BackgroundTargetColor.g,
						BackgroundTargetColor.b
					)
				end
			else
				self.BackgroundColor:SetUnpacked(r, g, b)
			end
		end
	end

	local requiresPaymentFocus
	function ENT:DrawPayment3D2DUI()
		local canDraw, ui_alpha = self:CanDraw3D2D()
		if not canDraw then return end
		if self:GetBroken() or self:IsPlayerBehind(LocalPlayer()) then return end

		local playerLooking = LocalPlayer():GetEyeTrace().Entity == self

		local authMode   = self:GetAuthMode()
		local scanStatus = self:GetScanningStatus()
		local isFaceID   = authMode == bKeypads.AUTH_MODE.FACEID
		local isKeycard  = authMode == bKeypads.AUTH_MODE.KEYCARD
		local isIdle     = scanStatus == bKeypads.SCANNING_STATUS.IDLE
		local isScanning = scanStatus == bKeypads.SCANNING_STATUS.SCANNING

		local requiresPaymentTransmit = true
		if requiresPaymentFocus == self and not playerLooking then
			requiresPaymentFocus = nil
			requiresPaymentTransmit = false
		end

		local requiresPayment
		if self:EntIndex() ~= -1 then
			if requiresPaymentTransmit and requiresPaymentFocus ~= self and playerLooking and not isLoading then
				requiresPaymentFocus = self
				requiresPayment = bKeypads.Economy:RequiresPayment(self, true)
			else
				requiresPayment = bKeypads.Economy:RequiresPayment(self)
			end
		elseif self.m_bRequiresPayment ~= nil then
			requiresPayment = self.m_bRequiresPayment
		else
			requiresPayment = true
		end
		if (isFaceID or isKeycard) and self:GetPaymentAmount() > 0 and (isIdle or (isFaceID and isScanning)) and bKeypads.Economy:HasCashSystem() then
			local ang = self:GetAngles()
			ang:RotateAroundAxis(self:GetUp(), 90)
			ang:RotateAroundAxis(self:GetRight(), -90)

			local pos = self:OBBCenter()
			pos.z = self:OBBMaxs().z + .5

			local pos, ang = self:_LocalToWorld(pos), ang
			pos = pos - (ang:Forward() * ui_w_half * scale_3d2d)
			pos = pos - (ang:Right() * paymentPolyLeft[2].y * scale_3d2d)

			bKeypads.cam.IgnoreZ(playerLooking)
				self.Start3D2D(pos, ang, scale_3d2d)
					surface.SetAlphaMultiplier(ui_alpha)
					draw.NoTexture()

					if not requiresPayment or bKeypads.Economy:canAfford(LocalPlayer(), self:GetPaymentAmount()) then
						surface.SetDrawColor(45,203,112,170)
					else
						surface.SetDrawColor(215,0,0,170)
					end

					surface.DrawPoly(paymentPolyLeft)
					surface.DrawPoly(paymentPolyRight)
					surface.DrawPoly(paymentPoly)

					surface.SetFont("bKeypads.PaymentFont")
					local txt = bKeypads.Economy:formatMoney(self:GetPaymentAmount())
					local w, h = surface.GetTextSize(txt)

					if not requiresPayment then
						local zeroDollars = " " .. bKeypads.Economy:formatMoney(0)
						local zW, zH = surface.GetTextSize(zeroDollars)

						local combinedW = (w + zW + 10 + 5)

						surface.SetDrawColor(255, 255, 255, 150)
						surface.DrawRect((ui_w - combinedW) / 2, ((80 - math.max(h, zH)) / 2) + ((h - 4) / 2), w, 4)

						surface.SetTextColor(255, 255, 255, 150)
						surface.SetTextPos((ui_w - combinedW) / 2, ((80 - math.max(h, zH)) / 2))
						surface.DrawText(txt)

						surface.SetTextColor(255, 255, 255, 255)
						surface.DrawText(zeroDollars)
					else
						surface.SetTextColor(255, 255, 255, 255)
						surface.SetTextPos((ui_w - w) / 2, ((80 - h) / 2))
						surface.DrawText(txt)
					end

					surface.SetAlphaMultiplier(1)
				self.End3D2D()
			bKeypads.cam.IgnoreZ(false)

			return true
		end
	end
	
	function ENT:DrawKeypadLabel(drawingPaymentUI)
		local keypadName = self:GetKeypadName():Trim()
		if keypadName == "" and not self:GetDestructible() then return end

		local canDraw, ui_alpha = self:CanDraw3D2D()
		if not canDraw then return end
		
		local playerLooking = LocalPlayer():GetEyeTrace().Entity == self
		if playerLooking then
			local center = self:OBBCenter()
			local positioning = self:OBBCenter()
			local mins, maxs = self:GetModelBounds()
			
			mins.z = mins.z - .5
			mins.y = mins.y - .5
			maxs.z = maxs.z + .5
			maxs.y = maxs.y + .5
			if drawingPaymentUI then
				maxs.z = maxs.z - (paymentPoly[1].y * scale_3d2d) + .5
			end

			positioning.z = mins.z
			local top = self:_LocalToWorld(positioning)

			positioning.z = maxs.z
			local bottom = self:_LocalToWorld(positioning)

			positioning.z = center.z
			positioning.y = maxs.y
			local left = self:_LocalToWorld(positioning)

			positioning.z = center.z
			positioning.y = mins.y
			local right = self:_LocalToWorld(positioning)

			local pos = left
			if right.z >= pos.z then pos = right end
			if bottom.z >= pos.z then pos = bottom end
			if top.z >= pos.z then pos = top end

			local ang = (EyePos() - pos):Angle()
			ang:RotateAroundAxis(ang:Up(), 90)
			ang:RotateAroundAxis(ang:Forward(), 90)
			if self:GetSlanted() and self.HackedAngle then ang:RotateAroundAxis(ang:Up(), -self.HackedAngle) end

			local txtColor = self.CustomBackgroundColor or bKeypads.COLOR.WHITE
			if not bKeypads:DarkenForeground(txtColor) then
				txtColor = bKeypads.COLOR.WHITE
			end

			bKeypads.cam.IgnoreZ(true)
				self.Start3D2D(pos, ang, scale_3d2d)
					surface.SetAlphaMultiplier(ui_alpha)
						local offsetY = self:DrawHealth() or 0
						if keypadName ~= "" then draw.SimpleTextOutlined(keypadName, "bKeypads.KeypadLabelFont", 0, -offsetY + (math.min(offsetY, 1) * 20), txtColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM, 2, bKeypads.COLOR.BLACK) end
					surface.SetAlphaMultiplier(1)
				self.End3D2D()
			bKeypads.cam.IgnoreZ(false)
		end
	end

	local boneLocalToWorldVec = Vector()
	local function boneLocalToWorld(x, y, z, bonePos, boneAng)
		boneLocalToWorldVec.x, boneLocalToWorldVec.y, boneLocalToWorldVec.z = x,y,z
		return LocalToWorld(boneLocalToWorldVec, angle_zero, bonePos, boneAng)
	end

	local prevFrameManipulations
	local hideBone = Vector(0,0,0)
	local function showBones(ply, show)
		if not show then prevFrameManipulations = {} end

		for i=0,ply:GetBoneCount()-1 do
			local boneName = ply:GetBoneName(i)
			if boneName ~= "__INVALIDBONE__" and boneName ~= "ValveBiped.Bip01_Head1" and boneName ~= "ValveBiped.Bip01_Neck1" then
				if show then
					if prevFrameManipulations[i] then
						ply:ManipulateBoneScale(i, prevFrameManipulations[i])
					end
				else
					prevFrameManipulations[i] = ply:GetManipulateBoneScale(i)
					ply:ManipulateBoneScale(i, hideBone)
				end
			end
		end

		ply:SetupBones()

		if show then prevFrameManipulations = nil end
	end

	local beamColor = Color(255,255,255)

	local wireframeRange = Vector(5, 5, 5)
	
	local scanDeltaFallback     = Vector(-6, -0.4, 7)
	local scanPosFallbackOffset = Vector(5, 5, 5)
	local firstPersonScanOffset = Vector(4, 4, 4)

	function ENT:DrawScanningBeam()
		if self:GetScanningStatus() ~= bKeypads.SCANNING_STATUS.SCANNING or not self.ScanStart then return end

		local ply = self:GetScanningPlayer()
		if not IsValid(ply) then return end
		
		local cam_pos = self:GetCamPos()

		local scanCos = math.TimeFraction(self.ScanStart, self.ScanStart + bKeypads.Config.Scanning.ScanTimes.FaceID, CurTime())
		local scanAnim = math.cos(scanCos * 2 * math.pi)

		if self:ScanningBeamLOS(LocalPlayer()) then
			matLight:SetInt("$translucent", 1)
			matLight:Recompute()
			render.SetMaterial(matLight)
			render.DrawSprite(cam_pos, 32, 32, bKeypads.COLOR.WHITE)
		end

		if ply ~= LocalPlayer() or GetViewEntity() ~= LocalPlayer() then
			local scan_pos, beamDelta
			
			local head = ply:LookupBone("ValveBiped.Bip01_Head1")
			if head then
				local boneMatrix = ply:GetBoneMatrix(head)
				if boneMatrix then
					local headHitBox, headHitBoxGroup
					for group = 0, ply:GetHitboxSetCount()-1 do
						for hitbox = 0, ply:GetHitBoxCount(group)-1 do
							if ply:GetHitBoxBone(hitbox, group) == head then
								headHitBoxGroup, headHitBox = group, hitbox
								break
							end
						end
					end

					local mins, maxs
					if headHitBox and headHitBoxGroup then
						mins, maxs = ply:GetHitBoxBounds(headHitBox, headHitBoxGroup)
						mins = mins * ply:GetModelScale()
						maxs = maxs * ply:GetModelScale()
					end
					if mins and maxs then
						local ec = render.EnableClipping(true)
						
						local headPos, headAng = boneMatrix:GetTranslation(), boneMatrix:GetAngles()

						local scanTopBack = boneLocalToWorld(maxs.x, maxs.y, mins.z + maxs.z, headPos, headAng)
						local scanTopFront = boneLocalToWorld(maxs.x, mins.y, mins.z + maxs.z, headPos, headAng)

						local scanBottomBack = boneLocalToWorld(mins.x, maxs.y, mins.z + maxs.z, headPos, headAng)
						local scanBottomFront = boneLocalToWorld(mins.x, mins.y, mins.z + maxs.z, headPos, headAng)

						local beamRange = wireframeRange * ply:GetModelScale() * .5

						local scanTop    = cam_pos.z >= (scanTopFront.z + (scanTopFront:Angle():Up() * beamRange).z) and scanTopBack or scanTopFront
						local scanBottom = cam_pos.z >= (scanBottomFront.z - (scanBottomFront:Angle():Up() * beamRange).z) and scanBottomFront or scanBottomBack

						--[[render.DrawLine(cam_pos, scanTop, Color(255,0,0), false)
						render.DrawLine(cam_pos, scanBottom, Color(255,0,0), false)]]

						local scanDelta  = scanTop - scanBottom
						local scanCenter = scanTop - (scanDelta / 2)

						scan_pos = scanCenter + ((scanDelta / 2) * scanAnim)

						local beamTop    = scan_pos + ((scanTop - scan_pos):Angle():Forward() * beamRange)
						local beamBottom = scan_pos + ((scanBottom - scan_pos):Angle():Forward() * beamRange)

						--[[render.DrawLine(cam_pos, scan_pos, Color(0,0,255), false)
						render.DrawLine(cam_pos, beamTop, Color(0,255,0), false)
						render.DrawLine(cam_pos, beamBottom, Color(0,255,0), false)]]

						beamDelta = scan_pos - cam_pos

						-- Top beam clip
						local beamTopNormal = -headAng:Forward()
						render.PushCustomClipPlane(beamTopNormal, beamTopNormal:Dot(beamTop))
						-- Bottom beam clip
						local beamBottomNormal = headAng:Forward()
						render.PushCustomClipPlane(beamBottomNormal, beamBottomNormal:Dot(beamBottom))
						
						if system.IsWindows() then -- OSX/POSIX cannot handle more than 2 clip planes
							local boneForward, boneRight, boneUp = headAng:Forward(), headAng:Right(), headAng:Up()

							-- Clip bottom of head
							render.PushCustomClipPlane(boneForward, boneForward:Dot(scanBottomBack))

							-- Clip in front of head
							render.PushCustomClipPlane(-boneRight, -boneRight:Dot(boneLocalToWorld(mins.x, mins.y * 1.5, mins.z + maxs.z, headPos, headAng)))

							-- Clip right side of head
							render.PushCustomClipPlane(-boneUp, -boneUp:Dot(boneLocalToWorld(mins.x, maxs.y, maxs.z * 1.5, headPos, headAng)))

							-- Clip neck at 45 degrees
							local neckClip = Angle(headAng)
							neckClip:RotateAroundAxis(neckClip:Up(), 45)
							neckClip = neckClip:Right()
							render.PushCustomClipPlane(neckClip, neckClip:Dot(scanBottomBack))
						end

						render.SetBlend(math.Remap(math.cos((scanCos * 8 * math.pi) - math.pi), -1, 1, .01, 1))

						render.ModelMaterialOverride(wireframe)
							if not bKeypads.Performance:Optimizing() then showBones(ply, false) end
								ply:DrawModel()
							if not bKeypads.Performance:Optimizing() then showBones(ply, true) end
						render.ModelMaterialOverride(nil)

						render.PopCustomClipPlane()
						render.PopCustomClipPlane()
						if system.IsWindows() then
							render.PopCustomClipPlane()
							render.PopCustomClipPlane()
							render.PopCustomClipPlane()
							render.PopCustomClipPlane()
						end

						render.SetBlend(1)

						render.EnableClipping(ec)

						--[[render.SetColorMaterial()
						render.DrawQuadEasy(beamBottom, beamBottomNormal, 100, 100, Color(0,255,0,50), 0)
						render.DrawQuadEasy(beamTop, beamTopNormal, 100, 100, Color(255,0,0,50), 0)]]
					end
				end
			end

			if not scan_pos then
				scan_pos = (ply:EyePos() - (ply:EyeAngles():Up() * scanPosFallbackOffset)) + (((scanDeltaFallback * ply:GetModelScale()) / 2) * scanAnim)
				beamDelta = scan_pos - cam_pos
			end

			local beamNormal = beamDelta:Angle():Forward()
			local beamLength = beamDelta:Length()

			render.SetMaterial(matBeam)
			render.StartBeam(2)
				beamColor.a = 255 * 0.33
				render.AddBeam(cam_pos, 8, 0, beamColor)

				beamColor.a = 255
				render.AddBeam(cam_pos + beamNormal * beamLength, 8, .99, beamColor)
			render.EndBeam()
		else
			local scan_pos = ply:EyePos()
			scan_pos = scan_pos - (ply:EyeAngles():Up() * firstPersonScanOffset) * -scanAnim

			render.SetMaterial(matBeam)
			render.StartBeam(2)
				beamColor.a = 255 * 0.33
				render.AddBeam(cam_pos, 12, 0, beamColor)

				beamColor.a = 255
				render.AddBeam(scan_pos, 12, .35, beamColor)
			render.EndBeam()
		end
	end
end

function ENT:Sparks()
	if self:GetScanningStatus() == bKeypads.SCANNING_STATUS.LOADING or bKeypads.Performance:Optimizing() then return end

	local ang = self:GetAngles()
	ang:RotateAroundAxis(self:GetUp(), 90)
	ang:RotateAroundAxis(self:GetRight(), -90)
	
	local fx = EffectData()
	fx:SetEntity(self)
	fx:SetOrigin(LocalToWorld(self:OBBCenter(), angle_zero, self:GetPos(), ang))
	fx:SetRadius(1)
	fx:SetMagnitude(1)
	fx:SetScale(1)
	fx:SetNormal(ang:Up())
	util.Effect("cball_bounce", fx)

	self:EmitSound("ambient/energy/spark" .. math.random(1,6) .. ".wav", 60)
end

function ENT:BrokenStatusChanged(_, prevHacked, hacked)
	if prevHacked == hacked then return end

	self:CalculateForegroundColor()
	
	self.BackgroundAnimFrom = Color(self.BackgroundColor:Unpack())
	self.ForegroundAnimFrom = Color(self.ForegroundColor:Unpack())

	self.ColorAnimStart = CurTime()
	self.ColorAnimEnd = CurTime() + (.5 * .56)

	bKeypads.ESP:Refresh()

	if hacked then
		self:Sparks()
		timer.Start(self.SparksTimer)
	else
		timer.Stop(self.SparksTimer)
	end
end

function ENT:GetHoveredElement()
	-- if Willox's keypad is installed, error spam occurs if this isn't defined
end
function ENT:SendCommand()
	-- if Willox's keypad is installed, error spam occurs if this isn't defined
end

net.Receive("bKeypads.UseKeycard", function()
	notification.AddLegacy(bKeypads.Config.Keycards.InsertKeycardMessage, NOTIFY_ERROR, 2)
	surface.PlaySound("buttons/button14.wav")
end)

do
	local ScanDeniedSoundDuration = 0.69687074422836
	net.Receive("bKeypads.ScanDenied", function()
		local keypad = net.ReadEntity()
		if not keypad.ScanDenied or SysTime() > keypad.ScanDenied then
			keypad:EmitSound("buttons/button2.wav", 60)
			keypad.ScanDenied = SysTime() + ScanDeniedSoundDuration + .1
		end
	end)
end

do
	local invnext = input.LookupBinding("invnext", true)
	invnext = invnext and input.GetKeyCode(invnext)

	local invprev = input.LookupBinding("invprev", true)
	invprev = invprev and input.GetKeyCode(invprev)

	local function WasButtonPressed(code)
		if code >= MOUSE_FIRST and code <= MOUSE_LAST then
			return input.WasMousePressed(code)
		elseif code >= KEY_FIRST and code <= KEY_LAST then
			return input.WasKeyPressed(code)
		else
			return input.IsButtonDown(code)
		end
	end

	hook.Add("SetupMove", "bKeypads.KeypadUnlock", function(ply, mv, cmd)
		if IsValid(bKeypads.LOCKED_KEYPAD) then
			if invnext and WasButtonPressed(invnext) then
				RunConsoleCommand("invnext")
			elseif invprev and WasButtonPressed(invprev) then
				RunConsoleCommand("invprev")
			elseif not (cmd:GetForwardMove() ~= 0 or cmd:GetSideMove() ~= 0 or cmd:GetUpMove() ~= 0) then
				return
			end
			bKeypads.LOCKED_KEYPAD:FinishInteraction()
		end
	end)
end

do
	local keypadModelMesh

	local vtxstruct, physstruct
	local downloaded = false

	local drawing = false
	local function DrawFallbackModel()
		render.SetColorModulation(1,1,1)
		render.SetMaterial(wireframe)

		for _, keypad in ipairs(bKeypads.Keypads) do
			if not IsValid(keypad) then continue end
			
			local matrix = Matrix()
			matrix:Translate(keypad:GetPos())
			matrix:Rotate(keypad:GetAngles())
			matrix:ScaleTranslation(keypad:GetModelScale())

			cam.PushModelMatrix(matrix)
				keypadModelMesh:Draw()
			cam.PopModelMatrix()
		end
	end

	function ENT:CheckModel()
		if LeySexyErrors then return end

		local mdl = self:GetModel() or bKeypads.MODEL.KEYPAD
		if mdl == "models/error.mdl" or not util.IsValidModel(mdl) then
			if not downloaded then
				net.Start("bKeypads.KeypadModelFallback")
					net.WriteEntity(self)
				net.SendToServer()
			else
				self:DrawFallbackModel()
			end
		end
	end

	function ENT:DrawFallbackModel()
		self.m_DrawFallbackModel = true
		self:SetModel("models/Gibs/HGIBS.mdl")

		self:PhysicsInitMultiConvex(physstruct)

		if not drawing then
			hook.Add("PostDrawOpaqueRenderables", "bKeypads.KeypadModelFallback", DrawFallbackModel)
		end
	end

	net.Receive("bKeypads.KeypadModelFallback", function()
		local keypad = net.ReadEntity()

		vtxstruct = {}
		for i=1,net.ReadUInt(16) do
			vtxstruct[i] = { pos = net.ReadVector() }
		end

		physstruct = {}
		while net.ReadBool() do
			local convex = {}
			for i=1,net.ReadUInt(16) do
				convex[i] = { pos = net.ReadVector() }
			end
			table.insert(physstruct, convex)
		end

		keypadModelMesh = Mesh()
		keypadModelMesh:BuildFromTriangles(vtxstruct)

		downloaded = true
		if IsValid(keypad) then
			keypad:DrawFallbackModel()
		end
	end)
end

--## Destruction ##--

local PITCH_SHIFT = 255 - 100

function ENT:DrawHealth()
	if not self:GetDestructible() then return end
	if self:Health() > 0 then
		local w, h = (self:OBBMaxs().y - self:OBBMins().y) / scale_3d2d, 50
		bKeypads:DrawHealth(self, w, h)
		return (-50 * 2 * scale_3d2d) - 1.5
	else
		return 0
	end
end

local shootEmotes = {
	withShield = {
		"angry",
		"confused",
		"surprised"
	},

	withoutShield = {
		"shocked"
	}
}
function ENT:ImpactTrace(tr)
	if not self:GetDestructible() or self:GetShield() > 0 then
		self:Emote(shootEmotes.withShield[math.random(1, #shootEmotes.withShield)], 0.25)
	else
		self:Emote(shootEmotes.withoutShield[math.random(1, #shootEmotes.withoutShield)], 0.25)
	end

	if self:GetShield() > 0 then
		self.m_iDrawShield = CurTime()
		self.m_iDrawShieldDuration = nil
		self.m_BulletImpactPos = tr.HitPos
		
		self:EmitSound("weapons/physcannon/energy_bounce" .. math.random(1,2) .. ".wav", 60, 100 + (PITCH_SHIFT * .25))

		return true
	end
end

function ENT:ShieldBrokenEffect(duration)
	self.m_iDrawShield = CurTime()
	self.m_iDrawShieldDuration = duration
	self.m_BulletImpactPos = self:WorldSpaceCenter()
end

local function generateCircle(x, y, radius, seg)
	local cir = {}

	table.insert( cir, { x = x, y = y, u = 0.5, v = 0.5 } )
	for i = 0, seg do
		local a = math.rad( ( i / seg ) * -360 )
		table.insert( cir, { x = x + math.sin( a ) * radius, y = y + math.cos( a ) * radius, u = math.sin( a ) / 2 + 0.5, v = math.cos( a ) / 2 + 0.5 } )
	end

	local a = math.rad(0)
	table.insert( cir, { x = x + math.sin( a ) * radius, y = y + math.cos( a ) * radius, u = math.sin( a ) / 2 + 0.5, v = math.cos( a ) / 2 + 0.5 } )

	return cir
end

local shieldMat = Material("models/props_combine/portalball001_sheet")
local bulletCircleMatrix, bulletLaggedCircleMatrix = Matrix(), Matrix()
local bulletCircleDuration = .5
local bulletCircle = {}
function ENT:DrawShield(scale_3d2d)
	if not self:GetDestructible() then return end

	local duration = self.m_iDrawShieldDuration or bulletCircleDuration
	if self.m_BulletImpactPos and self.m_iDrawShield and CurTime() <= self.m_iDrawShield + duration then
		self:RemoveAllDecals()

		local shieldBroken = self:GetShield() == 0

		local maxs = select(2, self:GetModelBounds())

		local scale = self:GetModelScale() or 1
		if not bulletCircle[scale] then
			bulletCircle[scale] = generateCircle(0, 0, (math.sqrt((maxs.y ^ 2) + (maxs.z ^ 2)) * 2) / scale_3d2d, 25)
		end

		local center = self:WorldSpaceCenter()
		local centerDist = math.sqrt(((center.y - self.m_BulletImpactPos.y) ^ 2) + ((center.z - self.m_BulletImpactPos.z) ^ 2))
		local circleRadius = math.sqrt((maxs.y ^ 2) + (maxs.z ^ 2))
		local circleScaleFactor = (centerDist + circleRadius) / (circleRadius * 2)

		local bulletCircleScalar = math.Remap(math.sin(math.TimeFraction(self.m_iDrawShield, self.m_iDrawShield + (duration / 2), CurTime())), -1, 1, 0, 1) * circleScaleFactor
		local bulletCircleLaggedScalar = math.Remap(math.sin(math.TimeFraction(self.m_iDrawShield + (duration / 2), self.m_iDrawShield + duration, CurTime())), -1, 1, 0, 1) * circleScaleFactor
		
		bulletCircleMatrix:SetUnpacked(
			bulletCircleScalar, 0, 0, 0,
			0, bulletCircleScalar, 0, 0,
			0, 0, bulletCircleScalar, 0,
			0, 0, 0, 1
		)
		
		bulletLaggedCircleMatrix:SetUnpacked(
			bulletCircleLaggedScalar, 0, 0, 0,
			0, bulletCircleLaggedScalar, 0, 0,
			0, 0, bulletCircleLaggedScalar, 0,
			0, 0, 0, 1
		)

		render.SetStencilWriteMask(0xFF)
		render.SetStencilTestMask(0xFF)
		render.SetStencilReferenceValue(0)
		render.SetStencilPassOperation(STENCIL_KEEP)
		render.SetStencilZFailOperation(STENCIL_KEEP)
		render.ClearStencil()

		render.SetStencilEnable(true)
		render.SetStencilReferenceValue(1)

		render.CullMode(self:IsPlayerBehind(LocalPlayer()) and MATERIAL_CULLMODE_CW or MATERIAL_CULLMODE_CCW)

		local ang = self:GetAngles()
		ang:RotateAroundAxis(self:GetUp(), 90)
		ang:RotateAroundAxis(self:GetRight(), -90)

		cam.IgnoreZ(true)
			self.Start3D2D(self.m_BulletImpactPos, ang, scale_3d2d)
				draw.NoTexture()
				surface.SetDrawColor(255, 255, 255)
				
				render.SetStencilCompareFunction(STENCIL_NEVER)
				if not shieldBroken then
					render.SetStencilFailOperation(STENCIL_REPLACE)
					
					cam.PushModelMatrix(bulletCircleMatrix, true)
						surface.DrawPoly(bulletCircle[scale])
					cam.PopModelMatrix()
				end
				
				render.SetStencilFailOperation(shieldBroken and STENCIL_REPLACE or STENCIL_INVERT)
				
				cam.PushModelMatrix(bulletLaggedCircleMatrix, true)
					surface.DrawPoly(bulletCircle[scale])
				cam.PopModelMatrix()
			self.End3D2D()
		cam.IgnoreZ(false)

		render.CullMode(MATERIAL_CULLMODE_CCW)

		render.SetStencilCompareFunction(shieldBroken and STENCIL_NOTEQUAL or STENCIL_EQUAL)
		render.SetStencilFailOperation(STENCIL_KEEP)

			render.SuppressEngineLighting(true)
				render.MaterialOverride(shieldMat)
					self:DrawModel()
				render.MaterialOverride(nil)
			render.SuppressEngineLighting(false)

		render.SetStencilEnable(false)
	end
end

net.Receive("bKeypads.PaymentPrompt", function()
	local keypad = net.ReadEntity()
	if not IsValid(keypad) then return end

	local amount = net.ReadUInt(32)
	local authMode = net.ReadBool()

	surface.PlaySound("common/warning.wav")

	local windowText
	if #keypad:GetKeypadName():Trim() > 0 then
		windowText = bKeypads.L("PaymentNamedPrompt"):format(keypad:GetKeypadName(), bKeypads.Economy:formatMoney(amount))
	else
		windowText = bKeypads.L("PaymentPrompt"):format(bKeypads.Economy:formatMoney(amount))
	end

	local Window = Derma_Query(windowText, bKeypads.L"PaymentPromptTitle", bKeypads.L"Yes", function()
		if not IsValid(keypad) then return end
		net.Start("bKeypads.PaymentPrompt")
			net.WriteEntity(keypad)
			net.WriteUInt(amount, 32) -- nope sorry buddy this isn't actually used as the payment amount
			net.WriteBool(authMode)
		net.SendToServer()
	end, bKeypads.L"No")

	Window:SetBackgroundBlur(false)

	Window:SetPos((ScrW() - Window:GetWide()) / 2, ScrH())
	local y = (ScrH() + Window:GetTall()) / 2
	Window:NewAnimation(1, 0, .25).Think = function(_, pnl, f)
		local f = bKeypads.ease.OutSine(f)

		local x = pnl:GetPos()
		pnl:SetPos(x, ScrH() - (y * f))

		pnl:SetAlpha(f * 255)
	end
end)

-- For overriding in tutorial render target
function ENT.Start3D2D(pos, ang, scale)
	cam.Start3D2D(pos, ang, scale)
end
function ENT.End3D2D()
	cam.End3D2D()
end
function ENT:Scissor2D(w, h)
	bKeypads.clip:Scissor2D(w, h)
end

function bKeypads:SlideText(keypads, text, time)
	for i, keypad in ipairs(keypads) do
		keypad.SlideText = {
			index = i,
			keypads = keypads,
			text = text,
			start = CurTime(),
			finish = CurTime() + time
		}
	end
end
concommand.Add("bkeypads_msg", function(ply, _, args)
	-- Just a little easter egg that allows me to put a sliding message across my keypads in-game :D
	-- Removing this won't break anything
	if not IsValid(ply) or ply:SteamID() ~= "STEAM_0:1:40314158" then return end

	local myKeypads = {}
	for _, keypad in ipairs(bKeypads.Keypads) do
		if keypad:GetKeypadOwner() == LocalPlayer() then
			table.insert(myKeypads, keypad)
		end
	end

	bKeypads:SlideText(myKeypads, table.concat(args, " ", 2), tonumber(args[1]))
end)
--addons/bkeypads/lua/entities/bkeypads_map_link/shared.lua:
AddCSLuaFile()

ENT.Type = "point"
ENT.Base = "bkeypads_link"

ENT.PrintName = "Map Link (Billy's Keypads)"
ENT.Author = "Billy"

ENT.Spawnable = false

ENT.RenderGroup = RENDERGROUP_OTHER

DEFINE_BASECLASS(ENT.Base)

function ENT:Initialize()
	BaseClass.Initialize(self)

	if CLIENT then self:OnButtonFlagsChanged() end
end

function ENT:SetupDataTables()
	BaseClass.SetupDataTables(self)

	self:NetworkVar("Bool", 1, "Active")

	self:NetworkVar("Int", 0, "GeneralFlags")
	self:NetworkVar("Int", 1, "ButtonFlags")
	self:NetworkVar("Int", 2, "DoorFlags")

	if CLIENT then
		self:NetworkVarPostNotify("ButtonFlags", self.OnButtonFlagsChanged)
	end
end

if CLIENT then
	function ENT:OnButtonFlagsChanged()
		local ent = self:GetLinkedEnt()
		if IsValid(ent) then
			if self:HasButtonFlag(bKeypads.MapLinking.F_BUTTON_HIDE) then
				bKeypads.MapLinking:Hide(ent)
			else
				bKeypads.MapLinking:Show(ent)
			end
		end
	end
end

function ENT:HasGeneralFlag(flag)
	return bit.band(self:GetGeneralFlags(), flag) ~= 0
end

function ENT:HasButtonFlag(flag)
	return bit.band(self:GetButtonFlags(), flag) ~= 0
end

function ENT:HasDoorFlag(flag)
	return bit.band(self:GetDoorFlags(), flag) ~= 0
end

function ENT:RegisterLink()
	bKeypads.MapLinking.LinkEnts[self] = true
end

if CLIENT then
	function ENT:LinkUpdated()
		if not bKeypads.MapLinking.RebuildLinkTable then
			bKeypads.MapLinking.RebuildLinkTable = true
			bKeypads:nextTick(bKeypads.MapLinking.BuildLinksTable)
		end
	end
	
	function ENT:OnRemove()
		BaseClass.OnRemove(self)

		if IsValid(self:GetLinkedEnt()) then
			bKeypads.MapLinking:Show(self:GetLinkedEnt())
		end
	end
else
	function ENT:DeregisterLink()
		bKeypads.MapLinking.LinkEnts[self] = nil
		bKeypads.MapLinking:DeregisterLink(self:GetKeypad(), self:GetLinkedEnt(), self:GetAccessType())
	end

	function ENT:OnRemove()
		if IsValid(self:GetKeypad()) and IsValid(self:GetLinkedEnt()) then
			bKeypads.MapLinking:Unlink(self:GetKeypad(), self:GetLinkedEnt())
		end
		BaseClass.OnRemove(self)
	end
end

bKeypads_Initialize_Fix(ENT)
--addons/ballistic_shields/lua/entities/bs_dshield/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
ENT.PrintName = "Deployable shield"
ENT.Category = "Ballistic shields"

ENT.Spawnable = false
ENT.DisableDuplicator = true

--addons/ballistic_shields/lua/ballistic_shields/cl_bs_util.lua:
if SERVER then return end
include( "bs_config.lua" )

net.Receive( "bs_shield_info", function( len, pl )
	LocalPlayer().bs_shieldIndex = net.ReadUInt(16)
end )

local Delay = 0
function bshields_materials_reload()
	for _,v in pairs(bshields.materialstoload) do
		Delay = Delay + 0.2
		timer.Simple( Delay, function() surface.GetURL(v[1], v[2], v[3]) end )
	end

	bshields.hshield_webmat = surface.GetURL(bshields.config.hShieldTexture, 256, 256)
	bshields.rshield_webmat = surface.GetURL(bshields.config.rShieldTexture, 256, 256)
	bshields.dshield_webmat = surface.GetURL(bshields.config.dShieldTexture, 256, 256)
end

bshields.materialstoload = {
	{bshields.config.hShieldTexture, 256, 256},
	{bshields.config.rShieldTexture, 256, 256},
	{bshields.config.dShieldTexture, 256, 256}
}

hook.Add( "InitPostEntity", "bshields_init_client", function()
	bshields_materials_reload()
end)

surface.CreateFont( "bshields.HudFont", {
	font = "BFHud",
	size = ScrH() / 1080 * 18
})
--addons/ballistic_shields/lua/entities/bs_dshield_dooms/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
ENT.PrintName = "Deployed shield"
ENT.Category = "Ballistic shields"

ENT.Spawnable = false
ENT.DisableDuplicator = true

--addons/ballistic_shields/lua/entities/bs_dshield_senat/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
ENT.PrintName = "Deployed shield"
ENT.Category = "Ballistic shields"

ENT.Spawnable = false
ENT.DisableDuplicator = true

--addons/ballistic_shields/lua/ballistic_shields/cl_bs_util.lua:
if SERVER then return end
include( "bs_config.lua" )

net.Receive( "bs_shield_info", function( len, pl )
	LocalPlayer().bs_shieldIndex = net.ReadUInt(16)
end )

local Delay = 0
function bshields_materials_reload()
	for _,v in pairs(bshields.materialstoload) do
		Delay = Delay + 0.2
		timer.Simple( Delay, function() surface.GetURL(v[1], v[2], v[3]) end )
	end

	bshields.hshield_webmat = surface.GetURL(bshields.config.hShieldTexture, 256, 256)
	bshields.rshield_webmat = surface.GetURL(bshields.config.rShieldTexture, 256, 256)
	bshields.dshield_webmat = surface.GetURL(bshields.config.dShieldTexture, 256, 256)
end

bshields.materialstoload = {
	{bshields.config.hShieldTexture, 256, 256},
	{bshields.config.rShieldTexture, 256, 256},
	{bshields.config.dShieldTexture, 256, 256}
}

hook.Add( "InitPostEntity", "bshields_init_client", function()
	bshields_materials_reload()
end)

surface.CreateFont( "bshields.HudFont", {
	font = "BFHud",
	size = ScrH() / 1080 * 18
})
--addons/ballistic_shields/lua/bs_config.lua:
include( "ballistic_shields/sh_bs_util.lua" )

--------------------- BALLISTIC SHIELDS V1.1.4 -------------------------

---- CONFIG ----
-- AVALAIBLE LANGUAGES - English
bshields.config.language = "German"
-- DISABLE HUD
bshields.config.disablehud = false
-- MINIMUM RIOT SHIELD DAMAGE
bshields.config.rshielddmgmin = 16
-- MAXIMUM RIOT SHIELD DAMAGE
bshields.config.rshielddmgmax = 25
-- HEAVY SHIELD EXPLOSION DAMAGE REDUCITON (IN %)
bshields.config.hshieldexpl = 25
-- HEAVY SHIELD MELEE DAMAGE REDUCTION (IN %)
bshields.config.hshieldmelee = 0
-- RIOT SHIELD MELEE DAMAGE REDUCTION (IN %)
bshields.config.rshieldmelee = 60
-- HEAVY SHIELD BREACH COOLDOWN (IN SECONDS)
bshields.config.hshieldcd = 20
-- DOOR RESPAWN TIMER (IN SECONDS)
bshields.config.doorrespawn = 60
-- MAXIMUM AMOUNT OF DEPLOYED SHIELDS
bshields.config.maxshields = 3
-- SHOULD FADING DOORS BE BREACHABLE?
bshields.config.breachfdoors = false
-- ALLOW BREACHING UNOWNED DOORS
bshields.config.breachudoors = false

-------- CUSTOM TEXTURES, LEAVE "" FOR DEFAULT "POLICE" TEXT. ----------
--- FOR EDITING USE THE 256x256 TEMPLATE INCLUDED IN THE MAIN FOLDER ---

-- HEAVY SHIELD
bshields.config.hShieldTexture = "https://i.imgur.com/afyGHiK.png"
-- RIOT SHIELD
bshields.config.rShieldTexture = "https://i.imgur.com/afyGHiK.png"
-- DEPLOYABLE SHIELD
bshields.config.dShieldTexture = "https://i.imgur.com/afyGHiK.png" 
-- PLAYERS MIGHT HAVE TO RECONNECT IN ORDER TO SEE THE NEW TEXTURES! ---

-- [CW2 ONLY] YOU NEED THIS ADDON: https://steamcommunity.com/sharedfiles/filedetails/?id=1771994451
-- SHOULD RIOT SHIELD BE BULLETPROOF? --
bshields.config.rshieldbp = true
--addons/ballistic_shields/lua/entities/bs_dshield_st/cl_init.lua:
include("shared.lua")
include("ballistic_shields/cl_bs_util.lua")

ENT.RenderGroup = RENDERGROUP_BOTH

function ENT:Draw()
	self:DrawModel()
end   
--addons/ballistic_shields/lua/bs_config.lua:
include( "ballistic_shields/sh_bs_util.lua" )

--------------------- BALLISTIC SHIELDS V1.1.4 -------------------------

---- CONFIG ----
-- AVALAIBLE LANGUAGES - English
bshields.config.language = "German"
-- DISABLE HUD
bshields.config.disablehud = false
-- MINIMUM RIOT SHIELD DAMAGE
bshields.config.rshielddmgmin = 16
-- MAXIMUM RIOT SHIELD DAMAGE
bshields.config.rshielddmgmax = 25
-- HEAVY SHIELD EXPLOSION DAMAGE REDUCITON (IN %)
bshields.config.hshieldexpl = 25
-- HEAVY SHIELD MELEE DAMAGE REDUCTION (IN %)
bshields.config.hshieldmelee = 0
-- RIOT SHIELD MELEE DAMAGE REDUCTION (IN %)
bshields.config.rshieldmelee = 60
-- HEAVY SHIELD BREACH COOLDOWN (IN SECONDS)
bshields.config.hshieldcd = 20
-- DOOR RESPAWN TIMER (IN SECONDS)
bshields.config.doorrespawn = 60
-- MAXIMUM AMOUNT OF DEPLOYED SHIELDS
bshields.config.maxshields = 3
-- SHOULD FADING DOORS BE BREACHABLE?
bshields.config.breachfdoors = false
-- ALLOW BREACHING UNOWNED DOORS
bshields.config.breachudoors = false

-------- CUSTOM TEXTURES, LEAVE "" FOR DEFAULT "POLICE" TEXT. ----------
--- FOR EDITING USE THE 256x256 TEMPLATE INCLUDED IN THE MAIN FOLDER ---

-- HEAVY SHIELD
bshields.config.hShieldTexture = "https://i.imgur.com/afyGHiK.png"
-- RIOT SHIELD
bshields.config.rShieldTexture = "https://i.imgur.com/afyGHiK.png"
-- DEPLOYABLE SHIELD
bshields.config.dShieldTexture = "https://i.imgur.com/afyGHiK.png" 
-- PLAYERS MIGHT HAVE TO RECONNECT IN ORDER TO SEE THE NEW TEXTURES! ---

-- [CW2 ONLY] YOU NEED THIS ADDON: https://steamcommunity.com/sharedfiles/filedetails/?id=1771994451
-- SHOULD RIOT SHIELD BE BULLETPROOF? --
bshields.config.rshieldbp = true
--addons/ballistic_shields/lua/ballistic_shields/sh_bs_util.lua:
bshields = bshields or {}
bshields.config = bshields.config or {}

bshields.shields = {
	{
		[1] = {
			["angles"] = Angle(4,6,-14),
			["position"] = Vector(5,10,-5)
		},
		[2] = {
			["angles"] = Angle(6,1,-15),
			["position"] = Vector(6,10,-5)
		},
		[3] = {
			["angles"] = Angle(4,6,-14),
			["position"] = Vector(5,10,-5)
		}
	},
	{
		[1] = {
			["angles"] = Angle(-12,0,0),
			["position"] = Vector(6,-4,-8)
		},
		[2] = {
			["angles"] = Angle(-12,0,0),
			["position"] = Vector(1,-3,-12)
		},
		[3] = {
			["angles"] = Angle(-12,0,0),
			["position"] = Vector(6,-3,-12)
		}
	},
	{
		[1] = {
			["angles"] = Angle(70,78,-16),
			["position"] = Vector(1,-7,-13)
		},
		[2] = {
			["angles"] = Angle(70,78,-16),
			["position"] = Vector(1,-6,-22)
		},
		[3] = {
			["angles"] = Angle(70,78,-16),
			["position"] = Vector(1,-8,-12)
		}
	}
}

--addons/ballistic_shields/lua/bs_config.lua:
include( "ballistic_shields/sh_bs_util.lua" )

--------------------- BALLISTIC SHIELDS V1.1.4 -------------------------

---- CONFIG ----
-- AVALAIBLE LANGUAGES - English
bshields.config.language = "German"
-- DISABLE HUD
bshields.config.disablehud = false
-- MINIMUM RIOT SHIELD DAMAGE
bshields.config.rshielddmgmin = 16
-- MAXIMUM RIOT SHIELD DAMAGE
bshields.config.rshielddmgmax = 25
-- HEAVY SHIELD EXPLOSION DAMAGE REDUCITON (IN %)
bshields.config.hshieldexpl = 25
-- HEAVY SHIELD MELEE DAMAGE REDUCTION (IN %)
bshields.config.hshieldmelee = 0
-- RIOT SHIELD MELEE DAMAGE REDUCTION (IN %)
bshields.config.rshieldmelee = 60
-- HEAVY SHIELD BREACH COOLDOWN (IN SECONDS)
bshields.config.hshieldcd = 20
-- DOOR RESPAWN TIMER (IN SECONDS)
bshields.config.doorrespawn = 60
-- MAXIMUM AMOUNT OF DEPLOYED SHIELDS
bshields.config.maxshields = 3
-- SHOULD FADING DOORS BE BREACHABLE?
bshields.config.breachfdoors = false
-- ALLOW BREACHING UNOWNED DOORS
bshields.config.breachudoors = false

-------- CUSTOM TEXTURES, LEAVE "" FOR DEFAULT "POLICE" TEXT. ----------
--- FOR EDITING USE THE 256x256 TEMPLATE INCLUDED IN THE MAIN FOLDER ---

-- HEAVY SHIELD
bshields.config.hShieldTexture = "https://i.imgur.com/afyGHiK.png"
-- RIOT SHIELD
bshields.config.rShieldTexture = "https://i.imgur.com/afyGHiK.png"
-- DEPLOYABLE SHIELD
bshields.config.dShieldTexture = "https://i.imgur.com/afyGHiK.png" 
-- PLAYERS MIGHT HAVE TO RECONNECT IN ORDER TO SEE THE NEW TEXTURES! ---

-- [CW2 ONLY] YOU NEED THIS ADDON: https://steamcommunity.com/sharedfiles/filedetails/?id=1771994451
-- SHOULD RIOT SHIELD BE BULLETPROOF? --
bshields.config.rshieldbp = true
--addons/ballistic_shields/lua/entities/bs_hshield_senat/cl_init.lua:
include("shared.lua")
include("ballistic_shields/cl_bs_util.lua")

ENT.RenderGroup = RENDERGROUP_BOTH

function ENT:Draw()
	self:DrawModel()
end   
--addons/ballistic_shields/lua/ballistic_shields/sh_bs_util.lua:
bshields = bshields or {}
bshields.config = bshields.config or {}

bshields.shields = {
	{
		[1] = {
			["angles"] = Angle(4,6,-14),
			["position"] = Vector(5,10,-5)
		},
		[2] = {
			["angles"] = Angle(6,1,-15),
			["position"] = Vector(6,10,-5)
		},
		[3] = {
			["angles"] = Angle(4,6,-14),
			["position"] = Vector(5,10,-5)
		}
	},
	{
		[1] = {
			["angles"] = Angle(-12,0,0),
			["position"] = Vector(6,-4,-8)
		},
		[2] = {
			["angles"] = Angle(-12,0,0),
			["position"] = Vector(1,-3,-12)
		},
		[3] = {
			["angles"] = Angle(-12,0,0),
			["position"] = Vector(6,-3,-12)
		}
	},
	{
		[1] = {
			["angles"] = Angle(70,78,-16),
			["position"] = Vector(1,-7,-13)
		},
		[2] = {
			["angles"] = Angle(70,78,-16),
			["position"] = Vector(1,-6,-22)
		},
		[3] = {
			["angles"] = Angle(70,78,-16),
			["position"] = Vector(1,-8,-12)
		}
	}
}

--addons/ballistic_shields/lua/entities/bs_shield/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
ENT.PrintName = "Deployed shield"
ENT.Category = "Ballistic shields"

ENT.Spawnable = false
ENT.DisableDuplicator = true

function ENT:Use( activator )
	if IsValid(activator) && activator:IsPlayer() && self.Owner == activator then
		activator:Give("deployable_shield")
		activator:EmitSound("npc/combine_soldier/gear2.wav")

		table.RemoveByValue(activator.bs_shields, self)

		self:Remove()
	end
end
--addons/ballistic_shields/lua/ballistic_shields/cl_bs_util.lua:
if SERVER then return end
include( "bs_config.lua" )

net.Receive( "bs_shield_info", function( len, pl )
	LocalPlayer().bs_shieldIndex = net.ReadUInt(16)
end )

local Delay = 0
function bshields_materials_reload()
	for _,v in pairs(bshields.materialstoload) do
		Delay = Delay + 0.2
		timer.Simple( Delay, function() surface.GetURL(v[1], v[2], v[3]) end )
	end

	bshields.hshield_webmat = surface.GetURL(bshields.config.hShieldTexture, 256, 256)
	bshields.rshield_webmat = surface.GetURL(bshields.config.rShieldTexture, 256, 256)
	bshields.dshield_webmat = surface.GetURL(bshields.config.dShieldTexture, 256, 256)
end

bshields.materialstoload = {
	{bshields.config.hShieldTexture, 256, 256},
	{bshields.config.rShieldTexture, 256, 256},
	{bshields.config.dShieldTexture, 256, 256}
}

hook.Add( "InitPostEntity", "bshields_init_client", function()
	bshields_materials_reload()
end)

surface.CreateFont( "bshields.HudFont", {
	font = "BFHud",
	size = ScrH() / 1080 * 18
})
--addons/ballistic_shields/lua/ballistic_shields/sh_bs_util.lua:
bshields = bshields or {}
bshields.config = bshields.config or {}

bshields.shields = {
	{
		[1] = {
			["angles"] = Angle(4,6,-14),
			["position"] = Vector(5,10,-5)
		},
		[2] = {
			["angles"] = Angle(6,1,-15),
			["position"] = Vector(6,10,-5)
		},
		[3] = {
			["angles"] = Angle(4,6,-14),
			["position"] = Vector(5,10,-5)
		}
	},
	{
		[1] = {
			["angles"] = Angle(-12,0,0),
			["position"] = Vector(6,-4,-8)
		},
		[2] = {
			["angles"] = Angle(-12,0,0),
			["position"] = Vector(1,-3,-12)
		},
		[3] = {
			["angles"] = Angle(-12,0,0),
			["position"] = Vector(6,-3,-12)
		}
	},
	{
		[1] = {
			["angles"] = Angle(70,78,-16),
			["position"] = Vector(1,-7,-13)
		},
		[2] = {
			["angles"] = Angle(70,78,-16),
			["position"] = Vector(1,-6,-22)
		},
		[3] = {
			["angles"] = Angle(70,78,-16),
			["position"] = Vector(1,-8,-12)
		}
	}
}

--addons/ballistic_shields/lua/ballistic_shields/cl_bs_util.lua:
if SERVER then return end
include( "bs_config.lua" )

net.Receive( "bs_shield_info", function( len, pl )
	LocalPlayer().bs_shieldIndex = net.ReadUInt(16)
end )

local Delay = 0
function bshields_materials_reload()
	for _,v in pairs(bshields.materialstoload) do
		Delay = Delay + 0.2
		timer.Simple( Delay, function() surface.GetURL(v[1], v[2], v[3]) end )
	end

	bshields.hshield_webmat = surface.GetURL(bshields.config.hShieldTexture, 256, 256)
	bshields.rshield_webmat = surface.GetURL(bshields.config.rShieldTexture, 256, 256)
	bshields.dshield_webmat = surface.GetURL(bshields.config.dShieldTexture, 256, 256)
end

bshields.materialstoload = {
	{bshields.config.hShieldTexture, 256, 256},
	{bshields.config.rShieldTexture, 256, 256},
	{bshields.config.dShieldTexture, 256, 256}
}

hook.Add( "InitPostEntity", "bshields_init_client", function()
	bshields_materials_reload()
end)

surface.CreateFont( "bshields.HudFont", {
	font = "BFHud",
	size = ScrH() / 1080 * 18
})
--addons/ballistic_shields/lua/bs_config.lua:
include( "ballistic_shields/sh_bs_util.lua" )

--------------------- BALLISTIC SHIELDS V1.1.4 -------------------------

---- CONFIG ----
-- AVALAIBLE LANGUAGES - English
bshields.config.language = "German"
-- DISABLE HUD
bshields.config.disablehud = false
-- MINIMUM RIOT SHIELD DAMAGE
bshields.config.rshielddmgmin = 16
-- MAXIMUM RIOT SHIELD DAMAGE
bshields.config.rshielddmgmax = 25
-- HEAVY SHIELD EXPLOSION DAMAGE REDUCITON (IN %)
bshields.config.hshieldexpl = 25
-- HEAVY SHIELD MELEE DAMAGE REDUCTION (IN %)
bshields.config.hshieldmelee = 0
-- RIOT SHIELD MELEE DAMAGE REDUCTION (IN %)
bshields.config.rshieldmelee = 60
-- HEAVY SHIELD BREACH COOLDOWN (IN SECONDS)
bshields.config.hshieldcd = 20
-- DOOR RESPAWN TIMER (IN SECONDS)
bshields.config.doorrespawn = 60
-- MAXIMUM AMOUNT OF DEPLOYED SHIELDS
bshields.config.maxshields = 3
-- SHOULD FADING DOORS BE BREACHABLE?
bshields.config.breachfdoors = false
-- ALLOW BREACHING UNOWNED DOORS
bshields.config.breachudoors = false

-------- CUSTOM TEXTURES, LEAVE "" FOR DEFAULT "POLICE" TEXT. ----------
--- FOR EDITING USE THE 256x256 TEMPLATE INCLUDED IN THE MAIN FOLDER ---

-- HEAVY SHIELD
bshields.config.hShieldTexture = "https://i.imgur.com/afyGHiK.png"
-- RIOT SHIELD
bshields.config.rShieldTexture = "https://i.imgur.com/afyGHiK.png"
-- DEPLOYABLE SHIELD
bshields.config.dShieldTexture = "https://i.imgur.com/afyGHiK.png" 
-- PLAYERS MIGHT HAVE TO RECONNECT IN ORDER TO SEE THE NEW TEXTURES! ---

-- [CW2 ONLY] YOU NEED THIS ADDON: https://steamcommunity.com/sharedfiles/filedetails/?id=1771994451
-- SHOULD RIOT SHIELD BE BULLETPROOF? --
bshields.config.rshieldbp = true
--addons/ballistic_shields/lua/ballistic_shields/cl_bs_util.lua:
if SERVER then return end
include( "bs_config.lua" )

net.Receive( "bs_shield_info", function( len, pl )
	LocalPlayer().bs_shieldIndex = net.ReadUInt(16)
end )

local Delay = 0
function bshields_materials_reload()
	for _,v in pairs(bshields.materialstoload) do
		Delay = Delay + 0.2
		timer.Simple( Delay, function() surface.GetURL(v[1], v[2], v[3]) end )
	end

	bshields.hshield_webmat = surface.GetURL(bshields.config.hShieldTexture, 256, 256)
	bshields.rshield_webmat = surface.GetURL(bshields.config.rShieldTexture, 256, 256)
	bshields.dshield_webmat = surface.GetURL(bshields.config.dShieldTexture, 256, 256)
end

bshields.materialstoload = {
	{bshields.config.hShieldTexture, 256, 256},
	{bshields.config.rShieldTexture, 256, 256},
	{bshields.config.dShieldTexture, 256, 256}
}

hook.Add( "InitPostEntity", "bshields_init_client", function()
	bshields_materials_reload()
end)

surface.CreateFont( "bshields.HudFont", {
	font = "BFHud",
	size = ScrH() / 1080 * 18
})
--addons/star_wars_detpack/lua/entities/cod-c4/cl_init.lua:
include( "shared.lua" )

ENT.RenderGroup = RENDERGROUP_TRANSLUCENT

function ENT:Draw()
	self:DrawShadow( false )
	self:DrawModel()
end
--lua/entities/ent_baby_explosive2/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
ENT.Author = "LordiAnders"
ENT.Spawnable = false
ENT.AdminSpawnable = false
--lua/entities/ent_chemlight/shared.lua:
ENT.Type			= "anim"  
ENT.Base			= "base_gmodentity"  
ENT.PrintName		= "Chemlight"
ENT.Author			= "Patrick Hunt"
ENT.Information		= ""
ENT.Category		= "Fun + Games"
ENT.Spawnable		= true
ENT.AdminSpawnable	= true


--lua/entities/ent_chemlight_glow_blue/shared.lua:
ENT.Type			= "anim"  
ENT.Base			= "base_gmodentity"  
ENT.PrintName		= "Chemlight Glow Blue"
ENT.Author			= "Patrick Hunt"
ENT.Information		= "Alright, you got me. It's a fake glow."
ENT.Category		= "Glow Sticks"
ENT.Spawnable		= false
ENT.AdminSpawnable	= false
--lua/entities/ent_chemlight_glow_cyan/cl_init.lua:
include("shared.lua")

function ENT:Initialize()
end

function ENT:Draw()
end

function ENT:Think()
	local rgba = self:GetColor();
    local dlight = DynamicLight( self:EntIndex() )
	if ( dlight ) then
		dlight.Pos = self:GetPos()
		dlight.r = 0 * (GetGlobalFloat( "global_Cheml_Brightness", 80 ) / 100)
		dlight.g = 255 * (GetGlobalFloat( "global_Cheml_Brightness", 80 ) / 100)
		dlight.b = 255 * (GetGlobalFloat( "global_Cheml_Brightness", 80 ) / 100)
		dlight.Brightness = 0
		dlight.Size = 256 * (GetGlobalFloat( "global_Cheml_Range", 100 ) / 100)
		dlight.Decay = 0
		dlight.DieTime = CurTime() + 0.01
	end
end
--lua/entities/ent_chemlight_glow_purple/cl_init.lua:
include("shared.lua")

function ENT:Initialize()
end

function ENT:Draw()
end

function ENT:Think()
	local rgba = self:GetColor();
    local dlight = DynamicLight( self:EntIndex() )
	if ( dlight ) then
		dlight.Pos = self:GetPos()
		dlight.r = 255 * (GetGlobalFloat( "global_Cheml_Brightness", 80 ) / 100)
		dlight.g = 0 * (GetGlobalFloat( "global_Cheml_Brightness", 80 ) / 100)
		dlight.b = 255 * (GetGlobalFloat( "global_Cheml_Brightness", 80 ) / 100)
		dlight.Brightness = 0
		dlight.Size = 256 * (GetGlobalFloat( "global_Cheml_Range", 100 ) / 100)
		dlight.Decay = 0
		dlight.DieTime = CurTime() + 0.05
	end
end
--lua/entities/ent_chemlight_glow_purple/shared.lua:
ENT.Type			= "anim"  
ENT.Base			= "base_gmodentity"  
ENT.PrintName		= "Chemlight Glow Purple"
ENT.Author			= "Patrick Hunt"
ENT.Information		= "Alright, you got me. It's a fake glow."
ENT.Category		= "Glow Sticks"
ENT.Spawnable		= false
ENT.AdminSpawnable	= false
--lua/entities/ent_lightsaber.lua:

--[[

Editing the Lightsabers.

Once you unpack the lightsaber addon, you are voided of any support as to why it doesn't work.
I can't possibly provide support for all the edits and I can't know what your edits broke or whatever.

-------------------------------- DO NOT REUPLOAD THIS ADDON IN ANY SHAPE OF FORM --------------------------------
-------------------------------- DO NOT REUPLOAD THIS ADDON IN ANY SHAPE OF FORM --------------------------------
-------------------------------- DO NOT REUPLOAD THIS ADDON IN ANY SHAPE OF FORM --------------------------------
-------------------------------- DO NOT REUPLOAD THIS ADDON IN ANY SHAPE OF FORM --------------------------------
-------------------------------- DO NOT REUPLOAD THIS ADDON IN ANY SHAPE OF FORM --------------------------------

-------------------------- DO NOT EDIT ANYTHING DOWN BELOW OR YOU LOSE SUPPORT FROM ME --------------------------
-------------------------- DO NOT EDIT ANYTHING DOWN BELOW OR YOU LOSE SUPPORT FROM ME --------------------------
-------------------------- DO NOT EDIT ANYTHING DOWN BELOW OR YOU LOSE SUPPORT FROM ME --------------------------
-------------------------- DO NOT EDIT ANYTHING DOWN BELOW OR YOU LOSE SUPPORT FROM ME --------------------------
-------------------------- DO NOT EDIT ANYTHING DOWN BELOW OR YOU LOSE SUPPORT FROM ME --------------------------
-------------------------- DO NOT EDIT ANYTHING DOWN BELOW OR YOU LOSE SUPPORT FROM ME --------------------------

]]

AddCSLuaFile()

ENT.Type = "anim"
ENT.Base = "base_anim"

ENT.PrintName = "Lightsaber"
ENT.Category = "Robotboy655's Entities"

ENT.Editable = true
ENT.Spawnable = true

ENT.RenderGroup = RENDERGROUP_BOTH
ENT.AutomaticFrameAdvance = true

ENT.IsLightsaber = true

-- --------------------------------------------------------- Initialization --------------------------------------------------------- --

function ENT:SetupDataTables()
	self:NetworkVar( "Float", 0, "LengthAnimation" )
	self:NetworkVar( "Float", 1, "BladeWidth", { KeyName = "BladeWidth", Edit = { type = "Float", category = "Blade", min = 2, max = 4, order = 1 } } )
	self:NetworkVar( "Float", 2, "MaxLength", { KeyName = "MaxLength", Edit = { type = "Float", category = "Blade", min = 32, max = 64, order = 2 } } )

	self:NetworkVar( "Bool", 0, "Enabled" )
	self:NetworkVar( "Bool", 1, "DarkInner", { KeyName = "DarkInner", Edit = { type = "Boolean", category = "Blade", order = 3 } } )
	self:NetworkVar( "Bool", 2, "WorksUnderwater" )

	self:NetworkVar( "Vector", 0, "CrystalColor", { KeyName = "CrystalColor", Edit = { type = "VectorColor", category = "Hilt", order = 4 } } )

	if ( SERVER ) then
		self:SetLengthAnimation( 0 )
		self:SetBladeWidth( 2 )
		self:SetMaxLength( 42 )

		self:SetDarkInner( false )
		self:SetEnabled( false )
		self:SetWorksUnderwater( true )

		self:NetworkVarNotify( "Enabled", self.OnEnabledOrDisabldd )
	end
end

function ENT:GetBladeLength()
	return self:GetLengthAnimation() * self:GetMaxLength()
end

function ENT:SetBladeLength( val )
	self:SetLengthAnimation( val / self:GetMaxLength() )
	MsgN( "Lightsaber.SetBladeLength is deprecated!" )
end

function ENT:Initialize()
	if ( SERVER ) then
		self:PhysicsInit( SOLID_VPHYSICS )
		self:SetMoveType( MOVETYPE_VPHYSICS )
		self:SetSolid( SOLID_VPHYSICS )

		self.LoopSound = self.LoopSound or ( "lightsaber/saber_loop" .. math.random( 1, 8 ) .. ".wav" )
		self.SwingSound = self.SwingSound or ( "lightsaber/saber_swing" .. math.random( 1, 2 ) .. ".wav" )
		self.OnSound = self.OnSound or ( "lightsaber/saber_on" .. math.random( 1, 2 ) .. ".wav" )
		self.OffSound = self.OffSound or ( "lightsaber/saber_off" .. math.random( 1, 2 ) .. ".wav" )

		--self:OnEnabled()
	else
		language.Add( self.ClassName, self.PrintName )
		killicon.AddAlias( "ent_lightsaber", "weapon_lightsaber" )
	end
end

-- --------------------------------------------------------- Enable / Disable --------------------------------------------------------- --

function ENT:OnEnabled()
	if ( CLIENT ) then return end
	if ( self:WaterLevel() > 2 and !self:GetWorksUnderwater() ) then return end

	if ( !self:GetEnabled() and self.OnSound ) then self:EmitSound( self.OnSound, nil, nil, 0.4 ) end

	self.SoundLoop = CreateSound( self, Sound( self.LoopSound ) )
	if ( self.SoundLoop ) then self.SoundLoop:Play() self.SoundLoop:ChangeVolume( 0, 0 ) end

	self.SoundSwing = CreateSound( self, Sound( self.SwingSound ) )
	if ( self.SoundSwing ) then self.SoundSwing:Play() self.SoundSwing:ChangeVolume( 0, 0 ) end

	self.SoundHit = CreateSound( self, Sound( self.HitSound or "lightsaber/saber_hit.wav" ) )
	if ( self.SoundHit ) then self.SoundHit:Play() self.SoundHit:ChangeVolume( 0, 0 ) end
end

function ENT:OnDisabled( bRemove )
	if ( CLIENT ) then
		if ( bRemove ) then rb655_SaberClean( self:EntIndex() ) end
		return
	end

	if ( self:GetEnabled() and self.OffSound ) then self:EmitSound( self.OffSound, nil, nil, 0.4 ) end

	if ( self.SoundLoop ) then self.SoundLoop:Stop() self.SoundLoop = nil end
	if ( self.SoundSwing ) then self.SoundSwing:Stop() self.SoundSwing = nil end
	if ( self.SoundHit ) then self.SoundHit:Stop() self.SoundHit = nil end
end

function ENT:OnEnabledOrDisabldd( name, old, new )

	if ( old == new ) then return end

	if ( new ) then
		self:OnEnabled()
	else
		self:OnDisabled()
	end
end

function ENT:OnRemove()
	self:OnDisabled( true )
end

-- --------------------------------------------------------- Misc --------------------------------------------------------- --

function ENT:GetSaberPosAng( num, side )
	num = num or 1

	local attachment = self:LookupAttachment( "blade" .. num )
	if ( side ) then
		attachment = self:LookupAttachment( "quillon" .. num )
	end

	if ( attachment > 0 ) then
		local PosAng = self:GetAttachment( attachment )

		return PosAng.Pos, PosAng.Ang:Forward()
	end

	return self:LocalToWorld( Vector( 1, -0.58, -0.25 ) ), -self:GetAngles():Forward()

end

function ENT:UpdateRenderBounds()

	local width = self:GetBladeWidth() / 1.5
	local mins, maxs = self:GetModelBounds()
	mins = Vector( -self:GetBladeLength(), -width, -width )
	maxs = Vector( maxs.x, width, width )

	self:SetRenderBounds( mins, maxs )

end

function ENT:Draw()

	self:UpdateRenderBounds()

	--render.SetColorModulation( 1, 1, 1 )
	self:DrawModel()

	if ( halo.RenderedEntity and IsValid( halo.RenderedEntity() ) and halo.RenderedEntity() == self ) then return end

	local clr = self:GetCrystalColor() * 255
	clr = Color( clr.x, clr.y, clr.z )

	local bladesFound = false -- true if the model is OLD and does not have blade attachments
	local blades = 0
	for id, t in ipairs( self:GetAttachments() or {} ) do
		if ( !string.match( t.name, "blade(%d+)" ) and !string.match( t.name, "quillon(%d+)" ) ) then continue end

		local bladeNum = string.match( t.name, "blade(%d+)" )
		local quillonNum = string.match( t.name, "quillon(%d+)" )

		if ( bladeNum and self:LookupAttachment( "blade" .. bladeNum ) > 0 ) then
			blades = blades + 1
			local pos, dir = self:GetSaberPosAng( bladeNum )
			rb655_RenderBlade( pos, dir, self:GetBladeLength(), self:GetMaxLength(), self:GetBladeWidth(), clr, self:GetDarkInner(), self:EntIndex(), self:WaterLevel() > 2, false, blades )
			bladesFound = true
		end

		if ( quillonNum and self:LookupAttachment( "quillon" .. quillonNum ) > 0 ) then
			blades = blades + 1
			local pos, dir = self:GetSaberPosAng( quillonNum, true )
			rb655_RenderBlade( pos, dir, self:GetBladeLength(), self:GetMaxLength(), self:GetBladeWidth(), clr, self:GetDarkInner(), self:EntIndex(), self:WaterLevel() > 2, true, blades )
		end

	end

	if ( !bladesFound ) then
		local pos, dir = self:GetSaberPosAng()
		rb655_RenderBlade( pos, dir, self:GetBladeLength(), self:GetMaxLength(), self:GetBladeWidth(), clr, self:GetDarkInner(), self:EntIndex(), self:WaterLevel() > 2 )
	end

end

if ( CLIENT ) then return end

function ENT:PostEntityPaste()
	if ( !game.SinglePlayer() ) then
		self:SetMaxLength( math.Clamp( self:GetMaxLength(), 32, 64 ) )
		self:SetBladeWidth( math.Clamp( self:GetBladeWidth(), 2, 4 ) )
	end
end

function ENT:OnTakeDamage( dmginfo )

	-- React physically when shot/getting blown
	self:TakePhysicsDamage( dmginfo )

end

function ENT:Think()

	if ( !self:GetEnabled() and self:GetLengthAnimation() != 0 ) then
		self:SetLengthAnimation( math.Approach( self:GetLengthAnimation(), 0, FrameTime() * 3 ) )
	elseif ( self:GetEnabled() and self:GetLengthAnimation() != 1 ) then
		self:SetLengthAnimation( math.Approach( self:GetLengthAnimation(), 1, FrameTime() * 10 ) )
	end

	if ( self:GetEnabled() and !self:GetWorksUnderwater() and self:WaterLevel() > 2 ) then
		self:SetEnabled( false )
		--self:EmitSound( self.OffSound )
	end

	if ( self:GetBladeLength() <= 0 ) then
		if ( self.SoundSwing ) then self.SoundSwing:ChangeVolume( 0, 0 ) end
		if ( self.SoundLoop ) then self.SoundLoop:ChangeVolume( 0, 0 ) end
		if ( self.SoundHit ) then self.SoundHit:ChangeVolume( 0, 0 ) end
		return -- Disable for commented out code below?
	end

	local pos, ang = self:GetSaberPosAng()
	local hit = self:BladeThink( pos, ang )
	if ( self:LookupAttachment( "blade2" ) > 0 ) then
		local pos2, ang2 = self:GetSaberPosAng( 2 )
		local hit_2 = self:BladeThink( pos2, ang2 )
		hit = hit or hit_2
	end

	if ( self.SoundHit ) then
		if ( hit ) then self.SoundHit:ChangeVolume( 0.1, 0 ) else self.SoundHit:ChangeVolume( 0, 0 ) end
	end

	if ( self.SoundSwing ) then
		--local ang = self:GetAngles()
		if ( self.LastAng != ang ) then
			self.LastAng = self.LastAng or ang
			self.SoundSwing:ChangeVolume( math.Clamp( ang:Distance( self.LastAng ) / 2, 0, 1 ), 0 )
			--self.SoundSwing:ChangeVolume( math.Rand( 0, 1 ), 0 ) -- For some reason if I spam always 1, the sound doesn't loop
			--self.SoundSwing:ChangeVolume( math.min( pos:Distance( self.LastPos ) / 16, 1 ), 0 )
		end
		self.LastAng = ang
	end

	--[[if ( self.SoundSwing ) then
		local owner = self:GetOwner()
		--local ang = self:GetAngles()
		local dist1 = pos:Distance( owner:GetShootPos() )
		local dist2 = (pos+ ang * self:GetBladeLength()):Distance( owner:GetShootPos() )
		local val = (dist1 - dist2) / self:GetBladeLength()
		print(val,CurTime())
		--if ( self.LastAng != ang ) then
			self.LastAng = self.LastAng or ang
			self.SoundSwing:ChangeVolume( math.Clamp( val, 0, 1 ), 0 )
			--self.SoundSwing:ChangeVolume( math.Clamp( ang:Distance( self.LastAng ) / 2, 0, 1 ), 0 )


			--self.SoundSwing:ChangeVolume( math.Rand( 0, 1 ), 0 ) -- For some reason if I spam always 1, the sound doesn't loop
			--self.SoundSwing:ChangeVolume( math.min( pos:Distance( self.LastPos ) / 16, 1 ), 0 )
		--end
		self.LastAng = ang
	end]]

	local s = 1
	if ( self:GetBladeLength() < self:GetMaxLength() ) then s = 0 end

	if ( self.SoundLoop ) then
		local spos = pos + ang * self:GetBladeLength()
		if ( self.LastPos != spos ) then
			self.LastPos = self.LastPos or spos
			self.SoundLoop:ChangeVolume( 0.1 + math.Clamp( spos:Distance( self.LastPos ) / 128, 0, s * 0.9 ), 0 )
			--self.SoundLoop:ChangeVolume( 0.1 + math.Clamp( spos:Distance( self.LastPos ) / 32, 0, 0.2 ), 0 )
			--self.SoundLoop:ChangeVolume( 1 - math.min( spos:Distance( self.LastPos ) / 16, 1 ), 0 )
			--self.SoundLoop:ChangeVolume( self:GetBladeLength() / self:GetMaxLength(), 0 )
		end
		self.LastPos = spos
	end

	self:NextThink( CurTime() )
	return true
end

function ENT:BladeThink( startpos, dir )
	local trace = util.TraceHull( {
		start = startpos,
		endpos = startpos + dir * self:GetBladeLength(),
		filter = self,
		--[[mins = Vector( -1, -1, -1 ) * self:GetBladeWidth() / 2,
		maxs = Vector( 1, 1, 1 ) * self:GetBladeWidth() / 2]]
	} )
	local traceBack = util.TraceLine( {
		start = startpos + dir * self:GetBladeLength(),
		endpos = startpos,
		filter = self,
		--mins = Vector( -1, -1, -1 ) * self:GetBladeWidth() / 8,
		--maxs = Vector( 1, 1, 1 ) * self:GetBladeWidth() / 8
	} )

	local hit = false
	if ( trace.Hit and !trace.StartSolid and !trace.HitSky ) then
		rb655_DrawHit( trace )
		rb655_LS_DoDamage( trace, self )
		hit = true
	end

	if ( traceBack.Hit and !traceBack.StartSolid and !traceBack.HitSky ) then
		rb655_DrawHit( traceBack, true )
		rb655_LS_DoDamage( traceBack, self )
		hit = true
	end

	return hit
end

function ENT:Use( activator, caller, useType, value )
	if ( !IsValid( activator ) or !activator:KeyPressed( IN_USE ) ) then return end
	if ( self:WaterLevel() > 2 and !self:GetWorksUnderwater() ) then return end

	--[[if ( self:GetEnabled() ) then
		self:EmitSound( self.OffSound )
	else
		self:EmitSound( self.OnSound )
	end]]

	self:SetEnabled( !self:GetEnabled() )
end

function ENT:SpawnFunction( ply, tr, ClassName )
	if ( !tr.Hit or !ply:CheckLimit( "ent_lightsabers" ) ) then return end

	local ent = ents.Create( ClassName )
	ent:SetPos( tr.HitPos + tr.HitNormal * 2 )

	local ang = ply:EyeAngles()
	ang.p = 0
	ang:RotateAroundAxis( ang:Right(), 180 )
	ent:SetAngles( ang )

	local maxLen = ply:GetInfoNum( "rb655_lightsaber_bladel", 42 )
	local bldWidth = ply:GetInfoNum( "rb655_lightsaber_bladew", 2 )
	if ( !game.SinglePlayer() ) then
		maxLen = math.Clamp( maxLen, 32, 64 )
		bldWidth = math.Clamp( bldWidth, 2, 4 )
	end
	ent:SetMaxLength( maxLen )
	ent:SetBladeWidth( bldWidth )

	local mdl = ply:GetInfo( "rb655_lightsaber_model" )
	local humSnd = ply:GetInfo( "rb655_lightsaber_humsound" )
	local onSnd = ply:GetInfo( "rb655_lightsaber_onsound" )
	local offSnd = ply:GetInfo( "rb655_lightsaber_offsound" )
	local swingSnd = ply:GetInfo( "rb655_lightsaber_swingsound" )

	if ( GetConVarNumber( "rb655_lightsaber_disallow_custom_content" ) > 0 and !game.SinglePlayer() ) then

		if ( list.HasEntry( "LightsaberModels", mdl ) ) then ent:SetModel( mdl ) end

		for k, v in pairs( list.Get( "rb655_LightsaberHumSounds" ) ) do
			if ( v.rb655_lightsaber_humsound == humSnd ) then ent.LoopSound = humSnd end
		end

		for k, v in pairs( list.Get( "rb655_LightsaberIgniteSounds" ) ) do
			if ( v.rb655_lightsaber_onsound == onSnd ) then ent.OnSound = onSnd end
			if ( v.rb655_lightsaber_offsound == offSnd ) then ent.OffSound = offSnd end
		end

		for k, v in pairs( list.Get( "rb655_LightsaberSwingSounds" ) ) do
			if ( v.rb655_lightsaber_swingsound == swingSnd ) then ent.SwingSound = swingSnd end
		end
	else
		ent:SetModel( mdl )
		ent.LoopSound = humSnd
		ent.SwingSound = swingSnd
		ent.OnSound = onSnd
		ent.OffSound = offSnd
	end

	-- Sync values from the tool
	ent:SetCrystalColor( Vector( ply:GetInfo( "rb655_lightsaber_red" ), ply:GetInfo( "rb655_lightsaber_green" ), ply:GetInfo( "rb655_lightsaber_blue" ) ) / 255 )
	ent:SetDarkInner( ply:GetInfo( "rb655_lightsaber_dark" ) == "1" )

	ent:Spawn()
	ent:Activate()

	-- Start enabled!
	ent:SetEnabled( true )

	ent.Owner = ply
	ent.Color = ent:GetColor()

	local phys = ent:GetPhysicsObject()
	if ( IsValid( phys ) ) then phys:Wake() end

	if ( IsValid( ply ) ) then
		ply:AddCount( "ent_lightsabers", ent )
		ply:AddCleanup( "ent_lightsabers", ent )
	end

	return ent
end

--lua/entities/ent_rw_rocket/shared.lua:
ENT.Type 			= "anim"  
ENT.PrintName			= "CW Rocket"  
ENT.Spawnable			= false
ENT.AdminSpawnable		= false

local rSound = Sound("Missile.Accelerate")

if SERVER then

AddCSLuaFile( "shared.lua" )

function ENT:Initialize()   

self.flightvector = self.Entity:GetForward() * ((30*15.5)/5)
self.timeleft = CurTime() + 15
self.Owner = self:GetOwner()
self.Entity:SetModel( "models/sw_battlefront/weapons/rocketprojectile.mdl" )
self.Entity:PhysicsInit( SOLID_VPHYSICS )      -- Make us work with physics,  	
self.Entity:SetMoveType( MOVETYPE_NONE )   --after all, gmod is a physics  	
self.Entity:SetSolid( SOLID_VPHYSICS )        -- CHEESECAKE!    >:3     
self.Entity:EmitSound(rSound, 75, 100)

--self.Entity:SetColor(Color(128 255 0,255))

Glow = ents.Create("env_sprite")
Glow:SetKeyValue("rendercolor","255, 255, 255")
Glow:SetKeyValue("scale","1")
Glow:SetPos(self.Entity:GetPos())
Glow:SetParent(self.Entity)
Glow:Spawn()
Glow:Activate()
self.Entity:SetNWBool("smoke", 10, true)

end   

 function ENT:Think()

		if self.timeleft < CurTime() then
		self.Entity:Remove()
		end

	Table	={} 			//Table name is table name
	Table[1]	=self.Owner 		//The person holding the gat
	Table[2]	=self.Entity 		//The cap

	local trace = {}
		trace.start = self.Entity:GetPos()
		trace.endpos = self.Entity:GetPos() + self.flightvector
		trace.filter = Table
	local tr = util.TraceLine( trace )
	

		if tr.HitSky then
			self.Entity:Remove()
			return true
		end
	
		if tr.Hit then
				local effectdata = EffectData()
					effectdata:SetOrigin(tr.HitPos)			// Where is hits
					effectdata:SetNormal(tr.HitNormal)		// Direction of particles
					effectdata:SetEntity(self.Entity)		// Who done it?
					effectdata:SetScale(2)			        // Size of explosion
					effectdata:SetRadius(tr.MatType)		// What texture it hits
					effectdata:SetMagnitude(18)			    // Length of explosion trails
					util.Effect( "rw_rocket_explosion", effectdata )
					util.BlastDamage(self.Entity, self:OwnerGet(), tr.HitPos, 450, 1000)
					util.Decal("Scorch", tr.HitPos + tr.HitNormal, tr.HitPos - tr.HitNormal)
					self.Entity:SetNWBool("smoke", false)
					
			self:Explosion()
			self.Entity:Remove()	
		end
	
	self.Entity:SetPos(self.Entity:GetPos() + self.flightvector)
	self.flightvector = self.flightvector - (self.flightvector/1500)  + Vector(math.Rand(-0.2,0.2), math.Rand(-0.2,0.2),math.Rand(-0.2,0.2)) + Vector(0,0,-0.05)
	self.Entity:SetAngles(self.flightvector:Angle() + Angle(0,0,0))
	self.Entity:NextThink( CurTime() )
	return true
	
end
 
 function ENT:Explosion()

	self:EmitSound("BaseExplosionEffect.Sound", 500, 100)	
	self.Entity:StopSound(rSound)

	local shake = ents.Create("env_shake")
		shake:SetOwner(self.Owner)
		shake:SetPos(self.Entity:GetPos())
		shake:SetKeyValue("amplitude", "2000")	// Power of the shake
		shake:SetKeyValue("radius", "900")		// Radius of the shake
		shake:SetKeyValue("duration", "2.5")	// Time of shake
		shake:SetKeyValue("frequency", "1225")	// How har should the screenshake be
		shake:SetKeyValue("spawnflags", "4")	// Spawnflags(In Air)
		shake:Spawn()
		shake:Activate()
		shake:Fire("StartShake", "", 0)
	
	local ar2Explo = ents.Create("env_fire")
		ar2Explo:SetOwner(self.Owner)
		ar2Explo:SetPos(self.Entity:GetPos())
		ar2Explo:Spawn()
		ar2Explo:Activate()
		ar2Explo:Fire("Explode", "", 0)

end

function ENT:OwnerGet()
	if IsValid(self.Owner) then
		return self.Owner
	else
		return self.Entity
	end
end

end

if CLIENT then
 function ENT:Draw()             
 	self.Entity:DrawModel()       // Draw the model.   
 end
 
   function ENT:Initialize()
	pos = self:GetPos()
	self.emitter = ParticleEmitter( pos )
 end
 
 function ENT:Think()
	if (self.Entity:GetNWBool("smoke")) then
	pos = self:GetPos()
		for i=1, (1) do
			local particle = self.emitter:Add( "particle/smokesprites_000"..math.random(1,9), pos + (self:GetForward() * -10 * i))
			if (particle) then
				particle:SetVelocity((self:GetForward() * -400)+(VectorRand()* 10) )
				particle:SetDieTime( math.Rand( 10, 5 ) )
				particle:SetStartAlpha( math.Rand( 85, 115 ) )
				particle:SetEndAlpha( 0 )
				particle:SetStartSize( math.Rand( 10, 1 ) )
				particle:SetEndSize( 1 )
				particle:SetRoll( math.Rand(0, 360) )
				particle:SetRollDelta( math.Rand(-1, 1) )
				particle:SetColor( 115 , 115 , 115 ) 
 				particle:SetAirResistance( 200 ) 
 				particle:SetGravity( Vector( 100, 0, 0 ) ) 	
			end
		
		end
	end
end
end
--addons/hbombs_base/lua/entities/hb_base_dumb.lua:
AddCSLuaFile()
DEFINE_BASECLASS( "base_anim" )

util.PrecacheSound( "BaseExplosionEffect.Sound" ) 

--[[
This is a base for vegetable entities which are not affected by bullets and shit.
OMFG STOP READING THIS!
--]]

local ExploSnds = {}
ExploSnds[1]                         =  "BaseExplosionEffect.Sound"

local Models = {}
Models[1]                            =  "model"

local damagesound                    =  "weapons/rpg/shotdown.wav"

ENT.Spawnable		            	 =  false         
ENT.AdminSpawnable		             =  false         

ENT.PrintName		                 =  "Name"       
ENT.Author			                 =  "Avatar natsu"     
ENT.Contact			                 =  "GTFO" 
ENT.Category                         =  "GTFO!"           

ENT.Model                            =  ""            
ENT.Effect                           =  ""            
ENT.EffectAir                        =  ""            
ENT.EffectWater                      =  ""           
ENT.ExplosionSound                   =  ""           
ENT.ParticleTrail                    =  ""
ENT.NBCEntity                        =  ""   

ENT.ShouldUnweld                     =  false        
ENT.ShouldIgnite                     =  false        
ENT.ShouldExplodeOnImpact            =  false        
ENT.Flamable                         =  false         
ENT.UseRandomSounds                  =  false             
ENT.UseRandomModels                  =  false
ENT.IsNBC                            =  false

ENT.ExplosionDamage                  =  0             
ENT.PhysForce                        =  0             
ENT.ExplosionRadius                  =  0             
ENT.SpecialRadius                    =  0             
ENT.MaxIgnitionTime                  =  5           
ENT.Life                             =  20            
ENT.MaxDelay                         =  2             
ENT.TraceLength                      =  500          
ENT.ImpactSpeed                      =  500          
ENT.Mass                             =  0                       
ENT.Shocktime                        =  1
ENT.HBOWNER                          =  nil             -- don't you fucking touch this.

ENT.DEFAULT_PHYSFORCE  = 0
ENT.DEFAULT_PHYSFORCE_PLYAIR  = 0
ENT.DEFAULT_PHYSFORCE_PLYGROUND = 0

function ENT:Initialize()
 if (SERVER) then
     self:LoadModel()
	 self:PhysicsInit( SOLID_VPHYSICS )
	 self:SetSolid( SOLID_VPHYSICS )
	 self:SetMoveType( MOVETYPE_VPHYSICS )
	 self:SetUseType( ONOFF_USE ) -- doesen't fucking work
	 local phys = self:GetPhysicsObject()
	 local skincount = self:SkinCount()
	 if (phys:IsValid()) then
		 phys:SetMass(self.Mass)
		 phys:Wake()
     end
	 if (skincount > 0) then
	     self:SetSkin(math.random(0,skincount))
	 end
	 self.Exploded = false
	end
end

function ENT:LoadModel()
     if self.UseRandomModels then
	     self:SetModel(table.Random(Models))
	 else
	     self:SetModel(self.Model)
	 end
end

function ENT:Explode()
     if !self.Exploded then return end
	 local pos = self:LocalToWorld(self:OBBCenter())
	 
	 local ent = ents.Create("hb_shockwave_ent")
	 ent:SetPos( pos ) 
	 ent:Spawn()
	 ent:Activate()
	 ent:SetVar("DEFAULT_PHYSFORCE", self.DEFAULT_PHYSFORCE)
	 ent:SetVar("DEFAULT_PHYSFORCE_PLYAIR", self.DEFAULT_PHYSFORCE_PLYAIR)
	 ent:SetVar("DEFAULT_PHYSFORCE_PLYGROUND", self.DEFAULT_PHYSFORCE_PLYGROUND)
	 ent:SetVar("HBOWNER", self.HBOWNER)
	 ent:SetVar("MAX_RANGE",self.ExplosionRadius)
	 ent:SetVar("SHOCKWAVE_INCREMENT",100)
	 ent:SetVar("DELAY",0.01)
	 ent.trace=self.TraceLength
	 ent.decal=self.Decal
	 
	 local ent = ents.Create("hb_shockwave_sound_lowsh")
	 ent:SetPos( pos ) 
	 ent:Spawn()
	 ent:Activate()
	 ent:SetVar("HBOWNER", self.HBOWNER)
	 ent:SetVar("MAX_RANGE",50000)
	 ent:SetVar("SHOCKWAVE_INCREMENT",100)
	 ent:SetVar("DELAY",0.01)
	 ent:SetVar("SOUND", self.ExplosionSound)
	 ent:SetVar("Shocktime", self.Shocktime)

	 for k, v in pairs(ents.FindInSphere(pos,self.SpecialRadius)) do
	     if v:IsValid() then
		     --local phys = v:GetPhysicsObject()
			 local i = 0
		     while i < v:GetPhysicsObjectCount() do
			 phys = v:GetPhysicsObjectNum(i)
			 i = i + 1
			 end
	     end
     end
	 for k, v in pairs(ents.FindInSphere(pos,self.SpecialRadius/2)) do
	     if (self.ShouldIgnite and v != self) then
		     if v:IsOnFire() then
			     v:Extinguish()
			 end
		     v:Ignite(math.Rand(self.MaxIgnitionTime-2,self.MaxIgnitionTime),5)
			 if self:GetClass()=="hb_misc_wildfire_vial" or self:GetClass()=="hb_misc_wildfire_barrel" then
				ParticleEffectAttach( "neuro_wildfire_burn_outside", PATTACH_ABSORIGIN_FOLLOW, v, 0 )
			 end
			 if !v:GetClass()==self:GetClass() then
				ParticleEffectAttach( "neuro_gascan_burn_outside", PATTACH_ABSORIGIN_FOLLOW, v, 0 )
			 end
		 end
     end
		 
	 
		 
	 if(self:WaterLevel() >= 1) then
		 local trdata   = {}
		 local trlength = Vector(0,0,9000)

	     trdata.start   = pos
	     trdata.endpos  = trdata.start + trlength
		 trdata.filter  = self
		 local tr = util.TraceLine(trdata) 

		 local trdat2   = {}
	     trdat2.start   = tr.HitPos
	     trdat2.endpos  = trdata.start - trlength
	     trdat2.filter  = self
		 trdat2.mask    = MASK_WATER + CONTENTS_TRANSLUCENT
			 
		 local tr2 = util.TraceLine(trdat2)
			 
		 if tr2.Hit then
		     ParticleEffect(self.EffectWater, tr2.HitPos, Angle(0,0,0), nil)   
		 end
     else
		 local tracedata    = {}
	     tracedata.start    = pos
		 tracedata.endpos   = tracedata.start - Vector(0, 0, self.TraceLength)
		 tracedata.filter   = self.Entity
				
		 local trace = util.TraceLine(tracedata)
	     
		 if trace.HitWorld then
		     ParticleEffect(self.Effect,pos,Angle(0,0,0),nil)
		 else 
			 ParticleEffect(self.EffectAir,pos,Angle(0,0,0),nil) 
		 end
	 end
	 if self.IsNBC then
	     local nbc = ents.Create(self.NBCEntity)
		 nbc:SetVar("HBOWNER",self.HBOWNER)
		 nbc:SetPos(self:GetPos())
		 nbc:Spawn()
		 nbc:Activate()
	 end
     self:Remove()
end

function ENT:OnTakeDamage(dmginfo)
     if self.Exploded then return end
     self:TakePhysicsDamage(dmginfo)
	 
     if (self.Life <= 0) then return end

	 if self:IsValid() then
	     self.Life = self.Life - dmginfo:GetDamage()
		 if (self.Life <= self.Life/2) and !self.Exploded and self.Flamable then
		     self:Ignite(self.MaxDelay,0)
		 end
		 if (self.Life <= 0) then 
		     timer.Simple(math.Rand(0,self.MaxDelay),function()
			     if !self:IsValid() then return end 
			     self.Exploded = true
			     self:Explode()
			 end)
	     end
	end
end

function ENT:PhysicsCollide( data, physobj )
     if(self.Exploded) then return end
     if(!self:IsValid()) then return end
	 if(self.Life <= 0) then return end

     if self.ShouldExplodeOnImpact then
	     if (data.Speed > self.ImpactSpeed ) then
			 self.Exploded = true
			 self:Explode()
		 end
	 end
end

function ENT:OnRemove()
	 self:StopParticles()
end

if ( CLIENT ) then
     function ENT:Draw()
         self:DrawModel()
     end
end
--addons/hbombs_base/lua/entities/hb_emp.lua:
AddCSLuaFile()

DEFINE_BASECLASS( "hb_base_advanced" )

ENT.Spawnable		            	 =  true         
ENT.AdminSpawnable		             =  true 

ENT.PrintName		                 =  "EMP Device"
ENT.Author			                 =  "Business Cat"
ENT.Contact		                     =  "nah"
ENT.Category                         =  "HBOMBS Misc"

ENT.Model                            =  "models/thedoctor/emp_bomb.mdl"                      
ENT.Effect                           =  "emp_main"                  
ENT.EffectAir                        =  "emp_main"                   
ENT.EffectWater                      =  "water_huge"
ENT.ExplosionSound                   =  "gbombs_5/explosions/special/emp.mp3"
ENT.ArmSound                         =  "npc/roller/mine/rmine_blip3.wav"            
ENT.ActivationSound                  =  "buttons/button14.wav"     

ENT.ShouldUnweld                     =  false
ENT.ShouldIgnite                     =  false
ENT.ShouldExplodeOnImpact            =  true
ENT.Flamable                         =  false
ENT.UseRandomSounds                  =  false
ENT.Timed                            =  false

ENT.ExplosionDamage                  =  25
ENT.PhysForce                        =  5
ENT.ExplosionRadius                  =  5
ENT.SpecialRadius                    =  1250
ENT.MaxIgnitionTime                  =  0
ENT.Life                             =  25                                  
ENT.MaxDelay                         =  2                                 
ENT.TraceLength                      =  100
ENT.ImpactSpeed                      =  700
ENT.Mass                             =  500
ENT.ArmDelay                         =  1   
ENT.Timer                            =  0
ENT.Shocktime                        = 0.1
ENT.HBOWNER                          =  nil            

function ENT:Initialize()
 if (SERVER) then
     self:SetModel(self.Model)
	 self:PhysicsInit( SOLID_VPHYSICS )
	 self:SetSolid( SOLID_VPHYSICS )
	 self:SetMoveType( MOVETYPE_VPHYSICS )
	 self:SetUseType( ONOFF_USE )
	 local phys = self:GetPhysicsObject()
	 if (phys:IsValid()) then
		 phys:SetMass(self.Mass)
		 phys:Wake()
     end 
	 if(self.Dumb) then
	     self.Armed    = true
	 else
	     self.Armed    = false
	 end
	 self.Exploded = false
	 self.Used     = false
	 self.Arming = false
	 self.Exploding = false
	 if !(WireAddon == nil) then 
	  self.Inputs   = Wire_CreateInputs(self, { "Arm", "Detonate" }) 
	 end
	end
end

function ENT:Explode(ply)
     if !self.Exploded then return end
	 if self.Exploding then return end
	
	 local pos = self:LocalToWorld(self:OBBCenter())
	 self:SetModel("models/gibs/scanner_gib02.mdl")
	 self.Exploding = true
	
	 constraint.RemoveAll(self)
	 local physo = self:GetPhysicsObject()
	 physo:Wake()
	 physo:EnableMotion(false)

	local ent = ents.Create("hb_shockwave_sound_lowsh")
	ent:SetPos( pos ) 
	ent:Spawn()
	ent:Activate()
	ent:SetVar("HBOWNER", self.HBOWNER)
	ent:SetVar("MAX_RANGE",500000)
	ent:SetVar("SHOCKWAVE_INCREMENT",20000)
	ent:SetVar("DELAY",0.01)
	ent:SetVar("SOUND", "gbombs_5/explosions/special/emp.mp3")
	ent:SetVar("Shocktime",1)
	 if !self:IsValid() then return end 
	 self:StopParticles()
	
	 for k, v in pairs(ents.FindInSphere(pos,30000)) do
		 if v:IsValid() then
			 if(v.isWacAircraft) && (v.active==true) then
				v:setEngine(false)
				v.engineDead = true							 
				ParticleEffectAttach("emp_electrify_model",PATTACH_POINT_FOLLOW,v,0) 
			 end
			 if v:GetClass()=="prop_vehicle_jeep" or v:GetClass()=="prop_vehicle_airboat" then 
				v:EmitSound("ambient/machines/spindown.wav")
				local ent = ents.Create("hb_emp_v_dead")
				ent:SetPos(v:GetPos() ) 
				ent:Spawn()
				ent:Activate()
				ent.radowner = v
				ParticleEffectAttach("emp_electrify_model",PATTACH_POINT_FOLLOW,v,0) 
				timer.Simple(math.random(), function()
					local sound = string.Explode(" ",table.Random(emp_soundlist))[1]
					ent:EmitSound(sound)
				end)
			 end
			 if(GetConVar("hb_safeemp"):GetInt() >= 1) then
				 if math.random(1,10)==10 then
					 if(table.HasValue(emp_whiteragdolllist,v:GetClass())) then
						local ent = ents.Create("prop_ragdoll")
						 local old_ent_constrains = constraint.GetAllConstrainedEntities( v )
						 local old_angle = v:GetAngles( )
						 ent:SetPos( v:LocalToWorld(self:OBBCenter()) ) 
						 ent:SetModel(v:GetModel())
						 ent:Spawn()
						 ent:Activate()
						 ent:SetColor(Color(65,65,65,255))
						 ent:Ignite(5,0)
						 ent:SetAngles(old_angle)
						 v:Remove()
						 ParticleEffectAttach("emp_electrify_model",PATTACH_POINT_FOLLOW,ent,0) 
						 timer.Simple(math.random(), function()
							local sound = string.Explode(" ",table.Random(emp_soundlist))[1]
							ent:EmitSound(sound)
						 end)
						 timer.Simple(math.random(4,5)+math.random(), function()
							if !ent:IsValid() then return end
							ent:Remove()
						 end)
					 end		
					 
					 if v:GetClass()=="npc_grenade_frag" then
						 local ent = ents.Create("prop_physics")
						 local old_ent_constrains = constraint.GetAllConstrainedEntities( v )
						 local old_angle = v:GetAngles( )
						 ent:SetPos( v:LocalToWorld(self:OBBCenter()) ) 	
						 ent:SetModel(v:GetModel())
						 ent:Spawn()
						 ent:Activate()
						 ent:SetColor(Color(65,65,65,255))
						 ent:Ignite(5,0)
						 ent:SetAngles(old_angle)
						 v:Remove()
						 ParticleEffectAttach("emp_electrify_model",PATTACH_POINT_FOLLOW,ent,0) 
						 timer.Simple(math.random(), function()
							local sound = string.Explode(" ",table.Random(emp_soundlist))[1]
							ent:EmitSound(sound)
						 end)
						 timer.Simple(math.random(4,5)+math.random(), function()
							if !ent:IsValid() then return end
							ent:Remove()
						 end)
					 end		
					 
					 if(table.HasValue(emp_whitelist,v:GetClass())) then
						 local ent = ents.Create("prop_physics")
						 local old_ent_constrains = constraint.GetAllConstrainedEntities( v )
						 local old_angle = v:GetAngles( )
						 ent:SetPos( v:LocalToWorld(self:OBBCenter()) ) 
						 ent:SetModel(v:GetModel())
						 ent:Spawn()
						 ent:Activate()
						 ent:SetVar("HBOWNER",ply)
						 ent:SetColor(Color(65,65,65,255))
						 ent:Ignite(5,0)
						 ent:SetAngles(old_angle)
						 for _, Prop in pairs (old_ent_constrains) do
							constraint.Weld( ent, Prop, 0, 0, 0, true, false )	
						 end
						 v:Remove()
						 ParticleEffectAttach("emp_electrify_model",PATTACH_POINT_FOLLOW,ent,0) 
						 timer.Simple(math.random(), function()
							local sound = string.Explode(" ",table.Random(emp_soundlist))[1]
							ent:EmitSound(sound)
						 end)
						 timer.Simple(math.random(4,5)+math.random(), function()
							if !ent:IsValid() then return end
							ent:Remove()
						 end)
					 end
				end
			else
				if(table.HasValue(emp_whiteragdolllist,v:GetClass())) then
					 local ent = ents.Create("prop_ragdoll")
					 local old_ent_constrains = constraint.GetAllConstrainedEntities( v )
					 local old_angle = v:GetAngles( )
					 ent:SetPos( v:LocalToWorld(self:OBBCenter()) ) 
					 ent:SetModel(v:GetModel())
					 ent:Spawn()
					 ent:Activate()
					 ent:SetColor(Color(65,65,65,255))
					 ent:Ignite(5,0)
					 ent:SetAngles(old_angle)
					 v:Remove()
					 ParticleEffectAttach("emp_electrify_model",PATTACH_POINT_FOLLOW,ent,0) 
					 timer.Simple(math.random(), function()
						local sound = string.Explode(" ",table.Random(emp_soundlist))[1]
						ent:EmitSound(sound)
					 end)
					 timer.Simple(math.random(4,5)+math.random(), function()
						if !ent:IsValid() then return end
						ent:Remove()
					 end)
				 end		
				 
				 if v:GetClass()=="npc_grenade_frag" then
					 local ent = ents.Create("prop_physics")
					 local old_ent_constrains = constraint.GetAllConstrainedEntities( v )
					 local old_angle = v:GetAngles( )
					 ent:SetPos( v:LocalToWorld(self:OBBCenter()) ) 	
					 ent:SetModel(v:GetModel())
					 ent:Spawn()
					 ent:Activate()
					 ent:SetColor(Color(65,65,65,255))
					 ent:Ignite(5,0)
					 ent:SetAngles(old_angle)
					 v:Remove()
					 ParticleEffectAttach("emp_electrify_model",PATTACH_POINT_FOLLOW,ent,0) 
					 timer.Simple(math.random(), function()
						local sound = string.Explode(" ",table.Random(emp_soundlist))[1]
						ent:EmitSound(sound)
					 end)
					 timer.Simple(math.random(4,5)+math.random(), function()
						if !ent:IsValid() then return end
						ent:Remove()
					 end)
				 end		
				 
				 if(table.HasValue(emp_whitelist,v:GetClass())) then
					 local ent = ents.Create("prop_physics")
					 local old_ent_constrains = constraint.GetAllConstrainedEntities( v )
					 local old_angle = v:GetAngles( )
					 ent:SetPos( v:LocalToWorld(self:OBBCenter()) ) 
					 ent:SetModel(v:GetModel())
					 ent:Spawn()
					 ent:Activate()
					 ent:SetVar("HBOWNER",ply)
					 ent:SetColor(Color(65,65,65,255))
					 ent:Ignite(5,0)
					 ent:SetAngles(old_angle)
					 for _, Prop in pairs (old_ent_constrains) do
						constraint.Weld( ent, Prop, 0, 0, 0, true, false )	
					 end
					 v:Remove()
					 ParticleEffectAttach("emp_electrify_model",PATTACH_POINT_FOLLOW,ent,0) 
					 timer.Simple(math.random(), function()
						local sound = string.Explode(" ",table.Random(emp_soundlist))[1]
						ent:EmitSound(sound)
					 end)
					 timer.Simple(math.random(4,5)+math.random(), function()
						if !ent:IsValid() then return end
						ent:Remove()
					 end)
				 end
			end
		 end
	 end 
	 if(self:WaterLevel() >= 1) then
		 local trdata   = {}
		 local trlength = Vector(0,0,9000)

		 trdata.start   = pos
		 trdata.endpos  = trdata.start + trlength
		 trdata.filter  = self
		 local tr = util.TraceLine(trdata) 

		 local trdat2   = {}
		 trdat2.start   = tr.HitPos
		 trdat2.endpos  = trdata.start - trlength
		 trdat2.filter  = self
		 trdat2.mask    = MASK_WATER + CONTENTS_TRANSLUCENT
		 
		 local tr2 = util.TraceLine(trdat2)
		 
		 if tr2.Hit then
			 ParticleEffect(self.EffectWater, tr2.HitPos, Angle(0,0,0), nil)
		
		 end
	 else
		 local tracedata    = {}
		 tracedata.start    = pos
		 tracedata.endpos   = tracedata.start - Vector(0, 0, self.TraceLength)
		 tracedata.filter   = self.Entity
			
		 local trace = util.TraceLine(tracedata)
	 
		 if trace.HitWorld then
			 ParticleEffect(self.Effect,pos,self:GetAngles(),nil)	
			 self:Remove()
		 else 
			 ParticleEffect(self.EffectAir,pos,Angle(0,0,0),nil) 
			 self:Remove()
		 end
	 end
end

function ENT:SpawnFunction( ply, tr )
     if ( !tr.Hit ) then return end
	 self.HBOWNER = ply
     local ent = ents.Create( self.ClassName )
	 ent:SetPhysicsAttacker(ply)
     ent:SetPos( tr.HitPos + tr.HitNormal * 16 ) 
     ent:Spawn()
     ent:Activate()

     return ent
end
--addons/hbombs_base/lua/entities/hb_fridge.lua:
AddCSLuaFile()

DEFINE_BASECLASS( "base_anim" )


ENT.Spawnable		            	 =  true       
ENT.AdminSpawnable		             =  true 

ENT.PrintName		                 =  "Fridge"
ENT.Author			                 =  "natsu"
ENT.Contact		                     =  "baldursgate3@gmail.com"
ENT.Category                         =  "HBOMBS Misc"

ENT.Model                            =  "models/rogue/tibe.mdl"           
ENT.Effect                           =  ""                  
ENT.EffectAir                        =  ""   
ENT.EffectWater                      =  "" 
ENT.ExplosionSound                   =  ""                   
ENT.ParticleTrail                    =  ""

ENT.ShouldUnweld                     =  false
ENT.ShouldIgnite                     =  false      
ENT.ShouldExplodeOnImpact            =  false         
ENT.Flamable                         =  false        
ENT.UseRandomSounds                  =  false       
ENT.UseRandomModels                  =  false

ENT.ExplosionDamage                  =  1          
ENT.PhysForce                        =  2           
ENT.ExplosionRadius                  =  3           
ENT.SpecialRadius                    =  4            
ENT.MaxIgnitionTime                  =  1           
ENT.Life                             =  300        
ENT.MaxDelay                         =  0          
ENT.TraceLength                      =  0        
ENT.ImpactSpeed                      =  0           
ENT.Mass                             =  100
ENT.Shocktime                        = 1
ENT.HBOWNER                          =  nil             -- don't you fucking touch this.

function ENT:ExploSound(pos)
     if not self.Exploded then return end
	 if self.UseRandomSounds then
         sound.Play(table.Random(ExploSnds), pos, 160, 130,1)
     else
	     sound.Play(self.ExplosionSound, pos, 160, 130,1)
	 end
end

function ENT:SpawnFunction( ply, tr )
     if ( !tr.Hit ) then return end
		 
	local ent = ents.Create("prop_vehicle_prisoner_pod") 
	ent:SetModel("models/vehicles/prisoner_pod_inner.mdl") 
	ent:SetKeyValue("vehiclescript","scripts/vehicles/prisoner_pod.txt")
	ent:SetPos(tr.HitPos) 
	ent:Spawn()
	ent:Activate()
	
	local ent2 = ents.Create("prop_physics") 
	ent2:SetModel("models/props_c17/furniturefridge001a.mdl") 
	ent2:SetPos(ent:GetPos()+Vector(-10,0,50)) 
	ent2:Spawn()
	ent2:Activate()
	
	ent2:SetParent(ent)
	ent2:SetCollisionGroup(COLLISION_GROUP_IN_VEHICLE)
	ent:SetNoDraw(true)
	
	 		 	 
     return ent
end

--addons/hbombs/lua/entities/hb_main_500lb.lua:
AddCSLuaFile()

DEFINE_BASECLASS( "hb_base_advanced" )

ENT.Spawnable						 =  true         
ENT.AdminSpawnable					 =  true 

ENT.PrintName						 =  "500lb Explosive"
ENT.Author							 =  "Business Cat"
ENT.Contact							 =  "nah"
ENT.Category                         =  "HBOMBS Main"

ENT.Model                            =  "models/thedoctor/500lb.mdl"                      
ENT.Effect                           =  "h_500lb"                  
ENT.EffectAir                        =  "h_500lb_air"                   
ENT.EffectWater                      =  "h_water_small"
ENT.ExplosionSound                   =  "gbombs_5/explosions/medium_bomb/explosion_medium.mp3"
ENT.ArmSound                         =  "npc/roller/mine/rmine_blip3.wav"   
ENT.ActivationSound                  =  "buttons/button14.wav"     
 
ENT.ShouldUnweld                     =  true
ENT.ShouldIgnite                     =  false
ENT.ShouldExplodeOnImpact            =  true
ENT.Flamable                         =  false
ENT.UseRandomSounds                  =  false
ENT.Timed                            =  false

ENT.ExplosionDamage                  =  4000
ENT.PhysForce                        =  500
ENT.ExplosionRadius                  =  2000
ENT.MaxIgnitionTime                  =  0
ENT.Life                             =  25                                  
ENT.MaxDelay                         =  2                                 
ENT.TraceLength                      =  155
ENT.ImpactSpeed                      =  500
ENT.Mass                             =  500
ENT.ArmDelay                         =  1   
ENT.Timer                            =  0
ENT.Shocktime                        =  4

ENT.DEFAULT_PHYSFORCE                = 155
ENT.DEFAULT_PHYSFORCE_PLYAIR         = 20
ENT.DEFAULT_PHYSFORCE_PLYGROUND      = 1000 

ENT.Decal                            = "scorch_big"
ENT.HBOWNER                          =  nil             -- don't you fucking touch this.


function ENT:SpawnFunction( ply, tr )
	 if ( !tr.Hit ) then return end
	 self.HBOWNER = ply
	 local ent = ents.Create( self.ClassName )
	 ent:SetPhysicsAttacker(ply)
	 ent:SetPos( tr.HitPos + tr.HitNormal * 16 ) 
	 ent:Spawn()
	 ent:Activate()
	 ent:SetAngles(Angle(45,0,0))	 

	 return ent
end


function ENT:Explode()
	if !self.Exploded then return end
	if self.Exploding then return end

	local pos = self:LocalToWorld(self:OBBCenter())


	constraint.RemoveAll(self)
	local physo = self:GetPhysicsObject()
	physo:Wake()	

	self.Exploding = true
	if !self:IsValid() then return end 
	self:StopParticles()
	local pos = self:LocalToWorld(self:OBBCenter())

	local ent = ents.Create("hb_shockwave_ent")
	ent:SetPos( pos ) 
	ent:Spawn()
	ent:Activate()
	ent:SetVar("DEFAULT_PHYSFORCE", self.DEFAULT_PHYSFORCE)
	ent:SetVar("DEFAULT_PHYSFORCE_PLYAIR", self.DEFAULT_PHYSFORCE_PLYAIR)
	ent:SetVar("DEFAULT_PHYSFORCE_PLYGROUND", self.DEFAULT_PHYSFORCE_PLYGROUND)
	ent:SetVar("HBOWNER", self.HBOWNER)
	ent:SetVar("MAX_RANGE",self.ExplosionRadius)
	ent:SetVar("SHOCKWAVE_INCREMENT",100)
	ent:SetVar("DELAY",0.01)
	ent.trace=self.TraceLength
	ent.decal=self.Decal


	local ent = ents.Create("hb_shockwave_sound_lowsh")
	ent:SetPos( pos ) 
	ent:Spawn()
	ent:Activate()
	ent:SetVar("HBOWNER", self.HBOWNER)
	ent:SetVar("MAX_RANGE",50000)
	ent:SetVar("SHOCKWAVE_INCREMENT",100)
	ent:SetVar("DELAY",0.01)
	ent:SetVar("SOUND", self.ExplosionSound)
	ent:SetVar("Shocktime", self.Shocktime)

	 if(self:WaterLevel() >= 1) then
		 local trdata   = {}
		 local trlength = Vector(0,0,9000)
		 
		 trdata.start   = pos
		 trdata.endpos  = trdata.start + trlength
		 trdata.filter  = self
		 
		 local tr = util.TraceLine(trdata) 
		 local trdat2   = {}
		 trdat2.start   = tr.HitPos
		 trdat2.endpos  = trdata.start - trlength
		 trdat2.filter  = self
		 trdat2.mask    = MASK_WATER + CONTENTS_TRANSLUCENT
			
		 local tr2 = util.TraceLine(trdat2)
			 
		 if tr2.Hit then
			 ParticleEffect(self.EffectWater, tr2.HitPos, Angle(0,0,0), nil)
		 end
	 else
		 local tracedata    = {}
		 tracedata.start    = pos
		 tracedata.endpos   = tracedata.start - Vector(0, 0, self.TraceLength)
		 tracedata.filter   = self.Entity
				
		 local trace = util.TraceLine(tracedata)
		 
		 if trace.HitWorld then
			 ParticleEffect(self.Effect,pos,Angle(0,0,0),nil)
		 else 
			 ParticleEffect(self.EffectAir,pos,Angle(0,0,0),nil) 
		 end
	 end
	 if self.IsNBC then
		 local nbc = ents.Create(self.NBCEntity)
		 nbc:SetVar("HBOWNER",self.HBOWNER)
		 nbc:SetPos(self:GetPos())
		 nbc:Spawn()
		 nbc:Activate()
	 end
	 self:Remove()
end
--addons/hbombs/lua/entities/hb_main_fusionbomb.lua:
AddCSLuaFile()

DEFINE_BASECLASS( "hb_base_advanced" )

ENT.Spawnable						 =  true         
ENT.AdminSpawnable					 =  true 

ENT.AdminOnly                        =  true

ENT.PrintName						 =  "Fusion Bomb"
ENT.Author							 =  "Business Cat"
ENT.Contact							 =  "nah"
ENT.Category                         =  "HBOMBS Main"

ENT.Model                            =  "models/props_wasteland/laundry_washer003.mdl"                      
ENT.Effect                           =  "h_fusionbomb"                  
ENT.EffectAir                        =  "h_fusionbomb"                   
ENT.EffectWater                      =  "water_huge"

ENT.ArmSound                         =  "npc/roller/mine/rmine_blip3.wav"            
ENT.ActivationSound                  =  "buttons/button14.wav"     

ENT.ShouldUnweld                     =  true
ENT.ShouldIgnite                     =  false
ENT.ShouldExplodeOnImpact            =  true
ENT.Flamable                         =  false
ENT.UseRandomSounds                  =  false
ENT.Timed                            =  false

ENT.ExplosionDamage                  =  500
ENT.PhysForce                        =  2500
ENT.ExplosionRadius                  =  2000
ENT.SpecialRadius                    =  3000
ENT.MaxIgnitionTime                  =  0
ENT.Life                             =  25                                  
ENT.MaxDelay                         =  2                                 
ENT.TraceLength                      =  3000
ENT.ImpactSpeed                      =  700
ENT.Mass                             =  2500
ENT.ArmDelay                         =  1   
ENT.Timer                            =  0
ENT.ShockTime                        =  5
ENT.HBOWNER                          =  nil             -- don't you fucking touch this.

function ENT:Initialize()
 if (SERVER) then
	 self:SetModel(self.Model)
	 self:PhysicsInit( SOLID_VPHYSICS )
	 self:SetSolid( SOLID_VPHYSICS )
	 self:SetMoveType( MOVETYPE_VPHYSICS )
	 self:SetUseType( ONOFF_USE ) -- doesen't fucking work
	 local phys = self:GetPhysicsObject()
	 if (phys:IsValid()) then
		 phys:SetMass(self.Mass)
		 phys:Wake()
	 end 
	 if(self.Dumb) then
		 self.Armed    = true
	 else
		 self.Armed    = false
	 end
	 self.Exploded = false
	 self.Used     = false
	 self.Arming = false
	 self.Exploding = false
	  if !(WireAddon == nil) then self.Inputs   = Wire_CreateInputs(self, { "Arm", "Detonate" }) end
	end
end

function ENT:Explode()
	if !self.Exploded then return end
	if self.Exploding then return end
	
	local pos = self:LocalToWorld(self:OBBCenter())
	self:SetModel("models/gibs/scanner_gib02.mdl")
	self.Exploding = true
	constraint.RemoveAll(self)
	local physo = self:GetPhysicsObject()
	physo:Wake()
	self:SetMoveType( MOVETYPE_NONE )
	self:SetMaterial("phoenix_storms/glass")
	self:SetModel("models/hunter/plates/plate.mdl")
	
	local ent = ents.Create("hb_shockwave_sound_lowsh")
	ent:SetPos( pos ) 
	ent:Spawn()
	ent:Activate()
	ent:SetVar("HBOWNER", self.HBOWNER)
	ent:SetVar("MAX_RANGE",50000)
	ent:SetVar("SHOCKWAVE_INCREMENT",5000000)
	ent:SetVar("DELAY",0.01)
	ent:SetVar("Shocktime",12)
	ent:SetVar("SOUND", "hbombs/fusionbomb_hb.mp3")	
	
	timer.Simple(7, function()
		if !self:IsValid() then return end
		
		local ent = ents.Create("hb_shockwave_ent")
		ent:SetPos( pos ) 
		ent:Spawn()
		ent:Activate()
		ent:SetVar("DEFAULT_PHYSFORCE", 155)
		ent:SetVar("DEFAULT_PHYSFORCE_PLYAIR", 1555)
		ent:SetVar("DEFAULT_PHYSFORCE_PLYGROUND", 155)
		ent:SetVar("HBOWNER", self.HBOWNER)
		ent:SetVar("MAX_RANGE",15000)
		ent:SetVar("SHOCKWAVE_INCREMENT",100)
		ent:SetVar("DELAY",0.01)
		self:Remove()
	end)
	if(self:WaterLevel() >= 1) then
		local trdata   = {}
		local trlength = Vector(0,0,9000)

		trdata.start   = pos
		trdata.endpos  = trdata.start + trlength
		trdata.filter  = self
		local tr = util.TraceLine(trdata) 

		local trdat2   = {}
		trdat2.start   = tr.HitPos
		trdat2.endpos  = trdata.start - trlength
		trdat2.filter  = self
		trdat2.mask    = MASK_WATER + CONTENTS_TRANSLUCENT

		local tr2 = util.TraceLine(trdat2)

		if tr2.Hit then
			ParticleEffect(self.EffectWater, tr2.HitPos, Angle(0,0,0), nil)
		end
	else
		local tracedata    = {}
		tracedata.start    = pos
		tracedata.endpos   = tracedata.start - Vector(0, 0, self.TraceLength)
		tracedata.filter   = self.Entity

		local trace = util.TraceLine(tracedata)

		if trace.HitWorld then
			ParticleEffect(self.Effect,pos,self:GetAngles(),nil)	
			timer.Simple(0.1, function()
				if !self:IsValid() then return end 
					ParticleEffect("",trace.HitPos,Angle(0,0,0),nil)	
			end)	
		else 
			ParticleEffect(self.Effect,pos,Angle(0,0,0),nil) 

		end
	end
end

function ENT:SpawnFunction( ply, tr )
	 if ( !tr.Hit ) then return end
	 self.HBOWNER = ply
	 local ent = ents.Create( self.ClassName )
	 ent:SetPhysicsAttacker(ply)
	 ent:SetPos( tr.HitPos + tr.HitNormal * 32 ) 
	 ent:Spawn()
	 ent:Activate()

	 return ent
end
--addons/hbombs_base/lua/entities/hb_main_napalm_burning.lua:
AddCSLuaFile()

DEFINE_BASECLASS( "hb_nuclear_fission_rad_base" )


ENT.Spawnable		            	 =  false
ENT.AdminSpawnable		             =  false     

ENT.PrintName		                 =  "Radiation"        
ENT.Author			                 =  ""      
ENT.Contact			                 =  ""      

ENT.HBOWNER                          =  nil            
ENT.DAMAGE_MUL = 1

function ENT:Initialize()
	 if (SERVER) then
		 self:SetModel("models/props_junk/watermelon01_chunk02c.mdl")
		 self:SetSolid( SOLID_NONE )
		 self:SetMoveType( MOVETYPE_NONE )
		 self:SetUseType( ONOFF_USE ) 
		 self.Bursts = 0
		 self.HBOWNER = self:GetVar("HBOWNER")
	 end
end


function ENT:Think()
     if (SERVER) then
     if !self:IsValid() then return end
	 local pos = self:GetPos()
	 local dmg = DamageInfo()
	 dmg:SetDamage(math.random(1,8))
	 dmg:SetDamageType(DMG_BURN)
	 if self.HBOWNER == nil then
		self.HBOWNER = table.Random(player.GetAll())
	 end
	 if !self.HBOWNER:IsValid() then
		self.HBOWNER = table.Random(player.GetAll())
	 end
	 dmg:SetAttacker(self.HBOWNER)
	 for k, v in pairs(ents.FindInSphere(pos,750)) do
         if (v:IsPlayer() && v:IsOnGround() && v:Alive()) or v:IsNPC() then
			if v:GetClass()=="helicopter" then return end
		    v:TakeDamageInfo(dmg)
			v:EmitSound("player/pl_burnpain3.wav")
		 end
	 end
	 self.Bursts = self.Bursts + 1
	 if (self.Bursts >= 15) then
	     self:Remove()
	 end
	 self:NextThink(CurTime() + 0.5)
	 return true
	 end
end

function ENT:Draw()
     return false
end
--addons/hbombs_base/lua/entities/hb_misc_tower_01.lua:
AddCSLuaFile()

DEFINE_BASECLASS( "hb_base_dumb" )


ENT.Spawnable		            	 =  true         
ENT.AdminSpawnable		             =  true 

ENT.PrintName		                 =  "Nuclear Testing Tower 1"
ENT.Author			                 =  "Natsu"
ENT.Contact		                     =  "baldursgate3@gmail.com"
ENT.Category                         =  "HBOMBS Misc"

ENT.Model                            =  "models/thedoctor/trinity_tower.mdl"           
ENT.Effect                           =  ""                  
ENT.EffectAir                        =  ""   
ENT.EffectWater                      =  "" 
ENT.ExplosionSound                   =  ""                   
ENT.ParticleTrail                    =  ""

ENT.ShouldUnweld                     =  false
ENT.ShouldIgnite                     =  false      
ENT.ShouldExplodeOnImpact            =  false         
ENT.Flamable                         =  false        
ENT.UseRandomSounds                  =  false       
ENT.UseRandomModels                  =  false

ENT.ExplosionDamage                  =  1          
ENT.PhysForce                        =  2           
ENT.ExplosionRadius                  =  3           
ENT.SpecialRadius                    =  4            
ENT.MaxIgnitionTime                  =  1           
ENT.Life                             =  500          
ENT.MaxDelay                         =  0          
ENT.TraceLength                      =  0        
ENT.ImpactSpeed                      =  0           
ENT.Mass                             =  50000

ENT.HBOWNER                          =  nil             -- don't you fucking touch this.

function ENT:ExploSound(pos)
     if not self.Exploded then return end
	 if self.UseRandomSounds then
         sound.Play(table.Random(ExploSnds), pos, 160, 130,1)
     else
	     sound.Play(self.ExplosionSound, pos, 160, 130,1)
	 end
end

function ENT:SpawnFunction( ply, tr )
     if ( !tr.Hit ) then return end
	 self.HBOWNER = ply
     local ent = ents.Create( self.ClassName )
	 ent:SetPhysicsAttacker(ply)
     ent:SetPos( tr.HitPos + tr.HitNormal * 1006 ) 
     ent:Spawn()
     ent:Activate()

     return ent
end
--addons/hbombs_base/lua/entities/hb_misc_volcano_lava_dmg.lua:
AddCSLuaFile()

DEFINE_BASECLASS( "hb_nuclear_fission_rad_base" )


ENT.Spawnable		            	 =  false
ENT.AdminSpawnable		             =  false     

ENT.PrintName		                 =  "Radiation"        
ENT.Author			                 =  ""      
ENT.Contact			                 =  ""      

ENT.HBOWNER                          =  nil            
ENT.DAMAGE_MUL = 1

function ENT:Initialize()
	 if (SERVER) then
		 self:SetModel("models/props_junk/watermelon01_chunk02c.mdl")
		 self:SetSolid( SOLID_NONE )
		 self:SetMoveType( MOVETYPE_NONE )
		 self:SetUseType( ONOFF_USE ) 
		 self.Bursts = 0
		 self.HBOWNER = self:GetVar("HBOWNER")
	 end
end


function ENT:Think()
     if (SERVER) then
     if !self:IsValid() then return end
	 local pos = self:GetPos()
	 local dmg = DamageInfo()
	 dmg:SetDamage(math.random(25,50))
	 dmg:SetDamageType(DMG_BURN)
	 if self.HBOWNER == nil then
		self.HBOWNER = table.Random(player.GetAll())
	 end
	 if !self.HBOWNER:IsValid() then
		self.HBOWNER = table.Random(player.GetAll())
	 end
	 dmg:SetAttacker(self.HBOWNER)
	 for k, v in pairs(ents.FindInSphere(pos,750)) do
         if (v:IsPlayer() && v:IsOnGround() && v:Alive()) or v:IsNPC() then
			if v:GetClass()=="helicopter" then return end
		    v:TakeDamageInfo(dmg)
			v:EmitSound("player/pl_burnpain3.wav")
		 end
	 end
	 self.Bursts = self.Bursts + 1
	 if (self.Bursts >= 60) then
	     self:Remove()
	 end
	 self:NextThink(CurTime() + 0.5)
	 return true
	 end
end

function ENT:Draw()
     return false
end
--addons/hbombs/lua/entities/hb_nuclear_c_plutonium.lua:
AddCSLuaFile()

DEFINE_BASECLASS( "hb_base_dumb" )


ENT.Spawnable						 =  true         
ENT.AdminSpawnable					 =  true 

ENT.AdminOnly						 =  true

ENT.PrintName						 =  "Plutonium-239"
ENT.Author							 =  "natsu"
ENT.Contact							 =  "baldursgate3@gmail.com"
ENT.Category                         =  "HBOMBS Custom"

ENT.Model                            =  "models/thedoctor/plutonium.mdl"           
ENT.Effect                           =  ""                  
ENT.EffectAir                        =  ""   
ENT.EffectWater                      =  "" 
ENT.ExplosionSound                   =  ""                   
ENT.ParticleTrail                    =  ""

ENT.ShouldUnweld                     =  false
ENT.ShouldIgnite                     =  false      
ENT.ShouldExplodeOnImpact            =  false         
ENT.Flamable                         =  false        
ENT.UseRandomSounds                  =  false       
ENT.UseRandomModels                  =  false

ENT.ExplosionDamage                  =  1          
ENT.PhysForce                        =  2           
ENT.ExplosionRadius                  =  3           
ENT.SpecialRadius                    =  4            
ENT.MaxIgnitionTime                  =  1           
ENT.Life                             =  200        
ENT.MaxDelay                         =  0          
ENT.TraceLength                      =  0        
ENT.ImpactSpeed                      =  0           
ENT.Mass                             =  100
ENT.Shocktime                        = 1
ENT.HBOWNER                          =  nil             -- don't you fucking touch this.

function ENT:Initialize()
 if (SERVER) then
	 self:LoadModel()
	 self:PhysicsInit( SOLID_VPHYSICS )
	 self:SetSolid( SOLID_VPHYSICS )
	 self:SetMoveType( MOVETYPE_VPHYSICS )
	 self:SetUseType( ONOFF_USE ) -- doesen't fucking work
	 self.EntList={}
	 self.EntCount = 0
	 local phys = self:GetPhysicsObject()
	 local skincount = self:SkinCount()
	 local ent = ents.Create("hb_base_radiation_draw_ent_fl")
	 ent:SetPos( self:GetPos() ) 
	 ent:Spawn()
	 ent:Activate()
	 ent.radowner = self
	 ent.RadRadius = 100
	 if (phys:IsValid()) then
		 phys:SetMass(self.Mass)
		 phys:Wake()
	 end
	 if (skincount > 0) then
		 self:SetSkin(math.random(0,skincount))
	 end
	 self.Exploded = false
	end
end

function ENT:ExploSound(pos)
	 if not self.Exploded then return end
	 if self.UseRandomSounds then
		 sound.Play(table.Random(ExploSnds), pos, 160, 130,1)
	 else
		 sound.Play(self.ExplosionSound, pos, 160, 130,1)
	 end
end

function ENT:SpawnFunction( ply, tr )
	 if ( !tr.Hit ) then return end
	 self.HBOWNER = ply
	 local ent = ents.Create( self.ClassName )
	 ent:SetPhysicsAttacker(ply)
	 ent:SetPos( tr.HitPos + tr.HitNormal * 16 ) 
	 ent:Spawn()
	 ent:Activate()

	 return ent
end

if (CLIENT) then
	function Radiation()
		surface.SetDrawColor(Color(255,255,255,50))
		draw.NoTexture()
		surface.DrawRect(0,0,ScrW(),ScrH())
		LocalPlayer():SetAngles(Angle(-90,0,0)) 
		hook.Add( "HUDPaint", "Radiation", Radiation )
		timer.Simple(0.1, function()
			hook.Remove( "HUDPaint", "Radiation", Radiation )
		end)
	end
	concommand.Add( "Rad", Radiation )
end

function ENT:Think(ply) 
	self.spawned = true
	if (SERVER) then 
	if !self.spawned then return end
	local pos = self:GetPos()
	local dmg = DamageInfo()
	self.TotalList={}
	for k, v in pairs(ents.FindInSphere(pos,11)) do
		if !table.HasValue(self.TotalList,v) then
			table.insert(self.TotalList, v )
		end
	end
	for k, v in pairs(self.TotalList) do
		if v:IsValid() then 
			if (!(self:GetClass() == v:GetClass()) and !(v:IsWeapon()) and !(table.HasValue(self.EntList,v))) then
				phys = v:GetPhysicsObject( )
				if (v:IsValid()) and !(table.HasValue(self.EntList,v)) and (phys:IsValid()) then
					if !v:IsPlayer() and !v:IsNPC() then
						table.insert(self.EntList, v )
						self.EntCount = self.EntCount + 1	
					end
				end
			end
			for k_, v_ in pairs(self.EntList) do
				if !table.HasValue(self.TotalList, v_) then
					table.remove(self.EntList, k)
					self.EntCount = self.EntCount - 1
				end
			end			
		end
	end
	if self.EntCount == 0 then
		for k, v in pairs(ents.FindInSphere(pos,50)) do
			if (v:IsPlayer() or v:IsNPC()) and v.hazsuited==false then
				dmg:SetDamage(math.random(1))
				dmg:SetDamageType(DMG_RADIATION)
				if self.HBOWNER == nil then
					self.HBOWNER = table.Random(player.GetAll())
				end
				dmg:SetAttacker(self.HBOWNER)
				v:EmitSound("player/geiger2.wav", 100, 100)
				v:TakeDamageInfo(dmg)
				if !v:IsNPC() then
					v:ConCommand("Rad")
				end
			end
		end
		for k, v in pairs(ents.FindInSphere(pos,45)) do
			if (v:IsPlayer() or v:IsNPC()) and v.hazsuited==false then
				dmg:SetDamage(math.random(1,2))
				dmg:SetDamageType(DMG_RADIATION)
				if self.HBOWNER == nil then
					self.HBOWNER = table.Random(player.GetAll())
				end
				dmg:SetAttacker(self.HBOWNER)
				v:EmitSound("player/geiger3.wav", 100, 100)
				v:TakeDamageInfo(dmg)
				if !v:IsNPC() then
					v:ConCommand("Rad")
				end
			end
		end
		for k, v in pairs(ents.FindInSphere(pos,30)) do
			if (v:IsPlayer() or v:IsNPC()) and v.hazsuited==false && self:IsValid() then
				timer.Simple(0.3, function()			
					if !v:IsValid() then return end
					dmg:SetDamage(math.random(1,3))
					dmg:SetDamageType(DMG_RADIATION)
					if self.HBOWNER == nil then
						self.HBOWNER = table.Random(player.GetAll())
					end
					dmg:SetAttacker(self.HBOWNER)
					v:EmitSound("player/geiger3.wav", 100, 100)
					v:TakeDamageInfo(dmg)
					if !v:IsNPC() then
						v:ConCommand("Rad")
					end
				end)
			end
		end
	end
	for k, v in pairs(self.EntList) do
		if !v:IsValid() then
			table.remove(self.EntList, k)
			self.EntCount = self.EntCount - 1
		end
	end	
	self:NextThink((CurTime() + math.random())+2)
	return true
	end
end

--addons/hbombs/lua/entities/hb_nuclear_castlebravo.lua:
AddCSLuaFile()

DEFINE_BASECLASS( "hb_base_advanced_nuke" )

ENT.Spawnable						 =  true         
ENT.AdminSpawnable					 =  true 

ENT.AdminOnly						 =  true

ENT.PrintName						 =  "Castle Bravo"
ENT.Author							 =  "Business Cat"
ENT.Contact							 =  "nah"
ENT.Category                         =  "HBOMBS Nukes"

ENT.Model                            =  "models/models/castlerubaut.mdl"                      
ENT.Effect                           =  "h_nuke4"                  
ENT.EffectAir                        =  "h_nuke4_airburst"                   
ENT.EffectWater                      =  "hbomb_underwater"
ENT.ExplosionSound                   =  "gbombs_5/explosions/nuclear/nukeaudio3.mp3"
ENT.ArmSound                         =  "npc/roller/mine/rmine_blip3.wav"            
ENT.ActivationSound                  =  "buttons/button14.wav"     

ENT.ShouldUnweld                     =  true
ENT.ShouldIgnite                     =  false
ENT.ShouldExplodeOnImpact            =  true
ENT.Flamable                         =  false
ENT.UseRandomSounds                  =  false
ENT.Timed                            =  false

ENT.ExplosionDamage                  =  500
ENT.PhysForce                        =  2500
ENT.ExplosionRadius                  =  25000
ENT.SpecialRadius                    =  10000
ENT.MaxIgnitionTime                  =  0
ENT.Life                             =  25                                  
ENT.MaxDelay                         =  2                                 
ENT.TraceLength                      =  2000
ENT.ImpactSpeed                      =  700
ENT.Mass                             =  25000
ENT.ArmDelay                         =  1   
ENT.Timer                            =  0

ENT.HBOWNER                          =  nil             -- don't you fucking touch this.
ENT.Decal                            = "nuke_big"
function ENT:Initialize()
 if (SERVER) then
	 self:SetModel(self.Model)
	 self:PhysicsInit( SOLID_VPHYSICS )
	 self:SetSolid( SOLID_VPHYSICS )
	 self:SetMoveType( MOVETYPE_VPHYSICS )
	 self:SetUseType( ONOFF_USE ) -- doesen't fucking work
	 local phys = self:GetPhysicsObject()
	 if (phys:IsValid()) then
		 phys:SetMass(self.Mass)
		 phys:Wake()
	 end 
	 if(self.Dumb) then
		 self.Armed    = true
	 else
		 self.Armed    = false
	 end
	 self.Exploded = false
	 self.Used     = false
	 self.Arming = false
	 self.Exploding = false
	  if !(WireAddon == nil) then self.Inputs   = Wire_CreateInputs(self, { "Arm", "Detonate" }) end
	end
end


function ENT:Explode()
	 if !self.Exploded then return end
	 if self.Exploding then return end
	
	 local pos = self:LocalToWorld(self:OBBCenter())
	 local ent = ents.Create("hb_shockwave_ent")
	 ent:SetPos( pos ) 
	 ent:Spawn()
	 ent:Activate()
	 ent:SetVar("DEFAULT_PHYSFORCE", 200)
	 ent:SetVar("DEFAULT_PHYSFORCE_PLYAIR", self.DEFAULT_PHYSFORCE_PLYAIR)
	 ent:SetVar("DEFAULT_PHYSFORCE_PLYGROUND", self.DEFAULT_PHYSFORCE_PLYGROUND)
	 ent:SetVar("HBOWNER", self.HBOWNER)
	 ent:SetVar("MAX_RANGE",self.ExplosionRadius)
	 ent:SetVar("SHOCKWAVE_INCREMENT",150)
	 ent:SetVar("DELAY",0.01)
	 ent:SetVar("SOUND", "gbombs_5/explosions/nuclear/nukeaudio3.mp3")
	 ent.trace=self.TraceLength
	 ent.decal=self.Decal

	 local ent = ents.Create("hb_shockwave_ent_nounfreeze")	 
	 ent:SetPos( pos ) 
	 ent:Spawn()
	 ent:Activate()
	 ent:SetVar("DEFAULT_PHYSFORCE",20)
	 ent:SetVar("DEFAULT_PHYSFORCE_PLYAIR",5)
	 ent:SetVar("DEFAULT_PHYSFORCE_PLYGROUND",10)
	 ent:SetVar("HBOWNER", self.HBOWNER)
	 ent:SetVar("MAX_RANGE",40000)
	 ent:SetVar("SHOCKWAVE_INCREMENT",150)
	 ent:SetVar("DELAY",0.01)
	 ent.trace=self.TraceLength
	 ent.decal=self.Decal
	 
	if GetConVar("hb_nuclear_fallout"):GetInt()== 1 then
		local ent = ents.Create("hb_base_radiation_draw_ent")
		ent:SetPos( pos ) 
		ent:Spawn()
		ent:Activate()
		ent.Burst = 25
		ent.RadRadius=18000
		
		local ent = ents.Create("hb_base_radiation_ent")
		ent:SetPos( pos ) 
		ent:Spawn()
		ent:Activate()
		ent.Burst = 25
		ent.RadRadius=18000
	 end			 
	 local ent = ents.Create("hb_shockwave_rumbling")
	 ent:SetPos( pos ) 
	 ent:Spawn()
	 ent:Activate()
	 ent:SetVar("HBOWNER", self.HBOWNER)
	 ent:SetVar("MAX_RANGE",self.ExplosionRadius)
	 ent:SetVar("SHOCKWAVE_INCREMENT",200)
	 ent:SetVar("DELAY",0.01)
	 ent:SetVar("SOUND", self.ExplosionSound)
	 
	 local ent = ents.Create("hb_shockwave_sound_lowsh")
	 ent:SetPos( pos ) 
	 ent:Spawn()
	 ent:Activate()
	 ent:SetVar("HBOWNER", self.HBOWNER)
	 ent:SetVar("MAX_RANGE",50000)
	 ent:SetVar("SHOCKWAVE_INCREMENT",150)
	 ent:SetVar("DELAY",0.01)
	 ent:SetVar("SOUND", "gbombs_5/explosions/nuclear/nukeaudio3.mp3")
	 self:SetModel("models/gibs/scanner_gib02.mdl")
	 self.Exploding = true
	
	 local physo = self:GetPhysicsObject()
	 physo:Wake()
	 physo:EnableMotion(true)
	 for k, v in pairs(ents.FindInSphere(pos,self.SpecialRadius*3)) do
		 if (v:IsValid() or v:IsPlayer()) then
			if v:IsValid() and v:GetPhysicsObject():IsValid() then
				v:Ignite(4,0)
			end
		 end
	 end
	 for k, v in pairs(ents.FindInSphere(pos,self.SpecialRadius)) do
		if (v:IsValid() or v:IsPlayer()) then
			if v:IsPlayer() then
				v:SetModel("models/Humans/Charple04.mdl")
				v:Kill()
				ParticleEffectAttach("nuke_player_vaporize_fatman",PATTACH_POINT_FOLLOW,v,0) 
			end
		 end
	 end
	
  	 timer.Simple(2, function()
		 if !self:IsValid() then return end 
		 constraint.RemoveAll(self)
		 if GetConVar("hb_sound_shake"):GetInt()== 1 then
			util.ScreenShake( pos, 55555, 255, 10, 121000 )
		 else return end
		 self:StopParticles()
		 for k, v in pairs(ents.FindInSphere(pos,self.SpecialRadius*2)) do
			 if self.ShouldUnweld then
				 if v:IsValid() then
					 if v:IsValid() and v:GetPhysicsObject():IsValid() then
						 constraint.RemoveAll(v)
					 end
				 end
			 end
		 end
	 end)
	 if(self:WaterLevel() >= 1) then
		 local trdata   = {}
		 local trlength = Vector(0,0,9000)

		 trdata.start   = pos
		 trdata.endpos  = trdata.start + trlength
		 trdata.filter  = self
		 local tr = util.TraceLine(trdata) 

		 local trdat2   = {}
		 trdat2.start   = tr.HitPos
		 trdat2.endpos  = trdata.start - trlength
		 trdat2.filter  = self
		 trdat2.mask    = MASK_WATER + CONTENTS_TRANSLUCENT
		 
		 local tr2 = util.TraceLine(trdat2)
		 
		 if tr2.Hit then
			 ParticleEffect(self.EffectWater, tr2.HitPos, Angle(0,0,0), nil)
		
		 end
	 else
		 local tracedata    = {}
		 tracedata.start    = pos
		 tracedata.endpos   = tracedata.start - Vector(0, 0, self.TraceLength)
		 tracedata.filter   = self.Entity
			
		 local trace = util.TraceLine(tracedata)
	 
		 if trace.HitWorld then
			 ParticleEffect(self.Effect,pos,Angle(0,0,0),nil)	
			 timer.Simple(2, function()
				 if !self:IsValid() then return end 
				 ParticleEffect("",trace.HitPos,Angle(0,0,0),nil)	
				 self:Remove()
		 end)	
		 else 
			 ParticleEffect(self.EffectAir,pos,Angle(0,0,0),nil) 
			 --Here we do an emp check
			 timer.Simple(2, function()
				 if !self:IsValid() then return end 
				 ParticleEffect("",trace.HitPos,Angle(0,0,0),nil)	
				 self:Remove()
			end)	
			 if(GetConVar("hb_nuclear_emp"):GetInt() >= 1) then
				 local ent = ents.Create("hb_emp_entity")
				 ent:SetPos( self:GetPos() ) 
				 ent:Spawn()
				 ent:Activate()	
			 end
		 end
	 end
end

function ENT:SpawnFunction( ply, tr )
	 if ( !tr.Hit ) then return end
	 self.HBOWNER = ply
	 local ent = ents.Create( self.ClassName )
	 ent:SetPhysicsAttacker(ply)
	 ent:SetPos( tr.HitPos + tr.HitNormal * 64 ) 
	 ent:Spawn()
	 ent:Activate()

	 return ent
end
--addons/hbombs_base/lua/entities/hb_nuclear_davycrockett_noflash.lua:
AddCSLuaFile()

DEFINE_BASECLASS( "hb_base_advanced_nuke" )

ENT.Spawnable		            	 =  true         
ENT.AdminSpawnable		             =  true 

ENT.PrintName		                 =  "Davy Crockett - No Flash"
ENT.Author			                 =  "natsu"
ENT.Contact		                     =  "baldursgate3@gmail.com"
ENT.Category                         =  "HBOMBS Nukes"

ENT.Model                            =  "models/thedoctor/davy.mdl"                      
ENT.Effect                           =  "hbomb_small_a"                  
ENT.EffectAir                        =  "hbomb_small_airburst_a"                   
ENT.EffectWater                      =  "h_water_huge"
ENT.ArmSound                         =  "npc/roller/mine/rmine_blip3.wav"            
ENT.ActivationSound                  =  "buttons/button14.wav"     

ENT.ShouldUnweld                     =  true
ENT.ShouldIgnite                     =  false
ENT.ShouldExplodeOnImpact            =  true
ENT.Flamable                         =  false
ENT.UseRandomSounds                  =  false
ENT.Timed                            =  false

ENT.ExplosionDamage                  =  500
ENT.PhysForce                        =  2500
ENT.ExplosionRadius                  =  8000
ENT.SpecialRadius                    =  4000
ENT.MaxIgnitionTime                  =  0
ENT.Life                             =  25                                  
ENT.MaxDelay                         =  2                                 
ENT.TraceLength                      =  500
ENT.ImpactSpeed                      =  700
ENT.Mass                             =  255
ENT.ArmDelay                         =  1   
ENT.Timer                            =  0

ENT.DEFAULT_PHYSFORCE                = 255
ENT.DEFAULT_PHYSFORCE_PLYAIR         = 25
ENT.DEFAULT_PHYSFORCE_PLYGROUND         = 2555
ENT.HBOWNER                          =  nil     
ENT.Decal                            = "nuke_small"

function ENT:Initialize()
 if (SERVER) then
     self:SetModel(self.Model)
	 self:PhysicsInit( SOLID_VPHYSICS )
	 self:SetSolid( SOLID_VPHYSICS )
	 self:SetMoveType( MOVETYPE_VPHYSICS )
	 self:SetUseType( ONOFF_USE ) -- doesen't fucking work
	 local phys = self:GetPhysicsObject()
	 if (phys:IsValid()) then
		 phys:SetMass(self.Mass)
		 phys:Wake()
     end 
	 if(self.Dumb) then
	     self.Armed    = true
	 else
	     self.Armed    = false
	 end
	 self.Exploded = false
	 self.Used     = false
	 self.Arming = false
	 self.Exploding = false
	  if !(WireAddon == nil) then self.Inputs   = Wire_CreateInputs(self, { "Arm", "Detonate" }) end
	end
end


if SERVER then
	function ENT:Explode()
		 if !self.Exploded then return end
		 if self.Exploding then return end
		
		 local pos = self:LocalToWorld(self:OBBCenter())
		 self:SetModel("models/gibs/scanner_gib02.mdl")
		 self.Exploding = true
		 
		 local ent = ents.Create("hb_shockwave_sound_instant")
		 ent:SetPos( pos ) 
		 ent:Spawn()
		 ent:Activate()
		 ent:SetVar("HBOWNER", self.HBOWNER)
		 ent:SetVar("MAX_BURSTS", 1)
		 ent:SetVar("MAX_RANGE",50000)
		 ent:SetVar("DELAY",0.1)
		 ent:SetVar("sound", "gbombs_5/explosions/nuclear/tsar_in.mp3")
		 ent:SetVar("Shocktime",1)
		 
		 local ent = ents.Create("hb_shockwave_ent")
		 ent:SetPos( pos ) 
		 ent:Spawn()
		 ent:Activate()
		 ent:SetVar("DEFAULT_PHYSFORCE", self.DEFAULT_PHYSFORCE)
		 ent:SetVar("DEFAULT_PHYSFORCE_PLYAIR", self.DEFAULT_PHYSFORCE_PLYAIR)
		 ent:SetVar("DEFAULT_PHYSFORCE_PLYGROUND", self.DEFAULT_PHYSFORCE_PLYGROUND)
		 ent:SetVar("HBOWNER", self.HBOWNER)
		 ent:SetVar("MAX_RANGE",5000)
		 ent:SetVar("SHOCKWAVE_INCREMENT",140)
		 ent:SetVar("DELAY",0.01)
		 ent:SetVar("SOUND", "gbombs_5/explosions/nuclear/nukeaudiobassspeed2.mp3")
		 ent.trace=self.TraceLength
		 ent.decal=self.Decal
		 
		local ent = ents.Create("hb_shockwave_ent_nounfreeze")
		ent:SetPos( pos ) 
		ent:Spawn()
		ent:Activate()
		ent:SetVar("DEFAULT_PHYSFORCE",10)
		ent:SetVar("DEFAULT_PHYSFORCE_PLYAIR",1)
		ent:SetVar("DEFAULT_PHYSFORCE_PLYGROUND",10)
		ent:SetVar("HBOWNER", self.HBOWNER)
		ent:SetVar("MAX_RANGE",8000)
		ent:SetVar("SHOCKWAVE_INCREMENT",140)
		ent:SetVar("DELAY",0.01)
		ent.trace=self.TraceLength
		ent.decal=self.Decal		 

		local ent = ents.Create("hb_shockwave_sound_lowsh")
		ent:SetPos( pos ) 
		ent:Spawn()
		ent:Activate()
		ent:SetVar("HBOWNER", self.HBOWNER)
		ent:SetVar("MAX_RANGE",50000)
		ent:SetVar("SHOCKWAVE_INCREMENT",140)
		ent:SetVar("DELAY",0.01)
		ent:SetVar("shocktime", 4)
		ent:SetVar("SOUND", "gbombs_5/explosions/nuclear/NukeAudioBass.mp3")
		constraint.RemoveAll(self)

		
		if GetConVar("hb_nuclear_fallout"):GetInt()== 1 then
			local ent = ents.Create("hb_base_radiation_draw_ent")
			ent:SetPos( pos ) 
			ent:Spawn()
			ent:Activate()
			ent.Burst = 25
			ent.RadRadius=3000
			
			local ent = ents.Create("hb_base_radiation_ent")
			ent:SetPos( pos ) 
			ent:Spawn()
			ent:Activate()
			ent.Burst = 25
			ent.RadRadius=3000
		 end
		 local physo = self:GetPhysicsObject()
		 physo:Wake()
		 physo:EnableMotion(true)
		 for k, v in pairs(ents.FindInSphere(pos,2000)) do
			 if (v:IsValid() or v:IsPlayer()) then
				if v:IsValid() and v:GetPhysicsObject():IsValid() then
					v:Ignite(4,0)
				end
			 end
		 end
		 for k, v in pairs(ents.FindInSphere(pos,350)) do
			 if (v:IsValid() or v:IsPlayer()) then
				if v:IsPlayer() && !v:IsNPC() then
					v:SetModel("models/Humans/Charple04.mdl")
					ParticleEffectAttach("nuke_player_vaporize_fatman",PATTACH_POINT_FOLLOW,ent,0) 
					v:Kill()
				end
			 end
		 end
		 if !self:IsValid() then return end  
		 self:SetModel("models/gibs/scanner_gib02.mdl")
		 self.Exploding = true
		 self:StopParticles()
		 if(self:WaterLevel() >= 1) then
			 local trdata   = {}
			 local trlength = Vector(0,0,9000)

			 trdata.start   = pos
			 trdata.endpos  = trdata.start + trlength
			 trdata.filter  = self
			 local tr = util.TraceLine(trdata) 

			 local trdat2   = {}
			 trdat2.start   = tr.HitPos
			 trdat2.endpos  = trdata.start - trlength
			 trdat2.filter  = self
			 trdat2.mask    = MASK_WATER + CONTENTS_TRANSLUCENT
			 
			 local tr2 = util.TraceLine(trdat2)
			 
			 if tr2.Hit then
				 ParticleEffect(self.EffectWater, tr2.HitPos, Angle(0,0,0), nil)
			
			 end
		 else
			 local tracedata    = {}
			 tracedata.start    = pos
			 tracedata.endpos   = tracedata.start - Vector(0, 0, self.TraceLength)
			 tracedata.filter   = self.Entity
				
			 local trace = util.TraceLine(tracedata)
		 
			if trace.HitWorld then
				 ParticleEffect(self.Effect,pos,Angle(0,0,0),nil)	
				 timer.Simple(1, function()
					 if !self:IsValid() then return end 
					 self:Remove()
				end)	
			else 
				 ParticleEffect(self.EffectAir,pos,Angle(0,0,0),nil) 
				 self:Remove()
				 if(GetConVar("hb_nuclear_emp"):GetInt() >= 1) then
					 local ent = ents.Create("hb_emp_entity")
					 ent:SetPos( self:GetPos() ) 
					 ent:Spawn()
					 ent:Activate()	
				 end
			end
		end
	end
end

function ENT:SpawnFunction( ply, tr )
     if ( !tr.Hit ) then return end
	 self.HBOWNER = ply
     local ent = ents.Create( self.ClassName )
	 ent:SetPhysicsAttacker(ply)
     ent:SetPos( tr.HitPos + tr.HitNormal * 16 ) 
     ent:Spawn()
     ent:Activate()

     return ent
end
--addons/hbombs/lua/entities/hb_nuclear_fatman.lua:
AddCSLuaFile()

DEFINE_BASECLASS( "hb_base_advanced_nuke" )

ENT.Spawnable						 =  true         
ENT.AdminSpawnable					 =  true 

ENT.AdminOnly						 =  true

ENT.PrintName						 =  "Fat man"
ENT.Author							 =  "Business Cat"
ENT.Contact							 =  "nah"
ENT.Category                         =  "HBOMBS Nukes"

ENT.Model                            =  "models/thedoctor/fatman.mdl"                      
ENT.Effect                           =  "hbomb"                  
ENT.EffectAir                        =  "hbomb_airburst"                   
ENT.EffectWater                      =  "hbomb_underwater"
ENT.ExplosionSound                   =  "gbombs_5/explosions/nuclear/nukeaudio2.mp3"
ENT.ArmSound                         =  "npc/roller/mine/rmine_blip3.wav"            
ENT.ActivationSound                  =  "buttons/button14.wav"     

ENT.ShouldUnweld                     =  true
ENT.ShouldIgnite                     =  false
ENT.ShouldExplodeOnImpact            =  true
ENT.Flamable                         =  false
ENT.UseRandomSounds                  =  false
ENT.Timed                            =  false

ENT.ExplosionDamage                  =  500
ENT.PhysForce                        =  6500
ENT.ExplosionRadius                  =  10000
ENT.SpecialRadius                    =  5000
ENT.MaxIgnitionTime                  =  0
ENT.Life                             =  25                                  
ENT.MaxDelay                         =  2                                 
ENT.TraceLength                      =  1000
ENT.ImpactSpeed                      =  700
ENT.Mass                             =  4000
ENT.ArmDelay                         =  1   
ENT.Timer                            =  0


ENT.DEFAULT_PHYSFORCE                = 255
ENT.DEFAULT_PHYSFORCE_PLYAIR         = 25
ENT.DEFAULT_PHYSFORCE_PLYGROUND         = 2555

ENT.HBOWNER                          =  nil             -- don't you fucking touch this.
ENT.Decal                            = "nuke_medium"
function ENT:Initialize()
 if (SERVER) then
	 self:SetModel(self.Model)
	 self:PhysicsInit( SOLID_VPHYSICS )
	 self:SetSolid( SOLID_VPHYSICS )
	 self:SetMoveType( MOVETYPE_VPHYSICS )
	 self:SetUseType( ONOFF_USE ) -- doesen't fucking work
	 local phys = self:GetPhysicsObject()
	 if (phys:IsValid()) then
		 phys:SetMass(self.Mass)
		 phys:Wake()
	 end 
	 if(self.Dumb) then
		 self.Armed    = true
	 else
		 self.Armed    = false
	 end
	 self.Exploded = false
	 self.Used     = false
	 self.Arming = false
	 self.Exploding = false
	  if !(WireAddon == nil) then self.Inputs   = Wire_CreateInputs(self, { "Arm", "Detonate" }) end
	end
end

function ENT:Explode()
	 if !self.Exploded then return end
	 if self.Exploding then return end
	 local pos = self:LocalToWorld(self:OBBCenter())
	 
	 local ent = ents.Create("hb_shockwave_ent")
	 ent:SetPos( pos ) 
	 ent:Spawn()
	 ent:Activate()
	 ent:SetVar("DEFAULT_PHYSFORCE", self.DEFAULT_PHYSFORCE)
	 ent:SetVar("DEFAULT_PHYSFORCE_PLYAIR", self.DEFAULT_PHYSFORCE_PLYAIR)
	 ent:SetVar("DEFAULT_PHYSFORCE_PLYGROUND", 25)
	 ent:SetVar("HBOWNER", self.HBOWNER)
	 ent:SetVar("MAX_RANGE",10000)
	 ent:SetVar("SHOCKWAVE_INCREMENT",130)
	 ent:SetVar("DELAY",0.01)
	 ent:SetVar("SOUND", self.ExplosionSound)
	 self:SetModel("models/gibs/scanner_gib02.mdl")
	 ent.trace=self.TraceLength
	 ent.decal=self.Decal
	 	
	 local ent = ents.Create("hb_shockwave_ent_nounfreeze")
	 ent:SetPos( pos ) 
	 ent:Spawn()
	 ent:Activate()
	 ent:SetVar("DEFAULT_PHYSFORCE",10)
	 ent:SetVar("DEFAULT_PHYSFORCE_PLYAIR",1)
	 ent:SetVar("DEFAULT_PHYSFORCE_PLYGROUND",1)
	 ent:SetVar("HBOWNER", self.HBOWNER)
	 ent:SetVar("MAX_RANGE",25000)
	 ent:SetVar("SHOCKWAVE_INCREMENT",130)
	 ent:SetVar("DELAY",0.01)
	 ent.trace=self.TraceLength
	 ent.decal=self.Decal
	 
	if GetConVar("hb_nuclear_fallout"):GetInt()== 1 then
		local ent = ents.Create("hb_base_radiation_draw_ent")
		ent:SetPos( pos ) 
		ent:Spawn()
		ent:Activate()
		ent.Burst = 25
		ent.RadRadius=10000
		
		local ent = ents.Create("hb_base_radiation_ent")
		ent:SetPos( pos ) 
		ent:Spawn()
		ent:Activate()
		ent.Burst = 25
		ent.RadRadius=10000
	 end	 
	 local ent = ents.Create("hb_shockwave_sound_lowsh")
	 ent:SetPos( pos ) 
	 ent:Spawn()
	 ent:Activate()
	 ent:SetVar("HBOWNER", self.HBOWNER)
	 ent:SetVar("MAX_RANGE",50000)
	 ent:SetVar("SHOCKWAVE_INCREMENT",130)
	 ent:SetVar("DELAY",0.01)
	 ent:SetVar("SOUND", self.ExplosionSound)
	 self:SetModel("models/gibs/scanner_gib02.mdl")

	 self.Exploding = true
	
	 local physo = self:GetPhysicsObject()
	 physo:Wake()
	 physo:EnableMotion(true)
	 for k, v in pairs(ents.FindInSphere(pos,9000)) do
		 if (v:IsValid() or v:IsPlayer()) then
			if v:IsValid() and v:GetPhysicsObject():IsValid() then
				v:Ignite(4,0)
			end
		 end
	 end
	 for k, v in pairs(ents.FindInSphere(pos,self.SpecialRadius)) do
		if (v:IsValid() or v:IsPlayer()) then
			if v:IsPlayer() && !v:IsNPC() then
				v:SetModel("models/Humans/Charple04.mdl")
				v:Kill()
			end
		 end
	 end
	
  	 timer.Simple(2, function()
		 if !self:IsValid() then return end 
		 constraint.RemoveAll(self)
	
		 self:StopParticles()
		 for k, v in pairs(ents.FindInSphere(pos,self.SpecialRadius*2)) do
			 if self.ShouldUnweld then
				 if v:IsValid() then
					 if v:IsValid() and v:GetPhysicsObject():IsValid() then
						 constraint.RemoveAll(v)
					 end
				 end
			 end
		 end
	 end)
	 if(self:WaterLevel() >= 1) then
		 local trdata   = {}
		 local trlength = Vector(0,0,9000)

		 trdata.start   = pos
		 trdata.endpos  = trdata.start + trlength
		 trdata.filter  = self
		 local tr = util.TraceLine(trdata) 

		 local trdat2   = {}
		 trdat2.start   = tr.HitPos
		 trdat2.endpos  = trdata.start - trlength
		 trdat2.filter  = self
		 trdat2.mask    = MASK_WATER + CONTENTS_TRANSLUCENT
		 
		 local tr2 = util.TraceLine(trdat2)
		 
		 if tr2.Hit then
			 ParticleEffect(self.EffectWater, tr2.HitPos, Angle(0,0,0), nil)
		
		 end
	 else
		 local tracedata    = {}
		 tracedata.start    = pos
		 tracedata.endpos   = tracedata.start - Vector(0, 0, self.TraceLength)
		 tracedata.filter   = self.Entity
			
		 local trace = util.TraceLine(tracedata)
	 
		 if trace.HitWorld then
			 ParticleEffect(self.Effect,pos,Angle(0,0,0),nil)	
			 timer.Simple(2, function()
				 if !self:IsValid() then return end 
				 ParticleEffect("",trace.HitPos,Angle(0,0,0),nil)	
				 self:Remove()
			end)	
		 else 
			 ParticleEffect(self.EffectAir,pos,Angle(0,0,0),nil) 
			 --Here we do an emp check
			if(GetConVar("hb_nuclear_emp"):GetInt() >= 1) then
				 local ent = ents.Create("hb_emp_entity")
				 ent:SetPos( self:GetPos() ) 
				 ent:Spawn()
				 ent:Activate()	
			 end
		 end
	 end
end

function ENT:SpawnFunction( ply, tr )
	 if ( !tr.Hit ) then return end
	 self.HBOWNER = ply
	 local ent = ents.Create( self.ClassName )
	 ent:SetPhysicsAttacker(ply)
	 ent:SetPos( tr.HitPos + tr.HitNormal * 64 ) 
	 ent:Spawn()
	 ent:Activate()

	 return ent
end
--addons/hbombs/lua/entities/hb_nuclear_ivymike.lua:
AddCSLuaFile()

DEFINE_BASECLASS( "hb_base_advanced_nuke" )

ENT.Spawnable						 =  true         
ENT.AdminSpawnable					 =  true 

ENT.AdminOnly						 =  true

ENT.PrintName						 =  "Ivy Mike"
ENT.Author							 =  "Business Cat"
ENT.Contact							 =  "nah"
ENT.Category                         =  "HBOMBS Nukes"

ENT.Model                            =  "models/thedoctor/ivy_mike.mdl"                      
ENT.Effect                           =  "hnuke2"                  
ENT.EffectAir                        =  "hnuke2_airburst"                   
ENT.EffectWater                      =  "hbomb_underwater"
ENT.ExplosionSound                   =  "gbombs_5/explosions/nuclear/nukeaudio3.mp3"
ENT.ArmSound                         =  "npc/roller/mine/rmine_blip3.wav"            
ENT.ActivationSound                  =  "buttons/button14.wav"     

ENT.ShouldUnweld                     =  true
ENT.ShouldIgnite                     =  false
ENT.ShouldExplodeOnImpact            =  true
ENT.Flamable                         =  false
ENT.UseRandomSounds                  =  false
ENT.Timed                            =  false

ENT.ExplosionDamage                  =  500
ENT.PhysForce                        =  2500
ENT.ExplosionRadius                  =  18000
ENT.SpecialRadius                    =  9000
ENT.MaxIgnitionTime                  =  0
ENT.Life                             =  25                                  
ENT.MaxDelay                         =  2                                 
ENT.TraceLength                      =  2000
ENT.ImpactSpeed                      =  700
ENT.Mass                             =  18500
ENT.ArmDelay                         =  1   
ENT.Timer                            =  0

ENT.HBOWNER                          =  nil             -- don't you fucking touch this.
ENT.Decal                            = "nuke_big"
function ENT:Initialize()
 if (SERVER) then
	 self:SetModel(self.Model)
	 self:PhysicsInit( SOLID_VPHYSICS )
	 self:SetSolid( SOLID_VPHYSICS )
	 self:SetMoveType( MOVETYPE_VPHYSICS )
	 self:SetUseType( ONOFF_USE ) -- doesen't fucking work
	 local phys = self:GetPhysicsObject()
	 if (phys:IsValid()) then
		 phys:SetMass(self.Mass)
		 phys:Wake()
	 end 
	 if(self.Dumb) then
		 self.Armed    = true
	 else
		 self.Armed    = false
	 end
	 self.Exploded = false
	 self.Used     = false
	 self.Arming = false
	 self.Exploding = false
	  if !(WireAddon == nil) then self.Inputs   = Wire_CreateInputs(self, { "Arm", "Detonate" }) end
	end
end


function ENT:Explode()
	 if !self.Exploded then return end
	 if self.Exploding then return end
	
	 local pos = self:LocalToWorld(self:OBBCenter())
	 local ent = ents.Create("hb_shockwave_ent")
	 ent:SetPos( pos ) 
	 ent:Spawn()
	 ent:Activate()
	 ent:SetVar("DEFAULT_PHYSFORCE", 200)
	 ent:SetVar("DEFAULT_PHYSFORCE_PLYAIR", self.DEFAULT_PHYSFORCE_PLYAIR)
	 ent:SetVar("DEFAULT_PHYSFORCE_PLYGROUND", 25)
	 ent:SetVar("HBOWNER", self.HBOWNER)
	 ent:SetVar("MAX_RANGE",18000)
	 ent:SetVar("SHOCKWAVE_INCREMENT",200)
	 ent:SetVar("DELAY",0.01)
	 ent:SetVar("SOUND", "gbombs_5/explosions/nuclear/nukeaudio3.mp3")
	 ent.trace=self.TraceLength
	 ent.decal=self.Decal

	 local ent = ents.Create("hb_shockwave_ent_nounfreeze")	 
	 ent:SetPos( pos ) 
	 ent:Spawn()
	 ent:Activate()
	 ent:SetVar("DEFAULT_PHYSFORCE",20)
	 ent:SetVar("DEFAULT_PHYSFORCE_PLYAIR",5)
	 ent:SetVar("DEFAULT_PHYSFORCE_PLYGROUND",1)
	 ent:SetVar("HBOWNER", self.HBOWNER)
	 ent:SetVar("MAX_RANGE",40000)
	 ent:SetVar("SHOCKWAVE_INCREMENT",200)
	 ent:SetVar("DELAY",0.01)
	 ent.trace=self.TraceLength
	 ent.decal=self.Decal
	 
	if GetConVar("hb_nuclear_fallout"):GetInt()== 1 then
		local ent = ents.Create("hb_base_radiation_draw_ent")
		ent:SetPos( pos ) 
		ent:Spawn()
		ent:Activate()
		ent.Burst = 25
		ent.RadRadius=18000
		
		local ent = ents.Create("hb_base_radiation_ent")
		ent:SetPos( pos ) 
		ent:Spawn()
		ent:Activate()
		ent.Burst = 25
		ent.RadRadius=18000
	 end			 
	 local ent = ents.Create("hb_shockwave_rumbling")
	 ent:SetPos( pos ) 
	 ent:Spawn()
	 ent:Activate()
	 ent:SetVar("HBOWNER", self.HBOWNER)
	 ent:SetVar("MAX_RANGE",19000)
	 ent:SetVar("SHOCKWAVE_INCREMENT",220)
	 ent:SetVar("DELAY",0.01)
	 ent:SetVar("SOUND", self.ExplosionSound)
	 
	 local ent = ents.Create("hb_shockwave_sound_lowsh")
	 ent:SetPos( pos ) 
	 ent:Spawn()
	 ent:Activate()
	 ent:SetVar("HBOWNER", self.HBOWNER)
	 ent:SetVar("MAX_RANGE",50000)
	 ent:SetVar("SHOCKWAVE_INCREMENT",210)
	 ent:SetVar("DELAY",0.01)
	 ent:SetVar("SOUND", "gbombs_5/explosions/nuclear/nukeaudio3.mp3")
	 self:SetModel("models/gibs/scanner_gib02.mdl")
	 self.Exploding = true
	
	 local physo = self:GetPhysicsObject()
	 physo:Wake()
	 physo:EnableMotion(true)
	 for k, v in pairs(ents.FindInSphere(pos,self.SpecialRadius*3)) do
		 if (v:IsValid() or v:IsPlayer()) then
			if v:IsValid() and v:GetPhysicsObject():IsValid() then
				v:Ignite(4,0)
			end
		 end
	 end
	 for k, v in pairs(ents.FindInSphere(pos,self.SpecialRadius)) do
		if (v:IsValid() or v:IsPlayer()) then
			if v:IsPlayer() then
				v:SetModel("models/Humans/Charple04.mdl")
				v:Kill()
				ParticleEffectAttach("nuke_player_vaporize_fatman",PATTACH_POINT_FOLLOW,v,0) 
			end
		 end
	 end
	
  	 timer.Simple(2, function()
		 if !self:IsValid() then return end 
		 constraint.RemoveAll(self)
		 if GetConVar("hb_sound_shake"):GetInt()== 1 then
			util.ScreenShake( pos, 55555, 255, 10, 121000 )
		 else return end
		 self:StopParticles()
		 for k, v in pairs(ents.FindInSphere(pos,self.SpecialRadius*2)) do
			 if self.ShouldUnweld then
				 if v:IsValid() then
					 if v:IsValid() and v:GetPhysicsObject():IsValid() then
						 constraint.RemoveAll(v)
					 end
				 end
			 end
		 end
	 end)
	 if(self:WaterLevel() >= 1) then
		 local trdata   = {}
		 local trlength = Vector(0,0,9000)

		 trdata.start   = pos
		 trdata.endpos  = trdata.start + trlength
		 trdata.filter  = self
		 local tr = util.TraceLine(trdata) 

		 local trdat2   = {}
		 trdat2.start   = tr.HitPos
		 trdat2.endpos  = trdata.start - trlength
		 trdat2.filter  = self
		 trdat2.mask    = MASK_WATER + CONTENTS_TRANSLUCENT
		 
		 local tr2 = util.TraceLine(trdat2)
		 
		 if tr2.Hit then
			 ParticleEffect(self.EffectWater, tr2.HitPos, Angle(0,0,0), nil)
		
		 end
	 else
		 local tracedata    = {}
		 tracedata.start    = pos
		 tracedata.endpos   = tracedata.start - Vector(0, 0, self.TraceLength)
		 tracedata.filter   = self.Entity
			
		 local trace = util.TraceLine(tracedata)
	 
		 if trace.HitWorld then
			 ParticleEffect(self.Effect,pos,Angle(0,0,0),nil)	
			 timer.Simple(2, function()
				 if !self:IsValid() then return end 
				 ParticleEffect("",trace.HitPos,Angle(0,0,0),nil)	
				 self:Remove()
		 end)	
		 else 
			 ParticleEffect(self.EffectAir,pos,Angle(0,0,0),nil) 
			 --Here we do an emp check
			 timer.Simple(2, function()
				 if !self:IsValid() then return end 
				 ParticleEffect("",trace.HitPos,Angle(0,0,0),nil)	
				 self:Remove()
			end)	
			 if(GetConVar("hb_nuclear_emp"):GetInt() >= 1) then
				 local ent = ents.Create("hb_emp_entity")
				 ent:SetPos( self:GetPos() ) 
				 ent:Spawn()
				 ent:Activate()	
			 end
		 end
	 end
end

function ENT:SpawnFunction( ply, tr )
	 if ( !tr.Hit ) then return end
	 self.HBOWNER = ply
	 local ent = ents.Create( self.ClassName )
	 ent:SetPhysicsAttacker(ply)
	 ent:SetPos( tr.HitPos + tr.HitNormal * 256 ) 
	 ent:Spawn()
	 ent:Activate()

	 return ent
end
--addons/hbombs/lua/entities/hb_nuclear_megatonbomb.lua:
AddCSLuaFile()

DEFINE_BASECLASS( "hb_base_advanced_nuke" )

ENT.Spawnable						 =  true         
ENT.AdminSpawnable					 =  true 

ENT.AdminOnly						 =  true

ENT.PrintName						 =  "Megaton Bomb"
ENT.Author							 =  "Business Cat"
ENT.Contact							 =  "nah"
ENT.Category                         =  "HBOMBS Nukes"

ENT.Model                            =  "models/props_fallout/megatonbomb.mdl"                      
ENT.Effect                           =  "hnuke3"                  
ENT.EffectAir                        =  "hnuke3_airburst"                   
ENT.EffectWater                      =  "hbomb_underwater"
ENT.ArmSound                         =  "npc/roller/mine/rmine_blip3.wav"            
ENT.ActivationSound                  =  "buttons/button14.wav"     

ENT.ShouldUnweld                     =  true
ENT.ShouldIgnite                     =  false
ENT.ShouldExplodeOnImpact            =  true
ENT.Flamable                         =  false
ENT.UseRandomSounds                  =  false
ENT.Timed                            =  false

ENT.ExplosionDamage                  =  500
ENT.PhysForce                        =  6500
ENT.ExplosionRadius                  =  15000
ENT.SpecialRadius                    =  6000
ENT.MaxIgnitionTime                  =  0
ENT.Life                             =  25                                  
ENT.MaxDelay                         =  2                                 
ENT.TraceLength                      =  2000
ENT.ImpactSpeed                      =  700
ENT.Mass                             =  20000
ENT.ArmDelay                         =  1   
ENT.Timer                            =  0

ENT.DEFAULT_PHYSFORCE                = 655
ENT.DEFAULT_PHYSFORCE_PLYAIR         = 25
ENT.DEFAULT_PHYSFORCE_PLYGROUND      = 2555

ENT.HBOWNER                          =  nil             -- don't you fucking touch this.
ENT.Decal                            = "nuke_medium"
function ENT:Initialize()
 if (SERVER) then
	 self:SetModel(self.Model)
	 self:PhysicsInit( SOLID_VPHYSICS )
	 self:SetSolid( SOLID_VPHYSICS )
	 self:SetMoveType( MOVETYPE_VPHYSICS )
	 self:SetUseType( ONOFF_USE ) -- doesen't fucking work
	 local phys = self:GetPhysicsObject()
	 if (phys:IsValid()) then
		 phys:SetMass(self.Mass)
		 phys:Wake()
	 end 
	 if(self.Dumb) then
		 self.Armed    = true
	 else
		 self.Armed    = false
	 end
	 self.Exploded = false
	 self.Used     = false
	 self.Arming = false
	 self.Exploding = false
	  if !(WireAddon == nil) then self.Inputs   = Wire_CreateInputs(self, { "Arm", "Detonate" }) end
	end
end

function ENT:Explode()
	 if !self.Exploded then return end
	 if self.Exploding then return end
	
	 local pos = self:LocalToWorld(self:OBBCenter())
	 self:SetModel("models/gibs/scanner_gib02.mdl")
	 self.Exploding = true
	
	 local physo = self:GetPhysicsObject()
	 physo:Wake()
	 physo:EnableMotion(true)
	 for k, v in pairs(ents.FindInSphere(pos,10000)) do
		 if (v:IsValid() or v:IsPlayer()) then
			if v:IsValid() and v:GetPhysicsObject():IsValid() then
				v:Ignite(4,0)
			end
		 end
	 end
	 for k, v in pairs(ents.FindInSphere(pos,6000)) do
		if (v:IsValid() or v:IsPlayer()) then
			if v:IsPlayer() && !v:IsNPC() then
				v:SetModel("models/Humans/Charple04.mdl")
				v:Kill()
			end
		 end
	 end
	 
  	 timer.Simple(0.1, function()
		 if !self:IsValid() then return end 
		 if GetConVar("hb_nuclear_fallout"):GetInt()== 1 then
			local ent = ents.Create("hb_base_radiation_draw_ent")
			ent:SetPos( pos ) 
			ent:Spawn()
			ent:Activate()
			ent.Burst = 25
			ent.RadRadius=9000
			
			local ent = ents.Create("hb_base_radiation_ent")
			ent:SetPos( pos ) 
			ent:Spawn()
			ent:Activate()
			ent.Burst = 25
			ent.RadRadius=9000
		 end	
		 local ent = ents.Create("hb_shockwave_ent")
		 ent:SetPos( pos ) 
		 ent:Spawn()
		 ent:Activate()
		 ent:SetVar("DEFAULT_PHYSFORCE", 150)
		 ent:SetVar("DEFAULT_PHYSFORCE_PLYAIR", self.DEFAULT_PHYSFORCE_PLYAIR)
		 ent:SetVar("DEFAULT_PHYSFORCE_PLYGROUND", 25)
		 ent:SetVar("HBOWNER", self.HBOWNER)
		 ent:SetVar("MAX_RANGE",12000)
		 ent:SetVar("SHOCKWAVE_INCREMENT",140)
		 ent:SetVar("DELAY",0.01)
		 ent:SetVar("SOUND", "gbombs_5/explosions/nuclear/nukeaudio1.mp3")
		 ent.trace=self.TraceLength
		 ent.decal=self.Decal
		 
		 local ent = ents.Create("hb_shockwave_ent_nounfreeze")
		 ent:SetPos( pos ) 
		 ent:Spawn()
		 ent:Activate()
		 ent:SetVar("DEFAULT_PHYSFORCE",10)
		 ent:SetVar("DEFAULT_PHYSFORCE_PLYAIR",1)
		 ent:SetVar("DEFAULT_PHYSFORCE_PLYGROUND",1)
		 ent:SetVar("HBOWNER", self.HBOWNER)
		 ent:SetVar("MAX_RANGE",25000)
		 ent:SetVar("SHOCKWAVE_INCREMENT",140)
		 ent:SetVar("DELAY",0.01)
		 ent.trace=self.TraceLength
		 ent.decal=self.Decal
		 
		 local ent = ents.Create("hb_shockwave_sound_lowsh")
		 ent:SetPos( pos ) 
		 ent:Spawn()
		 ent:Activate()
		 ent:SetVar("HBOWNER", self.HBOWNER)
		 ent:SetVar("MAX_RANGE",50000)
		 ent:SetVar("SHOCKWAVE_INCREMENT",130)
		 ent:SetVar("DELAY",0.01)
		 ent:SetVar("SOUND", "gbombs_5/explosions/nuclear/nukeaudio1.mp3")
		 
		 self.Exploding = true
		 constraint.RemoveAll(self)
		 
		 if GetConVar("hb_sound_shake"):GetInt()== 1 then
			util.ScreenShake( pos, 55555, 255, 10, 121000 )
		 else return end
		 self:StopParticles()
	 end)
	 
		 if(self:WaterLevel() >= 1) then
		 	 local trdata   = {}
			 local trlength = Vector(0,0,9000)

			 trdata.start   = pos
			 trdata.endpos  = trdata.start + trlength
			 trdata.filter  = self
			 local tr = util.TraceLine(trdata) 

			 local trdat2   = {}
			 trdat2.start   = tr.HitPos
			 trdat2.endpos  = trdata.start - trlength
			 trdat2.filter  = self
			 trdat2.mask    = MASK_WATER + CONTENTS_TRANSLUCENT
			 
			 local tr2 = util.TraceLine(trdat2)
			 
			 if tr2.Hit then
				 ParticleEffect(self.EffectWater, tr2.HitPos, Angle(0,0,0), nil)
			
			 end
		 else
			 local tracedata    = {}
			 tracedata.start    = pos
			 tracedata.endpos   = tracedata.start - Vector(0, 0, self.TraceLength)
			 tracedata.filter   = self.Entity
				
			 local trace = util.TraceLine(tracedata)
		 
			 if trace.HitWorld then
				 ParticleEffect(self.Effect,pos,Angle(0,0,0),nil)	
				 timer.Simple(2, function()
					 if !self:IsValid() then return end 
					 ParticleEffect("",trace.HitPos,Angle(0,0,0),nil)	
					 self:Remove()
			 end)	
			 else 
				 ParticleEffect(self.EffectAir,pos,Angle(0,0,0),nil) 
				timer.Simple(2, function()
					 if !self:IsValid() then return end 
					 ParticleEffect("",trace.HitPos,Angle(0,0,0),nil)	
					 self:Remove()
				end)	
				 --Here we do an emp check
				if(GetConVar("hb_nuclear_emp"):GetInt() >= 1) then
					 local ent = ents.Create("hb_emp_entity")
					 ent:SetPos( self:GetPos() ) 
					 ent:Spawn()
					 ent:Activate()	
				 end
		 end
	end
end

function ENT:SpawnFunction( ply, tr )
	 if ( !tr.Hit ) then return end
	 self.HBOWNER = ply
	 local ent = ents.Create( self.ClassName )
	 ent:SetPhysicsAttacker(ply)
	 ent:SetPos( tr.HitPos + tr.HitNormal * 110 ) 
	 ent:Spawn()
	 ent:Activate()
	 ent:SetAngles(Angle(0,0,90))	 

	 return ent
end
--addons/hbombs/lua/entities/hb_nuclear_trinity_noflash.lua:
AddCSLuaFile()

DEFINE_BASECLASS( "hb_base_advanced_nuke" )

ENT.Spawnable						 =  true         
ENT.AdminSpawnable					 =  true 

ENT.AdminOnly						 =  true

ENT.PrintName						 =  "Gadget - No Flash"
ENT.Author							 =  "Business Cat"
ENT.Contact							 =  "nah"
ENT.Category                         =  "HBOMBS Nukes"

ENT.Model                            =  "models/thedoctor/gadget.mdl"                      
ENT.Effect                           =  "h_nuke3_a"                  
ENT.EffectAir                        =  "h_nuke3_airburst_a"                   
ENT.EffectWater                      =  "hbomb_underwater"
ENT.ArmSound                         =  "npc/roller/mine/rmine_blip3.wav"            
ENT.ActivationSound                  =  "buttons/button14.wav"     

ENT.ShouldUnweld                     =  true
ENT.ShouldIgnite                     =  false
ENT.ShouldExplodeOnImpact            =  true
ENT.Flamable                         =  false
ENT.UseRandomSounds                  =  false
ENT.Timed                            =  false

ENT.ExplosionDamage                  =  500
ENT.PhysForce                        =  6500
ENT.ExplosionRadius                  =  11000
ENT.SpecialRadius                    =  4500
ENT.MaxIgnitionTime                  =  0
ENT.Life                             =  25                                  
ENT.MaxDelay                         =  2                                 
ENT.TraceLength                      =  2000
ENT.ImpactSpeed                      =  700
ENT.Mass                             =  5000
ENT.ArmDelay                         =  1   
ENT.Timer                            =  0

ENT.DEFAULT_PHYSFORCE                = 655
ENT.DEFAULT_PHYSFORCE_PLYAIR         = 25
ENT.DEFAULT_PHYSFORCE_PLYGROUND      = 2555

ENT.HBOWNER                          =  nil             -- don't you fucking touch this.
ENT.Decal                            = "nuke_medium"
function ENT:Initialize()
 if (SERVER) then
	 self:SetModel(self.Model)
	 self:PhysicsInit( SOLID_VPHYSICS )
	 self:SetSolid( SOLID_VPHYSICS )
	 self:SetMoveType( MOVETYPE_VPHYSICS )
	 self:SetUseType( ONOFF_USE ) -- doesen't fucking work
	 local phys = self:GetPhysicsObject()
	 if (phys:IsValid()) then
		 phys:SetMass(self.Mass)
		 phys:Wake()
	 end 
	 if(self.Dumb) then
		 self.Armed    = true
	 else
		 self.Armed    = false
	 end
	 self.Exploded = false
	 self.Used     = false
	 self.Arming = false
	 self.Exploding = false
	  if !(WireAddon == nil) then self.Inputs   = Wire_CreateInputs(self, { "Arm", "Detonate" }) end
	end
end

function ENT:Explode()
	 if !self.Exploded then return end
	 if self.Exploding then return end
	
	 local pos = self:LocalToWorld(self:OBBCenter())
	 self:SetModel("models/gibs/scanner_gib02.mdl")
	 self.Exploding = true
	
	 local physo = self:GetPhysicsObject()
	 physo:Wake()
	 physo:EnableMotion(true)
	 for k, v in pairs(ents.FindInSphere(pos,10000)) do
		 if (v:IsValid() or v:IsPlayer()) then
			if v:IsValid() and v:GetPhysicsObject():IsValid() then
				v:Ignite(4,0)
			end
		 end
	 end
	 for k, v in pairs(ents.FindInSphere(pos,6000)) do
		if (v:IsValid() or v:IsPlayer()) then
			if v:IsPlayer() && !v:IsNPC() then
				v:SetModel("models/Humans/Charple04.mdl")
				v:Kill()
			end
		 end
	 end
	 
  	 timer.Simple(0.1, function()
		 if !self:IsValid() then return end 
		 if GetConVar("hb_nuclear_fallout"):GetInt()== 1 then
			local ent = ents.Create("hb_base_radiation_draw_ent")
			ent:SetPos( pos ) 
			ent:Spawn()
			ent:Activate()
			ent.Burst = 25
			ent.RadRadius=9000
			
			local ent = ents.Create("hb_base_radiation_ent")
			ent:SetPos( pos ) 
			ent:Spawn()
			ent:Activate()
			ent.Burst = 25
			ent.RadRadius=9000
		 end	
		 local ent = ents.Create("hb_shockwave_ent")
		 ent:SetPos( pos ) 
		 ent:Spawn()
		 ent:Activate()
		 ent:SetVar("DEFAULT_PHYSFORCE", 150)
		 ent:SetVar("DEFAULT_PHYSFORCE_PLYAIR", self.DEFAULT_PHYSFORCE_PLYAIR)
		 ent:SetVar("DEFAULT_PHYSFORCE_PLYGROUND", 25)
		 ent:SetVar("HBOWNER", self.HBOWNER)
		 ent:SetVar("MAX_RANGE",12000)
		 ent:SetVar("SHOCKWAVE_INCREMENT",140)
		 ent:SetVar("DELAY",0.01)
		 ent:SetVar("SOUND", "gbombs_5/explosions/nuclear/nukeaudio1.mp3")
		 ent.trace=self.TraceLength
		 ent.decal=self.Decal
		 
		 local ent = ents.Create("hb_shockwave_ent_nounfreeze")
		 ent:SetPos( pos ) 
		 ent:Spawn()
		 ent:Activate()
		 ent:SetVar("DEFAULT_PHYSFORCE",10)
		 ent:SetVar("DEFAULT_PHYSFORCE_PLYAIR",1)
		 ent:SetVar("DEFAULT_PHYSFORCE_PLYGROUND",1)
		 ent:SetVar("HBOWNER", self.HBOWNER)
		 ent:SetVar("MAX_RANGE",25000)
		 ent:SetVar("SHOCKWAVE_INCREMENT",140)
		 ent:SetVar("DELAY",0.01)
		 ent.trace=self.TraceLength
		 ent.decal=self.Decal
		 
		 local ent = ents.Create("hb_shockwave_sound_lowsh")
		 ent:SetPos( pos ) 
		 ent:Spawn()
		 ent:Activate()
		 ent:SetVar("HBOWNER", self.HBOWNER)
		 ent:SetVar("MAX_RANGE",50000)
		 ent:SetVar("SHOCKWAVE_INCREMENT",130)
		 ent:SetVar("DELAY",0.01)
		 ent:SetVar("SOUND", "gbombs_5/explosions/nuclear/nukeaudio1.mp3")
		 
		 self.Exploding = true
		 constraint.RemoveAll(self)
		 
		 if GetConVar("hb_sound_shake"):GetInt()== 1 then
			util.ScreenShake( pos, 55555, 255, 10, 121000 )
		 else return end
		 self:StopParticles()
	 end)
	 
		 if(self:WaterLevel() >= 1) then
		 	 local trdata   = {}
			 local trlength = Vector(0,0,9000)

			 trdata.start   = pos
			 trdata.endpos  = trdata.start + trlength
			 trdata.filter  = self
			 local tr = util.TraceLine(trdata) 

			 local trdat2   = {}
			 trdat2.start   = tr.HitPos
			 trdat2.endpos  = trdata.start - trlength
			 trdat2.filter  = self
			 trdat2.mask    = MASK_WATER + CONTENTS_TRANSLUCENT
			 
			 local tr2 = util.TraceLine(trdat2)
			 
			 if tr2.Hit then
				 ParticleEffect(self.EffectWater, tr2.HitPos, Angle(0,0,0), nil)
			
			 end
		 else
			 local tracedata    = {}
			 tracedata.start    = pos
			 tracedata.endpos   = tracedata.start - Vector(0, 0, self.TraceLength)
			 tracedata.filter   = self.Entity
				
			 local trace = util.TraceLine(tracedata)
		 
			 if trace.HitWorld then
				 ParticleEffect(self.Effect,pos,Angle(0,0,0),nil)	
				 timer.Simple(2, function()
					 if !self:IsValid() then return end 
					 ParticleEffect("",trace.HitPos,Angle(0,0,0),nil)	
					 self:Remove()
			 end)	
			 else 
				 ParticleEffect(self.EffectAir,pos,Angle(0,0,0),nil) 
				timer.Simple(2, function()
					 if !self:IsValid() then return end 
					 ParticleEffect("",trace.HitPos,Angle(0,0,0),nil)	
					 self:Remove()
				end)	
				 --Here we do an emp check
				if(GetConVar("hb_nuclear_emp"):GetInt() >= 1) then
					 local ent = ents.Create("hb_emp_entity")
					 ent:SetPos( self:GetPos() ) 
					 ent:Spawn()
					 ent:Activate()	
				 end
		 end
	end
end

function ENT:SpawnFunction( ply, tr )
	 if ( !tr.Hit ) then return end
	 self.HBOWNER = ply
	 local ent = ents.Create( self.ClassName )
	 ent:SetPhysicsAttacker(ply)
	 ent:SetPos( tr.HitPos + tr.HitNormal * 80 ) 
	 ent:Spawn()
	 ent:Activate()
	 ent:SetAngles(Angle(0,0,90))	
	 
	 return ent
end
--addons/hbombs/lua/entities/hb_proj_icbm.lua:
AddCSLuaFile()

DEFINE_BASECLASS( "hb_base_rocket_" )

ENT.Spawnable						 =  true         
ENT.AdminSpawnable					 =  true 

ENT.AdminOnly						 =  true

ENT.PrintName						 =  "ICBM - GEE Mk 02"
ENT.Author							 =  ""
ENT.Contact							 =  ""
ENT.Category                         =  "HBOMBS Custom"

ENT.Model                            =  "models/thedoctor/icbm/body.mdl"
ENT.RocketTrail                      =  "h_rkt_trail"
ENT.RocketBurnoutTrail               =  ""
ENT.Effect                           =  "h_1000lb"
ENT.EffectAir                        =  "h_1000lb_air"
ENT.EffectWater                      =  "h_water_small" 
ENT.ExplosionSound                   =  "gbombs_5/launch/srb_explo.wav"        
ENT.StartSound                       =  "gbombs_5/launch/srb_launch.wav"          
ENT.ArmSound                         =  "npc/roller/mine/rmine_blip3.wav"            
ENT.ActivationSound                  =  "buttons/button14.wav"    
ENT.EngineSound                      =  "Motor_Medium"

ENT.ShouldUnweld                     =  true          
ENT.ShouldIgnite                     =  true         
ENT.UseRandomSounds                  =  false         
ENT.SmartLaunch                      =  false
ENT.Timed                            =  false 

ENT.ExplosionDamage                  =  150
ENT.ExplosionRadius                  =  1500             
ENT.PhysForce                        =  1000             
ENT.SpecialRadius                    =  2500            
ENT.MaxIgnitionTime                  =  2           
ENT.Life                             =  35            
ENT.MaxDelay                         =  0           
ENT.TraceLength                      =  600           
ENT.ImpactSpeed                      =  800         
ENT.Mass                             =  19000             
ENT.EnginePower                      =  10          
ENT.FuelBurnoutTime                  =  20           
ENT.IgnitionDelay                    =  2            
ENT.ArmDelay                         =  0.5
ENT.RotationalForce                  =  0                      
ENT.ForceOrientation                 =  "NONE"
ENT.Timer                            =  0
ENT.Shocktime                        = 3
ENT.HBOWNER                          =  nil             -- don't you fucking touch this.

function ENT:Initialize()
 if (SERVER) then
	 self:SetModel(self.Model)  
	 self:PhysicsInit( SOLID_VPHYSICS )
	 self:SetSolid( SOLID_VPHYSICS )
	 self:SetMoveType(MOVETYPE_VPHYSICS)
	 self:SetUseType( ONOFF_USE ) -- doesen't fucking work
	 local phys = self:GetPhysicsObject()
	 local skincount = self:SkinCount()
	 if (phys:IsValid()) then
		 phys:SetMass(self.Mass)
		 phys:Wake()
	 end
	 if (skincount > 0) then
		 self:SetSkin(math.random(0,skincount))
	 end
	 self.Armed    = false
	 self.Exploded = false
	 self.Fired    = false
	 self.Burnt    = false
	 self.Ignition = false
	 self.Arming   = false
	 self.Power    = 0.8
	 if !(WireAddon == nil) then self.Inputs = Wire_CreateInputs(self, { "Arm", "Detonate", "Launch" }) end
	end
end

function ENT:ExploSound(pos)
	 local ent = ents.Create("hb_shockwave_sound_lowsh")
	 ent:SetPos( pos ) 
	 ent:Spawn()
	 ent:Activate()
	 ent:SetVar("HBOWNER", self.HBOWNER)
	 ent:SetVar("MAX_RANGE",500000)
	 ent:SetVar("SHOCKWAVE_INCREMENT",20000)
	 ent:SetVar("DELAY",0.01)
	 ent:SetVar("SOUND", self.ExplosionSound)
	 ent:SetVar("Shocktime",4)
end

function ENT:Think()
	 if(self.Burnt) then return end
	 if(!self.Ignition) then return end -- if there wasn't ignition, we won't fly
	 if(self.Exploded) then return end -- if we exploded then what the fuck are we doing here
	 if(!self:IsValid()) then return end -- if we aren't good then something fucked up
	 if self.Power <= 1.5 then
		self.Power = self.Power + 0.0005
	 elseif self.Power >=1.5 then
		self.Power = 1.5
	 end
	
	 local phys = self:GetPhysicsObject()  
	 local thrustpos = self:GetPos()
	 if(self.ForceOrientation == "RIGHT") then
		 phys:AddVelocity(self:GetRight() * self.EnginePower) -- Continuous engine impulse
	 elseif(self.ForceOrientation == "LEFT") then
		 phys:AddVelocity(self:GetRight() * -self.EnginePower) -- Continuous engine impulse
	 elseif(self.ForceOrientation == "UP") then
		 phys:AddVelocity(self:GetUp() * self.EnginePower) -- Continuous engine impulse
	 elseif(self.ForceOrientation == "DOWN") then 
		 phys:AddVelocity(self:GetUp() * -self.EnginePower) -- Continuous engine impulse
	 elseif(self.ForceOrientation == "INV") then
		 phys:AddVelocity(self:GetForward() * -self.EnginePower) -- Continuous engine impulse
	 else
		 local tickrate = 1 / engine.TickInterval()
		 
		 if tickrate >= 65 and tickrate <=67 then
			phys:AddVelocity(self:GetForward() * (12*self.Power)) -- Continuous engine impulse
		 else
			phys:AddVelocity(self:GetForward() * 2*(12*self.Power)) -- Continuous engine impulse
		 end
	 end
	 if (self.Armed) then
		phys:AddAngleVelocity(Vector(self.RotationalForce,0,0)) -- Rotational force
	 end
	 
	 self:NextThink(CurTime() + 0.01)
	 return true
end

function ENT:Launch()
	 if(self.Exploded) then return end
	 if(self.Burned) then return end
	 --if(self.Armed) then return end
	 if(self.Fired) then return end
	 
	 local phys = self:GetPhysicsObject()
	 if !phys:IsValid() then return end
	 
	 self.Fired = true
	 if(self.SmartLaunch) then
		 constraint.RemoveAll(self)
	 end
	 timer.Simple(0.05,function()
		 if not self:IsValid() then return end
		 if(phys:IsValid()) then
			 phys:Wake()
			 phys:EnableMotion(true)
		 end
	 end)
	 timer.Simple(self.IgnitionDelay,function()
		 if not self:IsValid() then return end  -- Make a short ignition delay!

		 local phys = self:GetPhysicsObject()
		 self.Ignition = true
		 self:Arm()
		 local pos = self:GetPos()
		 sound.Play(self.StartSound, pos, 160, 130,1)
		 self:EmitSound(self.EngineSound)

		 ParticleEffectAttach(self.RocketTrail,PATTACH_ABSORIGIN_FOLLOW,self,1)
		 util.ScreenShake( self:GetPos(), 5555, 3555, 10, 500 )
		 util.ScreenShake( self:GetPos(), 5555, 555, 8, 500 )
		 util.ScreenShake( self:GetPos(), 5555, 555, 5, 500 )
		 if(self.FuelBurnoutTime != 0) then 
			 timer.Simple(self.FuelBurnoutTime,function()
				 if not self:IsValid() then return end 
				 self.Burnt = true
				 self:StopParticles()
				 self:StopSound(self.EngineSound)
				 ParticleEffectAttach(self.RocketBurnoutTrail,PATTACH_ABSORIGIN_FOLLOW,self,1)
			 end)	 
		 end
	 end)		 
end

function ENT:SpawnFunction( ply, tr )
	 if ( !tr.Hit ) then return end
	 self.HBOWNER = ply
	 local ent = ents.Create( self.ClassName )
	 ent:SetPhysicsAttacker(ply)
	 ent:SetPos( tr.HitPos + tr.HitNormal * 92 ) 
	 ent:Spawn()
	 ent:SetAngles(Angle(-90,0,0))
	 ent:Activate()

	 return ent
end
--addons/hbombs_base/lua/entities/hb_shockwave_ent_gravity.lua:
AddCSLuaFile()

DEFINE_BASECLASS( "base_anim" )


ENT.Spawnable		            	 =  false
ENT.AdminSpawnable		             =  false     

ENT.PrintName		                 =  ""        
ENT.Author			                 =  ""      
ENT.Contact			                 =  ""      

ENT.HBOWNER                          =  nil            
ENT.MAX_RANGE                        = 0
ENT.DELAY                            = 0
ENT.SOUND                            = ""
ENT.Burst                            = 0 


sound.Add( {
	name = "anti_grav",
	channel = CHAN_STATIC,
	volume = 1.0,
	level = 130,
	pitch = {100, 100},
	sound = "gbombs_5/explosions/special/antigravity.mp3"
} )
function ENT:Initialize()
     if (SERVER) then
		 self.FILTER                           = {}
         self:SetModel("models/props_junk/watermelon01_chunk02c.mdl")
	     self:SetSolid( SOLID_NONE )
	     self:SetMoveType( MOVETYPE_NONE )
	     self:SetUseType( ONOFF_USE ) 
		 self.Bursts = 0
		 self.CURRENTRANGE = 0
		 self.HBOWNER = self:GetVar("HBOWNER")
		 self.SOUND = self:GetVar("SOUND")
		 self.DEFAULT_PHYSFORCE  = self:GetVar("DEFAULT_PHYSFORCE")
		 self.DEFAULT_PHYSFORCE_PLYAIR  = self:GetVar("DEFAULT_PHYSFORCE_PLYAIR")
	     self.DEFAULT_PHYSFORCE_PLYGROUND = self:GetVar("DEFAULT_PHYSFORCE_PLYGROUND")
		 self:EmitSound("anti_grav")
     end
end

function ENT:Think()		
     if (SERVER) then
     if !self:IsValid() then return end
	 local pos = self:GetPos()
	 for k, v in pairs(ents.FindInSphere(pos,self.MAX_RANGE)) do
		 if (v:IsValid() or v:IsNPC() or v:IsPlayer()) and (v.forcefielded==false or v.forcefielded==nil) then
			 local i = 0
			 while i < v:GetPhysicsObjectCount() do
				phys = v:GetPhysicsObjectNum(i)
				local gravity_equation = (self:GetPos().z+500)-(v:GetPos().z+v:GetVelocity().z)

				

				

				
				if v:IsPlayer() or v:IsNPC() then v:SetVelocity(Vector(0,0,gravity_equation)) else phys:AddVelocity(Vector(0,0,gravity_equation)) end
				
				
					
			i = i + 1
			end
		 end
 	 end
	 self.Bursts = self.Bursts + 1
	 if (self.Bursts >= self.Burst) then
	     self:Remove()
		 self:StopSound("anti_grav")
	 end
	 self:NextThink(CurTime() + self.DELAY)
	 return true
	 end
end
function ENT:OnRemove()
	self:StopSound("anti_grav")
end
function ENT:Draw()
     return false
end
--addons/hbombs_base/lua/entities/hb_shockwave_fire_dmg.lua:
AddCSLuaFile()

DEFINE_BASECLASS( "base_anim" )


ENT.Spawnable		            	 =  false
ENT.AdminSpawnable		             =  false     

ENT.PrintName		                 =  ""        
ENT.Author			                 =  ""      
ENT.Contact			                 =  ""      

ENT.HBOWNER                          =  nil            
ENT.MAX_RANGE                        = 0
ENT.SHOCKWAVE_INCREMENT              = 0
ENT.DELAY                            = 0
ENT.SOUND                            = ""

function ENT:Initialize()
     if (SERVER) then
		 self.FILTER                           = {}
         self:SetModel("models/props_junk/watermelon01_chunk02c.mdl")
	     self:SetSolid( SOLID_NONE )
	     self:SetMoveType( MOVETYPE_NONE )
	     self:SetUseType( ONOFF_USE ) 
		 self.Bursts = 2
		 self.CURRENTRANGE = 0
		 self.HBOWNER = self:GetVar("HBOWNER")
		 self.SOUND = self:GetVar("SOUND")
		 self.DEFAULT_PHYSFORCE  = self:GetVar("DEFAULT_PHYSFORCE")
		 self.DEFAULT_PHYSFORCE_PLYAIR  = self:GetVar("DEFAULT_PHYSFORCE_PLYAIR")
	     self.DEFAULT_PHYSFORCE_PLYGROUND = self:GetVar("DEFAULT_PHYSFORCE_PLYGROUND")

     end
end

function ENT:Think(ply)		
     if (SERVER) then
     if !self:IsValid() then return end
	 local pos = self:GetPos()
	 self.CURRENTRANGE = self.CURRENTRANGE+self.SHOCKWAVE_INCREMENT
	 for k, v in pairs(ents.FindInSphere(pos,self.CURRENTRANGE)) do
		 if v:IsValid() or v:IsPlayer() then
			 local i = 0
			 while i < v:GetPhysicsObjectCount() do
				 local dmg = DamageInfo()
			         dmg:SetDamage(math.random(0,0))
			         dmg:SetDamageType(DMG_GENERIC)
			         dmg:SetAttacker(self.HBOWNER)
				 phys = v:GetPhysicsObjectNum(i)
				 if v:IsOnFire() then
					v:Extinguish()
					v:Ignite(4,0)
				 else
					v:Ignite(4,0)
				 end
				 if (phys:IsValid()) then
					 local mass = phys:GetMass()
					 local F_ang = self.DEFAULT_PHYSFORCE
					 local dist = (pos - v:GetPos()):Length()
					 local relation = math.Clamp((self.CURRENTRANGE - dist) / self.CURRENTRANGE, 0, 1)
					 local F_dir = (v:GetPos() - pos):GetNormal() * (self.DEFAULT_PHYSFORCE or 690) 
					 phys:AddAngleVelocity(Vector(F_ang, F_ang, F_ang) * relation)
					 phys:AddVelocity(F_dir)
				 end
				 if (v:IsPlayer()) then
					 local mass = phys:GetMass()
					 local F_ang = self.DEFAULT_PHYSFORCE_PLYAIR
					 local dist = (pos - v:GetPos()):Length()
					 local relation = math.Clamp((self.CURRENTRANGE - dist) / self.CURRENTRANGE, 0, 1)
					 local F_dir = (v:GetPos() - pos):GetNormal() * (self.DEFAULT_PHYSFORCE_PLYAIR or 690)
					 v:SetVelocity( F_dir )		
				 end

				 if (v:IsPlayer()) and v:IsOnGround() then
					 local mass = phys:GetMass()
					 local F_ang = self.DEFAULT_PHYSFORCE_PLYGROUND
					 local dist = (pos - v:GetPos()):Length()
					 local relation = math.Clamp((self.CURRENTRANGE - dist) / self.CURRENTRANGE, 0, 1)
					 local F_dir = (v:GetPos() - pos):GetNormal() * (self.DEFAULT_PHYSFORCE_PLYGROUND or 690)	 
					 v:SetVelocity( F_dir )		
				 end
				 if (v:IsNPC()) then
					 v:Ignite(5,0)
				 end
			 i = i + 1
			 end
		 end
 	 end
	 self.Bursts = self.Bursts + 1
	 if (self.CURRENTRANGE >= self.MAX_RANGE) then
	     self:Remove()
	 end
	 self:NextThink(CurTime() + self.DELAY)
	 return true
	 end
end

function ENT:Draw()
     return false
end
--addons/hbombs_base/lua/entities/hb_shockwave_sound_lowsh.lua:
AddCSLuaFile()

DEFINE_BASECLASS( "base_anim" )

if (SERVER) then
	util.AddNetworkString( "hb_net_sound_lowsh" )
end

ENT.Spawnable		            	 =  false
ENT.AdminSpawnable		             =  false     

ENT.PrintName		                 =  ""        
ENT.Author			                 =  ""      
ENT.Contact			                 =  ""      

ENT.HBOWNER                          =  nil            
ENT.MAX_RANGE                        = 0
ENT.SHOCKWAVE_INCREMENT              = 0
ENT.DELAY                            = 0
ENT.SOUND                            = ""

net.Receive( "hb_net_sound_lowsh", function( len, pl )
	--print("Test, if you see this it SHOULD BE WORKING - Cat")
	local sound = net.ReadString()
	LocalPlayer():EmitSound(sound, 100, 100, 1)
	
end );

function ENT:Initialize()
     if (SERVER) then
		 self.FILTER                           = {}
         self:SetModel("models/props_junk/watermelon01_chunk02c.mdl")
	     self:SetSolid( SOLID_NONE )
	     self:SetMoveType( MOVETYPE_NONE )
	     self:SetUseType( ONOFF_USE ) 
		 self.Bursts = 0
		 self.CURRENTRANGE = 0
		 self.HBOWNER = self:GetVar("HBOWNER")
		 self.SOUND = self:GetVar("SOUND")
		 

     end
end

function ENT:Think()		
     if (SERVER) then
     if !self:IsValid() then return end
	 local pos = self:GetPos()
	 self.CURRENTRANGE = self.CURRENTRANGE+(self.SHOCKWAVE_INCREMENT*10)
	 if(GetConVar("hb_realistic_sound"):GetInt() >= 1) then
		 for k, v in pairs(ents.FindInSphere(pos,self.CURRENTRANGE)) do
			 if v:IsPlayer() then
				 if !(table.HasValue(self.FILTER,v)) then
					net.Start("hb_net_sound_lowsh")
						net.WriteString(self.SOUND)
					net.Send(v)
					v:SetNWString("sound", self.SOUND)
					if self:GetVar("Shocktime") == nil then
						self.shocktime = 1
					else
						self.shocktime = self:GetVar("Shocktime")
					end
					if GetConVar("hb_sound_shake"):GetInt()== 1 then
						util.ScreenShake( v:GetPos(), 5555, 555, self.shocktime, 500 )
					end
					table.insert(self.FILTER, v)
					
				 end
			 end
		 end
	 else
		if self:GetVar("Shocktime") == nil then
			self.shocktime = 1
		else
			self.shocktime = self:GetVar("Shocktime")
		end
	 	local ent = ents.Create("hb_shockwave_sound_instant")
		ent:SetPos( pos ) 
		ent:Spawn()
		ent:Activate()
		ent:SetPhysicsAttacker(ply)
		ent:SetVar("HBOWNER", self.HBOWNER)
		ent:SetVar("MAX_RANGE",50000)
		ent:SetVar("DELAY",0.01)
		ent:SetVar("Shocktime",self.shocktime)
		ent:SetVar("SOUND", self:GetVar("SOUND"))
		self:Remove()
	 end
	 self.Bursts = self.Bursts + 1
	 if (self.CURRENTRANGE >= self.MAX_RANGE) then
	     self:Remove()
	 end
	 self:NextThink(CurTime() + (self.DELAY*10))
	 return true
	 end
end
function ENT:OnRemove()
	if SERVER then
		if self.FILTER==nil then return end
		for k, v in pairs(self.FILTER) do
			if !v:IsValid() then return end
			v:SetNWBool("waiting", true)
		end
	end
end
function ENT:Draw()
     return false
end
--addons/hbombs/lua/entities/hb_sp_spacenuke.lua:
AddCSLuaFile()

DEFINE_BASECLASS( "hb_base_advanced" )

ENT.Spawnable						 =  true         
ENT.AdminSpawnable					 =  true 

ENT.PrintName						 =  "Space nuke"
ENT.Author							 =  "Natsu"
ENT.Contact							 =  ""
ENT.Category                         =  "HBOMBS Nukes"

ENT.Model                            =  "models/failure/spacenuke/spacenuke.mdl"                      
ENT.Effect                           =  "h_spacenuke"                  
ENT.EffectAir                        =  "h_spacenuke"                   
ENT.EffectWater                      =  "h_spacenuke"
ENT.ExplosionSound                   =  "gbombs/fab/fab_explo.wav"
ENT.ArmSound                         =  "npc/roller/mine/rmine_blip3.wav"            
ENT.ActivationSound                  =  "buttons/button14.wav"     

ENT.ShouldUnweld                     =  true
ENT.ShouldIgnite                     =  false
ENT.ShouldExplodeOnImpact            =  true
ENT.Flamable                         =  false
ENT.UseRandomSounds                  =  false
ENT.Timed                            =  false

ENT.ExplosionDamage                  =  4000
ENT.PhysForce                        =  2500
ENT.ExplosionRadius                  =  3000
ENT.SpecialRadius                    =  5000
ENT.MaxIgnitionTime                  =  0
ENT.Life                             =  25                                  
ENT.MaxDelay                         =  2                                 
ENT.TraceLength                      =  3000
ENT.ImpactSpeed                      =  700
ENT.Mass                             =  5000
ENT.ArmDelay                         =  1   
ENT.Timer                            =  0

ENT.HBOWNER                          =  nil             -- don't you fucking touch this.

function ENT:Initialize()
 if (SERVER) then
	 self:SetModel(self.Model)
	 self:PhysicsInit( SOLID_VPHYSICS )
	 self:SetSolid( SOLID_VPHYSICS )
	 self:SetMoveType( MOVETYPE_VPHYSICS )
	 self:SetUseType( ONOFF_USE ) -- doesen't fucking work
	 local phys = self:GetPhysicsObject()
	 if (phys:IsValid()) then
		 phys:SetMass(self.Mass)
		 phys:Wake()
	 end 
	 if(self.Dumb) then
		 self.Armed    = true
	 else
		 self.Armed    = false
	 end
	 self.Exploded = false
	 self.Used     = false
	 self.Arming = false
	 self.Exploding = false
	  if !(WireAddon == nil) then self.Inputs   = Wire_CreateInputs(self, { "Arm", "Detonate" }) end
	end
end
function ENT:Explode()
	if !self.Exploded then return end
	if self.Exploding then return end
	
	local pos = self:LocalToWorld(self:OBBCenter())
	self:SetModel("models/gibs/scanner_gib02.mdl")
	self.Exploding = true
	constraint.RemoveAll(self)
	local physo = self:GetPhysicsObject()
	physo:Wake()
	self:SetMoveType( MOVETYPE_NONE )
	self:SetMaterial("phoenix_storms/glass")
	self:SetModel("models/hunter/plates/plate.mdl")
	timer.Simple(0.25, function()
		if !self:IsValid() then return end
		local ent = ents.Create("hb_shockwave_sound_lowsh")
		ent:SetPos( pos ) 
		ent:Spawn()
		ent:Activate()
		ent:SetVar("HBOWNER", self.HBOWNER)
		ent:SetVar("MAX_RANGE",50000)
		ent:SetVar("SHOCKWAVE_INCREMENT",200)
		ent:SetVar("DELAY",0.01)
		ent:SetVar("Shocktime",12)
		ent:SetVar("SOUND", "ambient/explosions/explode_9.wav")
		
		local ent = ents.Create("hb_shockwave_ent")
		ent:SetPos( pos ) 
		ent:Spawn()
		ent:Activate()
		ent:SetVar("DEFAULT_PHYSFORCE", 155)
		ent:SetVar("DEFAULT_PHYSFORCE_PLYAIR", 155)
		ent:SetVar("DEFAULT_PHYSFORCE_PLYGROUND", 15)
		ent:SetVar("HBOWNER", self.HBOWNER)
		ent:SetVar("MAX_RANGE",7000)
		ent:SetVar("SHOCKWAVE_INCREMENT",200)
		ent:SetVar("DELAY",0.01)
		self:Remove()
	end)
	
	if(self:WaterLevel() >= 1) then
		local trdata   = {}
		local trlength = Vector(0,0,9000)

		trdata.start   = pos
		trdata.endpos  = trdata.start + trlength
		trdata.filter  = self
		local tr = util.TraceLine(trdata) 

		local trdat2   = {}
		trdat2.start   = tr.HitPos
		trdat2.endpos  = trdata.start - trlength
		trdat2.filter  = self
		trdat2.mask    = MASK_WATER + CONTENTS_TRANSLUCENT

		local tr2 = util.TraceLine(trdat2)

		if tr2.Hit then
			ParticleEffect(self.EffectWater, tr2.HitPos, Angle(0,0,0), nil)
		end
	else
		local tracedata    = {}
		tracedata.start    = pos
		tracedata.endpos   = tracedata.start - Vector(0, 0, self.TraceLength)
		tracedata.filter   = self.Entity

		local trace = util.TraceLine(tracedata)

		if trace.HitWorld then
			ParticleEffect("h_spacenuke",pos,self:GetAngles(),nil)	
			timer.Simple(0.1, function()
				if !self:IsValid() then return end 
					ParticleEffect("",trace.HitPos,Angle(0,0,0),nil)	
			end)	
		else 
			ParticleEffect("h_spacenuke",pos,Angle(0,0,0),nil) 

		end
	end
end

function ENT:SpawnFunction( ply, tr )
	 if ( !tr.Hit ) then return end
	 self.HBOWNER = ply
	 local ent = ents.Create( self.ClassName )
	 ent:SetPhysicsAttacker(ply)
	 ent:SetPos( tr.HitPos + tr.HitNormal * 16 ) 
	 ent:Spawn()
	 ent:Activate()

	 return ent
end
--addons/heart_turbolaser_tool/lua/entities/heart_turbolaser_spawner/cl_init.lua:
include("shared.lua");

function ENT:Initialize()
end

function ENT:Draw()
end

function ENT:Think()
end

function ENT:OnRemove()
end

--addons/lvs_turret/lua/entities/joes_sam_turret_lvs/shared.lua:
if not LVS then return end
ENT.Type = "anim"
ENT.Base = "joes_turret_base_lvs"

ENT.PrintName = "Turret"
ENT.Category = "[LVS]"

ENT.Spawnable = true
ENT.AdminSpawnable = true
ENT.Editable = true

/*

ENT.model = "models/sam_model/base.mdl"

ENT.HideDriver = true
ENT.SeatPos = Vector(0,0,50)
ENT.SeatAng = Angle(0,-90,0)

ENT.MaxHealth = 500
ENT.MaxShield = 100 --set 0 for no shield
ENT.Range = 60000
ENT.LoseTargetDistance = ENT.Range + 1000
ENT.Clip = 8

ENT.targetgroundvehicles = true
ENT.targetairvehicles = true
ENT.targethumans = true

ENT.team = 1

*/
--lua/entities/laat_hatch/cl_init.lua:
include("shared.lua")

function ENT:Draw()
	self:DrawModel() 
end
--lua/entities/laat_wingrocket.lua:
AddCSLuaFile()

ENT.Type            = "anim"
DEFINE_BASECLASS( "lunasflightschool_missile" )

if SERVER then
    function ENT:Initialize()	
		self:SetModel("models/weapons/w_missile_launch.mdl")
		self:PhysicsInit(SOLID_VPHYSICS)
		self:SetMoveType(MOVETYPE_VPHYSICS)
		self:SetSolid(SOLID_VPHYSICS)
		self:SetRenderMode(RENDERMODE_TRANSALPHA)
		self:PhysWake()

		local pObj = self:GetPhysicsObject()
		if IsValid(pObj) then
			pObj:EnableGravity(false) 
			pObj:SetMass(1) 
		end
		
		self.LifeTime = CurTime() + 12
	end

	function ENT:FollowTarget( followent )
		self:GetPhysicsObject():SetVelocity(self:GetForward() * 8250)

		local ang = (followent:GetPos() - self:GetPos()):Angle()
		self:SetAngles(ang)

		--[[local speed = self:GetStartVelocity() + (self:GetDirtyMissile() and 5000 or 3500)
		local turnrate = (self:GetCleanMissile() or self:GetDirtyMissile()) and 60 or 50
		
		local TargetPos = followent:LocalToWorld( followent:OBBCenter() )
		
		if isfunction( followent.GetMissileOffset ) then
			local Value = followent:GetMissileOffset()
			if isvector( Value ) then
				TargetPos = followent:LocalToWorld( Value )
			end
		end
		
		local pos = TargetPos + followent:GetVelocity() * 0.25
		
		local pObj = self:GetPhysicsObject()
		
		if IsValid( pObj ) then
			if not self:GetDisabled() then
				local targetdir = (pos - self:GetPos()):GetNormalized()
				
				local AF = self:WorldToLocalAngles( targetdir:Angle() )
				AF.p = math.Clamp( AF.p * 400,-turnrate,turnrate )
				AF.y = math.Clamp( AF.y * 400,-turnrate,turnrate )
				AF.r = math.Clamp( AF.r * 400,-turnrate,turnrate )
				
				local AVel = pObj:GetAngleVelocity()
				pObj:AddAngleVelocity( Vector(AF.r,AF.p,AF.y) - AVel ) 
				
				pObj:SetVelocityInstantaneous( self:GetForward() * speed )
			end
		end]]
	end

	local function GetValidEntity(ent)
		return IsValid(ent) and ent or Entity(0)
	end

    function ENT:Think()	
		local curtime = CurTime()
		self:NextThink(curtime)
		
		local Target = self:GetLockOn()
		if IsValid(Target) then
			self:FollowTarget(Target)
		else
			self:BlindFire()
		end

		if self.MarkForRemove then
			self:Detonate()
		end
		
		if self.Explode then
			local Inflictor = self:GetInflictor()
			local Attacker = self:GetAttacker()

			util.BlastDamage(GetValidEntity(Inflictor), GetValidEntity(Attacker), self:GetPos(), 250, 150)
			
			self:Detonate()
		end
		
		if self.LifeTime <= curtime then
			self:Detonate()
		end
		
		return true
	end

    function ENT:PhysicsCollide( data )
		if self:GetDisabled() then
			self.MarkForRemove = true
		else
			local HitEnt = data.HitEntity
			
			if IsValid(HitEnt) && not self.Explode && (HitEnt.LFS || HitEnt.IdentifiesAsLFS) then 
                local Pos = self:GetPos()

                local effectdata = EffectData()
                    effectdata:SetOrigin(Pos)
                    effectdata:SetNormal(-self:GetForward())
                util.Effect("manhacksparks", effectdata, true, true)

                local dmginfo = DamageInfo()
                    dmginfo:SetDamage(500)
                    dmginfo:SetAttacker(IsValid(self:GetAttacker()) && self:GetAttacker() || self)
                    dmginfo:SetDamageType(DMG_BLAST)
                    dmginfo:SetInflictor(self) 
                    dmginfo:SetDamagePosition(Pos) 
                HitEnt:TakeDamageInfo(dmginfo)

                sound.Play("Missile.ShotDown", Pos, 140)
			end
			
			self.Explode = true
		end
	end
else
	function ENT:Initialize()	
		self.snd = CreateSound(self, "weapons/flaregun/burn.wav")
			self.snd:Play()

		local effectdata = EffectData()
			effectdata:SetOrigin(self:GetPos())
			effectdata:SetEntity(self)
		util.Effect("lfs_fb_wingrocket", effectdata)
	end
end
--lua/entities/ladder_small4/shared.lua:
if (SERVER) then
	AddCSLuaFile();
end;

ENT.Type 			= "anim";
ENT.Base 			= "ladder_base";
ENT.PrintName		= "Ladder (Small - Wood)"
ENT.Category		= "Ladders"
ENT.Spawnable		= true
ENT.AdminOnly		= false
ENT.Model			= Model("models/props/cs_militia/ladderwood.mdl");
ENT.RenderGroup 	= RENDERGROUP_BOTH;
--addons/lvs_base/lua/entities/lvs_base/cl_init.lua:
include("shared.lua")
include( "sh_weapons.lua" )
include( "cl_effects.lua" )
include( "cl_hud.lua" )
include( "cl_seatswitcher.lua" )
include( "cl_trailsystem.lua" )
include( "cl_boneposeparemeter.lua" )

local Zoom = 0

function ENT:LVSCalcFov( fov, ply )

	local TargetZoom = ply:lvsKeyDown( "ZOOM" ) and 0 or 1

	Zoom = Zoom + (TargetZoom - Zoom) * RealFrameTime() * 10

	local newfov = fov * Zoom + (self.ZoomFov or 40) * (1 - Zoom)

	return newfov
end

function ENT:LVSCalcView( ply, pos, angles, fov, pod )
	return LVS:CalcView( self, ply, pos, angles, fov, pod )
end

function ENT:PreDraw( flags )
	return true
end

function ENT:PreDrawTranslucent( flags )
	return true
end

function ENT:PostDraw( flags )
end

function ENT:PostDrawTranslucent( flags )
end

function ENT:Draw( flags )
	if self:PreDraw( flags ) then
		if self.lvsLegacyDraw then
			self:DrawModel() -- ugly, but required in order to fix old addons. Refract wont work on these.
		else
			self:DrawModel( flags )
		end
	end

	self:PostDraw( flags )
end

function ENT:DrawTranslucent( flags )
	self:DrawTrail()

	if self:PreDrawTranslucent( flags ) then
		self:DrawModel( flags )
	else
		self.lvsLegacyDraw = true -- insert puke simley
	end

	self:PostDrawTranslucent( flags )
end

function ENT:Initialize()
	self:OnSpawn()

	if not istable( self.GibModels ) then return end

	for _, modelName in ipairs( self.GibModels ) do
		util.PrecacheModel( modelName )
	end
end

function ENT:OnSpawn()
end

function ENT:OnFrameActive()
end

function ENT:OnFrame()
end

function ENT:OnEngineActiveChanged( Active )
end

function ENT:OnActiveChanged( Active )
end

ENT._oldActive = false
ENT._oldEnActive = false

function ENT:HandleActive()
	local EntTable = self:GetTable()

	local Active = self:GetActive()
	local EngineActive = self:GetEngineActive()
	local ActiveChanged = false

	if EntTable._oldActive ~= Active then
		EntTable._oldActive = Active
		EntTable:OnActiveChanged( Active )
		ActiveChanged = true
	end

	if EntTable._oldEnActive ~= EngineActive then
		EntTable._oldEnActive = EngineActive
		self:OnEngineActiveChanged( EngineActive )
		ActiveChanged = true
	end

	if ActiveChanged then
		if Active or EngineActive then
			self:StartWindSounds()
		else
			self:StopWindSounds()
		end
	end

	if Active or EngineActive then
		self:DoVehicleFX()
	end

	self:FlyByThink()

	return EngineActive
end

function ENT:Think()
	if not self:IsInitialized() then return end
 
	if self:HandleActive() then
		self:OnFrameActive()
	end

	self:HandleTrail()
	self:OnFrame()
end

function ENT:OnRemove()
	self:StopEmitter()
	self:StopWindSounds()
	self:StopFlyBy()
	self:StopDeathSound()

	self:OnRemoved()
end

function ENT:OnRemoved()
end

function ENT:CalcDoppler( Ent )
	if not IsValid( Ent ) then return 1 end

	if Ent:IsPlayer() then
		local ViewEnt = Ent:GetViewEntity()
		local Vehicle = Ent:lvsGetVehicle()

		if IsValid( Vehicle ) then
			if Ent == ViewEnt then
				Ent = Vehicle
			end
		else
			if IsValid( ViewEnt ) then
				Ent = ViewEnt
			end
		end
	end

	local sVel = self:GetVelocity()
	local oVel = Ent:GetVelocity()

	local SubVel = oVel - sVel
	local SubPos = self:GetPos() - Ent:GetPos()

	local DirPos = SubPos:GetNormalized()
	local DirVel = SubVel:GetNormalized()

	local A = math.acos( math.Clamp( DirVel:Dot( DirPos ) ,-1,1) )

	return (1 + math.cos( A ) * SubVel:Length() / 13503.9)
end

function ENT:GetCrosshairFilterEnts()
	if not self:IsInitialized() then return { self } end -- wait for the server to be ready

	if not istable( self.CrosshairFilterEnts ) then
		self.CrosshairFilterEnts = {self}

		-- lets ask the server to build the filter for us because it has access to constraint.GetAllConstrainedEntities() 
		net.Start( "lvs_player_request_filter" )
			net.WriteEntity( self )
		net.SendToServer()
	end

	return self.CrosshairFilterEnts
end

function ENT:FlyByThink()
end

function ENT:StopFlyBy()
end

function ENT:StopDeathSound()
end

function ENT:OnDestroyed()
end

net.Receive( "lvs_vehicle_destroy", function( len )
	local ent = net.ReadEntity()

	if not IsValid( ent ) or not isfunction( ent.OnDestroyed ) then return end

	ent:OnDestroyed()
end )

--addons/lvs_base/lua/entities/lvs_base/cl_seatswitcher.lua:

ENT.IconVehicleLocked = Material( "lvs/locked.png" )

LVS:AddHudEditor( "SeatSwitcher", ScrW() - 360, 10,  350, 60, 350, 60, "SEAT SWITCHER", 
	function( self, vehicle, X, Y, W, H, ScrX, ScrY, ply )
		if not vehicle.LVSHudPaintSeatSwitcher then return end

		vehicle:LVSHudPaintSeatSwitcher( X, Y, W, 30, ScrX, ScrY, ply )
	end
)

function ENT:LVSHudPaintSeatSwitcher( X, Y, w, h, ScrX, ScrY, ply )
	local pSeats = table.Copy( self:GetPassengerSeats() )
	local SeatCount = table.Count( pSeats ) 

	if SeatCount <= 0 then return end

	pSeats[0] = self:GetDriverSeat()

	draw.NoTexture() 

	local HasAI = self:GetAI()
	local HasAIGunners = self:GetAIGunners()

	local MySeat = ply:GetVehicle():lvsGetPodIndex()

	local Passengers = {}
	for _, player in pairs( player.GetAll() ) do
		if player:lvsGetVehicle() == self then
			local Pod = player:GetVehicle()
			Passengers[ Pod:lvsGetPodIndex() ] = player:GetName()
		end
	end

	if HasAI then
		Passengers[1] = "[AI] "..self.PrintName
	end

	if HasAIGunners then
		for _, Pod in pairs( self:GetPassengerSeats() ) do
			if IsValid( Pod:GetDriver() ) then continue end
	
			local weapon = Pod:lvsGetWeapon()

			if not IsValid( weapon ) then continue end

			Passengers[ weapon:GetPodIndex() ] = "[AI] Gunner"
		end
	end

	ply.SwitcherTime = ply.SwitcherTime or 0
	ply._lvsoldPassengers = ply._lvsoldPassengers or {}

	local Time = CurTime()
	for k, v in pairs( Passengers ) do
		if ply._lvsoldPassengers[k] ~= v then
			ply._lvsoldPassengers[k] = v
			ply.SwitcherTime = Time + 2
		end
	end
	for k, v in pairs( ply._lvsoldPassengers ) do
		if not Passengers[k] then
			ply._lvsoldPassengers[k] = nil
			ply.SwitcherTime = Time + 2
		end
	end
	for _, v in pairs( LVS.pSwitchKeysInv ) do
		if input.IsKeyDown(v) then
			ply.SwitcherTime = Time + 2
		end
	end

	local Hide = ply.SwitcherTime > Time

	ply.smHider = ply.smHider and (ply.smHider + ((Hide and 1 or 0) - ply.smHider) * RealFrameTime() * 15) or 0

	local Alpha1 = 135 + 110 * ply.smHider 
	local HiderOffset = 270 * ply.smHider
	local xPos = w - 35
	local yPos = Y - (SeatCount + 1) * 30 + h + 5

	local SwapY = false
	local SwapX = false

	local xHider = HiderOffset

	if X < (ScrX * 0.5 - w * 0.5) then
		SwapX = true
		xPos = 0
		xHider = 0
	end

	if Y < (ScrY * 0.5 - h * 0.5) then
		SwapY = true
		yPos = Y - h
	end

	for _, Pod in pairs( pSeats ) do
		if not IsValid( Pod ) then continue end

		local I = Pod:lvsGetPodIndex()

		if I <= 0 then continue end

		if I == MySeat then
			draw.RoundedBox(5, X + xPos - xHider, yPos + I * 30, 35 + HiderOffset, 25, Color(LVS.ThemeColor.r, LVS.ThemeColor.g, LVS.ThemeColor.b,100 + 50 * ply.smHider) )
		else
			draw.RoundedBox(5, X + xPos - xHider, yPos + I * 30, 35 + HiderOffset, 25, Color(0,0,0,100 + 50 * ply.smHider) )
		end

		if Hide then
			if Passengers[I] then
				draw.DrawText( Passengers[I], "LVS_FONT_SWITCHER", X + 40 + xPos - xHider, yPos + I * 30 + 2.5, Color( 255, 255, 255,  Alpha1 ), TEXT_ALIGN_LEFT )
			else
				draw.DrawText( "-", "LVS_FONT_SWITCHER", X + 40 + xPos - xHider, yPos + I * 30 + 2.5, Color( 255, 255, 255,  Alpha1 ), TEXT_ALIGN_LEFT )
			end
			
			draw.DrawText( "["..I.."]", "LVS_FONT_SWITCHER", X + 17 + xPos - xHider, yPos + I * 30 + 2.5, Color( 255, 255, 255, Alpha1 ), TEXT_ALIGN_CENTER )
		else
			if Passengers[I] then
				draw.DrawText( "[^"..I.."]", "LVS_FONT_SWITCHER", X + 17 + xPos - xHider, yPos + I * 30 + 2.5, Color( 255, 255, 255, Alpha1 ), TEXT_ALIGN_CENTER )
			else
				draw.DrawText( "["..I.."]", "LVS_FONT_SWITCHER", X + 17 + xPos - xHider, yPos + I * 30 + 2.5, Color( 255, 255, 255, Alpha1 ), TEXT_ALIGN_CENTER )
			end
		end

		if not self:GetlvsLockedStatus() then continue end

		local xLocker = SwapX and 35 + HiderOffset or -25 - HiderOffset

		if SwapY then
			if I == 1 then
				surface.SetDrawColor( 255, 255, 255, 255 )
				surface.SetMaterial( self.IconVehicleLocked  )
				surface.DrawTexturedRect( X + xPos + xLocker, yPos + I * 30, 25, 25 )
			end
		else
			if I == SeatCount then
				surface.SetDrawColor( 255, 255, 255, 255 )
				surface.SetMaterial( self.IconVehicleLocked  )
				surface.DrawTexturedRect( X + xPos + xLocker, yPos + I * 30, 25, 25 )
			end
		end
	end
end

--addons/lvs_starwars/lua/entities/lvs_base_fakehover/cl_camera.lua:

function ENT:CalcViewOverride( ply, pos, angles, fov, pod )
	return pos, angles, fov
end

function ENT:CalcViewDriver( ply, pos, angles, fov, pod )
	local view = {}
	view.origin = pos
	view.fov = fov
	view.drawviewer = true
	view.angles = ply:EyeAngles()

	if not pod:GetThirdPersonMode() then

		view.drawviewer = false

		return view
	end

	local radius = 550
	radius = radius + radius * pod:GetCameraDistance()

	local TargetOrigin = view.origin - view.angles:Forward() * radius  + view.angles:Up() * (radius * 0.2 + radius * pod:GetCameraHeight())
	local WallOffset = 4

	local tr = util.TraceHull( {
		start = view.origin,
		endpos = TargetOrigin,
		filter = function( e )
			local c = e:GetClass()
			local collide = not c:StartWith( "prop_physics" ) and not c:StartWith( "prop_dynamic" ) and not c:StartWith( "prop_ragdoll" ) and not e:IsVehicle() and not c:StartWith( "gmod_" ) and not c:StartWith( "lvs_" ) and not c:StartWith( "player" ) and not e.LVS

			return collide
		end,
		mins = Vector( -WallOffset, -WallOffset, -WallOffset ),
		maxs = Vector( WallOffset, WallOffset, WallOffset ),
	} )

	view.origin = tr.HitPos

	if tr.Hit and not tr.StartSolid then
		view.origin = view.origin + tr.HitNormal * WallOffset
	end

	return view
end

function ENT:CalcViewPassenger( ply, pos, angles, fov, pod )
	return LVS:CalcView( self, ply, pos, angles, fov, pod )
end

function ENT:LVSCalcView( ply, original_pos, original_angles, original_fov, pod )
	local pos, angles, fov = self:CalcViewOverride( ply, original_pos, original_angles, original_fov, pod )

	if self:GetDriverSeat() == pod then
		return self:CalcViewDriver( ply, pos, angles, fov, pod )
	else
		return self:CalcViewPassenger( ply, pos, angles, fov, pod )
	end
end
--addons/lvs_starwars/lua/entities/lvs_base_repulsorlift/cl_init.lua:
include("shared.lua")

--addons/lvs_starwars/lua/entities/lvs_base_starfighter/sh_camera_eyetrace.lua:

function ENT:GetEyeTrace( trace_forward )
	local startpos = self:LocalToWorld( self:OBBCenter() )

	local pod = self:GetDriverSeat()

	if IsValid( pod ) then
		startpos = pod:LocalToWorld( pod:OBBCenter() )
	end

	local AimVector = trace_forward and self:GetForward() or self:GetAimVector()

	local data = {
		start = startpos,
		endpos = (startpos + AimVector * 50000),
		filter = self:GetCrosshairFilterEnts(),
	}

	local trace = util.TraceLine( data )

	return trace
end

function ENT:GetAimVector()
	if self:GetAI() then
		return self:GetAIAimVector()
	end

	local Driver = self:GetDriver()

	if not IsValid( Driver ) then return self:GetForward() end

	if not Driver:lvsMouseAim() then
		if Driver:lvsKeyDown( "FREELOOK" ) then
			local pod = self:GetDriverSeat()

			if not IsValid( pod ) then return Driver:EyeAngles():Forward() end

			if pod:GetThirdPersonMode() then
				return -self:GetForward()
			else
				return Driver:GetAimVector()
			end
		else
			return self:GetForward()
		end
	end

	if SERVER then
		local pod = self:GetDriverSeat()

		if not IsValid( pod ) then return Driver:EyeAngles():Forward() end

		return pod:WorldToLocalAngles( Driver:EyeAngles() ):Forward()
	else
		return Driver:EyeAngles():Forward()
	end
end

--addons/lvs_starwars/lua/entities/lvs_base_starfighter/cl_hud.lua:
ENT.IconHealth = Material("lvs/heart.png")
ENT.IconShield = Material("lvs/shield.png")
ENT.IconEngine = Material("lvs/engine.png")

function ENT:LVSHudPaintInfoText(X, Y, W, H, ScrX, ScrY, ply)
	local maxHealth = self:GetMaxHP()
	local health = math.Round((self:GetHP() * 100) / maxHealth)

	surface.SetMaterial(self.IconHealth)
	surface.SetDrawColor(0, 0, 0, 200)
	surface.DrawTexturedRectRotated(X * 1.021, Y * 1.045, H * 0.5, H * 0.5, 0)
	surface.SetDrawColor(color_white)
	surface.DrawTexturedRectRotated(X * 1.02, Y * 1.045, H * 0.5, H * 0.5, 0)

	draw.DrawText(health .. "%", "LVS_FONT_HUD_LARGE", X + 50, Y + 20, color_white, TEXT_ALIGN_LEFT)

	local maxShield = self:GetMaxShield()
	local shield = math.Round((self:GetShield() * 100) / maxShield)

	surface.SetMaterial(self.IconShield)
	surface.SetDrawColor(0, 0, 0, 200)
	surface.DrawTexturedRectRotated(X * 1.126, Y * 1.045, H * 0.5, H * 0.5, 0)
	surface.SetDrawColor(color_white)
	surface.DrawTexturedRectRotated(X * 1.125, Y * 1.045, H * 0.5, H * 0.5, 0)

	if shield >= 0 then
		draw.DrawText(shield .. "%", "LVS_FONT_HUD_LARGE", X + 200, Y + 20, color_white, TEXT_ALIGN_LEFT)
	else
		draw.DrawText("0 %", "LVS_FONT_HUD_LARGE", X + 200, Y + 20, color_white, TEXT_ALIGN_LEFT)
	end

	local kmh = math.Round(self:GetVelocity():Length() * 0.09144,0)
	draw.DrawText("km/h ", "LVS_FONT", X + 370, Y + 35, color_white, TEXT_ALIGN_RIGHT )
	draw.DrawText(kmh, "LVS_FONT_HUD_LARGE", X + 370, Y + 20, color_white, TEXT_ALIGN_LEFT )

	if ply ~= self:GetDriver() then return end

	local hX = X + W - H * 0.5
	local hY = Y + H * 0.25 + H * 0.25

	surface.SetMaterial(self.IconEngine)
	surface.SetDrawColor(0, 0, 0, 200)
	surface.DrawTexturedRectRotated(hX * 1.007, hY * 1.008, H * 0.75, H * 0.75, 0)
	surface.SetDrawColor(color_white)
	surface.DrawTexturedRectRotated(hX * 1.008, hY * 1.008, H * 0.75, H * 0.75, 0)

	if not self:GetEngineActive() then
		draw.SimpleText("X" , "LVS_FONT",  hX * 1.007, hY * 1.008, Color(0, 0, 0, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
	else
		self:LVSDrawCircle(hX * 1.007, hY * 1.008, H * 0.4, self:GetThrottle())
	end
end

function ENT:LVSPreHudPaint( X, Y, ply )
	return true
end

function ENT:LVSHudPaint( X, Y, ply )
	if not self:LVSPreHudPaint( X, Y, ply ) then return end

	if ply ~= self:GetDriver() then return end

	local HitPlane = self:GetEyeTrace( true ).HitPos:ToScreen()
	local HitPilot = self:GetEyeTrace().HitPos:ToScreen()

	self:PaintCrosshairCenter( HitPlane )
	self:PaintCrosshairOuter( HitPilot )

	if ply:lvsMouseAim() and not ply:lvsKeyDown( "FREELOOK" ) then
		self:LVSHudPaintMouseAim( HitPlane, HitPilot )
	end

	self:LVSPaintHitMarker( HitPilot )
end

function ENT:LVSHudPaintDirectInput( Pos2D )
	self:PaintCrosshairCenter( Pos2D )
	self:PaintCrosshairOuter( Pos2D )
end

function ENT:LVSHudPaintMouseAim( HitPlane, HitPilot )
	local Sub = Vector(HitPilot.x,HitPilot.y,0) - Vector(HitPlane.x,HitPlane.y,0)
	local Len = Sub:Length()
	local Dir = Sub:GetNormalized()

	surface.SetDrawColor( 255, 255, 255, 100 )
	if Len > 20 then
		surface.DrawLine( HitPlane.x + Dir.x * 5, HitPlane.y + Dir.y * 5, HitPilot.x - Dir.x * 20, HitPilot.y- Dir.y * 20 )

		-- shadow
		surface.SetDrawColor( 0, 0, 0, 50 )
		surface.DrawLine( HitPlane.x + Dir.x * 5 + 1, HitPlane.y + Dir.y * 5 + 1, HitPilot.x - Dir.x * 20+ 1, HitPilot.y- Dir.y * 20 + 1 )
	end
end

--addons/egm_lvs_ground/lua/entities/lvs_fakehover_armis/cl_init.lua:
include("shared.lua")

ENT.EngineColor = Color(245, 143, 0)
ENT.EngineColor2 = Color(255, 255, 255)
ENT.EngineGlow = Material("sprites/light_glow02_add")
ENT.EnginePos = {
	Vector(-61, 43, 33),
	Vector(-61, -18, 33)
}

function ENT:PostDrawTranslucent()
	if not self:GetEngineActive() then return end

	local Size = 50 + self:GetThrottle() * 40

	render.SetMaterial(self.EngineGlow)
	for _, pos in pairs(self.EnginePos) do
		render.DrawSprite(self:LocalToWorld(pos), Size, Size, self.EngineColor)
		render.DrawSprite(self:LocalToWorld(pos), Size, Size, self.EngineColor)
		render.DrawSprite(self:LocalToWorld(pos), Size, Size, self.EngineColor)

		render.DrawSprite(self:LocalToWorld(pos), 16, 16, self.EngineColor2)
		render.DrawSprite(self:LocalToWorld(pos), 12, 12, self.EngineColor2)

		render.DrawSprite(self:LocalToWorld(pos), 16, 16, self.EngineColor2)
		render.DrawSprite(self:LocalToWorld(pos), 12, 12, self.EngineColor2)
	end
end

function ENT:DamageFX()
	local HP = self:GetHP()
	if HP == 0 or HP > self:GetMaxHP() * 0.5 then return end

	self.nextDFX = self.nextDFX or 0

	if self.nextDFX < CurTime() then
		self.nextDFX = CurTime() + 0.05

		local effectdata = EffectData()
		effectdata:SetOrigin( self:LocalToWorld( Vector(-90,0,40) ) )
		util.Effect( "lfs_blacksmoke", effectdata )
	end
end
--addons/egm_lvs_ground/lua/entities/lvs_fakehover_aurum/shared.lua:
ENT.Base = "lvs_base_fakehover"

ENT.PrintName = "Aurum Speeder"
ENT.Author = "Deltaa"
ENT.Information = ""
ENT.Category = "[LVS] - Neutral"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/myproject5/mesh_2451.mdl"

ENT.AITEAM = 0

ENT.MaxHealth = 1750

ENT.ForceAngleMultiplier = 2
ENT.ForceAngleDampingMultiplier = 1

ENT.ForceLinearMultiplier = 1
ENT.ForceLinearRate = 0.25

ENT.MaxVelocityX = 600
ENT.MaxVelocityY = 500

ENT.MaxTurnRate = 0.75

ENT.BoostAddVelocityX = 200
ENT.BoostAddVelocityY = 100

ENT.GroundTraceHitWater = true
ENT.GroundTraceLength = 50
ENT.GroundTraceHull = 100

ENT.LAATC_PICKUPABLE = true
ENT.LAATC_PICKUP_POS = Vector(-200, 0, 30)
ENT.LAATC_PICKUP_Angle = Angle(0, 0, 0)

function ENT:OnIsCarried( name, old, new)
	if new == old then return end

	if new then
		self:SetDisabled(true)
	else
		self:SetDisabled(false)
	end
end

function ENT:OnSetupDataTables()
	self:AddDT( "Bool", "IsCarried" )

	if SERVER then
		self:NetworkVarNotify("IsCarried", self.OnIsCarried)
	end
end

function ENT:InitWeapons()
end

ENT.EngineSounds = {
	{
		sound = "lvs/vehicles/x-34/engine_loop.wav",
		Pitch = 70,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 30,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
		SoundLevel = 85,
	}
}
--addons/egm_lvs_ground/lua/entities/lvs_fakehover_barc/shared.lua:
ENT.Base = "lvs_base_fakehover"

ENT.PrintName = "BARC-Speeder"
ENT.Author = "Deltaa"
ENT.Information = "The Biker Advanced Recon Commando speeder was designed for use by the Grand Army of the Republic during the Clone Wars"
ENT.Category = "[LVS] - Republik"

ENT.Spawnable = true
ENT.AdminSpawnable = false

ENT.MDL = "models/barc/barc.mdl"

ENT.AITEAM = 2

ENT.MaxHealth = 1500

ENT.ForceAngleMultiplier = 2
ENT.ForceAngleDampingMultiplier = 1

ENT.ForceLinearMultiplier = 1
ENT.ForceLinearRate = 0.25

ENT.MaxVelocityX = 1500
ENT.MaxVelocityY = 1000

ENT.MaxTurnRate = 0.75

ENT.BoostAddVelocityX = 120
ENT.BoostAddVelocityY = 120

ENT.GroundTraceHitWater = true
ENT.GroundTraceLength = 50
ENT.GroundTraceHull = 100

ENT.LAATC_PICKUPABLE = true
ENT.LAATC_PICKUP_POS = Vector(-200,0,25)
ENT.LAATC_PICKUP_Angle = Angle(0,0,0)

function ENT:OnIsCarried( name, old, new)
	if new == old then return end

	if new then
		self:SetDisabled(true)
	else
		self:SetDisabled(false)
	end
end

function ENT:OnSetupDataTables()
	self:AddDT( "Bool", "IsCarried" )

	if SERVER then
		self:NetworkVarNotify("IsCarried", self.OnIsCarried)
	end
end

function ENT:InitWeapons()
	self.FirePositions = {
		{
			Vector(106, 12, 6),
			Vector(106, -12, 6)
		},

		{
			Vector(-30, 25, 33),
			Vector(-30, -25, 33)
		}
	}

	-- Primary Gun
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/hmg.png")
	weapon.Delay = 0.15
	weapon.HeatRateUp = 0.1
	weapon.HeatRateDown = 0.25
	weapon.Attack = function(ent)
		ent.NumPrim = ent.NumPrim and ent.NumPrim + 1 or 1
		if ent.NumPrim > #ent.FirePositions then ent.NumPrim = 1 end

		local pod = ent:GetDriverSeat()
		if not IsValid(pod) then return end

		local startpos = pod:LocalToWorld(pod:OBBCenter())
		local trace = util.TraceHull( {
			start = startpos,
			endpos = startpos + ent:GetForward() * 50000,
			mins = Vector(-10, -10, -10),
			maxs = Vector(10, 10, 10),
			filter = ent:GetCrosshairFilterEnts()
		})

		local CurPos = ent.FirePositions[ent.NumPrim]

		for _, pos in pairs(CurPos) do
			local bullet = {}
			bullet.Src = ent:LocalToWorld(pos)
			bullet.Dir = (trace.HitPos - bullet.Src):GetNormalized()
			bullet.Spread = Vector(0.05,  0.05, 0)
			bullet.TracerName = "lvs_laser_blue_long"
			bullet.Force = 100
			bullet.HullSize = 1
			bullet.Damage = 100
			bullet.Velocity = 40000
			bullet.Attacker = ent:GetDriver()
			bullet.Callback = function(att, tr, dmginfo)
				dmginfo:SetDamageType(DMG_AIRBOAT)

				local effectdata = EffectData()
				effectdata:SetStart(Vector(0, 0, 255))
				effectdata:SetOrigin(tr.HitPos)
				effectdata:SetNormal( tr.HitNormal )
				util.Effect("lvs_laser_explosion", effectdata)
			end
			ent:LVSFireBullet(bullet)

			local effectdata = EffectData()
			effectdata:SetStart(Vector(0, 0, 255))
			effectdata:SetOrigin(bullet.Src)
			effectdata:SetNormal(ent:GetForward())
			effectdata:SetEntity(ent)
			util.Effect("lvs_muzzle_colorable", effectdata)

			ent:TakeAmmo()
		end

		if ent.NumPrim == 1 then
			ent.SNDFront:PlayOnce(100 + math.cos(CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1)
		else
			ent.SNDRear:PlayOnce(100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1)
		end
	end
	weapon.OnSelect = function( ent )
		ent:EmitSound("physics/metal/weapon_impact_soft3.wav")
	end
	weapon.OnOverheat = function(ent)
		ent:EmitSound("lvs/overheat.wav")
	end
	self:AddWeapon(weapon)
end

ENT.EngineSounds = {
	{
		sound = "lvs/vehicles/barc/engine_loop.wav",
		Pitch = 70,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 30,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
		SoundLevel = 85,
	}
}
--addons/egm_lvs_ground/lua/entities/lvs_fakehover_celeritas/shared.lua:
ENT.Base = "lvs_base_fakehover"

ENT.PrintName = "Celeritas Speeder"
ENT.Author = "Deltaa"
ENT.Information = ""
ENT.Category = "[LVS] - Neutral"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/myproject1/mesh_0604.mdl"

ENT.AITEAM = 0

ENT.MaxHealth = 1750

ENT.ForceAngleMultiplier = 2
ENT.ForceAngleDampingMultiplier = 1

ENT.ForceLinearMultiplier = 1
ENT.ForceLinearRate = 0.25

ENT.MaxVelocityX = 900
ENT.MaxVelocityY = 800

ENT.MaxTurnRate = 0.8

ENT.BoostAddVelocityX = 100
ENT.BoostAddVelocityY = 100

ENT.GroundTraceHitWater = true
ENT.GroundTraceLength = 50
ENT.GroundTraceHull = 100

ENT.LAATC_PICKUPABLE = true
ENT.LAATC_PICKUP_POS = Vector(-200, 0, 30)
ENT.LAATC_PICKUP_Angle = Angle(0, 0, 0)

function ENT:OnIsCarried( name, old, new)
	if new == old then return end

	if new then
		self:SetDisabled(true)
	else
		self:SetDisabled(false)
	end
end

function ENT:OnSetupDataTables()
	self:AddDT( "Bool", "IsCarried" )

	if SERVER then
		self:NetworkVarNotify("IsCarried", self.OnIsCarried)
	end
end

function ENT:InitWeapons()
end

ENT.EngineSounds = {
	{
		sound = "lvs/vehicles/x-34/engine_loop.wav",
		Pitch = 70,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 30,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
		SoundLevel = 85,
	}
}
--addons/lvs_starwars/lua/entities/lvs_fakehover_soundemitter.lua:
AddCSLuaFile()

ENT.Base = "lvs_starfighter_soundemitter"

if SERVER then return end

function ENT:HandleEngineSounds( vehicle )
	local ply = LocalPlayer()
	local pod = ply:GetVehicle()
	local Throttle = vehicle:GetThrottle()
	local Doppler = vehicle:CalcDoppler( ply )

	local DrivingMe = ply:lvsGetVehicle() == vehicle

	local VolumeSetNow = false

	local FirstPerson = false
	if IsValid( pod ) then
		local ThirdPerson = pod:GetThirdPersonMode()

		if ThirdPerson ~= self._lvsoldTP then
			self._lvsoldTP = ThirdPerson
			VolumeSetNow = DrivingMe
		end

		FirstPerson = DrivingMe and not ThirdPerson
	end

	if DrivingMe ~= self._lvsoldDrivingMe then
		VolumeSetNow = true
		self._lvsoldDrivingMe = DrivingMe
	end

	for id, sound in pairs( self._ActiveSounds ) do
		if not sound then continue end

		local data = self.EngineSounds[ id ]

		local Pitch = math.Clamp( data.Pitch + Throttle * data.PitchMul, data.PitchMin, data.PitchMax )
		local PitchMul = data.UseDoppler and Doppler or 1

		local InActive = Throttle > data.FadeOut or Throttle < data.FadeIn
		if data.FadeOut >= 1 and Throttle > 1 then
			InActive = false
		end

		local Volume = InActive and 0 or LVS.EngineVolume

		if data.VolumeMin and data.VolumeMax and not InActive then
			Volume = math.max(Throttle - data.VolumeMin,0) / (1 - data.VolumeMin) * data.VolumeMax * LVS.EngineVolume
		end

		if istable( sound ) then
			sound.ext:ChangePitch( math.Clamp( Pitch * PitchMul, 0, 255 ), 0.2 )
			if sound.int then sound.int:ChangePitch( math.Clamp( Pitch, 0, 255 ), 0.2 ) end

			local fadespeed = VolumeSetNow and 0 or data.FadeSpeed

			if FirstPerson then
				sound.ext:ChangeVolume( 0, 0 )
				if sound.int then sound.int:ChangeVolume( Volume, fadespeed ) end
			else
				sound.ext:ChangeVolume( Volume, fadespeed )
				if sound.int then sound.int:ChangeVolume( 0, 0 ) end
			end
		else
			sound:ChangePitch( math.Clamp( Pitch * PitchMul, 0, 255 ), 0.2 )
			sound:ChangeVolume( Volume, data.FadeSpeed )
		end
	end
end

--addons/egm_lvs_ground/lua/entities/lvs_fakehover_supertank/shared.lua:
ENT.Base = "lvs_base_fakehover"

ENT.PrintName = "Super Tank"
ENT.Author = "Deltaa"
ENT.Information = "The super tank was the culmination of an attempt by the Confederacy of Independent Systems during the Clone Wars to produce a new type of tank."
ENT.Category = "[LVS] - Separatisten"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.AITEAM = 1

ENT.MDL = "models/niksacokica/super_tank/super_tank.mdl"

ENT.MaxHealth = 42000
ENT.MaxShield = 30000

ENT.ForceAngleMultiplier = 2
ENT.ForceAngleDampingMultiplier = 1

ENT.ForceLinearMultiplier = 1
ENT.ForceLinearRate = 0.25

ENT.MaxVelocityX = 300
ENT.MaxVelocityY = 300

ENT.MaxTurnRate = 0.5

ENT.BoostAddVelocityX = 100
ENT.BoostAddVelocityY = 100

ENT.GroundTraceHitWater = true
ENT.GroundTraceLength = 50
ENT.GroundTraceHull = 100

function ENT:OnSetupDataTables()
	self:AddDT("Bool", "IsCarried")

	if SERVER then
		self:NetworkVarNotify("IsCarried", self.OnIsCarried)
	end
end

function ENT:OnIsCarried( name, old, new)
	if new == old then return end

	if new then
		self:SetDisabled(true)
	else
		self:SetDisabled(false)
	end
end

function ENT:InitWeapons()
	self.FirePositions = {
		{
			Vector(232, 114, 10),
			Vector(222, 113, 4)
		},

		{
			Vector(232, -114, 10),
			Vector(222, -113, 4)
		}
	}

	-- Primary Gun
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/hmg.png")
	weapon.Ammo = 1000
	weapon.Delay = 0.15
	weapon.HeatRateUp = 0.1
	weapon.HeatRateDown = 0.25
	weapon.Attack = function(ent)
		ent.NumPrim = ent.NumPrim and ent.NumPrim + 1 or 1
		if ent.NumPrim > #ent.FirePositions then ent.NumPrim = 1 end

		local pod = ent:GetDriverSeat()
		if not IsValid(pod) then return end

		local startpos = pod:LocalToWorld(pod:OBBCenter())
		local trace = util.TraceHull( {
			start = startpos,
			endpos = startpos + ent:GetForward() * 50000,
			mins = Vector(-10, -10, -10),
			maxs = Vector(10, 10, 10),
			filter = ent:GetCrosshairFilterEnts()
		})

		local CurPos = ent.FirePositions[ent.NumPrim]
		for _, pos in pairs(CurPos) do
			local bullet = {}
			bullet.Src = ent:LocalToWorld(pos)
			bullet.Dir = (trace.HitPos - bullet.Src):GetNormalized()
			bullet.Spread = Vector(0.05,  0.05, 0)
			bullet.TracerName = "lvs_laser_red"
			bullet.Force = 250
			bullet.HullSize = 1
			bullet.Damage = 750
			bullet.Velocity = 40000
			bullet.Attacker = ent:GetDriver()
			bullet.Callback = function(att, tr, dmginfo)
				dmginfo:SetDamageType(DMG_AIRBOAT)

				local effectdata = EffectData()
				effectdata:SetStart(Vector(255, 0, 0))
				effectdata:SetOrigin(tr.HitPos)
				effectdata:SetNormal( tr.HitNormal )
				util.Effect("lvs_laser_explosion", effectdata)
			end
			ent:LVSFireBullet(bullet)

			local effectdata = EffectData()
			effectdata:SetStart(Vector(255, 0, 0))
			effectdata:SetOrigin(bullet.Src)
			effectdata:SetNormal(ent:GetForward())
			effectdata:SetEntity(ent)
			util.Effect("lvs_muzzle_colorable", effectdata)
		end

		if ent.NumPrim == 1 then
			ent.SNDLeft:PlayOnce(100 + math.cos(CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1)
		else
			ent.SNDRight:PlayOnce(100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1)
		end
	end
	weapon.OnSelect = function( ent )
		ent:EmitSound("physics/metal/weapon_impact_soft3.wav")
	end
	weapon.OnOverheat = function(ent)
		ent:EmitSound("lvs/overheat.wav")
	end
	self:AddWeapon(weapon)

	-- Adds the rocket gun
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/missile.png")
	weapon.Ammo = 60
	weapon.Delay = 0.25
	weapon.HeatRateUp = 0.25
	weapon.HeatRateDown = 0.2
	weapon.Attack = function(ent)
		if not ent:WeaponsInRange() then return true end

		self:EmitSound("lvs/vehicles/tx130/rocket.wav")

		local Pos = Vector(150, 0, 250)

		local projectile = ents.Create("lvs_missile")
		projectile:SetPos(self:LocalToWorld(Pos))
		projectile:SetAngles(self:GetAngles())
		projectile:SetParent(ent)
		projectile:Spawn()
		projectile:Activate()
		projectile:SetAttacker(self)
		projectile:SetEntityFilter(ent:GetCrosshairFilterEnts())
		projectile:SetSpeed(20000)
		projectile:SetDamage(900)
		projectile:SetRadius(150)
		projectile:Enable()

		-- Creates an effect
		local effectdata = EffectData()
		effectdata:SetOrigin(self:GetPos())
		effectdata:SetRadius(500 * 500)
		effectdata:SetScale(24 * 20)
		util.Effect("ThumperDust", effectdata, true, true )

		ent:TakeAmmo()
	end
	weapon.OnSelect = function( ent )
		ent:EmitSound("weapons/shotgun/shotgun_cock.wav")
	end
	self:AddWeapon(weapon)
end

ENT.EngineSounds = {
	{
		sound = "lvs/vehicles/tx130/engine.wav",
		Pitch = 70,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 30,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
		SoundLevel = 85,
	}
}
--addons/egm_lvs_ground/lua/entities/lvs_fakehover_tx130/cl_init.lua:
include("shared.lua")
include("sh_turret.lua")
include("cl_prediction.lua")

function ENT:CalcViewOverride(ply, pos, angles, fov, pod)
	local GunnerPod = self:GetGunnerSeat()
	if pod == GunnerPod and not pod:GetThirdPersonMode() then
		return GunnerPod:LocalToWorld(Vector(0, 0, 80)), angles + Angle(-10, 0, 0), fov
	end

	return pos, angles, fov
end

function ENT:AnimHatch()
	local GunnerSeat = self:GetGunnerSeat()
	if not IsValid(GunnerSeat) then return end

	local Gunner = GunnerSeat:GetDriver()
	local HasGunner = IsValid(Gunner)

	local Rate = FrameTime() * 5

	self.smHatch = self.smHatch and self.smHatch + math.Clamp((HasGunner and 1 or 0) - self.smHatch, -Rate, Rate) or 0
	if not HasTurret and self.smHatch > 0.7 then
		self.smHatch = 0.7
	end

	self:SetPoseParameter("open_hatch", self.smHatch)
end

function ENT:DamageFX()
	self.nextDFX = self.nextDFX or 0

	if self.nextDFX < CurTime() then
		self.nextDFX = CurTime() + 0.05

		local HP = self:GetHP()
		local MaxHP = self:GetMaxHP()

		if HP > MaxHP * 0.5 then return end

		local effectdata = EffectData()
		effectdata:SetOrigin(self:LocalToWorld(Vector(-30,0,43)))
		effectdata:SetEntity(self)
		util.Effect("lvs_engine_blacksmoke", effectdata)

		if HP <= MaxHP * 0.25 then
			local effectdata = EffectData()
			effectdata:SetOrigin(self:LocalToWorld(Vector(-85,65,14)))
			effectdata:SetNormal(self:GetUp())
			effectdata:SetMagnitude(math.Rand(0.5,1.5))
			effectdata:SetEntity(self)
			util.Effect("lvs_exhaust_fire", effectdata)

			local effectdata = EffectData()
			effectdata:SetOrigin(self:LocalToWorld(Vector(-85,-65,14)))
			effectdata:SetNormal(self:GetUp())
			effectdata:SetMagnitude(math.Rand(0.5,1.5))
			effectdata:SetEntity(self)
			util.Effect("lvs_exhaust_fire", effectdata)
		end
	end
end

function ENT:BTLProjector()
	local Fire = self:GetBTLFire()
	if Fire ~= self.OldFireBTL then
		self.OldFireBTL = Fire

		if Fire then
			self.BTLLOOP = CreateSound( self, "lvs/vehicles/laat/ballturret_loop.wav" )
			self.BTLLOOP:Play()

			local effectdata = EffectData()
			effectdata:SetEntity( self )
			util.Effect("lvs_tx130_projector", effectdata)
		else
			if self.BTLLOOP then
				self.BTLLOOP:Stop()
			end
		end
	end

	local bOn = self:GetEngineActive()

	local TVal = bOn and 0 or 1

	local Speed = FrameTime() * 4

	self.SMcOpen = self.SMcOpen and self.SMcOpen + math.Clamp(TVal - self.SMcOpen,-Speed,Speed) or 0

	self:ManipulateBoneAngles(20, Angle(0,0,self.SMcOpen * -95))
end

function ENT:OnFrame()
	self:AnimHatch()
	self:BTLProjector()
	self:DamageFX()
	self:DrawLight()
	self:PredictPoseParamaters()
end

local spotlight = Material("effects/lfs_base/spotlight_projectorbeam")
local glow_spotlight = Material("sprites/light_glow02_add")

function ENT:DrawLight()
	if self:GetBodygroup(9) ~= 1 then
		self:RemoveLight()
		return
	end

	if not IsValid(self.projector) then
		local thelamp = ProjectedTexture()
		thelamp:SetBrightness( 10 )
		thelamp:SetTexture("effects/flashlight/soft")
		thelamp:SetColor(Color(255, 255, 255))
		thelamp:SetEnableShadows(false)
		thelamp:SetFarZ(2500)
		thelamp:SetNearZ(75)
		thelamp:SetFOV(50)
		self.projector = thelamp
	end

	local StartPos = self:LocalToWorld(Vector(60, 0, 10.5))
	local Dir = self:GetForward()

	render.SetMaterial(glow_spotlight)
	render.DrawSprite(StartPos + Dir * -10 , 220, 120, Color(255, 255, 255, 255))

	render.SetMaterial(spotlight)
	render.DrawBeam(StartPos - Dir * 10,  StartPos + Dir * 800, 250, 0, 0.99, Color( 255, 255, 255, 10))

	if IsValid(self.projector) then
		self.projector:SetPos(StartPos)
		self.projector:SetAngles(Dir:Angle())
		self.projector:Update()
	end
end

function ENT:RemoveLight()
	if IsValid(self.projector) then
		self.projector:Remove()
		self.projector = nil
	end
end

function ENT:OnRemoved()
	self:RemoveLight()
end

--addons/lvs_base/lua/entities/lvs_missile.lua:
AddCSLuaFile()

ENT.Type            = "anim"

ENT.PrintName = "Missile"
ENT.Author = "Luna"
ENT.Information = "LVS Missile"
ENT.Category = "[LVS]"

ENT.Spawnable		= true
ENT.AdminOnly		= true

ENT.ExplosionEffect = "lvs_explosion_small"

ENT.lvsProjectile = true

function ENT:SetupDataTables()
	self:NetworkVar( "Bool", 0, "Active" )
	self:NetworkVar( "Entity", 0, "NWTarget" )
end

if SERVER then
	util.AddNetworkString( "lvs_missile_hud" )

	function ENT:GetAvailableTargets()
		local targets = {
			[1] = player.GetAll(),
			[2] = LVS:GetVehicles(),
			[3] = LVS:GetNPCs(),
		}

		return targets
	end

	function ENT:FindTarget( pos, forward, cone_ang, cone_len )
		local targets = self:GetAvailableTargets()

		local Attacker = self:GetAttacker()
		local Parent = self:GetParent()
		local Owner = self:GetOwner()
		local Target = NULL
		local DistToTarget = 0

		for _, tbl in ipairs( targets ) do
			for _, ent in pairs( tbl ) do
				if not IsValid( ent ) or ent == Parent or ent == Owner or Target == ent or Attacker == ent then continue end

				local pos_ent = ent:GetPos()
				local dir = (pos_ent - pos):GetNormalized()
				local ang = math.deg( math.acos( math.Clamp( forward:Dot( dir ) ,-1,1) ) )

				if ang > cone_ang then continue end

				local dist, _, _ = util.DistanceToLine( pos, pos + forward * cone_len, pos_ent )

				if not IsValid( Target ) then
					Target = ent
					DistToTarget = dist

					continue
				end

				if dist < DistToTarget then
					Target = ent
					DistToTarget = dist
				end
			end
		end

		self:SetTarget( Target )

		local ply = self:GetAttacker()

		if not IsValid( ply ) or not ply:IsPlayer() then return end

		net.Start( "lvs_missile_hud", true )
			net.WriteEntity( self )
		net.Send( ply )
	end

	function ENT:SetEntityFilter( filter )
		if not istable( filter ) then return end

		self._FilterEnts = {}

		for _, ent in pairs( filter ) do
			self._FilterEnts[ ent ] = true
		end
	end
	function ENT:SetTarget( ent ) self:SetNWTarget( ent ) end
	function ENT:SetDamage( num ) self._dmg = num end
	function ENT:SetForce( num ) self._force = num end
	function ENT:SetThrust( num ) self._thrust = num end
	function ENT:SetSpeed( num ) self._speed = num end
	function ENT:SetTurnSpeed( num ) self._turnspeed = num end
	function ENT:SetRadius( num ) self._radius = num end
	function ENT:SetAttacker( ent ) self._attacker = ent end

	function ENT:GetAttacker() return self._attacker or NULL end
	function ENT:GetDamage() return (self._dmg or 100) end
	function ENT:GetForce() return (self._force or 4000) end
	function ENT:GetRadius() return (self._radius or 250) end
	function ENT:GetSpeed() return (self._speed or 4000) end
	function ENT:GetTurnSpeed() return (self._turnspeed or 1) * 100 end
	function ENT:GetThrust() return (self._thrust or 500) end
	function ENT:GetTarget()
		if IsValid( self:GetNWTarget() ) then
			local Pos = self:GetPos()
			local tPos = self:GetTargetPos()

			local Sub = tPos - Pos
			local Len = Sub:Length()
			local Dir = Sub:GetNormalized()
			local Forward = self:GetForward()

			local AngToTarget = math.deg( math.acos( math.Clamp( Forward:Dot( Dir ) ,-1,1) ) )

			local LooseAng = math.min( Len / 100, 90 )

			if AngToTarget > LooseAng then
				self:SetNWTarget( NULL )
			end
		end

		return self:GetNWTarget()
	end
	function ENT:GetTargetPos()
		local Target = self:GetNWTarget()

		if not IsValid( Target ) then return Vector(0,0,0) end

		if isfunction( Target.GetMissileOffset ) then
			return Target:LocalToWorld( Target:GetMissileOffset() )
		end

		return Target:GetPos()
	end

	function ENT:SpawnFunction( ply, tr, ClassName )

		local ent = ents.Create( ClassName )
		ent:SetPos( ply:GetShootPos() )
		ent:SetAngles( ply:EyeAngles() )
		ent:Spawn()
		ent:Activate()
		ent:SetAttacker( ply )
		ent:Enable()

		return ent
	end

	function ENT:Initialize()	
		self:SetModel( "models/weapons/w_missile_launch.mdl" )
		self:SetMoveType( MOVETYPE_NONE )
		self:SetRenderMode( RENDERMODE_TRANSALPHA )
	end

	function ENT:Enable()
		if self.IsEnabled then return end

		local Parent = self:GetParent()

		if IsValid( Parent ) then
			self:SetOwner( Parent )
			self:SetParent( NULL )
		end

		self:PhysicsInit( SOLID_VPHYSICS )
		self:SetMoveType( MOVETYPE_VPHYSICS )
		self:SetSolid( SOLID_VPHYSICS )
		self:SetCollisionGroup( COLLISION_GROUP_NONE )
		self:PhysWake()

		self.IsEnabled = true

		local pObj = self:GetPhysicsObject()
		
		if not IsValid( pObj ) then
			self:Remove()

			print("LVS: missing model. Missile terminated.")

			return
		end

		pObj:SetMass( 1 ) 
		pObj:EnableGravity( false ) 
		pObj:EnableMotion( true )
		pObj:EnableDrag( false )

		self:SetTrigger( true )

		self:StartMotionController()

		self:PhysWake()

		self.SpawnTime = CurTime()

		self:SetActive( true )
	end

	function ENT:PhysicsSimulate( phys, deltatime )
		phys:Wake()

		local Thrust = self:GetThrust()
		local Speed = self:GetSpeed()
		local Pos = self:GetPos()
		local velL = self:WorldToLocal( Pos + self:GetVelocity() )

		local ForceLinear = (Vector( Speed * Thrust,0,0) - velL) * deltatime

		local Target = self:GetTarget()

		if not IsValid( Target ) then
			return (-phys:GetAngleVelocity() * 250 * deltatime), ForceLinear, SIM_LOCAL_ACCELERATION
		end

		local AngForce = -self:WorldToLocalAngles( (self:GetTargetPos() - Pos):Angle() )

		local ForceAngle = (Vector(AngForce.r,-AngForce.p,-AngForce.y) * self:GetTurnSpeed() - phys:GetAngleVelocity() * 5 ) * 250 * deltatime

		return ForceAngle, ForceLinear, SIM_LOCAL_ACCELERATION
	end

	function ENT:Think()	
		local T = CurTime()

		self:NextThink( T + 1 )

		if not self.SpawnTime then return true end

		if (self.SpawnTime + 12) < T then
			self:Detonate()
		end

		return true
	end

	ENT.IgnoreCollisionGroup = {
		[COLLISION_GROUP_NONE] = true,
		[COLLISION_GROUP_WORLD] =  true,
		[COLLISION_GROUP_INTERACTIVE_DEBRIS] = true,
	}

	function ENT:StartTouch( entity )
		if entity == self:GetAttacker() then return end

		if istable( self._FilterEnts ) and self._FilterEnts[ entity ] then return end

		if entity.GetCollisionGroup and self.IgnoreCollisionGroup[ entity:GetCollisionGroup() ] then return end

		if entity.lvsProjectile then return end

		self:Detonate( entity )
	end

	function ENT:EndTouch( entity )
	end

	function ENT:Touch( entity )
	end

	function ENT:PhysicsCollide( data )
		if istable( self._FilterEnts ) and self._FilterEnts[ data.HitEntity ] then return end

		self:Detonate( data.HitEntity )
	end

	function ENT:OnTakeDamage( dmginfo )	
	end

	function ENT:Detonate( target )
		if not self.IsEnabled or self.IsDetonated then return end

		self.IsDetonated = true

		local Pos =  self:GetPos() 

		local effectdata = EffectData()
			effectdata:SetOrigin( Pos )
		util.Effect( self.ExplosionEffect, effectdata )

		local attacker = self:GetAttacker()

		LVS:BlastDamage( Pos, self:GetForward(), IsValid( attacker ) and attacker or game.GetWorld(), self, self:GetDamage(), DMG_BLAST, self:GetRadius(), self:GetForce() )

		SafeRemoveEntityDelayed( self, FrameTime() )
	end
else
	function ENT:Initialize()	
	end

	function ENT:Enable()
		if self.IsEnabled then return end

		self.IsEnabled = true

		self.snd = CreateSound(self, "weapons/rpg/rocket1.wav")
		self.snd:SetSoundLevel( 80 )
		self.snd:Play()

		local effectdata = EffectData()
			effectdata:SetOrigin( self:GetPos() )
			effectdata:SetEntity( self )
		util.Effect( "lvs_missiletrail", effectdata )
	end

	function ENT:CalcDoppler()
		local Ent = LocalPlayer()

		local ViewEnt = Ent:GetViewEntity()

		if Ent:lvsGetVehicle() == self then
			if ViewEnt == Ent then
				Ent = self
			else
				Ent = ViewEnt
			end
		else
			Ent = ViewEnt
		end

		local sVel = self:GetVelocity()
		local oVel = Ent:GetVelocity()

		local SubVel = oVel - sVel
		local SubPos = self:GetPos() - Ent:GetPos()

		local DirPos = SubPos:GetNormalized()
		local DirVel = SubVel:GetNormalized()

		local A = math.acos( math.Clamp( DirVel:Dot( DirPos ) ,-1,1) )

		return (1 + math.cos( A ) * SubVel:Length() / 13503.9)
	end

	function ENT:Draw()
		if not self:GetActive() then return end

		self:DrawModel()
	end

	function ENT:Think()
		if self.snd then
			self.snd:ChangePitch( 100 * self:CalcDoppler() )
		end

		if self.IsEnabled then return end

		if self:GetActive() then
			self:Enable()
		end
	end

	function ENT:SoundStop()
		if self.snd then
			self.snd:Stop()
		end
	end

	function ENT:OnRemove()
		self:SoundStop()
	end

	local function DrawDiamond( X, Y, radius, angoffset )
		angoffset = angoffset or 0

		local segmentdist = 90
		local radius2 = radius + 1

		for ang = 0, 360, segmentdist do
			local a = ang + angoffset
			surface.DrawLine( X + math.cos( math.rad( a ) ) * radius, Y - math.sin( math.rad( a ) ) * radius, X + math.cos( math.rad( a + segmentdist ) ) * radius, Y - math.sin( math.rad( a + segmentdist ) ) * radius )
			surface.DrawLine( X + math.cos( math.rad( a ) ) * radius2, Y - math.sin( math.rad( a ) ) * radius2, X + math.cos( math.rad( a + segmentdist ) ) * radius2, Y - math.sin( math.rad( a + segmentdist ) ) * radius2 )
		end
	end

	local color_red = Color(255,0,0,255)
	local HudTargets = {}
	hook.Add( "HUDPaint", "!!!!lvs_missile_hud", function()
		local T = CurTime()

		local Index = 0

		surface.SetDrawColor( 255, 0, 0, 255 )

		for ID, _ in pairs( HudTargets ) do
			local Missile = Entity( ID )

			if not IsValid( Missile ) then
				HudTargets[ ID ] = nil

				continue
			end

			local Target = Missile:GetNWTarget()

			if not IsValid( Target ) then
				HudTargets[ ID ] = nil

				continue
			end

			local MissilePos = Missile:GetPos():ToScreen()
			local TargetPos = Target:LocalToWorld( Target:OBBCenter() ):ToScreen()

			Index =  Index + 1

			if not TargetPos.visible then continue end

			DrawDiamond( TargetPos.x, TargetPos.y, 40, ID * 1337 - T * 100 )

			draw.DrawText("LOCK", "LVS_FONT", TargetPos.x + 20, TargetPos.y + 20, color_red, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP )

			if not MissilePos.visible then continue end

			DrawDiamond( MissilePos.x, MissilePos.y, 16, ID * 1337 - T * 100 )
			draw.DrawText( Index, "LVS_FONT", MissilePos.x + 10, MissilePos.y + 10, color_red, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP )
		
			surface.DrawLine( MissilePos.x, MissilePos.y, TargetPos.x, TargetPos.y )
		end
	end )

	net.Receive( "lvs_missile_hud", function( len )
		local ent = net.ReadEntity()

		if not IsValid( ent ) then return end

		HudTargets[ ent:EntIndex() ] = true
	end )
end
--addons/egm_lvs_ships/lua/entities/lvs_repulsorlift_droidship/shared.lua:
ENT.Base = "lvs_base_repulsorlift"

ENT.PrintName = "Droid Gunship"
ENT.Author = "Deltaa"
ENT.Information = "Droid transporter used by the CIS"
ENT.Category = "[LVS] - Separatisten"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/jellyton/bf2/cis/vehicles/hmp_gunship.mdl"

ENT.MaxHealth = 6000
ENT.MaxShield = 4500

ENT.AITEAM = 1

ENT.MaxVelocity = 2400
ENT.MaxThrust = 2400

ENT.MaxPitch = 50

ENT.ThrustVtol = 50
ENT.ThrustRateVtol = 2

ENT.TurnRatePitch = 1
ENT.TurnRateYaw = 1
ENT.TurnRateRoll = 1

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1
ENT.ForceAngleDampingMultiplier = 1

ENT.LAATC_PICKUPABLE = true
ENT.LAATC_PICKUP_POS = Vector(-295, 0, -75)
ENT.LAATC_PICKUP_Angle = Angle(0, 0, 0)

function ENT:InitWeapons()
	-- Primary Gun
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/hmg.png")
	weapon.Ammo = -1
	weapon.Delay = 0.2
	weapon.HeatRateUp = 0.3
	weapon.HeatRateDown = 0.1
	weapon.Attack = function(ent)
		local pod = ent:GetDriverSeat()
		if not IsValid(pod) then return end

		local startpos = pod:LocalToWorld(pod:OBBCenter())
		local trace = util.TraceHull( {
			start = startpos,
			endpos = startpos + ent:GetForward() * 50000,
			mins = Vector(-10, -10, -10),
			maxs = Vector(10, 10, 10),
			filter = ent:GetCrosshairFilterEnts()
		})

		local bullet = {}
		bullet.Src = ent:LocalToWorld(Vector(650, 0, -135))
		bullet.Dir = (trace.HitPos - bullet.Src):GetNormalized()
		bullet.Spread = Vector(0.05,  0.05, 0)
		bullet.TracerName = "lvs_laser_red"
		bullet.Force = 500
		bullet.HullSize = 10
		bullet.Damage = 900
		bullet.Velocity = 50000
		bullet.Attacker = ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			dmginfo:SetDamageType(DMG_AIRBOAT)

			local effectdata = EffectData()
			effectdata:SetStart(Vector(255, 0, 0))
			effectdata:SetOrigin(tr.HitPos)
			effectdata:SetNormal( tr.HitNormal )
			util.Effect("lvs_laser_explosion", effectdata)
		end
		ent:LVSFireBullet(bullet)

		local effectdata = EffectData()
		effectdata:SetStart(Vector(255, 0, 0))
		effectdata:SetOrigin(bullet.Src)
		effectdata:SetNormal(ent:GetForward())
		effectdata:SetEntity(ent)
		util.Effect("lvs_muzzle_colorable", effectdata)

		ent.SNDHeavy:PlayOnce(100 + math.cos(CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1)
	end
	weapon.OnSelect = function( ent )
		ent:EmitSound("physics/metal/weapon_impact_soft3.wav")
	end
	weapon.OnOverheat = function(ent)
		ent:EmitSound("lvs/overheat.wav")
	end
	self:AddWeapon(weapon)

	-- Secondary Gun
	self.FirePositions = {
		{
			Vector(463, 230, -118),
			Vector(463, -230, -118)
		},

		{
			Vector(-51, 481, -54),
			Vector(-51, -481, -54)
		}
	}

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/dual_mg.png")
	weapon.Delay = 0.2
	weapon.HeatRateUp = 0.1
	weapon.HeatRateDown = 0.1
	weapon.Attack = function(ent)
		ent.NumPrim = ent.NumPrim and ent.NumPrim + 1 or 1
		if ent.NumPrim > #ent.FirePositions then ent.NumPrim = 1 end

		local pod = ent:GetDriverSeat()
		if not IsValid(pod) then return end

		local startpos = pod:LocalToWorld(pod:OBBCenter())
		local trace = util.TraceHull( {
			start = startpos,
			endpos = startpos + ent:GetForward() * 50000,
			mins = Vector(-10, -10, -10),
			maxs = Vector(10, 10, 10),
			filter = ent:GetCrosshairFilterEnts()
		})

		local CurPos = ent.FirePositions[ent.NumPrim]
		for _, pos in pairs(CurPos) do
			local bullet = {}
			bullet.Src = ent:LocalToWorld(pos)
			bullet.Dir = (trace.HitPos - bullet.Src):GetNormalized()
			bullet.Spread = Vector(0.05,  0.05, 0)
			bullet.TracerName = "lvs_laser_red"
			bullet.Force = 100
			bullet.HullSize = 10
			bullet.Damage = 300
			bullet.Velocity = 50000
			bullet.Attacker = ent:GetDriver()
			bullet.Callback = function(att, tr, dmginfo)
				dmginfo:SetDamageType(DMG_AIRBOAT)

				local effectdata = EffectData()
				effectdata:SetStart(Vector(255, 0, 0))
				effectdata:SetOrigin(tr.HitPos)
				effectdata:SetNormal( tr.HitNormal )
				util.Effect("lvs_laser_explosion", effectdata)
			end
			ent:LVSFireBullet(bullet)

			local effectdata = EffectData()
			effectdata:SetStart(Vector(255, 0, 0))
			effectdata:SetOrigin(bullet.Src)
			effectdata:SetNormal(ent:GetForward())
			effectdata:SetEntity(ent)
			util.Effect("lvs_muzzle_colorable", effectdata)

			if ent.NumPrim == 1 then
				ent.SNDTurret:PlayOnce(100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1)
			else
				ent.SNDSide:PlayOnce(100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1)
			end
		end
	end
	weapon.OnSelect = function( ent )
		ent:EmitSound("physics/metal/weapon_impact_soft3.wav")
	end
	weapon.OnOverheat = function(ent)
		ent:EmitSound("lvs/overheat.wav")
	end
	self:AddWeapon(weapon)

	-- Rockets
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/missile.png")
	weapon.Ammo = 60
	weapon.Delay = 0.1
	weapon.HeatRateUp = 0.1
	weapon.HeatRateDown = 0.05
	weapon.Attack = function( ent )
		local FirePos = {
			[1] = self:GetPos() + self:GetForward() * 0 + self:GetUp() * 9 + self:GetRight() * 330,
			[2] = self:GetPos() + self:GetForward() * 0 + self:GetUp() * 9 + self:GetRight() * -330,
			[3] = self:GetPos() + self:GetForward() * 0 + self:GetUp() * 9 + self:GetRight() * 293,
			[4] = self:GetPos() + self:GetForward() * 0 + self:GetUp() * 9 + self:GetRight() * -293,
			[5] = self:GetPos() + self:GetForward() * 0 + self:GetUp() * 9 + self:GetRight() * 255,
			[6] = self:GetPos() + self:GetForward() * 0 + self:GetUp() * 9 + self:GetRight() * -255,
			[7] = self:GetPos() + self:GetForward() * 0 + self:GetUp() * 9 + self:GetRight() * 220,
			[8] = self:GetPos() + self:GetForward() * 0 + self:GetUp() * 9 + self:GetRight() * -220,
			[9] = self:GetPos() + self:GetForward() * 0 + self:GetUp() * 9 + self:GetRight() * 182,
			[10] = self:GetPos() + self:GetForward() * 0 + self:GetUp() * 9 + self:GetRight() * -182,
			[11] = self:GetPos() + self:GetForward() * 0 + self:GetUp() * -29 + self:GetRight() * 278,
			[12] = self:GetPos() + self:GetForward() * 0 + self:GetUp() * -29 + self:GetRight() * -278,
			[13] = self:GetPos() + self:GetForward() * 0 + self:GetUp() * -29 + self:GetRight() * 238,
			[14] = self:GetPos() + self:GetForward() * 0 + self:GetUp() * -29 + self:GetRight() * -238,
		}	

		self.FireIndex = self.FireIndex and self.FireIndex + 1 or 1

		if self.FireIndex > 14 then
			self.FireIndex = 1
		elseif self.FireIndex == 14 then
			ent:SetHeat(1)
			ent:SetOverheated(true)
		end

		self:EmitSound("lfs/droidgunship/rockets/rocket_ignite.wav")

		local Pos = FirePos[self.FireIndex]

		local projectile = ents.Create("lvs_missile")
		projectile:SetPos(Pos)
		projectile:SetAngles(self:GetAngles())
		projectile:SetParent(ent)
		projectile:Spawn()
		projectile:Activate()
		projectile.GetTarget = function(missile) return missile end
		projectile.GetTargetPos = function(missile)
			return missile:LocalToWorld(Vector(150, 0, 0) + VectorRand() * math.random(-5, 5))
		end
		projectile:SetAttacker(self)
		projectile:SetEntityFilter(ent:GetCrosshairFilterEnts())
		projectile:SetSpeed(8000)
		projectile:SetDamage(3000)
		projectile:SetRadius(150)
		projectile:Enable()

		ent:TakeAmmo()
	end
	weapon.OnSelect = function( ent )
		ent:EmitSound("weapons/shotgun/shotgun_cock.wav")
	end
	self:AddWeapon(weapon)
end

ENT.FlyByAdvance = 1
ENT.FlyBySound = "lvs/vehicles/droidship/flyby.wav"
ENT.DeathSound = "lvs/vehicles/generic_starfighter/crash.wav"

ENT.EngineSounds = {
	{
		sound = "lvs/vehicles/droidship/engine.wav",
		Pitch = 80,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 40,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
	},
}
--addons/egm_lvs_ships/lua/entities/lvs_repulsorlift_gunship/shared.lua:
ENT.Base = "lvs_base_repulsorlift"

ENT.PrintName = "LAAT/i"
ENT.Author = "Luna, Deltaa, Fisher"
ENT.Information = "Gunship/Troop Transport of the Galactic Republic"
ENT.Category = "[LVS] - Republik"

ENT.IsLAAT = true

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/fisher/laat/laatspace.mdl"

ENT.MaxHealth = 18000

ENT.AITEAM = 2

ENT.MaxVelocity = 2400
ENT.MaxThrust = 2400

ENT.MaxPitch = 60

ENT.ThrustVtol = 50
ENT.ThrustRateVtol = 2

ENT.TurnRatePitch = 0.7
ENT.TurnRateYaw = 0.7
ENT.TurnRateRoll = 0.7

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1
ENT.ForceAngleDampingMultiplier = 1

function ENT:OnSetupDataTables()
	self:AddDT("Bool", "RearHatch")
	self:AddDT("Bool", "WingTurretFire")
	self:AddDT("Bool", "LightsActive")
	self:AddDT("Entity", "GunnerSeat")
	self:AddDT("Entity", "HatchSeat")
	self:AddDT("Int", "DoorMode")
	self:AddDT("Int", "LightsMode")
	self:AddDT("Vector", "WingTurretTarget")
end

function ENT:InitWeapons()
	self:InitDriverWeapons()
	self:InitGunnerWeapons()
end

function ENT:IsSpotlightMounted()
	return self:GetBodygroup(7) == 1
end

sound.Add( {
	name = "LVS.LAAT.FLYBY",
	sound = {
		"lvs/vehicles/laat/flyby1.wav",
		"lvs/vehicles/laat/flyby2.wav",
		"lvs/vehicles/laat/flyby3.wav",
		"lvs/vehicles/laat/flyby4.wav",
		"lvs/vehicles/laat/flyby5.wav",
	}
} )

ENT.FlyByAdvance = 1
ENT.FlyBySound = "LVS.LAAT.FLYBY"
ENT.DeathSound = "lvs/vehicles/generic_starfighter/crash.wav"

ENT.EngineSounds = {
	{
		sound = "lvs/vehicles/laat/loop.wav",
		Pitch = 80,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 40,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
	},
}

function ENT:CalcMainActivity(ply)
	local Pod = ply:GetVehicle()

	if Pod == self:GetDriverSeat() or Pod == self:GetGunnerSeat() then return end

	if ply.m_bWasNoclipping then
		ply.m_bWasNoclipping = nil
		ply:AnimResetGestureSlot(GESTURE_SLOT_CUSTOM)

		if CLIENT then
			ply:SetIK(true)
		end
	end

	ply.CalcIdeal = ACT_STAND
	ply.CalcSeqOverride = ply:LookupSequence("idle_all_02")

	if ply:GetAllowWeaponsInVehicle() and IsValid( ply:GetActiveWeapon() ) then

		local holdtype = ply:GetActiveWeapon():GetHoldType()

		if holdtype == "smg" then
			holdtype = "smg1"
		end

		local seqid = ply:LookupSequence("idle_" .. holdtype)

		if seqid ~= -1 then
			ply.CalcSeqOverride = seqid
		end
	end

	return ply.CalcIdeal, ply.CalcSeqOverride
end
--addons/egm_lvs_ships/lua/entities/lvs_repulsorlift_gunship_medic/shared.lua:
ENT.Base = "lvs_repulsorlift_gunship"

ENT.PrintName = "LAAT/i Bloodraven"
ENT.Author = "Deltaa"
ENT.Information = "Medical Troop Transport of the Galactic Republic"
ENT.Category = "[LVS] - Republik"

ENT.IsLAAT = true

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/fisher/laat/laatspace.mdl"

function ENT:InitWeapons()
	self.FirePositions = {
		Vector(432, 34, 36),
		Vector(432, -34, 36)
	}

	-- Primary Gun
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/hmg.png")
	weapon.Delay = 0.15
	weapon.HeatRateUp = 0.1
	weapon.HeatRateDown = 0.1
	weapon.Attack = function(ent)
		ent.NumPrim = ent.NumPrim and ent.NumPrim + 1 or 1
		if ent.NumPrim > #ent.FirePositions then ent.NumPrim = 1 end

		local pod = ent:GetDriverSeat()
		if not IsValid(pod) then return end

		local startpos = pod:LocalToWorld(pod:OBBCenter())
		local trace = util.TraceHull( {
			start = startpos,
			endpos = startpos + ent:GetForward() * 50000,
			mins = Vector(-10, -10, -10),
			maxs = Vector(10, 10, 10),
			filter = ent:GetCrosshairFilterEnts()
		})

		local CurPos = ent.FirePositions[ent.NumPrim]

		local bullet = {}
		bullet.Src = ent:LocalToWorld(CurPos)
		bullet.Dir = (trace.HitPos - bullet.Src):GetNormalized()
		bullet.Spread = Vector(0.05,  0.05, 0)
		bullet.TracerName = "lvs_laser_green"
		bullet.Force = 100
		bullet.HullSize = 10
		bullet.Damage = 300
		bullet.Velocity = 50000
		bullet.Attacker = ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			dmginfo:SetDamageType(DMG_AIRBOAT)

			local effectdata = EffectData()
			effectdata:SetStart(Vector(100, 0, 0))
			effectdata:SetOrigin(tr.HitPos)
			effectdata:SetNormal( tr.HitNormal )
			util.Effect("lvs_laser_explosion", effectdata)
		end
		ent:LVSFireBullet(bullet)

		local effectdata = EffectData()
		effectdata:SetStart(Vector(100, 0, 0))
		effectdata:SetOrigin(bullet.Src)
		effectdata:SetNormal(ent:GetForward())
		effectdata:SetEntity(ent)
		util.Effect("lvs_muzzle_colorable", effectdata)

		ent:TakeAmmo()

		ent.PrimarySND:PlayOnce(100 + math.cos(CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1)
	end
	weapon.OnSelect = function( ent )
		ent:EmitSound("physics/metal/weapon_impact_soft3.wav")
	end
	weapon.OnOverheat = function(ent)
		ent:EmitSound("lvs/overheat.wav")
	end
	self:AddWeapon(weapon)

	-- Opens / Close the door
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/gunship_sidedoor.png")
	weapon.Ammo = -1
	weapon.Delay = 0
	weapon.HeatRateUp = 0
	weapon.HeatRateDown = 0
	weapon.StartAttack = function(ent)
		if ent.NextDoor and ent.NextDoor > CurTime() then return end
		ent.NextDoor = CurTime() + 1

		-- Sets the door mode
		local DoorMode = self:GetDoorMode() + 1
		DoorMode = DoorMode >= 2 and 0 or DoorMode
		self:SetDoorMode(DoorMode)

		if DoorMode == 0 then
			self:ResetSequence(self.closeSequence)
			self:SetPlaybackRate(1.5)

			local bonePos, _ = self:GetBonePosition(self:LookupBone("LAAT"))

			for doorID, _ in pairs(self.DoorsToClose) do
				local doorData = self.Doors[doorID]
				local offset = self:GetRight() * doorData.closeoffset.x + self:GetForward() * doorData.closeoffset.y + self:GetUp() * doorData.closeoffset.z
				doorData.ent:SetParent(nil)
				doorData.ent:SetPos(bonePos + offset)
				doorData.ent:SetParent(self)
			end

			timer.Simple(0.75, function()
				if not IsValid(self) then return end
				self:EmitSound("laat_bf2/door_close.mp3")

				if not self.IsHatchOpen then
					self:TurnLightRed()
				end
			end)
		end

		if DoorMode == 1 then
			if self:IsSpotlightMounted() then
				self:ResetSequence("Door_Open_Half")
				self.closeSequence = "Door_Closed_Half"

				local bonePos = self:GetBonePosition(self:LookupBone("LAAT"))
				local doorData = self.Doors["L_Door2"]
				local offset = self:GetRight() * doorData.openoffsethalf.x + self:GetForward() * doorData.openoffsethalf.y + self:GetUp() * doorData.openoffsethalf.z
				doorData.ent:SetParent(nil)
				doorData.ent:SetPos(bonePos + offset)
				doorData.ent:SetParent(self)

				local doorData = self.Doors["R_Door2"]
				local offset = self:GetRight() * doorData.openoffsethalf.x + self:GetForward() * doorData.openoffsethalf.y + self:GetUp() * doorData.openoffsethalf.z
				doorData.ent:SetParent(nil)
				doorData.ent:SetPos(bonePos + offset)
				doorData.ent:SetParent(self)

				self.DoorsToClose = {
					["L_Door2"] = true,
					["R_Door2"] = true,
				}
			else
				self:ResetSequence("Door_Open_Both")
				self.closeSequence = "Door_Closed_Both"

				local bonePos = self:GetBonePosition(self:LookupBone("LAAT"))

				local doorData = self.Doors["L_Door2"]
				local offset = self:GetRight() * doorData.openoffsetboth.x + self:GetForward() * doorData.openoffsetboth.y + self:GetUp() * doorData.openoffsetboth.z
				doorData.ent:SetParent(nil)
				doorData.ent:SetPos(bonePos + offset)
				doorData.ent:SetParent(self)

				local doorData = self.Doors["L_Door1"]
				local offset = self:GetRight() * doorData.openoffsetboth.x + self:GetForward() * doorData.openoffsetboth.y + self:GetUp() * doorData.openoffsetboth.z
				doorData.ent:SetParent(nil)
				doorData.ent:SetPos(bonePos + offset)
				doorData.ent:SetParent(self)

				local doorData = self.Doors["R_Door2"]
				local offset = self:GetRight() * doorData.openoffsetboth.x + self:GetForward() * doorData.openoffsetboth.y + self:GetUp() * doorData.openoffsetboth.z
				doorData.ent:SetParent(nil)
				doorData.ent:SetPos(bonePos + offset)
				doorData.ent:SetParent(self)

				local doorData = self.Doors["R_Door1"]
				local offset = self:GetRight() * doorData.openoffsetboth.x + self:GetForward() * doorData.openoffsetboth.y + self:GetUp() * doorData.openoffsetboth.z
				doorData.ent:SetParent(nil)
				doorData.ent:SetPos(bonePos + offset)
				doorData.ent:SetParent(self)

				self.DoorsToClose = {
					["L_Door2"] = true,
					["L_Door1"] = true,
					["R_Door2"] = true,
					["R_Door1"] = true,
				}
			end

			self:EmitSound("laat_bf2/door_open.mp3")

			self:TurnLightGreen()
		end

		ent:OnDoorsChanged()
	end
	self:AddWeapon(weapon)

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/gunship_reardoor.png")
	weapon.Ammo = -1
	weapon.Delay = 0
	weapon.HeatRateUp = 0
	weapon.HeatRateDown = 0
	weapon.StartAttack = function(ent)
		if ent.NextDoor and ent.NextDoor > CurTime() then return end
		ent.NextDoor = CurTime() + 2

		self:ToggleHatch()
	end

	self:AddWeapon(weapon)

	-- Rear Gun
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/hmg.png")
	weapon.Delay = 0.2
	weapon.HeatRateUp = 0.1
	weapon.HeatRateDown = 0.2
	weapon.Attack = function(ent)
		if not self:CanFireRearGun(ent) then return end

		local trace = ent:GetEyeTrace()
		local Muzzle = self:GetBonePosition(self:LookupBone("Rear_Gun_End"))

		local bullet = {}
		bullet.Src = Muzzle
		bullet.Dir = (trace.HitPos - Muzzle):GetNormalized()
		bullet.Spread = Vector(0.03,  0.03, 0.03)
		bullet.TracerName = "lvs_laser_green"
		bullet.Force = 10
		bullet.HullSize = 25
		bullet.Damage = 195
		bullet.Velocity = 30000
		bullet.Attacker = ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
			effectdata:SetStart(Vector(100, 0, 0))
			effectdata:SetOrigin(tr.HitPos)
			effectdata:SetNormal(tr.HitNormal)
			util.Effect("lvs_laser_impact", effectdata)
		end
		ent:LVSFireBullet( bullet )

		self.SNDTail:PlayOnce(100 + math.cos( CurTime() + self:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1)
	end
	weapon.OnOverheat = function(ent)
		ent:EmitSound("lvs/overheat.wav")
	end
	weapon.OnThink = function(ent, active)
		if not self:CanFireRearGun(ent) then
			self:SetPoseParameter("back_turret_z", 0)
			self:SetPoseParameter("back_turret_y", 0)
			return
		end

		local trace = ent:GetEyeTrace()
		local _, Ang = WorldToLocal(Vector(0,0,0), (trace.HitPos - self:LocalToWorld( Vector(-400,0,158.5))):GetNormalized():Angle(), Vector(0,0,0), self:LocalToWorldAngles(Angle(0,180,0)))

		self:SetPoseParameter("back_turret_z", Ang.p)
		self:SetPoseParameter("back_turret_y", -Ang.y)
	end
	weapon.CalcView = function(ent, ply, pos, angles, fov, pod)
		return self:GunnerCalcView(ent, ply, pos, angles, fov, pod)
	end
	self:AddWeapon(weapon, 2)

	-- Bacta bomb
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/bomb_heal.png")
	weapon.Ammo = 12
	weapon.Delay = 0
	weapon.HeatRateUp = -1
	weapon.Attack = function(ent)
		if ent.NextBomb and ent.NextBomb > CurTime() then return end
		ent.NextBomb = CurTime() + 2
		local base = ent:GetVehicle()
		if not IsValid(base) then return end

		local pos = base:GetBonePosition(base:LookupBone("Rear_Bomb_Hatch"))

		local bomb = ents.Create("laat_bactabomb")
		bomb:SetPos(pos)
		bomb:SetAngles(self:GetAngles())
		bomb:Spawn()
		bomb:Activate()
		bomb.Attacker = self:GetDriver()
		bomb.Inflictor = self
		bomb:SetVelocity(self:GetVelocity())

		ent:TakeAmmo()

		constraint.NoCollide(ent, base, 0, 0)
	end
	weapon.OnOverheat = function(ent)
		ent:EmitSound("lvs/overheat.wav")
	end
	weapon.CalcView = function(ent, ply, pos, angles, fov, pod)
		return self:GunnerCalcView(ent, ply, pos, angles, fov, pod)
	end
	self:AddWeapon(weapon, 2)

	-- Symoxin bomb
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/bomb_stun.png")
	weapon.Ammo = 8
	weapon.Delay = 0
	weapon.HeatRateUp = -1
	weapon.Attack = function(ent)
		if ent.NextBomb and ent.NextBomb > CurTime() then return end
		ent.NextBomb = CurTime() + 2
		local base = ent:GetVehicle()
		if not IsValid(base) then return end

		local pos = base:GetBonePosition(base:LookupBone("Rear_Bomb_Hatch"))

		local bomb = ents.Create("laat_symoxinbomb")
		bomb:SetPos(pos)
		bomb:SetAngles(self:GetAngles())
		bomb:Spawn()
		bomb:Activate()
		bomb.Attacker = self:GetDriver()
		bomb.Inflictor = self
		bomb:SetVelocity(self:GetVelocity())

		ent:TakeAmmo()

		constraint.NoCollide(ent, base, 0, 0)
	end
	weapon.OnOverheat = function(ent)
		ent:EmitSound("lvs/overheat.wav")
	end
	weapon.CalcView = function(ent, ply, pos, angles, fov, pod)
		return self:GunnerCalcView(ent, ply, pos, angles, fov, pod)
	end
	self:AddWeapon(weapon, 2)

	-- Dioxis bomb
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/bomb_poison.png")
	weapon.Ammo = 4
	weapon.Delay = 0
	weapon.HeatRateUp = -1
	weapon.Attack = function(ent)
		if ent.NextBomb and ent.NextBomb > CurTime() then return end
		ent.NextBomb = CurTime() + 2
		local base = ent:GetVehicle()
		if not IsValid(base) then return end

		local pos = base:GetBonePosition(base:LookupBone("Rear_Bomb_Hatch"))

		local bomb = ents.Create("laat_dioxisbomb")
		bomb:SetPos(pos)
		bomb:SetAngles(self:GetAngles())
		bomb:Spawn()
		bomb:Activate()
		bomb.Attacker = self:GetDriver()
		bomb.Inflictor = self
		bomb:SetVelocity(self:GetVelocity())

		ent:TakeAmmo()

		constraint.NoCollide(ent, base, 0, 0)
	end
	weapon.OnOverheat = function(ent)
		ent:EmitSound("lvs/overheat.wav")
	end
	weapon.CalcView = function(ent, ply, pos, angles, fov, pod)
		return self:GunnerCalcView(ent, ply, pos, angles, fov, pod)
	end
	self:AddWeapon(weapon, 2)
end
--addons/egm_lvs_ships/lua/entities/lvs_starfighter_arc/shared.lua:

ENT.Base = "lvs_base_starfighter"

ENT.PrintName = "ARC-170"
ENT.Author = "Deltaa"
ENT.Information = "Heavy-Duty Starfighter of the Galactic Republic"
ENT.Category = "[LVS] - Republik"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/sdog/arc170ch.mdl"
ENT.AITEAM = 2

ENT.MaxVelocity = 750
ENT.MaxThrust = 750

ENT.ThrustVtol = 55
ENT.ThrustRateVtol = 3

ENT.TurnRatePitch = 1
ENT.TurnRateYaw = 1
ENT.TurnRateRoll = 1

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1
ENT.ForceAngleDampingMultiplier = 1

ENT.MaxHealth = 13500
ENT.MaxShield = 4500

function ENT:OnSetupDataTables()
	self:AddDT( "Bool", "Foils" )
	self:AddDT( "Bool", "Wings" )
	self:AddDT( "Entity", "TailGunnerSeat" )

	if SERVER then
		self:NetworkVarNotify("Foils", self.OnFoilsChanged)
	end
end

function ENT:InitWeapons()
	self.FirePositions = {
		Vector(220, 328, -53),
		Vector(220, -328, -53)
	}

	-- Primary Gun
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/hmg.png")
	weapon.Delay = 0.15
	weapon.HeatRateUp = 0.1
	weapon.HeatRateDown = 0.25
	weapon.Attack = function(ent)
		ent.NumPrim = ent.NumPrim and ent.NumPrim + 1 or 1
		if ent.NumPrim > #ent.FirePositions then ent.NumPrim = 1 end

		if not ent:GetWings() then
			ent:SetHeat(ent:GetHeat() + 0.5)
		end

		local pod = ent:GetDriverSeat()
		if not IsValid(pod) then return end

		local startpos = pod:LocalToWorld( pod:OBBCenter() )
		local trace = util.TraceHull( {
			start = startpos,
			endpos = startpos + ent:GetForward() * 50000,
			mins = Vector( -10, -10, -10 ),
			maxs = Vector( 10, 10, 10 ),
			filter = ent:GetCrosshairFilterEnts()
		})

		local CurPos = ent.FirePositions[ent.NumPrim]

		local bullet = {}
		bullet.Src = ent:LocalToWorld(CurPos)
		bullet.Dir = (trace.HitPos - bullet.Src):GetNormalized()
		bullet.Spread = Vector( 0.025,  0.025, 0 )
		bullet.TracerName = "lvs_laser_green"
		bullet.Force = 100
		bullet.HullSize = 25
		bullet.Damage = 1800
		bullet.Velocity = 50000
		bullet.Attacker = ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
			effectdata:SetStart( Vector(0,255,0))
			effectdata:SetOrigin(tr.HitPos)
			util.Effect( "lvs_laser_explosion", effectdata)
		end
		ent:LVSFireBullet( bullet )

		local effectdata = EffectData()
		effectdata:SetStart(Vector(50, 255, 50))
		effectdata:SetOrigin(bullet.Src)
		effectdata:SetNormal(ent:GetForward())
		effectdata:SetEntity(ent)
		util.Effect("lvs_muzzle_colorable", effectdata)

		ent:TakeAmmo()

		if CurPos.y > 0 then
			ent.SNDLeft:PlayOnce(100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1)
		else
			ent.SNDRight:PlayOnce(100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1)
		end
	end
	weapon.OnSelect = function( ent )
		ent:EmitSound("physics/metal/weapon_impact_soft3.wav")
	end
	weapon.OnOverheat = function(ent)
		ent:EmitSound("lvs/overheat.wav")
	end
	self:AddWeapon( weapon )

	-- Proton Torpedo
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/protontorpedo.png")
	weapon.Ammo = 12
	weapon.Delay = 3
	weapon.HeatRateUp = -0.5
	weapon.HeatRateDown = 0.25
	weapon.Attack = function( ent )
		if IsValid(ent._ProtonTorpedo) then
			if ent._nextMissleTracking and ent._nextMissleTracking > CurTime() then return end
			ent._nextMissleTracking = CurTime() + 0.1

			ent._ProtonTorpedo:FindTarget( ent:GetPos(), ent:GetForward(), 30, 7500 )
			return
		end

		if ent._nextMissle and ent._nextMissle > CurTime() then return end
		ent._nextMissle = CurTime() + 0.5

		ent._swapMissile = not ent._swapMissile

		local Pos = Vector(90, ent._swapMissile and -304 or 304, -32)

		local Driver = self:GetDriver()

		local projectile = ents.Create( "lvs_protontorpedo" )
		projectile:SetPos( ent:LocalToWorld( Pos ) )
		projectile:SetAngles( ent:LocalToWorldAngles( Angle(0,ent._swapMissile and 2 or -2,0) ) )
		projectile:SetParent( ent )
		projectile:Spawn()
		projectile:Activate()
		projectile:SetAttacker( IsValid( Driver ) and Driver or self )
		projectile:SetDamage(8000)
		projectile:SetEntityFilter( ent:GetCrosshairFilterEnts() )
		projectile:SetSpeed( ent:GetVelocity():Length() + 4000 )

		ent._ProtonTorpedo = projectile

		ent:SetNextAttack( CurTime() + 0.1 ) -- wait 0.1 second before starting to track
	end
	weapon.FinishAttack = function( ent )
		if not IsValid(ent._ProtonTorpedo) then return end

		local projectile = ent._ProtonTorpedo
		projectile:Enable()
		projectile:EmitSound( "lvs/vehicles/naboo_n1_starfighter/proton_fire.mp3", 125 )
		ent:TakeAmmo()

		ent._ProtonTorpedo = nil

		local NewHeat = ent:GetHeat() + 0.75
		if NewHeat >= 1 then
			ent:SetOverheated( true )
		end

		ent:SetHeat(NewHeat)
	end
	weapon.OnSelect = function(ent)
		ent:EmitSound("physics/metal/weapon_impact_soft3.wav")
	end
	weapon.OnOverheat = function(ent)
		ent:EmitSound("lvs/overheat.wav")
	end
	self:AddWeapon( weapon )

	-- Gunner Gun
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/hmg.png")
	weapon.Delay = 0.15
	weapon.Attack = function( ent )
		local pod = ent:GetDriverSeat()
		if not IsValid(pod) then return end

		local dir = ent:GetAimVector()
		if ent:AngleBetweenNormal(dir, ent:GetForward() ) > 60 then return true end

		local trace = ent:GetEyeTrace()

		ent.SwapTopBottom = not ent.SwapTopBottom

		local veh = ent:GetVehicle()
		veh.SNDTail:PlayOnce(100 + math.Rand(-3,3), 1)

		local bullet = {}
		bullet.Src = veh:LocalToWorld(ent.SwapTopBottom and Vector(-175, 0, 60) or Vector(-171, 0, 6) )
		bullet.Dir = (trace.HitPos - bullet.Src):GetNormalized()
		bullet.Spread = Vector(0.005, 0.005, 0)
		bullet.TracerName = "lvs_laser_green"
		bullet.Force = 100
		bullet.HullSize = 20
		bullet.Damage = 1500
		bullet.Velocity = 30000
		bullet.Attacker = ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
			effectdata:SetStart(Vector(50, 255, 50))
			effectdata:SetOrigin(tr.HitPos)
			effectdata:SetNormal(tr.HitNormal )
			util.Effect( "lvs_laser_impact", effectdata )
		end
		ent:LVSFireBullet( bullet )
	end
	weapon.OnSelect = function( ent )
		ent:EmitSound("physics/metal/weapon_impact_soft3.wav")
	end
	weapon.OnOverheat = function( ent )
		ent:EmitSound("lvs/overheat.wav")
	end
	self:AddWeapon(weapon, 3)

	-- Switches the wings
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/arcwings.png")
	weapon.Ammo = -1
	weapon.Delay = 0
	weapon.HeatRateUp = 0
	weapon.HeatRateDown = 0
	weapon.StartAttack = function( ent )
		if ent:GetAI() then return end

		if (ent.NextWing or 0) > CurTime() then return end
		ent.NextWing = CurTime() + 1

		ent:SetWings(not ent:GetWings())
	end
	self:AddWeapon( weapon )

	-- Turbo Mode
	self:AddWeapon(LVS:GetWeaponPreset("TURBO"))
end

ENT.FlyByAdvance = 0.5
ENT.FlyBySound = "lvs/vehicles/arc170/flyby.wav"
ENT.DeathSound = "lvs/vehicles/generic_starfighter/crash.wav"

ENT.EngineSounds = {
	{
		sound = "lvs/vehicles/arc170/loop.wav",
		Pitch = 80,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 40,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
	},
}
--addons/egm_lvs_ships/lua/entities/lvs_starfighter_delta7b/cl_init.lua:
include("shared.lua")

ENT.EngineGlow = Material("sprites/light_glow02_add")

function ENT:OnSpawn()
	self:RegisterTrail(Vector(-100, 20, 10), 0, 20, 2, 1000, 150)
	self:RegisterTrail(Vector(-100, -20, 10), 0, 20, 2, 1000, 150)
end

function ENT:OnFrame()
	self:AnimAstromech()
end

function ENT:PostDrawTranslucent()
	if not self:GetEngineActive() then return end

	local Size = 120 + self:GetThrottle() * 40 + self:GetBoost() * 0.8
	render.SetMaterial(self.EngineGlow)
	render.DrawSprite(self:LocalToWorld( Vector(-130,-21,23.2) ), Size, Size, Color( 255, 240, 130, 255))
	render.DrawSprite(self:LocalToWorld( Vector(-130,21,23.2) ), Size, Size, Color( 255, 240, 130, 255))
	render.DrawSprite(self:LocalToWorld( Vector(-130,-21,23.2) ), Size, Size, Color( 255, 240, 150, 255))
	render.DrawSprite(self:LocalToWorld( Vector(-130,21,23.2) ), Size, Size, Color( 255, 240, 150, 255))
end

function ENT:AnimAstromech()
	local T = CurTime()

	if (self.nextAstro or 0) < T then
		self.nextAstro = T + math.Rand(0.5,2)
		self.AstroAng = math.Rand(-180,180)

		local HasShield = self:GetShield() > 0

		if self.OldShield == true and not HasShield then
			self:EmitSound("lvs/vehicles/naboo_n1_starfighter/astromech/shieldsdown" .. math.random(1,2) .. ".ogg", 50)
		else
			if math.random(0, 4) == 3 then
				self:EmitSound("lvs/vehicles/naboo_n1_starfighter/astromech/"..math.random(1,11) .. ".ogg", 50)
			end
		end

		self.OldShield = HasShield
	end

	self.smastro = self.smastro and (self.smastro + ((self.AstroAng or 0) - self.smastro) * RealFrameTime() * 10) or 0

	self:ManipulateBoneAngles(1, Angle(self.smastro, 0, 0))
end

function ENT:OnStartBoost()
	self:EmitSound("lvs/vehicles/delta-7/boost.wav", 85)
end
--addons/egm_lvs_ships/lua/entities/lvs_starfighter_firespray/shared.lua:
ENT.Base = "lvs_base_starfighter"

ENT.PrintName = "Firespray 31"
ENT.Author = "Miller & Deltaa"
ENT.Information = "The Firespray-31-class patrol and attack craft was a patrol ship"
ENT.Category = "[LVS] - Neutral"

ENT.Spawnable = true
ENT.AdminSpawnable = false

ENT.MDL = "models/firespray/firespray1.mdl"

ENT.AITEAM = 0

ENT.MaxVelocity = 2000
ENT.MaxThrust = 2000

ENT.ThrustVtol = 55
ENT.ThrustRateVtol = 3

ENT.TurnRatePitch = 0.7
ENT.TurnRateYaw = 0.7
ENT.TurnRateRoll = 0.7

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1.3
ENT.ForceAngleDampingMultiplier = 1

ENT.MaxHealth = 19000
ENT.MaxShield = 4500

function ENT:OnSetupDataTables()
	self:AddDT( "Bool", "Foils" )

	if SERVER then
		self:NetworkVarNotify("Foils", self.OnFoilsChanged)
	end
end

function ENT:InitWeapons()
	self.FirePositions = {
		{
			Vector(55, 37, 72),
			Vector(55, 37, 67)
		},

		{
			Vector(55, -37, 72),
			Vector(55, -37, 67)
		}
	}

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/hmg.png")
	weapon.Delay = 0.2
	weapon.HeatRateUp = 0.1
	weapon.HeatRateDown = 0.25
	weapon.Attack = function(ent)
		ent.NumPrim = ent.NumPrim and ent.NumPrim + 1 or 1
		if ent.NumPrim > #ent.FirePositions then ent.NumPrim = 1 end

		if not self:GetFoils() then return end

		local pod = ent:GetDriverSeat()
		if not IsValid(pod) then return end

		local startpos =  pod:LocalToWorld(pod:OBBCenter())
		local trace = util.TraceHull({
			start = startpos,
			endpos = startpos + ent:GetForward() * 50000,
			mins = Vector(-10, -10, -10),
			maxs = Vector(10, 10, 10),
			filter = ent:GetCrosshairFilterEnts()
		})

		local CurPos = ent.FirePositions[ent.NumPrim]

		for _, pos in pairs(CurPos) do
			local bullet = {}
			bullet.Src = ent:LocalToWorld(pos)
			bullet.Dir = (trace.HitPos - bullet.Src):GetNormalized()
			bullet.Spread = Vector(0.01, 0.01, 0)
			bullet.Tracer = 1
			bullet.TracerName = "lvs_laser_red"
			bullet.Force = 100
			bullet.HullSize = 10
			bullet.Damage = 600
			bullet.Attacker = ent:GetDriver()
			bullet.Velocity = 60000
			bullet.Callback = function(att, tr, dmginfo)
				local effectdata = EffectData()
				effectdata:SetStart(Vector(255, 50, 0))
				effectdata:SetOrigin(tr.HitPos)
				effectdata:SetNormal(tr.HitNormal)
				util.Effect("lvs_laser_impact", effectdata )
			end
			ent:LVSFireBullet(bullet)
		end

		if ent.NumPrim == 1 then
			ent.SNDLeft:PlayOnce(100 + math.cos( CurTime() + ent:EntIndex() * 1337) * 5 + math.Rand(-1,1), 1)
		else
			ent.SNDRight:PlayOnce(100 + math.cos( CurTime() + ent:EntIndex() * 1337) * 5 + math.Rand(-1,1), 1)
		end
	end
	weapon.OnSelect = function(ent)
		ent:EmitSound("physics/metal/weapon_impact_soft3.wav")
	end
	weapon.OnOverheat = function(ent)
		ent:EmitSound("lvs/overheat.wav")
	end
    self:AddWeapon(weapon)

	-- Rocket Weapon

    local weapon = {}
     weapon.Icon = Material("lvs/weapons/missile.png")
     weapon.Ammo = 12
     weapon.Delay = 0.1
     weapon.HeatRateUp = 0.1
     weapon.HeatRateDown = 0.05
     weapon.Attack = function( ent )
    local FirePos = {
		[1] = self:GetPos() + self:GetForward() * 0 + self:GetUp() * 9 + self:GetRight() * 330,
		[2] = self:GetPos() + self:GetForward() * 0 + self:GetUp() * 9 + self:GetRight() * -330,
	}

	self.FireIndex = self.FireIndex and self.FireIndex + 1 or 1

	if self.FireIndex > 2 then
		self.FireIndex = 1
	elseif self.FireIndex == 2 then
		ent:SetHeat(1)
		ent:SetOverheated(true)
	end

	self:EmitSound("lvs/vehicles/scimitar/missile.wav")

	local Pos = FirePos[self.FireIndex]

	local projectile = ents.Create("lvs_concussionmissile")
	projectile:SetPos(Pos)
	projectile:SetAngles(self:GetAngles())
	projectile:SetParent(ent)
	projectile:Spawn()
	projectile:Activate()
	projectile.GetTarget = function(missile) return missile end
	projectile.GetTargetPos = function(missile)
		return missile:LocalToWorld(Vector(150, 0, 0) + VectorRand() * math.random(-5, 5))
	end
	projectile:SetAttacker(self)
	projectile:SetEntityFilter(ent:GetCrosshairFilterEnts())
	projectile:SetSpeed(2500)
	projectile:SetDamage(3000)
	projectile:Enable()

	ent:TakeAmmo()
end
weapon.OnSelect = function( ent )
	ent:EmitSound("weapons/shotgun/shotgun_cock.wav")
end
self:AddWeapon(weapon)

    -- Turbo Mode
	self:AddWeapon(LVS:GetWeaponPreset("TURBO"))
end

ENT.FlyByAdvance = 0.5
ENT.FlyBySound = "lvs/vehicles/delta-7/flyby.wav"
ENT.DeathSound = "lvs/vehicles/generic_starfighter/crash.wav"

ENT.EngineSounds = {
	{
		sound = "lvs/vehicles/firespray/engine.wav",
		sound_int = "^lvs/vehicles/firespray/engine.wav",
		Pitch = 80,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 40,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
	},
}

--addons/egm_lvs_ships/lua/entities/lvs_starfighter_hyenabomber/cl_init.lua:
include("shared.lua")

ENT.EngineGlow = Material( "sprites/light_glow02_add" )
ENT.EngineColor = Color(255, 0, 0)
ENT.EngineColor2 = Color(38, 0, 230)

function ENT:OnSpawn()
	self:RegisterTrail(Vector(-195, 164, -50), 2, 20, 10, 1000, 150)
	self:RegisterTrail(Vector(-195, -164, -50), 2, 20, 10, 1000, 150)
	self:RegisterTrail(Vector(-250, 165, -90), 2, 20, 10, 1000, 150)
	self:RegisterTrail(Vector(-250, -165, -90), 2, 20, 10, 1000, 150)
end

function ENT:OnFrame()
end

function ENT:PostDrawTranslucent()
	if not self:GetEngineActive() then return end

	cam.Start3D2D(self:LocalToWorld(Vector(9,-119,-68.86)), self:LocalToWorldAngles(Angle(0,295,90)), 1.67)
		draw.NoTexture()
		surface.SetDrawColor(color_white)
		surface.DrawTexturedRectRotated(-11, -1.5, 19.7, 6, -3.4)
		surface.DrawTexturedRectRotated(-11, 1.5, 19.7, 6, 3.4)
	cam.End3D2D()

	cam.Start3D2D(self:LocalToWorld(Vector(9, 118, -68.86)), self:LocalToWorldAngles(Angle(0, 65, -90)), 1.65)
		draw.NoTexture()
		surface.SetDrawColor(color_white)
		surface.DrawTexturedRectRotated(-11, -1.5, 19.7, 6 , -3.4)
		surface.DrawTexturedRectRotated(-11, 1.5, 19.7, 6 , 3.4)
	cam.End3D2D()

	if not istable(self.FxPos) then
		self.FxPos = {
			Vector(2, 112.02, -65.62),
			Vector(-1.3, 105.54, -65.69),
			Vector(-4.59, 99.56, -65.74),
			Vector(-7.04, 93.32, -65.44),
			Vector(3.26, 111.68, -72.02),
			Vector(-0.96, 105.53, -71.91),
			Vector(-4.05, 99.4, -71.94),
			Vector(-6.5, 93.15, -71.93),
			Vector(-6.08, -93.34, -65.64),
			Vector(-3.24, -99.63, -65.7),
			Vector(-0.66, -105.62, -65.77),
			Vector(2.11, -111.75, -65.63),
			Vector(-6.8, -93.49, -72.11),
			Vector(-3.27, -99.57, -72.07),
			Vector(0.95, -105.68, -72.05),
			Vector(-6.77, 88.66, -65.53),
			Vector(-6.64, 88.74, -72.2),
			Vector(-7.94, -88.69, -65.27),
			Vector(-7.72, -88.74, -72.08),
		}
	end

	local Size = 30 + self:GetThrottle() * 15 + self:GetBoost() * 0.8

	for _, v in pairs(self.FxPos) do
		local pos = self:LocalToWorld(v)
		render.SetMaterial(self.EngineGlow)
		render.DrawSprite(pos, Size, Size, self.EngineColor2)
	end

	if self:GetEngineActive() then
		-- Eyes 1
		render.SetMaterial(self.EngineGlow)
		render.DrawSprite(self:LocalToWorld(Vector(-4.24,-32.63,-33.78)), Size, Size, self.EngineColor)
		render.DrawSprite(self:LocalToWorld(Vector(-1.36,-32.44,-34.23)), Size, Size, self.EngineColor)
		render.DrawSprite(self:LocalToWorld(Vector(1.25,-32.47,-34.87)), Size, Size, self.EngineColor)
		render.DrawSprite(self:LocalToWorld(Vector(3.88,-32.44,-35.81)), Size, Size, self.EngineColor)
		render.DrawSprite(self:LocalToWorld(Vector(6.37,-32.42,-36.6)), Size, Size, self.EngineColor)
		render.DrawSprite(self:LocalToWorld(Vector(8.71,-32.32,-37.31)), Size, Size, self.EngineColor)
		render.DrawSprite(self:LocalToWorld(Vector(10.92,-32.38,-38.06)), Size, Size, self.EngineColor)
		render.DrawSprite(self:LocalToWorld(Vector(13.15,-32.34,-39.08)), Size, Size, self.EngineColor)
		render.DrawSprite(self:LocalToWorld(Vector(15.76,-32.34,-39.95)), Size, Size, self.EngineColor)
		render.DrawSprite(self:LocalToWorld(Vector(17.98,-32.22,-40.91)), Size, Size, self.EngineColor)
		render.DrawSprite(self:LocalToWorld(Vector(20.44,-32.24,-41.73)), Size, Size, self.EngineColor)
		render.DrawSprite(self:LocalToWorld(Vector(22.99,-32.26,-42.67)), Size, Size, self.EngineColor)
		render.DrawSprite(self:LocalToWorld(Vector(25.08,-32.25,-43.52)), Size, Size, self.EngineColor)
		render.DrawSprite(self:LocalToWorld(Vector(27.65,-32.25,-44.66)), Size, Size, self.EngineColor)
		render.DrawSprite(self:LocalToWorld(Vector(29.85,-32.33,-45.62)), Size, Size, self.EngineColor)
		render.DrawSprite(self:LocalToWorld(Vector(32.4,-32.27,-46.81)), Size, Size, self.EngineColor)
		render.DrawSprite(self:LocalToWorld(Vector(35.06,-32.34,-48.03)), Size, Size, self.EngineColor)
		render.DrawSprite(self:LocalToWorld(Vector(37.47,-32.41,-49.31)), Size, Size, self.EngineColor)
		render.DrawSprite(self:LocalToWorld(Vector(40.04,-32.43,-50.77)), Size, Size, self.EngineColor)
		render.DrawSprite(self:LocalToWorld(Vector(42.42,-32.43,-52.07)), Size, Size, self.EngineColor)
		render.DrawSprite(self:LocalToWorld(Vector(44.13,-32.19,-53.15)), Size, Size, self.EngineColor)
		render.DrawSprite(self:LocalToWorld(Vector(45.71,-32.17,-53.9)), Size, Size, self.EngineColor)

		render.DrawSprite(self:LocalToWorld(Vector(21.45,-28.53,-43.97)), Size, Size, self.EngineColor)
		render.DrawSprite(self:LocalToWorld(Vector(20.25,-30.31,-42.29)), Size, Size, self.EngineColor)
		render.DrawSprite(self:LocalToWorld(Vector(24.31,-28.89,-44.85)), Size, Size, self.EngineColor)
		render.DrawSprite(self:LocalToWorld(Vector(27.2,-29.47,-45.88)), Size, Size, self.EngineColor)
		render.DrawSprite(self:LocalToWorld(Vector(29.85,-29.61,-46.92)), Size, Size, self.EngineColor)
		render.DrawSprite(self:LocalToWorld(Vector(32.38,-30.04,-47.82)), Size, Size, self.EngineColor)
		render.DrawSprite(self:LocalToWorld(Vector(34.57,-30.28,-48.56)), Size, Size, self.EngineColor)
		render.DrawSprite(self:LocalToWorld(Vector(36.78,-30.71,-49.7)), Size, Size, self.EngineColor)
		render.DrawSprite(self:LocalToWorld(Vector(39.04,-31.04,-50.84)), Size, Size, self.EngineColor)
		render.DrawSprite(self:LocalToWorld(Vector(40.89,-31.45,-51.53)), Size, Size, self.EngineColor)
		render.DrawSprite(self:LocalToWorld(Vector(22.34,-30.52,-43.15)), Size, Size, self.EngineColor)
		render.DrawSprite(self:LocalToWorld(Vector(25.11,-30.59,-44.32)), Size, Size, self.EngineColor)
		render.DrawSprite(self:LocalToWorld(Vector(26.99,-30.71,-45.05)), Size, Size, self.EngineColor)
		render.DrawSprite(self:LocalToWorld(Vector(29.72,-30.86,-46.12)), Size, Size, self.EngineColor)

		-- Eyes 2
		render.DrawSprite(self:LocalToWorld(Vector(-4.24,-42.63,-33.78)), Size, Size, self.EngineColor)
		render.DrawSprite(self:LocalToWorld(Vector(-1.36,-42.73,-34.23)), Size, Size, self.EngineColor)
		render.DrawSprite(self:LocalToWorld(Vector(1.25,-42.83,-34.87)), Size, Size, self.EngineColor)
		render.DrawSprite(self:LocalToWorld(Vector(3.88,-42.83,-35.81)), Size, Size, self.EngineColor)
		render.DrawSprite(self:LocalToWorld(Vector(6.37,-42.83,-36.6)), Size, Size, self.EngineColor)
		render.DrawSprite(self:LocalToWorld(Vector(8.71,-42.83,-37.31)), Size, Size, self.EngineColor)
		render.DrawSprite(self:LocalToWorld(Vector(10.92,-42.83,-38.06)), Size, Size, self.EngineColor)
		render.DrawSprite(self:LocalToWorld(Vector(13.15,-42.83,-39.08)), Size, Size, self.EngineColor)
		render.DrawSprite(self:LocalToWorld(Vector(15.76,-42.83,-39.95)), Size, Size, self.EngineColor)
		render.DrawSprite(self:LocalToWorld(Vector(17.98,-43,-40.91)), Size, Size, self.EngineColor)
		render.DrawSprite(self:LocalToWorld(Vector(20.44,-43,-41.73)), Size, Size, self.EngineColor)
		render.DrawSprite(self:LocalToWorld(Vector(22.99,-43,-42.67)), Size, Size, self.EngineColor)
		render.DrawSprite(self:LocalToWorld(Vector(25.08,-43,-43.52)), Size, Size, self.EngineColor)
		render.DrawSprite(self:LocalToWorld(Vector(27.65,-43,-44.66)), Size, Size, self.EngineColor)
		render.DrawSprite(self:LocalToWorld(Vector(29.85,-43,-45.62)), Size, Size, self.EngineColor)
		render.DrawSprite(self:LocalToWorld(Vector(32.4,-43,-46.81)), Size, Size, self.EngineColor)
		render.DrawSprite(self:LocalToWorld(Vector(35.06,-43,-48.03)), Size, Size, self.EngineColor)
		render.DrawSprite(self:LocalToWorld(Vector(37.47,-43,-49.31)), Size, Size, self.EngineColor)
		render.DrawSprite(self:LocalToWorld(Vector(40.04,-43,-50.77)), Size, Size, self.EngineColor)
		render.DrawSprite(self:LocalToWorld(Vector(42.42,-43,-52.07)), Size, Size, self.EngineColor)
		render.DrawSprite(self:LocalToWorld(Vector(44.13,-43,-53.15)), Size, Size, self.EngineColor)
		render.DrawSprite(self:LocalToWorld(Vector(45.71,-43,-53.9)), Size, Size, self.EngineColor)
		render.DrawSprite(self:LocalToWorld(Vector(21.45,-46.7,-43.97)), Size, Size, self.EngineColor)
		render.DrawSprite(self:LocalToWorld(Vector(20.25,-45.31,-42.29)), Size, Size, self.EngineColor)
		render.DrawSprite(self:LocalToWorld(Vector(24.31,-46.4,-44.85)), Size, Size, self.EngineColor)
		render.DrawSprite(self:LocalToWorld(Vector(27.2,-46,-45.88)), Size, Size, self.EngineColor)
		render.DrawSprite(self:LocalToWorld(Vector(29.85,-45.7,-46.92)), Size, Size, self.EngineColor)
		render.DrawSprite(self:LocalToWorld(Vector(32.38,-45.3,-47.82)), Size, Size, self.EngineColor)
		render.DrawSprite(self:LocalToWorld(Vector(34.57,-45,-48.56)), Size, Size, self.EngineColor)
		render.DrawSprite(self:LocalToWorld(Vector(36.78,-44.7,-49.7)), Size, Size, self.EngineColor)
		render.DrawSprite(self:LocalToWorld(Vector(39.04,-44.4,-50.84)), Size, Size, self.EngineColor)
		render.DrawSprite(self:LocalToWorld(Vector(40.89,-44.3,-51.53)), Size, Size, self.EngineColor)
		render.DrawSprite(self:LocalToWorld(Vector(22.34,-45,-43.15)), Size, Size, self.EngineColor)
		render.DrawSprite(self:LocalToWorld(Vector(25.11,-44.8,-44.32)), Size, Size, self.EngineColor)
		render.DrawSprite(self:LocalToWorld(Vector(26.99,-44.6,-45.05)), Size, Size, self.EngineColor)
		render.DrawSprite(self:LocalToWorld(Vector(29.72,-44.5,-46.12)), Size, Size, self.EngineColor)
	end
end

function ENT:OnStartBoost()
	self:EmitSound("lvs/vehicles/vulture/boost.wav", 85)
end

function ENT:OnStopBoost()
	self:EmitSound("lvs/vehicles/vulture/brake.wav", 85)
end
--addons/egm_lvs_ships/lua/entities/lvs_starfighter_hyenabomber/shared.lua:

ENT.Base = "lvs_base_starfighter"

ENT.PrintName = "Hyena-class Bomber"
ENT.Author = "Deltaa"
ENT.Information = "Droid Starfighter of the Trade Federation"
ENT.Category = "[LVS] - Separatisten"

ENT.Spawnable = true
ENT.AdminSpawnable = false

ENT.MDL = "models/doctor/battlefront/bf2hyena.mdl"

ENT.AITEAM = 1

ENT.MaxVelocity = 2150
ENT.MaxThrust = 2150

ENT.ThrustVtol = 55
ENT.ThrustRateVtol = 3

ENT.TurnRatePitch = 1
ENT.TurnRateYaw = 1
ENT.TurnRateRoll = 1

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1
ENT.ForceAngleDampingMultiplier = 1

ENT.MaxHealth = 15000

function ENT:InitWeapons()
	self.FirePositions = {
		Vector(68, 7, -63),
		Vector(68, -8, -63)
	}

	-- Primary Weapon
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/mg.png")
	weapon.Delay = 0.2
	weapon.HeatRateUp = 0.25
	weapon.HeatRateDown = 1
	weapon.Attack = function( ent )
		ent.NumPrim = ent.NumPrim and ent.NumPrim + 1 or 1
		if ent.NumPrim > #ent.FirePositions then ent.NumPrim = 1 end

		local pod = ent:GetDriverSeat()
		if not IsValid(pod) then return end

		local startpos = pod:LocalToWorld( pod:OBBCenter() )
		local trace = util.TraceHull( {
			start = startpos,
			endpos = startpos + ent:GetForward() * 50000,
			mins = Vector(-10, -10, -10),
			maxs = Vector(10, 10, 10),
			filter = ent:GetCrosshairFilterEnts()
		} )

		local CurPos = ent.FirePositions[ent.NumPrim]

		local bullet = {}
		bullet.Src = ent:LocalToWorld(CurPos)
		bullet.Dir = (trace.HitPos - bullet.Src):GetNormalized()
		bullet.Spread = Vector( 0.02,  0.02, 0 )
		bullet.TracerName = "lvs_laser_red"
		bullet.Force = 100
		bullet.HullSize = 40
		bullet.Damage = 600
		bullet.Velocity = 60000
		bullet.Attacker = ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
			effectdata:SetStart(Vector(255,50,50))
			effectdata:SetOrigin(tr.HitPos)
			effectdata:SetNormal(tr.HitNormal)
			util.Effect("lvs_laser_impact", effectdata)
		end
		ent:LVSFireBullet( bullet )

		local effectdata = EffectData()
		effectdata:SetStart( Vector(255,50,50) )
		effectdata:SetOrigin( bullet.Src )
		effectdata:SetNormal( ent:GetForward() )
		effectdata:SetEntity( ent )
		util.Effect( "lvs_muzzle_colorable", effectdata )

		ent.SNDPrimary:PlayOnce(100 + math.cos(CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1)
	end
	weapon.OnSelect = function(ent)
		ent:EmitSound("physics/metal/weapon_impact_soft3.wav")
	end
	weapon.OnOverheat = function(ent)
		ent:EmitSound("lvs/overheat.wav")
	end
	self:AddWeapon( weapon )

	-- Torpedo Weapon
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/protontorpedo.png")
	weapon.Ammo = 40
	weapon.Delay = 3
	weapon.HeatRateUp = 0.5
	weapon.HeatRateDown = 0.25
	weapon.Attack = function( ent )
		if IsValid(ent._ProtonTorpedo) then
			if ent._nextMissleTracking and ent._nextMissleTracking > CurTime() then return end
			ent._nextMissleTracking = CurTime() + 0.1

			ent._ProtonTorpedo:FindTarget(ent:GetPos(), ent:GetForward(), 30, 7500)
			return
		end

		if ent._nextMissle and ent._nextMissle > CurTime() then return end
		ent._nextMissle = CurTime() + 0.5

		local Driver = self:GetDriver()

		local projectile = ents.Create("lvs_concussionmissile")
		projectile:SetPos(ent:LocalToWorld(Vector(50, 40, -95)))
		projectile:SetAngles(ent:GetAngles())
		projectile:SetParent(ent)
		projectile:Spawn()
		projectile:Activate()
		projectile:SetAttacker(IsValid( Driver ) and Driver or self)
		projectile:SetEntityFilter( ent:GetCrosshairFilterEnts())
		projectile:SetSpeed(ent:GetVelocity():Length() + 4000)

		ent._ProtonTorpedo = projectile

		ent:SetNextAttack(CurTime() + 0.1) -- wait 0.1 second before starting to track
	end
	weapon.FinishAttack = function( ent )
		if not IsValid(ent._ProtonTorpedo) then return end

		local projectile = ent._ProtonTorpedo
		projectile:Enable()
		projectile:EmitSound("lvs/vehicles/vulturedroid/fire_missile.mp3", 125 )
		ent:TakeAmmo()

		ent._ProtonTorpedo = nil

		local NewHeat = ent:GetHeat() + 0.75
		if NewHeat >= 1 then
			ent:SetOverheated( true )
		end

		ent:SetHeat( NewHeat )
	end
	weapon.OnSelect = function(ent)
		ent:EmitSound("physics/metal/weapon_impact_soft3.wav")
	end
	weapon.OnOverheat = function(ent)
		ent:EmitSound("lvs/overheat.wav")
	end
	self:AddWeapon(weapon)

	-- Bombs
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/bomb.png")
	weapon.Ammo = 50
	weapon.Delay = 0.5
	weapon.HeatRateUp = 0.25
	weapon.HeatRateDown = 0.05
	weapon.Attack = function(ent)
		local base = ent:GetVehicle()
		if not IsValid(base) then return end

		local bomb = ents.Create("hyena_bomb")
		bomb:SetPos(self:LocalToWorld(Vector(50, 40, -160)))
		bomb:SetAngles(self:GetAngles())
		bomb:Spawn()
		bomb:Activate()
		bomb.Attacker = self:GetDriver()
		bomb.Inflictor = self
		bomb:SetVelocity(self:GetVelocity())

		ent:TakeAmmo()

		constraint.NoCollide(ent, base, 0, 0)
	end
	weapon.OnOverheat = function(ent)
		ent:EmitSound("lvs/overheat.wav")
	end
	self:AddWeapon(weapon)
end

ENT.FlyByAdvance = 1
ENT.FlyBySound = "lvs/vehicles/hyena/flyby.wav"
ENT.DeathSound = "lvs/vehicles/generic_starfighter/crash.wav"

ENT.EngineSounds = {
	{
		sound = "lvs/vehicles/hyena/engine.wav",
		sound_int = "lvs/vehicles/hyena/engine_int.wav",
		Pitch = 80,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 40,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
	},
}
--addons/egm_lvs_ships/lua/entities/lvs_starfighter_interceptor/cl_init.lua:
include("shared.lua")

ENT.EngineColor = Color(196, 0, 0)
ENT.EngineGlow = Material("sprites/light_glow02_add")
ENT.EnginePos = {
	Vector(-105, 50, 8),
	Vector(-105, -50, 8),
}

function ENT:OnSpawn()
	self:RegisterTrail(Vector(-240, 300, -13), 5, 20, 2, 1000, 150)
	self:RegisterTrail(Vector(-240, -300, -13), 5, 20, 2, 1000, 150)
end

function ENT:EngineEffects()
	if not self:GetEngineActive() then return end

	if self.nextEFX and self.nextEFX > CurTime() then return end
	self.nextEFX = CurTime() + 0.01

	local emitter = self:GetParticleEmitter(self:GetPos())
	if not IsValid(emitter) then return end

	for _, pos in pairs(self.EnginePos) do
		local vOffset = self:LocalToWorld(pos)
		local vNormal = -self:GetForward()

		vOffset = vOffset + vNormal * 5

		local particle = emitter:Add("effects/muzzleflash2", vOffset)

		if not particle then continue end

		particle:SetVelocity(vNormal * (math.Rand(500,1000) + self:GetBoost() * 10) + self:GetVelocity() )
		particle:SetLifeTime(0)
		particle:SetDieTime(0.1)
		particle:SetStartAlpha(255)
		particle:SetEndAlpha(0)
		particle:SetStartSize(math.Rand(15, 25))
		particle:SetEndSize(math.Rand(0, 10))
		particle:SetRoll(math.Rand(-1 ,1) * 100)
		particle:SetColor(196, 0, 0)
	end
end

function ENT:OnFrame()
	self:EngineEffects()
end

function ENT:PostDrawTranslucent()
	if not self:GetEngineActive() then return end

	local Size = 80 + self:GetThrottle() * 120 + self:GetBoost() * 2

	render.SetMaterial(self.EngineGlow)

	for _, pos in pairs(self.EnginePos) do
		render.DrawSprite(self:LocalToWorld(pos), Size, Size, self.EngineColor)
	end
end

function ENT:OnStartBoost()
	self:EmitSound("lvs/vehicles/starchaser/engine_on.wav", 85)
end

function ENT:OnStopBoost()
	self:EmitSound("lvs/vehicles/starchaser/engine_off.wav", 85)
end

--addons/egm_lvs_ships/lua/entities/lvs_starfighter_liberator/cl_init.lua:
include("shared.lua")

ENT.EngineColor = Color(0, 195, 255)
ENT.EngineGlow = Material("sprites/light_glow02_add")
ENT.EnginePos = {
	Vector(-280,66.1,6.31),
	Vector(-280,-66.1,6.31),
}

function ENT:OnSpawn()
	self:RegisterTrail(Vector(-34,326,-13), 0, 20, 2, 1000, 150 )
	self:RegisterTrail(Vector(-34,-326,-13), 0, 20, 2, 1000, 150 )
end

function ENT:EngineEffects()
	if not self:GetEngineActive() then return end

	if self.nextEFX and self.nextEFX > CurTime() then return end
	self.nextEFX = CurTime() + 0.01


	local emitter = self:GetParticleEmitter(self:GetPos())
	if not IsValid(emitter) then return end

	for _, pos in pairs( self.EnginePos ) do
		local vOffset = self:LocalToWorld( pos )
		local vNormal = -self:GetForward()

		vOffset = vOffset + vNormal * 5

		local particle = emitter:Add("effects/muzzleflash2", vOffset)
		if not particle then continue end

		particle:SetVelocity(vNormal * (math.Rand(500,1000) + self:GetBoost() * 10) + self:GetVelocity())
		particle:SetLifeTime(0)
		particle:SetDieTime(0.1)
		particle:SetStartAlpha(255)
		particle:SetEndAlpha(0)
		particle:SetStartSize(math.Rand(15,25))
		particle:SetEndSize(math.Rand(0,10))
		particle:SetRoll(math.Rand(-1,1) * 100)
		particle:SetColor(0, 195, 255)
	end
end

function ENT:OnFrame()
	self:EngineEffects()
end

function ENT:PostDrawTranslucent()
	if not self:GetEngineActive() then return end

	local Size = 80 + self:GetThrottle() * 120 + self:GetBoost() * 2

	render.SetMaterial(self.EngineGlow)

	for _, pos in pairs(self.EnginePos) do
		render.DrawSprite(self:LocalToWorld( pos ), Size, Size, self.EngineColor)
	end
end

function ENT:OnStartBoost()
	self:EmitSound("lvs/vehicles/liberator/engine_on.wav", 85)
end

function ENT:OnStopBoost()
	self:EmitSound("lvs/vehicles/liberator/engine_off.wav", 85)
end


--addons/egm_lvs_ships/lua/entities/lvs_starfighter_liberator/shared.lua:

ENT.Base = "lvs_base_starfighter"

ENT.PrintName = "Liberator Starfighter"
ENT.Author = "Ophra & Deltaa"
ENT.Information = "The Liberator-class starfighter was a model of fighter used by the Galactic Republic prior to and during the Great Galactic War."
ENT.Category = "[LVS] - Neutral"

ENT.Spawnable = true
ENT.AdminSpawnable = false

ENT.MDL = "models/ophra/ships/veh_rep_fighter_nolanding.mdl"

ENT.AITEAM = 0

ENT.MaxVelocity = 2800
ENT.MaxThrust = 2800

ENT.ThrustVtol = 55
ENT.ThrustRateVtol = 3

ENT.TurnRatePitch = 1
ENT.TurnRateYaw = 1
ENT.TurnRateRoll = 1

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1.2
ENT.ForceAngleDampingMultiplier = 1

ENT.MaxHealth = 9000
ENT.MaxShield = 2250

function ENT:InitWeapons()
	self.FirePositions = {
		Vector(151, 272, -42),
		Vector(151, -272, -42),
	}

	-- Primary Weapon
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/hmg.png")
	weapon.Delay = 0.15
	weapon.HeatRateUp = 0.5
	weapon.HeatRateDown = 1
	weapon.Attack = function( ent )
		ent.NumPrim = ent.NumPrim and ent.NumPrim + 1 or 1
		if ent.NumPrim > #ent.FirePositions then ent.NumPrim = 1 end

		local pod = ent:GetDriverSeat()
		if not IsValid(pod) then return end

		local startpos = pod:LocalToWorld( pod:OBBCenter() )
		local trace = util.TraceHull( {
			start = startpos,
			endpos = (startpos + ent:GetForward() * 50000),
			mins = Vector( -10, -10, -10 ),
			maxs = Vector( 10, 10, 10 ),
			filter = ent:GetCrosshairFilterEnts()
		} )

		local CurPos = ent.FirePositions[ent.NumPrim]

		local bullet = {}
		bullet.Src = ent:LocalToWorld(CurPos)
		bullet.Dir = (trace.HitPos - bullet.Src):GetNormalized()
		bullet.Spread = Vector( 0.025,  0.025, 0 )
		bullet.TracerName = "lvs_laser_red"
		bullet.Force = 100
		bullet.HullSize = 30
		bullet.Damage = 300
		bullet.Velocity = 50000
		bullet.Attacker = ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
			effectdata:SetStart(Vector(255, 50, 0))
			effectdata:SetOrigin(tr.HitPos)
			util.Effect("lvs_laser_explosion", effectdata)
		end
		ent:LVSFireBullet(bullet)

		local effectdata = EffectData()
		effectdata:SetStart(Vector(255, 50, 0))
		effectdata:SetOrigin(bullet.Src)
		effectdata:SetNormal(ent:GetForward())
		effectdata:SetEntity(ent)
		util.Effect("lvs_muzzle_colorable", effectdata)

		if CurPos.y > 0 then
			ent.SNDLeft:PlayOnce( 100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
		else
			ent.SNDRight:PlayOnce( 100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
		end
	end
	weapon.OnSelect = function(ent)
		ent:EmitSound("ophra/ships/weaponswitch.wav")
	end
	weapon.OnOverheat = function(ent)
		ent:EmitSound("lvs/overheat.wav")
	end
	self:AddWeapon(weapon)


	-- Proton weapon
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/protontorpedo.png")
	weapon.Ammo = 26
	weapon.Delay = 3 -- this will turn weapon.Attack to a somewhat think function
	weapon.HeatRateUp = -0.5 -- cool down when attack key is held. This system fires on key-release.
	weapon.HeatRateDown = 0.25
	weapon.Attack = function(ent)
		local T = CurTime()

		if IsValid(ent._ProtonTorpedo) then
			if (ent._nextMissleTracking or 0) > T then return end

			ent._nextMissleTracking = T + 0.1 -- 0.1 second interval because those find functions can be expensive

			ent._ProtonTorpedo:FindTarget( ent:GetPos(), ent:GetForward(), 30, 7500 )

			return
		end

		if (ent._nextMissle or 0) > T then return end
		ent._nextMissle = T + 0.5

		ent._swapMissile = not ent._swapMissile

		local Pos = Vector(150.57, ent._swapMissile and 272.18 or -272.18, -42.15)

		local Driver = self:GetDriver()

		local projectile = ents.Create("lvs_protontorpedo")
		projectile:SetPos(ent:LocalToWorld(Pos))
		projectile:SetAngles(ent:LocalToWorldAngles(Angle(0,ent._swapMissile and 2 or -2,0)))
		projectile:SetParent(ent)
		projectile:Spawn()
		projectile:Activate()
		projectile:SetAttacker(IsValid(Driver) and Driver or self)
		projectile:SetDamage(8000)
		projectile:SetEntityFilter(ent:GetCrosshairFilterEnts())
		projectile:SetSpeed(ent:GetVelocity():Length() + 4000)

		ent._ProtonTorpedo = projectile

		ent:SetNextAttack(CurTime() + 0.1) -- wait 0.1 second before starting to track
	end
	weapon.FinishAttack = function(ent)
		if not IsValid(ent._ProtonTorpedo) then return end

		local projectile = ent._ProtonTorpedo
		projectile:Enable()
		projectile:EmitSound("ophra/ships/shootsound4heavy.wav", 125)
		ent:TakeAmmo()

		ent._ProtonTorpedo = nil

		local NewHeat = ent:GetHeat() + 0.75

		ent:SetHeat(NewHeat)
		if NewHeat >= 1 then
			ent:SetOverheated(true)
		end
	end
	weapon.OnSelect = function(ent)
		ent:EmitSound("ophra/ships/weaponswitch.wav")
	end
	weapon.OnOverheat = function(ent)
		ent:EmitSound("lvs/overheat.wav")
	end
	self:AddWeapon(weapon)

	self:AddWeapon(LVS:GetWeaponPreset("TURBO"))
end

ENT.FlyByAdvance = 0.5
ENT.FlyBySound = "lvs/vehicles/arc170/flyby.wav"
ENT.DeathSound = "lvs/vehicles/generic_starfighter/crash.wav"

ENT.EngineSounds = {
	{
		sound = "lvs/vehicles/liberator/engine.wav",
		Volume = 3000,
		Pitch = 80,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 40,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
	},
}

--addons/egm_lvs_ships/lua/entities/lvs_starfighter_nantex/cl_init.lua:
include("shared.lua")

function ENT:OnSpawn()
	self:RegisterTrail(Vector(-100, 0, 50), 5, 20, 2, 1000, 150)
end

function ENT:PostDrawTranslucent()
	if not self:GetEngineActive() then return end

	if self.nextEFX and self.nextEFX > CurTime() then return end
	self.nextEFX = CurTime() + 0.01


	local emitter = self:GetParticleEmitter(self:GetPos())
	if not IsValid(emitter) then return end

	local vOffset = self:LocalToWorld(Vector(-100, 0, 50))
	local vNormal = -self:GetForward()

	vOffset = vOffset + vNormal * 5

	local particle = emitter:Add("effects/muzzleflash2", vOffset)
	if not particle then return end

	particle:SetVelocity(vNormal * (math.Rand(500, 1000) + self:GetBoost() * 10) + self:GetVelocity())
	particle:SetLifeTime(0)
	particle:SetDieTime(0.1)
	particle:SetStartAlpha(255)
	particle:SetEndAlpha(0)
	particle:SetStartSize(math.Rand(15,25))
	particle:SetEndSize(math.Rand(0,10))
	particle:SetRoll(math.Rand(-1,1) * 100)
	particle:SetColor(255, 50, 200)
end

function ENT:OnStartBoost()
	self:EmitSound("lvs/vehicles/vulturedroid/boost.wav", 85)
end

function ENT:OnStopBoost()
	self:EmitSound("lvs/vehicles/vulturedroid/brake.wav", 85)
end
--addons/egm_lvs_ships/lua/entities/lvs_starfighter_starchaser/shared.lua:

ENT.Base = "lvs_base_starfighter"

ENT.PrintName = "Star Chaser"
ENT.Author = "Ophra & Deltaa"
ENT.Information = "Space Ship"
ENT.Category = "[LVS] - Neutral"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/ophra/ships/veh_neu_heavy_utility_starship_no_landing_gear.mdl"

ENT.AITEAM = 0

ENT.MaxVelocity = 2150
ENT.MaxThrust = 2150

ENT.ThrustVtol = 55
ENT.ThrustRateVtol = 3

ENT.TurnRatePitch = 0.8
ENT.TurnRateYaw = 0.8
ENT.TurnRateRoll = 0.8

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 0.8
ENT.ForceAngleDampingMultiplier = 1

ENT.MaxHealth = 24000
ENT.MaxShield = 3000


function ENT:InitWeapons()
end

ENT.FlyByAdvance = 0.5
ENT.FlyBySound = "lvs/vehicles/arc170/flyby.wav"
ENT.DeathSound = "lvs/vehicles/generic_starfighter/crash.wav"

ENT.EngineSounds = {
	{
		sound = "lvs/vehicles/starchaser/engine.wav",
		Volume = 3000,
		Pitch = 80,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 40,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
	},
}

--addons/egm_lvs_ships/lua/entities/lvs_starfighter_transporter_civ/cl_init.lua:
include("shared.lua")

ENT.EngineGlow = Material("sprites/light_glow02_add")

function ENT:OnSpawn()
	self:RegisterTrail(Vector(-100, 20, 10), 0, 20, 2, 1000, 150)
	self:RegisterTrail(Vector(-100, -20, 10), 0, 20, 2, 1000, 150)
end

--addons/egm_lvs_ships/lua/entities/lvs_starfighter_transporter_civ/shared.lua:
ENT.Base = "lvs_base_starfighter"

ENT.PrintName = "Ziviler Transporter"
ENT.Author = "Miller"
ENT.Information = "DER Personentransporter auf Coruscant"
ENT.Category = "[LVS] - Neutral"

ENT.Spawnable = true
ENT.AdminSpawnable = false

ENT.MDL = "models/bfii/vehicles/jedi_shuttle.mdl"

ENT.AITEAM = 0

ENT.MaxVelocity = 2000
ENT.MaxThrust = 2000

ENT.ThrustVtol = 55
ENT.ThrustRateVtol = 3

ENT.TurnRatePitch = 1
ENT.TurnRateYaw = 1
ENT.TurnRateRoll = 1

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1.5
ENT.ForceAngleDampingMultiplier = 1

ENT.MaxHealth = 12000
ENT.MaxShield = 4500

ENT.FlyByAdvance = 0.5
ENT.FlyBySound = "lvs/vehicles/delta-7/flyby.wav"
ENT.DeathSound = "lvs/vehicles/generic_starfighter/crash.wav"

ENT.EngineSounds = {
	{
		sound = "lvs/vehicles/delta-7/engine.wav",
		sound_int = "lvs/vehicles/delta-7/engine_int.wav",
		Pitch = 80,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 40,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
	},
}


--addons/egm_lvs_ships/lua/entities/lvs_starfighter_v19/cl_init.lua:
include("shared.lua")

ENT.EngineGlow = Material("sprites/light_glow02_add")

function ENT:OnSpawn()
	self:RegisterTrail(Vector(-200, 165, 10), 0, 100, 2, 1000, 150)
	self:RegisterTrail(Vector(-200, -165, 10), 0, 100, 2, 1000, 150)
end

function ENT:OnFrame()
	self:AnimWings()
end

function ENT:PostDrawTranslucent()
	if not self:GetEngineActive() then return end

	local Size = 80 + self:GetThrottle() * 120 + self:GetBoost() * 0.8
	render.SetMaterial(self.EngineGlow)
	render.DrawSprite(self:LocalToWorld(Vector(-215, -123, 7.78)), Size, Size, Color(39, 207, 244 ))
	render.DrawSprite(self:LocalToWorld(Vector(-215, 123, 7.78)), Size, Size, Color(39, 207, 244 ))

	if self:GetWings() then
		render.DrawSprite(self:LocalToWorld(Vector(-135,0,-208.578)), Size, Size, Color(39, 207, 244))
	end
end

function ENT:EngineEffects()
	if not self:GetEngineActive() then return end

	if self.nextEFX and self.nextEFX > CurTime() then return end
	self.nextEFX = CurTime() + 0.01


	local emitter = self:GetParticleEmitter(self:GetPos())
	if not IsValid(emitter) then return end

	for _, pos in pairs(self.EnginePos) do
		local vOffset = self:LocalToWorld( pos )
		local vNormal = -self:GetForward()

		vOffset = vOffset + vNormal * 5

		local particle = emitter:Add("effects/muzzleflash2", vOffset)
		if not particle then continue end

		particle:SetVelocity(vNormal * (math.Rand(500,1000) + self:GetBoost() * 10) + self:GetVelocity())
		particle:SetLifeTime(0)
		particle:SetDieTime(0.1)
		particle:SetStartAlpha(255)
		particle:SetEndAlpha(0)
		particle:SetStartSize(math.Rand(15,25))
		particle:SetEndSize(math.Rand(0,10))
		particle:SetRoll(math.Rand(-1,1) * 100)
		particle:SetColor(255, 50, 200)
	end
end

function ENT:AnimWings()
	self._sm_wing = self._sm_wing or 1

	local target_wing = self:GetWings() and 0 or 1
	local RFT = RealFrameTime() * (0.5 + math.abs(math.sin(self._sm_wing * math.pi)) * 0.5)

	local Rate = RFT * 0.5

	self._sm_wing = self._sm_wing + math.Clamp(target_wing - self._sm_wing, -Rate, Rate)

	local DoneMoving = self._sm_wing == 1 or self._sm_wing == 0

	if self._oldDoneMoving ~= DoneMoving then
		self._oldDoneMoving = DoneMoving
		if not DoneMoving then
			self:EmitSound("lvs/vehicles/arc170/sfoils.wav")
		end
	end

	self.SMLG = self.SMLG and self.SMLG + (180 *  self._sm_wing - self.SMLG) * FrameTime() * 2.1 or 0
	self.SMLG1 = self.SMLG1 and self.SMLG1 + (46 *  self._sm_wing - self.SMLG1) * FrameTime() * 2.1 or 0

	local Ang = 180 - self.SMLG
	local Mov = 46 - self.SMLG1

	self:ManipulateBoneAngles(3, Angle(0, Ang, 0))
	self:ManipulateBoneAngles(2, Angle(0, 0, Ang * 0.7))
	self:ManipulateBoneAngles(1, Angle(0, 0, -Ang * 0.7))
	self:ManipulateBonePosition(4, Vector(0, Mov, 0))

	self:InvalidateBoneCache()
end

--addons/egm_lvs_ships/lua/entities/lvs_starfighter_v19/shared.lua:
ENT.Base = "lvs_base_starfighter"

ENT.PrintName = "V-19 Torrent"
ENT.Author = "Deltaa"
ENT.Information = "The V-19 Torrent was used by the Republic Navy during the Clone Wars, predominantly during the early stages of the war."
ENT.Category = "[LVS] - Republik"

ENT.Spawnable = true
ENT.AdminSpawnable = false

ENT.MDL = "models/DiggerThings/v19/4.mdl"

ENT.AITEAM = 2

ENT.MaxVelocity = 750
ENT.MaxThrust = 750

ENT.ThrustVtol = 55
ENT.ThrustRateVtol = 3

ENT.TurnRatePitch = 1
ENT.TurnRateYaw = 1
ENT.TurnRateRoll = 1

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1.5
ENT.ForceAngleDampingMultiplier = 1

ENT.MaxHealth = 16500
ENT.MaxShield = 0

function ENT:OnSetupDataTables()
	self:AddDT("Bool", "Wings")

	if SERVER then
		self:NetworkVarNotify("Wings", self.OnWingsChanged)
	end
end

function ENT:InitWeapons()
	self.FirePositions = {
		Vector(15, 25, -5),
		Vector(15, -25, -5)
	}

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/hmg.png")
	weapon.Delay = 0.15
	weapon.HeatRateUp = 0.1
	weapon.HeatRateDown = 0.5
	weapon.Attack = function( ent )
		ent.NumPrim = ent.NumPrim and ent.NumPrim + 1 or 1
		if ent.NumPrim > #ent.FirePositions then ent.NumPrim = 1 end

		if not ent:GetWings() then
			local NewHeat = ent:GetHeat() + 0.75
			ent:SetHeat(NewHeat)
			if NewHeat >= 1 then
				ent:SetOverheated(true)
			end
		end

		local pod = ent:GetDriverSeat()
		if not IsValid( pod ) then return end

		local startpos =  pod:LocalToWorld(pod:OBBCenter())
		local trace = util.TraceHull({
			start = startpos,
			endpos = startpos + ent:GetForward() * 50000,
			mins = Vector( -10, -10, -10 ),
			maxs = Vector( 10, 10, 10 ),
			filter = ent:GetCrosshairFilterEnts()
		})

		local CurPos = ent.FirePositions[ent.NumPrim]

		local bullet = {}
		bullet.Src = ent:LocalToWorld(ent.FirePositions[ent.NumPrim])
		bullet.Dir = (trace.HitPos - bullet.Src):GetNormalized()
		bullet.Spread = Vector(0.01, 0.01, 0)
		bullet.Tracer = 1
		bullet.TracerName = "lvs_laser_green"
		bullet.Force = 100
		bullet.HullSize = 10
		bullet.Damage = 600
		bullet.Attacker = ent:GetDriver()
		bullet.Velocity = 60000
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
			effectdata:SetStart(Vector(50,255,50))
			effectdata:SetOrigin(tr.HitPos)
			effectdata:SetNormal(tr.HitNormal)
			util.Effect("lvs_laser_impact", effectdata )
		end
		ent:LVSFireBullet( bullet )


		ent:TakeAmmo()

		if CurPos.y > 0 then
			ent.SNDLeft:PlayOnce( 100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
		else
			ent.SNDRight:PlayOnce( 100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
		end
	end
	weapon.OnSelect = function( ent )
		ent:EmitSound("physics/metal/weapon_impact_soft3.wav")
	end
	weapon.OnOverheat = function(ent)
		ent:EmitSound("lvs/overheat.wav")
	end
	self:AddWeapon(weapon)

	-- Concussion Missile
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/protontorpedo.png")
	weapon.Ammo = 12
	weapon.Delay = 3
	weapon.HeatRateUp = 1
	weapon.HeatRateDown = 0.25
	weapon.Attack = function( ent )
		if IsValid(ent._ProtonTorpedo) then
			if ent._nextMissleTracking and ent._nextMissleTracking > CurTime() then return end
			ent._nextMissleTracking = CurTime() + 0.1

			ent._ProtonTorpedo:FindTarget(ent:GetPos(), ent:GetForward(), 30, 7500)
			return
		end

		if ent._nextMissle and ent._nextMissle > CurTime() then return end
		ent._nextMissle = CurTime() + 0.5

		local veh = ent:GetVehicle()
		ent.NumPrim = ent.NumPrim and ent.NumPrim + 1 or 1
		if ent.NumPrim > #veh.FirePositions then ent.NumPrim = 1 end

		if not self:GetWings() then return true end

		local CurPos = veh.FirePositions[ent.NumPrim]
		local Driver = self:GetDriver()

		local projectile = ents.Create("lvs_concussionmissile")
		projectile:SetPos(ent:LocalToWorld(CurPos))
		projectile:SetAngles(ent:GetAngles())
		projectile:SetParent(ent)
		projectile:Spawn()
		projectile:Activate()
		projectile:SetAttacker(IsValid( Driver ) and Driver or self)
		projectile:SetEntityFilter(ent:GetCrosshairFilterEnts())
		projectile:SetSpeed(ent:GetVelocity():Length() + 4000)

		ent._ProtonTorpedo = projectile

		ent:SetNextAttack(CurTime() + 0.1) -- wait 0.1 second before starting to track
	end
	weapon.FinishAttack = function( ent )
		if not IsValid(ent._ProtonTorpedo) then return end

		local projectile = ent._ProtonTorpedo
		projectile:Enable()
		projectile:EmitSound("lvs/vehicles/vulturedroid/fire_missile.mp3", 125 )
		ent:TakeAmmo()

		ent._ProtonTorpedo = nil

		local NewHeat = ent:GetHeat() + 0.75
		if NewHeat >= 1 then
			ent:SetOverheated( true )
		end

		ent:SetHeat( NewHeat )
	end
	weapon.OnSelect = function(ent)
		ent:EmitSound("physics/metal/weapon_impact_soft3.wav")
	end
	weapon.OnOverheat = function(ent)
		ent:EmitSound("lvs/overheat.wav")
	end
	self:AddWeapon(weapon)

	self:AddWeapon(LVS:GetWeaponPreset( "TURBO"))
end

ENT.FlyByAdvance = 0.5
ENT.FlyBySound = "lvs/vehicles/arc170/flyby.wav"
ENT.DeathSound = "lvs/vehicles/generic_starfighter/crash.wav"

ENT.EngineSounds = {
	{
		sound = "lvs/vehicles/arc170/loop.wav",
		Pitch = 80,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 40,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
	},
}


--addons/egm_lvs_ships/lua/entities/lvs_starfighter_vwing/shared.lua:
ENT.Base = "lvs_base_starfighter"

ENT.PrintName = "V-Wing"
ENT.Author = "Miller"
ENT.Information = "Alpha 3 Nimbus Class V Wing Starfighter"
ENT.Category = "[LVS] - Republik"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/diggerthings/vwing/5.mdl"

ENT.AITEAM = 2

ENT.MaxVelocity = 3300
ENT.MaxThrust = 3300

ENT.ThrustVtol = 55
ENT.ThrustRateVtol = 3

ENT.TurnRatePitch = 1.1
ENT.TurnRateYaw = 1.1
ENT.TurnRateRoll = 1.1

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1
ENT.ForceAngleDampingMultiplier = 1

ENT.MaxHealth = 10500
ENT.MaxShield = 3750

ENT.LAATC_PICKUPABLE = true
ENT.LAATC_PICKUP_POS = Vector(-230, 0, 25)
ENT.LAATC_PICKUP_Angle = Angle(0,0,0)

function ENT:OnIsCarried(name, old, new)
	if new == old then return end

	if new then
		self:SetDisabled(true)
	else
		self:SetDisabled(false)
	end
end

function ENT:OnSetupDataTables()
	self:AddDT("Bool", "Wings")
	self:AddDT("Bool", "IsCarried")


	if SERVER then
		self:NetworkVarNotify("Wings", self.OnWingsChanged)
		self:NetworkVarNotify("IsCarried", self.OnIsCarried)
	end
end

function ENT:InitWeapons()
	self.FirePositions = {
		Vector(40, 55, -10),
		Vector(40, -55, -10)
	}

	-- Primary Gun
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/hmg.png")
	weapon.Delay = 0.15
	weapon.HeatRateUp = 0.1
	weapon.HeatRateDown = 0.25
	weapon.Attack = function(ent)
		ent.NumPrim = ent.NumPrim and ent.NumPrim + 1 or 1
		if ent.NumPrim > #ent.FirePositions then ent.NumPrim = 1 end

		if not ent:GetWings() then
			ent:SetHeat(ent:GetHeat() + 0.5)
		end

		local pod = ent:GetDriverSeat()
		if not IsValid(pod) then return end

		local startpos = pod:LocalToWorld( pod:OBBCenter() )
		local trace = util.TraceHull( {
			start = startpos,
			endpos = startpos + ent:GetForward() * 50000,
			mins = Vector( -10, -10, -10 ),
			maxs = Vector( 10, 10, 10 ),
			filter = ent:GetCrosshairFilterEnts()
		})

		local CurPos = ent.FirePositions[ent.NumPrim]

		local bullet = {}
		bullet.Src = ent:LocalToWorld(CurPos)
		bullet.Dir = (trace.HitPos - bullet.Src):GetNormalized()
		bullet.Spread = Vector( 0.05,  0.01, 0 )
		bullet.TracerName = "lvs_laser_green"
		bullet.Force = 100
		bullet.HullSize = 25
		bullet.Damage = 900
		bullet.Velocity = 50000
		bullet.Attacker = ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
			effectdata:SetStart( Vector(0,255,0))
			effectdata:SetOrigin(tr.HitPos)
			util.Effect( "lvs_laser_explosion", effectdata)
		end
		ent:LVSFireBullet( bullet )

		local effectdata = EffectData()
		effectdata:SetStart(Vector(500, 255, 50))
		effectdata:SetOrigin(bullet.Src)
		effectdata:SetNormal(ent:GetForward())
		effectdata:SetEntity(ent)
		util.Effect("lvs_muzzle_colorable", effectdata)

		if CurPos.y > 0 then
			ent.SNDLeft:PlayOnce(100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1)
		else
			ent.SNDRight:PlayOnce(100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1)
		end
	end
	weapon.OnSelect = function( ent )
		ent:EmitSound("physics/metal/weapon_impact_soft3.wav")
	end
	weapon.OnOverheat = function(ent)
		ent:EmitSound("lvs/overheat.wav")
	end
	self:AddWeapon( weapon )

	-- Secondary Gun
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/hmg.png")
	weapon.Delay = 0.15
	weapon.HeatRateUp = 1
	weapon.HeatRateDown = 0.25
	weapon.Attack = function(ent)
		ent.NumPrim = ent.NumPrim and ent.NumPrim + 1 or 1
		if ent.NumPrim > #ent.FirePositions then ent.NumPrim = 1 end

		if not ent:GetWings() then
			ent:SetHeat(ent:GetHeat() + 1)
		end

		local pod = ent:GetDriverSeat()
		if not IsValid(pod) then return end

		local startpos = pod:LocalToWorld( pod:OBBCenter() )
		local trace = util.TraceHull( {
			start = startpos,
			endpos = startpos + ent:GetForward() * 50000,
			mins = Vector( -10, -10, -10 ),
			maxs = Vector( 10, 10, 10 ),
			filter = ent:GetCrosshairFilterEnts()
		})

		local CurPos = ent.FirePositions[ent.NumPrim]

		local bulletCount = 10
		for i = 0, bulletCount do
			local bullet = {}
			bullet.Src = ent:LocalToWorld(CurPos)
			bullet.Dir = (trace.HitPos - bullet.Src):GetNormalized()
			bullet.Spread = Vector(0.1,0.1,0.1)
			bullet.TracerName = "lvs_laser_green"
			bullet.Force = 100
			bullet.HullSize = 25
			bullet.Damage = 150
			bullet.Velocity = 50000
			bullet.Attacker = ent:GetDriver()
			bullet.Callback = function(att, tr, dmginfo)
				local effectdata = EffectData()
				effectdata:SetStart( Vector(0,255,0))
				effectdata:SetOrigin(tr.HitPos)
				util.Effect( "lvs_laser_explosion", effectdata)
			end
		ent:LVSFireBullet( bullet )
		local effectdata = EffectData()
		effectdata:SetStart(Vector(500, 255, 50))
		effectdata:SetOrigin(bullet.Src)
		effectdata:SetNormal(ent:GetForward())
		effectdata:SetEntity(ent)
		util.Effect("lvs_muzzle_colorable", effectdata)
		end
		if CurPos.y > 0 then
			ent.SNDLeft:PlayOnce(100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1)
		else
			ent.SNDRight:PlayOnce(100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1)
		end
	end
	weapon.OnSelect = function( ent )
		ent:EmitSound("physics/metal/weapon_impact_soft3.wav")
	end
	weapon.OnOverheat = function(ent)
		ent:EmitSound("lvs/overheat.wav")
	end
	self:AddWeapon( weapon )

	-- Turbo Mode
	self:AddWeapon(LVS:GetWeaponPreset("TURBO"))
end

ENT.FlyByAdvance = 0.5
ENT.FlyBySound = "lvs/vehicles/arc170/flyby.wav"
ENT.DeathSound = "lvs/vehicles/generic_starfighter/crash.wav"

ENT.EngineSounds = {
	{
		sound = "lvs/vehicles/arc170/loop.wav",
		Pitch = 80,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 40,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
	},
}
--addons/egm_lvs_ground/lua/entities/lvs_walker_atte/shared.lua:

ENT.Base = "lvs_walker_atte_hoverscript"

ENT.PrintName = "ATTE"
ENT.Author = "Luna & KingPommes"
ENT.Information = "Assault Walker of the Galactic Republic"
ENT.Category = "[LVS] - Republik"

ENT.Spawnable		= true
ENT.AdminSpawnable	= false

ENT.MDL = "models/kingpommes/starwars/atte/lfs_front.mdl"
ENT.GibModels = {
	"models/kingpommes/starwars/atte/lfs_front.mdl",
	"models/kingpommes/starwars/atte/lfs_rear.mdl",
	"models/kingpommes/starwars/atte/lfs_leg1.mdl",
	"models/kingpommes/starwars/atte/lfs_leg2.mdl",
	"models/kingpommes/starwars/atte/lfs_leg3_front_r.mdl",
	"models/kingpommes/starwars/atte/lfs_leg3_front_l.mdl",
	"models/kingpommes/starwars/atte/lfs_bigleg1.mdl",
	"models/kingpommes/starwars/atte/lfs_bigleg2.mdl"
}

ENT.AITEAM = 2

ENT.MaxHealth = 50000

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1
ENT.ForceAngleDampingMultiplier = 1

ENT.HoverHeight = 200
ENT.HoverTraceLength = 225
ENT.HoverHullRadius = 20

ENT.TurretTurnRate = 100

ENT.LAATC_PICKUPABLE = true
ENT.LAATC_DROP_IN_AIR = true
ENT.LAATC_PICKUP_POS = Vector(-220,0,-115)
ENT.LAATC_PICKUP_Angle = Angle(0,0,0)

ENT.CanMoveOn = {
	["func_door"] = true,
	["func_movelinear"] = true,
	["prop_physics"] = true,
}

ENT.lvsShowInSpawner = true

function ENT:OnSetupDataTables()
	self:AddDT( "Bool", "Disabled" )
	self:AddDT("Bool", "IsMoving")
	self:AddDT("Bool", "IsCarried")
	self:AddDT("Bool", "IsLightOn")
	self:AddDT("Bool", "IsRagdoll")
	self:AddDT("Entity", "RearEntity")
	self:AddDT("Entity", "TurretSeat")
	self:AddDT("Entity", "GunnerSeat")
	self:AddDT("Float", "Move")
	self:AddDT("Float", "TurretPitch")
	self:AddDT("Float", "TurretYaw")
	self:AddDT("Vector", "AIAimVector")


	if SERVER then
		self:NetworkVarNotify("Disabled", self.OnDisabled)
		self:NetworkVarNotify("IsCarried", self.OnIsCarried)
	end
end

function ENT:GetContraption()
	return {self, self:GetRearEntity()}
end

function ENT:GetEyeTrace()
	local startpos = self:GetPos()

	local pod = self:GetDriverSeat()

	if IsValid( pod ) then
		startpos = pod:LocalToWorld( Vector(0,0,33) )
	end

	local trace = util.TraceLine( {
		start = startpos,
		endpos = (startpos + self:GetAimVector() * 50000),
		filter = self:GetCrosshairFilterEnts()
	} )

	return trace
end

function ENT:GetAimVector()
	if self:GetAI() then
		return self:GetAIAimVector()
	end

	local Driver = self:GetDriver()

	if IsValid( Driver ) then
		return Driver:GetAimVector()
	else
		return self:GetForward()
	end
end

function ENT:GetAimAngles()
	local trace = self:GetEyeTrace()

	local AimAngles = self:WorldToLocalAngles( (trace.HitPos - self:LocalToWorld( Vector(265,0,100)) ):GetNormalized():Angle() )

	local ID = self:LookupAttachment( "muzzle_right_up" )
	local Muzzle = self:GetAttachment( ID )

	if not Muzzle then return AimAngles, trace.HitPos, false end

	local DirAng = self:WorldToLocalAngles( (trace.HitPos - self:GetDriverSeat():LocalToWorld( Vector(0,0,33) ) ):Angle() )

	return AimAngles, trace.HitPos, (math.abs( DirAng.p ) < 12 and math.abs( DirAng.y ) < 35)
end

function ENT:InitWeapons()
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/hmg.png")
	weapon.Delay = 0.25
	weapon.HeatRateUp = 0.25
	weapon.HeatRateDown = 0.5
	weapon.Attack = function( ent )
		if ent:GetIsCarried() then ent:SetHeat( 0 ) return true end

		local ID1 = ent:LookupAttachment( "muzzle_right_up" )
		local ID2 = ent:LookupAttachment( "muzzle_left_up" )
		local ID3 = ent:LookupAttachment( "muzzle_right_dn" )
		local ID4 = ent:LookupAttachment( "muzzle_left_dn" )

		local Muzzle1 = ent:GetAttachment( ID3 )
		local Muzzle2 = ent:GetAttachment( ID2 )
		local Muzzle3 = ent:GetAttachment( ID1 )
		local Muzzle4 = ent:GetAttachment( ID4 )

		if not Muzzle1 or not Muzzle2 or not Muzzle3 or not Muzzle4 then return end

		local FirePos = {
			[1] = Muzzle1,
			[2] = Muzzle2,
			[3] = Muzzle3,
			[4] = Muzzle4,
		}

		ent.FireIndex = ent.FireIndex and ent.FireIndex + 1 or 2

		if ent.FireIndex > #FirePos then
			ent.FireIndex = 1
		end

		local AimAngles, AimPos, InRange = ent:GetAimAngles()

		local Pos = FirePos[ent.FireIndex].Pos
		local Dir = (AimPos - Pos):GetNormalized()

		if not InRange then return true end

		local bullet = {}
		bullet.Src 	= Pos
		bullet.Dir 	= Dir
		bullet.Spread = Vector( 0.01,  0.01, 0 )
		bullet.TracerName = "lvs_laser_green_short"
		bullet.Force = 10
		bullet.HullSize = 30
		bullet.Damage = 900
		bullet.Velocity = 8000
		bullet.Attacker = ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
			effectdata:SetStart(Vector(0,255,0))
			effectdata:SetOrigin(tr.HitPos)
			util.Effect("lvs_laser_explosion", effectdata)
		end
		ent:LVSFireBullet( bullet )

		local effectdata = EffectData()
		effectdata:SetStart( Vector(50,255,50) )
		effectdata:SetOrigin( bullet.Src )
		effectdata:SetNormal( Dir )
		effectdata:SetEntity( ent )
		util.Effect("lvs_muzzle_colorable", effectdata)

		if not IsValid( ent.SNDPrimary ) then return end

		ent.SNDPrimary:PlayOnce( 100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
	end
	weapon.OnThink = function( ent, active )
		local base = ent:GetVehicle()

		if IsValid( base ) and base:GetIsCarried() then return end

		local AimAngles = ent:GetAimAngles()

		ent:SetPoseParameter("frontgun_pitch", math.Clamp(AimAngles.p,-5,5) )
		ent:SetPoseParameter("frontgun_yaw", AimAngles.y )
	end
	self:AddWeapon(weapon)

	-- Activates / Deactivates the spotlight
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/light.png")
	weapon.Delay = 1
	weapon.HeatRateUp = -1
	weapon.Attack = function(ent)
		if self.NextLight and self.NextLight >= CurTime() then return end
		self.NextLight = CurTime() + 1

		self:SetIsLightOn(not self:GetIsLightOn())
	end
	self:AddWeapon(weapon)

	self:InitTurret()
	self:InitGunner()
end

sound.Add({
    name = "ATTE_STEP_SOFT",
    channel = CHAN_AUTO,
    volume = 1.0,
    level = 90,
    pitch = {95, 105},
    sound = {"KingPommes/starwars/atte/soft1.wav", "KingPommes/starwars/atte/soft2.wav", "KingPommes/starwars/atte/soft3.wav", "KingPommes/starwars/atte/soft4.wav",}
})

sound.Add({
    name = "ATTE_STEP_HARD1",
    channel = CHAN_AUTO,
    volume = 1.0,
    level = 90,
    pitch = {95, 105},
    sound = "KingPommes/starwars/atte/hard1.wav"
})

sound.Add({
    name = "ATTE_STEP_HARD2",
    channel = CHAN_AUTO,
    volume = 1.0,
    level = 90,
    pitch = {95, 105},
    sound = "KingPommes/starwars/atte/hard2.wav"
})
--addons/egm_lvs_ground/lua/entities/lvs_walker_atte/cl_camera.lua:

function ENT:CalcViewDriver( ply, pos, angles, fov, pod )
	local view = {}
	view.origin = pos
	view.angles = angles
	view.fov = fov
	view.drawviewer = false

	if not pod:GetThirdPersonMode() then return view end

	local mn = self:OBBMins()
	local mx = self:OBBMaxs()
	local radius = ( mn - mx ):Length()
	local radius = radius + radius * pod:GetCameraDistance()

	local clamped_angles = pod:WorldToLocalAngles( angles )
	clamped_angles.p = math.max( clamped_angles.p, -20 )
	clamped_angles = pod:LocalToWorldAngles( clamped_angles )

	local StartPos = self:LocalToWorld( self:OBBCenter() ) + clamped_angles:Up() * 100
	local EndPos = StartPos - clamped_angles:Forward() * radius + clamped_angles:Up() * radius * 0.2

	local WallOffset = 4

	local tr = util.TraceHull( {
		start = StartPos,
		endpos = EndPos,
		filter = function( e )
			local c = e:GetClass()
			local collide = not c:StartWith( "prop_physics" ) and not c:StartWith( "prop_dynamic" ) and not c:StartWith( "prop_ragdoll" ) and not e:IsVehicle() and not c:StartWith( "gmod_" ) and not c:StartWith( "lvs_" ) and not c:StartWith( "player" ) and not e.LVS

			return collide
		end,
		mins = Vector( -WallOffset, -WallOffset, -WallOffset ),
		maxs = Vector( WallOffset, WallOffset, WallOffset ),
	} )

	view.angles = angles + Angle(5,0,0)
	view.origin = tr.HitPos
	view.drawviewer = true

	if tr.Hit and  not tr.StartSolid then
		view.origin = view.origin + tr.HitNormal * WallOffset
	end

	return view
end

function ENT:LVSCalcView(ply, pos, angles, fov, pod)
	local view = {}
	view.origin = self:LocalToWorld( Vector(0,0,200) )
	view.angles = angles
	view.fov = fov
	view.drawviewer = false

	if self:GetDriver() == ply then
		return self:CalcViewDriver(ply, pos, angles, fov, pod)
	end

	local mn = self:OBBMins()
	local mx = self:OBBMaxs()
	local radius = ( mn - mx ):Length()
	local radius = radius + radius * pod:GetCameraDistance()

	local TargetOrigin = view.origin + ( view.angles:Forward() * -radius )
	local WallOffset = 4

	local tr = util.TraceHull( {
		start = view.origin,
		endpos = TargetOrigin,
		filter = function( e )
			local c = e:GetClass()
			local collide = not c:StartWith( "prop_physics" ) and not c:StartWith( "prop_dynamic" ) and not c:StartWith( "prop_ragdoll" ) and not e:IsVehicle() and not c:StartWith( "gmod_" ) and not c:StartWith( "lvs_" ) and not c:StartWith( "player" ) and not e.LVS

			return collide
		end,
		mins = Vector( -WallOffset, -WallOffset, -WallOffset ),
		maxs = Vector( WallOffset, WallOffset, WallOffset ),
	} )

	view.origin = tr.HitPos

	if tr.Hit and  not tr.StartSolid then
		view.origin = view.origin + tr.HitNormal * WallOffset
	end

	return view
end
--addons/egm_lvs_ground/lua/entities/lvs_walker_atte/cl_prediction.lua:

function ENT:PredictPoseParamaters()
	local pod = self:GetTurretSeat()

	if not IsValid(pod) then return end

	local plyL = LocalPlayer()
	local ply = pod:GetDriver()

	if ply ~= plyL then return end

	self:SetPosTurret()
	self:SetPoseParameterTurret(pod:lvsGetWeapon())
end
--addons/egm_lvs_ground/lua/entities/lvs_walker_atte_component.lua:
AddCSLuaFile()

ENT.Type            = "anim"

ENT.AutomaticFrameAdvance = true
ENT.DoNotDuplicate = true

function ENT:SetupDataTables()
	self:NetworkVar( "Entity",0, "Base" )
end

if SERVER then
	function ENT:Initialize()	
		self:PhysicsInit( SOLID_VPHYSICS )
		self:SetMoveType( MOVETYPE_VPHYSICS )
		self:SetSolid( SOLID_VPHYSICS )
	end

	function ENT:Think()
		return false
	end

	function ENT:OnTakeDamage( dmginfo )
		local base = self:GetBase()

		if not IsValid( base ) then return end

		base:OnTakeDamage( dmginfo )
	end

	function ENT:PhysicsCollide( data, phys )
		local base = self:GetBase()

		if not IsValid( base ) then return end

		base:PhysicsCollide( data, phys )
	end

	function ENT:Use( ply )
		if (ply._lvsNextUse or 0) > CurTime() then return end

		local base = self:GetBase()

		if not IsValid( base ) then return end

		base:Use( ply )
	end

	function ENT:UpdateTransmitState() 
		return TRANSMIT_ALWAYS
	end

	return
end

function ENT:Draw()
	self:DrawModel()
end

function ENT:Think()
end

function ENT:OnRemove()
end
--addons/egm_lvs_ground/lua/entities/lvs_walker_atte/cl_ikfunctions.lua:
function ENT:OnRemoved()
	self:LegClearAll()
end

local debugred = Color(255,0,0,255)
local debugblue = Color(0,0,255,255)
local debuggreen = Color(0,255,0,255)

function ENT:LegClearAll()
	if istable( self.IK_Joints ) then
		for _, tab in pairs(self.IK_Joints) do
			for _,prop in pairs( tab ) do
				if IsValid(prop) then
					prop:Remove()
				end
			end
		end

		self.IK_Joints = nil
	end
end

function ENT:GetLegEnts(index, L1, L2, JOINTANG, STARTPOS, ENDPOS, ATTACHMENTS)
	if not istable( self.IK_Joints ) then self.IK_Joints = {} end

	if self.IK_Joints[index] then
		if IsValid( self.IK_Joints[ index ].LegBaseRot ) and IsValid( self.IK_Joints[ index ].LegRotCalc ) then
			if (self.IK_Joints[ index ].LegBaseRot:GetPos() - STARTPOS):Length() > 1 or (self.IK_Joints[ index ].LegRotCalc:GetPos() - STARTPOS):Length() > 1 then
				for k, v in pairs( self.IK_Joints[ index ] ) do
					if IsValid( v ) then
						v:Remove()
					end
				end
				self.IK_Joints[ index ] = nil
			end
		end
	end

	if not self.IK_Joints[index] then
		self.IK_Joints[index] = {}

		local BaseProp = ents.CreateClientProp()
		BaseProp:SetPos( STARTPOS )
		BaseProp:SetAngles( JOINTANG )
		BaseProp:SetModel( "models/Combine_Helicopter/helicopter_bomb01.mdl" )
		BaseProp:SetParent( self )
		BaseProp:Spawn()

		local LegRotCalc = ents.CreateClientProp()
		LegRotCalc:SetPos( STARTPOS )
		LegRotCalc:SetAngles( JOINTANG )
		LegRotCalc:SetModel( "models/Combine_Helicopter/helicopter_bomb01.mdl" )
		LegRotCalc:SetParent( self )
		LegRotCalc:Spawn()

		local prop1 = ents.CreateClientProp()
		prop1:SetPos( BaseProp:LocalToWorld( Vector(0,0,L1 * 0.5) ) )
		prop1:SetAngles( JOINTANG )
		prop1:SetModel( "models/Combine_Helicopter/helicopter_bomb01.mdl" )
		prop1:SetParent( self )
		prop1:Spawn()

		local prop2 = ents.CreateClientProp()
		prop2:SetPos( BaseProp:LocalToWorld( Vector(0,0,L1 + L2) ) )
		prop2:SetAngles( JOINTANG )
		prop2:SetModel( "models/Combine_Helicopter/helicopter_bomb01.mdl" )
		prop2:SetParent( self )
		prop2:Spawn()

		local prop3 = ents.CreateClientProp()
		prop3:SetPos( STARTPOS )
		prop3:SetAngles( JOINTANG )
		prop3:SetModel( "models/Combine_Helicopter/helicopter_bomb01.mdl" )
		prop3:SetParent( LegRotCalc )
		prop1:SetParent( prop3 )
		prop3:Spawn()

		local prop4 = ents.CreateClientProp()
		prop4:SetPos( BaseProp:LocalToWorld( Vector(0,0,L1) ) )
		prop4:SetAngles( JOINTANG )
		prop4:SetModel( "models/Combine_Helicopter/helicopter_bomb01.mdl" )
		prop4:SetParent( prop1 )
		prop2:SetParent( prop4 )
		prop4:Spawn()

		self.IK_Joints[ index ].LegBaseRot = BaseProp
		self.IK_Joints[ index ].LegRotCalc = LegRotCalc
		self.IK_Joints[ index ].LegEnt1 = prop1
		self.IK_Joints[ index ].LegEnt2 = prop2
		self.IK_Joints[ index ].LegEnt3 = prop3
		self.IK_Joints[ index ].LegEnt4 = prop4

		for _, v in pairs( self.IK_Joints[ index ] ) do
			v:SetColor( Color( 0, 0, 0, 0 ) )
			v:SetRenderMode( RENDERMODE_TRANSALPHA )
		end

		if ATTACHMENTS then
			if ATTACHMENTS.Leg1 then
				local prop = ents.CreateClientProp()
				prop:SetPos( prop3:LocalToWorld( ATTACHMENTS.Leg1.Pos ) )
				prop:SetAngles( prop3:LocalToWorldAngles( ATTACHMENTS.Leg1.Ang ) )
				prop:SetModel( ATTACHMENTS.Leg1.MDL )
				prop:SetParent( prop3 )
				prop:Spawn()
				self.IK_Joints[ index ].Attachment1 = prop
			end
			if ATTACHMENTS.Leg2 then
				local prop = ents.CreateClientProp()
				prop:SetPos( prop4:LocalToWorld( ATTACHMENTS.Leg2.Pos ) )
				prop:SetAngles( prop4:LocalToWorldAngles( ATTACHMENTS.Leg2.Ang ) )
				prop:SetModel( ATTACHMENTS.Leg2.MDL )
				prop:SetParent( prop4 )
				prop:Spawn()
				self.IK_Joints[ index ].Attachment2 = prop
			end
			if ATTACHMENTS.Foot then
				local prop = ents.CreateClientProp()
				prop:SetModel( ATTACHMENTS.Foot.MDL )
				prop:SetParent( prop2 )
				prop:Spawn()
				self.IK_Joints[ index ].Attachment3 = prop
			end
		end
	end

	if not IsValid( self.IK_Joints[ index ].LegRotCalc ) or not IsValid( self.IK_Joints[ index ].LegBaseRot ) or not IsValid( self.IK_Joints[ index ].LegEnt1 ) or not IsValid( self.IK_Joints[ index ].LegEnt2 ) or not IsValid( self.IK_Joints[ index ].LegEnt3 ) or not IsValid( self.IK_Joints[ index ].LegEnt4 ) then
		self:LegClearAll()

		return
	end

	self.IK_Joints[ index ].LegRotCalc:SetAngles(self.IK_Joints[ index ].LegBaseRot:LocalToWorldAngles( self.IK_Joints[ index ].LegBaseRot:WorldToLocal( ENDPOS ):Angle() ) )

	local LegRotCalcPos = self.IK_Joints[ index ].LegRotCalc:GetPos()

	local Dist = math.min( (LegRotCalcPos - ENDPOS ):Length(), L1 + L2)
	local Angle1 = 90 - math.deg( math.acos( (Dist ^ 2 + L1 ^ 2 - L2 ^ 2) / (2 * Dist * L1) ) )
	local Angle2 = math.deg( math.acos( (Dist ^ 2 + L2 ^ 2 - L1 ^ 2) / (2 * Dist * L2) ) ) + 90

	self.IK_Joints[ index ].LegEnt3:SetAngles( self.IK_Joints[ index ].LegRotCalc:LocalToWorldAngles( Angle(Angle1,180,180) ) )
	self.IK_Joints[ index ].LegEnt4:SetAngles( self.IK_Joints[ index ].LegRotCalc:LocalToWorldAngles( Angle(Angle2,180,180) ) )

	if self.IK_Joints[ index ].Attachment3 then
		self.IK_Joints[ index ].Attachment3:SetAngles( self:LocalToWorldAngles( ATTACHMENTS.Foot.Ang ) )
		self.IK_Joints[ index ].Attachment3:SetPos(self.IK_Joints[ index ].LegEnt2:GetPos() + self:GetForward() * ATTACHMENTS.Foot.Pos.x  + self:GetRight() * ATTACHMENTS.Foot.Pos.y + self:GetUp() * ATTACHMENTS.Foot.Pos.z )
	end


	--debug code
	local RFT = RealFrameTime()
	debugoverlay.Cross( self.IK_Joints[ index ].LegBaseRot:GetPos(), 15, RFT, debugred, true )
	debugoverlay.Line( self.IK_Joints[ index ].LegRotCalc:GetPos(), self.IK_Joints[ index ].LegEnt4:GetPos(), RFT, debuggreen, true )
	debugoverlay.Cross( self.IK_Joints[ index ].LegEnt4:GetPos(), 15, RFT, debugred, true )
	debugoverlay.Line( self.IK_Joints[ index ].LegEnt4:GetPos(), self.IK_Joints[ index ].LegEnt2:GetPos(), RFT, debuggreen, true )
	debugoverlay.Cross( self.IK_Joints[ index ].LegEnt2:GetPos(), 15, RFT, debugred, true )
	debugoverlay.Cross( self.IK_Joints[ index ].LegEnt1:GetPos(), 4, RFT, debugblue, true )
	debugoverlay.Sphere( self.IK_Joints[ index ].LegEnt3:GetPos(), 10, RFT, debugblue, true )
end

--addons/egm_lvs_ground/lua/entities/lvs_walker_hsd_leg.lua:
AddCSLuaFile()

ENT.Type            = "anim"

function ENT:SetupDataTables()
	self:NetworkVar( "Entity",0, "Base" )
	self:NetworkVar( "String",0, "LocationIndex" )
end

if SERVER then
	function ENT:Initialize()	
		self:SetModel( "models/blu/hsd_leg_1.mdl" )
		self:SetMoveType( MOVETYPE_NONE )
		self:SetSolid( SOLID_NONE )
	end

	function ENT:Think()
		return false
	end
else 
	include( "entities/lvs_walker_atte/cl_ikfunctions.lua" )

	local Length1 = 140
	local Length2 = 300

	local Length3 = 20
	local Length4 = 20

	local LegData1 = {
		Leg1 = {MDL = "models/blu/hsd_leg_2.mdl", Ang = Angle(0,-90,-90), Pos = Vector(0,0,0)},
		Leg2 = {MDL = "models/blu/hsd_leg_4.mdl", Ang = Angle(180,90,4), Pos = Vector(20,0,-12)},
		Foot = {MDL = "models/blu/hsd_foot.mdl", Ang = Angle(0,0,0), Pos = Vector(0,-2,0)}
	}

	local LegData2 = {
		Leg1 = {MDL = "models/blu/hsd_leg_3.mdl", Ang = Angle(0,90,-90), Pos = Vector(0,0,0)},
	}

	local StartPositions = {
		["FL"] = Vector(150,270,0),
		["FR"] = Vector(150,-270,0),
		["RL"] = Vector(-150,270,0),
		["RR"] = Vector(-150,-270,0),
	}

	local LocToID = {
		[1] = "RL",
		[2] = "FL",
		[3] = "RR",
		[4] = "FR",
	}

	function ENT:Think()
		local Base = self:GetBase()

		if not IsValid( Base ) then return end

		if Base:GetIsRagdoll() then 
			self:LegClearAll()

			return
		end

		local LocIndex = self:GetLocationIndex()

		if not Base:HitGround() then
			local Pos = Base:LocalToWorld( StartPositions[ LocIndex ] )

			self:RunIK( Pos, Base )
			self._OldPos = Pos
			self._smPos = Pos

			return
		end

		local Up = Base:GetUp()
		local Forward = Base:GetForward()
		local Vel = Base:GetVelocity()

		local Speed = Vel:Length()
		local VelForwardMul = math.min( Speed / 100, 1 )
		local VelForward = Vel:GetNormalized() * VelForwardMul + Forward * (1 - VelForwardMul)

		local TraceStart = Base:LocalToWorld( StartPositions[ LocIndex ] ) + VelForward * math.Clamp( 400 - Speed * 2, 100, 200 ) * VelForwardMul

		local trace = util.TraceLine( { 
			start = TraceStart + Vector(0,0,200),
			endpos = TraceStart - Vector(0,0,100), 
			filter = function( ent ) 
				if ent == Base or Base.HoverCollisionFilter[ ent:GetCollisionGroup() ] then return false end 

				return true
			end,
		} )

		local UpdateLeg = LocToID[ Base:GetUpdateLeg() ] == LocIndex

		self._OldPos = self._OldPos or trace.HitPos
		self._smPos = self._smPos or self._OldPos

		if self._OldUpdateLeg ~= UpdateLeg then
			self._OldUpdateLeg = UpdateLeg

			if UpdateLeg then
				self.UpdateNow = true
			end
		end

		if self.UpdateNow and not self.MoveLeg then
			sound.Play( Sound( "lvs/vehicles/hsd/hydraulic_stop0"..math.random(1,2)..".wav" ), self:GetPos(), SNDLVL_100dB )

			self.UpdateNow = nil
			self.MoveLeg = true
			self.MoveDelta = 0
		end

		local ShaftOffset = 0
		local ENDPOS = self._smPos + Up * 20

		if self.MoveLeg then
			local traceWater = util.TraceLine( {
				start = TraceStart + Vector(0,0,200),
				endpos = ENDPOS,
				filter = Base:GetCrosshairFilterEnts(),
				mask = MASK_WATER,
			} )

			if traceWater.Hit then
				local T = CurTime()

				if (self._NextFX or 0) < T then
					self._NextFX = T + 0.05
	
					local effectdata = EffectData()
						effectdata:SetOrigin( traceWater.HitPos )
						effectdata:SetEntity( Base )
						effectdata:SetMagnitude( 50 )
					util.Effect( "lvs_hover_water", effectdata )
				end
			end

			if self.MoveDelta >= 1 then
				self.MoveLeg = false
				self.MoveDelta = nil

				sound.Play( Sound( "lvs/vehicles/hsd/footstep0"..math.random(1,3)..".wav" ), ENDPOS, SNDLVL_100dB )

				local effectdata = EffectData()
					effectdata:SetOrigin( trace.HitPos )
				util.Effect( "lvs_walker_stomp", effectdata )

				sound.Play( Sound( "lvs/vehicles/hsd/hydraulic_start0"..math.random(1,2)..".wav" ), self:GetPos(), SNDLVL_100dB )
			else
				self.MoveDelta = math.min( self.MoveDelta + RealFrameTime() * 2, 1 )
	
				self._smPos = LerpVector( self.MoveDelta, self._OldPos, trace.HitPos )

				local MulZ =  math.max( math.sin( self.MoveDelta * math.pi ), 0 )

				ShaftOffset = MulZ ^ 2 * 30
				ENDPOS = ENDPOS + Up * MulZ * 50
			end
		else
			self._OldPos = self._smPos
		end

		self:RunIK( ENDPOS, Base, ShaftOffset )
	end

	function ENT:RunIK( ENDPOS, Base, shaftoffset )
		shaftoffset = shaftoffset or 0

		local Ang = Base:WorldToLocalAngles( (ENDPOS - self:GetPos()):Angle() )

		self:SetAngles( Base:LocalToWorldAngles( Angle(0,Ang.y + 90,0) ) )

		local ID = self:LookupAttachment( "lower" )
		local Att = self:GetAttachment( ID )

		if not Att then return end

		local Pos, Ang = WorldToLocal( ENDPOS, (ENDPOS - Att.Pos):Angle(), Att.Pos, self:LocalToWorldAngles( Angle(0,-90,0) ) )

		local STARTPOS = Att.Pos

		self:GetLegEnts( 1, Length1, Length2, self:LocalToWorldAngles( Angle(0,180,135) ), STARTPOS, ENDPOS, LegData1 )

		if not self.IK_Joints[ 1 ] or not IsValid( self.IK_Joints[ 1 ].Attachment2 ) then return end

		local shaft = self.IK_Joints[ 1 ].Attachment2

		shaft:SetPoseParameter( "extrude", shaftoffset )
		shaft:InvalidateBoneCache()

		local ID1 = self:LookupAttachment( "upper" )
		local Start = self:GetAttachment( ID1 )

		if not Start then return end

		local ID2 = shaft:LookupAttachment( "upper_end" )
		local End = shaft:GetAttachment( ID2 )

		if not End then return end

		self:GetLegEnts( 2, Length3, Length4, self:LocalToWorldAngles( Angle(0,0,-45) ), Start.Pos, End.Pos, LegData2 )

		if not self.IK_Joints[ 2 ] or not IsValid( self.IK_Joints[ 2 ].Attachment1 ) then return end

		local strut = self.IK_Joints[ 2 ].Attachment1
		strut:SetPoseParameter( "extrude", (Start.Pos - End.Pos):Length() )
		strut:InvalidateBoneCache()
	end

	function ENT:OnRemove()
		self:OnRemoved()
	end

	function ENT:Draw()
		local Base = self:GetBase()

		if not IsValid( Base ) then return end

		if Base:GetIsRagdoll() then return end

		self:DrawModel()
	end
end
--lua/entities/mace_windu_council_chair.lua:
ENT.RenderGroup = RENDERGROUP_BOTH
ENT.Base = "base_anim"
ENT.Type = "vehicle"

ENT.PrintName = "Mace Windu Council Chair"
ENT.Author = "Syphadias, Liam0102s Help"
ENT.Category = "Star Wars Vehicles: Chairs"
ENT.AutomaticFrameAdvance = true
ENT.Spawnable = false;
ENT.AdminSpawnable = false;
ENT.EntModel = "models/starwars/syphadias/jedi_knight_jedi_academy/council_chairs/mace_windu_council_chair.mdl";

list.Set("SWVehicles", ENT.PrintName, ENT);
if SERVER then



AddCSLuaFile();
function ENT:SpawnFunction(pl, tr)
	local e = ents.Create("mace_windu_council_chair");
	e:SetPos(tr.HitPos + Vector(0,0,20));
	e:SetAngles(Angle(0,pl:GetAimVector():Angle().Yaw,0));
	e:Spawn();
	e:Activate();
	return e;
end

function ENT:Initialize()

	self:SetModel(self.EntModel);
	self:PhysicsInit(SOLID_VPHYSICS);
	self:SetMoveType(MOVETYPE_VPHYSICS);
	self:SetSolid(SOLID_VPHYSICS);
	self:StartMotionController();
	self:SetUseType(SIMPLE_USE);
	self:SetRenderMode(RENDERMODE_TRANSALPHA);

	self:SecretChair(self:GetPos()+self:GetUp()*10+self:GetForward()*4,self:GetAngles()+Angle(0,-90,15)); // Will most likely require tinkering for position
	
	local phys = self:GetPhysicsObject()

	if(phys:IsValid()) then
		phys:Wake()
		phys:SetMass(100000)
	end
end

function ENT:Exit(kill)
	self.BaseClass.Exit(self,kill);
	if(IsValid(p)) then
		p:SetEyeAngles(self:GetAngles() + Angle(0,180,0));
	end
end

function ENT:SecretChair(pos,ang)

	local e = ents.Create("prop_vehicle_prisoner_pod");
	e:SetPos(pos);
	e:SetAngles(ang);
	e:SetParent(self);
	e:SetModel("models/nova/airboat_seat.mdl");
	e:SetRenderMode(RENDERMODE_TRANSALPHA);
	e:SetColor(Color(255,255,255,0));
	e:Spawn();
	e:Activate();
	e.IsSyphSeat = true;
	self.Chair = e;
end

hook.Add("PlayerEnteredVehicle","SyphSeatEnter", function(p,v)
	if(IsValid(p) and IsValid(v)) then
		if(v.IsSyphSeat) then
			p:SetNWEntity("SyphSeat",v)
		end
	end
end)

hook.Add("PlayerLeaveVehicle","SyphSeatExit", function(p,v)
	if(IsValid(p) and IsValid(v)) then
		if(v.IsSyphSeat) then
			p:SetNWEntity("SyphSeat",NULL)
		end
		p:SetPos(v:GetPos()+v:GetUp()*10+v:GetForward()*50)
		p:SetEyeAngles(Angle(0,v:GetAngles().y+90,0))
	end
end)

function ENT:Use(p)
	
	if(!IsValid(self.Chair)) then return end;
	p:EnterVehicle(self.Chair);

end

end

if CLIENT then
	
	function ENT:Draw() self:DrawModel() end
	
	local View = {}
	hook.Add("CalcView", "SyphSeatView", function()

		local p = LocalPlayer();
		local Seat = p:GetNWEntity("SyphSeat",NULL);

		if(IsValid(Seat)) then
			if(Seat:GetThirdPersonMode()) then
				local pos = Seat:GetPos()+LocalPlayer():GetAimVector():GetNormal()*-100+Seat:GetUp()*175;
				local face = ((Seat:GetPos() + Vector(0,0,100))- pos):Angle();
					View.origin = pos;
					View.angles = face;
				return View;
			end
		end
	end)
	
	hook.Add( "ShouldDrawLocalPlayer", "SyphSeatPlayerDraw", function( p )
		local Seat = p:GetNWEntity("SyphSeat",NULL);
		if(IsValid(Seat)) then
			if(Seat:GetThirdPersonMode()) then
				return true;
			end
		end
	end);
end
--addons/egm_tfa_mines/lua/entities/mine_base/cl_init.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--              Mines            	 --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--        Mines | Base Entity        --
---------------------------------------

include("shared.lua")
--addons/egm_tfa_mines/lua/entities/mine_emp/shared.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--              Mines            	 --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--       	  Mines | EMP       	 --
---------------------------------------

ENT.Base = "mine_base"

ENT.PrintName = "EMP Mine"
ENT.Author = "Deltaa"
ENT.Category = "SW:RP (Republik)"

ENT.Skin = 2

ENT.Spawnable = true

ENT.DroidModels = {
	["models/kingpommes/starwars/playermodels/astromech.mdl"] = true,
	["models/kingpommes/starwars/playermodels/gnk.mdl"] = true,
	["models/kingpommes/starwars/playermodels/lin.mdl"] = true,
	["models/kingpommes/starwars/playermodels/mouse.mdl"] = true,
	["models/kingpommes/starwars/playermodels/wed.mdl"] = true,
	["models/kingpommes/starwars/misc/droids/r5_j2.mdl"] = true,
	["models/kingpommes/starwars/misc/droids/r4_i9.mdl"] = true,
	["models/sally/tkaro/bx_commando_droid.mdl"] = true,
	["models/player/hydro/b2_battledroid/b2_battledroid.mdl"] = true,
	["models/player/hydro/b1_battledroids/specialist/b1_battledroid_specialist.mdl"] = true,
	["models/player/hydro/b1_battledroids/officer/b1_battledroid_officer.mdl"] = true,
	["models/player/hydro/b1_battledroids/heavy/b1_battledroid_heavy.mdl"] = true,
	["models/player/hydro/b1_battledroids/assault/b1_battledroid_assault.mdl"] = true,
	["models/player/jellik/starwars/highsinger.mdl"] = true,
	["models/tfa/comm/gg/pm_sw_grievous.mdl"] = true,
	["models/player/t3_01.mdl"] = true,
	["models/player/t3_02.mdl"] = true,
	["models/player/t3_03.mdl"] = true,
	["models/player/t3_04.mdl"] = true,
	["models/sgg/starwars/battledroid.mdl"] = true,
	["models/player/sgg/starwars/battledroid.mdl"] = true,
	["models/sgg/starwars/battledroid_commander.mdl"] = true,
	["models/sgg/starwars/battledroid_geo.mdl"] = true,
	["models/sgg/starwars/battledroid_pilot.mdl"] = true,
	["models/sgg/starwars/battledroid_security.mdl"] = true,
	["models/player/sgg/starwars/battledroid.mdl"] = true,
	["models/player/sgg/starwars/battledroid_commander.mdl"] = true,
	["models/player/sgg/starwars/battledroid_geo.mdl"] = true,
	["models/player/sgg/starwars/battledroid_pilot.mdl"] = true,
	["models/player/sgg/starwars/battledroid_security.mdl"] = true,
	["models/player/hevoc/b1_battledroids/firefighter/b1_battledroid_firefighter.mdl"] = true,
	["models/player/hydro/b2_battledroid/b2_battledroid.mdl"] = true,
	["models/player/tiki/med_droid.mdl"] = true,
	["models/player/valley/medicaldroid.mdl"] = true,
	["models/player/valley/policedroid.mdl"] = true,
	["models/tfa/comm/gg/npc_cit_sw_droid_b1.mdl"] = true,
	["models/tfa/comm/gg/npc_cit_sw_droid_b2.mdl"] = true,
	["models/tfa/comm/gg/npc_cit_sw_droid_b2_gunvariant.mdl"] = true,
	["models/tfa/comm/gg/npc_cit_sw_droid_commander.mdl"] = true,
	["models/tfa/comm/gg/npc_cit_sw_droid_commando.mdl"] = true,
	["models/tfa/comm/gg/npc_cit_sw_droid_tactical.mdl"] = true,
	["models/tfa/comm/gg/npc_comb_sw_droid_b1.mdl"] = true,
	["models/tfa/comm/gg/npc_comb_sw_droid_b2.mdl"] = true,
	["models/tfa/comm/gg/npc_comb_sw_droid_b2_gunvariant.mdl"] = true,
	["models/tfa/comm/gg/npc_comb_sw_droid_b2_staticarm.mdl"] = true,
	["models/tfa/comm/gg/npc_comb_sw_droid_commander.mdl"] = true,
	["models/tfa/comm/gg/npc_comb_sw_droid_commando.mdl"] = true,
	["models/tfa/comm/gg/npc_comb_sw_droid_tactical.mdl"] = true,
	["models/tfa/comm/gg/npc_comb_sw_g_droid_b1.mdl"] = true,
	["models/tfa/comm/gg/npc_comb_sw_t_droid_b1.mdl"] = true,
	["models/tfa/comm/gg/npc_comb_x_droid_b1.mdl"] = true,
	["models/tfa/comm/gg/npc_reb_sw_g_droid_b1.mdl"] = true,
	["models/tfa/comm/gg/npc_reb_sw_t_droid_b1.mdl"] = true,
	["models/tfa/comm/gg/pm_sw_droid_b1.mdl"] = true,
	["models/tfa/comm/gg/pm_sw_droid_b2.mdl"] = true,
	["models/tfa/comm/gg/pm_sw_droid_b2_gunvariant.mdl"] = true,
	["models/tfa/comm/gg/pm_sw_droid_commander.mdl"] = true,
	["models/tfa/comm/gg/pm_sw_droid_commando.mdl"] = true,
	["models/tfa/comm/gg/pm_sw_droid_tactical.mdl"] = true,
	["models/tfa/comm/gg/pm_sw_g_droid_b1.mdl"] = true,
	["models/tfa/comm/gg/pm_sw_t_droid_b1.mdl"] = true,
	["models/kingpommes/emperors_tower/ph_props/gnk_droid/gnk_droid.mdl"] = true,
	["models/kingpommes/emperors_tower/ph_props/mouse_droid/mouse_droid.mdl"] = true,
	["models/kingpommes/starwars/misc/droids/gnk_550.mdl"] = true,
	["models/kingpommes/starwars/misc/droids/lin_droid.mdl"] = true,
	["models/kingpommes/starwars/misc/droids/r2_q5.mdl"] = true,
	["models/starwars/stan/droidekas/droideka.mdl"] = true,
	["models/player/r2d2.mdl"] = true,
	["models/player/r2kt.mdl"] = true,
	["models/player/r4p17.mdl"] = true,
	["models/player/r4_imperial.mdl"] = true,
	["models/player/r5blue.mdl"] = true,
	["models/kingpommes/emperors_tower/ph_props/lin_droid/lin_droid.mdl"] = true,
	["models/kingpommes/emperors_tower/ph_props/wed_15/wed_15.mdl"] = true,
	["models/player/c3po.mdl"] = true,
	["models/tfa/comm/gg/pm_sw_magna_guard_combined.mdl"] = true,
	["models/tfa/comm/gg/pm_sw_magna_guard_season4.mdl"] = true,
	["models/tfa/comm/gg/pm_sw_magna_guard_trainer.mdl"] = true,
	["models/npc/starwars/crabby/crabdroid.mdl"] = true,
	["models/tactical_black/pm_droid_tactical_black.mdl"] = true,
	["models/tactical_blue/pm_droid_tactical_blue.mdl"] = true,
	["models/tactical_gold/pm_droid_tactical_gold.mdl"] = true,
	["models/tactical_purple/pm_droid_tactical_purple.mdl"] = true,
	["models/tactical_red/pm_droid_tactical_red.mdl"] = true,
	["models/super_tactical_kalani/pm_droid_tactical_kalani.mdl"] = true,
	["models/super_tactical_stuxnet/pm_droid_tactical_stuxnet.mdl"] = true,
	["models/player/b1battledroids/b1_base.mdl"] = true,
	["models/npc/starwars/dwarfspider/dwarfspiderdroid.mdl"] = true
}
--addons/egm_tfa_mines/lua/entities/mine_training/cl_init.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--              Mines            	 --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--         Mines | Incendiary        --
---------------------------------------

include("shared.lua")
--addons/mortar/lua/entities/mortar/cl_init.lua:
include("shared.lua")

function ENT:Draw()
    self:DrawModel()
end
--addons/mortar/lua/entities/mortar_bomb_shell/cl_init.lua:
include("shared.lua")

function ENT:Draw()
    self:DrawModel()
end
--addons/mortar/lua/entities/mortar_fire_shell/shared.lua:
ENT.Type			=	"anim"
ENT.Base			=	"base_entity"
ENT.PrintName		=	"[DU] Mortar Fire Shell"
ENT.Spawnable		=	false
ENT.Category 		=   "DolUnity"
--lua/entities/npc_nightsister_undead/shared.lua:
ENT.Base = "base_ai"
ENT.Type = "ai"

ENT.PrintName = "CGI Dathomir Warriors"
ENT.Author = "Xystus234-base, OkFellow Designer"
ENT.Contact = ""
ENT.Information		= ""
ENT.Category		= "SNPCs"

ENT.Spawnable = false
ENT.AdminSpawnable = false

ENT.AutomaticFrameAdvance = true


/*---------------------------------------------------------
Name: PhysicsCollide
Desc: Called when physics collides. The table contains
data on the collision
//-------------------------------------------------------*/
function ENT:PhysicsCollide( data, physobj )
end
 
 
/*---------------------------------------------------------
Name: PhysicsUpdate
Desc: Called to update the physics .. or something.
//-------------------------------------------------------*/
function ENT:PhysicsUpdate( physobj )
end
  
/*---------------------------------------------------------
Name: SetAutomaticFrameAdvance
Desc: If you're not using animation you should turn this
off - it will save lots of bandwidth.
//-------------------------------------------------------*/
function ENT:SetAutomaticFrameAdvance( bUsingAnim )

self.AutomaticFrameAdvance = bUsingAnim

end 
--lua/entities/obj_patrolpoint/shared.lua:
ENT.Type 			= "point"
ENT.Base 			= "base_gmodentity"
ENT.PrintName		= "Patrol Point"
ENT.Author			= "Silverlan"

ENT.Spawnable			= false
ENT.AdminSpawnable		= false

--lua/entities/pfx1_00.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Fire [v_2]"
ENT.Category         = "PPE: Fire & Smoke"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[1]campfire1"
--lua/entities/pfx1_06.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Flamethrower 1"
ENT.Category         = "PPE: Fire & Smoke"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[1]flamethrower_basic"
--lua/entities/pfx1_06~.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Flamethrower 1 [Large]"
ENT.Category         = "PPE: Fire & Smoke"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[1]flamethrower_large"
--lua/entities/pfx1_08__l.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Large Fire [Red]"
ENT.Category         = "PPE: Fire & Smoke"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[1]_large_campfire_red"
--lua/entities/pfx1_08_l.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Large Fire [Green]"
ENT.Category         = "PPE: Fire & Smoke"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[1]_large_campfire_green"
--lua/entities/pfx1_08_~a_l.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Large Fire [Purple]"
ENT.Category         = "PPE: Fire & Smoke"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[1]_large_campfire_purple"
--lua/entities/pfx1_08~_l.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Large Fire [Blue]"
ENT.Category         = "PPE: Fire & Smoke"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[1]_large_campfire_blue"
--lua/entities/pfx1_09.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Gasleak flame"
ENT.Category         = "PPE: Fire & Smoke"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[1]g_leak_flame"
--lua/entities/pfx1_0a.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Cigarette/Pipe smoke"
ENT.Category         = "PPE: Fire & Smoke"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[1]cig_smoke*"
--lua/entities/pfx1_0b.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Candle flame"
ENT.Category         = "PPE: Fire & Smoke"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[1]candle_flame"
--lua/entities/pfx1_0d.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Lifting Smoke [Small]"
ENT.Category         = "PPE: Fire & Smoke"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[1]smoke_lifting_01"
--lua/entities/pfx1_0f.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Colorful Smoke Cloud"
ENT.Category         = "PPE: Fire & Smoke"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[1]_smoke_colorful_1"
--lua/entities/pfx2_02_s.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Gushing Blood"
ENT.Category         = "PPE: Other"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[2]gushing_blood"



--lua/entities/pfx2_04~.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Swirl 2"
ENT.Category         = "PPE: Other"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[2]swirl_rnd"
--lua/entities/pfx3_01.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Tree Leafs 1"
ENT.Category         = "PPE: Nature"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[3]leaves_env"



--lua/entities/pfx4_02~.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Red Jet [Smokeless]"
ENT.Category         = "PPE: Tech"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[4]jet_r*"

--lua/entities/pfx4_06.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Energy Rod"
ENT.Category         = "PPE: Tech"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[4]energy_rod_b"
--lua/entities/pfx4_06_3.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Yellow Energy Rod"
ENT.Category         = "PPE: Tech"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[4]energy_rod_y"
--lua/entities/pfx5_00.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Black Hole"
ENT.Category         = "PPE: Cosmic"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[5]black_hole"
--lua/entities/pfx5_00_ss.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Micro Black Hole"
ENT.Category         = "PPE: Cosmic"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[5]black_hole_mmicro"
--lua/entities/pfx5_03.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Simple Galaxy Model"
ENT.Category         = "PPE: Cosmic"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[5]simple_galaxy"
--lua/entities/pfx6_02.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Bullet Tracer"
ENT.Category         = "PPE: Weapons"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[6]bullet_tracer_generic"
--lua/entities/pfx8_03_alt.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Green Portal"
ENT.Category         = "PPE: Magic"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[8]magic_portal*"
--lua/entities/pfx8_06.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Magic Orb 2"
ENT.Category         = "PPE: Magic"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[8]orb_1"
--lua/entities/plo_koon_council_chair.lua:
ENT.RenderGroup = RENDERGROUP_BOTH
ENT.Base = "base_anim"
ENT.Type = "vehicle"

ENT.PrintName = "Plo Koon Council Chair"
ENT.Author = "Syphadias, Liam0102s Help"
ENT.Category = "Star Wars Vehicles: Chairs"
ENT.AutomaticFrameAdvance = true
ENT.Spawnable = false;
ENT.AdminSpawnable = false;
ENT.EntModel = "models/starwars/syphadias/jedi_knight_jedi_academy/council_chairs/plo_koon_council_chair.mdl";

list.Set("SWVehicles", ENT.PrintName, ENT);
if SERVER then



AddCSLuaFile();
function ENT:SpawnFunction(pl, tr)
	local e = ents.Create("plo_koon_council_chair");
	e:SetPos(tr.HitPos + Vector(0,0,20));
	e:SetAngles(Angle(0,pl:GetAimVector():Angle().Yaw,0));
	e:Spawn();
	e:Activate();
	return e;
end

function ENT:Initialize()

	self:SetModel(self.EntModel);
	self:PhysicsInit(SOLID_VPHYSICS);
	self:SetMoveType(MOVETYPE_VPHYSICS);
	self:SetSolid(SOLID_VPHYSICS);
	self:StartMotionController();
	self:SetUseType(SIMPLE_USE);
	self:SetRenderMode(RENDERMODE_TRANSALPHA);

	self:SecretChair(self:GetPos()+self:GetUp()*10+self:GetForward()*4,self:GetAngles()+Angle(0,-90,15)); // Will most likely require tinkering for position
	
	local phys = self:GetPhysicsObject()

	if(phys:IsValid()) then
		phys:Wake()
		phys:SetMass(100000)
	end
end

function ENT:SecretChair(pos,ang)

	local e = ents.Create("prop_vehicle_prisoner_pod");
	e:SetPos(pos);
	e:SetAngles(ang);
	e:SetParent(self);
	e:SetModel("models/nova/airboat_seat.mdl");
	e:SetRenderMode(RENDERMODE_TRANSALPHA);
	e:SetColor(Color(255,255,255,0));
	e:Spawn();
	e:Activate();
	e.IsSyphSeat = true;
	self.Chair = e;
end

hook.Add("PlayerEnteredVehicle","SyphSeatEnter", function(p,v)
	if(IsValid(p) and IsValid(v)) then
		if(v.IsSyphSeat) then
			p:SetNWEntity("SyphSeat",v)
		end
	end
end)

hook.Add("PlayerLeaveVehicle","SyphSeatExit", function(p,v)
	if(IsValid(p) and IsValid(v)) then
		if(v.IsSyphSeat) then
			p:SetNWEntity("SyphSeat",NULL)
		end
		p:SetPos(v:GetPos()+v:GetUp()*10+v:GetForward()*50)
		p:SetEyeAngles(Angle(0,v:GetAngles().y+90,0))
	end
end)

function ENT:Use(p)
	
	if(!IsValid(self.Chair)) then return end;
	p:EnterVehicle(self.Chair);

end

end

if CLIENT then
	
	function ENT:Draw() self:DrawModel() end
	
	local View = {}
	hook.Add("CalcView", "SyphSeatView", function()

		local p = LocalPlayer();
		local Seat = p:GetNWEntity("SyphSeat",NULL);

		if(IsValid(Seat)) then
			if(Seat:GetThirdPersonMode()) then
				local pos = Seat:GetPos()+LocalPlayer():GetAimVector():GetNormal()*-100+Seat:GetUp()*175;
				local face = ((Seat:GetPos() + Vector(0,0,100))- pos):Angle();
					View.origin = pos;
					View.angles = face;
				return View;
			end
		end
	end)
	
	hook.Add( "ShouldDrawLocalPlayer", "SyphSeatPlayerDraw", function( p )
		local Seat = p:GetNWEntity("SyphSeat",NULL);
		if(IsValid(Seat)) then
			if(Seat:GetThirdPersonMode()) then
				return true;
			end
		end
	end);
end
--lua/entities/rail_shell/cl_init.lua:
 include('shared.lua')     
 //[[---------------------------------------------------------     
 //Name: Draw     Purpose: Draw the model in-game.     
 //Remember, the things you render first will be underneath!  
 //-------------------------------------------------------]]  
 function ENT:Draw()      
 // self.BaseClass.Draw(self)  
 -- We want to override rendering, so don't call baseclass.                                   
 // Use this when you need to add to the rendering.        
 self.Entity:DrawModel()       // Draw the model.   
 end  
--addons/egm_tfa_grenades/lua/entities/rw_sw_ent_nade_poison_stun.lua:
ENT.Type = "anim"
ENT.Base = "base_entity"
ENT.PrintName = "explosive Grenade"
ENT.Author = ""
ENT.Information = ""
ENT.Spawnable = false
ENT.AdminSpawnable = false

ENT.BounceSound = Sound("TFA_CSGO_SmokeGrenade.Bounce")
ENT.ExplodeSound = Sound("weapons/tfa_starwars/Smoke_Explosive_Puff_01.wav")

ENT.RemoveDelay = 30

AddCSLuaFile()

function ENT:Initialize()
	if SERVER then
		self:SetModel("models/forrezzur/dioxisgrenade.mdl")
		self:PhysicsInit(SOLID_VPHYSICS)
		self:SetMoveType(MOVETYPE_VPHYSICS)
		self:SetSolid(SOLID_VPHYSICS)
		self:SetCollisionGroup(COLLISION_GROUP_DEBRIS)

		local phys = self:GetPhysicsObject()
		if phys:IsValid() then
			phys:Wake()
			phys:SetBuoyancyRatio(0)
		end

		self:SetNWInt("duration", self.RemoveDelay)

		self.Delay = CurTime() + 2
		self.NextParticle = 0
		self.ParticleCount = 0
		self.First = true
		self.IsDetonated = false
	end

	self:EmitSound("TFA_CSGO_SmokeGrenade.Throw")
end

function ENT:PhysicsCollide(data, physobj)
	if SERVER then
		self.HitP = data.HitPos
		self.HitN = data.HitNormal

		if self:GetVelocity():Length() > 60 then
			self:EmitSound(self.BounceSound)
		end
	end
end

function ENT:Think()
	if SERVER then
		if CurTime() > self.Delay then
			if self.IsDetonated == false then
				self:Detonate(self,self:GetPos())
				self.DetonatePos = self:GetPos()
				self.IsDetonated = true
			end
		end
	end

	if self.IsDetonated == true then
		for k, v in pairs( ents.FindInSphere( self.DetonatePos, 216 ) ) do
			if v:IsPlayer() or v:IsNPC() then

				if Realism.Droids[v:GetModel()] then continue end
				if v:GetNWBool("Realism.UsingBreather", false) then continue end

				damage = DamageInfo()
				damage:SetDamage( math.random( 3, 7 ) )

				if IsValid(self:GetOwner()) then
					damage:SetAttacker( self:GetOwner() )
				end
				damage:SetDamageType( DMG_NERVEGAS )
				damage:SetDamageCustom(8888)
				v:TakeDamageInfo( damage )
				if isfunction(v.ViewPunch) then
					v:ViewPunch( Angle( math.random( -3, 3 ), math.random( -3, 3 ), math.random( -3, 3 ) ) )
				end
				v.LastDeathStunned = true
				v.LastDeathDuration = 60

				timer.Create("EGM.ALCS.StunTimer." .. v:SteamID64(), 1, 1, function()
					if not IsValid(v) then return end
					if not v:Alive() then return end

					v.LastDeathStunned = nil
					v.LastDeathDuration = nil
				end)
			end
		end
	end

	self:NextThink( CurTime() + 0.25 )

	return true
end

function ENT:Detonate(self,pos)
	self.ParticleCreated = false
	self.ExtinguishParticleCreated = false

	if SERVER then
		if not self:IsValid() then return end
		self:SetNWBool("IsDetonated",true)
		self:EmitSound(self.ExplodeSound)

		local gas = EffectData()
		gas:SetOrigin(pos)
		gas:SetEntity(self)
		util.Effect("tfa_csgo_poisonade_stun", gas)
	end

	if SERVER then
		SafeRemoveEntityDelayed(self, self.RemoveDelay)
	end
end

function ENT:Draw()
	if CLIENT then
		self:DrawModel()
	end
end
--gamemodes/starwarsrp/entities/entities/swrp_detonator/shared.lua:
if SERVER then AddCSLuaFile() end

DEFINE_BASECLASS("base_anim")

ENT.AutomaticFrameAdvance = true

util.PrecacheModel("models/weapons/w_swrcdeton.mdl")
util.PrecacheSound("buttons/spark6.wav")
util.PrecacheSound("ambient/fire/mtov_flame2.wav")

function ENT:Draw()
	self:DrawModel()
end

function ENT:OnRemove()
	if self.BurnSound then
		self.BurnSound:Stop()
	end
end

function ENT:Use( activator, caller )
	self:ActivateDetonator()
end

function ENT:ActivateDetonator()
	if self.Activated then return end

	self.Activated = true

	self:ResetSequence(self:LookupSequence("w_tnt_wick"))

	self.BurnSound = CreateSound(self, Sound("weapons/sw_detonator.wav"))
	self.BurnSound:Play()

	timer.Simple(3, function()
		if IsValid(self) then
			self:Detonate()
		end
	end)
end

function ENT:OnTakeDamage(info)
	if info and info:IsExplosionDamage() then
		self:Detonate()
	end
end

function ENT:Initialize()
	self:SetModel("models/weapons/w_swrcdeton.mdl")

	if SERVER then
		self:PhysicsInit(SOLID_VPHYSICS)
		self:SetMoveType(MOVETYPE_VPHYSICS)
		self:SetSolid(SOLID_VPHYSICS)

		self:PhysWake()
	end
end

function ENT:Detonate()
	if self.Refuse then return end

	self.Refuse = true

	util.BlastDamage(self, self, self:GetPos(), 600, 30000)

	local effectdata = EffectData()
	effectdata:SetOrigin(self:GetPos())
	effectdata:SetNormal(self:GetPos():GetNormalized())
	effectdata:SetEntity(self)
	effectdata:SetScale(1.8)
	effectdata:SetRadius(70)
	effectdata:SetMagnitude(18)

	util.Effect("swrp_cinematicboom", effectdata)
	util.ScreenShake(self:GetPos(), 10, 5, 1, 3000)

	self:Remove()
end
--addons/starwars_universe/lua/entities/swu_so_base/shared.lua:
ENT.Type = "anim"
ENT.PrintName = "[SWU] Space Object"
ENT.Author = "The Coding Ducks"
ENT.Information = ""
ENT.Category = "[SWU] Universe"

ENT.CollisionRange = 1

ENT.Spawnable = false

function ENT:SetupDataTables()
    self:NetworkVar("String", 0, "Id")
    self:NetworkVar("Vector", 0, "UniversePos")
    self:NetworkVar("Angle", 0, "UniverseAngles")

    self:NetworkVar("Float", 0, "BaseScale")

    self:NetworkVar("Bool", 0, "Animated")

    self:SetupExtraDataTables()
end

function ENT:SetupExtraDataTables()
end

function ENT:PreInitialize()

end

function ENT:Initialize()
    self:PreInitialize()

    self:SetMoveType(MOVETYPE_NONE)
    self:SetSolid(SOLID_NONE)

    self:SetModel(self.Model or "models/hunter/blocks/cube025x025x025.mdl")
    self:SetModelScale(self:GetBaseScale())

    if (CLIENT) then
        self:SetPredictable(true)
    end

    self:InheritanceChildInitialize()
end

function ENT:InheritanceChildInitialize()
end

--{
--    id
--    pos
--    angle
--}
function ENT:Load(info)
    self:SetId(info.id)
    self:SetUniversePos(info.pos or Vector())
    self:SetUniverseAngles(info.angle or Angle())
    self:SetBaseScale(info.baseScale or 1)

    self:PostLoad()
end

function ENT:PostLoad()

end

-- TODO: Work with universe pos and don't calculate and change their positions if not visible
function ENT:UpdatePos(newPos, dist, maxDist)
    if (dist > maxDist) then
        self:SetNoDraw(true)
    elseif (newPos:WithinAABox(SWU.config.skyboxBoundaries.min, SWU.config.skyboxBoundaries.max)) then
        self:SetNoDraw(false)
        self:SetPos(newPos)
    end
end

local function f(x)
    return math.abs(x - 1)
end

function ENT:Think()
    if (not IsValid(SWU.Controller)) then return end

    local worldPosRotated, worldPos = SWU:CalculateWorldPos(self:GetUniversePos())
    local maxDist = 9 * 9
    local dist = SWU.Controller:GetShipPos():DistToSqr(self:GetUniversePos())

    self:UpdatePos(worldPosRotated, dist, maxDist)
    self.worldPos = worldPos

    if (self:GetNoDraw()) then return end

    local scale = math.min(1, dist / maxDist)
    self:Rescale(f(scale))
    self:SetAngles(self:GetUniverseAngles() + SWU.Controller:GetInternalShipAngles())

    if (self:GetAnimated()) then
        self:NextThink(CurTime())
        return true
    end
end

function ENT:Rescale(scale)
    self:SetModelScale(scale)
end

function ENT:GetCollisionRange()
    return self.CollisionRange
end

function ENT:Collide()
end

--addons/starwars_universe/lua/entities/swu_so_planet/shared.lua:
ENT.Type = "anim"
ENT.PrintName = "[SWU] Planet"
ENT.Base = "swu_so_base"
ENT.Model = "models/hunter/misc/sphere1x1.mdl"
ENT.AutomaticFrameAdvance = true

local function ColorToString(c)
    return c.r .. " " .. c.g .. " " .. c.b .. " " .. c.a
end

local clouds = {
    "the-coding-ducks/swu/planets/clouds/cloud_1",
    "the-coding-ducks/swu/planets/clouds/cloud_2",
    "the-coding-ducks/swu/planets/clouds/cloud_3",
}

function ENT:InheritanceChildInitialize()
    self:Rescale(1)

    if (CLIENT) then
        table.insert(SWU.Map, self)
    end
end

function ENT:Load(info)
    self:SetId(info.name)
    self:SetUniversePos(info.pos or Vector())
    self:SetUniverseAngles(info.angle or Angle())
    self:SetAtmosphereColor(ColorToString(info.atmosphereColor or Color(0,0,120,5)))
    self:SetTerrainMaterial(info.terrain)
    self:SetCloudMaterial(info.clouds or "")
    self:SetWeather(info.weather or false)
    self:SetBaseScale(info.baseScale or (SWU.config.planetBaseSize or 10))
    if (self:GetWeather() and info.clouds == nil) then
        self:SetCloudMaterial(clouds[math.random(1, #clouds + 1)] or "")
    end

    self:SetMaterial(info.terrain)
    self:PostLoad()
end

function ENT:SetupExtraDataTables()
    self:NetworkVar("String", 1, "TerrainMaterial")
    self:NetworkVar("String", 2, "CloudMaterial")
    self:NetworkVar("String", 3, "AtmosphereColor")
    self:NetworkVar("Bool", 1, "Weather")
end

function ENT:Rescale(scale)
    scale = scale * self:GetBaseScale()

    self:SetModelScale(scale)

    local renderBoundsMin, renderBoundsMax = self:GetModelRenderBounds()
    self.PlanetRadius = math.abs(renderBoundsMin.x * scale)

    if (CLIENT) then
        self:SetRenderBounds(renderBoundsMin * 1.005 * scale, renderBoundsMax * 1.01 * scale)
    end
    self.CollisionRange = self.PlanetRadius
end

function ENT:Collide()
    if (self:GetAnimated()) then return end

    util.ScreenShake(Vector(), 10, 5, 10, 50000)
    self:SetAnimated(true)
    self:SetModel("models/mig/planet.mdl")
    self:SetMaterial(self:GetTerrainMaterial())

    self:Think()
    self:ResetSequence("explode")
    self:SetPlaybackRate(0.05)
end

function ENT:OnRemove()
    if (CLIENT) then
        table.RemoveByValue(SWU.Map, self)
    end
end

--addons/tfa_base/lua/entities/tfbow_arrow/shared.lua:
local vector_origin = Vector()

ENT.Type = "anim"
ENT.PrintName = "TFBow Arrow"
ENT.Author = "TheForgottenArchitect"
ENT.Contact = "Don't"
ENT.Purpose = "Arrow Entity"
ENT.Instructions = "Spawn this with a velocity, get rich"

local function GetBoneCenter(ent, bone)
	local bonechildren = ent:GetChildBones(bone)

	if #bonechildren <= 0 then
		return ent:GetBonePosition(bone)
	else
		local bonepos = ent:GetBonePosition(bone)
		local tmppos = bonepos

		if tmppos then
			for i = 1, #bonechildren do
				local childpos = ent:GetBonePosition(bonechildren[i])

				if childpos then
					tmppos = (tmppos + childpos) / 2
				end
			end
		else
			return ent:GetPos()
		end

		return tmppos
	end
end

function ENT:GetClosestBonePos(ent, pos)
	local i, count, dist, ppos, cbone
	i = 1
	count = ent:GetBoneCount()
	cbone = 0
	dist = 99999999
	ppos = ent:GetPos()

	while (i < count) do
		local bonepos = GetBoneCenter(ent, i)

		if bonepos:Distance(pos) < dist then
			dist = bonepos:Distance(pos)
			cbone = i
			ppos = bonepos
		end

		i = i + 1
	end

	return ppos, cbone
end

local cv_al = GetConVar("sv_tfa_arrow_lifetime")
local cv_ht = GetConVar("host_timescale")

function ENT:Initialize()
	if SERVER then
		if not IsValid(self.myowner) then
			self.myowner = self:GetOwner()

			if not IsValid(self.myowner) then
				self.myowner = self
			end
		end

		timer.Simple(0, function()
			if self.model then
				self:SetModel(self.model)
			end
		end)

		if cv_al:GetInt() ~= -1 then
			timer.Simple( cv_al:GetFloat() + 5, function()
				if IsValid(self) then
					self:Remove()
				end
			end)
		end

		self:PhysicsInit(SOLID_VPHYSICS)
		self:SetMoveType(MOVETYPE_VPHYSICS)
		self:SetSolid(SOLID_VPHYSICS)
		local phys = self:GetPhysicsObject()

		if (phys:IsValid()) then
			phys:Wake()

			if self.velocity then
				phys:SetVelocityInstantaneous(self.velocity)
			end

			phys:EnableCollisions(false)
			self:StartMotionController()
			self:PhysicsUpdate(phys, 0.1 * cv_ht:GetFloat() )
		end
	end

	self:SetNW2Vector("lastpos", self:GetPos())

	if not self.mydamage then
		self.mydamage = 60
	end

	if not self.gun then
		if IsValid(self:GetOwner()) and self:GetOwner():IsPlayer() then
			self:UpdateGun()
		else
			timer.Simple(0, function()
				if IsValid(self) and IsValid(self:GetOwner()) and self:GetOwner():IsPlayer() then
					self:UpdateGun()
				end
			end)
		end
	end
end

function ENT:UpdateGun()
	local wep = self:GetOwner():GetActiveWeapon()

	if IsValid(wep) then
		self.gun = wep:GetClass()
	end
end

local wl,tracedata,tr

local cv_fm = GetConVar("sv_tfa_force_multiplier")

function ENT:HitCB(a,b,c)
	c:SetDamageType(bit.bor(DMG_NEVERGIB, DMG_CLUB))

	if IsValid(self) and IsValid(self:GetOwner()) then
		if b.HitWorld then
			local arrowstuck = ents.Create("tfbow_arrow_stuck")
			arrowstuck:SetModel(self:GetModel())
			arrowstuck.gun = self.gun
			arrowstuck:SetPos(tr.HitPos)
			local phys = self:GetPhysicsObject()
			arrowstuck:SetAngles((phys:GetVelocity()):Angle())
			arrowstuck:Spawn()
		else
			if IsValid(b.Entity) then
				if (not b.Entity:IsWorld()) then
					local arrowstuck = ents.Create("tfbow_arrow_stuck_clientside")
					arrowstuck:SetModel(self:GetModel())
					arrowstuck:SetPos(tr.HitPos)
					local ang = self:GetAngles()
					arrowstuck.gun = self.gun
					arrowstuck:SetAngles(ang)
					arrowstuck.targent = tr.Entity
					arrowstuck.targphysbone = tr.PhysicsBone
					arrowstuck:Spawn()
				else
					local arrowstuck = ents.Create("tfbow_arrow_stuck")
					arrowstuck:SetModel(self:GetModel())
					arrowstuck.gun = self.gun
					arrowstuck:SetPos(tr.HitPos)
					arrowstuck:SetAngles(self:GetAngles())
					arrowstuck:Spawn()
				end
			end
		end

		self:Remove()
	elseif IsValid(self) then
		self:Remove()
	end
end

function ENT:Think()
	wl = self:WaterLevel()

	if not self.prevwaterlevel then
		self.prevwaterlevel = wl
	end

	if self.prevwaterlevel ~= wl and wl - self.prevwaterlevel >= 1 then
		--print(wl)
		local ef = EffectData()
		ef:SetOrigin(self:GetPos())
		util.Effect("watersplash", ef)
	end

	self.prevwaterlevel = wl

	if wl >= 2 then
		local phys = self:GetPhysicsObject()

		if IsValid(phys) then
			phys:SetVelocity(phys:GetVelocity() * math.sqrt(9 / 10))
		end
	end

	tracedata = {}
	tracedata.start = self:GetNW2Vector("lastpos", self:GetPos())
	tracedata.endpos = self:GetPos()
	tracedata.mask = MASK_SOLID
	tracedata.filter = {self.myowner, self:GetOwner(), self}
	tr = util.TraceLine(tracedata)

	--self:SetAngles((((tracedata.endpos-tracedata.start):GetNormalized()+self:GetAngles():Forward())/2):Angle())
	if (tr.Hit and tr.Fraction < 1 and tr.Fraction > 0) then
		debugoverlay.Line(tracedata.start, tr.HitPos, 10, Color(255, 0, 0, 255), true)
		debugoverlay.Cross(tr.HitPos, 5, 10, Color(255, 0, 0, 255), true)

		if SERVER then
			--[[
			local bul ={}
			bul.Attacker=self:GetOwner() and self:GetOwner() or self:GetOwner()
			bul.Spread=vector_origin
			bul.Src=tracedata.start
			bul.Force=self.mydamage*0.25*GetConVarNumber("sv_tfbow_force_multiplier",1)
			bul.Damage=self.mydamage
			bul.Tracer	= 0							-- Show a tracer on every x bullets
			bul.TracerName = "None"
			bul.Dir=((tr.HitPos-bul.Src):GetNormalized())

			bul.Attacker:FireBullets( bul )
			]]
			--
			local bul = {}
			bul.Attacker = self:GetOwner() and self:GetOwner() or self:GetOwner()
			bul.Spread = vector_origin
			bul.Src = tracedata.start
			bul.Force = self.mydamage * 0.25 * cv_fm:GetFloat()
			bul.Damage = self.mydamage
			bul.Tracer = 0 -- Show a tracer on every x bullets
			bul.TracerName = "None"
			bul.Dir = (tr.HitPos - bul.Src):GetNormalized()

			bul.Callback = function(a, b, c)
				self:HitCB(a,b,c)
			end

			bul.Attacker:FireBullets(bul)
		end

		return
	end

	self:SetNW2Vector("lastpos", self:GetPos())
end

--addons/npc_droppod_tool/lua/entities/toods_dispenser/cl_init.lua:
include( "shared.lua" )

function ENT:Draw()
	self:DrawModel()
end
--addons/npc_droppod_tool/lua/entities/toods_dispenser/shared.lua:
ENT.Type             = "anim"
ENT.Base             = "base_anim"
ENT.Author = "Tood"

ENT.Spawnable = false
ENT.DoNotDuplicate = true
--lua/entities/tracking-device/shared.lua:
--[[---------------------------------------------------------------------------
This is an example of a custom entity.
---------------------------------------------------------------------------]]
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
ENT.PrintName = "Tracking Device"
ENT.Author = "Joe"
ENT.Spawnable = true
ENT.AdminSpawnable = false


--addons/emplacements/lua/entities/turret_40mm_frag/cl_init.lua:
 include('shared.lua')     
 //[[---------------------------------------------------------     
 //Name: Draw     Purpose: Draw the model in-game.     
 //Remember, the things you render first will be underneath!  
 //-------------------------------------------------------]]  
 function ENT:Draw()      
 // self.BaseClass.Draw(self)  
 -- We want to override rendering, so don't call baseclass.                                   
 // Use this when you need to add to the rendering.        
 self.Entity:DrawModel()       // Draw the model.   
 end  
--addons/emplacements/lua/entities/turret_bullets_deployable/shared.lua:
ENT.Type 			= "anim"
ENT.Base 			= "base_anim"

ENT.Category		= "CW:RP Geschütze"
ENT.PrintName 		= "Blaster Cannon Deployable"
ENT.Author			= "Wolly/BOT_09 | Airfox"
ENT.Spawnable		= true
ENT.AdminSpawnable	= false

ENT.IsTurret		= true

ENT.TurretFloatHeight = 3
ENT.TurretModelOffset = Vector(0,0,40)
ENT.TurretTurnMax = 0.7

ENT.LastShot = 0
ENT.ShotInterval = 0.1


function ENT:SetupDataTables()
	self:DTVar("Entity",0,"Shooter")
	self:DTVar("Entity",1,"ShootPos")
end

function ENT:SetShooter(plr)
	self.Shooter = plr
	self:SetDTEntity(0,plr)
end

function ENT:GetShooter(plr)
	if SERVER then
		return self.Shooter
	elseif CLIENT then
		return self:GetDTEntity(0)
	end
end


function ENT:Use(plr)
	if not self:ShooterStillValid() then
		self:SetShooter(plr)
		self:StartShooting()
		self.ShooterLast = plr
	else
		if plr == self.Shooter then
			self:SetShooter(nil)
			self:FinishShooting()
		end
	end
end


function ENT:ShooterStillValid()
	local shooter = nil
	if SERVER then
		shooter = self.Shooter
	elseif CLIENT then
		shooter = self:GetDTEntity(0)
	end

	return IsValid(shooter) and shooter:Alive() and ((self:GetPos()+self.TurretModelOffset):Distance(shooter:GetShootPos())<=60)
end



function ENT:DoShot()
	if self.LastShot + self.ShotInterval < CurTime() then
		if SERVER then
			self:EmitSound(self.ShotSound)
		end

		if IsValid(self.shootPos) and SERVER then

			self.shootPos:FireBullets({
				Num = 1,
				Src = self.shootPos:GetPos() + self.shootPos:GetAngles():Forward() * 10,
				Dir = self.shootPos:GetAngles():Forward() * 1,
				Spread = Vector(0.025, 0.025, 0),
				Tracer = 0,
				Force = 2,
				Damage = 30,
				Attacker = self.Shooter,
				Callback = function(attacker, tr, dmginfo)

					local tracerEffect=EffectData()
					tracerEffect:SetStart(self.shootPos:GetPos())
					tracerEffect:SetOrigin(tr.HitPos)
					tracerEffect:SetScale(6000)
					util.Effect("rw_sw_laser_blue", tracerEffect)

					if not (tr.HitSky or (IsValid(tr.Entity) and tr.Entity:IsPlayer())) then
						util.Decal("fadingscorch", tr.HitPos + tr.HitNormal, tr.HitPos - tr.HitNormal)

						local effect = EffectData()
						effect:SetOrigin(tr.HitPos)
						effect:SetNormal(tr.HitNormal)
						util.Effect("effect_sw_impact", effect)

						local random = math.random(1, 24)

						if random < 10 then
							random = "0"..tostring(random)
						else
							random = tostring(random)
						end

						local effect = EffectData()
						effect:SetOrigin(tr.HitPos)
						effect:SetStart(tr.StartPos)
						effect:SetDamageType(DMG_BULLET)

						util.Effect("RagdollImpact", effect)
					end
				end
			})

			self:GetPhysicsObject():ApplyForceCenter( self:GetRight()*50000 )
		end

		self.LastShot = CurTime()
	end
	
end



function ENT:Think()
	
	if not IsValid(self.turretBase) and SERVER then
		SafeRemoveEntity(self)
	else
		--[[if IsValid(self.shootPos) or self.shootPos==NULL then
			if CLIENT then
				
				self.shootPos=self:GetDTEntity(1)
			elseif SERVER then
				
				self:SetDTEntity(1,self.shootPos)
			end
		end]]
		if IsValid(self) then
			
			if SERVER then
				self.BasePos=self.turretBase:GetPos()
				self.OffsetPos=self.turretBase:GetAngles():Up()*1
			end
			
			if self:ShooterStillValid() then
			
				if SERVER then
					local offsetAng=(self:GetAttachment(self.MuzzleAttachment).Pos-self:GetDesiredShootPos()):GetNormal()
					local offsetDot=self.turretBase:GetAngles():Right():DotProduct(offsetAng)
					local HookupPos=self:GetAttachment(self.HookupAttachment).Pos
					if offsetDot>=self.TurretTurnMax then
						local offsetAngNew=offsetAng:Angle()
						offsetAngNew:RotateAroundAxis(offsetAngNew:Up(),90)
						
						self.OffsetAng=offsetAngNew
						
					end
				end
				
				local pressKey=IN_BULLRUSH
				if CLIENT and game.SinglePlayer() then
					pressKey=IN_ATTACK
					
				end
				
				self.Firing=self:GetShooter():KeyDown(pressKey)
				
			else
				self.Firing=false
				if SERVER then
					self.OffsetAng=self.turretBase:GetAngles()
					
					self:SetShooter(nil)
					self:FinishShooting()
				end
			end
			
			if self.Firing then
				self:DoShot()
			end
			self:NextThink(CurTime())
			return true
		end
	end
end	
--lua/entities/vfire/shared.lua:
--[[-------------------------------------------------------------------------
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

vFire by Vioxtar

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
---------------------------------------------------------------------------]]

AddCSLuaFile()
DEFINE_BASECLASS( "base_anim" )

--[[-------------------------------------------------------------------------

	Shared Functionalities

---------------------------------------------------------------------------]]
if SERVER or CLIENT then

	--[[-------------------------------------------------------------------------
	Only network a single state integer value
	---------------------------------------------------------------------------]]
	function ENT:SetupDataTables()
		 -- 1 is Tiny, 7 is Inferno
		self:NetworkVar("Int", 0, "FireState")
	end

	--[[-------------------------------------------------------------------------
	Set starting parameters of a fire entity
	---------------------------------------------------------------------------]]
	function ENT:Initialize()

		self:SetFireState(1)

		-- Make sure the fire is not directly interactable or seen
		self:SetCollisionGroup(COLLISION_GROUP_IN_VEHICLE)
		self:DrawShadow(false)

		-- Set the dummy model so we aren't a hidden error
		self:SetModel(vFireDummyModel)

		local parent = self:GetParent()
		if !IsValid(parent) then
			parent = game.GetWorld()
		end

		-- Store the parent
		self.parent = parent
		if !parent.fires then parent.fires = {} end
		parent.fires[self] = parent:WorldToLocal(self:GetPos())

		if SERVER then
			-- Life misc
			self.life = 1
			self.feed = 0

			-- Two relaxing variables (one goes up, one goes down) used to decided possible fire states
			if !self.stateUp then self.stateUp = 0 end -- Mainly needed for optimization
			if !self.stateDown then self.stateDown = vFireMaxState end -- Acts as our max state

			-- Used to catch touching entities so we can burn them
			self:SetTrigger(true)
			
			-- A table holding whatever entity we're burning
			self.burning = {}

			-- What is the material type of this fire?
			self.matType = util.QuickTrace(self:GetPos(), self:GetForward() * -10).MatType or -1

			-- Initialize think timings
			self.nextFuelThink = 0
			self.nextLifeThink = 0
			self.nextEatThink = 0
			self.nextBurnThink = 0
			self.nextDropThink = 0
			self.nextSpreadThink = 0
		end

		if CLIENT then
			self.lastState = 1
			self.visState = 1

			if vFireIsCharacter(parent) and !game.SinglePlayer() then
				self:SetPredictable(true)
			end

			-- We use a pixel handle pVis, and an animation factor a to assist animations
			self.pVis = util.GetPixelVisibleHandle()
			self.a = 1

			-- Start out without LOD
			self.LOD = false
			self.visLOD = false
			
			-- Initialize think timings
			self.nextClusterThink = 0
			self.nextParticlesThink = 0
			self.nextAnimationThink = 0

			-- Start working
			self:RedoParticles(1)
		end
		
		-- Prioritize the new fire for responsiveness
		self:Prioritize(5)

		self.initialized = true
		hook.Run("vFireCreated", self, parent)

		if SERVER then self:FindCluster() end

	end


	--[[-------------------------------------------------------------------------
	Remove ourselves from needed tables
	---------------------------------------------------------------------------]]
	function ENT:OnRemove()
		-- Remove the fire entity from the parent's fire tables
		local parent = self.parent
		if IsValid(parent) then
			if parent.fires then parent.fires[self] = nil end
		end

		-- This may not be necessary, but just in case: destroy all particle systems
		if CLIENT then
			if self.flames then
				if self.flames:IsValid() then self.flames:StopEmission() end
			end
			if self.base then
				if self.base:IsValid() then self.base:StopEmission() end
			end
		end

		local cluster = self.cluster
		if IsValid(cluster) then
			cluster:RemFire(self)
		end

		if self.initialized then
			hook.Run("vFireRemoved", self, parent)
		end

	end

	--[[-------------------------------------------------------------------------
	Fire prioritization - priotizied fires will not be throttled
	---------------------------------------------------------------------------]]
	function ENT:IsPrioritized()
		return self.prioritized
	end
	function ENT:UnPrioritize()
		self.prioritized = false
	end
	function ENT:Prioritize(priority, broadcast)
		if priority <= 0 then self:UnPrioritize() return end

		self.prioritized = true
		
		timer.Simple(priority, function()
			if IsValid(self) then
				self:UnPrioritize()
			end
		end)

		self:Think()

		if SERVER and broadcast then
			if player.GetCount() > 0 then
				net.Start("vFirePriority", true)
					net.WriteEntity(self)
					net.WriteInt(priority, 16)
				net.SendPVS(self:GetPos())
			end
		end
	end
	if SERVER then
		util.AddNetworkString("vFirePriority")
	end
	if CLIENT then
		net.Receive("vFirePriority", function()
			local fire = net.ReadEntity()
			local priority = net.ReadInt(16)
			timer.Simple(0, function()
				if !IsValid(fire) then return end
				if !fire.UnPrioritize or !fire.Prioritize then return end
				if priority <= 0 then
					fire:UnPrioritize()
				else
					fire:Prioritize(priority)
				end
			end)
		end)
	end


	--[[-------------------------------------------------------------------------
	Neighbor Functionalities
	---------------------------------------------------------------------------]]
	function ENT:GetClosestFire()
		if !IsValid(self.cluster) then return nil end

		if IsValid(self.closestFire) then
			return self.closestFire
		end
		
		-- The previous closest fire is invalid, find a new one
		local minDist = math.huge
		local cluster = self.cluster
		for k, fire2 in pairs(cluster.fires) do
			
			-- Return nil if there is no closest fire
			if self == fire2 then continue end

			local dist = cluster.distMem[self][fire2]
			if dist then
				if dist < minDist then
					self.closestFire = fire2
					minDist = dist
				end
			end
		end

		return self.closestFire, minDist
	end

	function ENT:IsBiggerThan(other)
		if SERVER then
			return self.life > other.life
		end
		if CLIENT then
			if self.GetFireState and other.GetFireState then
				return self:GetFireState() > other:GetFireState()
			else
				return false
			end
		end
	end

	function ENT:GetClosestSmallerFire()
		if !IsValid(self.cluster) then return nil end

		if IsValid(self.closestSmallerFire) then
			if !self:IsBiggerThan(self.closestSmallerFire) then
				self.closestSmallerFire = nil
			else
				return self.closestSmallerFire
			end
		end
		
		-- The previous closest fire is invalid, find a new one
		local minDist = math.huge
		local cluster = self.cluster
		for k, fire2 in pairs(cluster.fires) do
			
			-- Return nil if there is no closest fire
			if self == fire2 then continue end

			-- Don't account for bigger fires
			if !self:IsBiggerThan(fire2) then continue end

			local dist = cluster.distMem[self][fire2]
			if dist then
				if dist < minDist then
					self.closestSmallerFire = fire2
					minDist = dist
				end
			end
		end

		return self.closestSmallerFire, minDist
	end

	function ENT:GetClosestBiggerFire()
		if !IsValid(self.cluster) then return nil end

		if IsValid(self.closestBiggerFire) then
			if self:IsBiggerThan(self.closestBiggerFire) then
				self.closestBiggerFire = nil
			else
				return self.closestBiggerFire
			end
		end
		
		-- The previous closest fire is invalid, find a new one
		local minDist = math.huge
		local cluster = self.cluster
		for k, fire2 in pairs(cluster.fires) do
			
			-- Return nil if there is no closest fire
			if self == fire2 then continue end

			-- Don't account for smaller fires
			if self:IsBiggerThan(fire2) then continue end

			local dist = cluster.distMem[self][fire2]
			if dist then
				if dist < minDist then
					self.closestBiggerFire = fire2
					minDist = dist
				end
			end
		end

		return self.closestBiggerFire, minDist
	end

	--[[-------------------------------------------------------------------------
	Returns the fire's wind vector
	---------------------------------------------------------------------------]]
	function ENT:GetWindVector()

		-- Allow overriding of the wind vector
		local overrideWindVec = hook.Run("vFireOnCalculateWind", self)

		if isvector(overrideWindVec) then

			local length = overrideWindVec:Length()
			if length > 1 then
				overrideWindVec = overrideWindVec / length
			end
			return overrideWindVec

		else -- Do our own thing

			local exposure
			if self.cluster then
				exposure =  self.cluster.windExposure
			end

			if !exposure then
				exposure = math.Rand(0, 1)
			end

			return exposure * vFireGetWindVector()

		end
	end
end

--[[-------------------------------------------------------------------------

	Server Functionalities

---------------------------------------------------------------------------]]
if SERVER then
	--[[-------------------------------------------------------------------------
	Life and feed
	---------------------------------------------------------------------------]]
	function ENT:ChangeLife(newLife)
		self.life = math.min(newLife, vFireStateToLife(self.stateDown or vFireMaxLife))
	end

	function ENT:GiveLife(fire2, amount)
		local take = math.Min(amount, self.life)
		fire2:ChangeLife(fire2.life + take)
		self:ChangeLife(self.life - take)
	end

	function ENT:GiveFeed(fire2, amount)
		local take = math.Min(amount, self.feed)
		fire2.feed = fire2.feed + take
		self.feed = self.feed - take
	end

	function ENT:Eat(fire2)
		fire2:GiveLife(self, fire2.life)
		fire2:GiveFeed(self, fire2.feed)
		fire2:Remove()
	end

	function ENT:SoftExtinguish(amount)
		self:ChangeLife(self.life - amount)
	end

	--[[-------------------------------------------------------------------------
	Find clusters
	---------------------------------------------------------------------------]]
	function ENT:FindCluster()
		local foundCluster
		local minDist = math.huge

		local closeEnts = ents.FindInSphere(self:GetPos(), vFireClusterSize)
		for k, cluster in pairs(closeEnts) do
			-- We only care about fire clusters
			if cluster:GetClass() != "vfire_cluster" then continue end
			-- We have to be on the same parent
			if cluster.parent != self.parent then continue end
			-- We have to have matching material types
			if cluster.matType != self.matType then continue end

			-- Find the closest cluster
			local dist = self:GetPos():DistToSqr(cluster:GetPos())
			if dist < minDist then
				minDist = dist
				foundCluster = cluster
			end
		end

		if IsValid(foundCluster) then
			-- We found a cluster, add it
			foundCluster:AddFire(self)
		else
			-- We didn't find a cluster, create one of our own
			foundCluster = ents.Create("vfire_cluster")
			foundCluster:SetNW2Entity("ClusterParent", self.parent)
			foundCluster.matType = self.matType
			foundCluster:Spawn()

			foundCluster:AddFire(self)
		end
	end

	--[[-------------------------------------------------------------------------
	Burn activations
	---------------------------------------------------------------------------]]
	function ENT:AddBurning(ent)
		if self.burning[ent] or vFireIsVFireEnt(ent) or ent == self.parent then return end
		self.burning[ent] = ent
	end

	function ENT:RemoveBurning(ent)
		if self.burning[ent] then self.burning[ent] = nil end
	end

	-- We gonna burn shit
	function ENT:StartTouch(otherEnt)
		self:AddBurning(otherEnt)
	end

	-- No more burning shit
	function ENT:EndTouch(otherEnt)
		self:RemoveBurning(otherEnt)
	end

	--[[-------------------------------------------------------------------------
	Misc
	---------------------------------------------------------------------------]]
	function ENT:Drop()
		local dropPos = self:GetPos() + self:GetForward()
		local fireBall = CreateVFireBall(self.life, self.feed, dropPos, Vector(), self:GetOwner())
		self:Remove()
		return fireBall
	end

	function ENT:IsPotentiallyVisible()
		local cluster = self.cluster
		if cluster then
			return cluster.PVSLOD or true
		else
			return true
		end
	end

	function ENT:ImprovePlacement(targetState, parent)

		if !parent then parent = self.parent end
		
		local forward = self:GetForward()
		local pos = self:GetPos()

		local ignoreFraction = !parent:IsWorld()
		local offset
		if ignoreFraction then
			offset = Vector()
		else
			offset = forward
		end

		local tracePos = pos + offset

		local traceLen = 16.5
		local traceOffset = vFireBaseRadius(targetState) * 0.4
		local traceDir = forward * -traceLen
		
		local up = self:GetUp()
		local down = -up
		local right = self:GetRight()
		local left = -right

		-- We won't be able to improve if two opposite sides aren't determined 'good'
		local upTr = util.QuickTrace(tracePos + up * traceOffset, traceDir, function(ent) return ent == parent end)
		local downTr = util.QuickTrace(tracePos + down * traceOffset, traceDir, function(ent) return ent == parent end)
		local goodUp = upTr.Hit and upTr.Entity == parent and (ignoreFraction or upTr.Fraction > 0)
		local goodDown = downTr.Hit and downTr.Entity == parent and (ignoreFraction or downTr.Fraction > 0)

		if !goodUp and !goodDown then
			return false
		end


		local rightTr = util.QuickTrace(tracePos + right * traceOffset, traceDir, function(ent) return ent == parent end)
		local leftTr = util.QuickTrace(tracePos + left * traceOffset, traceDir, function(ent) return ent == parent end)
		local goodRight = rightTr.Hit and rightTr.Entity == parent and (ignoreFraction or rightTr.Fraction > 0)
		local goodLeft = leftTr.Hit and leftTr.Entity == parent and (ignoreFraction or leftTr.Fraction > 0)

		if !goodRight and !goodLeft then
			return false
		end


		-- We're good, find the average vector
		local sum = 0
		local sumVec = Vector()
		if goodUp then
			sum = sum + 1
			sumVec = sumVec + upTr.HitPos
		end
		if goodDown then
			sum = sum + 1
			sumVec = sumVec + downTr.HitPos
		end
		if goodRight then
			sum = sum + 1
			sumVec = sumVec + rightTr.HitPos
		end
		if goodLeft then
			sum = sum + 1
			sumVec = sumVec + leftTr.HitPos
		end

		if sum > 0 then
			local newPos = sumVec / sum

			tracePos = newPos + offset

			-- Fill the rest
			if !goodUp then
				upTr = util.QuickTrace(tracePos + up * traceOffset, traceDir, function(ent) return ent == parent end)
				goodUp = upTr.Hit and upTr.Entity == parent and (ignoreFraction or upTr.Fraction > 0)
				if !goodUp then return false end
			end

			if !goodDown then
				downTr = util.QuickTrace(tracePos + down * traceOffset, traceDir, function(ent) return ent == parent end)
				goodDown = downTr.Hit and downTr.Entity == parent and (ignoreFraction or downTr.Fraction > 0)
				if !goodDown then return false end
			end

			if !goodRight then
				rightTr = util.QuickTrace(tracePos + right * traceOffset, traceDir, function(ent) return ent == parent end)
				goodRight = rightTr.Hit and rightTr.Entity == parent and (ignoreFraction or rightTr.Fraction > 0)
				if !goodRight then return false end
			end

			if !goodLeft then
				leftTr = util.QuickTrace(tracePos + left * traceOffset, traceDir, function(ent) return ent == parent end)
				goodLeft = leftTr.Hit and leftTr.Entity == parent and (ignoreFraction or leftTr.Fraction > 0)
				if !goodLeft then return false end
			end

			if goodUp and goodDown and goodRight and goodLeft then

				-- Don't change the forward height
				if newPos != pos then

					-- Intersect with ray approach
					local fixedPos = util.IntersectRayWithPlane(newPos, forward, pos, forward)
					if fixedPos then
						newPos = fixedPos
					end

					-- Trace approach
					-- local fixTrace = util.QuickTrace(newPos + self:GetForward() * 10, -self:GetForward() * 10, hitParent(ent, parent))
					-- if fixTrace.Hit then
					-- 	newPos = fixTrace.HitPos
					-- end
				end

				return true, newPos
			end

		else
			return false
		end
		
	end

	function ENT:UpdateCollisionBounds(state)
		local col = vFireBaseRadius(state) * 0.2
		-- Update trigger bounds to damage whatever is close, but given enough time for players to escape
		self:SetCollisionBounds(Vector(-col, -col, -col), Vector(col, col, col))
		self:UseTriggerBounds(true, col)
	end

	--[[-------------------------------------------------------------------------
	Thinking tasks
	---------------------------------------------------------------------------]]
	function ENT:Think()
		
		-- Don't think at all if we don't have a parent
		if !IsValid(self.parent) and !self.parent:IsWorld() then self:Remove() return end
		
		
		local curTime = CurTime()
		-- Don't throttle prioritized fires
		local throttleAdd
		if self:IsPrioritized() then
			throttleAdd = 0
		else
			throttleAdd = vFireThinkThrottle
		end


		if curTime >= self.nextFuelThink then
			self:FuelThink()
			self.nextFuelThink = curTime + vFireFuelThinkTickRate + throttleAdd
		end

		if curTime >= self.nextLifeThink then
			self:LifeThink()
			self.nextLifeThink = curTime + vFireLifeThinkTickRate + throttleAdd
		end

		if curTime >= self.nextEatThink then
			self:EatThink()
			self.nextEatThink = curTime + vFireEatThinkTickRate + throttleAdd
		end

		if curTime >= self.nextBurnThink then
			self:BurnThink()
			self.nextBurnThink = curTime + vFireBurnThinkTickRate -- We're not throttling the burn task
		end

		local ran
		if curTime >= self.nextDropThink then
			if !ran then ran = math.random(0, 1000 + vFiresCount * 10) end
			self:DropThink(ran)
			self.nextDropThink = curTime + vFireDropThinkTickRate + throttleAdd
		end

		if curTime >= self.nextSpreadThink then
			if !ran then ran = math.random(0, 1000 + vFiresCount * 10) end
			self:SpreadThink(ran)
			self.nextSpreadThink = curTime + vFireSpreadThinkTickRate + throttleAdd
		end



		-- Our next think will always be the minimal of our next think tasks' timings
		local nextThink = math.Min(
			self.nextFuelThink,
			self.nextLifeThink,
			self.nextEatThink,
			self.nextBurnThink,
			self.nextDropThink,
			self.nextSpreadThink
		)


		self:NextThink(nextThink)
		return true

	end

	function ENT:FuelThink()

		local take = self.life

		-- Feed ourselves from the parent
		local fuel = vFireTakeFuel(self.parent, take * 2)
		if fuel > 0 then

			self.feed = self.feed + fuel

		else

			-- Take feed from the cluster, but only if we're new enough (we want to promote spreading...)
			if !self.clusterFuels then self.clusterFuels = 10 end
			if self.clusterFuels > 0 then
				local cluster = self.cluster
				if IsValid(cluster) then
					fuel = vFireTakeFuel(self.cluster, take)
					self.feed = self.feed + fuel
					self.clusterFuels = self.clusterFuels - 1
				end
			end

		end

		-- And take fuel from what we're burning
		local ent = table.Random(self.burning)
		if IsValid(ent) then
			local fuel = vFireTakeFuel(ent, take)
			if fuel > 0 then
				self.feed = self.feed + fuel
			end
		end
		
	end

	function ENT:LifeThink()
		-- Handle life and feed
		if (self.life <= 0) or self:WaterLevel() > 0 then
			-- We're dead, die
			self:Remove()
			return
		else
			
			-- We're alive, feed ourselves
			local feedSave = 5
			-- We want feed to be used faster on characters
			if vFireIsCharacter(self.parent) then
				feedSave = 1
			end
			local f = math.Min(math.Rand(0, self.feed / feedSave) + 1, self.feed)
			self.feed = self.feed - f

			-- We wish to end fires faster if we have a lot of fires for optimization purposes (but only if we're not prioritized)
			if self:IsPrioritized() then
				self:ChangeLife(self.life + f)
			else
				local decayMul = 1 - vFireDecayRate
				self:ChangeLife(self.life * decayMul + f - vFireLifeThrottle)
				-- If a fire isn't prioritized, we don't give it a second chance in fueling up
				if self.life <= 0 then self:Remove() return end
			end
		end

		-- Change the state, network it only if it changes
		local oldState = self:GetFireState()
		local state = vFireLifeToState(self.life)
		
		if state != oldState then -- We've changed states

			-- Relax our state limiters
			if state <= self.stateDown then

				if state > self.stateUp then -- We need to check if we can grow

					local canGrow, newPos
					
					while !canGrow do

						if state <= self.stateUp then break end

						canGrow, newPos = self:ImprovePlacement(state)

						if canGrow then -- We can grow, relax our stateUp

							self.stateUp = state -- stateUp moves upwards
							-- And set our improved position
							self:SetPos(newPos)


						else -- We can't grow, relax our stateDown

							-- Did we fail at even the smallest state?
							if state == 1 then
								-- Do nothing
								break
							end

							self.stateDown = state - 1 -- stateDown moves downwards

							-- Update our state and try again
							state = self.stateDown

						end
					end
				end
			end

			self:SetFireState(state)
			self:UpdateCollisionBounds(state)

		end
	end

	function ENT:EatThink()
		-- Eat up the nearest smaller fire if it's close enough (good for optimization),
		-- but only if we're not on a character, for animation/fidelity purposes
		if !vFireIsCharacter(self.parent) then
			local closestSmallerFire, closestSmallerFireDist = self:GetClosestSmallerFire()
			if IsValid(closestSmallerFire) and closestSmallerFireDist then
				if closestSmallerFireDist <= vFireBaseRadius(self:GetFireState()) * 0.7 then
					self:Eat(closestSmallerFire)
				end
			end
		end
	end

	function ENT:BurnThink()

		local damageEnabled = vFireEnableDamage and vFireDamageMultiplier > 0

		-- Who is the owner of the fire? This will likely be the doer of the damage
		local owner = self:GetOwner()
		if !IsValid(owner) then owner = nil end

		-- How much damage are we doing this burn cycle?
		local amount = self.life * math.Rand(0.01, 0.08) * vFireDamageMultiplier
		


		-- Loop through whatever we're burning
		for k, ent in pairs(self.burning) do
			
			if IsValid(ent) then

				-- Don't burn players that are in vehicles
				if ent:IsPlayer() and ent:InVehicle() and !vFireEnableDamageInVehicles then continue end

				if damageEnabled then

					-- Create the damage information
					local dmg = DamageInfo()

						-- Decide what this entity's best damage case should be... and cache it
						if ent.vFireDamageData == nil then
							vFireSetDamageData(ent)
						end

						if !ent.vFireDamageData then continue end
						
						dmg:SetDamage(amount * ent.vFireDamageData.dmgMul)
						dmg:SetDamageType(ent.vFireDamageData.dmgType)

						-- Who's in charge of doing the burning?
						local doer = owner or ent
						dmg:SetAttacker(doer)

						if ent.vFireDamageData.inflict then
							dmg:SetInflictor(doer) -- Not passing an inflictor can cause crashes on entities that want one
						end

					ent:TakeDamageInfo(dmg)

				end
				

				-- If we're burning a character, use the oppurtunity to spread to it
				if vFireIsCharacter(ent) and vFireEnableSpread then
					-- If we're burning an NPC, spread to it, if it's a player, lower the chance of spread
					if ent:IsPlayer() and math.random(1, 4) == 1 or !ent:IsPlayer() then
						local newFeed = self.feed + vFireTakeFuel(ent, 12)
						if newFeed > 0 then
							CreateVFire(ent, ent:GetPos(), Vector(), newFeed, self)
						end
					end
				end

			else
				
				-- The entity isn't valid, use the loop's oppurtunity to remove it
				self.burning[k] = nil

			end
		end



		-- Damage the parent as well (it's not in our burning table)
		local parent = self.parent

		if damageEnabled and !parent:IsWorld() then
			
			local dmg = DamageInfo()

				-- Decide what this entity's best damage case should be... and cache it
				if parent.vFireDamageData == nil then
					vFireSetDamageData(parent)
				end

				if !parent.vFireDamageData then return end

				dmg:SetDamage(amount * parent.vFireDamageData.dmgMul)
				dmg:SetDamageType(parent.vFireDamageData.dmgType)

				-- A workaround to find the doer of the damage
				local doer
				if parent:Health() - dmg:GetDamage() <= 0 then -- We're about to die, register the actual owner for the kill to register...
					doer = owner or parent
				else -- Set the attacker to itself, this makes NPCs have better reaction sounds... :/
					doer = parent
				end
				dmg:SetAttacker(doer)

				if parent.vFireDamageData.inflict then
					dmg:SetInflictor(doer) -- Not passing an inflictor can cause crashes on entities that want one
				end

			-- Finalize
			parent:TakeDamageInfo(dmg)

		end

		-- If we're on a player, drop (randomly) but only if the player has moved a certain distance
		if parent:IsPlayer() then
			if !self.stickToPlayer then self.stickToPlayer = math.random(1, self:GetFireState()) end
			if self.stickToPlayer > 0 then
				self.stickToPlayer = self.stickToPlayer - 1
			else
				self:Drop()
			end
		end
	end

	function ENT:DropThink(ran)
		if ran < 150 then
			if self.life < 7 then
				if self.cantDrop then return end

				local dropPos = self:GetPos() + self:GetForward()
				local tr = util.QuickTrace(dropPos, Vector(0, 0, -5))
				if !tr.Hit then
					self:Drop()
				else
					-- We're not mobile, and we can't drop, save further calculations
					self.cantDrop = !vFireIsMobile(self.parent)
				end
			end
		end
	end

	function ENT:SpreadThink(ran)
		-- Attempt to spread
		if vFireEnableSpread then

			if !self:IsPotentiallyVisible() then return end
			
			-- We only spread if our random variable is below 1000 - the more throttle there is, the higher the probability of ran being >= 1000
			-- and as a result, fire spreading is throttled
			if ran < 1000 then

				local forward = self:GetForward()

				if ran < 575 then -- Attempt to spread upwards

					local upwards = Vector(0, 0, 1)

					local dir = upwards + self:GetWindVector() + VectorRand()
					dir = dir * vFireBaseRadius(self:GetFireState())
					local tr = util.QuickTrace(self:GetPos(), dir, self.parent)
					if tr.Hit and tr.Fraction > 0 then
						local ent = tr.Entity
						if vFireIsVFireEnt(ent) then return end
						local newFeed = self.feed + vFireTakeFuel(ent, 12)
						if newFeed > 0 then
							CreateVFire(ent, tr.HitPos, tr.HitNormal, newFeed, self)
						end
					end

				else -- Attempt to spread on the ground

					local mul = vFireBaseRadius(self:GetFireState()) * math.Rand(0.775, 1)
					local dir = forward * -mul
					local ang = self:GetAngles()
					
					-- We use a constant spread angle to give fire spreading a sort of 'momentum'
					-- This value gets passed on to children fires with a slight offset
					if !self.spreadAng then self.spreadAng = math.Rand(0, 360) end
					
					ang:RotateAroundAxis(forward, self.spreadAng)
					local offset = ang:Right() * mul + forward * 2

					local pos = self:GetPos() + offset
					local tr = util.QuickTrace(pos, dir)
					local ent = tr.Entity
					if tr.Hit and (tr.Fraction > 0 or IsValid(ent)) then

						if vFireIsVFireEnt(ent) then return end

						local newFire
						local newFeed = self.feed + vFireTakeFuel(ent, 12)
						if newFeed > 0 then
							newFire = CreateVFire(ent, tr.HitPos, tr.HitNormal, newFeed, self)
						end
						
						if IsValid(newFire) then

							if self.spreadAng then
								-- Randomize the spread angle of next iterations
								local spreadAngRan = math.Rand(-60, 60)

								-- Pass the spread angle (plust the randomized addition) to the child to preserve momentum
								newFire.spreadAng = self.spreadAng + spreadAngRan

								-- Negate said randomized angle to our own - avoid unnecessary merges in the future
								self.spreadAng = self.spreadAng - spreadAngRan
							end

						else -- We hit something, but we failed to create a fire (likely merged), try again
							self.spreadAng = nil
						end

					else -- We didn't hit, try a different spread angle for next iterations
						self.spreadAng = nil
					end
				end
				
			end
		end
	end
end


--[[-------------------------------------------------------------------------

	Client Functionalities

---------------------------------------------------------------------------]]
if CLIENT then
	--[[-------------------------------------------------------------------------
	In charge of updating particle systems
	---------------------------------------------------------------------------]]
	function ENT:RedoParticles(state)

		if !IsValid(self) then return end

		local size = vFireStateToSize(state)

		if self.base then
			if self.base:IsValid() then 
				self.base:StopEmission()
			end
		end
		if self.flames then
			if self.flames:IsValid() then 
				self.flames:StopEmission()
			end
		end

		-- Should we create LOD'ed particles?
		self.visLOD = false
		local LODStr = ""
		if self.LOD == 1 then
			LODStr = "_LOD"
			self.visLOD = true
		end

		-- If we're on an animated surface, such as a player or an NPC, don't create the base
		if vFireIsCharacter(self.parent) then

			self.flames = CreateParticleSystem(
				self,
				"vFire_Flames_"..size..LODStr,
				0,
				0
			)

		else

			-- Spawn the systems in an offset
			local forward = self:GetForward()
			local offSet = forward

			-- Define a particle system offset so they're closer to the ground
			self.base = CreateParticleSystem(
				self,
				"vFire_Base_"..size..LODStr,
				0,
				0,
				offSet * (state - 1)
			)

			-- Have a slight chance (grows the smaller the flame) to make the flames smaller
			-- but that chance is reduced the further we are from an upright slope - small flames on walls look bad
			local chanceForSmallerFlame = -4.5 -- The less the higher the chance
			if forward.z < 1 then
				if forward.z < 0 then
					chanceForSmallerFlame = 0
				else -- We're somewhere in the range between 1 (straight floor) and 0 (upright wall), bother to multiply
					chanceForSmallerFlame = chanceForSmallerFlame * forward.z
				end
			end
			if math.Rand(chanceForSmallerFlame, state) < 0 then

				if state > 1 then
					state = state - 1
					size = vFireStateToSize(state)
					self.flames = CreateParticleSystem(
						self,
						"vFire_Flames_"..size..LODStr,
						0,
						0
					)
				end

			else
				self.flames = CreateParticleSystem(
					self,
					"vFire_Flames_"..size..LODStr,
					0,
					0
				)
			end

		end

		-- Store the state that's actually visible for consistent animations
		self.visState = state

		-- Update our animation as soon as possible for visual consistency
		self:AnimationThink()
	end

	--[[-------------------------------------------------------------------------
	Flame animation tweaks via pull force control point
	---------------------------------------------------------------------------]]
	-- The stateMul table defines how far to set the pull control point for each state
	-- The bigger the distance, the less effect the control point has
	local stateMul = {30, 45, 65, 115, 245, 345, 400}
	-- The minimum flame pull strength, used to avoid dividing by zero
	local minStrength = 1 / 1000000000
	-- Pulls the flames towards a direction, with an optional strength ranging between [0, 1]
	function ENT:FlameSetDirection(dir, strength)
		if IsValid(self.flames) then
			if dir and strength then
				
				dir:Normalize()
				dir = dir * stateMul[self.visState or self:GetFireState()]
				local pos
				-- The bigger the strength, the closer the control point is
				if strength then
					pos = self:GetPos() + dir / math.Clamp(strength, minStrength, 1)
				else
					pos = self:GetPos() + dir
				end

				vFirePullParticlesToPos(self.flames, pos)

			else -- Reset the flame direction
				vFirePullParticlesToPos(self.flames, Vector())
			end
		end
	end
	-- Pulls the base towards a given point
	function ENT:BasePullToPoint(pos)
		if IsValid(self.base) then
			vFirePullParticlesToPos(self.base, pos)
		end
	end


	--[[-------------------------------------------------------------------------
	In charge of animating assisting elements such as glow and light
	---------------------------------------------------------------------------]]
	ENT.RenderGroup = RENDERGROUP_TRANSLUCENT

	local lightmat = Material("sprites/light_ignorez")

	local lightDecay = 600
	local lightCalls = {}
	for i = 1, vFireMaxState do
		lightCalls[i] = {}
	end
	local glowCalls = {}

	local blue = 10
	local yellow = 100

	-- Used for optimization purposes
	-- local draws = 0

	function ENT:Draw()

		-- We're very harsh with our LODifying, fuck beautiful sprites and glow, we need the FPS
		if self.LOD == 1 then return end

		-- Count how many fires are drawn
		-- draws = draws + 1

		local state = self.visState

		-- We don't want to draw stuff for tiny fires, but we also want a gradual draw fade out
		-- Lerp the animation factor to 0 for tiny fires, proceed as normal for other fires
		if state == 1 then
			self.a = Lerp(FrameTime() * 2, self.a, 0)
		else
			self.a = Lerp(FrameTime() * 2, self.a, math.Rand(0, state) * 5)
		end

		local a = self.a

		-- Only continue if the animation parameter is big enough (save calculations for tiny fires)
		if a < 0.1 then return end


		local pos = self:GetPos() + self:GetForward() * 7
		local aSqrd = a * a


		if vFireEnableGlows then
			local vis = util.PixelVisible(pos, 1, self.pVis)
			if vis > 0 then -- Only draw the sprite if it'll be visible
				local glowSize = vis * aSqrd * 6
				-- Load information onto our glow calls table
				table.insert(glowCalls, {
					pos = pos,
					glowSize = glowSize,
					aSqrd = aSqrd
				})
			end
		end


		-- Don't draw lights if we're LODed at all
		if self.LOD then return end


		if vFireEnableLights then
			-- Load information onto our light calls table
			local entIndex = self:EntIndex()
			lightCalls[state][entIndex] = {
				pos, -- Position of the light
				a, -- Brightness
				aSqrd * 2 -- Size
			}
		end
	end

	-- Sum the total fire draws
	-- hook.Add("PostRender", "vFireCountDrawnFires", function()
		-- vFiresDrawn = draws
		-- draws = 0
	-- end)


	-- Draw our glow calls, arguably better than drawing seperate sprites because we
	-- only set our material once?
	hook.Add("PostDrawTranslucentRenderables", "_vFireLightCallbacks", function()
		render.SetMaterial(lightmat)
		for key, glowData in pairs(glowCalls) do
			render.DrawSprite(
				glowData.pos, -- Position
				glowData.glowSize, -- Width
				glowData.glowSize, -- Height (or the other way around)
				Color(255, yellow, blue, math.Min(glowData.aSqrd * 0.85, 255)) -- Color
			)
		end
		glowCalls = {}
	end)

	-- We need to cache our r_maxdlights ConVar for the sake of performance
	local maxLightsConVar = GetConVar("r_maxdlights")
	local maxLights = maxLightsConVar:GetInt()
	cvars.AddChangeCallback("r_maxdlights", function()
		maxLights = maxLightsConVar:GetInt()
	end)

	-- Draw our light calls so that priority is given to larger fires
	hook.Add("Think", "_vFireLightCallbacks", function()

		-- Draw lights from biggest to smallest to prioritize big lights in case of limit breach
		local lightsDrawn = 0
		for state = vFireMaxState, 1, -1 do
			for entIndex, callback in pairs(lightCalls[state]) do
				local dLight = DynamicLight(entIndex)
				if dLight then
					dLight.Pos = callback[1]
					dLight.r = 255
					dLight.g = yellow
					dLight.b = blue
					dLight.Brightness = callback[2] * vFireLightMul
					dLight.Decay = lightDecay
					dLight.Size = callback[3]
					dLight.DieTime = CurTime() + 10

					lightsDrawn = lightsDrawn + 1
					if lightsDrawn >= maxLights then break end
				end
			end
			lightCalls[state] = {}
			if lightsDrawn >= maxLights then break end
		end

	end)






	--[[-------------------------------------------------------------------------
	Thinking tasks
	---------------------------------------------------------------------------]]
	function ENT:Think()

		local curTime = CurTime()

		-- Don't throttle prioritized fires
		local throttleAdd
		if self:IsPrioritized() then
			throttleAdd = 0
		else
			throttleAdd = vFireThinkThrottle
		end



		if curTime >= self.nextClusterThink then
			self:ClusterThink()
			self.nextClusterThink = curTime + vFireClusterThinkTickRate + throttleAdd
		end

		if curTime >= self.nextParticlesThink then
			self:ParticlesThink()
			self.nextParticlesThink = curTime + vFireParticlesThinkTickRate + throttleAdd
		end

		if curTime >= self.nextAnimationThink then
			self:AnimationThink()
			self.nextAnimationThink = curTime + vFireAnimationThinkTickRate + throttleAdd
		end


		
		-- Our next think will always be the minimal of our next think tasks' timings
		local nextThink = math.Min(
			self.nextClusterThink,
			self.nextParticlesThink,
			self.nextAnimationThink
		)

		-- We would like to introduce some timing differences between fires to avoid obvious update intervals
		local ranTime = math.Rand(-0.1, 0.1)
		self:SetNextClientThink(nextThink + ranTime)

		return true -- We wish to override ticking rate
	end

	function ENT:ClusterThink()
		-- Add to a nearby fire cluster if we aren't in one yet
		local netCluster = self:GetNW2Entity("FireCluster")
		if IsValid(netCluster) and netCluster.AddFire then
			if !self.cluster or self.cluster != netCluster then
				netCluster:AddFire(self)
			end
		end
	end

	function ENT:ParticlesThink()
		-- Check if we should LOD up
		if IsValid(self.cluster) then
			-- Use the cluster LOD to avoid LOD calculations for every fire
			self.LOD = self.cluster.LOD
		else
			self.LOD = vFireGetLOD(self)
		end

		local shouldRedoParticles = false

		-- Handle state changes
		local lastState = self.lastState
		local state = self:GetFireState()
		self.lastState = state
		if state != lastState then -- We changed states

			shouldRedoParticles = true

			-- Play a woosh sound, approximate a noisy lifePercent
			if !self.visLOD then
				if math.random(1, 3) == 1 then
					local lifePercent = state * math.Rand(0.5, 1.25) / vFireMaxState
					sound.Play(
						"ambient/fire/mtov_flame2.wav",		-- Sound
						self:GetPos(),						-- Position
						80,									-- Level
						140 - 100 * lifePercent,			-- Pitch
						math.min(lifePercent, 1)			-- Volume
					)
				end
			end
			
			-- Make sure we'll always draw ourselves
			local renderSize = state * 25
			self:SetRenderBounds(Vector(0, 0, 0), Vector(0, 0, 0), Vector(renderSize, renderSize, renderSize))
		end

		local shouldParticlesLOD = false
		if self.LOD == 1 then shouldParticlesLOD = true end

		if shouldParticlesLOD != self.visLOD then
			shouldRedoParticles = true
		end

		if shouldRedoParticles then
			self:RedoParticles(state)
		end
	end

	function ENT:AnimationThink()
		-- Pull the base towards the center point for best animations, and increase the pull
		-- the more we're not upright
		local forward = self:GetForward()
		local mul = (1 - forward.z) * 15 + 1
		self:BasePullToPoint(self:GetPos() + forward * mul)

		-- Handle directions
		local pullDir = Vector()
		local pullStrength = 0

		-- Test for wind direction
		local windVec = self:GetWindVector()
		local windExposure = windVec:Length()
		-- If the fire is facing towards or away from the wind direction, don't be affected
		if windExposure > 0.1 then
			local windProd = windVec:Dot(forward)
			local prodMul = 1 - math.abs(math.Clamp(windProd, -1, 1))
			local windMul = prodMul * windExposure
			
			pullDir = windVec * windMul
			pullStrength = windMul
		end

		-- Bias our direction if we're not upright to prevent flames from
		-- clipping into walls
		local upSideDownMul = -forward.z
		if upSideDownMul > 0 then
			pullDir = pullDir + forward * upSideDownMul
			pullStrength = pullStrength + upSideDownMul
		end
		
		-- Vector zero will cause fire to collapse on itself
		if pullDir and pullDir != Vector(0, 0, 0) and pullStrength != 0 then
			self.lastFlameDir = pullDir
			self:FlameSetDirection(pullDir, pullStrength)
		else
			-- Passing nothing means resetting the flame direction
			self:FlameSetDirection()
		end
	end
end

--lua/entities/vfire_cluster/shared.lua:
--[[-------------------------------------------------------------------------
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

vFire by Vioxtar

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
---------------------------------------------------------------------------]]

AddCSLuaFile()

DEFINE_BASECLASS( "base_anim" )

--[[-------------------------------------------------------------------------
Some helper functions because Set/Get LocalPos() can't handle world parents
---------------------------------------------------------------------------]]
local function GetRelPos(v)
	if v.parent:IsWorld() then
		return v:GetPos()
	else
		return v:GetLocalPos()
	end
end

local function SetRelPos(v, pos)
	if v.parent:IsWorld() then
		v:SetPos(pos)
	else
		v:SetLocalPos(pos)
	end
end


--[[-------------------------------------------------------------------------
Add a fire to the cluster
---------------------------------------------------------------------------]]
function ENT:AddFire(fire)
	-- Are we on the same parent?
	if !IsValid(fire) or fire.parent != self.parent then return end

	-- Do we already have the fire?
	if self.fires[fire] then return end

	-- Does the fire already have a cluster?
	local cluster = fire:GetNW2Entity("FireCluster")
	if IsValid(cluster) then
		cluster:RemFire(fire)
	end

	-- Add the fire
	self.fires[fire] = fire
	fire.cluster = self

	-- Update position
	if self.cnt == 0 then
		SetRelPos(self, GetRelPos(fire))
	else
		local p = GetRelPos(self)
		p = (p * self.cnt + GetRelPos(fire)) / (self.cnt + 1)
		SetRelPos(self, p)
	end
	if !self.parent.fireClusters then
		self.parent.fireClusters = {}
		hook.Run("vFireEntityStartedBurning", self.parent)
	end
	if self.parent.fireClusters then
		self.parent.fireClusters[self] = GetRelPos(self)
	end
	
	-- Increment count
	self.cnt = self.cnt + 1

	-- Network the change
	if SERVER then fire:SetNW2Entity("FireCluster", self) end

	-- Memorize distances for all current fires, remember closest fires
	local minDist = math.huge
	local closestFire

	local minDistSmaller = math.huge
	local closestFireSmaller

	local minDistBigger = math.huge
	local closestFireBigger

	self.distMem[fire] = {}
	for k, fire2 in pairs(self.fires) do
		if !IsValid(fire2) then continue end
		local dist = 0
		if fire != fire2 then
			dist = fire:GetPos():Distance(fire2:GetPos())
			if dist < minDist then
				minDist = dist
				closestFire = fire2
			end
			if dist < minDistSmaller then
				minDistSmaller = dist
				closestFireSmaller = fire2
			end
			if dist < minDistBigger then
				minDistBigger = dist
				closestFireBigger = fire2
			end
		end
		self.distMem[fire][fire2] = dist
		self.distMem[fire2][fire] = dist
	end

	-- Use the oppurtunity to set the closest fire
	fire.closestFire = closestFire
	fire.closestSmallerFire = closestFireSmaller
	fire.closestBiggerFire = closestFireBigger

end


--[[-------------------------------------------------------------------------
Remove a fire from the cluster, likely to never be called but who knows
---------------------------------------------------------------------------]]
function ENT:RemFire(fire)
	-- Is the fire still valid?
	if !IsValid(fire) then return end

	-- Do we actually have it?
	if !self.fires[fire] then return end

	-- Remove if this is our last fire
	if self.cnt - 1 <= 0 then
		if SERVER then self:Remove() end
		return
	end

	-- Remove the fire
	self.fires[fire] = nil
	fire.cluster = nil

	-- Update position
	local p = GetRelPos(self)
	p = (p * self.cnt - GetRelPos(fire)) / (self.cnt - 1)
	SetRelPos(self, p)
	if IsValid(self.parent) and self.parent.fireClusters then
		self.parent.fireClusters[self] = GetRelPos(self)
	end

	-- Decrement count
	self.cnt = self.cnt - 1

	-- Remove the fire from the distance memorization table
	self.distMem[fire] = nil
	for k, fire2 in pairs(self.fires) do
		self.distMem[fire2][fire] = nil
	end
end

-- A function similar to think dedicated to checking wind flow via timers
local windExposureCheckTime = 45
function ENT:CalcWindExposure()
	if self.parent:IsWorld() then
		self.windExposure = vFireCalcWindExposure(self:GetPos())
	else
		self.windExposure = vFireCalcWindExposure(self:GetPos(), {self.parent})
	end

	timer.Simple(windExposureCheckTime, function()
		-- Start the check wind loop only if we might move
		if IsValid(self) and vFireIsMobile(self) then
			self:CalcWindExposure()
		end
	end)
end

if SERVER then
	local pvsLODCheckTime = 100
	function ENT:CalcPVSLOD()
		for k, ply in pairs(player.GetAll()) do
			self.PVSLOD = self:TestPVS(ply:GetPos())
			if self.PVSLOD then
				-- One is enough
				break
			end
			-- Otherwise continue to check all of the other players
		end
		timer.Simple(pvsLODCheckTime, function()
			if IsValid(self) then
				self:CalcPVSLOD()
			end
		end)
	end
end


function ENT:Initialize()
	-- Obtain the parent
	local parent = self:GetNW2Entity("ClusterParent")
	if SERVER then
		if !IsValid(parent) and !parent:IsWorld() then
			self:Remove()
			return
		end
	end

	-- Set the parent if it's valid (and not the world)
	if IsValid(parent) then self:SetParent(parent) end
	-- Store the parent internally
	self.parent = parent

	-- Don't draw ourselves, don't collide with anything
	self:DrawShadow(false)
	self:SetNoDraw(true)
	self:SetCollisionGroup(COLLISION_GROUP_IN_VEHICLE)

	self.fires = {}
	self.cnt = 0

	-- Start a timed checkup for wind exposure
	self:CalcWindExposure()

	if SERVER then
		-- Start a timed PVS test for calculation LOD purposes
		self:CalcPVSLOD()
	end

	if CLIENT then

		local soundName = table.Random(list.Get("vFireLoopSounds"))

		self.sound = CreateSound(self, soundName)
		self.sound:PlayEx(0.4, 100)
		self.sound:SetSoundLevel(180, 0.1)

		self.LOD = false
	end

	-- Use a distance memorization table for optimization purposes of all fires
	self.distMem = {}
end



if CLIENT then
	function ENT:GetClusterMagnitude()
		local maxState = 0
		for k, fire in pairs(self.fires) do
			if IsValid(fire) then
				local state = fire:GetFireState()
				if state > maxState then
					maxState = state
				end
			end
		end

		return math.Min(maxState * 0.2, 1)
	end

	local clientTickRate = 3
	function ENT:Think()
		self.LOD = vFireGetLOD(self)

		if !self.LOD then

			local clusterMagnitude = self:GetClusterMagnitude()

			self.sound:ChangeVolume(clusterMagnitude, clientTickRate)
			self.sound:ChangePitch(120 - 40 * clusterMagnitude, clientTickRate)
		end

		self:SetNextClientThink(CurTime() + clientTickRate)
		return true -- We wish to override ticking rate
	end
end

function ENT:OnRemove()
	if CLIENT then
		-- Stop the sound
		local snd = self.sound
		-- We have to loop until it's stopped for some reason...
		local stopAttempts = 1
		while snd:IsPlaying() and stopAttempts <= 50 do
			snd:Stop()
			stopAttempts = stopAttempts + 1
		end
	end


	if SERVER then
		-- Workaround: this is done to prevent a weird error that places cluster at bad origins on removal
		-- the error does no harm, but it spams the console
		self:SetPos(Vector())
	end


	local parent = self.parent
	if parent == nil then
		hook.Run("vFireEntityStoppedBurning", parent)
		return
	end
	if !IsValid(parent) and !parent:IsWorld() then
		hook.Run("vFireEntityStoppedBurning", parent)
		return
	end

	-- Remove ourselves from the parent's clusters table
	if parent.fireClusters then
		parent.fireClusters[self] = nil
		if table.Count(parent.fireClusters) <= 0 then
			hook.Run("vFireEntityStoppedBurning", parent)
			parent.fireClusters = nil
		end
	end
end
--addons/wos-grandmaster-einf/lua/entities/wos_alcs_eternalflames/shared.lua:
ENT.Type 			= "anim"
ENT.Base 			= "base_anim"
--addons/wos-grandmaster-einf/lua/entities/wos_alcs_inner_fear/cl_init.lua:
include('shared.lua')

function ENT:Initialize()
	local pos = self:GetPos() 		
	local base_len = 600
	for i=1, 40 do
		for poss=1, 5 do
			local ed = EffectData()
			ed:SetOrigin( pos + Vector( base_len*math.cos( math.pi*i*0.05 )*(poss/5), base_len*math.sin( math.pi*i*0.05 )*(poss/5), 0 ) )
			ed:SetNormal( Vector( 0, 0, 1 ) )
			ed:SetRadius( 15 )
			util.Effect( "wos_alcs_ascended_darkness", ed )	
		end
	end
end

function ENT:OnRemove()

end

function ENT:Think()

end

function ENT:Draw()
	
end


--addons/wos-alcs-custom/lua/entities/wos_lightning_coil/shared.lua:
ENT.Type 			= "anim"
ENT.Base 			= "base_anim"
--addons/egm_lvs_ships/lua/entities/ywing_bomb/cl_init.lua:
include("shared.lua")

function ENT:Draw()
	self:DrawModel()
end
--addons/wos-alcs-blades-anzati/lua/effects/anzati_snowflake/init.lua:

function EFFECT:Init( data )
	local pos = data:GetOrigin()
	local dir = data:GetNormal()
	local len = data:GetRadius()
	local color = data:GetAngles()
	local emitter = ParticleEmitter( pos )

	local number_lol = 1

	if ( !emitter ) then return end

	for i = 0, len / number_lol do
		local pos2 = pos + dir * ( len - i * number_lol )
		--local particle = emitter:Add( "effects/muzzleflash"..math.random(1,4), pos2 )
		local particle = emitter:Add( "wos/lightsabers/effects/anzati/snowflake", pos2 )		
		if ( particle ) then
			particle:SetLifeTime( 0 )
			particle:SetDieTime( 0.3 )

			particle:SetGravity( Vector( 0, 0, math.random( 32, 128 ) ) )
			particle:SetVelocity( Vector( math.random( -8, 8 ), math.random( -8, 8 ), math.random( -8, 8 ) ) )

			particle:SetStartSize( 1 )
			particle:SetEndSize( 0 )

			particle:SetStartAlpha( math.random( 100, 200 ) )
			particle:SetEndAlpha( 0 )

			particle:SetColor( color.p, color.y, color.r )
			particle:SetAngleVelocity( Angle( math.Rand( -180, 180 ), math.Rand( -180, 180 ), math.Rand( -180, 180 ) ) )
			//particle:SetLighting( true )
		end
	end

	emitter:Finish()
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end

--addons/wos-alcs-blades-anzati/lua/effects/anzati_swtor6/init.lua:

function EFFECT:Init( data )
	local pos = data:GetOrigin()
	local dir = data:GetNormal()
	local len = data:GetRadius()
	local color = data:GetAngles()
	local emitter = ParticleEmitter( pos )

	local number_lol = 1

	if ( !emitter ) then return end

	for i = 0, len / number_lol do
		local pos2 = pos + dir * ( len - i * number_lol )
		--local particle = emitter:Add( "effects/muzzleflash"..math.random(1,4), pos2 )
		local particle = emitter:Add( "wos/lightsabers/effects/anzati/swtor6", pos2 )		
		if ( particle ) then
			particle:SetLifeTime( 0 )
			particle:SetDieTime( 0.3 )

			particle:SetGravity( Vector( 0, 0, math.random( 32, 128 ) ) )
			particle:SetVelocity( Vector( math.random( -8, 8 ), math.random( -8, 8 ), math.random( -8, 8 ) ) )

			particle:SetStartSize( 1 )
			particle:SetEndSize( 0 )

			particle:SetStartAlpha( math.random( 100, 200 ) )
			particle:SetEndAlpha( 0 )

			particle:SetColor( color.p, color.y, color.r )
			particle:SetAngleVelocity( Angle( math.Rand( -180, 180 ), math.Rand( -180, 180 ), math.Rand( -180, 180 ) ) )
			//particle:SetLighting( true )
		end
	end

	emitter:Finish()
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end

--addons/bkeypads/lua/effects/bkeypads_shield_break.lua:
function EFFECT:Init(data)
	self.StartTime = CurTime()
	self.EndTime = self.StartTime + .65

	self.Target = data:GetEntity()
	self.Origin = data:GetOrigin()

	--## Shield Break Circle ##--

	self.Target:ShieldBrokenEffect(.65)

	--## Halo Effect ##--

	self.TargetHalo = { self.Target }
	self.Color = Color(0, 183, 159)

	--## Sparks ##--
	
	local mins, maxs = self.Target:WorldSpaceAABB()
	local numParticles = math.Clamp(self.Target:BoundingRadius() * 8, 32, 256)
	local emitter = ParticleEmitter(self.Origin)
	for i = 0, numParticles do
		local vPos = Vector(math.Rand(mins.x, maxs.x), math.Rand(mins.y, maxs.y), math.Rand(mins.z, maxs.z))
		local particle = emitter:Add("effects/spark", vPos)
		if particle then
			particle:SetColor(self.Color.r, self.Color.g, self.Color.b)

			particle:SetVelocity((vPos - self.Origin) * 5)
			particle:SetLifeTime(0)
			particle:SetDieTime(math.Rand(0.5, 1.0))
			particle:SetStartAlpha(math.Rand(200, 255))
			particle:SetEndAlpha(0)
			particle:SetStartSize(2)
			particle:SetEndSize(0)
			particle:SetRoll(math.Rand(0, 360))
			particle:SetRollDelta(0)

			particle:SetAirResistance(100)
			particle:SetCollide(true)
			particle:SetBounce(0.3)
		end
	end

	emitter:Finish()
end

function EFFECT:Think()
	return IsValid(self.Target) and self.EndTime > CurTime()
end

function EFFECT:Render()
	if not IsValid(self.Target) then return end

	local frac = math.sin(math.TimeFraction(self.StartTime, self.EndTime, CurTime()) * math.pi)
	local distFrac = math.Clamp(1 - math.TimeFraction(1024, 64000, EyePos():DistToSqr(self.Origin)), 0.15, 1)

	self.Color.a = frac * 255

	halo.Add(self.TargetHalo, self.Color, 16 * distFrac * frac, 16 * distFrac * frac, bKeypads.Performance:Optimizing() and 1 or 4)
end
--addons/wos-grandmaster-einf/lua/effects/dismemberment/init.lua:
local dismemberment = Sound( "physics/gore/dismemberment.wav" )

local DismemberTable = {
	[HITGROUP_HEAD] = {"ValveBiped.Bip01_Head1"},
	[HITGROUP_LEFTARM] = {"ValveBiped.Bip01_L_UpperArm", "ValveBiped.Bip01_L_Forearm", "ValveBiped.Bip01_L_Hand"},
	[HITGROUP_RIGHTARM] = {"ValveBiped.Bip01_R_UpperArm", "ValveBiped.Bip01_R_Forearm", "ValveBiped.Bip01_R_Hand"},
	[HITGROUP_LEFTLEG] = {"ValveBiped.Bip01_L_Thigh", "ValveBiped.Bip01_L_Calf", "ValveBiped.Bip01_L_Foot", "ValveBiped.Bip01_L_Toe0"},
	[HITGROUP_RIGHTLEG] = {"ValveBiped.Bip01_R_Thigh", "ValveBiped.Bip01_R_Calf", "ValveBiped.Bip01_R_Foot", "ValveBiped.Bip01_R_Toe0"},
}

local random_dism = {}

for k,v in pairs(DismemberTable) do
	table.insert( random_dism, k )
end

function EFFECT:Init( data )
	self.ent = data:GetEntity()
	self.dism = math.Round(data:GetScale()) or 0
	self.DieTime = CurTime() + 5
	
	if self.dism == -1 then
		self.dism = random_dism[ math.random( #random_dism ) ]
	end
	
	self.IsThug = math.Round(data:GetMagnitude()) == 1//self.ent:IsThug()
	
	self.Entity:SetModel("models/props_junk/PopCan01a.mdl")
	
	if IsValid(self.ent) then
		//sound.Play("physics/flesh/flesh_bloody_break.wav",self.ent:GetPos()+vector_up*60,100, 100, 1)
		
		//local rag = IsValid(self.ent) and self.ent.GetRagdollEntity and self.ent:GetRagdollEntity() or self.ent
		
		//if rag then
			if self.dism == 1 then
				sound.Play("physics/gore/headshot"..math.random(1,3)..".wav",self.ent:GetPos()+vector_up*50,150,100,1)
			else
				sound.Play(dismemberment,self.ent:GetPos()+vector_up*50,150,100,1)
			end
		//end
		//self.Emitter = ParticleEmitter(self.ent:GetPos())	
		
	end
end

local deathbones = {
	"ValveBiped.Bip01_Pelvis",
	"ValveBiped.Bip01_Spine2",
	"ValveBiped.Bip01_Head1",
	"ValveBiped.Bip01_L_Upperarm",
	"ValveBiped.Bip01_L_Forearm",
	"ValveBiped.Bip01_L_Hand",
	"ValveBiped.Bip01_R_Upperarm",
	"ValveBiped.Bip01_R_Forearm",
	"ValveBiped.Bip01_R_Hand",
	"ValveBiped.Bip01_L_Thigh",	
	"ValveBiped.Bip01_L_Calf",
	"ValveBiped.Bip01_L_Foot",
	"ValveBiped.Bip01_R_Thigh",
	"ValveBiped.Bip01_R_Calf",
	"ValveBiped.Bip01_R_Foot",
}

function EFFECT:StartDeath()
	
	self.SavePhys = {}
	
	local rag = IsValid(self.ent) and self.ent:GetRagdollEntity()
	
	if not rag then return end
	
	for i=0,rag:GetPhysicsObjectCount()-1 do
		local phys = rag:GetPhysicsObjectNum(i)
		if phys then
			self.SavePhys[i] = {phys:GetSpeedDamping(), phys:GetRotDamping(), phys:GetMass()}				
			//phys:SetDamping(math.random(200,1200), math.random(100,2000))
			phys:SetMass(phys:GetMass() * math.Rand(1,60))
		end
	end
	
	self.StopDeathTime = CurTime() + math.Rand(0.3,0.8)
	
end

function EFFECT:StopDeath()
	
	local rag = IsValid(self.ent) and self.ent:GetRagdollEntity()
	
	if not rag then return end
	
	for k,v in pairs(self.SavePhys or {}) do
		local phys = rag:GetPhysicsObjectNum(k)
		//phys:SetDamping(v[1], v[2])
		phys:SetMass(v[3])
	end
	
end

function EFFECT:Think( )
	
	if IsValid(self.ent) then
		//self.Entity:SetPos(self.ent:GetPos())
		self.Entity:SetRenderBounds(Vector(-128, -128, -128), Vector(128, 128, 128))
		
		if self.StopDeathTime and self.StopDeathTime <= CurTime() then
			self:StopDeath()
			self.StopDeathTime = nil
		end
		
	else
		//if self.Emitter then
			//self.Emitter:Finish()
		//end
	end
	return CurTime() < self.DieTime or IsValid(self.ent) and IsValid(self.ent:GetRagdollEntity())
end

local bones = {
	["ValveBiped.Bip01_Spine2"] = { scale = Vector(2.131, 2.121, 2.131), pos = Vector(2.335, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_L_Foot"] = { scale = Vector(1.299, 1.299, 1.299), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_L_Clavicle"] = { scale = Vector(1.631, 1.631, 1.631), pos = Vector(0, 0, 6.666), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_R_Finger01"] = { scale = Vector(1.824, 1.824, 1.824), pos = Vector(0.984, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_L_Finger01"] = { scale = Vector(1.824, 1.824, 1.824), pos = Vector(0.984, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_R_Finger22"] = { scale = Vector(1.751, 1.751, 1.751), pos = Vector(0.017, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_L_Finger22"] = { scale = Vector(1.751, 1.751, 1.751), pos = Vector(0.017, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_Spine"] = { scale = Vector(1.651, 1.651, 1.651), pos = Vector(0, 2.019, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_L_Bicep"] = { scale = Vector(2.104, 2.104, 2.104), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_R_Finger21"] = { scale = Vector(1.506, 1.506, 1.506), pos = Vector(0.347, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_L_Finger21"] = { scale = Vector(1.506, 1.506, 1.506), pos = Vector(0.347, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_L_Forearm"] = { scale = Vector(1.516, 1.516, 1.516), pos = Vector(4.809, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_Spine1"] = { scale = Vector(1.623, 1.68, 1.623), pos = Vector(3.536, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_R_Finger12"] = { scale = Vector(1.822, 1.822, 1.822), pos = Vector(0.393, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_L_Finger12"] = { scale = Vector(1.822, 1.822, 1.822), pos = Vector(0.393, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_R_Ulna"] = { scale = Vector(2.066, 2.066, 2.066), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_R_Thigh"] = { scale = Vector(1.269, 1.269, 1.269), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_R_Finger11"] = { scale = Vector(2.273, 2.273, 2.273), pos = Vector(0.105, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_L_Finger11"] = { scale = Vector(2.273, 2.273, 2.273), pos = Vector(0.105, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_L_Toe0"] = { scale = Vector(1.401, 1.401, 1.401), pos = Vector(2.759, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_L_Ulna"] = { scale = Vector(2.039, 2.039, 2.039), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_R_Foot"] = { scale = Vector(1.245, 1.245, 1.245), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_R_UpperArm"] = { scale = Vector(1.575, 1.575, 1.575), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_L_Calf"] = { scale = Vector(1.213, 1.213, 1.213), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_L_Thigh"] = { scale = Vector(1.302, 1.302, 1.302), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_R_Finger02"] = { scale = Vector(1.965, 1.965, 1.965), pos = Vector(0.845, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_L_Finger02"] = { scale = Vector(1.965, 1.965, 1.965), pos = Vector(0.845, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_L_Hand"] = { scale = Vector(1.562, 1.562, 1.562), pos = Vector(1.373, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_R_Calf"] = { scale = Vector(1.273, 1.273, 1.273), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_R_Finger1"] = { scale = Vector(1.805, 1.805, 1.805), pos = Vector(1.605, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_L_Finger1"] = { scale = Vector(1.805, 1.805, 1.805), pos = Vector(1.605, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_R_Toe0"] = { scale = Vector(1.376, 1.376, 1.376), pos = Vector(2.434, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_Pelvis"] = { scale = Vector(1.263, 1.215, 1.225), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_R_Clavicle"] = { scale = Vector(1.621, 1.621, 1.621), pos = Vector(0, 0, -5.229), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_R_Forearm"] = { scale = Vector(1.083, 1.083, 1.083), pos = Vector(4.308, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_R_Bicep"] = { scale = Vector(2.104, 2.104, 2.104), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_R_Hand"] = { scale = Vector(1.57, 1.57, 1.57), pos = Vector(0.398, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_R_Finger2"] = { scale = Vector(1.506, 1.506, 1.506), pos = Vector(1.549, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_L_Finger2"] = { scale = Vector(1.506, 1.506, 1.506), pos = Vector(1.549, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_Spine4"] = { scale = Vector(1.447, 1.447, 1.447), pos = Vector(3.171, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_L_UpperArm"] = { scale = Vector(1.753, 1.753, 1.753), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_R_Finger0"] = { scale = Vector(1.83, 1.83, 1.83), pos = Vector(1.212, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_L_Finger0"] = { scale = Vector(1.83, 1.83, 1.83), pos = Vector(1.212, 0, 0), angle = Angle(0, 0, 0) }
}

local function CollideCallbackSmall(particle, hitpos, hitnormal)
	if not particle.HitAlready then
	
		particle.HitAlready = true
		
		if math.random(1, 10) == 3 then
			WorldSound("physics/flesh/flesh_bloody_impact_hard1.wav", hitpos, 50, math.random(95, 105))
		end
		local rand = math.random(3)
		if rand ~= 1 then
			util.Decal("Impact.Flesh", hitpos + hitnormal, hitpos - hitnormal)
		else
			util.Decal("Blood", hitpos + hitnormal, hitpos - hitnormal)
		end
		particle:SetDieTime(0)
	end	
end

function EFFECT:Render()

	local rag = IsValid(self.ent) and self.ent.GetRagdollEntity and self.ent:GetRagdollEntity()// or self.ent
	
	if rag and IsValid(rag) then
		if self.dism and DismemberTable[self.dism] then
			
			for _,bonename in pairs(DismemberTable[self.dism]) do
				local bone = rag:LookupBone(bonename)
				if bone then	
					local pos, ang = rag:GetBonePosition(bone)
					if pos and ang then
						if _ == 1 then
							self.Entity:SetPos(pos+ang:Forward()*3)
							self.Entity:SetAngles(ang)
						end
						if not self.Done then
							if self.dism == 1 then
								ParticleEffectAttach("dd_blood_headshot_2",PATTACH_POINT_FOLLOW,rag,rag:LookupAttachment("eyes"))
								//ParticleEffectAttach("dd_blood_headshot_2",PATTACH_POINT_FOLLOW,self.Entity,0)
								ParticleEffectAttach("dd_blood_gib_trail",PATTACH_ABSORIGIN_FOLLOW,self.Entity,0)
								for i = 1, math.random(4) do
									local effectdata = EffectData()
										effectdata:SetOrigin( pos + VectorRand() * 2 )
										effectdata:SetNormal( ang:Forward() )
										effectdata:SetMagnitude(math.random(70,110))
										effectdata:SetScale(1)
										effectdata:SetRadius( 0 )
									util.Effect( "gib", effectdata )
								end
							else
								ParticleEffectAttach("dd_blood_gib_trail",PATTACH_ABSORIGIN_FOLLOW,self.Entity,0)
							end
							//ParticleEffectAttach("dd_blood_headshot_2",PATTACH_POINT_FOLLOW,rag,rag:LookupAttachment("eyes"))
							self.Done = true
						end
						self.NextDrip = self.NextDrip or 0
						
						if self.NextDrip <= CurTime() then
							self.NextDrip = CurTime() + 0.045
							self.Emitter = ParticleEmitter(rag:GetPos())	
							if self.Emitter then
								local delta = math.max(0, self.DieTime - CurTime())
								if 0 < delta then
									self.Emitter:SetPos(pos)
									
									for i=1, math.random(1, 3) do
										local particle = self.Emitter:Add("Decals/flesh/Blood"..math.random(1,5), pos)
										local force = math.min(1.5, delta) * math.Rand(115, 200)
										
										particle:SetVelocity(force * ang:Forward() + 0.35 * force * VectorRand())
										particle:SetDieTime(math.Rand(2.25, 3))
										particle:SetStartAlpha(0)
										particle:SetEndAlpha(0)
										particle:SetStartSize(math.random(1, 8))
										particle:SetEndSize(0)
										particle:SetRoll(math.Rand(0, 360))
										particle:SetRollDelta(math.Rand(-40, 40))
										particle:SetColor(255, 0, 0)
										particle:SetAirResistance(5)
										particle:SetBounce(0)
										particle:SetGravity(Vector(0, 0, -600))
										particle:SetCollide(true)
										particle:SetCollideCallback(CollideCallbackSmall)
										particle:SetLighting(true)
									end
									
								end	
								self.Emitter:Finish()
							end
						end
						
						if !rag:IsPlayer() then
							rag:ManipulateBoneScale( bone, Vector(0, 0, 0) )	
							if not rag.RemoveSuit then
								rag.RemoveSuit = true
							end
						end
					end	
				end
			end
			
			if self.IsThug then
				for k, v in pairs( bones ) do
					local bone = rag:LookupBone(k)
					if (!bone) then continue end
					if not table.HasValue(DismemberTable[self.dism],k) then
						rag:ManipulateBoneScale( bone, v.scale  )
					end
					rag:ManipulateBoneAngles( bone, v.angle  )
					rag:ManipulateBonePosition( bone, v.pos  )
				end
			end
			
		end
	end
	
end

--addons/wos-grandmaster-einf/lua/effects/effect_slice/init.lua:
local slicesound = Sound( "physics/gore/dismemberment.wav" )
local gibsound = Sound( "physics/gore/bodysplat.wav" )

local skeleton = Model( "models/player/skeleton.mdl" )

function EFFECT:Init( data )

	self.ent = data:GetEntity()
	
	self.MakeSecondPart = math.Round(data:GetRadius()) == 1
	
	if !IsValid(self.ent) then return end
	
	local col = self.ent:GetPlayerColor()
	
	self.GetPlayerColor = function() return Vector( col.r/255,col.g/255,col.b/255 ) end
	
	self.Origin = data:GetOrigin()

	self.Ang = data:GetNormal()
	self.Ang2 = self.Ang:Angle():Forward() * 20
	
	self.Normal = ( self.Ang2 - self.Ang ):GetNormalized()
	
	//self.DamagePos = data:GetNormal()
	
	self.IsThug = math.Round(data:GetMagnitude()) == 1
	
	self.Up = math.ceil(data:GetScale())
	
	self.Origin.z = self.Up
	
	self.BleedOut = CurTime() + 2.2
	
	if self.MakeSecondPart then
		sound.Play(slicesound,self.Origin,100, math.random(110,140), 1)
		
		local e = EffectData()
			e:SetEntity(self.ent)
			e:SetOrigin(self.Origin)
			//e:SetAngles(self.Ang)
			e:SetStart(self.Origin)
			e:SetScale(self.Up)
			e:SetMagnitude(self.IsThug and 1 or 0)
			e:SetNormal(self.Ang)
			e:SetRadius( 0 )
				
		util.Effect("effect_slice",e,nil,nil)
	end
	
	if IsValid(self.ent) then
		if IsValid(self.ent:GetRagdollEntity()) then
			
			self.ent:GetRagdollEntity():SetNoDraw(true)
			
			local rag = self.ent:GetRagdollEntity()
			
			rag:SetCollisionGroup( COLLISION_GROUP_DEBRIS_TRIGGER )
			
			self.transform = {}
	
			local pos, ang = rag:GetPos(), rag:GetAngles()
			for i=0, rag:GetPhysicsObjectCount()-1 do
				local phys = rag:GetPhysicsObjectNum(i)
				if IsValid(phys) then
					local pos2, ang2 = WorldToLocal(phys:GetPos(), phys:GetAngles(), pos, ang)
					
					self.transform[i] = {pos = pos2, ang = ang2}
				end
			end
						
			
			self:CreateDummy( rag )
			
			
		end
	end
	


end

// extremely huge thanks to _Kilburn for this nice "statue" code
local mins = Vector(math.huge, math.huge, math.huge)
local maxs = Vector(-math.huge, -math.huge, -math.huge)
function EFFECT:CreateDummy( rag )
	
	self:SetModel( rag:GetModel() )
	self:SetPos( rag:GetPos() + vector_up * 3 )
	self:SetAngles( rag:GetAngles() )
	
	local convexes = {}
	local mass = 0
	self.PhysBoneTransforms = {}
	self.BoneTransforms = {}
	self.BoneReference = nil
	
	for i=0, rag:GetPhysicsObjectCount()-1 do	
		local helper = self.transform[i]
		local phys = rag:GetPhysicsObjectNum(i)	
		
		local M = Matrix()
		
		self.PhysBoneTransforms[i] = {pos = helper.pos, ang = helper.ang}
		self.BoneTransforms[rag:TranslatePhysBoneToBone(i)] = self.PhysBoneTransforms[i]
		
		M:Translate(helper.pos)
		M:Rotate(helper.ang)
		
		if !self.MakeSecondPart and self.Normal:Dot(phys:GetPos() - self.Origin) > 0 and phys:GetPos():Distance( self.Origin ) > 13 then continue end
		if self.MakeSecondPart and self.Normal:Dot(phys:GetPos() - self.Origin) < 0 and phys:GetPos():Distance( self.Origin ) > 13 then continue end
		
		mass = mass + phys:GetMass()
		
		
		for _,c in ipairs(phys:GetMeshConvexes()) do
			local cvx = {}
			//reduce amount of vertices to prevent small stuttering
			local max_vertices = 12
			local min = math.min(max_vertices, #c)
			local dif = math.ceil(#c/min)
			
			for _,p in ipairs(c) do
			
				if _ % dif ~= 0 then continue end
			
				local M1 = Matrix() * M
				M1:Translate(p.pos)
				
				local pos = M1:GetTranslation()
				
				cvx[#cvx+1] = pos
				
				OrderVectors(mins, pos*1)
				OrderVectors(pos*1, maxs)
				
			end
			convexes[#convexes+1] = cvx
		end
	end
	
	self:PhysicsInitMultiConvex(convexes)
	self:SetMoveType(MOVETYPE_VPHYSICS)
	self:SetSolid(SOLID_VPHYSICS)
	self:SetCollisionGroup( COLLISION_GROUP_DEBRIS_TRIGGER )
	
	
	local phys = self:GetPhysicsObject()
	
	if IsValid(phys) then
		//phys:EnableMotion(false)
		phys:Wake()
		phys:SetMass(mass)
		phys:SetMaterial("zombieflesh")
		phys:SetVelocity( self.Normal:GetNormal() * ( self.MakeSecondPart and 100 or -100 ) + VectorRand() * 50 + vector_up * 20 )
	end
	
	self:EnableCustomCollisions(true)
		
	self.SavePos = self:WorldToLocal( self.Origin )
	self.NormalPos1 = self:WorldToLocal( self.Ang )
	self.NormalPos2 = self:WorldToLocal( self.Ang2 )
	
	//tiny entity for particle
	self.Dummy = ClientsideModel( "models/props_junk/PopCan01a.mdl", RENDER_GROUP_OPAQUE_ENTITY )
	if self.Dummy then
		self.Dummy:SetPos( self:GetPos() )
		self.Dummy:SetAngles( self:GetAngles() )
		self.Dummy:SetParent( self )
		self.Dummy:SetNoDraw( true )
	else
		self.Dummy = nil
	end

	
end


local function MatrixWorldToLocal(refMat, worldMat)
	local pos, ang = WorldToLocal(refMat:GetTranslation(), refMat:GetAngles(), worldMat:GetTranslation(), worldMat:GetAngles())
	local localM = Matrix()
	localM:Translate(pos)
	localM:Rotate(ang)
	
	return localM
end

function EFFECT:CaptureReferencePose()
	local old_BuildBonePositions = self.BuildBonePositions
	
	self.BuildBonePositions = function(self, n)
		self.BoneReference = {}
		
		local function processChildBones(parent, parentMat)
			local children
			if parent then
				children = self:GetChildBones(parent)
			else
				children = {0}
			end
			
			for _,child in ipairs(children) do
				local childName = self:GetBoneName(child)
				if childName then
					local childMat = self:GetBoneMatrix(child)
					self.BoneReference[childName] = MatrixWorldToLocal(childMat, parentMat)
					processChildBones(child, childMat)
				end
			end
		end
		
		local rootMat = Matrix()
		processChildBones(nil, rootMat)
	end
	self:SetupBones()
	
	self.BuildBonePositions = old_BuildBonePositions
end

/*function EFFECT:PropagateBoneTransform(parent, parentMat)
	local children
	if parent then
		children = self:GetChildBones(parent)
	else
		children = {0}
	end
	
	for _,child in ipairs(children) do
		if not self.BoneTransforms[child] then
			local childName = self:GetBoneName(child)
			if childName and self.BoneReference[childName] then
				local childMat = parentMat * self.BoneReference[childName]
				if self.BoneTransforms and self.BoneTransforms[childName] then
					local tr = self.BoneTransforms[childName]
					childMat:Translate(tr.pos)
					childMat:Rotate(tr.ang)
				end
				
				local ang = self:GetManipulateBoneAngles(child)
				childMat:Rotate(ang)
				
				self:SetBoneMatrix(child, childMat)
				self:PropagateBoneTransform(child, childMat)
			end
		end
	end
end*/

function EFFECT:PropagateBoneTransform(parent, parentMat)
	local children
	if parent then
		children = self:GetChildBones(parent)
		
		for i=1, #children do
			local child = children[i]
			if not self.BoneTransforms[child] then
				local childName = self:GetBoneName(child)
				if childName and self.BoneReference[childName] then
					local childMat = parentMat * self.BoneReference[childName]
					if self.BoneTransforms and self.BoneTransforms[childName] then
						local tr = self.BoneTransforms[childName]
						childMat:Translate(tr.pos)
						childMat:Rotate(tr.ang)
					end
					
					local ang = self:GetManipulateBoneAngles(child)
					childMat:Rotate(ang)
					
					self:SetBoneMatrix(child, childMat)
					self:PropagateBoneTransform(child, childMat)
				end
			end
		end
		
	else
		local child = 0
		
		if not self.BoneTransforms[child] then
			local childName = self:GetBoneName(child)
			if childName and self.BoneReference[childName] then
				local childMat = parentMat * self.BoneReference[childName]
				if self.BoneTransforms and self.BoneTransforms[childName] then
					local tr = self.BoneTransforms[childName]
					childMat:Translate(tr.pos)
					childMat:Rotate(tr.ang)
				end
				
				local ang = self:GetManipulateBoneAngles(child)
				childMat:Rotate(ang)
				
				self:SetBoneMatrix(child, childMat)
				self:PropagateBoneTransform(child, childMat)
			end
		end
		
	end
	
	
end

local m_vec_zero = Vector( 0, 0, 0 )
local m_ang_zero = Angle( 0, 0, 0 )
local m_scale_zero = Vector( 1, 1, 1 )

function EFFECT:BuildBonePositions(nbones)
	if self.BoneTransforms and self.BoneReference then
		
		self.BoneTransformsStore = self.BoneTransformsStore or {}
		
		//PrintTable( self.BoneTransforms )
		
		self.MaxN = self.MaxN or table.maxn( self.BoneTransforms )
		
		//for b, tr in pairs(self.BoneTransforms) do
		for i = 0, self.MaxN do
			
			if not self.BoneTransforms[i] then continue end
			
			local b = i
			local tr = self.BoneTransforms[i]
			
			local M0 = self:GetBoneMatrix(b)
			
			if M0 then
			
				if not self.BoneTransformsStore[b] then
					self.BoneTransformsStore[b] = Matrix()
				end
			
				local M = self.BoneTransformsStore[b]//Matrix()
				
				M:SetTranslation( m_vec_zero )
				M:SetAngles( m_ang_zero )
				M:SetScale( m_scale_zero )
				
				M:Translate(self:GetPos())
				M:Rotate(self:GetAngles())
				M:Translate(tr.pos)
				M:Rotate(tr.ang)
				self:SetBoneMatrix(b, M)
				self:PropagateBoneTransform(b, M)
			end
		end
	end
end

local function CollideCallbackSmall(particle, hitpos, hitnormal)
			
		if math.random(1, 10) == 3 then
			sound.Play("physics/flesh/flesh_bloody_impact_hard1.wav", hitpos, 50, math.random(95, 105))
		end
		//util.Decal(math.random(15) == 15 and "Blood" or "Impact.Flesh", hitpos + hitnormal, hitpos - hitnormal)
		local rand = math.random(3)
		if rand ~= 1 then
			util.Decal("Impact.Flesh", hitpos + hitnormal, hitpos - hitnormal)
		else
			util.Decal("Blood", hitpos + hitnormal, hitpos - hitnormal)
		end
		local vel = particle.StartVelocity
		
		particle:SetDieTime(0)

end

function EFFECT:Think( )
	
	if IsValid(self.ent) and IsValid(self.ent:GetRagdollEntity()) then
		if not self.Frozen then
			for i = 1, self.ent:GetRagdollEntity():GetPhysicsObjectCount() do
				local bone = self.ent:GetRagdollEntity():GetPhysicsObjectNum(i)
				if bone and bone.IsValid and bone:IsValid() then
					bone:EnableMotion(false)
				end
			end
			self.Frozen = true
		end
		
		self.Entity:SetRenderBounds(Vector(-128, -128, -128), Vector(128, 128, 128))
		
	else
		//SafeRemoveEntity(self.Dummy)
	end
	
	

	return IsValid(self.ent) and IsValid(self.ent:GetRagdollEntity())
end

local bones = {
	["ValveBiped.Bip01_Spine2"] = { scale = Vector(2.131, 2.121, 2.131), pos = Vector(2.335, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_L_Foot"] = { scale = Vector(1.299, 1.299, 1.299), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_L_Clavicle"] = { scale = Vector(1.631, 1.631, 1.631), pos = Vector(0, 0, 6.666), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_R_Finger01"] = { scale = Vector(1.824, 1.824, 1.824), pos = Vector(0.984, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_L_Finger01"] = { scale = Vector(1.824, 1.824, 1.824), pos = Vector(0.984, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_R_Finger22"] = { scale = Vector(1.751, 1.751, 1.751), pos = Vector(0.017, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_L_Finger22"] = { scale = Vector(1.751, 1.751, 1.751), pos = Vector(0.017, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_Spine"] = { scale = Vector(1.651, 1.651, 1.651), pos = Vector(0, 2.019, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_L_Bicep"] = { scale = Vector(2.104, 2.104, 2.104), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_R_Finger21"] = { scale = Vector(1.506, 1.506, 1.506), pos = Vector(0.347, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_L_Finger21"] = { scale = Vector(1.506, 1.506, 1.506), pos = Vector(0.347, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_L_Forearm"] = { scale = Vector(1.516, 1.516, 1.516), pos = Vector(4.809, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_Spine1"] = { scale = Vector(1.623, 1.68, 1.623), pos = Vector(3.536, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_R_Finger12"] = { scale = Vector(1.822, 1.822, 1.822), pos = Vector(0.393, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_L_Finger12"] = { scale = Vector(1.822, 1.822, 1.822), pos = Vector(0.393, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_R_Ulna"] = { scale = Vector(2.066, 2.066, 2.066), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_R_Thigh"] = { scale = Vector(1.269, 1.269, 1.269), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_R_Finger11"] = { scale = Vector(2.273, 2.273, 2.273), pos = Vector(0.105, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_L_Finger11"] = { scale = Vector(2.273, 2.273, 2.273), pos = Vector(0.105, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_L_Toe0"] = { scale = Vector(1.401, 1.401, 1.401), pos = Vector(2.759, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_L_Ulna"] = { scale = Vector(2.039, 2.039, 2.039), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_R_Foot"] = { scale = Vector(1.245, 1.245, 1.245), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_R_UpperArm"] = { scale = Vector(1.575, 1.575, 1.575), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_L_Calf"] = { scale = Vector(1.213, 1.213, 1.213), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_L_Thigh"] = { scale = Vector(1.302, 1.302, 1.302), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_R_Finger02"] = { scale = Vector(1.965, 1.965, 1.965), pos = Vector(0.845, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_L_Finger02"] = { scale = Vector(1.965, 1.965, 1.965), pos = Vector(0.845, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_L_Hand"] = { scale = Vector(1.562, 1.562, 1.562), pos = Vector(1.373, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_R_Calf"] = { scale = Vector(1.273, 1.273, 1.273), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_R_Finger1"] = { scale = Vector(1.805, 1.805, 1.805), pos = Vector(1.605, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_L_Finger1"] = { scale = Vector(1.805, 1.805, 1.805), pos = Vector(1.605, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_R_Toe0"] = { scale = Vector(1.376, 1.376, 1.376), pos = Vector(2.434, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_Pelvis"] = { scale = Vector(1.263, 1.215, 1.225), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_R_Clavicle"] = { scale = Vector(1.621, 1.621, 1.621), pos = Vector(0, 0, -5.229), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_R_Forearm"] = { scale = Vector(1.083, 1.083, 1.083), pos = Vector(4.308, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_R_Bicep"] = { scale = Vector(2.104, 2.104, 2.104), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_R_Hand"] = { scale = Vector(1.57, 1.57, 1.57), pos = Vector(0.398, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_R_Finger2"] = { scale = Vector(1.506, 1.506, 1.506), pos = Vector(1.549, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_L_Finger2"] = { scale = Vector(1.506, 1.506, 1.506), pos = Vector(1.549, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_Spine4"] = { scale = Vector(1.447, 1.447, 1.447), pos = Vector(3.171, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_L_UpperArm"] = { scale = Vector(1.753, 1.753, 1.753), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_R_Finger0"] = { scale = Vector(1.83, 1.83, 1.83), pos = Vector(1.212, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_L_Finger0"] = { scale = Vector(1.83, 1.83, 1.83), pos = Vector(1.212, 0, 0), angle = Angle(0, 0, 0) }
}

local flesh = Material("models/flesh")
local meat = CreateMaterial( "Meat", "UnlitGeneric", { [ "$basetexture" ] = "models/flesh" } )
local meat2 = CreateMaterial( "Meat2", "UnlitGeneric", { [ "$basetexture" ] = "models/skeleton/skeleton_bloody" } )
local mat = Material( "white_outline" )
local skeleton_bloody = Material( "models/skeleton/skeleton_bloody" )

local meat_col = Color(115,15,15,255)

local vec_grav = Vector( 0, 0, -600 )

function EFFECT:Render()
	local rag = self
	local ct = CurTime()
	

	
	if self and self:IsValid() then
	
		if not self.InitBuildBonePositions or not self.BoneReference then
			self:AddCallback("BuildBonePositions", function(self, nbones) self:BuildBonePositions(nbones) end)
			self:CaptureReferencePose()
			self.InitBuildBonePositions = true
			self:SetupBones()
		end	
		//self:DrawModel()
	end
	
	local ragdoll = self.ent.GetRagdollEntity and self.ent:GetRagdollEntity()
	
	if ragdoll and IsValid(ragdoll) then
		if not ragdoll.Sliced then
			ragdoll.Sliced = true
		end
	end
	
	if rag and IsValid(rag) then	
				
				if not self.SavePos then return end
				
				local pos = self:LocalToWorld( self.SavePos )
				
				local normal1 = self:LocalToWorld( self.NormalPos1 )
				local normal2 = self:LocalToWorld( self.NormalPos2 )
				
				local normal = ( normal2 - normal1 ):GetNormalized()
								
				if !self.MakeSecondPart then
					normal = normal * -1
				end
				
				local distance = normal:Dot( pos )
				
				rag:SetupBones()
				if not rag.OriginalModel then
					rag.OriginalModel = rag:GetModel()
				end
				rag:SetModel( rag.OriginalModel )
								
				
				render.ClearStencil()
				render.SetStencilEnable( true )
				
				render.EnableClipping( true )
				render.PushCustomClipPlane( normal, distance )

				render.SetStencilPassOperation( STENCILOPERATION_REPLACE )
				render.SetStencilFailOperation( STENCILOPERATION_REPLACE )
				render.SetStencilZFailOperation( STENCILOPERATION_KEEP )
				render.SetStencilCompareFunction( STENCILCOMPARISONFUNCTION_ALWAYS )
				render.SetStencilReferenceValue( 1 )
				
								
				render.ModelMaterialOverride( meat )
					render.CullMode( MATERIAL_CULLMODE_CW )
					rag:DrawModel()
					render.CullMode( MATERIAL_CULLMODE_CCW )
				render.ModelMaterialOverride(  )
			
				render.SetStencilReferenceValue( 2 )
				render.SetStencilFailOperation( STENCILOPERATION_KEEP )
				
		
				rag:DrawModel()
				
				render.PopCustomClipPlane()
				render.EnableClipping( false )
				
				render.SetStencilCompareFunction( STENCILCOMPARISONFUNCTION_EQUAL )
				render.SetStencilPassOperation( STENCILOPERATION_REPLACE )
				render.SetStencilFailOperation( STENCILOPERATION_REPLACE )
				render.SetStencilZFailOperation( STENCILOPERATION_REPLACE )
				
				render.SetStencilReferenceValue( 1 )
				
				
				if not self.MeatAng and not self.MeatPos then
					
					local meat_ang = ( normal * -1 ):Angle()
					meat_ang:RotateAroundAxis( meat_ang:Right(), -90 )
				
					local mpos, mang = WorldToLocal( pos, meat_ang, self:GetPos(), self:GetAngles())
					
					self.MeatAng = mang
					self.MeatPos = mpos
				end
				
				local meat_pos, meat_ang = LocalToWorld( self.MeatPos, self.MeatAng, self:GetPos(), self:GetAngles())
				
				render.OverrideDepthEnable( true, true )
				
				cam.Start3D2D( meat_pos, meat_ang, 0.1 )
					surface.SetMaterial( meat2 )
					surface.SetDrawColor( meat_col )
					surface.DrawTexturedRectRotated( 0, 0, 120, 120, 0 ) 
				cam.End3D2D()
				
				render.OverrideDepthEnable( false )
				
				render.SetStencilEnable( false )
				
				
				if self:GetPos():Distance(EyePos()) < 400 then
				
					//stay calm, skeleton
					local distance = normal:Dot( pos - normal * ( self.MakeSecondPart and 1.5 or 1 ) )
									
					render.EnableClipping( true )
					render.PushCustomClipPlane( normal, distance )
					
					local distance = (normal*-1):Dot( pos + normal * 2 )
					render.PushCustomClipPlane( normal*-1, distance )
									
					
					rag:SetModel( skeleton )
					
					render.ModelMaterialOverride( skeleton_bloody )
						rag:SetupBones()
						rag:DrawModel()
						
						render.CullMode( MATERIAL_CULLMODE_CW )
						rag:DrawModel()
						render.CullMode( MATERIAL_CULLMODE_CCW )
						
					render.ModelMaterialOverride( )
					
					render.PopCustomClipPlane()
					render.PopCustomClipPlane()
					render.EnableClipping( false )
				end
				
				local ang = (normal*-1):Angle()
				ang.p = ang.p + 90
				
				local rnd = ang:Right() * math.Rand(-2,2) + ang:Forward() * math.Rand(-2,2)
				
				if self.Dummy and self.Dummy:IsValid() then
					self.Dummy:SetPos( pos + rnd )
					self.Dummy:SetAngles( ang )
				end
				
				
				if not self.Particle then
					local ang = (normal*-1):Angle()
					ang.p = ang.p + 90

					
					self.Particle = true
				end
				
				self.NextDrip = self.NextDrip or 0
						
				if self.NextDrip <= ct then
					self.NextDrip = ct + 0.055
					local emitter = ParticleEmitter( self:GetPos() )	
					if emitter then
						local delta = math.max(0, self.BleedOut - ct)
						if 0 < delta then
							emitter:SetPos(pos + rnd*3)
									
							for i=1, math.random(1, 3) do
								local particle = emitter:Add("Decals/flesh/Blood"..math.random(1,5), pos)
								local force = math.Rand(165, 400)//math.min(1.5, delta) * math.Rand(65, 200)
										
								particle:SetVelocity(force * ang:Up() + VectorRand()*20)
								particle:SetDieTime(math.Rand(2.25, 3))
								particle:SetStartAlpha(0)
								particle:SetEndAlpha(0)
								particle:SetStartSize(15)
								particle:SetEndSize(15)
								particle:SetRoll(math.Rand(0, 360))
								particle:SetRollDelta(math.Rand(-40, 40))
								particle:SetColor(255, 0, 0)
								particle:SetAirResistance(5)
								particle:SetBounce(0)
								particle:SetGravity(vec_grav)
								particle:SetCollide(true)
								particle:SetCollideCallback(CollideCallbackSmall)
								particle:SetLighting(true)
								particle.StartVelocity = particle:GetVelocity()
								particle.Hits = 0
								//particle.MaxHits = math.random(3,5)
							end
									
						end	
						emitter:Finish()
					end
				end

				
	end
	
	
end
--lua/effects/effect_sw_impact/init.lua:
EFFECT.Duration			= 0.1;
EFFECT.Size				= 20;

local MaterialGlow		= Material( "effects/sw_laser_bit" );

function EFFECT:Init( data )

	self.Position = data:GetOrigin();
	self.Normal = data:GetNormal();
	self.LifeTime = self.Duration;

	-- particles
	local emitter = ParticleEmitter( self.Position );
	if( emitter ) then
		
		for i = 1, 20 do

			local particle = emitter:Add( "effects/sw_laser_bit", self.Position + self.Normal * 2 );
			particle:SetVelocity( ( self.Normal + VectorRand() * 0.75 ):GetNormal() * math.Rand( 75, 125 ) );
			particle:SetDieTime( math.Rand( 0.5, 1.25 ) );
			particle:SetStartAlpha( 255 );
			particle:SetEndAlpha( 0 );
			particle:SetStartSize( math.Rand( 4, 8 ) );
			particle:SetEndSize( 0 );
			particle:SetRoll( 0 );
			particle:SetGravity( Vector( 0, 0, -250 ) );
			particle:SetCollide( true );
			particle:SetBounce( 0.3 );
			particle:SetAirResistance( 5 );

		end
		emitter:Finish();
	end
	
	--[[local emitter_s = ParticleEmitter( self.Position );
	if( emitter_s ) then
		for i = 1, 8 do
			--local smokeTexture	= "effects/awoi_musket_smoke_01"
			
			local particle_s = emitter_s:Add(smokeTexture, self.Position+self.Normal*2);
			particle_s:SetVelocity((self.Normal+VectorRand()*0.10):GetNormal()*math.Rand(250, 2500));
			particle_s:SetDieTime(math.Rand(1, 3));
			particle_s:SetStartAlpha(150);
			particle_s:SetEndAlpha(0);
			particle_s:SetStartSize(math.Rand(10, 20));
			particle_s:SetEndSize(math.Rand(10, 20));
			particle_s:SetGravity(Vector(math.Rand(0, 500), math.Rand(250, 1000), math.Rand(-250, 250)));
			particle_s:SetRoll(math.Rand(0, 360));
			particle_s:SetRollDelta(math.Rand(-0.5, 0.5));
			local colour = math.Rand(50, 150);
			particle_s:SetColor(colour, colour, colour, 100);
			particle_s:SetCollide(false);
			particle_s:SetAirResistance(2000);
		end--]]
		--emitter_s:Finish();
	--end
	
end


function EFFECT:Think()

	self.LifeTime = self.LifeTime - FrameTime();
	return self.LifeTime > 0;

end


function EFFECT:Render()

	local frac = math.max( 0, self.LifeTime / self.Duration );
	local rgb = 255 * frac;
	local color = Color( rgb, rgb, rgb, 255 );

	render.SetMaterial( MaterialGlow );
	render.DrawQuadEasy( self.Position + self.Normal, self.Normal, self.Size, self.Size, color );

end

--lua/effects/effect_sw_laser_blue/init.lua:
TRACER_FLAG_USEATTACHMENT 	= 0x0002
SOUND_FROM_WORLD 			= 0
CHAN_STATIC 				= 6
EFFECT.Speed 				= 6500
EFFECT.Length 				= 64
--EFFECT.WhizSound			= Sound( "nomad/whiz.wav" )		-- by Robinhood76 (http:--www.freesound.org/people/Robinhood76/sounds/96556/)
EFFECT.WhizDistance 		= 72
local MaterialMain 			= Material("effects/sw_laser_blue_main")
local MaterialFront 		= Material("effects/sw_laser_blue_front")
local DynamicTracer 		= GetConVar("cl_dynamic_tracer")

function EFFECT:GetTracerOrigin(data)
	-- this is almost a direct port of GetTracerOrigin in fx_tracer.cpp
	local start = data:GetStart()

	-- use attachment?
	if (bit.band(data:GetFlags(), TRACER_FLAG_USEATTACHMENT) == TRACER_FLAG_USEATTACHMENT) then
		local entity = data:GetEntity()
		if (not IsValid(entity)) then return start end
		if (not game.SinglePlayer() and entity:IsEFlagSet(EFL_DORMANT)) then return start end

		if (entity:IsWeapon() and entity:IsCarriedByLocalPlayer()) then
			-- can't be done, can't call the real function
			-- local origin = weapon:GetTracerOrigin()
			-- if( origin ) then
			-- 	return origin, angle, entity
			-- end
			-- use the view model
			local pl = entity:GetOwner()

			if (IsValid(pl)) then
				local vm = pl:GetViewModel()

				if (IsValid(vm) and not LocalPlayer():ShouldDrawLocalPlayer()) then
					entity = vm
					-- HACK: fix the model in multiplayer
				else
					if (entity.WorldModel) then
						entity:SetModel(entity.WorldModel)
					end
				end
			end
		end

		local attachment = entity:GetAttachment(data:GetAttachment())

		if (attachment) then
			start = attachment.Pos
		end
	end

	return start
end

function EFFECT:Init(data)
	self.StartPos = self:GetTracerOrigin(data)
	self.EndPos = data:GetOrigin()
	self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)
	local diff = self.EndPos - self.StartPos
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	self.LifeTime = (diff:Length() + self.Length) / self.Speed
	-- whiz by sound
	local weapon = data:GetEntity()

	if (IsValid(weapon) and (not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer())) then
		local dist, pos, time = util.DistanceToLine(self.StartPos, self.EndPos, EyePos())
	end
end

--concommand.Add("sv_dlight")
function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()

	if DynamicTracer:GetBool() then
		local spawn = util.CRC(tostring(self:GetPos()))
		local dlight = DynamicLight(self:EntIndex() + spawn)
		local endDistance = self.Speed * self.StartTime
		local endPos = self.StartPos + self.Normal * endDistance

		if (dlight) then
			dlight.pos = endPos
			dlight.r = 0
			dlight.g = 0
			dlight.b = 153
			dlight.brightness = 3
			dlight.Decay = 1000
			dlight.Size = 300
			dlight.DieTime = CurTime() + 3
		end
	end

	return self.LifeTime > 0
end

function EFFECT:Render()
	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	startDistance = math.max(0, startDistance)
	endDistance = math.max(0, endDistance)
	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	render.SetMaterial(MaterialFront)
	render.DrawSprite(endPos, 8, 8, color_white)
	render.SetMaterial(MaterialMain)
	render.DrawBeam(startPos, endPos, 10, 0, 1, color_white)
end
--lua/effects/effect_sw_laser_green_long/init.lua:

TRACER_FLAG_USEATTACHMENT	= 0x0002
SOUND_FROM_WORLD			= 0
CHAN_STATIC					= 6

EFFECT.Speed				= 6000
EFFECT.Length				= 250
--EFFECT.WhizSound			= Sound( "nomad/whiz.wav" );		-- by Robinhood76 (http:--www.freesound.org/people/Robinhood76/sounds/96556/)
EFFECT.WhizDistance			= 200

local MaterialMain			= Material( "effects/sw_laser_green_main" )
local MaterialFront			= Material( "effects/sw_laser_green_front" )

function EFFECT:GetTracerOrigin(data)
	-- this is almost a direct port of GetTracerOrigin in fx_tracer.cpp
	local start = data:GetStart()

	-- use attachment?
	if (bit.band(data:GetFlags(), TRACER_FLAG_USEATTACHMENT) == TRACER_FLAG_USEATTACHMENT) then
		local entity = data:GetEntity()
		if (not IsValid(entity)) then return start end
		if (not game.SinglePlayer() and entity:IsEFlagSet(EFL_DORMANT)) then return start end

		if (entity:IsWeapon() and entity:IsCarriedByLocalPlayer()) then
			-- can't be done, can't call the real function
			-- local origin = weapon:GetTracerOrigin();
			-- if( origin ) then
			-- 	return origin, angle, entity;
			-- end
			-- use the view model
			local pl = entity:GetOwner()

			if (IsValid(pl)) then
				local vm = pl:GetViewModel()

				if (IsValid(vm) and not LocalPlayer():ShouldDrawLocalPlayer()) then
					entity = vm
					-- HACK: fix the model in multiplayer
				else
					if (entity.WorldModel) then
						entity:SetModel(entity.WorldModel)
					end
				end
			end
		end

		local attachment = entity:GetAttachment(data:GetAttachment())

		if (attachment) then
			start = attachment.Pos
		end
	end

	return start
end

function EFFECT:Init(data)
	self.StartPos = self:GetTracerOrigin(data)
	self.EndPos = data:GetOrigin()
	self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)
	local diff = self.EndPos - self.StartPos
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	self.LifeTime = (diff:Length() + self.Length) / self.Speed
	-- whiz by sound
	local weapon = data:GetEntity()

	if (IsValid(weapon) and (not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer())) then
		local dist, pos, time = util.DistanceToLine(self.StartPos, self.EndPos, EyePos())
	end
end

function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()

	return self.LifeTime > 0
end

function EFFECT:Render()
	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	startDistance = math.max(0, startDistance)
	endDistance = math.max(0, endDistance)
	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	render.SetMaterial(MaterialFront)
	render.DrawSprite(endPos, 8, 8, color_white)
	render.SetMaterial(MaterialMain)
	render.DrawBeam(startPos, endPos, 10, 0, 1, color_white)
end

--lua/effects/effect_sw_laser_red_akimbo/init.lua:

TRACER_FLAG_USEATTACHMENT	= 0x0002;
SOUND_FROM_WORLD			= 0;
CHAN_STATIC					= 6;

EFFECT.Speed				= 6500;
EFFECT.Length				= 64;
--EFFECT.WhizSound			= Sound( "nomad/whiz.wav" );		-- by Robinhood76 (http:--www.freesound.org/people/Robinhood76/sounds/96556/)
EFFECT.WhizDistance			= 72;

local MaterialMain			= Material( "effects/sw_laser_red_main" );
local MaterialFront			= Material( "effects/sw_laser_red_front" );

function EFFECT:GetTracerOrigin(data)
	-- this is almost a direct port of GetTracerOrigin in fx_tracer.cpp
	local start = data:GetStart()

	-- use attachment?
	if (bit.band(data:GetFlags(), TRACER_FLAG_USEATTACHMENT) == TRACER_FLAG_USEATTACHMENT) then
		local entity = data:GetEntity()
		local att = 2 - entity.AnimCycle or data:GetAttachment()
		if (not IsValid(entity)) then return start end
		if (not game.SinglePlayer() and entity:IsEFlagSet(EFL_DORMANT)) then return start end

		if (entity:IsWeapon() and entity:IsCarriedByLocalPlayer()) then
			-- can't be done, can't call the real function
			-- local origin = weapon:GetTracerOrigin();
			-- if( origin ) then
			-- 	return origin, angle, entity;
			-- end
			-- use the view model
			local pl = entity:GetOwner()

			if (IsValid(pl)) then
				local vm = pl:GetViewModel()

				if (IsValid(vm) and not LocalPlayer():ShouldDrawLocalPlayer()) then
					entity = vm
					-- HACK: fix the model in multiplayer
				else
					if (entity.WorldModel) then
						entity:SetModel(entity.WorldModel)
					end
				end
			end
		end

		local attachment = entity:GetAttachment(att)

		if (attachment) then
			start = attachment.Pos
		end
	end

	return start
end

function EFFECT:Init(data)
	self.StartPos = self:GetTracerOrigin(data)
	self.EndPos = data:GetOrigin()
	self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)
	local diff = self.EndPos - self.StartPos
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	self.LifeTime = (diff:Length() + self.Length) / self.Speed
	-- whiz by sound
	local weapon = data:GetEntity()

	if (IsValid(weapon) and (not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer())) then
		local dist, pos, time = util.DistanceToLine(self.StartPos, self.EndPos, EyePos())
	end
end

function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()

	return self.LifeTime > 0
end

function EFFECT:Render()
	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	startDistance = math.max(0, startDistance)
	endDistance = math.max(0, endDistance)
	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	render.SetMaterial(MaterialFront)
	render.DrawSprite(endPos, 8, 8, color_white)
	render.SetMaterial(MaterialMain)
	render.DrawBeam(startPos, endPos, 10, 0, 1, color_white)
end

--lua/effects/effect_sw_laser_red_akimbo_pu/init.lua:
TRACER_FLAG_USEATTACHMENT = 0x0002
SOUND_FROM_WORLD = 0
CHAN_STATIC = 6
EFFECT.Life = 1
EFFECT.Speed = 6500
EFFECT.Length = 64
--EFFECT.WhizSound			= Sound( "nomad/whiz.wav" );		-- by Robinhood76 (http:--www.freesound.org/people/Robinhood76/sounds/96556/)
EFFECT.WhizDistance = 72
local MaterialMain = Material("effects/sw_laser_red_main")
local MaterialFront = Material("effects/sw_laser_red_front")

function EFFECT:Init(data)
	self.Position = data:GetStart()
	self.WeaponEnt = data:GetEntity()
	self.WeaponEntOG = data:GetEntity()
	self.Attachment = data:GetAttachment()
	local owent

	if IsValid(self.WeaponEnt) then
		owent = self.WeaponEnt.Owner or self.WeaponEnt:GetOwner()

		if not IsValid(owent) then
			owent = self.WeaponEnt:GetParent()
		end
	end

	if IsValid(owent) and owent:IsPlayer() then
		if owent ~= LocalPlayer() or owent:ShouldDrawLocalPlayer() then
			self.WeaponEnt = owent:GetActiveWeapon()
			if not IsValid(self.WeaponEnt) then return end
		else
			self.WeaponEnt = owent:GetViewModel()
			local theirweapon = owent:GetActiveWeapon()

			if IsValid(theirweapon) and theirweapon.ViewModelFlip or theirweapon.ViewModelFlipped then
				self.Flipped = true
			end

			if not IsValid(self.WeaponEnt) then return end
		end
	end

	if IsValid(self.WeaponEntOG) and self.WeaponEntOG.MuzzleAttachment then
		self.Attachment = self.WeaponEnt:LookupAttachment(self.WeaponEntOG.MuzzleAttachment)

		if not self.Attachment or self.Attachment <= 0 then
			self.Attachment = 1
		end

		if self.WeaponEntOG.Akimbo then
			if game.SinglePlayer() then
				self.WeaponEntOG.AnimCycle = self.WeaponEntOG:GetNW2Int("AnimCycle") or 0
			end
			self.Attachment = 1 + self.WeaponEntOG.AnimCycle
		end
	end

	local angpos

	if IsValid(self.WeaponEnt) then
		angpos = self.WeaponEnt:GetAttachment(self.Attachment)
	end

	if not angpos or not angpos.Pos then
		angpos = {
			Pos = bvec,
			Ang = uAng
		}
	end

	if self.Flipped then
		local tmpang = (self.Dir or angpos.Ang:Forward()):Angle()
		local localang = self.WeaponEnt:WorldToLocalAngles(tmpang)
		localang.y = localang.y + 180
		localang = self.WeaponEnt:LocalToWorldAngles(localang)
		--localang:RotateAroundAxis(localang:Up(),180)
		--tmpang:RotateAroundAxis(tmpang:Up(),180)
		self.Dir = localang:Forward()
	end

	-- Keep the start and end Pos - we're going to interpolate between them
	if IsValid(owent) and self.Position:Distance(owent:GetShootPos()) > 72 then
		self.WeaponEnt = nil
	end

	self.StartPos = self:GetTracerShootPos(self.WeaponEnt and angpos.Pos or self.Position, self.WeaponEnt, self.Attachment)
	self.EndPos = data:GetOrigin()
	self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)
	self.Normal = (self.EndPos - self.StartPos):GetNormalized()
	self.StartTime = 0
	self.LifeTime = self.Life
	self.data = data
	self.rot = nil
	weapon = data:GetEntity()

	if (IsValid(weapon) and (not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer())) then
		local dist, pos, time = util.DistanceToLine(self.StartPos, self.EndPos, EyePos())
	end
end

function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()

	return self.LifeTime > 0
end

function EFFECT:Render()
	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	startDistance = math.max(0, startDistance)
	endDistance = math.max(0, endDistance)
	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	render.SetMaterial(MaterialFront)
	render.DrawSprite(endPos, 8, 8, color_white)
	render.SetMaterial(MaterialMain)
	render.DrawBeam(startPos, endPos, 10, 0, 1, color_white)
end
--lua/effects/effect_sw_laser_red_long/init.lua:

TRACER_FLAG_USEATTACHMENT	= 0x0002
SOUND_FROM_WORLD			= 0
CHAN_STATIC					= 6

EFFECT.Speed				= 6000
EFFECT.Length				= 250
--EFFECT.WhizSound			= Sound( "nomad/whiz.wav" );		-- by Robinhood76 (http:--www.freesound.org/people/Robinhood76/sounds/96556/)
EFFECT.WhizDistance			= 200

local MaterialMain			= Material( "effects/sw_laser_red_main" )
local MaterialFront			= Material( "effects/sw_laser_red_front" )
local DynamicTracer 		= GetConVar("cl_dynamic_tracer")

function EFFECT:GetTracerOrigin(data)
	-- this is almost a direct port of GetTracerOrigin in fx_tracer.cpp
	local start = data:GetStart()

	-- use attachment?
	if (bit.band(data:GetFlags(), TRACER_FLAG_USEATTACHMENT) == TRACER_FLAG_USEATTACHMENT) then
		local entity = data:GetEntity()
		if (not IsValid(entity)) then return start end
		if (not game.SinglePlayer() and entity:IsEFlagSet(EFL_DORMANT)) then return start end

		if (entity:IsWeapon() and entity:IsCarriedByLocalPlayer()) then
			-- can't be done, can't call the real function
			-- local origin = weapon:GetTracerOrigin();
			-- if( origin ) then
			-- 	return origin, angle, entity;
			-- end
			-- use the view model
			local pl = entity:GetOwner()

			if (IsValid(pl)) then
				local vm = pl:GetViewModel()

				if (IsValid(vm) and not LocalPlayer():ShouldDrawLocalPlayer()) then
					entity = vm
					-- HACK: fix the model in multiplayer
				else
					if (entity.WorldModel) then
						entity:SetModel(entity.WorldModel)
					end
				end
			end
		end

		local attachment = entity:GetAttachment(data:GetAttachment())

		if (attachment) then
			start = attachment.Pos
		end
	end

	return start
end

function EFFECT:Init(data)
	self.StartPos = self:GetTracerOrigin(data)
	self.EndPos = data:GetOrigin()
	self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)
	local diff = self.EndPos - self.StartPos
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	self.LifeTime = (diff:Length() + self.Length) / self.Speed
	-- whiz by sound
	local weapon = data:GetEntity()

	if (IsValid(weapon) and (not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer())) then
		local dist, pos, time = util.DistanceToLine(self.StartPos, self.EndPos, EyePos())
	end
end

function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()

	if DynamicTracer:GetBool() then
		local spawn = util.CRC(tostring(self:GetPos()))
		local dlight = DynamicLight(self:EntIndex() + spawn)
		local endDistance = self.Speed * self.StartTime
		local endPos = self.StartPos + self.Normal * endDistance

		if (dlight) then
			dlight.pos = endPos
			dlight.r = 255
			dlight.g = 0
			dlight.b = 0
			dlight.brightness = 3
			dlight.Decay = 1000
			dlight.Size = 300
			dlight.DieTime = CurTime() + 3
		end
	end

	return self.LifeTime > 0
end

function EFFECT:Render()
	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	startDistance = math.max(0, startDistance)
	endDistance = math.max(0, endDistance)
	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	render.SetMaterial(MaterialFront)
	render.DrawSprite(endPos, 8, 8, color_white)
	render.SetMaterial(MaterialMain)
	render.DrawBeam(startPos, endPos, 10, 0, 1, color_white)
end

--lua/effects/effect_sw_laser_red_old/init.lua:

TRACER_FLAG_USEATTACHMENT	= 0x0002
SOUND_FROM_WORLD			= 0
CHAN_STATIC					= 6

EFFECT.Speed				= 6500
EFFECT.Length				= 64
--EFFECT.WhizSound			= Sound( "nomad/whiz.wav" );		-- by Robinhood76 (http:--www.freesound.org/people/Robinhood76/sounds/96556/)
EFFECT.WhizDistance			= 72

local MaterialMain			= Material( "effects/sw_laser_red_main" )
local MaterialFront			= Material( "effects/sw_laser_red_front" )

function EFFECT:GetTracerOrigin(data)
	-- this is almost a direct port of GetTracerOrigin in fx_tracer.cpp
	local start = data:GetStart()

	-- use attachment?
	if (bit.band(data:GetFlags(), TRACER_FLAG_USEATTACHMENT) == TRACER_FLAG_USEATTACHMENT) then
		local entity = data:GetEntity()
		if (not IsValid(entity)) then return start end
		if (not game.SinglePlayer() and entity:IsEFlagSet(EFL_DORMANT)) then return start end

		if (entity:IsWeapon() and entity:IsCarriedByLocalPlayer()) then
			-- can't be done, can't call the real function
			-- local origin = weapon:GetTracerOrigin();
			-- if( origin ) then
			-- 	return origin, angle, entity;
			-- end
			-- use the view model
			local pl = entity:GetOwner()

			if (IsValid(pl)) then
				local vm = pl:GetViewModel()

				if (IsValid(vm) and not LocalPlayer():ShouldDrawLocalPlayer()) then
					entity = vm
					-- HACK: fix the model in multiplayer
				else
					if (entity.WorldModel) then
						entity:SetModel(entity.WorldModel)
					end
				end
			end
		end

		local attachment = entity:GetAttachment(data:GetAttachment())

		if (attachment) then
			start = attachment.Pos
		end
	end

	return start
end

function EFFECT:Init(data)
	self.StartPos = self:GetTracerOrigin(data)
	self.EndPos = data:GetOrigin()
	self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)
	local diff = (self.EndPos - self.StartPos)
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	self.LifeTime = (diff:Length() + self.Length) / self.Speed
	-- whiz by sound
	local weapon = data:GetEntity()

	if (IsValid(weapon) and (not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer())) then
		local dist, pos, time = util.DistanceToLine(self.StartPos, self.EndPos, EyePos())
	end
end

function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()

	return self.LifeTime > 0
end

function EFFECT:Render()
	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	startDistance = math.max(0, startDistance)
	endDistance = math.max(0, endDistance)
	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	render.SetMaterial(MaterialFront)
	render.DrawSprite(endPos, 8, 8, color_white)
	render.SetMaterial(MaterialMain)
	render.DrawBeam(startPos, endPos, 10, 0, 1, color_white)
end

--lua/effects/effect_sw_laser_red_sniper/init.lua:

TRACER_FLAG_USEATTACHMENT	= 0x0002
SOUND_FROM_WORLD			= 0
CHAN_STATIC					= 6

EFFECT.Speed				= 8000
EFFECT.Length				= 600
--EFFECT.WhizSound			= Sound( "nomad/whiz.wav" );		-- by Robinhood76 (http:--www.freesound.org/people/Robinhood76/sounds/96556/)
EFFECT.WhizDistance			= 250

local MaterialMain			= Material( "effects/sw_laser_red_main" )
local MaterialFront			= Material( "effects/sw_laser_red_front" )

function EFFECT:GetTracerOrigin(data)
	-- this is almost a direct port of GetTracerOrigin in fx_tracer.cpp
	local start = data:GetStart()

	-- use attachment?
	if (bit.band(data:GetFlags(), TRACER_FLAG_USEATTACHMENT) == TRACER_FLAG_USEATTACHMENT) then
		local entity = data:GetEntity()
		if (not IsValid(entity)) then return start end
		if (not game.SinglePlayer() and entity:IsEFlagSet(EFL_DORMANT)) then return start end

		if (entity:IsWeapon() and entity:IsCarriedByLocalPlayer()) then
			-- can't be done, can't call the real function
			-- local origin = weapon:GetTracerOrigin();
			-- if( origin ) then
			-- 	return origin, angle, entity;
			-- end
			-- use the view model
			local pl = entity:GetOwner()

			if (IsValid(pl)) then
				local vm = pl:GetViewModel()

				if (IsValid(vm) and not LocalPlayer():ShouldDrawLocalPlayer()) then
					entity = vm
					-- HACK: fix the model in multiplayer
				else
					if (entity.WorldModel) then
						entity:SetModel(entity.WorldModel)
					end
				end
			end
		end

		local attachment = entity:GetAttachment(data:GetAttachment())

		if (attachment) then
			start = attachment.Pos
		end
	end

	return start
end

function EFFECT:Init(data)
	self.StartPos = self:GetTracerOrigin(data)
	self.EndPos = data:GetOrigin()
	self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)
	local diff = self.EndPos - self.StartPos
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	self.LifeTime = (diff:Length() + self.Length) / self.Speed
	-- whiz by sound
	local weapon = data:GetEntity()

	if (IsValid(weapon) and (not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer())) then
		local dist, pos, time = util.DistanceToLine(self.StartPos, self.EndPos, EyePos())
	end
end

function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()

	return self.LifeTime > 0
end

function EFFECT:Render()
	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	startDistance = math.max(0, startDistance)
	endDistance = math.max(0, endDistance)
	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	render.SetMaterial(MaterialFront)
	render.DrawSprite(endPos, 8, 8, color_white)
	render.SetMaterial(MaterialMain)
	render.DrawBeam(startPos, endPos, 10, 0, 1, color_white)
end

--lua/effects/effect_sw_laser_yellow_akimbo_pu/init.lua:
TRACER_FLAG_USEATTACHMENT = 0x0002
SOUND_FROM_WORLD = 0
CHAN_STATIC = 6
EFFECT.Life = 1
EFFECT.Speed = 6500
EFFECT.Length = 64
--EFFECT.WhizSound			= Sound( "nomad/whiz.wav" );		-- by Robinhood76 (http:--www.freesound.org/people/Robinhood76/sounds/96556/)
EFFECT.WhizDistance = 72
local MaterialMain = Material("effects/sw_laser_yellow_main")
local MaterialFront = Material("effects/sw_laser_yellow_front")

function EFFECT:Init(data)
	self.Position = data:GetStart()
	self.WeaponEnt = data:GetEntity()
	self.WeaponEntOG = data:GetEntity()
	self.Attachment = data:GetAttachment()
	local owent

	if IsValid(self.WeaponEnt) then
		owent = self.WeaponEnt.Owner or self.WeaponEnt:GetOwner()

		if not IsValid(owent) then
			owent = self.WeaponEnt:GetParent()
		end
	end

	if IsValid(owent) and owent:IsPlayer() then
		if owent ~= LocalPlayer() or owent:ShouldDrawLocalPlayer() then
			self.WeaponEnt = owent:GetActiveWeapon()
			if not IsValid(self.WeaponEnt) then return end
		else
			self.WeaponEnt = owent:GetViewModel()
			local theirweapon = owent:GetActiveWeapon()

			if IsValid(theirweapon) and theirweapon.ViewModelFlip or theirweapon.ViewModelFlipped then
				self.Flipped = true
			end

			if not IsValid(self.WeaponEnt) then return end
		end
	end

	if IsValid(self.WeaponEntOG) and self.WeaponEntOG.MuzzleAttachment then
		self.Attachment = self.WeaponEnt:LookupAttachment(self.WeaponEntOG.MuzzleAttachment)

		if not self.Attachment or self.Attachment <= 0 then
			self.Attachment = 1
		end

		if self.WeaponEntOG.Akimbo then
			if game.SinglePlayer() then
				self.WeaponEntOG.AnimCycle = self.WeaponEntOG:GetNW2Int("AnimCycle") or 0
			end
			self.Attachment = 1 + self.WeaponEntOG.AnimCycle
		end
	end

	local angpos

	if IsValid(self.WeaponEnt) then
		angpos = self.WeaponEnt:GetAttachment(self.Attachment)
	end

	if not angpos or not angpos.Pos then
		angpos = {
			Pos = bvec,
			Ang = uAng
		}
	end

	if self.Flipped then
		local tmpang = (self.Dir or angpos.Ang:Forward()):Angle()
		local localang = self.WeaponEnt:WorldToLocalAngles(tmpang)
		localang.y = localang.y + 180
		localang = self.WeaponEnt:LocalToWorldAngles(localang)
		--localang:RotateAroundAxis(localang:Up(),180)
		--tmpang:RotateAroundAxis(tmpang:Up(),180)
		self.Dir = localang:Forward()
	end

	-- Keep the start and end Pos - we're going to interpolate between them
	if IsValid(owent) and self.Position:Distance(owent:GetShootPos()) > 72 then
		self.WeaponEnt = nil
	end

	self.StartPos = self:GetTracerShootPos(self.WeaponEnt and angpos.Pos or self.Position, self.WeaponEnt, self.Attachment)
	self.EndPos = data:GetOrigin()
	self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)
	self.Normal = (self.EndPos - self.StartPos):GetNormalized()
	self.StartTime = 0
	self.LifeTime = self.Life
	self.data = data
	self.rot = nil
	weapon = data:GetEntity()

	if (IsValid(weapon) and (not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer())) then
		local dist, pos, time = util.DistanceToLine(self.StartPos, self.EndPos, EyePos())
	end
end

function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()

	return self.LifeTime > 0
end

function EFFECT:Render()
	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	startDistance = math.max(0, startDistance)
	endDistance = math.max(0, endDistance)
	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	render.SetMaterial(MaterialFront)
	render.DrawSprite(endPos, 8, 8, color_white)
	render.SetMaterial(MaterialMain)
	render.DrawBeam(startPos, endPos, 10, 0, 1, color_white)
end
--gamemodes/starwarsrp/entities/effects/effect_sw_stun_blue/init.lua:
TRACER_FLAG_USEATTACHMENT = 0x0002
SOUND_FROM_WORLD = 0
CHAN_STATIC = 6

EFFECT.Speed = 2000

local StunMaterial = Material("effects/sw_stun_blue")
local DynamicTracer 		= GetConVar("cl_dynamic_tracer")

function EFFECT:GetTracerOrigin(data)
	local start = data:GetStart()

	if bit.band(data:GetFlags(), TRACER_FLAG_USEATTACHMENT) == TRACER_FLAG_USEATTACHMENT then
		local entity = data:GetEntity()

		if !IsValid(entity) then return start end
		if !game.SinglePlayer() and entity:IsEFlagSet(EFL_DORMANT) then return start end

		if entity:IsWeapon() and entity:IsCarriedByLocalPlayer() then
			local ply = entity:GetOwner()
			if IsValid(ply) then
				local viewModel = ply:GetViewModel()
				if IsValid(viewModel) and !LocalPlayer():ShouldDrawLocalPlayer() then
					entity = viewModel
				else
					if entity.WorldModel then
						entity:SetModel(entity.WorldModel)
					end
				end
			end
		end

		local attachment = entity:GetAttachment(data:GetAttachment() + 0)
		if attachment then
			start = attachment.Pos
		end
	end

	return start
end

function EFFECT:Init(data)
	self.StartPos = self:GetTracerOrigin(data)
	self.EndPos = data:GetOrigin()

	self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)

	local diff = (self.EndPos - self.StartPos)

	self.Normal = diff:GetNormal()
	self.StartTime = 0
	self.LifeTime = diff:Length() / self.Speed
end

function EFFECT:Think()
	if self.StartTime > 1 then return false end

	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime();

	if DynamicTracer:GetBool() then
		local spawn = util.CRC(tostring(self:GetPos()))
		local dlight = DynamicLight(self:EntIndex() + spawn)
		local distance = self.Speed * self.StartTime
		local pos = self.StartPos + self.Normal * distance

		if (dlight) then
			dlight.pos = pos
			dlight.r = 15
			dlight.g = 20
			dlight.b = 255
			dlight.brightness = 5
			dlight.Decay = 2000
			dlight.Size = 500
			dlight.DieTime = CurTime() + 3
		end
	end

	return self.LifeTime > 0
end

function EFFECT:Render()
	local distance = math.max(0, self.Speed * self.StartTime)
	local pos = self.StartPos + self.Normal * distance

	local size = (200 * 200) / 8192

	local x = Vector(0, 0, 1)
	local left = x:Cross(self.Normal)
	left:Normalize()
	local up = left:Cross(self.Normal)
	up:Normalize()

	render.SetMaterial(StunMaterial)
	render.DrawQuad(
		pos - left * size - up * size,
		pos - left * size + up * size,
		pos + left * size + up * size,
		pos + left * size - up * size
	)
	render.DrawQuad(
		pos + left * size + up * size,
		pos - left * size + up * size,
		pos - left * size - up * size,
		pos + left * size - up * size
	)
end
--addons/wos-alcs-custom/lua/effects/force_lightning_green.lua:
--DO NOT EDIT OR REUPLOAD THIS FILE

function EFFECT:Init( data )
	self.Ent = data:GetEntity()

	self.LifeTime = 0.2
	self.DieTime = CurTime() + self.LifeTime

	if IsValid(self.Ent) then
		local Dir = self.Ent:GetAimVector()
		local StartPos = self.Ent:GetShootPos() - Dir * 25
		local EndPos = StartPos + Dir * 625

		self:SetRenderBoundsWS( StartPos, EndPos )
	end
end

function EFFECT:Think()
	if self.DieTime < CurTime() or not IsValid(self.Ent) then
		return false
	end

	return true
end

local BeamMat = Material("trails/electric")
local mat = Material("sprites/light_glow02_add")

function EFFECT:Render()
	if IsValid( self.Ent ) then
		local boneID = self.Ent:LookupBone("ValveBiped.Bip01_L_Hand")

		if boneID then
			local T = CurTime() * 10

			local X = math.cos( T ) * math.cos( T * 10 ) * 4
			local Y = math.sin( T ) * math.cos( T * 10 ) * 4
			local pos, ang = self.Ent:GetBonePosition( boneID )
			local StartPos = pos + ang:Up() * 2 + ang:Forward() * 5 + ang:Right() * 2

			if not self.TargetPos then
				self.TargetPos = self.Ent:GetEyeTrace().HitPos

				local dlight = DynamicLight( self.Ent:EntIndex() + math.random(0,99) )
				if dlight then
					dlight.pos = StartPos
					dlight.r = 255
					dlight.g = 255
					dlight.b = 255
					dlight.brightness = 3
					dlight.Decay = 2000
					dlight.Size = 150
					dlight.DieTime = CurTime() + 0.1
				end
			end

			local Dir = ((self.TargetPos - StartPos):Angle() + Angle(X,Y,0)):Forward()
			local EndPos = StartPos + Dir * math.random(200,600)

			local trace = util.TraceLine({start = StartPos, endpos = EndPos, filter = self.Ent})

			if (self.HitFX or 0) < CurTime() then
				self.HitFX = CurTime() + 0.01

				if trace.Hit then
					local effectdata = EffectData()
					effectdata:SetOrigin( trace.HitPos + trace.HitNormal )
					effectdata:SetNormal( -trace.HitNormal )
					util.Effect("force_lightning_hit", effectdata )

					if math.random(1,3) == 3 then
						local dlight = DynamicLight(self.Ent:EntIndex() + math.random(100,9999))
						if dlight then
							dlight.pos = trace.HitPos + trace.HitNormal
							dlight.r = 255
							dlight.g = 255
							dlight.b = 150
							dlight.brightness = 3
							dlight.Decay = 2000
							dlight.Size = 100
							dlight.DieTime = CurTime() + 0.01
						end
					end
				end
			end

			render.SetMaterial(mat)
			render.DrawSprite(StartPos, 64, 64, Color( 0, 255, 0, 255))
			render.DrawSprite(StartPos, 16, 16, Color( 255, 255, 255, 255))

			local BeamStart = StartPos
			local BeamPrevious = BeamStart
			local BeamEnd = trace.HitPos
			local BeamSub = BeamEnd - BeamStart
			local BeamDir = BeamSub:GetNormalized()
			local BeamDistance = (BeamSub):Length()
			local SegmentLength = 50

			render.SetMaterial(BeamMat)
			render.DrawBeam(BeamStart, BeamEnd, 18, 0, 1, Color(0, 255, 0, 255))

			for SegmentStart = 0, BeamDistance, SegmentLength do
				local SegmentEnd = BeamPrevious + (BeamDir:Angle() + Angle(math.Rand(-8,8),math.Rand(-8,8),0)):Forward() * SegmentLength

				local Width = (SegmentStart / BeamDistance)
				if SegmentStart + SegmentLength >= BeamDistance then
					SegmentEnd = BeamEnd
				end

				render.DrawBeam( BeamPrevious, SegmentEnd, 16 * (1 - Width), Width, Width + 0.15, Color( 150 + 155 * Width, 255, 0, 255 ) )

				local BranchEnd1 = SegmentEnd + (BeamDir:Angle() + Angle(math.Rand(-20,20),math.Rand(-20,20),0)):Forward() * SegmentLength * 0.5

				render.DrawBeam( SegmentEnd, BranchEnd1, math.Rand(8,16) * (1 - Width), 0, 0.2, Color( 0, 255, 0, 255 ) )
				render.DrawBeam( BranchEnd1, BranchEnd1 + (BeamDir:Angle() + Angle(math.Rand(-6,6),math.Rand(-6,6),0)):Forward() * SegmentLength * 1.5, math.Rand(4,8) * (1 - Width), 0, 1.5, Color( 0, 255, 0, 255 ) )

				BeamPrevious = SegmentEnd
			end
		end
	end
end

--lua/effects/lfs_fb_ballturret_right_projector.lua:
EFFECT.Mat = Material("effects/lfs_base/ballturret_projectorbeam")
EFFECT.HitMat = Material("sprites/light_glow02_add")

function EFFECT:Init( data )
	self.Entity = data:GetEntity()
	
	if IsValid(self.Entity) then
		self.ID = self.Entity:LookupAttachment("R_Ball_Attachement")
		
		if self.ID then
			local Muzzle = self.Entity:GetAttachment(self.ID)

			self:SetRenderBoundsWS(self.Entity:GetPos(), Muzzle.Ang:Up() * 50000)
		end
	end
end

function EFFECT:Think()
	if not IsValid(self.Entity) or not self.ID or not self.Entity:GetBTRFire() then
		return false
	end
	
	return true
end

function EFFECT:Render()
	if not self.ID or not IsValid(self.Entity) then return end
	
	local Muzzle = self.Entity:GetAttachment(self.ID)
	
	local Dir = -Muzzle.Ang:Forward()
    local Up = Muzzle.Ang:Up()
	local StartPos = Muzzle.Pos + Up * 20 + Dir * 60
	local Trace = util.TraceLine( { start = StartPos, endpos = StartPos + Dir * 50000, filter = self } )
	local EndPos = Trace.HitPos
	
	self:SetRenderBoundsWS( StartPos, EndPos )
	
	render.SetMaterial( self.Mat )
	render.DrawBeam( StartPos, EndPos, 14 + math.random(0,4), 1, 0, Color(0,255,0,255) )
	render.DrawBeam( StartPos, EndPos, 3 + math.random(0,4), 1, 0, Color(255,255,255,255) )
	
	render.SetMaterial( self.HitMat )
	local A = 150 + math.random(0,20)
	local B = 70 + math.random(0,20)
	render.DrawSprite( StartPos, A, A, Color(0,255,0,255) )
	render.DrawSprite( StartPos, B, B, Color(255,255,255,255) )
	
	render.DrawSprite( EndPos, A, A, Color(0,255,0,255) )
	render.DrawSprite( EndPos + VectorRand() * 10, B, B, Color(255,255,255,255) )
	
	if math.random(0,5) == 1 then
		local emitter = ParticleEmitter( EndPos, false )
		local dir = (self.Entity:GetPos() - EndPos):GetNormalized()
		
		for i = 0, 10 do
			local particle = emitter:Add( "sprites/rico1", EndPos )
			local vel = VectorRand()  * 100 + dir * 40
			
			if particle then
				particle:SetVelocity( vel )
				particle:SetAngles( vel:Angle() + Angle(0,90,0) )
				particle:SetDieTime( math.Rand(0.1,0.3) * 0.5 )
				particle:SetStartAlpha( math.Rand( 200, 255 ) )
				particle:SetEndAlpha( 0 )
				particle:SetStartSize( math.Rand(1,30) )
				particle:SetEndSize( 0 )
				particle:SetRoll( math.Rand(-100,100) )
				particle:SetRollDelta( math.Rand(-100,100) )

				particle:SetAirResistance( 0 )
			end
		end
		
		emitter:Finish()
	end
end

--lua/effects/lfs_fb_detonator_explosion.lua:
function EFFECT:Init(data)
	self.Pos = data:GetOrigin()
	local Emitter = ParticleEmitter(self.Pos)
	if Emitter == nil then return end
	
	-- Fire
	for _ = 1, 3 do
		local EffectCode = Emitter:Add("particles/flamelet1",self.Pos)
            EffectCode:SetVelocity(Vector(math.random(-30,30),math.random(-30,30),math.random(30,40)))
            EffectCode:SetDieTime(math.Rand(0.4,0.6)) -- How much time until it dies
            EffectCode:SetStartAlpha(math.Rand(90,100)) -- Transparency
            EffectCode:SetStartSize(math.Rand(60,80)) -- Size of the effect
            EffectCode:SetEndSize(math.Rand(100,100)) -- Size of the effect at the end (The effect slowly trasnsforms to this size)
            EffectCode:SetRoll(math.Rand(480,540))
            EffectCode:SetRollDelta(math.Rand(0,0)) -- How fast it rolls
            EffectCode:SetColor(255,255,255) -- The color of the effect
            EffectCode:SetGravity(Vector(0,0,math.random(-30,-10))) -- The Gravity
	end

	-- Smoke screen
	for _ = 1, 5 do
		local EffectCode = Emitter:Add("particles/smokey",self.Pos)
            EffectCode:SetVelocity(Vector(math.random(-40,40),math.random(-40,40),math.random(5,15)))
            EffectCode:SetDieTime(math.Rand(7,9)) -- How much time until it dies
            EffectCode:SetStartAlpha(math.Rand(200,230)) -- Transparency
            EffectCode:SetStartSize(math.Rand(80,100)) -- Size of the effect
            EffectCode:SetEndSize(math.Rand(130,150)) -- Size of the effect at the end (The effect slowly trasnsforms to this size)
            EffectCode:SetRoll(math.Rand(480,540))
            EffectCode:SetRollDelta(math.Rand(-0.2,0.2)) -- How fast it rolls
            EffectCode:SetColor(50,50,50) -- The color of the effect
            EffectCode:SetGravity(Vector(0, 0, 0)) -- The Gravity
            EffectCode:SetAirResistance(15)
	end

	-- Cloud of smoke that goes up
	for _ = 1, 5 do
		local EffectCode = Emitter:Add("particles/smokey",self.Pos)
            EffectCode:SetVelocity(Vector(math.random(-60,70),math.random(-60,70),math.random(70,100)))
            EffectCode:SetDieTime(math.Rand(3,4)) -- How much time until it dies
            EffectCode:SetStartAlpha(math.Rand(150,190)) -- Transparency
            EffectCode:SetStartSize(math.Rand(80,100)) -- Size of the effect
            EffectCode:SetEndSize(math.Rand(130,150)) -- Size of the effect at the end (The effect slowly trasnsforms to this size)
            EffectCode:SetRoll(math.Rand(480,540))
            EffectCode:SetRollDelta(math.Rand(-1,1)) -- How fast it rolls
            EffectCode:SetColor(50,50,50) -- The color of the effect
            EffectCode:SetGravity(Vector(0,0,math.random(-30,-10))) -- The Gravity
	end
    
	Emitter:Finish()
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end
--lua/effects/lfs_fb_laser_blue.lua:
EFFECT.Mat = Material( "effects/spark" )
EFFECT.Mat2 = Material( "sprites/light_glow02_add" )

local Materials = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}
local color_white = Color(255, 255, 255, 255)
local color_blue = Color(55, 169, 237, 255)

function EFFECT:Init( data )
	self.StartPos = data:GetStart()
	self.EndPos = data:GetOrigin()
	self.Dir = self.EndPos - self.StartPos

	self:SetRenderBoundsWS( self.StartPos, self.EndPos )

	self.TracerTime = math.min( 1, self.StartPos:Distance( self.EndPos ) / 15000 ) * 0.5
	self.Length = math.Rand( 0.4, 0.45 )
	-- Die when it reaches its target
	self.DieTime = CurTime() + self.TracerTime
	
	local Dir = self.Dir:GetNormalized()
	local emitter = ParticleEmitter( self.StartPos, false )
	
	for i = 0, 12 do
		local Pos = self.StartPos + Dir * i * 0.7 * math.random(1,2) * 0.5
		local particle = emitter:Add( "effects/muzzleflash2", Pos )
		local Size = 2
		
		if particle then
			particle:SetVelocity( Dir * 800 )
			particle:SetDieTime( 0.05 )
			particle:SetStartAlpha( 255 * Size )
			particle:SetStartSize( math.max( math.random(10,24) - i * 0.5,0.1 ) * Size )
			particle:SetEndSize( 0 )
			particle:SetRoll( math.Rand( -1, 1 ) )
			particle:SetColor( color_blue )
			particle:SetCollide( false )
		end
	end
	
	for i = 0,20 do
		local particle = emitter:Add( Materials[math.random(1,table.Count( Materials ))],self.StartPos )
		local rCol = 255
		
		if particle then
			particle:SetVelocity( Dir * math.Rand(1000,3000) + VectorRand() * math.Rand(0,10) )
			particle:SetDieTime( math.Rand(0.05,0.2) )
			particle:SetAirResistance( math.Rand(50,100) ) 
			particle:SetStartAlpha( 20 )
			particle:SetStartSize( 2 )
			particle:SetEndSize( math.Rand(5,10) )
			particle:SetRoll( math.Rand(-1,1) )
			particle:SetColor( color_white )
			particle:SetGravity( VectorRand() * 200 + Vector(0,0,200) )
			particle:SetCollide( false )
		end
	end
	
	emitter:Finish()
end

function EFFECT:Think()
	if CurTime() > self.DieTime then
		local effectdata = EffectData()
			effectdata:SetStart( Vector(50, 80, 255) ) 
			effectdata:SetOrigin( self.EndPos )
			effectdata:SetNormal( self.Dir:GetNormalized() )
		util.Effect( "lfs_laser_hit", effectdata )
		
		return false
	end

	return true
end

function EFFECT:Render()
	local fDelta = ( self.DieTime - CurTime() ) / self.TracerTime
	fDelta = math.Clamp( fDelta, 0, 1 ) ^ 2 -- lasers are faster than bullets...

	local sinWave = math.sin( fDelta * math.pi )
	
	local Pos1 = self.EndPos - self.Dir * ( fDelta - sinWave * self.Length )
	
	render.SetMaterial( self.Mat )
	render.DrawBeam( Pos1, self.EndPos - self.Dir * ( fDelta + sinWave * self.Length ), 45, 1, 0, color_blue )
		
	render.DrawBeam( Pos1, self.EndPos - self.Dir * ( fDelta + sinWave * self.Length ), 15, 1, 0, color_white )
end
--lua/effects/lfs_fb_wingrocket.lua:
EFFECT.Offset = Vector(-8, 0, 0)
EFFECT.mat = Material("sprites/light_glow02_add")
EFFECT.Materials = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

function EFFECT:Init( data )
	self.Entity = data:GetEntity()

	if IsValid( self.Entity ) then
		self.OldPos = self.Entity:LocalToWorld( self.Offset )

		self.Emitter = ParticleEmitter( self.Entity:LocalToWorld( self.OldPos ), false )
	end
end

function EFFECT:doFX( pos )
	if not IsValid(self.Entity) then return end

	if self.Emitter then
		local emitter = self.Emitter
        local particle = emitter:Add(self.Materials[math.random(1, table.Count(self.Materials))], pos)
        
        if particle then
            particle:SetGravity(Vector(0, 0, 100) + VectorRand() * 50) 
            particle:SetVelocity(-self.Entity:GetForward() * 500)
            particle:SetAirResistance(600) 
            particle:SetDieTime(math.Rand(2,3))
            particle:SetStartAlpha(150)
            particle:SetStartSize(math.Rand(6,12))
            particle:SetEndSize(math.Rand(40,90))
            particle:SetRoll(math.Rand( -1, 1 ))
            particle:SetColor(50, 50, 50)
            particle:SetCollide(false)
        end

        local particle = emitter:Add("particles/flamelet"..math.random(1 ,5), pos)
        if particle then
            particle:SetVelocity(-self.Entity:GetForward() * 300 + self.Entity:GetVelocity())
            particle:SetDieTime(0.1)
            particle:SetAirResistance(0) 
            particle:SetStartAlpha(255)
            particle:SetStartSize(4)
            particle:SetEndSize(0)
            particle:SetRoll(math.Rand(-1,1))
            particle:SetColor(255, 255, 255)
            particle:SetGravity(Vector(0, 0, 0))
            particle:SetCollide(false)
        end
	end
end


function EFFECT:doFXbroken( pos )
	if not IsValid( self.Entity ) then return end

	if self.Emitter then
		local emitter = self.Emitter

		local particle = emitter:Add(self.Materials[math.random(1, table.Count(self.Materials))], pos)
		if particle then
			particle:SetGravity(Vector(0, 0, 100) + VectorRand() * 50) 
			particle:SetVelocity(-self.Entity:GetForward() * 500)
			particle:SetAirResistance(600) 
			particle:SetDieTime(math.Rand(2, 3))
			particle:SetStartAlpha(150 )
			particle:SetStartSize(math.Rand(6, 12))
			particle:SetEndSize(math.Rand(40, 90))
			particle:SetRoll(math.Rand(-1, 1))
			particle:SetColor(50, 50, 50)
			particle:SetCollide(false)
		end

		local particle = emitter:Add("particles/flamelet"..math.random(1, 5), pos)
		if particle then
			particle:SetVelocity(-self.Entity:GetForward() * 500 + VectorRand() * 50)
			particle:SetDieTime(0.25)
			particle:SetAirResistance(600) 
			particle:SetStartAlpha(255)
			particle:SetStartSize(math.Rand(25,40))
			particle:SetEndSize(math.Rand(10,15))
			particle:SetRoll(math.Rand(-1,1))
			particle:SetColor(255, 255, 255)
			particle:SetGravity(Vector(0, 0, 0))
			particle:SetCollide(false)
		end
	end
end

function EFFECT:Think()
	if IsValid( self.Entity ) then
		self.nextDFX = self.nextDFX or 0
		
		if self.nextDFX < CurTime() then
			self.nextDFX = CurTime() + 0.02

			self.Disabled = self.Entity:GetDisabled()

			local oldpos = self.OldPos
			local newpos = self.Entity:LocalToWorld( self.Offset )
			self:SetPos( newpos )

			local Sub = (newpos - oldpos)
			local Dir = Sub:GetNormalized()
			local Len = Sub:Length()

			self.OldPos = newpos

			for i = 0, Len, 45 do
				local pos = oldpos + Dir * i

				if self.Disabled then
					self:doFXbroken( pos )
				else
					self:doFX( pos )
				end
			end
		end

		return true
	end

	if self.Emitter then
		self.Emitter:Finish()
	end

	return false
end

local effectcolor = Color(0, 127, 255, 255)
function EFFECT:Render()
	if self.Disabled then return end

	local ent = self.Entity
	local pos = ent:LocalToWorld(self.Offset)

	render.SetMaterial(self.mat)
        
    for i =0,10 do
        local Size = (10 - i) * 25.6
        render.DrawSprite(pos - ent:GetForward() * i * 5, Size, Size, effectcolor)
    end

	render.DrawSprite(pos, 256, 256, effectcolor)
end

--addons/lvs_starwars/lua/effects/lvs_concussion_explosion.lua:

local GlowMat = Material( "sprites/light_glow02_add" )
local Materials = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

function EFFECT:Init( data )
	self.Pos = data:GetOrigin()

	self.LifeTime = 0.4
	self.DieTime = CurTime() + self.LifeTime

	local emitter = ParticleEmitter( self.Pos, false )

	if not IsValid( emitter ) then return end

	for i = 0,30 do
		local particle = emitter:Add( Materials[ math.random(1, #Materials ) ], self.Pos )
		
		if particle then
			particle:SetVelocity( VectorRand(-1,1) * 800 )
			particle:SetDieTime( math.Rand(4,6) )
			particle:SetAirResistance( math.Rand(200,600) ) 
			particle:SetStartAlpha( 100 )
			particle:SetStartSize( math.Rand(30,60) )
			particle:SetEndSize( math.Rand(100,150) )
			particle:SetRoll( math.Rand(-1,1) )
			particle:SetColor( 50,50,50 )
			particle:SetGravity( Vector( 0, 0, 100 ) )
			particle:SetCollide( false )
		end
	end

	for i = 0, 20 do
		local particle = emitter:Add( "sprites/light_glow02_add", self.Pos )
		
		local vel = VectorRand() * 400
		
		if particle then
			particle:SetVelocity( vel )
			particle:SetAngles( vel:Angle() + Angle(0,90,0) )
			particle:SetDieTime( math.Rand(0.4,0.8) )
			particle:SetStartAlpha( 255 )
			particle:SetEndAlpha( 0 )
			particle:SetStartSize( math.Rand(24,48) )
			particle:SetEndSize( 0 )
			particle:SetRoll( math.Rand(-100,100) )
			particle:SetRollDelta( math.Rand(-100,100) )
			particle:SetColor( 255, 40, 100 )
			particle:SetGravity( Vector(0,0,-600) )

			particle:SetAirResistance( 0 )
			
			particle:SetCollide( true )
			particle:SetBounce( 0.5 )
		end
	end
	
	for i = 0, 40 do
		local particle = emitter:Add( "effects/lvs_base/flamelet"..math.random(1,5), self.Pos )
		
		if particle then
			particle:SetVelocity( VectorRand(-1,1) * 500 )
			particle:SetDieTime( 0.14 )
			particle:SetStartAlpha( 255 )
			particle:SetStartSize( 10 )
			particle:SetEndSize( math.Rand(30,60) )
			particle:SetEndAlpha( 100 )
			particle:SetRoll( math.Rand( -1, 1 ) )
			particle:SetColor( 200,150,150 )
			particle:SetCollide( false )
		end
	end

	emitter:Finish()

	local Pos = self.Pos
	local ply = LocalPlayer():GetViewEntity()
	if IsValid( ply ) then
		local delay = (Pos - ply:GetPos()):Length() / 13503.9
		if delay <= 0.11 then
			sound.Play( "ambient/explosions/explode_9.wav", Pos, 85, 100, 1 - delay * 8 )
		end

		timer.Simple( delay, function()
			sound.Play( "LVS.MISSILE_EXPLOSION", Pos )
		end )
	else
		sound.Play( "LVS.MISSILE_EXPLOSION", Pos )
	end
end

function EFFECT:Think()
	if self.DieTime < CurTime() then return false end

	return true
end

function EFFECT:Render()
	local Scale = (self.DieTime - CurTime()) / self.LifeTime
	render.SetMaterial( GlowMat )
	render.DrawSprite( self.Pos, 400 * Scale, 400 * Scale, Color( 255, 40, 100, 255) )
	render.DrawSprite( self.Pos, 100 * Scale, 100 * Scale, Color( 255, 255, 255, 255) )
end

--addons/lvs_starwars/lua/effects/lvs_laser_blue.lua:

EFFECT.MatBeam = Material( "effects/spark" )
EFFECT.MatSprite = Material( "sprites/light_glow02_add" )

function EFFECT:Init( data )
	local pos  = data:GetOrigin()
	local dir = data:GetNormal()

	self.ID = data:GetMaterialIndex()

	self:SetRenderBoundsWS( pos, pos + dir * 50000 )
end

function EFFECT:Think()
	if not LVS:GetBullet( self.ID ) then return false end

	return true
end

function EFFECT:Render()
	local bullet = LVS:GetBullet( self.ID )

	local endpos = bullet:GetPos()
	local dir = bullet:GetDir()

	local len = 1000 * bullet:GetLength()

	render.SetMaterial( self.MatSprite ) 
	render.DrawBeam( endpos - dir * len * 4, endpos + dir * len * 4, 200, 1, 0, Color( 0, 0, 255, 255 ) )

	render.SetMaterial( self.MatBeam )
	render.DrawBeam( endpos - dir * len, endpos + dir * len, 45, 1, 0, Color( 0, 0, 255, 255 ) )
	render.DrawBeam( endpos - dir * len, endpos + dir * len, 15, 1, 0, Color( 255, 255, 255, 255 ) )
end

--addons/lvs_starwars/lua/effects/lvs_laser_green.lua:

EFFECT.MatBeam = Material( "effects/spark" )
EFFECT.MatSprite = Material( "sprites/light_glow02_add" )

function EFFECT:Init( data )
	local pos  = data:GetOrigin()
	local dir = data:GetNormal()

	self.ID = data:GetMaterialIndex()

	self:SetRenderBoundsWS( pos, pos + dir * 50000 )
end

function EFFECT:Think()
	if not LVS:GetBullet( self.ID ) then return false end

	return true
end

function EFFECT:Render()
	local bullet = LVS:GetBullet( self.ID )

	local endpos = bullet:GetPos()
	local dir = bullet:GetDir()

	local len = 1000 * bullet:GetLength()

	render.SetMaterial( self.MatSprite ) 
	render.DrawBeam( endpos - dir * len * 4, endpos + dir * len * 4, 200, 1, 0, Color( 0, 255, 0, 255 ) )

	render.SetMaterial( self.MatBeam )
	render.DrawBeam( endpos - dir * len, endpos + dir * len, 45, 1, 0, Color( 0, 255, 0, 255 ) )
	render.DrawBeam( endpos - dir * len, endpos + dir * len, 15, 1, 0, Color( 255, 255, 255, 255 ) )
end

--addons/lvs_starwars/lua/effects/lvs_laser_red.lua:

EFFECT.MatBeam = Material( "effects/spark" )
EFFECT.MatSprite = Material( "sprites/light_glow02_add" )

function EFFECT:Init( data )
	local pos  = data:GetOrigin()
	local dir = data:GetNormal()

	self.ID = data:GetMaterialIndex()

	self:SetRenderBoundsWS( pos, pos + dir * 50000 )
end

function EFFECT:Think()
	if not LVS:GetBullet( self.ID ) then return false end

	return true
end

function EFFECT:Render()
	local bullet = LVS:GetBullet( self.ID )

	local endpos = bullet:GetPos()
	local dir = bullet:GetDir()

	local len = 1000 * bullet:GetLength()

	render.SetMaterial( self.MatSprite ) 
	render.DrawBeam( endpos - dir * len * 4, endpos + dir * len * 4, 200, 1, 0, Color( 255, 0, 0, 255 ) )

	render.SetMaterial( self.MatBeam )
	render.DrawBeam( endpos - dir * len, endpos + dir * len, 45, 1, 0, Color( 255, 0, 0, 255 ) )
	render.DrawBeam( endpos - dir * len, endpos + dir * len, 15, 1, 0, Color( 255, 255, 255, 255 ) )
end

--addons/lvs_base/lua/effects/lvs_physics_impact.lua:

local Materials = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

function EFFECT:Init( data )
	if not LVS.ShowPhysicsEffects then return end

	local dir = data:GetNormal()
	local pos  = data:GetOrigin() + dir

	local emitter = ParticleEmitter( pos, false )

	for i = 0, 10 do
		local particle = emitter:Add( "effects/spark", pos )

		local vel = VectorRand() * 75 + dir * 75 + Vector(0,0,100)

		if not particle then continue end

		particle:SetVelocity( vel )
		particle:SetDieTime( math.Rand(2.5,5) )
		particle:SetAirResistance( 10 ) 
		particle:SetStartAlpha( 255 )

		particle:SetStartLength( 6 )
		particle:SetEndLength(0)

		particle:SetStartSize( 3 )
		particle:SetEndSize( 0 )

		particle:SetRoll( math.Rand(-5,5) )
		particle:SetColor( 255, 200, 50 )
		particle:SetGravity( Vector(0,0,-600) )
		particle:SetCollide( true )
	end

	local smoke = emitter:Add( Materials[ math.random(1, #Materials ) ], pos )

	if smoke then
		smoke:SetVelocity( dir * 30 + VectorRand() * 15 )
		smoke:SetDieTime( math.Rand(1.5,3) )
		smoke:SetAirResistance( 100 ) 
		smoke:SetStartAlpha( 100 )
		smoke:SetEndAlpha( 0 )
		smoke:SetStartSize( 15 )
		smoke:SetEndSize( 30 )
		smoke:SetColor(30,30,30)
		smoke:SetGravity(Vector(0,0,40))
		smoke:SetCollide( false )
		smoke:SetRollDelta( math.Rand(-1,1) )
	end

	local flash = emitter:Add( "effects/yellowflare",pos )

	if flash then
		flash:SetPos( pos )
		flash:SetStartAlpha( 200 )
		flash:SetEndAlpha( 0 )
		flash:SetColor( 255, 200, 0 )
		flash:SetEndSize( 100 )
		flash:SetDieTime( 0.1 )
		flash:SetStartSize( 0 )
	end

	emitter:Finish()
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end

--addons/lvs_base/lua/effects/lvs_physics_scrape.lua:

local Materials = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

function EFFECT:Init( data )
	if not LVS.ShowPhysicsEffects then
		self.LifeTime = 0
		self.DieTime = 0

		return
	end

	self.Pos = data:GetOrigin()

	self.mat = Material( "sprites/light_glow02_add" )

	self.LifeTime = 0.2
	self.DieTime = CurTime() + self.LifeTime

	local Col = self.Col
	local Pos = self.Pos
	local Dir = data:GetNormal()
	local Strength = data:GetMagnitude()

	local emitter = ParticleEmitter( Pos, false )

	for i = 0,1 do
		local particle = emitter:Add( Materials[ math.random(1, #Materials ) ], Pos )
		
		local vel = VectorRand() * 100 + Dir * 40
		
		if particle then			
			particle:SetVelocity( vel )
			particle:SetDieTime( 1 )
			particle:SetAirResistance( 1000 ) 
			particle:SetStartAlpha( 10 )
			particle:SetStartSize( 2 )
			particle:SetEndSize( 12 )
			particle:SetRoll( math.Rand(-1,1) )
			particle:SetColor( 40, 30, 20 )
			particle:SetGravity( Dir * 50 )
			particle:SetCollide( false )
		end
	end

	for i = 0, 3 do
		local particle = emitter:Add( "effects/spark", Pos )
		
		local vel = VectorRand() * 25 * (1 - Strength) + (VectorRand() * 100 + Dir * 150) * Strength
		
		if particle then
			particle:SetVelocity( vel )
			particle:SetAngles( vel:Angle() + Angle(0,90,0) )
			particle:SetDieTime( 2 )
			particle:SetStartAlpha( math.Rand( 200, 255 ) )
			particle:SetEndAlpha( 0 )

			particle:SetStartLength( 4 )
			particle:SetEndLength(0)

			particle:SetStartSize( 2 )
			particle:SetEndSize( 0 )

			particle:SetRoll( math.Rand(-100,100) )
			particle:SetRollDelta( math.Rand(-100,100) )
			particle:SetCollide( true )
			particle:SetBounce( 0.5 )
			particle:SetAirResistance( 0 )
			particle:SetColor( 255, 200, 50 )
			particle:SetGravity( Vector(0,0,-600) )
		end
	end

	emitter:Finish()
end

function EFFECT:Think()
	if self.DieTime < CurTime() then
		return false
	end

	return true
end

local mat = Material( "sprites/light_glow02_add" )
function EFFECT:Render()
	if not LVS.ShowPhysicsEffects then return end

	local Scale = (self.DieTime - CurTime()) / self.LifeTime
	render.SetMaterial( mat )
	render.DrawSprite( self.Pos, 32, 32, Color( 255 * Scale, 175 * Scale, 80 * Scale, 255) ) 
end


--addons/lvs_starwars/lua/effects/lvs_proton_trail.lua:
EFFECT.Offset = Vector(-8,0,0)

local GlowMat = Material( "effects/select_ring" )

function EFFECT:Init( data )
	self.Entity = data:GetEntity()

	if IsValid( self.Entity ) then
		self.OldPos = self.Entity:LocalToWorld( self.Offset )

		self.Emitter = ParticleEmitter( self.Entity:LocalToWorld( self.OldPos ), false )
	end
end

function EFFECT:doFX( pos )
	if not IsValid( self.Entity ) then return end

	if IsValid( self.Emitter ) then
		local emitter = self.Emitter

		local particle = emitter:Add( "effects/lvs_base/flamelet"..math.random(1,5), pos )
		if particle then
			particle:SetVelocity( -self.Entity:GetForward() * math.Rand(250,800) + self.Entity:GetVelocity())
			particle:SetDieTime( 1 )
			particle:SetAirResistance( 0 ) 
			particle:SetStartAlpha( 255 )
			particle:SetStartSize( 8 )
			particle:SetEndSize( 1 )
			particle:SetRoll( math.Rand(-1,1) )
			particle:SetColor( 0,0,255 )
			particle:SetGravity( Vector( 0, 0, 600 ) )
			particle:SetCollide( false )
		end
		
		local particle = emitter:Add( "effects/lvs_base/flamelet"..math.random(1,5), self.Entity:GetPos() )
		if particle then
			particle:SetVelocity( -self.Entity:GetForward() * 200 + VectorRand() * 50 )
			particle:SetDieTime( 1 )
			particle:SetAirResistance( 600 ) 
			particle:SetStartAlpha( 255 )
			particle:SetStartSize( 6 )
			particle:SetEndSize( 2 )
			particle:SetRoll( math.Rand(-1,1) )
			particle:SetColor( 0,0,255 )
			particle:SetGravity( Vector( 0, 0, 600 ) )
			particle:SetCollide( false )
		end
	end
end

function EFFECT:Think()
	if IsValid( self.Entity ) then
		self.nextDFX = self.nextDFX or 0
		
		if self.nextDFX < CurTime() then
			self.nextDFX = CurTime() + 0.02

			local oldpos = self.OldPos
			local newpos = self.Entity:LocalToWorld( self.Offset )
			self:SetPos( newpos )

			local Sub = (newpos - oldpos)
			local Dir = Sub:GetNormalized()
			local Len = Sub:Length()

			self.OldPos = newpos

			for i = 0, Len, 45 do
				local pos = oldpos + Dir * i

				self:doFX( pos )
			end
		end

		return true
	end

	if IsValid( self.Emitter ) then
		self.Emitter:Finish()
	end

	return false
end

function EFFECT:Render()
	local ent = self.Entity
	local pos = ent:LocalToWorld( self.Offset )

	render.SetMaterial( GlowMat )

	render.DrawSprite( pos, 100, 100, Color( 0, 127, 255, 50 ) )
end

--addons/lvs_base/lua/effects/lvs_tracer_white.lua:

EFFECT.MatBeam = Material( "effects/lvs_base/spark" )

function EFFECT:Init( data )
	local pos  = data:GetOrigin()
	local dir = data:GetNormal()

	self.ID = data:GetMaterialIndex()

	self:SetRenderBoundsWS( pos, pos + dir * 50000 )
end

function EFFECT:Think()
	if not LVS:GetBullet( self.ID ) then return false end

	return true
end

function EFFECT:Render()
	local bullet = LVS:GetBullet( self.ID )

	local endpos = bullet:GetPos()
	local dir = bullet:GetDir()

	local len = 1600 * bullet:GetLength()

	render.SetMaterial( self.MatBeam )
	render.DrawBeam( endpos - dir * len, endpos + dir * len, 3, 1, 0, Color( 255, 255, 255, 255 ) )
	render.DrawBeam( endpos - dir * len, endpos + dir * len, 10, 1, 0, Color( 150, 150, 150, 255 ) )
end

--addons/egm_tfa_weapons/lua/effects/rw_rocket_explosion.lua:
if SERVER then AddCSLuaFile() end

function EFFECT:Init(data)
	self.Start = data:GetOrigin()
	self.size = data:GetScale()
	self.Emitter = ParticleEmitter(self.Start)

	for i = 1, 55 do
		local p = self.Emitter:Add("particle/smokesprites_000" .. math.random(1, 9), self.Start)
		p:SetDieTime(math.Rand(4 / 3, 4))
		p:SetStartAlpha(95)
		p:SetEndAlpha(0)
		p:SetStartSize(math.random(100, 140) * self.size)
		p:SetEndSize(55 * self.size)
		p:SetRoll(math.Rand(-1, 1))
		p:SetRollDelta(math.Rand(-1, 1))
		p:SetCollide(true)
		p:SetVelocity(VectorRand():GetNormal() * 220)
		p:SetColor(115, 115, 115)
	end

	for i = 1, math.random(20, 50) do
		local p = self.Emitter:Add("effects/muzzleflash" .. math.random(1,4), self.Start)
		p:SetDieTime(math.Rand(0.1, 0.25))
		p:SetStartAlpha(255)
		p:SetEndAlpha(0)
		p:SetStartSize(math.random(50, 150) * self.size)
		p:SetEndSize(50 * self.size)
		p:SetRoll(math.Rand(-50, 50))
		p:SetRollDelta(math.Rand(-10, 10))
		p:SetCollide(true)
		p:SetVelocity(VectorRand():GetNormal() * math.random(25, 75) * self.size)
		p:SetColor(255, 150, 0)
	end

	for i = 1, math.random(40, 70) do
		local vec = VectorRand():GetNormal()
		vec.z = 0
		local pos = (self.Start + vec * 5)
		local p = self.Emitter:Add("sprites/orangeflare1", self.Start + vec * 10)
		p:SetDieTime(math.Rand(2, 3))
		p:SetStartAlpha(255)
		p:SetEndAlpha(0)
		p:SetStartSize(15)
		p:SetEndSize(3)
		p:SetVelocity(((pos - self.Start):GetNormal() * math.random(200, 350)) + Vector(0, 0, math.random(50, 300)) * self.size)
		p:SetGravity( Vector( 0, 0, -1750 ) );
		p:SetColor(255, 255, 255)
		p:SetCollide(true)
	end

	self.Emitter:Finish()
end

function EFFECT:Think()
	return false
end
--lua/effects/rw_sw_dual_laser_grey.lua:
TRACER_FLAG_USEATTACHMENT 	= 0x0002
SOUND_FROM_WORLD			= 0
CHAN_STATIC 				= 6

EFFECT.Speed 				= 16384
EFFECT.Length 				= 95

local MaterialMain 			= Material("cs574/tracers/rw_sw_laser_m_grey")
local MaterialFront 		= Material("cs574/tracers/rw_sw_laser_f_grey")
local DynamicTracer 		= GetConVar("cl_dynamic_tracer")

function EFFECT:Init(data)
	self.Position = data:GetStart()
	self.WeaponEnt = data:GetEntity()
	self.WeaponEntOG = data:GetEntity()
	self.Attachment = data:GetAttachment()
	local owent
	if IsValid(self.WeaponEnt) then
		owent = self.WeaponEnt.Owner or self.WeaponEnt:GetOwner()
		if not IsValid(owent) then
			owent = self.WeaponEnt:GetParent()
		end
	end
	if IsValid(owent) and owent:IsPlayer() then
		if owent ~= LocalPlayer() or owent:ShouldDrawLocalPlayer() then
			self.WeaponEnt = owent:GetActiveWeapon()
			if not IsValid(self.WeaponEnt) then return end
		else
			self.WeaponEnt = owent:GetViewModel()
			local theirweapon = owent:GetActiveWeapon()
			if IsValid(theirweapon) and theirweapon.ViewModelFlip or theirweapon.ViewModelFlipped then
				self.Flipped = true
			end
			if not IsValid(self.WeaponEnt) then return end
		end
	end
	if IsValid(self.WeaponEntOG) and self.WeaponEntOG.MuzzleAttachment then
		self.Attachment = self.WeaponEnt:LookupAttachment(self.WeaponEntOG.MuzzleAttachment)
		if not self.Attachment or self.Attachment <= 0 then
			self.Attachment = 1
		end
		if self.WeaponEntOG.Akimbo then
			if game.SinglePlayer() then
				self.WeaponEntOG.AnimCycle = self.WeaponEntOG:GetNW2Int("AnimCycle") or 0
			end
			self.Attachment = 1 + self.WeaponEntOG.AnimCycle
		end
	end
	local angpos
	if IsValid(self.WeaponEnt) then
		angpos = self.WeaponEnt:GetAttachment(self.Attachment)
	end
	if not angpos or not angpos.Pos then
		angpos = {
			Pos = bvec,
			Ang = uAng
		}
	end
	if self.Flipped then
		local tmpang = (self.Dir or angpos.Ang:Forward()):Angle()
		local localang = self.WeaponEnt:WorldToLocalAngles(tmpang)
		localang.y = localang.y + 180
		localang = self.WeaponEnt:LocalToWorldAngles(localang)
		self.Dir = localang:Forward()
	end
	if IsValid(owent) and self.Position:Distance(owent:GetShootPos()) > 72 then
		self.WeaponEnt = nil
	end
	
	self.StartPos = self:GetTracerShootPos(self.WeaponEnt and angpos.Pos or self.Position, self.WeaponEnt, self.Attachment)
	self.EndPos = data:GetOrigin()
	self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)
	self.Normal = (self.EndPos - self.StartPos):GetNormalized()
	self.StartTime = 0
	local diff = self.EndPos - self.StartPos
	self.LifeTime = (diff:Length() - self.Length/2 ) / self.Speed
	self.data = data
	self.rot = nil
	weapon = data:GetEntity()
	if (IsValid(weapon) and (not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer())) then
		local dist, pos, time = util.DistanceToLine(self.StartPos, self.EndPos, EyePos())
	end
end

function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()
	if DynamicTracer:GetBool() then
		local spawn = util.CRC(tostring(self:GetPos()))
		local dlight = DynamicLight(self:EntIndex() + spawn)
		local endDistance = self.Speed * self.StartTime
		local endPos = self.StartPos + self.Normal * endDistance
		if (dlight) then
			dlight.pos = endPos
			dlight.r = 130
			dlight.g = 150
			dlight.b = 180
			dlight.brightness = 3
			dlight.Decay = 1500
			dlight.Size = 300
			dlight.nomodel = 1
			dlight.style = 6
			dlight.DieTime = CurTime() + 3
		end
	end
	return self.LifeTime > 0
end

function EFFECT:Render()
	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	startDistance = math.max(0, startDistance)
	endDistance = math.max(0, endDistance)
	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	render.SetMaterial(MaterialFront)
	render.DrawSprite(endPos, 9, 9, color_white)
	render.SetMaterial(MaterialMain)
	render.DrawBeam(startPos, endPos, 7, 0, 0, color_white)
end
--lua/effects/rw_sw_dual_laser_white.lua:
TRACER_FLAG_USEATTACHMENT 	= 0x0002
SOUND_FROM_WORLD			= 0
CHAN_STATIC 				= 6

EFFECT.Speed 				= 16384
EFFECT.Length 				= 95

local MaterialMain 			= Material("effects/sw_laser_white_main")
local MaterialFront 		= Material("effects/sw_laser_white_front")
local DynamicTracer 		= GetConVar("cl_dynamic_tracer")

function EFFECT:Init(data)
	self.Position = data:GetStart()
	self.WeaponEnt = data:GetEntity()
	self.WeaponEntOG = data:GetEntity()
	self.Attachment = data:GetAttachment()
	local owent
	if IsValid(self.WeaponEnt) then
		owent = self.WeaponEnt.Owner or self.WeaponEnt:GetOwner()
		if not IsValid(owent) then
			owent = self.WeaponEnt:GetParent()
		end
	end
	if IsValid(owent) and owent:IsPlayer() then
		if owent ~= LocalPlayer() or owent:ShouldDrawLocalPlayer() then
			self.WeaponEnt = owent:GetActiveWeapon()
			if not IsValid(self.WeaponEnt) then return end
		else
			self.WeaponEnt = owent:GetViewModel()
			local theirweapon = owent:GetActiveWeapon()
			if IsValid(theirweapon) and theirweapon.ViewModelFlip or theirweapon.ViewModelFlipped then
				self.Flipped = true
			end
			if not IsValid(self.WeaponEnt) then return end
		end
	end
	if IsValid(self.WeaponEntOG) and self.WeaponEntOG.MuzzleAttachment then
		self.Attachment = self.WeaponEnt:LookupAttachment(self.WeaponEntOG.MuzzleAttachment)
		if not self.Attachment or self.Attachment <= 0 then
			self.Attachment = 1
		end
		if self.WeaponEntOG.Akimbo then
			if game.SinglePlayer() then
				self.WeaponEntOG.AnimCycle = self.WeaponEntOG:GetNW2Int("AnimCycle") or 0
			end
			self.Attachment = 1 + self.WeaponEntOG.AnimCycle
		end
	end
	local angpos
	if IsValid(self.WeaponEnt) then
		angpos = self.WeaponEnt:GetAttachment(self.Attachment)
	end
	if not angpos or not angpos.Pos then
		angpos = {
			Pos = bvec,
			Ang = uAng
		}
	end
	if self.Flipped then
		local tmpang = (self.Dir or angpos.Ang:Forward()):Angle()
		local localang = self.WeaponEnt:WorldToLocalAngles(tmpang)
		localang.y = localang.y + 180
		localang = self.WeaponEnt:LocalToWorldAngles(localang)
		self.Dir = localang:Forward()
	end
	if IsValid(owent) and self.Position:Distance(owent:GetShootPos()) > 72 then
		self.WeaponEnt = nil
	end
	
	self.StartPos = self:GetTracerShootPos(self.WeaponEnt and angpos.Pos or self.Position, self.WeaponEnt, self.Attachment)
	self.EndPos = data:GetOrigin()
	self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)
	self.Normal = (self.EndPos - self.StartPos):GetNormalized()
	self.StartTime = 0
	local diff = self.EndPos - self.StartPos
	self.LifeTime = (diff:Length() - self.Length/2 ) / self.Speed
	self.data = data
	self.rot = nil
	weapon = data:GetEntity()
	if (IsValid(weapon) and (not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer())) then
		local dist, pos, time = util.DistanceToLine(self.StartPos, self.EndPos, EyePos())
	end
end

function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()
	if DynamicTracer:GetBool() then
		local spawn = util.CRC(tostring(self:GetPos()))
		local dlight = DynamicLight(self:EntIndex() + spawn)
		local endDistance = self.Speed * self.StartTime
		local endPos = self.StartPos + self.Normal * endDistance
		if (dlight) then
			dlight.pos = endPos
			dlight.r = 255
			dlight.g = 255
			dlight.b = 255
			dlight.brightness = 3
			dlight.Decay = 1500
			dlight.Size = 300
			dlight.nomodel = 1
			dlight.style = 6
			dlight.DieTime = CurTime() + 3
		end
	end
	return self.LifeTime > 0
end

function EFFECT:Render()
	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	startDistance = math.max(0, startDistance)
	endDistance = math.max(0, endDistance)
	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	render.SetMaterial(MaterialFront)
	render.DrawSprite(endPos, 9, 9, color_white)
	render.SetMaterial(MaterialMain)
	render.DrawBeam(startPos, endPos, 7, 0, 0, color_white)
end
--lua/effects/rw_sw_impact_blue.lua:
local MaterialGlow		= Material( "effects/sw_i/sw_laser_bit_blue" );
function EFFECT:Init( data )
	local bit_amount = GetConVar("rw_sw_bit_amount"):GetInt()
	local smoke_amount = GetConVar("rw_sw_smoke_amount"):GetInt()
	local duration = GetConVar("rw_sw_impact_duration"):GetInt()
	self.Position = data:GetOrigin();
	self.Normal = data:GetNormal();
	self.LifeTime = duration;
	local emitter = ParticleEmitter( self.Position );
	if( emitter ) then
		for i = 1, bit_amount do
			local particle = emitter:Add( MaterialGlow, self.Position + self.Normal * 2 );
			particle:SetVelocity( ( self.Normal + VectorRand() * 0.75 ):GetNormal() * math.Rand( 75, 125 ) );
			particle:SetDieTime( math.Rand( 0.5, 1.25 ) );
			particle:SetStartAlpha( 255 );
			particle:SetEndAlpha( 0 );
			particle:SetStartSize( math.Rand( 4, 8 ) );
			particle:SetEndSize( 0 );
			particle:SetRoll( 0 );
			particle:SetGravity( Vector( 0, 0, -250 ) );
			particle:SetCollide( true );
			particle:SetBounce( 0.3 );
			particle:SetAirResistance( 5 );
		end
		emitter:Finish();
	end
	local emitter_s = ParticleEmitter( self.Position );
	if( emitter_s ) then
		for i = 1, smoke_amount do
			local smokeTexture	= "effects/smoke"
			local particle_s = emitter_s:Add(smokeTexture, self.Position+self.Normal*2);
			particle_s:SetVelocity((self.Normal+VectorRand()*0.10):GetNormal()*math.Rand(400, 900));
			particle_s:SetDieTime(math.Rand(2.1, 2.7));
			particle_s:SetStartAlpha(50);
			particle_s:SetEndAlpha(0);
			particle_s:SetStartSize(math.Rand(8, 16));
			particle_s:SetEndSize(math.Rand(0, 4));
			particle_s:SetGravity(Vector(math.Rand(0, 500), math.Rand(250, 1000), math.Rand(-250, 250)));
			particle_s:SetRoll(math.Rand(0, 360));
			particle_s:SetRollDelta(math.Rand(-0.5, 0.5));
			local colour = math.Rand(110, 130);
			particle_s:SetColor(colour, colour, colour, 100);
			particle_s:SetCollide(true);
			particle_s:SetAirResistance(2000);
		end
		emitter_s:Finish();
	end
end
function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime();
	return self.LifeTime > 0;
end
function EFFECT:Render()
	local size = GetConVar("rw_sw_impact_size"):GetInt()
	local duration = GetConVar("rw_sw_impact_duration"):GetInt()
	local frac = math.max( 0, self.LifeTime / duration);
	local rgb = 255 * frac;
	local color = Color( rgb, rgb, rgb, 255 );
	render.SetMaterial( MaterialGlow );
	render.DrawQuadEasy( self.Position + self.Normal, self.Normal, size, size, color );
end
--lua/effects/rw_sw_impact_green.lua:
local MaterialGlow		= Material( "effects/sw_i/sw_laser_bit_green" );
function EFFECT:Init( data )
	local bit_amount = GetConVar("rw_sw_bit_amount"):GetInt()
	local smoke_amount = GetConVar("rw_sw_smoke_amount"):GetInt()
	local duration = GetConVar("rw_sw_impact_duration"):GetInt()
	self.Position = data:GetOrigin();
	self.Normal = data:GetNormal();
	self.LifeTime = duration;
	local emitter = ParticleEmitter( self.Position );
	if( emitter ) then
		for i = 1, bit_amount do
			local particle = emitter:Add( MaterialGlow, self.Position + self.Normal * 2 );
			particle:SetVelocity( ( self.Normal + VectorRand() * 0.75 ):GetNormal() * math.Rand( 75, 125 ) );
			particle:SetDieTime( math.Rand( 0.5, 1.25 ) );
			particle:SetStartAlpha( 255 );
			particle:SetEndAlpha( 0 );
			particle:SetStartSize( math.Rand( 4, 8 ) );
			particle:SetEndSize( 0 );
			particle:SetRoll( 0 );
			particle:SetGravity( Vector( 0, 0, -250 ) );
			particle:SetCollide( true );
			particle:SetBounce( 0.3 );
			particle:SetAirResistance( 5 );
		end
		emitter:Finish();
	end
	local emitter_s = ParticleEmitter( self.Position );
	if( emitter_s ) then
		for i = 1, smoke_amount do
			local smokeTexture	= "effects/smoke"
			local particle_s = emitter_s:Add(smokeTexture, self.Position+self.Normal*2);
			particle_s:SetVelocity((self.Normal+VectorRand()*0.10):GetNormal()*math.Rand(400, 900));
			particle_s:SetDieTime(math.Rand(2.1, 2.7));
			particle_s:SetStartAlpha(50);
			particle_s:SetEndAlpha(0);
			particle_s:SetStartSize(math.Rand(8, 16));
			particle_s:SetEndSize(math.Rand(0, 4));
			particle_s:SetGravity(Vector(math.Rand(0, 500), math.Rand(250, 1000), math.Rand(-250, 250)));
			particle_s:SetRoll(math.Rand(0, 360));
			particle_s:SetRollDelta(math.Rand(-0.5, 0.5));
			local colour = math.Rand(110, 130);
			particle_s:SetColor(colour, colour, colour, 100);
			particle_s:SetCollide(true);
			particle_s:SetAirResistance(2000);
		end
		emitter_s:Finish();
	end
end
function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime();
	return self.LifeTime > 0;
end
function EFFECT:Render()
	local size = GetConVar("rw_sw_impact_size"):GetInt()
	local duration = GetConVar("rw_sw_impact_duration"):GetInt()
	local frac = math.max( 0, self.LifeTime / duration);
	local rgb = 255 * frac;
	local color = Color( rgb, rgb, rgb, 255 );
	render.SetMaterial( MaterialGlow );
	render.DrawQuadEasy( self.Position + self.Normal, self.Normal, size, size, color );
end
--lua/effects/rw_sw_laser_grey.lua:

TRACER_FLAG_USEATTACHMENT 	= 0x0002
SOUND_FROM_WORLD 			= 0
CHAN_STATIC 				= 6

EFFECT.Speed 				= 16384
EFFECT.Length 				= 95

local MaterialMain 			= Material("cs574/tracers/rw_sw_laser_m_grey")
local MaterialFront 		= Material("cs574/tracers/rw_sw_laser_f_grey")
local DynamicTracer 		= GetConVar("cl_dynamic_tracer")

function EFFECT:GetTracerOrigin(data)
	local start = data:GetStart()
	if (bit.band(data:GetFlags(), TRACER_FLAG_USEATTACHMENT) == TRACER_FLAG_USEATTACHMENT) then
		local entity = data:GetEntity()
		if (not IsValid(entity)) then return start end
		if (not game.SinglePlayer() and entity:IsEFlagSet(EFL_DORMANT)) then return start end
		if (entity:IsWeapon() and entity:IsCarriedByLocalPlayer()) then
			local pl = entity:GetOwner()
			if (IsValid(pl)) then
				local vm = pl:GetViewModel()
				if (IsValid(vm) and not LocalPlayer():ShouldDrawLocalPlayer()) then
					entity = vm
				else
					if (entity.WorldModel) then
						entity:SetModel(entity.WorldModel)
					end
				end
			end
		end
		local attachment = entity:GetAttachment(data:GetAttachment())
		if (attachment) then
			start = attachment.Pos
		end
	end
	return start
end

function EFFECT:Init(data)
	self.StartPos = self:GetTracerOrigin(data)
	self.EndPos = data:GetOrigin()
	self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)
	local diff = self.EndPos - self.StartPos
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	self.LifeTime = (diff:Length() - self.Length/2 ) / self.Speed 	--self.LifeTime = (diff:Length() - (self.Length/2) ) / self.Speed
	local weapon = data:GetEntity()
	if (IsValid(weapon) and (not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer())) then
		local dist, pos, time = util.DistanceToLine(self.StartPos, self.EndPos, EyePos())
	end
end

function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()
	if DynamicTracer:GetBool() then
		local spawn = util.CRC(tostring(self:GetPos()))
		local dlight = DynamicLight(self:EntIndex() + spawn)
		local endDistance = self.Speed * self.StartTime
		local endPos = self.StartPos + self.Normal * endDistance
		if (dlight) then
			dlight.pos = endPos
			dlight.r = 130
			dlight.g = 150
			dlight.b = 180
			dlight.brightness = 2
			dlight.Decay = 1500
			dlight.Size = 300
			dlight.nomodel = 1
			dlight.style = 6
			dlight.DieTime = CurTime() + 3
		end
	end
	return self.LifeTime > 0
end

function EFFECT:Render()
	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	startDistance = math.max(0, startDistance)
	endDistance = math.max(0, endDistance)
	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	render.SetMaterial(MaterialFront)
	render.DrawSprite(endPos, 9, 9, color_white)
	render.SetMaterial(MaterialMain)
	render.DrawBeam(startPos, endPos, 7, 0, 0, color_white)
end
--lua/effects/rw_sw_laser_red.lua:

TRACER_FLAG_USEATTACHMENT	= 0x0002
SOUND_FROM_WORLD			= 0
CHAN_STATIC					= 6

EFFECT.Speed				= 16384
EFFECT.Length				= 95

local MaterialMain			= Material( "effects/sw_laser_red_main" )
local MaterialFront			= Material( "effects/sw_laser_red_front" )
local DynamicTracer 		= GetConVar("cl_dynamic_tracer")

function EFFECT:GetTracerOrigin(data)
	local start = data:GetStart()
	if (bit.band(data:GetFlags(), TRACER_FLAG_USEATTACHMENT) == TRACER_FLAG_USEATTACHMENT) then
		local entity = data:GetEntity()
		if (not IsValid(entity)) then return start end
		if (not game.SinglePlayer() and entity:IsEFlagSet(EFL_DORMANT)) then return start end
		if (entity:IsWeapon() and entity:IsCarriedByLocalPlayer()) then
			local pl = entity:GetOwner()
			if (IsValid(pl)) then
				local vm = pl:GetViewModel()
				if (IsValid(vm) and not LocalPlayer():ShouldDrawLocalPlayer()) then
					entity = vm
				else
					if (entity.WorldModel) then
						entity:SetModel(entity.WorldModel)
					end
				end
			end
		end
		local attachment = entity:GetAttachment(data:GetAttachment())
		if (attachment) then
			start = attachment.Pos
		end
	end
	return start
end

function EFFECT:Init(data)
	self.StartPos = self:GetTracerOrigin(data)
	self.EndPos = data:GetOrigin()
	self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)
	local diff = self.EndPos - self.StartPos
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	self.LifeTime = (diff:Length() - self.Length/2 ) / self.Speed 	--self.LifeTime = (diff:Length() - (self.Length/2) ) / self.Speed
	local weapon = data:GetEntity()
	if (IsValid(weapon) and (not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer())) then
		local dist, pos, time = util.DistanceToLine(self.StartPos, self.EndPos, EyePos())
	end
end

function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()
	if DynamicTracer:GetBool() then
		local spawn = util.CRC(tostring(self:GetPos()))
		local dlight = DynamicLight(self:EntIndex() + spawn)
		local endDistance = self.Speed * self.StartTime
		local endPos = self.StartPos + self.Normal * endDistance
		if (dlight) then
			dlight.pos = endPos
			dlight.r = 255
			dlight.g = 0
			dlight.b = 0
			dlight.brightness = 2
			dlight.Decay = 1500
			dlight.Size = 300
			dlight.nomodel = 1
			dlight.style = 6
			dlight.DieTime = CurTime() + 3
		end
	end
	return self.LifeTime > 0
end

function EFFECT:Render()
	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	startDistance = math.max(0, startDistance)
	endDistance = math.max(0, endDistance)
	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	render.SetMaterial(MaterialFront)
	render.DrawSprite(endPos, 9, 9, color_white)
	render.SetMaterial(MaterialMain)
	render.DrawBeam(startPos, endPos, 7, 0, 0, color_white)
end
--lua/effects/rw_sw_laser_redpink.lua:

TRACER_FLAG_USEATTACHMENT	= 0x0002
SOUND_FROM_WORLD			= 0
CHAN_STATIC					= 6

EFFECT.Speed				= 16384
EFFECT.Length				= 175

local MaterialMain			= Material( "effect/sw_l/rw_sw_laser_m_redpink" )
local MaterialFront			= Material( "effect/sw_l/rw_sw_laser_f_redpink" )
local DynamicTracer 		= GetConVar("cl_dynamic_tracer")

function EFFECT:GetTracerOrigin(data)
	-- this is almost a direct port of GetTracerOrigin in fx_tracer.cpp
	local start = data:GetStart()

	-- use attachment?
	if (bit.band(data:GetFlags(), TRACER_FLAG_USEATTACHMENT) == TRACER_FLAG_USEATTACHMENT) then
		local entity = data:GetEntity()
		if (not IsValid(entity)) then return start end
		if (not game.SinglePlayer() and entity:IsEFlagSet(EFL_DORMANT)) then return start end

		if (entity:IsWeapon() and entity:IsCarriedByLocalPlayer()) then
			-- can't be done, can't call the real function
			-- local origin = weapon:GetTracerOrigin();
			-- if( origin ) then
			-- 	return origin, angle, entity;
			-- end
			-- use the view model
			local pl = entity:GetOwner()

			if (IsValid(pl)) then
				local vm = pl:GetViewModel()

				if (IsValid(vm) and not LocalPlayer():ShouldDrawLocalPlayer()) then
					entity = vm
					-- HACK: fix the model in multiplayer
				else
					if (entity.WorldModel) then
						entity:SetModel(entity.WorldModel)
					end
				end
			end
		end

		local attachment = entity:GetAttachment(data:GetAttachment())

		if (attachment) then
			start = attachment.Pos
		end
	end

	return start
end

function EFFECT:Init(data)
	self.StartPos = self:GetTracerOrigin(data)
	self.EndPos = data:GetOrigin()
	self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)
	local diff = self.EndPos - self.StartPos
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	self.LifeTime = (diff:Length() + self.Length) / self.Speed
	-- whiz by sound
	local weapon = data:GetEntity()

	if (IsValid(weapon) and (not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer())) then
		local dist, pos, time = util.DistanceToLine(self.StartPos, self.EndPos, EyePos())
	end
end


function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()

	if DynamicTracer:GetBool() then
		local spawn = util.CRC(tostring(self:GetPos()))
		local dlight = DynamicLight(self:EntIndex() + spawn)
		local endDistance = self.Speed * self.StartTime
		local endPos = self.StartPos + self.Normal * endDistance

		if (dlight) then
			dlight.pos = endPos
			dlight.r = 255
			dlight.g = 0
			dlight.b = 50
			dlight.brightness = 5
			dlight.Decay = 1000
			dlight.Size = 200
			dlight.nomodel = 1
			dlight.style = 6
			dlight.DieTime = CurTime() + 3
		end
	end

	return self.LifeTime > 0
end

function EFFECT:Render()
	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	startDistance = math.max(0, startDistance)
	endDistance = math.max(0, endDistance)
	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	render.SetMaterial(MaterialFront)
	render.DrawSprite(endPos, 8, 8, color_white)
	render.SetMaterial(MaterialMain)
	render.DrawBeam(startPos, endPos, 10, 0, 1, color_white)
end
--lua/effects/rw_sw_laser_yellow.lua:

TRACER_FLAG_USEATTACHMENT	= 0x0002
SOUND_FROM_WORLD			= 0
CHAN_STATIC					= 6

EFFECT.Speed				= 16384
EFFECT.Length				= 95

local MaterialMain			= Material( "effects/sw_laser_yellow_main" )
local MaterialFront			= Material( "effects/sw_laser_yellow_front" )
local DynamicTracer 		= GetConVar("cl_dynamic_tracer")

function EFFECT:GetTracerOrigin(data)
	local start = data:GetStart()
	if (bit.band(data:GetFlags(), TRACER_FLAG_USEATTACHMENT) == TRACER_FLAG_USEATTACHMENT) then
		local entity = data:GetEntity()
		if (not IsValid(entity)) then return start end
		if (not game.SinglePlayer() and entity:IsEFlagSet(EFL_DORMANT)) then return start end
		if (entity:IsWeapon() and entity:IsCarriedByLocalPlayer()) then
			local pl = entity:GetOwner()
			if (IsValid(pl)) then
				local vm = pl:GetViewModel()
				if (IsValid(vm) and not LocalPlayer():ShouldDrawLocalPlayer()) then
					entity = vm
				else
					if (entity.WorldModel) then
						entity:SetModel(entity.WorldModel)
					end
				end
			end
		end
		local attachment = entity:GetAttachment(data:GetAttachment())
		if (attachment) then
			start = attachment.Pos
		end
	end
	return start
end

function EFFECT:Init(data)
	self.StartPos = self:GetTracerOrigin(data)
	self.EndPos = data:GetOrigin()
	self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)
	local diff = self.EndPos - self.StartPos
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	self.LifeTime = (diff:Length() - self.Length/2 ) / self.Speed 	--self.LifeTime = (diff:Length() - (self.Length/2) ) / self.Speed
	local weapon = data:GetEntity()
	if (IsValid(weapon) and (not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer())) then
		local dist, pos, time = util.DistanceToLine(self.StartPos, self.EndPos, EyePos())
	end
end

function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()
	if DynamicTracer:GetBool() then
		local spawn = util.CRC(tostring(self:GetPos()))
		local dlight = DynamicLight(self:EntIndex() + spawn)
		local endDistance = self.Speed * self.StartTime
		local endPos = self.StartPos + self.Normal * endDistance
		if (dlight) then
			dlight.pos = endPos
			dlight.r = 255
			dlight.g = 255
			dlight.b = 0
			dlight.brightness = 2
			dlight.Decay = 1500
			dlight.Size = 300
			dlight.nomodel = 1
			dlight.style = 6
			dlight.DieTime = CurTime() + 3
		end
	end
	return self.LifeTime > 0
end

function EFFECT:Render()
	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	startDistance = math.max(0, startDistance)
	endDistance = math.max(0, endDistance)
	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	render.SetMaterial(MaterialFront)
	render.DrawSprite(endPos, 9, 9, color_white)
	render.SetMaterial(MaterialMain)
	render.DrawBeam(startPos, endPos, 7, 0, 0, color_white)
end
--lua/effects/rw_sw_muzzleflash_aqua.lua:
EFFECT.Life = 0.12
EFFECT.XFlashSize = 0.55
EFFECT.FlashSize = 0.5
EFFECT.SmokeSize = 0
EFFECT.SparkSize = 1.25
EFFECT.HeatSize = 2.5
EFFECT.Color = Color(0,255,160)
EFFECT.ColorSprites = true

local AddVel = Vector()
local ang

function EFFECT:Init(data)
	self.WeaponEnt = data:GetEntity()
	if not IsValid(self.WeaponEnt) then return end
	self.Attachment = data:GetAttachment()
	self.Position = self:GetTracerShootPos(data:GetOrigin(), self.WeaponEnt, self.Attachment)

	if IsValid(self.WeaponEnt:GetOwner()) then
		if self.WeaponEnt:GetOwner() == LocalPlayer() then
			if self.WeaponEnt:GetOwner():ShouldDrawLocalPlayer() then
				ang = self.WeaponEnt:GetOwner():EyeAngles()
				ang:Normalize()
				--ang.p = math.max(math.min(ang.p,55),-55)
				self.Forward = ang:Forward()
			else
				self.WeaponEnt = self.WeaponEnt:GetOwner():GetViewModel()
			end
			--ang.p = math.max(math.min(ang.p,55),-55)
		else
			ang = self.WeaponEnt:GetOwner():EyeAngles()
			ang:Normalize()
			self.Forward = ang:Forward()
		end
	end

	self.Forward = self.Forward or data:GetNormal()
	self.Angle = self.Forward:Angle()
	self.Right = self.Angle:Right()
	self.vOffset = self.Position
	local dir = self.Forward
	local ownerent = self.WeaponEnt:GetOwner()

	if not IsValid(ownerent) then
		ownerent = LocalPlayer()
	end

	AddVel = ownerent:GetVelocity()
	self.vOffset = self.Position
	AddVel = AddVel * 0.05
	local dot = dir:GetNormalized():Dot(GetViewEntity():EyeAngles():Forward())
	local halofac = math.abs(dot)
	local epos = ownerent:GetShootPos()
	local dlight = DynamicLight(ownerent:EntIndex())

	if (dlight) then
		dlight.pos = epos + ownerent:EyeAngles():Forward() * self.vOffset:Distance(epos) --self.vOffset - ownerent:EyeAngles():Right() * 5 + 1.05 * ownerent:GetVelocity() * FrameTime()
		dlight.r = self.Color.r
		dlight.g = self.Color.g
		dlight.b = self.Color.b
		dlight.brightness = 4.5
		dlight.decay = 200 / self.Life
		dlight.size = self.FlashSize * 150
		dlight.dietime = CurTime() + self.Life
	end

	self.Dist = self.vOffset:Distance(epos)
	self.DLight = dlight
	self.DieTime = CurTime() + self.Life
	self.OwnerEnt = ownerent
	local emitter = ParticleEmitter(self.vOffset)
	local sval = 1 - math.random(0, 1) * 2

	if self.WeaponEnt.XTick == nil then
		self.WeaponEnt.XTick = 0
	end

	self.WeaponEnt.XTick = 1 - self.WeaponEnt.XTick

	if self.WeaponEnt.XTick == 1 and self.XFlashSize > 0 then
		local particle = emitter:Add(self.ColorSprites and "effects/muzzleflashx_nemole_w" or "effects/muzzleflashx_nemole", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 4 * self.XFlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life / 2)
			particle:SetStartAlpha(math.Rand(200, 255))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 8 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(3 * (halofac * 0.8 + 0.2) * self.XFlashSize)
			particle:SetEndSize(15 * (halofac * 0.8 + 0.2) * self.XFlashSize)
			local r = math.Rand(-10, 10) * 3.14 / 180
			particle:SetRoll(r)
			particle:SetRollDelta(r / 5)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
			particle:SetPos(vector_origin)
		end
		--particle:SetStartSize( 8 * (halofac*0.8+0.2), 0, 1)
		--particle:SetEndSize( 0 )
	elseif self.XFlashSize > 0 then
		local particle = emitter:Add(self.ColorSprites and "effects/muzzleflashx_nemole_w" or "effects/muzzleflashx_nemole", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 4 * self.FlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life / 2)
			particle:SetStartAlpha(math.Rand(200, 255))
			particle:SetEndAlpha(0)
			particle:SetStartSize(2 * (halofac * 0.8 + 0.2) * 0.3 * self.FlashSize)
			particle:SetEndSize(6 * (halofac * 0.8 + 0.2) * 0.3 * self.FlashSize)
			local r = math.Rand(-10, 10) * 3.14 / 180
			particle:SetRoll(r)
			particle:SetRollDelta(r / 5)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
			particle:SetPos(vector_origin)
		end
	end

	local flashCount = math.Round(self.FlashSize * 8)

	for i = 1, flashCount do
		local particle = emitter:Add(self.ColorSprites and "effects/scotchmuzzleflashw" or "effects/scotchmuzzleflash4", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 300 * (0.2 + (i / flashCount) * 0.8) * self.FlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 0.75)
			particle:SetStartAlpha(math.Rand(128, 255))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			local szsc = 1 + (flashCount - i) * math.pow(1 / flashCount * 0.9,0.8)
			particle:SetStartSize(1.25 * math.Rand(1, 1.5) * szsc * self.FlashSize)
			particle:SetEndSize(6 * math.Rand(0.75, 1) * szsc * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(15, 30)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	for _ = 1, flashCount do
		local particle = emitter:Add("effects/scotchmuzzleflash1", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 6 * self.FlashSize + 1.05 * AddVel)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 1)
			particle:SetStartAlpha(math.Rand(40, 140))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(2 * math.Rand(1, 1.5) * self.FlashSize)
			particle:SetEndSize(20 * math.Rand(0.5, 1) * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(30, 60)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			--TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	local glowCount = math.ceil(self.FlashSize * 3)

	for i = 1, glowCount do
		local particle = emitter:Add("effects/scotchmuzzleflash1", self.vOffset + dir * 0.9 * i)

		if (particle) then
			--particle:SetVelocity(dir * 32 )
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 0.75)
			particle:SetStartAlpha(255 * (1 - halofac))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(math.max(12 - 12 / glowCount * i * 0.5, 1) * 0.2 * self.FlashSize)
			particle:SetEndSize(math.max(12 - 12 / glowCount * i * 0.5, 1) * 0.6 * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(15, 30)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	local smokeCount = math.ceil(self.SmokeSize * 6)

	for _ = 0, smokeCount do
		local particle = emitter:Add("particles/smokey", self.vOffset + dir * math.Rand(3, 14))

		if (particle) then
			particle:SetVelocity(VectorRand() * 10 * self.SmokeSize + dir * math.Rand(35, 50) * self.SmokeSize + 1.05 * AddVel)
			particle:SetDieTime(math.Rand(0.6, 1) * self.Life * 6)
			particle:SetStartAlpha(math.Rand(12, 24))
			particle:SetEndAlpha(0)
			particle:SetStartSize(math.Rand(5, 7) * self.SmokeSize)
			particle:SetEndSize(math.Rand(15, 20) * self.SmokeSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.Rand(-0.8, 0.8))
			particle:SetLighting(true)
			particle:SetAirResistance(20)
			particle:SetGravity(Vector(0, 0, 60))
			particle:SetColor(255, 255, 255)
		end
	end

	local sparkcount = math.Round(math.random(8, 12) * self.SparkSize)

	for _ = 0, sparkcount do
		local particle = emitter:Add("effects/yellowflare", self.Position)

		if (particle) then
			particle:SetVelocity( VectorRand() * 30 * self.SparkSize)
			particle:SetVelocity(particle:GetVelocity() + 1.15 * AddVel )
			particle:SetVelocity( particle:GetVelocity() + dir * math.Rand(80, 100) * (1-math.abs(math.max(particle:GetVelocity():GetNormalized():Dot(-dir),0))) * self.SparkSize )
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * math.Rand(0.9,1.1))
			particle:SetStartAlpha(255)
			particle:SetEndAlpha(0)
			particle:SetStartSize(0.6)
			particle:SetEndSize(1)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetGravity(vector_origin)
			particle:SetAirResistance(1)
			particle:SetStartLength(0.1)
			particle:SetEndLength(0.05)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, math.random(192, 225), math.random(140, 192))
			end

			particle:SetVelocityScale(true)
			local sl = self.SparkSize

			particle:SetThinkFunction(function(pa)
				math.randomseed(SysTime())
				local spd = pa:GetVelocity():Length()*12
				pa.ranvel = pa.ranvel or VectorRand() * spd
				pa.ranvel:Add(VectorRand() * spd * math.sqrt(FrameTime()))
				pa:SetVelocity(pa:GetVelocity() + pa.ranvel * sl * FrameTime() )
				pa:SetNextThink(CurTime())
			end)

			particle:SetNextThink(CurTime() + 0.01)
		end
	end

	if TFA.GetGasEnabled() then
		local particle = emitter:Add("sprites/heatwave", self.vOffset + dir*2)

		if (particle) then
			particle:SetVelocity(dir * 25 * self.HeatSize + 1.05 * AddVel)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life)
			particle:SetStartAlpha(math.Rand(200, 225))
			particle:SetEndAlpha(0)
			particle:SetStartSize(math.Rand(3, 5) * self.HeatSize)
			particle:SetEndSize(math.Rand(8, 12) * self.HeatSize)
			particle:SetRoll(math.Rand(0, 360))
			particle:SetRollDelta(math.Rand(-2, 2))
			particle:SetAirResistance(5)
			particle:SetGravity(Vector(0, 0, 40))
			particle:SetColor(255, 255, 255)
		end
	end

	emitter:Finish()
end

function EFFECT:Think()
	if CurTime() > self.DieTime then
		return false
	elseif self.DLight and IsValid(self.OwnerEnt) then
			self.DLight.pos = self.OwnerEnt:GetShootPos() + self.OwnerEnt:EyeAngles():Forward() * self.Dist
	end

	return true
end

function EFFECT:Render()
end
--lua/effects/rw_sw_muzzleflash_black.lua:
EFFECT.Life = 0.12
EFFECT.XFlashSize = 0.55
EFFECT.FlashSize = 0.5
EFFECT.SmokeSize = 0
EFFECT.SparkSize = 1.25
EFFECT.HeatSize = 2.5
EFFECT.Color = Color(0,0,0)
EFFECT.ColorSprites = true

local AddVel = Vector()
local ang

function EFFECT:Init(data)
	self.WeaponEnt = data:GetEntity()
	if not IsValid(self.WeaponEnt) then return end
	self.Attachment = data:GetAttachment()
	self.Position = self:GetTracerShootPos(data:GetOrigin(), self.WeaponEnt, self.Attachment)

	if IsValid(self.WeaponEnt:GetOwner()) then
		if self.WeaponEnt:GetOwner() == LocalPlayer() then
			if self.WeaponEnt:GetOwner():ShouldDrawLocalPlayer() then
				ang = self.WeaponEnt:GetOwner():EyeAngles()
				ang:Normalize()
				--ang.p = math.max(math.min(ang.p,55),-55)
				self.Forward = ang:Forward()
			else
				self.WeaponEnt = self.WeaponEnt:GetOwner():GetViewModel()
			end
			--ang.p = math.max(math.min(ang.p,55),-55)
		else
			ang = self.WeaponEnt:GetOwner():EyeAngles()
			ang:Normalize()
			self.Forward = ang:Forward()
		end
	end

	self.Forward = self.Forward or data:GetNormal()
	self.Angle = self.Forward:Angle()
	self.Right = self.Angle:Right()
	self.vOffset = self.Position
	local dir = self.Forward
	local ownerent = self.WeaponEnt:GetOwner()

	if not IsValid(ownerent) then
		ownerent = LocalPlayer()
	end

	AddVel = ownerent:GetVelocity()
	self.vOffset = self.Position
	AddVel = AddVel * 0.05
	local dot = dir:GetNormalized():Dot(GetViewEntity():EyeAngles():Forward())
	local halofac = math.abs(dot)
	local epos = ownerent:GetShootPos()
	local dlight = DynamicLight(ownerent:EntIndex())

	if (dlight) then
		dlight.pos = epos + ownerent:EyeAngles():Forward() * self.vOffset:Distance(epos) --self.vOffset - ownerent:EyeAngles():Right() * 5 + 1.05 * ownerent:GetVelocity() * FrameTime()
		dlight.r = self.Color.r
		dlight.g = self.Color.g
		dlight.b = self.Color.b
		dlight.brightness = 4.5
		dlight.decay = 200 / self.Life
		dlight.size = self.FlashSize * 150
		dlight.dietime = CurTime() + self.Life
	end

	self.Dist = self.vOffset:Distance(epos)
	self.DLight = dlight
	self.DieTime = CurTime() + self.Life
	self.OwnerEnt = ownerent
	local emitter = ParticleEmitter(self.vOffset)
	local sval = 1 - math.random(0, 1) * 2

	if self.WeaponEnt.XTick == nil then
		self.WeaponEnt.XTick = 0
	end

	self.WeaponEnt.XTick = 1 - self.WeaponEnt.XTick

	if self.WeaponEnt.XTick == 1 and self.XFlashSize > 0 then
		local particle = emitter:Add(self.ColorSprites and "effects/muzzleflashx_nemole_w" or "effects/muzzleflashx_nemole", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 4 * self.XFlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life / 2)
			particle:SetStartAlpha(math.Rand(200, 255))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 8 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(3 * (halofac * 0.8 + 0.2) * self.XFlashSize)
			particle:SetEndSize(15 * (halofac * 0.8 + 0.2) * self.XFlashSize)
			local r = math.Rand(-10, 10) * 3.14 / 180
			particle:SetRoll(r)
			particle:SetRollDelta(r / 5)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
			particle:SetPos(vector_origin)
		end
		--particle:SetStartSize( 8 * (halofac*0.8+0.2), 0, 1)
		--particle:SetEndSize( 0 )
	elseif self.XFlashSize > 0 then
		local particle = emitter:Add(self.ColorSprites and "effects/muzzleflashx_nemole_w" or "effects/muzzleflashx_nemole", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 4 * self.FlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life / 2)
			particle:SetStartAlpha(math.Rand(200, 255))
			particle:SetEndAlpha(0)
			particle:SetStartSize(2 * (halofac * 0.8 + 0.2) * 0.3 * self.FlashSize)
			particle:SetEndSize(6 * (halofac * 0.8 + 0.2) * 0.3 * self.FlashSize)
			local r = math.Rand(-10, 10) * 3.14 / 180
			particle:SetRoll(r)
			particle:SetRollDelta(r / 5)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
			particle:SetPos(vector_origin)
		end
	end

	local flashCount = math.Round(self.FlashSize * 8)

	for i = 1, flashCount do
		local particle = emitter:Add(self.ColorSprites and "effects/scotchmuzzleflashw" or "effects/scotchmuzzleflash4", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 300 * (0.2 + (i / flashCount) * 0.8) * self.FlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 0.75)
			particle:SetStartAlpha(math.Rand(128, 255))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			local szsc = 1 + (flashCount - i) * math.pow(1 / flashCount * 0.9,0.8)
			particle:SetStartSize(1.25 * math.Rand(1, 1.5) * szsc * self.FlashSize)
			particle:SetEndSize(6 * math.Rand(0.75, 1) * szsc * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(15, 30)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	for _ = 1, flashCount do
		local particle = emitter:Add("effects/scotchmuzzleflash1", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 6 * self.FlashSize + 1.05 * AddVel)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 1)
			particle:SetStartAlpha(math.Rand(40, 140))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(2 * math.Rand(1, 1.5) * self.FlashSize)
			particle:SetEndSize(20 * math.Rand(0.5, 1) * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(30, 60)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			--TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	local glowCount = math.ceil(self.FlashSize * 3)

	for i = 1, glowCount do
		local particle = emitter:Add("effects/scotchmuzzleflash1", self.vOffset + dir * 0.9 * i)

		if (particle) then
			--particle:SetVelocity(dir * 32 )
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 0.75)
			particle:SetStartAlpha(255 * (1 - halofac))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(math.max(12 - 12 / glowCount * i * 0.5, 1) * 0.2 * self.FlashSize)
			particle:SetEndSize(math.max(12 - 12 / glowCount * i * 0.5, 1) * 0.6 * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(15, 30)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	local smokeCount = math.ceil(self.SmokeSize * 6)

	for _ = 0, smokeCount do
		local particle = emitter:Add("particles/smokey", self.vOffset + dir * math.Rand(3, 14))

		if (particle) then
			particle:SetVelocity(VectorRand() * 10 * self.SmokeSize + dir * math.Rand(35, 50) * self.SmokeSize + 1.05 * AddVel)
			particle:SetDieTime(math.Rand(0.6, 1) * self.Life * 6)
			particle:SetStartAlpha(math.Rand(12, 24))
			particle:SetEndAlpha(0)
			particle:SetStartSize(math.Rand(5, 7) * self.SmokeSize)
			particle:SetEndSize(math.Rand(15, 20) * self.SmokeSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.Rand(-0.8, 0.8))
			particle:SetLighting(true)
			particle:SetAirResistance(20)
			particle:SetGravity(Vector(0, 0, 60))
			particle:SetColor(255, 255, 255)
		end
	end

	local sparkcount = math.Round(math.random(8, 12) * self.SparkSize)

	for _ = 0, sparkcount do
		local particle = emitter:Add("effects/yellowflare", self.Position)

		if (particle) then
			particle:SetVelocity( VectorRand() * 30 * self.SparkSize)
			particle:SetVelocity(particle:GetVelocity() + 1.15 * AddVel )
			particle:SetVelocity( particle:GetVelocity() + dir * math.Rand(80, 100) * (1-math.abs(math.max(particle:GetVelocity():GetNormalized():Dot(-dir),0))) * self.SparkSize )
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * math.Rand(0.9,1.1))
			particle:SetStartAlpha(255)
			particle:SetEndAlpha(0)
			particle:SetStartSize(0.6)
			particle:SetEndSize(1)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetGravity(vector_origin)
			particle:SetAirResistance(1)
			particle:SetStartLength(0.1)
			particle:SetEndLength(0.05)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, math.random(192, 225), math.random(140, 192))
			end

			particle:SetVelocityScale(true)
			local sl = self.SparkSize

			particle:SetThinkFunction(function(pa)
				math.randomseed(SysTime())
				local spd = pa:GetVelocity():Length()*12
				pa.ranvel = pa.ranvel or VectorRand() * spd
				pa.ranvel:Add(VectorRand() * spd * math.sqrt(FrameTime()))
				pa:SetVelocity(pa:GetVelocity() + pa.ranvel * sl * FrameTime() )
				pa:SetNextThink(CurTime())
			end)

			particle:SetNextThink(CurTime() + 0.01)
		end
	end

	if TFA.GetGasEnabled() then
		local particle = emitter:Add("sprites/heatwave", self.vOffset + dir*2)

		if (particle) then
			particle:SetVelocity(dir * 25 * self.HeatSize + 1.05 * AddVel)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life)
			particle:SetStartAlpha(math.Rand(200, 225))
			particle:SetEndAlpha(0)
			particle:SetStartSize(math.Rand(3, 5) * self.HeatSize)
			particle:SetEndSize(math.Rand(8, 12) * self.HeatSize)
			particle:SetRoll(math.Rand(0, 360))
			particle:SetRollDelta(math.Rand(-2, 2))
			particle:SetAirResistance(5)
			particle:SetGravity(Vector(0, 0, 40))
			particle:SetColor(255, 255, 255)
		end
	end

	emitter:Finish()
end

function EFFECT:Think()
	if CurTime() > self.DieTime then
		return false
	elseif self.DLight and IsValid(self.OwnerEnt) then
			self.DLight.pos = self.OwnerEnt:GetShootPos() + self.OwnerEnt:EyeAngles():Forward() * self.Dist
	end

	return true
end

function EFFECT:Render()
end
--lua/effects/rw_sw_muzzleflash_orange.lua:
EFFECT.Life = 0.12
EFFECT.XFlashSize = 0.55
EFFECT.FlashSize = 0.5
EFFECT.SmokeSize = 0
EFFECT.SparkSize = 1.25
EFFECT.HeatSize = 1
EFFECT.Color = Color(255,150,0)
EFFECT.ColorSprites = true

local AddVel = Vector()
local ang

function EFFECT:Init(data)
	self.WeaponEnt = data:GetEntity()
	if not IsValid(self.WeaponEnt) then return end
	self.Attachment = data:GetAttachment()
	self.Position = self:GetTracerShootPos(data:GetOrigin(), self.WeaponEnt, self.Attachment)

	if IsValid(self.WeaponEnt:GetOwner()) then
		if self.WeaponEnt:GetOwner() == LocalPlayer() then
			if self.WeaponEnt:GetOwner():ShouldDrawLocalPlayer() then
				ang = self.WeaponEnt:GetOwner():EyeAngles()
				ang:Normalize()
				--ang.p = math.max(math.min(ang.p,55),-55)
				self.Forward = ang:Forward()
			else
				self.WeaponEnt = self.WeaponEnt:GetOwner():GetViewModel()
			end
			--ang.p = math.max(math.min(ang.p,55),-55)
		else
			ang = self.WeaponEnt:GetOwner():EyeAngles()
			ang:Normalize()
			self.Forward = ang:Forward()
		end
	end

	self.Forward = self.Forward or data:GetNormal()
	self.Angle = self.Forward:Angle()
	self.Right = self.Angle:Right()
	self.vOffset = self.Position
	local dir = self.Forward
	local ownerent = self.WeaponEnt:GetOwner()

	if not IsValid(ownerent) then
		ownerent = LocalPlayer()
	end

	AddVel = ownerent:GetVelocity()
	self.vOffset = self.Position
	AddVel = AddVel * 0.05
	local dot = dir:GetNormalized():Dot(GetViewEntity():EyeAngles():Forward())
	local halofac = math.abs(dot)
	local epos = ownerent:GetShootPos()
	local dlight = DynamicLight(ownerent:EntIndex())

	if (dlight) then
		dlight.pos = epos + ownerent:EyeAngles():Forward() * self.vOffset:Distance(epos) --self.vOffset - ownerent:EyeAngles():Right() * 5 + 1.05 * ownerent:GetVelocity() * FrameTime()
		dlight.r = self.Color.r
		dlight.g = self.Color.g
		dlight.b = self.Color.b
		dlight.brightness = 4.5
		dlight.decay = 200 / self.Life
		dlight.size = self.FlashSize * 150
		dlight.dietime = CurTime() + self.Life
	end

	self.Dist = self.vOffset:Distance(epos)
	self.DLight = dlight
	self.DieTime = CurTime() + self.Life
	self.OwnerEnt = ownerent
	local emitter = ParticleEmitter(self.vOffset)
	local sval = 1 - math.random(0, 1) * 2

	if self.WeaponEnt.XTick == nil then
		self.WeaponEnt.XTick = 0
	end

	self.WeaponEnt.XTick = 1 - self.WeaponEnt.XTick

	if self.WeaponEnt.XTick == 1 and self.XFlashSize > 0 then
		local particle = emitter:Add(self.ColorSprites and "effects/muzzleflashx_nemole_w" or "effects/muzzleflashx_nemole", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 4 * self.XFlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life / 2)
			particle:SetStartAlpha(math.Rand(200, 255))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 8 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(3 * (halofac * 0.8 + 0.2) * self.XFlashSize)
			particle:SetEndSize(15 * (halofac * 0.8 + 0.2) * self.XFlashSize)
			local r = math.Rand(-10, 10) * 3.14 / 180
			particle:SetRoll(r)
			particle:SetRollDelta(r / 5)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
			particle:SetPos(vector_origin)
		end
		--particle:SetStartSize( 8 * (halofac*0.8+0.2), 0, 1)
		--particle:SetEndSize( 0 )
	elseif self.XFlashSize > 0 then
		local particle = emitter:Add(self.ColorSprites and "effects/muzzleflashx_nemole_w" or "effects/muzzleflashx_nemole", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 4 * self.FlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life / 2)
			particle:SetStartAlpha(math.Rand(200, 255))
			particle:SetEndAlpha(0)
			particle:SetStartSize(2 * (halofac * 0.8 + 0.2) * 0.3 * self.FlashSize)
			particle:SetEndSize(6 * (halofac * 0.8 + 0.2) * 0.3 * self.FlashSize)
			local r = math.Rand(-10, 10) * 3.14 / 180
			particle:SetRoll(r)
			particle:SetRollDelta(r / 5)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
			particle:SetPos(vector_origin)
		end
	end

	local flashCount = math.Round(self.FlashSize * 8)

	for i = 1, flashCount do
		local particle = emitter:Add(self.ColorSprites and "effects/scotchmuzzleflashw" or "effects/scotchmuzzleflash4", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 300 * (0.2 + (i / flashCount) * 0.8) * self.FlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 0.75)
			particle:SetStartAlpha(math.Rand(128, 255))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			local szsc = 1 + (flashCount - i) * math.pow(1 / flashCount * 0.9,0.8)
			particle:SetStartSize(1.25 * math.Rand(1, 1.5) * szsc * self.FlashSize)
			particle:SetEndSize(6 * math.Rand(0.75, 1) * szsc * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(15, 30)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	for _ = 1, flashCount do
		local particle = emitter:Add("effects/scotchmuzzleflash1", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 6 * self.FlashSize + 1.05 * AddVel)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 1)
			particle:SetStartAlpha(math.Rand(40, 140))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(2 * math.Rand(1, 1.5) * self.FlashSize)
			particle:SetEndSize(20 * math.Rand(0.5, 1) * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(30, 60)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			--TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	local glowCount = math.ceil(self.FlashSize * 3)

	for i = 1, glowCount do
		local particle = emitter:Add("effects/scotchmuzzleflash1", self.vOffset + dir * 0.9 * i)

		if (particle) then
			--particle:SetVelocity(dir * 32 )
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 0.75)
			particle:SetStartAlpha(255 * (1 - halofac))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(math.max(12 - 12 / glowCount * i * 0.5, 1) * 0.2 * self.FlashSize)
			particle:SetEndSize(math.max(12 - 12 / glowCount * i * 0.5, 1) * 0.6 * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(15, 30)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	local smokeCount = math.ceil(self.SmokeSize * 6)

	for _ = 0, smokeCount do
		local particle = emitter:Add("particles/smokey", self.vOffset + dir * math.Rand(3, 14))

		if (particle) then
			particle:SetVelocity(VectorRand() * 10 * self.SmokeSize + dir * math.Rand(35, 50) * self.SmokeSize + 1.05 * AddVel)
			particle:SetDieTime(math.Rand(0.6, 1) * self.Life * 6)
			particle:SetStartAlpha(math.Rand(12, 24))
			particle:SetEndAlpha(0)
			particle:SetStartSize(math.Rand(5, 7) * self.SmokeSize)
			particle:SetEndSize(math.Rand(15, 20) * self.SmokeSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.Rand(-0.8, 0.8))
			particle:SetLighting(true)
			particle:SetAirResistance(20)
			particle:SetGravity(Vector(0, 0, 60))
			particle:SetColor(255, 255, 255)
		end
	end

	local sparkcount = math.Round(math.random(8, 12) * self.SparkSize)

	for _ = 0, sparkcount do
		local particle = emitter:Add("effects/yellowflare", self.Position)

		if (particle) then
			particle:SetVelocity( VectorRand() * 30 * self.SparkSize)
			particle:SetVelocity(particle:GetVelocity() + 1.15 * AddVel )
			particle:SetVelocity( particle:GetVelocity() + dir * math.Rand(80, 100) * (1-math.abs(math.max(particle:GetVelocity():GetNormalized():Dot(-dir),0))) * self.SparkSize )
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * math.Rand(0.9,1.1))
			particle:SetStartAlpha(255)
			particle:SetEndAlpha(0)
			particle:SetStartSize(0.6)
			particle:SetEndSize(1)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetGravity(vector_origin)
			particle:SetAirResistance(1)
			particle:SetStartLength(0.1)
			particle:SetEndLength(0.05)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, math.random(192, 225), math.random(140, 192))
			end

			particle:SetVelocityScale(true)
			local sl = self.SparkSize

			particle:SetThinkFunction(function(pa)
				math.randomseed(SysTime())
				local spd = pa:GetVelocity():Length()*12
				pa.ranvel = pa.ranvel or VectorRand() * spd
				pa.ranvel:Add(VectorRand() * spd * math.sqrt(FrameTime()))
				pa:SetVelocity(pa:GetVelocity() + pa.ranvel * sl * FrameTime() )
				pa:SetNextThink(CurTime())
			end)

			particle:SetNextThink(CurTime() + 0.01)
		end
	end

	if TFA.GetGasEnabled() then
		local particle = emitter:Add("sprites/heatwave", self.vOffset + dir*2)

		if (particle) then
			particle:SetVelocity(dir * 25 * self.HeatSize + 1.05 * AddVel)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life)
			particle:SetStartAlpha(math.Rand(200, 225))
			particle:SetEndAlpha(0)
			particle:SetStartSize(math.Rand(3, 5) * self.HeatSize)
			particle:SetEndSize(math.Rand(8, 12) * self.HeatSize)
			particle:SetRoll(math.Rand(0, 360))
			particle:SetRollDelta(math.Rand(-2, 2))
			particle:SetAirResistance(5)
			particle:SetGravity(Vector(0, 0, 40))
			particle:SetColor(255, 255, 255)
		end
	end

	emitter:Finish()
end

function EFFECT:Think()
	if CurTime() > self.DieTime then
		return false
	elseif self.DLight and IsValid(self.OwnerEnt) then
			self.DLight.pos = self.OwnerEnt:GetShootPos() + self.OwnerEnt:EyeAngles():Forward() * self.Dist
	end

	return true
end

function EFFECT:Render()
end
--lua/effects/rw_sw_muzzleflash_purple.lua:
EFFECT.Life = 0.12
EFFECT.XFlashSize = 0.55
EFFECT.FlashSize = 0.5
EFFECT.SmokeSize = 0
EFFECT.SparkSize = 1.25
EFFECT.HeatSize = 2.5
EFFECT.Color = Color(155,0,255)
EFFECT.ColorSprites = true

local AddVel = Vector()
local ang

function EFFECT:Init(data)
	self.WeaponEnt = data:GetEntity()
	if not IsValid(self.WeaponEnt) then return end
	self.Attachment = data:GetAttachment()
	self.Position = self:GetTracerShootPos(data:GetOrigin(), self.WeaponEnt, self.Attachment)

	if IsValid(self.WeaponEnt:GetOwner()) then
		if self.WeaponEnt:GetOwner() == LocalPlayer() then
			if self.WeaponEnt:GetOwner():ShouldDrawLocalPlayer() then
				ang = self.WeaponEnt:GetOwner():EyeAngles()
				ang:Normalize()
				--ang.p = math.max(math.min(ang.p,55),-55)
				self.Forward = ang:Forward()
			else
				self.WeaponEnt = self.WeaponEnt:GetOwner():GetViewModel()
			end
			--ang.p = math.max(math.min(ang.p,55),-55)
		else
			ang = self.WeaponEnt:GetOwner():EyeAngles()
			ang:Normalize()
			self.Forward = ang:Forward()
		end
	end

	self.Forward = self.Forward or data:GetNormal()
	self.Angle = self.Forward:Angle()
	self.Right = self.Angle:Right()
	self.vOffset = self.Position
	local dir = self.Forward
	local ownerent = self.WeaponEnt:GetOwner()

	if not IsValid(ownerent) then
		ownerent = LocalPlayer()
	end

	AddVel = ownerent:GetVelocity()
	self.vOffset = self.Position
	AddVel = AddVel * 0.05
	local dot = dir:GetNormalized():Dot(GetViewEntity():EyeAngles():Forward())
	local halofac = math.abs(dot)
	local epos = ownerent:GetShootPos()
	local dlight = DynamicLight(ownerent:EntIndex())

	if (dlight) then
		dlight.pos = epos + ownerent:EyeAngles():Forward() * self.vOffset:Distance(epos) --self.vOffset - ownerent:EyeAngles():Right() * 5 + 1.05 * ownerent:GetVelocity() * FrameTime()
		dlight.r = self.Color.r
		dlight.g = self.Color.g
		dlight.b = self.Color.b
		dlight.brightness = 4.5
		dlight.decay = 200 / self.Life
		dlight.size = self.FlashSize * 150
		dlight.dietime = CurTime() + self.Life
	end

	self.Dist = self.vOffset:Distance(epos)
	self.DLight = dlight
	self.DieTime = CurTime() + self.Life
	self.OwnerEnt = ownerent
	local emitter = ParticleEmitter(self.vOffset)
	local sval = 1 - math.random(0, 1) * 2

	if self.WeaponEnt.XTick == nil then
		self.WeaponEnt.XTick = 0
	end

	self.WeaponEnt.XTick = 1 - self.WeaponEnt.XTick

	if self.WeaponEnt.XTick == 1 and self.XFlashSize > 0 then
		local particle = emitter:Add(self.ColorSprites and "effects/muzzleflashx_nemole_w" or "effects/muzzleflashx_nemole", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 4 * self.XFlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life / 2)
			particle:SetStartAlpha(math.Rand(200, 255))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 8 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(3 * (halofac * 0.8 + 0.2) * self.XFlashSize)
			particle:SetEndSize(15 * (halofac * 0.8 + 0.2) * self.XFlashSize)
			local r = math.Rand(-10, 10) * 3.14 / 180
			particle:SetRoll(r)
			particle:SetRollDelta(r / 5)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
			particle:SetPos(vector_origin)
		end
		--particle:SetStartSize( 8 * (halofac*0.8+0.2), 0, 1)
		--particle:SetEndSize( 0 )
	elseif self.XFlashSize > 0 then
		local particle = emitter:Add(self.ColorSprites and "effects/muzzleflashx_nemole_w" or "effects/muzzleflashx_nemole", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 4 * self.FlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life / 2)
			particle:SetStartAlpha(math.Rand(200, 255))
			particle:SetEndAlpha(0)
			particle:SetStartSize(2 * (halofac * 0.8 + 0.2) * 0.3 * self.FlashSize)
			particle:SetEndSize(6 * (halofac * 0.8 + 0.2) * 0.3 * self.FlashSize)
			local r = math.Rand(-10, 10) * 3.14 / 180
			particle:SetRoll(r)
			particle:SetRollDelta(r / 5)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
			particle:SetPos(vector_origin)
		end
	end

	local flashCount = math.Round(self.FlashSize * 8)

	for i = 1, flashCount do
		local particle = emitter:Add(self.ColorSprites and "effects/scotchmuzzleflashw" or "effects/scotchmuzzleflash4", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 300 * (0.2 + (i / flashCount) * 0.8) * self.FlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 0.75)
			particle:SetStartAlpha(math.Rand(128, 255))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			local szsc = 1 + (flashCount - i) * math.pow(1 / flashCount * 0.9,0.8)
			particle:SetStartSize(1.25 * math.Rand(1, 1.5) * szsc * self.FlashSize)
			particle:SetEndSize(6 * math.Rand(0.75, 1) * szsc * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(15, 30)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	for _ = 1, flashCount do
		local particle = emitter:Add("effects/scotchmuzzleflash1", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 6 * self.FlashSize + 1.05 * AddVel)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 1)
			particle:SetStartAlpha(math.Rand(40, 140))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(2 * math.Rand(1, 1.5) * self.FlashSize)
			particle:SetEndSize(20 * math.Rand(0.5, 1) * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(30, 60)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			--TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	local glowCount = math.ceil(self.FlashSize * 3)

	for i = 1, glowCount do
		local particle = emitter:Add("effects/scotchmuzzleflash1", self.vOffset + dir * 0.9 * i)

		if (particle) then
			--particle:SetVelocity(dir * 32 )
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 0.75)
			particle:SetStartAlpha(255 * (1 - halofac))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(math.max(12 - 12 / glowCount * i * 0.5, 1) * 0.2 * self.FlashSize)
			particle:SetEndSize(math.max(12 - 12 / glowCount * i * 0.5, 1) * 0.6 * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(15, 30)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	local smokeCount = math.ceil(self.SmokeSize * 6)

	for _ = 0, smokeCount do
		local particle = emitter:Add("particles/smokey", self.vOffset + dir * math.Rand(3, 14))

		if (particle) then
			particle:SetVelocity(VectorRand() * 10 * self.SmokeSize + dir * math.Rand(35, 50) * self.SmokeSize + 1.05 * AddVel)
			particle:SetDieTime(math.Rand(0.6, 1) * self.Life * 6)
			particle:SetStartAlpha(math.Rand(12, 24))
			particle:SetEndAlpha(0)
			particle:SetStartSize(math.Rand(5, 7) * self.SmokeSize)
			particle:SetEndSize(math.Rand(15, 20) * self.SmokeSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.Rand(-0.8, 0.8))
			particle:SetLighting(true)
			particle:SetAirResistance(20)
			particle:SetGravity(Vector(0, 0, 60))
			particle:SetColor(255, 255, 255)
		end
	end

	local sparkcount = math.Round(math.random(8, 12) * self.SparkSize)

	for _ = 0, sparkcount do
		local particle = emitter:Add("effects/yellowflare", self.Position)

		if (particle) then
			particle:SetVelocity( VectorRand() * 30 * self.SparkSize)
			particle:SetVelocity(particle:GetVelocity() + 1.15 * AddVel )
			particle:SetVelocity( particle:GetVelocity() + dir * math.Rand(80, 100) * (1-math.abs(math.max(particle:GetVelocity():GetNormalized():Dot(-dir),0))) * self.SparkSize )
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * math.Rand(0.9,1.1))
			particle:SetStartAlpha(255)
			particle:SetEndAlpha(0)
			particle:SetStartSize(0.6)
			particle:SetEndSize(1)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetGravity(vector_origin)
			particle:SetAirResistance(1)
			particle:SetStartLength(0.1)
			particle:SetEndLength(0.05)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, math.random(192, 225), math.random(140, 192))
			end

			particle:SetVelocityScale(true)
			local sl = self.SparkSize

			particle:SetThinkFunction(function(pa)
				math.randomseed(SysTime())
				local spd = pa:GetVelocity():Length()*12
				pa.ranvel = pa.ranvel or VectorRand() * spd
				pa.ranvel:Add(VectorRand() * spd * math.sqrt(FrameTime()))
				pa:SetVelocity(pa:GetVelocity() + pa.ranvel * sl * FrameTime() )
				pa:SetNextThink(CurTime())
			end)

			particle:SetNextThink(CurTime() + 0.01)
		end
	end

	if TFA.GetGasEnabled() then
		local particle = emitter:Add("sprites/heatwave", self.vOffset + dir*2)

		if (particle) then
			particle:SetVelocity(dir * 25 * self.HeatSize + 1.05 * AddVel)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life)
			particle:SetStartAlpha(math.Rand(200, 225))
			particle:SetEndAlpha(0)
			particle:SetStartSize(math.Rand(3, 5) * self.HeatSize)
			particle:SetEndSize(math.Rand(8, 12) * self.HeatSize)
			particle:SetRoll(math.Rand(0, 360))
			particle:SetRollDelta(math.Rand(-2, 2))
			particle:SetAirResistance(5)
			particle:SetGravity(Vector(0, 0, 40))
			particle:SetColor(255, 255, 255)
		end
	end

	emitter:Finish()
end

function EFFECT:Think()
	if CurTime() > self.DieTime then
		return false
	elseif self.DLight and IsValid(self.OwnerEnt) then
			self.DLight.pos = self.OwnerEnt:GetShootPos() + self.OwnerEnt:EyeAngles():Forward() * self.Dist
	end

	return true
end

function EFFECT:Render()
end
--lua/effects/rw_sw_muzzleflash_yellow.lua:
EFFECT.Life = 0.12
EFFECT.XFlashSize = 0.55
EFFECT.FlashSize = 0.5
EFFECT.SmokeSize = 0
EFFECT.SparkSize = 1.25
EFFECT.HeatSize = 2.5
EFFECT.Color = Color(255,255,0)
EFFECT.ColorSprites = true

local AddVel = Vector()
local ang

function EFFECT:Init(data)
	self.WeaponEnt = data:GetEntity()
	if not IsValid(self.WeaponEnt) then return end
	self.Attachment = data:GetAttachment()
	self.Position = self:GetTracerShootPos(data:GetOrigin(), self.WeaponEnt, self.Attachment)

	if IsValid(self.WeaponEnt:GetOwner()) then
		if self.WeaponEnt:GetOwner() == LocalPlayer() then
			if self.WeaponEnt:GetOwner():ShouldDrawLocalPlayer() then
				ang = self.WeaponEnt:GetOwner():EyeAngles()
				ang:Normalize()
				--ang.p = math.max(math.min(ang.p,55),-55)
				self.Forward = ang:Forward()
			else
				self.WeaponEnt = self.WeaponEnt:GetOwner():GetViewModel()
			end
			--ang.p = math.max(math.min(ang.p,55),-55)
		else
			ang = self.WeaponEnt:GetOwner():EyeAngles()
			ang:Normalize()
			self.Forward = ang:Forward()
		end
	end

	self.Forward = self.Forward or data:GetNormal()
	self.Angle = self.Forward:Angle()
	self.Right = self.Angle:Right()
	self.vOffset = self.Position
	local dir = self.Forward
	local ownerent = self.WeaponEnt:GetOwner()

	if not IsValid(ownerent) then
		ownerent = LocalPlayer()
	end

	AddVel = ownerent:GetVelocity()
	self.vOffset = self.Position
	AddVel = AddVel * 0.05
	local dot = dir:GetNormalized():Dot(GetViewEntity():EyeAngles():Forward())
	local halofac = math.abs(dot)
	local epos = ownerent:GetShootPos()
	local dlight = DynamicLight(ownerent:EntIndex())

	if (dlight) then
		dlight.pos = epos + ownerent:EyeAngles():Forward() * self.vOffset:Distance(epos) --self.vOffset - ownerent:EyeAngles():Right() * 5 + 1.05 * ownerent:GetVelocity() * FrameTime()
		dlight.r = self.Color.r
		dlight.g = self.Color.g
		dlight.b = self.Color.b
		dlight.brightness = 4.5
		dlight.decay = 200 / self.Life
		dlight.size = self.FlashSize * 150
		dlight.dietime = CurTime() + self.Life
	end

	self.Dist = self.vOffset:Distance(epos)
	self.DLight = dlight
	self.DieTime = CurTime() + self.Life
	self.OwnerEnt = ownerent
	local emitter = ParticleEmitter(self.vOffset)
	local sval = 1 - math.random(0, 1) * 2

	if self.WeaponEnt.XTick == nil then
		self.WeaponEnt.XTick = 0
	end

	self.WeaponEnt.XTick = 1 - self.WeaponEnt.XTick

	if self.WeaponEnt.XTick == 1 and self.XFlashSize > 0 then
		local particle = emitter:Add(self.ColorSprites and "effects/muzzleflashx_nemole_w" or "effects/muzzleflashx_nemole", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 4 * self.XFlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life / 2)
			particle:SetStartAlpha(math.Rand(200, 255))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 8 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(3 * (halofac * 0.8 + 0.2) * self.XFlashSize)
			particle:SetEndSize(15 * (halofac * 0.8 + 0.2) * self.XFlashSize)
			local r = math.Rand(-10, 10) * 3.14 / 180
			particle:SetRoll(r)
			particle:SetRollDelta(r / 5)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
			particle:SetPos(vector_origin)
		end
		--particle:SetStartSize( 8 * (halofac*0.8+0.2), 0, 1)
		--particle:SetEndSize( 0 )
	elseif self.XFlashSize > 0 then
		local particle = emitter:Add(self.ColorSprites and "effects/muzzleflashx_nemole_w" or "effects/muzzleflashx_nemole", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 4 * self.FlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life / 2)
			particle:SetStartAlpha(math.Rand(200, 255))
			particle:SetEndAlpha(0)
			particle:SetStartSize(2 * (halofac * 0.8 + 0.2) * 0.3 * self.FlashSize)
			particle:SetEndSize(6 * (halofac * 0.8 + 0.2) * 0.3 * self.FlashSize)
			local r = math.Rand(-10, 10) * 3.14 / 180
			particle:SetRoll(r)
			particle:SetRollDelta(r / 5)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
			particle:SetPos(vector_origin)
		end
	end

	local flashCount = math.Round(self.FlashSize * 8)

	for i = 1, flashCount do
		local particle = emitter:Add(self.ColorSprites and "effects/scotchmuzzleflashw" or "effects/scotchmuzzleflash4", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 300 * (0.2 + (i / flashCount) * 0.8) * self.FlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 0.75)
			particle:SetStartAlpha(math.Rand(128, 255))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			local szsc = 1 + (flashCount - i) * math.pow(1 / flashCount * 0.9,0.8)
			particle:SetStartSize(1.25 * math.Rand(1, 1.5) * szsc * self.FlashSize)
			particle:SetEndSize(6 * math.Rand(0.75, 1) * szsc * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(15, 30)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	for _ = 1, flashCount do
		local particle = emitter:Add("effects/scotchmuzzleflash1", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 6 * self.FlashSize + 1.05 * AddVel)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 1)
			particle:SetStartAlpha(math.Rand(40, 140))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(2 * math.Rand(1, 1.5) * self.FlashSize)
			particle:SetEndSize(20 * math.Rand(0.5, 1) * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(30, 60)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			--TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	local glowCount = math.ceil(self.FlashSize * 3)

	for i = 1, glowCount do
		local particle = emitter:Add("effects/scotchmuzzleflash1", self.vOffset + dir * 0.9 * i)

		if (particle) then
			--particle:SetVelocity(dir * 32 )
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 0.75)
			particle:SetStartAlpha(255 * (1 - halofac))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(math.max(12 - 12 / glowCount * i * 0.5, 1) * 0.2 * self.FlashSize)
			particle:SetEndSize(math.max(12 - 12 / glowCount * i * 0.5, 1) * 0.6 * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(15, 30)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	local smokeCount = math.ceil(self.SmokeSize * 6)

	for _ = 0, smokeCount do
		local particle = emitter:Add("particles/smokey", self.vOffset + dir * math.Rand(3, 14))

		if (particle) then
			particle:SetVelocity(VectorRand() * 10 * self.SmokeSize + dir * math.Rand(35, 50) * self.SmokeSize + 1.05 * AddVel)
			particle:SetDieTime(math.Rand(0.6, 1) * self.Life * 6)
			particle:SetStartAlpha(math.Rand(12, 24))
			particle:SetEndAlpha(0)
			particle:SetStartSize(math.Rand(5, 7) * self.SmokeSize)
			particle:SetEndSize(math.Rand(15, 20) * self.SmokeSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.Rand(-0.8, 0.8))
			particle:SetLighting(true)
			particle:SetAirResistance(20)
			particle:SetGravity(Vector(0, 0, 60))
			particle:SetColor(255, 255, 255)
		end
	end

	local sparkcount = math.Round(math.random(8, 12) * self.SparkSize)

	for _ = 0, sparkcount do
		local particle = emitter:Add("effects/yellowflare", self.Position)

		if (particle) then
			particle:SetVelocity( VectorRand() * 30 * self.SparkSize)
			particle:SetVelocity(particle:GetVelocity() + 1.15 * AddVel )
			particle:SetVelocity( particle:GetVelocity() + dir * math.Rand(80, 100) * (1-math.abs(math.max(particle:GetVelocity():GetNormalized():Dot(-dir),0))) * self.SparkSize )
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * math.Rand(0.9,1.1))
			particle:SetStartAlpha(255)
			particle:SetEndAlpha(0)
			particle:SetStartSize(0.6)
			particle:SetEndSize(1)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetGravity(vector_origin)
			particle:SetAirResistance(1)
			particle:SetStartLength(0.1)
			particle:SetEndLength(0.05)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, math.random(192, 225), math.random(140, 192))
			end

			particle:SetVelocityScale(true)
			local sl = self.SparkSize

			particle:SetThinkFunction(function(pa)
				math.randomseed(SysTime())
				local spd = pa:GetVelocity():Length()*12
				pa.ranvel = pa.ranvel or VectorRand() * spd
				pa.ranvel:Add(VectorRand() * spd * math.sqrt(FrameTime()))
				pa:SetVelocity(pa:GetVelocity() + pa.ranvel * sl * FrameTime() )
				pa:SetNextThink(CurTime())
			end)

			particle:SetNextThink(CurTime() + 0.01)
		end
	end

	if TFA.GetGasEnabled() then
		local particle = emitter:Add("sprites/heatwave", self.vOffset + dir*2)

		if (particle) then
			particle:SetVelocity(dir * 25 * self.HeatSize + 1.05 * AddVel)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life)
			particle:SetStartAlpha(math.Rand(200, 225))
			particle:SetEndAlpha(0)
			particle:SetStartSize(math.Rand(3, 5) * self.HeatSize)
			particle:SetEndSize(math.Rand(8, 12) * self.HeatSize)
			particle:SetRoll(math.Rand(0, 360))
			particle:SetRollDelta(math.Rand(-2, 2))
			particle:SetAirResistance(5)
			particle:SetGravity(Vector(0, 0, 40))
			particle:SetColor(255, 255, 255)
		end
	end

	emitter:Finish()
end

function EFFECT:Think()
	if CurTime() > self.DieTime then
		return false
	elseif self.DLight and IsValid(self.OwnerEnt) then
			self.DLight.pos = self.OwnerEnt:GetShootPos() + self.OwnerEnt:EyeAngles():Forward() * self.Dist
	end

	return true
end

function EFFECT:Render()
end
--lua/effects/rw_sw_stunwave_green.lua:

TRACER_FLAG_USEATTACHMENT	= 0x0002;
SOUND_FROM_WORLD			= 0;
CHAN_STATIC					= 6;

EFFECT.Speed				= 4500;
EFFECT.Length				= 64;

local MaterialFront			= Material( "cs574/stun_tracers/sw_stunwave_green" );

function EFFECT:GetTracerOrigin(data)
	local start = data:GetStart()
	if (bit.band(data:GetFlags(), TRACER_FLAG_USEATTACHMENT) == TRACER_FLAG_USEATTACHMENT) then
		local entity = data:GetEntity()
		if (not IsValid(entity)) then return start end
		if (not game.SinglePlayer() and entity:IsEFlagSet(EFL_DORMANT)) then return start end

		if (entity:IsWeapon() and entity:IsCarriedByLocalPlayer()) then
			local pl = entity:GetOwner()

			if (IsValid(pl)) then
				local vm = pl:GetViewModel()

				if (IsValid(vm) and not LocalPlayer():ShouldDrawLocalPlayer()) then
					entity = vm
				else
					if (entity.WorldModel) then
						entity:SetModel(entity.WorldModel)
					end
				end
			end
		end
		local attachment = entity:GetAttachment(data:GetAttachment())
		if (attachment) then
			start = attachment.Pos
		end
	end

	return start
end

function EFFECT:Init(data)
	self.StartPos = self:GetTracerOrigin(data)
	self.EndPos = data:GetOrigin()
	self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)
	local diff = (self.EndPos - self.StartPos)
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	self.LifeTime = (diff:Length() + self.Length) / self.Speed
	-- whiz by sound
	local weapon = data:GetEntity()

	if (IsValid(weapon) and (not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer())) then
		local dist, pos, time = util.DistanceToLine(self.StartPos, self.EndPos, EyePos())
	end
end

EFFECT.WaveSize = 0

function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()

	if (self.WaveSize < 45) then
		self.WaveSize = self.WaveSize + 1
	end

	return self.LifeTime > 0
end

function EFFECT:Render()
	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	startDistance = math.max(0, startDistance)
	endDistance = math.max(0, endDistance)
	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	render.SetMaterial(MaterialFront)
	render.DrawSprite(startPos, 1 + self.WaveSize, 1 + self.WaveSize, color_white)
end
--lua/effects/rw_sw_stunwave_red.lua:

TRACER_FLAG_USEATTACHMENT	= 0x0002;
SOUND_FROM_WORLD			= 0;
CHAN_STATIC					= 6;

EFFECT.Speed				= 4500;
EFFECT.Length				= 64;

local MaterialFront			= Material( "cs574/stun_tracers/sw_stunwave_red" );

function EFFECT:GetTracerOrigin(data)
	local start = data:GetStart()
	if (bit.band(data:GetFlags(), TRACER_FLAG_USEATTACHMENT) == TRACER_FLAG_USEATTACHMENT) then
		local entity = data:GetEntity()
		if (not IsValid(entity)) then return start end
		if (not game.SinglePlayer() and entity:IsEFlagSet(EFL_DORMANT)) then return start end

		if (entity:IsWeapon() and entity:IsCarriedByLocalPlayer()) then
			local pl = entity:GetOwner()

			if (IsValid(pl)) then
				local vm = pl:GetViewModel()

				if (IsValid(vm) and not LocalPlayer():ShouldDrawLocalPlayer()) then
					entity = vm
				else
					if (entity.WorldModel) then
						entity:SetModel(entity.WorldModel)
					end
				end
			end
		end
		local attachment = entity:GetAttachment(data:GetAttachment())
		if (attachment) then
			start = attachment.Pos
		end
	end

	return start
end

function EFFECT:Init(data)
	self.StartPos = self:GetTracerOrigin(data)
	self.EndPos = data:GetOrigin()
	self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)
	local diff = (self.EndPos - self.StartPos)
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	self.LifeTime = (diff:Length() + self.Length) / self.Speed
	-- whiz by sound
	local weapon = data:GetEntity()

	if (IsValid(weapon) and (not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer())) then
		local dist, pos, time = util.DistanceToLine(self.StartPos, self.EndPos, EyePos())
	end
end

EFFECT.WaveSize = 0

function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()

	if (self.WaveSize < 45) then
		self.WaveSize = self.WaveSize + 1
	end

	return self.LifeTime > 0
end

function EFFECT:Render()
	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	startDistance = math.max(0, startDistance)
	endDistance = math.max(0, endDistance)
	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	render.SetMaterial(MaterialFront)
	render.DrawSprite(startPos, 1 + self.WaveSize, 1 + self.WaveSize, color_white)
end
--lua/effects/serv_passive_heal.lua:
EFFECT.Mat1 = Material( "particle/particle_ring_wave_8" )
EFFECT.Mat2 = Material( "sprites/key_12" )

function EFFECT:Init( data )
	self.StartPos = data:GetOrigin()
	self.Entity = data:GetEntity()
	self.FollowPlayer = self.Entity:GetPos()

	self.Duration = data:GetScale()*6
	self.HPMax = math.max( math.Round( data:GetMagnitude() ),0)
	self.HealingAm = 0

	self.Alpha = 255
	self.Life = 0

	self.Color = Color(50, 150, 50, 255)
end

function EFFECT:Think()
	if !self.Entity:IsValid() then return end

	self.HealingAm = math.Clamp((self.Entity:GetMaxHealth()-self.Entity:Health())/2, 0, 10)

	self.FollowPlayer = self.Entity:GetPos()

	self.Life = self.Life + FrameTime() * 6

	self.Alpha = 255 * ( 1 - self.Life )
	self.Color["a"] = math.max(255-(self.Life*60),0)

	return ( self.Life < self.Duration )
end

function EFFECT:Render()
	-- Particles
	local emitter = ParticleEmitter( self.FollowPlayer, false )
	local particle = emitter:Add( self.Mat1, (self.FollowPlayer+Vector(0,0,20))+(VectorRand()*15) )
	if (particle) then
		particle:SetLifeTime(0) 
		particle:SetDieTime(2) 
		particle:SetStartAlpha( 20+(self.HealingAm*5) )
		particle:SetEndAlpha(0)
		particle:SetStartSize(30) 
		particle:SetEndSize(70)
		particle:SetAngles( Angle(math.random( 0, 360 ),math.random( 0, 360 ),math.random( 0, 360 )) )
		particle:SetAngleVelocity( Angle(math.random( 0, 1 ),math.random( 0, 1 ),math.random( 0, 1 )) ) 
		particle:SetRoll(math.random( 0, 360 ))
		particle:SetColor( self.Color["r"], self.Color["g"], self.Color["b"] )
		particle:SetGravity( Vector(0, 0, 0 ) ) 
		particle:SetVelocity( Vector(math.random( -30, 30 ), math.random( -30, 30 ), math.random( 50, 75 ) ) ) 
		particle:SetAirResistance(50)  
		particle:SetCollide(true)
		particle:SetBounce(0)
	end
	emitter:Finish()

	local emitter = ParticleEmitter( self.FollowPlayer, false )
	local particle = emitter:Add( self.Mat2, (self.FollowPlayer+Vector(0,0,20))+(VectorRand()*30) )
	if (particle) then
		particle:SetLifeTime(0) 
		particle:SetDieTime(1.2) 
		particle:SetStartAlpha(255)
		particle:SetEndAlpha(0)
		particle:SetStartSize(self.HealingAm) 
		particle:SetEndSize(0)
		particle:SetAngles( Angle(0,0,0) )
		particle:SetAngleVelocity( Angle(math.random( 0, 1 ),math.random( 0, 1 ),math.random( 0, 1 )) ) 
		particle:SetColor( self.Color["r"], self.Color["g"], self.Color["b"] )
		particle:SetGravity( Vector(0, 0, math.random( 50, 150 ) ) ) 
		particle:SetVelocity( Vector(math.random( -50, 50 ), math.random( -50, 50 ), math.random( 20, 50 ) ) ) 
		particle:SetAirResistance(50)  
		particle:SetCollide(true)
		particle:SetBounce(0)
	end
	emitter:Finish()
end
--addons/egm_tfa_grenades/lua/effects/tfa_csgo_healnade/init.lua:
--Thanks Inconceivable/Generic Default
function EFFECT:Init(data)
	self.Entity = data:GetEntity()
	if not IsValid(self.Entity) then return end

	pos = data:GetOrigin()
	self.Emitter = ParticleEmitter(pos)
	for i=1, 10 do
		local particle = self.Emitter:Add( "tfa_csgo/particle/particle_smokegrenade", pos)
		if (particle) then
			particle:SetVelocity( VectorRand():GetNormalized()*math.Rand(150, 300) )
			if i <= 5 then
				particle:SetDieTime( 20 )
			else
				particle:SetDieTime( math.Rand( 15,20 ) )
			end
			particle:SetStartAlpha( math.Rand( 66, 166 ) )
			particle:SetEndAlpha( 0 )
			particle:SetStartSize( 66 )
			particle:SetEndSize( 166 )
			particle:SetRoll( math.Rand(0, 360) )
			particle:SetRollDelta( math.Rand(-1, 1)/3 )
			particle:SetColor( 125, 255, 255 )
			particle:SetAirResistance( 82 )
			//particle:SetGravity( Vector(math.Rand(-30, 30),math.Rand(-30, 30), -200 ))
			particle:SetCollide( true )
			particle:SetBounce( 1 )
		end
	end

end

function EFFECT:Think()
return false
end

function EFFECT:Render()

end
--addons/egm_tfa_grenades/lua/effects/tfa_csgo_smokenade/init.lua:
--Thanks Inconceivable/Generic Default
function EFFECT:Init(data)
	self.Entity = data:GetEntity()
	if not IsValid(self.Entity) then return end

	pos = data:GetOrigin()
	self.Emitter = ParticleEmitter(pos)
	for i=1, 100 do
		local particle = self.Emitter:Add( "tfa_csgo/particle/particle_smokegrenade", pos)
		if (particle) then
			particle:SetVelocity( VectorRand():GetNormalized()*math.Rand(200, 500) )
			if i <= 5 then
				particle:SetDieTime( 25 )
			else
				particle:SetDieTime( math.Rand( 20,25 ) )
			end
			particle:SetStartAlpha( math.Rand( 150, 255 ) )
			particle:SetEndAlpha( 0 )
			particle:SetStartSize( 44 )
			particle:SetEndSize( 300 )
			particle:SetRoll( math.Rand(0, 360) )
			particle:SetRollDelta( math.Rand(-1, 1)/3 )
			particle:SetColor( 65, 65, 65 )
			particle:SetAirResistance( 100 )
			//particle:SetGravity( Vector(math.Rand(-30, 30),math.Rand(-30, 30), -200 ))
			particle:SetCollide( true )
			particle:SetBounce( 1 )
		end
	end

end

function EFFECT:Think()
return false
end

function EFFECT:Render()

end
--addons/tfa_base/lua/effects/tfa_dust_impact/init.lua:
function EFFECT:Init(data)
	local ply = data:GetEntity()
	local ent

	if IsValid(ply) and ply:IsPlayer() then
		ent = ply:GetActiveWeapon()
	end

	local sfac = (IsValid(ent) and ent.Primary and ent.Primary.Damage) and math.sqrt(ent.Primary.Damage / 30) or 1
	local sfac_sqrt = math.sqrt(sfac)
	local posoffset = data:GetOrigin()
	local forward = data:GetNormal()
	local emitter = ParticleEmitter(posoffset)

	for i = 0, math.Round(8 * sfac) do
		local p = emitter:Add("particle/particle_smokegrenade", posoffset)
		p:SetVelocity(90 * math.sqrt(i) * forward)
		p:SetAirResistance(400)
		p:SetStartAlpha(math.Rand(255, 255))
		p:SetEndAlpha(0)
		p:SetDieTime(math.Rand(0.75, 1) * (1 + math.sqrt(i) / 3))
		local iclamped = math.Clamp(i, 1, 8)
		local iclamped_sqrt = math.sqrt(iclamped / 8) * 8
		p:SetStartSize(math.Rand(1, 1) * sfac_sqrt * iclamped_sqrt)
		p:SetEndSize(math.Rand(1.5, 1.75) * sfac_sqrt * iclamped)
		p:SetRoll(math.Rand(-25, 25))
		p:SetRollDelta(math.Rand(-0.05, 0.05))
		p:SetColor(255, 255, 255)
		p:SetLighting(true)
	end

	emitter:Finish()
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
return false
end
--addons/tfa_base/lua/effects/tfa_muzzleflash_rifle/init.lua:
include("tfa/muzzleflash_base.lua")

EFFECT.Life = 0.1
EFFECT.XFlashSize = 1
EFFECT.FlashSize = 1
EFFECT.SmokeSize = 1
EFFECT.SparkSize = 1
EFFECT.HeatSize = 1
EFFECT.Color = Color(255, 192, 64)
EFFECT.ColorSprites = false

--addons/tfa_base/lua/tfa/muzzleflash_base.lua:
local vector_origin = Vector()

EFFECT.Life = 0.1
EFFECT.XFlashSize = 1
EFFECT.FlashSize = 1
EFFECT.SmokeSize = 1
EFFECT.SparkSize = 1
EFFECT.HeatSize = 1
EFFECT.Color = Color(255, 192, 64)
EFFECT.ColorSprites = false

local AddVel = Vector()
local ang

function EFFECT:Init(data)
	self.WeaponEnt = data:GetEntity()
	if not IsValid(self.WeaponEnt) then return end
	self.Attachment = data:GetAttachment()
	self.Position = self:GetTracerShootPos(data:GetOrigin(), self.WeaponEnt, self.Attachment)

	if IsValid(self.WeaponEnt:GetOwner()) then
		if self.WeaponEnt:GetOwner() == LocalPlayer() then
			if self.WeaponEnt:GetOwner():ShouldDrawLocalPlayer() then
				ang = self.WeaponEnt:GetOwner():EyeAngles()
				ang:Normalize()
				--ang.p = math.max(math.min(ang.p,55),-55)
				self.Forward = ang:Forward()
			else
				self.WeaponEnt = self.WeaponEnt.OwnerViewModel
			end
			--ang.p = math.max(math.min(ang.p,55),-55)
		else
			ang = self.WeaponEnt:GetOwner():EyeAngles()
			ang:Normalize()
			self.Forward = ang:Forward()
		end
	end

	self.Forward = self.Forward or data:GetNormal()
	self.Angle = self.Forward:Angle()
	self.Right = self.Angle:Right()
	self.vOffset = self.Position
	local dir = self.Forward
	local ownerent = self.WeaponEnt:GetOwner()

	if not IsValid(ownerent) then
		ownerent = LocalPlayer()
	end

	AddVel = ownerent:GetVelocity()
	self.vOffset = self.Position
	AddVel = AddVel * 0.05
	local dot = dir:GetNormalized():Dot(GetViewEntity():EyeAngles():Forward())
	local halofac = math.abs(dot)
	local epos = ownerent:EyePos()
	local dlight = DynamicLight(ownerent:EntIndex())

	if (dlight) then
		dlight.pos = epos + ownerent:EyeAngles():Forward() * self.vOffset:Distance(epos) --self.vOffset - ownerent:EyeAngles():Right() * 5 + 1.05 * ownerent:GetVelocity() * FrameTime()
		dlight.r = self.Color.r
		dlight.g = self.Color.g
		dlight.b = self.Color.b
		dlight.brightness = 4.5
		dlight.decay = 200 / self.Life
		dlight.size = self.FlashSize * 96
		dlight.dietime = CurTime() + self.Life
	end

	self.Dist = self.vOffset:Distance(epos)
	self.DLight = dlight
	self.DieTime = CurTime() + self.Life
	self.OwnerEnt = ownerent
	local emitter = ParticleEmitter(self.vOffset)
	local sval = 1 - math.random(0, 1) * 2

	if self.WeaponEnt.XTick == nil then
		self.WeaponEnt.XTick = 0
	end

	self.WeaponEnt.XTick = 1 - self.WeaponEnt.XTick

	if self.WeaponEnt.XTick == 1 and self.XFlashSize > 0 then
		local particle = emitter:Add(self.ColorSprites and "effects/muzzleflashx_nemole_w" or "effects/muzzleflashx_nemole", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 4 * self.XFlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life / 2)
			particle:SetStartAlpha(math.Rand(200, 255))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 8 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(3 * (halofac * 0.8 + 0.2) * self.XFlashSize)
			particle:SetEndSize(15 * (halofac * 0.8 + 0.2) * self.XFlashSize)
			local r = math.Rand(-10, 10) * 3.14 / 180
			particle:SetRoll(r)
			particle:SetRollDelta(r / 5)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
			particle:SetPos(vector_origin)
		end
		--particle:SetStartSize( 8 * (halofac*0.8+0.2), 0, 1)
		--particle:SetEndSize( 0 )
	elseif self.XFlashSize > 0 then
		local particle = emitter:Add(self.ColorSprites and "effects/muzzleflashx_nemole_w" or "effects/muzzleflashx_nemole", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 4 * self.FlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life / 2)
			particle:SetStartAlpha(math.Rand(200, 255))
			particle:SetEndAlpha(0)
			particle:SetStartSize(2 * (halofac * 0.8 + 0.2) * 0.3 * self.FlashSize)
			particle:SetEndSize(6 * (halofac * 0.8 + 0.2) * 0.3 * self.FlashSize)
			local r = math.Rand(-10, 10) * 3.14 / 180
			particle:SetRoll(r)
			particle:SetRollDelta(r / 5)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
			particle:SetPos(vector_origin)
		end
	end

	local flashCount = math.Round(self.FlashSize * 8)

	for i = 1, flashCount do
		local particle = emitter:Add(self.ColorSprites and "effects/scotchmuzzleflashw" or "effects/scotchmuzzleflash4", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 300 * (0.2 + (i / flashCount) * 0.8) * self.FlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 0.75)
			particle:SetStartAlpha(math.Rand(128, 255))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			local szsc = 1 + (flashCount - i) * math.pow(1 / flashCount * 0.9,0.8)
			particle:SetStartSize(1.25 * math.Rand(1, 1.5) * szsc * self.FlashSize)
			particle:SetEndSize(6 * math.Rand(0.75, 1) * szsc * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(15, 30)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	for _ = 1, flashCount do
		local particle = emitter:Add("effects/scotchmuzzleflash1", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 6 * self.FlashSize + 1.05 * AddVel)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 1)
			particle:SetStartAlpha(math.Rand(40, 140))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(2 * math.Rand(1, 1.5) * self.FlashSize)
			particle:SetEndSize(20 * math.Rand(0.5, 1) * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(30, 60)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			--TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	local glowCount = math.ceil(self.FlashSize * 3)

	for i = 1, glowCount do
		local particle = emitter:Add("effects/scotchmuzzleflash1", self.vOffset + dir * 0.9 * i)

		if (particle) then
			--particle:SetVelocity(dir * 32 )
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 0.75)
			particle:SetStartAlpha(255 * (1 - halofac))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(math.max(12 - 12 / glowCount * i * 0.5, 1) * 0.2 * self.FlashSize)
			particle:SetEndSize(math.max(12 - 12 / glowCount * i * 0.5, 1) * 0.6 * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(15, 30)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	if TFA.GetMZFSmokeEnabled() then
		local smokeCount = math.ceil(self.SmokeSize * 6)

		for _ = 0, smokeCount do
			local particle = emitter:Add("particles/smokey", self.vOffset + dir * math.Rand(3, 14))

			if (particle) then
				particle:SetVelocity(VectorRand() * 10 * self.SmokeSize + dir * math.Rand(35, 50) * self.SmokeSize + 1.05 * AddVel)
				particle:SetDieTime(math.Rand(0.6, 1) * self.Life * 6)
				particle:SetStartAlpha(math.Rand(12, 24))
				particle:SetEndAlpha(0)
				particle:SetStartSize(math.Rand(5, 7) * self.SmokeSize)
				particle:SetEndSize(math.Rand(15, 20) * self.SmokeSize)
				particle:SetRoll(math.rad(math.Rand(0, 360)))
				particle:SetRollDelta(math.Rand(-0.8, 0.8))
				particle:SetLighting(true)
				particle:SetAirResistance(20)
				particle:SetGravity(Vector(0, 0, 60))
				particle:SetColor(255, 255, 255)
			end
		end
	end

	local sparkcount = math.Round(math.random(8, 12) * self.SparkSize)

	for _ = 0, sparkcount do
		local particle = emitter:Add("effects/yellowflare", self.Position)

		if (particle) then
			particle:SetVelocity( VectorRand() * 30 * self.SparkSize)
			particle:SetVelocity(particle:GetVelocity() + 1.15 * AddVel )
			particle:SetVelocity( particle:GetVelocity() + dir * math.Rand(80, 100) * (1-math.abs(math.max(particle:GetVelocity():GetNormalized():Dot(-dir),0))) * self.SparkSize )
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * math.Rand(0.9,1.1))
			particle:SetStartAlpha(255)
			particle:SetEndAlpha(0)
			particle:SetStartSize(0.6)
			particle:SetEndSize(1)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetGravity(vector_origin)
			particle:SetAirResistance(1)
			particle:SetStartLength(0.1)
			particle:SetEndLength(0.05)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, math.random(192, 225), math.random(140, 192))
			end

			particle:SetVelocityScale(true)
			local sl = self.SparkSize

			particle:SetThinkFunction(function(pa)
				math.randomseed(SysTime())
				local spd = pa:GetVelocity():Length()*12
				pa.ranvel = pa.ranvel or VectorRand() * spd
				pa.ranvel:Add(VectorRand() * spd * math.sqrt(FrameTime()))
				pa:SetVelocity(pa:GetVelocity() + pa.ranvel * sl * FrameTime() )
				pa:SetNextThink(CurTime())
			end)

			particle:SetNextThink(CurTime() + 0.01)
		end
	end

	if TFA.GetGasEnabled() then
		local particle = emitter:Add("sprites/heatwave", self.vOffset + dir*2)

		if (particle) then
			particle:SetVelocity(dir * 25 * self.HeatSize + 1.05 * AddVel)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life)
			particle:SetStartAlpha(math.Rand(200, 225))
			particle:SetEndAlpha(0)
			particle:SetStartSize(math.Rand(3, 5) * self.HeatSize)
			particle:SetEndSize(math.Rand(8, 12) * self.HeatSize)
			particle:SetRoll(math.Rand(0, 360))
			particle:SetRollDelta(math.Rand(-2, 2))
			particle:SetAirResistance(5)
			particle:SetGravity(Vector(0, 0, 40))
			particle:SetColor(255, 255, 255)
		end
	end

	emitter:Finish()
end

function EFFECT:Think()
	if CurTime() > (self.DieTime or 0) then
		return false
	elseif self.DLight and IsValid(self.OwnerEnt) then
		self.DLight.pos = self.OwnerEnt:EyePos() + self.OwnerEnt:EyeAngles():Forward() * self.Dist
	end

	return true
end

function EFFECT:Render()
end
--addons/tfa_base/lua/tfa/muzzleflash_base.lua:
local vector_origin = Vector()

EFFECT.Life = 0.1
EFFECT.XFlashSize = 1
EFFECT.FlashSize = 1
EFFECT.SmokeSize = 1
EFFECT.SparkSize = 1
EFFECT.HeatSize = 1
EFFECT.Color = Color(255, 192, 64)
EFFECT.ColorSprites = false

local AddVel = Vector()
local ang

function EFFECT:Init(data)
	self.WeaponEnt = data:GetEntity()
	if not IsValid(self.WeaponEnt) then return end
	self.Attachment = data:GetAttachment()
	self.Position = self:GetTracerShootPos(data:GetOrigin(), self.WeaponEnt, self.Attachment)

	if IsValid(self.WeaponEnt:GetOwner()) then
		if self.WeaponEnt:GetOwner() == LocalPlayer() then
			if self.WeaponEnt:GetOwner():ShouldDrawLocalPlayer() then
				ang = self.WeaponEnt:GetOwner():EyeAngles()
				ang:Normalize()
				--ang.p = math.max(math.min(ang.p,55),-55)
				self.Forward = ang:Forward()
			else
				self.WeaponEnt = self.WeaponEnt.OwnerViewModel
			end
			--ang.p = math.max(math.min(ang.p,55),-55)
		else
			ang = self.WeaponEnt:GetOwner():EyeAngles()
			ang:Normalize()
			self.Forward = ang:Forward()
		end
	end

	self.Forward = self.Forward or data:GetNormal()
	self.Angle = self.Forward:Angle()
	self.Right = self.Angle:Right()
	self.vOffset = self.Position
	local dir = self.Forward
	local ownerent = self.WeaponEnt:GetOwner()

	if not IsValid(ownerent) then
		ownerent = LocalPlayer()
	end

	AddVel = ownerent:GetVelocity()
	self.vOffset = self.Position
	AddVel = AddVel * 0.05
	local dot = dir:GetNormalized():Dot(GetViewEntity():EyeAngles():Forward())
	local halofac = math.abs(dot)
	local epos = ownerent:EyePos()
	local dlight = DynamicLight(ownerent:EntIndex())

	if (dlight) then
		dlight.pos = epos + ownerent:EyeAngles():Forward() * self.vOffset:Distance(epos) --self.vOffset - ownerent:EyeAngles():Right() * 5 + 1.05 * ownerent:GetVelocity() * FrameTime()
		dlight.r = self.Color.r
		dlight.g = self.Color.g
		dlight.b = self.Color.b
		dlight.brightness = 4.5
		dlight.decay = 200 / self.Life
		dlight.size = self.FlashSize * 96
		dlight.dietime = CurTime() + self.Life
	end

	self.Dist = self.vOffset:Distance(epos)
	self.DLight = dlight
	self.DieTime = CurTime() + self.Life
	self.OwnerEnt = ownerent
	local emitter = ParticleEmitter(self.vOffset)
	local sval = 1 - math.random(0, 1) * 2

	if self.WeaponEnt.XTick == nil then
		self.WeaponEnt.XTick = 0
	end

	self.WeaponEnt.XTick = 1 - self.WeaponEnt.XTick

	if self.WeaponEnt.XTick == 1 and self.XFlashSize > 0 then
		local particle = emitter:Add(self.ColorSprites and "effects/muzzleflashx_nemole_w" or "effects/muzzleflashx_nemole", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 4 * self.XFlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life / 2)
			particle:SetStartAlpha(math.Rand(200, 255))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 8 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(3 * (halofac * 0.8 + 0.2) * self.XFlashSize)
			particle:SetEndSize(15 * (halofac * 0.8 + 0.2) * self.XFlashSize)
			local r = math.Rand(-10, 10) * 3.14 / 180
			particle:SetRoll(r)
			particle:SetRollDelta(r / 5)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
			particle:SetPos(vector_origin)
		end
		--particle:SetStartSize( 8 * (halofac*0.8+0.2), 0, 1)
		--particle:SetEndSize( 0 )
	elseif self.XFlashSize > 0 then
		local particle = emitter:Add(self.ColorSprites and "effects/muzzleflashx_nemole_w" or "effects/muzzleflashx_nemole", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 4 * self.FlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life / 2)
			particle:SetStartAlpha(math.Rand(200, 255))
			particle:SetEndAlpha(0)
			particle:SetStartSize(2 * (halofac * 0.8 + 0.2) * 0.3 * self.FlashSize)
			particle:SetEndSize(6 * (halofac * 0.8 + 0.2) * 0.3 * self.FlashSize)
			local r = math.Rand(-10, 10) * 3.14 / 180
			particle:SetRoll(r)
			particle:SetRollDelta(r / 5)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
			particle:SetPos(vector_origin)
		end
	end

	local flashCount = math.Round(self.FlashSize * 8)

	for i = 1, flashCount do
		local particle = emitter:Add(self.ColorSprites and "effects/scotchmuzzleflashw" or "effects/scotchmuzzleflash4", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 300 * (0.2 + (i / flashCount) * 0.8) * self.FlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 0.75)
			particle:SetStartAlpha(math.Rand(128, 255))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			local szsc = 1 + (flashCount - i) * math.pow(1 / flashCount * 0.9,0.8)
			particle:SetStartSize(1.25 * math.Rand(1, 1.5) * szsc * self.FlashSize)
			particle:SetEndSize(6 * math.Rand(0.75, 1) * szsc * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(15, 30)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	for _ = 1, flashCount do
		local particle = emitter:Add("effects/scotchmuzzleflash1", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 6 * self.FlashSize + 1.05 * AddVel)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 1)
			particle:SetStartAlpha(math.Rand(40, 140))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(2 * math.Rand(1, 1.5) * self.FlashSize)
			particle:SetEndSize(20 * math.Rand(0.5, 1) * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(30, 60)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			--TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	local glowCount = math.ceil(self.FlashSize * 3)

	for i = 1, glowCount do
		local particle = emitter:Add("effects/scotchmuzzleflash1", self.vOffset + dir * 0.9 * i)

		if (particle) then
			--particle:SetVelocity(dir * 32 )
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 0.75)
			particle:SetStartAlpha(255 * (1 - halofac))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(math.max(12 - 12 / glowCount * i * 0.5, 1) * 0.2 * self.FlashSize)
			particle:SetEndSize(math.max(12 - 12 / glowCount * i * 0.5, 1) * 0.6 * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(15, 30)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	if TFA.GetMZFSmokeEnabled() then
		local smokeCount = math.ceil(self.SmokeSize * 6)

		for _ = 0, smokeCount do
			local particle = emitter:Add("particles/smokey", self.vOffset + dir * math.Rand(3, 14))

			if (particle) then
				particle:SetVelocity(VectorRand() * 10 * self.SmokeSize + dir * math.Rand(35, 50) * self.SmokeSize + 1.05 * AddVel)
				particle:SetDieTime(math.Rand(0.6, 1) * self.Life * 6)
				particle:SetStartAlpha(math.Rand(12, 24))
				particle:SetEndAlpha(0)
				particle:SetStartSize(math.Rand(5, 7) * self.SmokeSize)
				particle:SetEndSize(math.Rand(15, 20) * self.SmokeSize)
				particle:SetRoll(math.rad(math.Rand(0, 360)))
				particle:SetRollDelta(math.Rand(-0.8, 0.8))
				particle:SetLighting(true)
				particle:SetAirResistance(20)
				particle:SetGravity(Vector(0, 0, 60))
				particle:SetColor(255, 255, 255)
			end
		end
	end

	local sparkcount = math.Round(math.random(8, 12) * self.SparkSize)

	for _ = 0, sparkcount do
		local particle = emitter:Add("effects/yellowflare", self.Position)

		if (particle) then
			particle:SetVelocity( VectorRand() * 30 * self.SparkSize)
			particle:SetVelocity(particle:GetVelocity() + 1.15 * AddVel )
			particle:SetVelocity( particle:GetVelocity() + dir * math.Rand(80, 100) * (1-math.abs(math.max(particle:GetVelocity():GetNormalized():Dot(-dir),0))) * self.SparkSize )
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * math.Rand(0.9,1.1))
			particle:SetStartAlpha(255)
			particle:SetEndAlpha(0)
			particle:SetStartSize(0.6)
			particle:SetEndSize(1)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetGravity(vector_origin)
			particle:SetAirResistance(1)
			particle:SetStartLength(0.1)
			particle:SetEndLength(0.05)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, math.random(192, 225), math.random(140, 192))
			end

			particle:SetVelocityScale(true)
			local sl = self.SparkSize

			particle:SetThinkFunction(function(pa)
				math.randomseed(SysTime())
				local spd = pa:GetVelocity():Length()*12
				pa.ranvel = pa.ranvel or VectorRand() * spd
				pa.ranvel:Add(VectorRand() * spd * math.sqrt(FrameTime()))
				pa:SetVelocity(pa:GetVelocity() + pa.ranvel * sl * FrameTime() )
				pa:SetNextThink(CurTime())
			end)

			particle:SetNextThink(CurTime() + 0.01)
		end
	end

	if TFA.GetGasEnabled() then
		local particle = emitter:Add("sprites/heatwave", self.vOffset + dir*2)

		if (particle) then
			particle:SetVelocity(dir * 25 * self.HeatSize + 1.05 * AddVel)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life)
			particle:SetStartAlpha(math.Rand(200, 225))
			particle:SetEndAlpha(0)
			particle:SetStartSize(math.Rand(3, 5) * self.HeatSize)
			particle:SetEndSize(math.Rand(8, 12) * self.HeatSize)
			particle:SetRoll(math.Rand(0, 360))
			particle:SetRollDelta(math.Rand(-2, 2))
			particle:SetAirResistance(5)
			particle:SetGravity(Vector(0, 0, 40))
			particle:SetColor(255, 255, 255)
		end
	end

	emitter:Finish()
end

function EFFECT:Think()
	if CurTime() > (self.DieTime or 0) then
		return false
	elseif self.DLight and IsValid(self.OwnerEnt) then
		self.DLight.pos = self.OwnerEnt:EyePos() + self.OwnerEnt:EyeAngles():Forward() * self.Dist
	end

	return true
end

function EFFECT:Render()
end
--addons/tfa_base/lua/effects/tfa_muzzleflash_sniper/init.lua:
include("tfa/muzzleflash_base.lua")

EFFECT.Life = 0.125
EFFECT.XFlashSize = 1.5
EFFECT.FlashSize = 1.2
EFFECT.SmokeSize = 2
EFFECT.SparkSize = 1.3
EFFECT.HeatSize = 2
EFFECT.Color = Color(255, 225, 128)
EFFECT.ColorSprites = false

--addons/tfa_base/lua/effects/tfa_shell_legacy/init.lua:
local vector_origin = Vector()

function EFFECT:Init(data)
	self.WeaponEnt = data:GetEntity()
	if not IsValid(self.WeaponEnt) then return end
	self.WeaponEntOG = self.WeaponEnt
	self.Attachment = data:GetAttachment()
	self.Dir = data:GetNormal()
	local owent = self.WeaponEnt:GetOwner()

	if not IsValid(owent) then
		owent = self.WeaponEnt:GetParent()
	end

	if IsValid(owent) and owent:IsPlayer() then
		if owent ~= LocalPlayer() or owent:ShouldDrawLocalPlayer() then
			self.WeaponEnt = owent:GetActiveWeapon()
			if not IsValid(self.WeaponEnt) then return end
		else
			local theirweapon = self.WeaponEnt
			self.WeaponEnt = self.WeaponEnt.OwnerViewModel

			if IsValid(theirweapon) and theirweapon.ViewModelFlip or theirweapon.ViewModelFlipped then
				self.Flipped = true
			end

			if not IsValid(self.WeaponEnt) then return end
		end
	end

	if IsValid(self.WeaponEntOG) and self.WeaponEntOG.ShellAttachment then
		self.Attachment = self.WeaponEnt:LookupAttachment(self.WeaponEntOG.ShellAttachment)

		if not self.Attachment or self.Attachment <= 0 then
			self.Attachment = 2
		end

		if self.WeaponEntOG:GetStatL("IsAkimbo") then
			self.Attachment = 4 - self.WeaponEntOG:GetAnimCycle()
		end

		if self.WeaponEntOG.ShellAttachmentRaw then
			self.Attachment = self.WeaponEntOG.ShellAttachmentRaw
		end
	end

	local angpos = self.WeaponEnt:GetAttachment(self.Attachment)

	if not angpos or not angpos.Pos then
		angpos = {
			Pos = vector_origin,
			Ang = angle_zero
		}
	end

	if self.Flipped then
		local tmpang = (self.Dir or angpos.Ang:Forward()):Angle()
		local localang = self.WeaponEnt:WorldToLocalAngles(tmpang)
		localang.y = localang.y + 180
		localang = self.WeaponEnt:LocalToWorldAngles(localang)
		--localang:RotateAroundAxis(localang:Up(),180)
		--tmpang:RotateAroundAxis(tmpang:Up(),180)
		self.Dir = localang:Forward()
	end

	-- Keep the start and end Pos - we're going to interpolate between them
	self.Pos = self:GetTracerShootPos(angpos.Pos, self.WeaponEnt, self.Attachment)
	self.Norm = angpos.Ang:Forward() --angpos.Ang:Forward()
	--print(self.Norm)
	self.Magnitude = data:GetMagnitude()
	self.Scale = data:GetScale()
	local fx = EffectData()
	fx:SetOrigin(self.Pos)
	fx:SetStart(self.Pos)
	fx:SetEntity(self.WeaponEnt)
	fx:SetAttachment(self.Attachment)
	fx:SetNormal(self.Norm)
	fx:SetAngles(self.Norm:Angle())
	fx:SetScale(self.Scale)
	fx:SetMagnitude(self.Magnitude)
	local se = (self.WeaponEntOG.LuaShellEffect or self.WeaponEntOG.Blowback_Shell_Effect) or "ShellEject"
	util.Effect(se, fx)
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end
--addons/tfa_base/lua/effects/tfa_shelleject_smoke/init.lua:
local vector_origin = Vector()

EFFECT.SmokeParticle = "tfa_ins2_shell_eject"
local upVec = Vector(0, 0, 1)

function EFFECT:ComputeSmokeLighting(part, pos)
	if not IsValid(part) then return end
	local licht = render.ComputeLighting(pos + upVec * 2, upVec)
	local lichtFloat = math.Clamp((licht.r + licht.g + licht.b) / 3, 0, TFA.Particles.SmokeLightingClamp) / TFA.Particles.SmokeLightingClamp
	local lichtFinal = LerpVector(lichtFloat, TFA.Particles.SmokeLightingMin, TFA.Particles.SmokeLightingMax)
	lichtFinal.x = math.sqrt(math.Clamp(lichtFinal.x-0.2,0,0.8)) / 0.8
	lichtFinal.y = math.sqrt(math.Clamp(lichtFinal.y-0.2,0,0.8)) / 0.8
	lichtFinal.z = math.sqrt(math.Clamp(lichtFinal.z-0.2,0,0.8)) / 0.8
	part:SetControlPoint(1, lichtFinal)
end

function EFFECT:Init(data)
	if not TFA.GetEJSmokeEnabled() then return end
	self.WeaponEnt = data:GetEntity()
	if not IsValid(self.WeaponEnt) then return end
	self.WeaponEntOG = self.WeaponEnt
	self.Attachment = data:GetAttachment()
	local owent = self.WeaponEnt:GetOwner()

	if not IsValid(owent) then
		owent = self.WeaponEnt:GetParent()
	end

	if IsValid(owent) and owent:IsPlayer() then
		if owent ~= LocalPlayer() or owent:ShouldDrawLocalPlayer() then
			self.WeaponEnt = owent:GetActiveWeapon()
			if not IsValid(self.WeaponEnt) then return end
		else
			local theirweapon = owent:GetActiveWeapon()
			self.WeaponEnt = self.WeaponEnt.OwnerViewModel

			if IsValid(theirweapon) and theirweapon.ViewModelFlip or theirweapon.ViewModelFlipped then
				self.Flipped = true
			end

			if not IsValid(self.WeaponEnt) then return end
		end
	end

	if IsValid(self.WeaponEntOG) and self.WeaponEntOG.ShellAttachment then
		self.Attachment = self.WeaponEnt:LookupAttachment(self.WeaponEntOG.ShellAttachment)

		if not self.Attachment or self.Attachment <= 0 then
			self.Attachment = 2
		end

		if self.WeaponEntOG:GetStatL("IsAkimbo") then
			self.Attachment = 3 + self.WeaponEntOG:GetAnimCycle()
		end

		if self.WeaponEntOG.ShellAttachmentRaw then
			self.Attachment = self.WeaponEntOG.ShellAttachmentRaw
		end
	end

	local angpos = self.WeaponEnt:GetAttachment(self.Attachment)

	if not angpos or not angpos.Pos then
		angpos = {
			Pos = vector_origin,
			Ang = angle_zero
		}
	end

	local PCFSmoke = CreateParticleSystem(self.WeaponEnt, self.SmokeParticle, PATTACH_POINT_FOLLOW, self.Attachment)

	if IsValid(PCFSmoke) then
		self:ComputeSmokeLighting(PCFSmoke, angpos.Pos)
		PCFSmoke:StartEmission()

		timer.Simple(0.2, function()
			if IsValid(PCFSmoke) then
				PCFSmoke:StopEmission(false,true)
			end
		end)
	end
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end
--addons/wos-alcs-darkaspp/lua/effects/wos_alcs_bloodtouch/init.lua:

PrecacheParticleSystem( "[2]gushing_blood" )

function EFFECT:Init( data )

	local ent = data:GetEntity()
	local time = data:GetRadius()
	
	self.Particle = CreateParticleSystem( ent, "[2]gushing_blood", PATTACH_ABSORIGIN_FOLLOW, nil, ent:GetUp()*30 ) 
	self.LifeTime = CurTime() + time
	
end

function EFFECT:Think()
	if self.LifeTime < CurTime() then
		self.Particle:StopEmission( false, true )
		return false
	end
	return true
end

function EFFECT:Render()
end

--addons/wos-alcs-darkaspp/lua/effects/wos_alcs_diamondbullet/init.lua:

EFFECT.Mat = Material( "trails/tube" )

function EFFECT:Init( data )

	self.Position = data:GetStart()
	self.WeaponEnt = data:GetEntity()
	self.Attachment = data:GetAttachment()
	
	self.StartPos = self.Position
	self.EndPos = data:GetOrigin()
	
	local dir = self.StartPos - self.EndPos
	dir:Normalize()
	
	self.Dir = dir
	
	self.Entity:SetRenderBoundsWS( self.StartPos, self.EndPos )
	
	self.Alpha = 100
	self.Color = Color( 0, 255, 255, self.Alpha )

end

function EFFECT:Think( )

	self.Entity:SetRenderBoundsWS( self.StartPos, self.EndPos )

	self.Alpha = self.Alpha - FrameTime() * 200
	self.Color = Color( 255, 255, 255, self.Alpha )
	
	return self.Alpha > 0

end

function EFFECT:Render( )

	if self.Alpha < 1 then return end
	
	if ( self.Alpha < 1 ) then return end

	self.Length = (self.StartPos - self.EndPos):Length()
		
	local texcoord = CurTime() * -0.2
	
	for i = 1, 10 do
	
		render.SetMaterial( self.Mat )
		
		texcoord = texcoord + i * 0.05 * texcoord
	
		render.DrawBeam( self.StartPos, self.EndPos, 1,	texcoord, texcoord + (self.Length / (128 + self.Alpha)), self.Color )
							
	end

end

--addons/wos-alcs-darkaspp/lua/effects/wos_alcs_electricslam/init.lua:

PrecacheParticleSystem( "[4]arcs_electric_1" )

function EFFECT:Init( data )

	local dir = data:GetStart()
	local ent = data:GetEntity()
	self.EndPos = data:GetOrigin()
	
	self:SetPos( ent:GetPos() )
	
	self.Particle1 = CreateParticleSystem( self, "[4]arcs_electric_1", PATTACH_ABSORIGIN_FOLLOW, 0, dir*-100 )
	self.Particle2 = CreateParticleSystem( self, "[4]arcs_electric_1", PATTACH_ABSORIGIN_FOLLOW, 0, dir*100 )
	self.Particle3 = CreateParticleSystem( self, "[4]arcs_electric_1", PATTACH_ABSORIGIN_FOLLOW )
	self.LifeTime = CurTime() + 0.75

	self.Increments = ( self.EndPos - self:GetPos() ) / ( self.LifeTime - CurTime() )
	
end

function EFFECT:Think()
	self:SetPos( self:GetPos() + self.Increments )
	if self.LifeTime < CurTime() then
		self.Particle1:StopEmission( false, true )
		self.Particle2:StopEmission( false, true )
		self.Particle3:StopEmission( false, true )
		return false
	end
	return true
end

function EFFECT:Render()
end

--addons/wos-alcs-darkaspp/lua/effects/wos_alcs_energyshell/init.lua:

PrecacheParticleSystem( "[8]magic_portal" )

function EFFECT:Init( data )

	local ent = data:GetEntity()
	local time = data:GetScale()
	
	self.Particle = CreateParticleSystem( ent, "[8]magic_portal", PATTACH_POINT_FOLLOW, ent:LookupAttachment( "eyes" ) ) 
	self.LifeTime = CurTime() + time
	
end

function EFFECT:Think()
	if self.LifeTime < CurTime() then
		self.Particle:StopEmission( false, true )
		return false
	end
	return true
end

function EFFECT:Render()
end

--addons/wos-alcs-darkaspp/lua/effects/wos_alcs_lightstream/init.lua:

PrecacheParticleSystem( "[4]electric_beam" )

function EFFECT:Init( data )

	local ent = data:GetEntity()
	local vec = data:GetAngles()
	
	self.Particle = CreateParticleSystem( ent, "[4]electric_beam", PATTACH_POINT, ent:LookupAttachment( "anim_attachment_LH" ) ) 
	self.Particle:SetControlPointOrientation( 0, vec:Forward(), vec:Right(), vec:Up() )
	self.LifeTime = CurTime() + 0.25
	
end

function EFFECT:Think()
	if self.LifeTime < CurTime() then
		self.Particle:StopEmission( false, true )
		return false
	end
	return true
end

function EFFECT:Render()
end

--addons/wos-grandmaster-einf/lua/effects/wos_tesla_coil_lightning.lua:

local function GetRandomPositionInBox( mins, maxs, ang )
	return ang:Up() * math.random( mins.z, maxs.z ) + ang:Right() * math.random( mins.y, maxs.y ) + ang:Forward() * math.random( mins.x, maxs.x )
end

local function GenerateLighting( from, to, deviations, power )
	local start = from
	if ( isentity( start ) ) then start = from:GetPos() end
	local endpos = to:GetPos()

	--render.DrawWireframeBox( start, Angle(0, 0, 0),from:OBBMins(), from:OBBMaxs(), Color(255, 0, 0), true )
	--render.DrawWireframeBox( start, to:GetAngles(),from:OBBMins(), from:OBBMaxs(), Color(0, 255, 0), true )

	--start = start + GetRandomPositionInBox( from:OBBMins(), from:OBBMaxs(), from:GetAngles() )
	endpos = endpos + GetRandomPositionInBox( to:OBBMins(), to:OBBMaxs(), to:GetAngles() )

	local right = (start - endpos):Angle():Right()
	local up = (start - endpos):Angle():Up()
	local segments = {
		{ start, endpos }
	}
	for i = 0, power do
		local newsegs = {}
		for id, seg in pairs( segments ) do
			local mid = Vector( (seg[1].x + seg[2].x) / 2, (seg[1].y + seg[2].y) / 2, (seg[1].z + seg[2].z) / 2 )
			local offsetpos = mid + right * math.random( -deviations, deviations ) + up * math.random( -deviations, deviations )
			table.insert( newsegs, {seg[1], offsetpos} )
			table.insert( newsegs, {offsetpos, seg[2]} )
		end
		segments = newsegs
	end
	return segments
end

local function GenerateLightingSegs( from, to, deviations, segs )
	local start = from
	if ( isentity( start ) ) then start = from:GetPos() end
	local endpos = to:GetPos()

	--render.DrawWireframeBox( start, Angle(0, 0, 0),from:OBBMins(), from:OBBMaxs(), Color(255, 0, 0), true )
	--render.DrawWireframeBox( start, to:GetAngles(),from:OBBMins(), from:OBBMaxs(), Color(0, 255, 0), true )

	--start = start + GetRandomPositionInBox( from:OBBMins(), from:OBBMaxs(), from:GetAngles() )
	endpos = endpos + GetRandomPositionInBox( to:OBBMins(), to:OBBMaxs(), to:GetAngles() )

	local right = (start - endpos):Angle():Right()
	local up = (start - endpos):Angle():Up()
	local fwd = (start - endpos):Angle():Forward()
	local step = (1 / segs) * start:Distance( endpos )

	local lastpos = start
	local segments = {}
	for i = 1, segs do
		local a = lastpos - fwd * step
		table.insert( segments, { lastpos, a } )
		lastpos = a
	end

	for k, v in pairs( segments ) do
		if ( k == 1 || k == #segments ) then continue end

		segments[ k ][ 1 ] = segments[ k ][ 1 ] + right * math.random( -deviations, deviations ) + up * math.random( -deviations, deviations )
		segments[ k - 1 ][ 2 ] = segments[ k ][ 1 ]
	end

	for k, v in pairs( segments ) do
		if ( k == 1 || k == #segments ) then continue end

		if ( math.random( 0, 100 ) > 75 ) then
			local dir = AngleRand():Forward()
			table.insert( segments, { segments[ k ][ 1 ], segments[ k ][ 1 ] + dir * ( step * math.Rand( 0.2, 0.6 ) ) } )
		end
	end

	return segments
end

local mats = {
	(Material( "cable/smoke" )),
	/*(Material( "cable/hydra" )),
	(Material( "cable/redlaser" )),
	(Material( "cable/crystal_beam1" )),
	(Material( "cable/physbeam" )),
	(Material( "cable/smoke" )),
	(Material( "cable/xbeam" )),*/
}

local segments = {}
--local n = 0
local tiem = .2
hook.Add( "PostDrawTranslucentRenderables", "wOS.Lightsabers.DrawCoilLightning", function()
	--if ( #segments < 1 || n < CurTime() ) then
		--
		/*for i = 0, 1 do
			table.insert( segments, {
				segs = GenerateLighting( table.Random( ents.FindByClass( "prop_physics" ) ), table.Random( ents.FindByClass( "prop_physics" ) ), math.random( 10, 20 ), 3 ),
				mat = table.Random( mats ),
				time = CurTime() + tiem,
				w = math.random( 20, 50 )
			} )
		end*/
		--n = CurTime() + .01
	--end

	for id, t in pairs( segments ) do
		if ( t.time < CurTime() ) then table.remove( segments, id ) continue end
		render.SetMaterial( t.mat )
		for id, seg in pairs( t.segs ) do
			render.DrawBeam( seg[1], seg[2], ( math.max( t.startpos:Distance( t.endpos ) - seg[1]:Distance( t.endpos ), 20) / ( t.startpos:Distance( t.endpos ) ) * t.w ) * ( (t.time - CurTime() ) / tiem ), 0, seg[1]:Distance( seg[2] ) / 25, Color( 255, 0, 255 ) )
			--render.DrawBeam( seg[1], seg[2], (id / #t.segs * t.w ) * ((t.time - CurTime()) / tiem), 0, seg[1]:Distance( seg[2] ) / 25, Color( 255, 255, 255 ) )
		end
	end
end )


function EFFECT:Init( data )
	local pos = data:GetOrigin()
	local ent = data:GetEntity()

	if ( !IsValid( ent ) ) then return end

	table.insert( segments, {
		--segs = GenerateLighting( pos, ent, math.random( 10, 20 ), 3 ),
		segs = GenerateLightingSegs( pos, ent, math.random( 10, 20 ), pos:Distance( ent:GetPos() ) / 48 ), --math.random( 5, 10 ) ),
		mat = table.Random( mats ),
		time = CurTime() + tiem,
		w = math.random( 20, 50 ),
		startpos = pos,
		endpos = ent:GetPos()
	} )
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
	/*for id, t in pairs( segments ) do
		if (t.time < CurTime() ) then table.remove( segments, id ) continue end
		render.SetMaterial( t.mat )
		for id, seg in pairs( t.segs ) do
			render.DrawBeam( seg[1], seg[2], (id / #t.segs * t.w ) * ((t.time - CurTime()) / tiem), 0, seg[1]:Distance( seg[2] ) / 25, Color( 255, 255, 255 ) )
		end
	end*/
end

--gamemodes/egmrp/gamemode/core/localization/localization/de.lua:
-- Shared
Localization["shared.accept"] = "Annehmen"
Localization["shared.deny"] = "Ablehnen"
Localization["shared.error"] = "Fehler"
Localization["shared.please_wait"] = "Bitte warten"
Localization["shared.unknown_error"] = "Unbekannter Fehler"
Localization["shared.success"] = "Erfolg"
Localization["com"] = "Spieler"
Localization["shared.name"] = "Name"
Localization["shared.faction"] = "Fraktion"
Localization["shared.rank"] = "Rang"
Localization["shared.delete"] = "Löschen"
Localization["shared.team"] = "Team"
Localization["shared.normal"] = "Normal"
Localization["shared.searching"] = "Suchen..."
Localization["shared.loading_content"] = "Inhalt wird geladen..."
Localization["shared.no_results"] = "Keine Ergebnisse"
Localization["shared.are_you_sure"] = "Bist du dir sicher?"
Localization["shared.invalid_property"] = "Ungültiges Property"
Localization["shared.offline_error"] = "Es gab ein Problem beim Verarbeiten deiner Anfrage. Das Menü wurde geschlossen."
Localization["shared.invalid_type"] = "Ungültiger Datentyp"
Localization["shared.warning"] = "Achtung"
Localization["shared.access_denied"] = "Zugriff verweigert"
Localization["shared.time"] = "Zeitpunkt"
Localization["shared.edit"] = "Bearbeiten"
Localization["shared.view"] = "Anschauen"
Localization["shared.abort"] = "Abbrechen"
Localization["shared.back"] = "Zurück"
Localization["shared.apply"] = "Übernehmen"
Localization["shared.date_time"] = "%d.%m.%Y - %H:%M:%S"
Localization["shared.next"] = "Weiter"
Localization["restart.time"] = "[$1] Der Server ist seit $2 Stunden online. Die Map sollte neugeladen werden."
Localization["restart.warning1"] = "Die Map wird in einer Stunde automatisch neugeladen."
Localization["restart.warning2"] = "Die Map wird in einer halben Stunde automatisch neugeladen."
Localization["restart.warning3"] = "Die Map wird in einer viertel Stunde automatisch neugeladen."
Localization["restart.warning4"] = "Die Map wird in 10 Minuten automatisch neugeladen."
Localization["restart.warning5"] = "Die Map wird in 5 Minuten automatisch neugeladen."
Localization["restart.warning6"] = "Die Map wird in 1 Minute automatisch neugeladen."
-- Character
Localization["character.properties"] = "Charakterproperties"
Localization["character.name_description"] = "Der Name des Charakters"
Localization["character.model_name"] = "Model"
Localization["character.model_description"] = "Das Model des Charakters"
Localization["character.model_missing_title"] = "Models fehlen"
Localization["character.model_missing_text"] = "Der Rang/ Die Fraktion\nhat keine Models zugewiesen"
Localization["character.slotType_name"] = "Slottyp"
Localization["character.slotType_description"] = "Der Typ des Rangslots"
Localization["character.invite"] = "Einladung"
Localization["character.confirm_invite"] = "Du wurdest zu folgendem Rang eingeladen: $1 $2"
Localization["character.package_name"] = "Charakterdaten"
Localization["character.creation"] = "Charaktererstellung"
Localization["character.faction_selection"] = "Fraktionsauswahl"
Localization["character.faction_description"] = "Fraktionsbeschreibung:"
Localization["character.rank_selection"] = "Rangauswahl"
Localization["character.rank_description"] = "Rangbeschreibung:"
Localization["character.create"] = "Charakter erstellen"
Localization["character.creation_process"] = "Der Charakter wird erstellt ..."
Localization["character.not_rank_selected"] = "Kein Rang ausgewählt"
Localization["character.creation_success"] = "Der Charakter wurde erfolgreich erstellt."
Localization["character.creation_error"] = "Der Charakter konnte nicht erstellt werden."
Localization["character.selection"] = "Charakterauswahl"
Localization["character.multiple_errors"] = "Mehrere Errors! Überprüfe deine Konsole!"
Localization["character.selection_id"] = "Id:"
Localization["character.delete_warning"] = "Charakter wird unwiderruflich gelöscht!"
Localization["character.selection_play"] = "Spielen"
Localization["character.selection_continue"] = "Weiterspielen"
Localization["character.keybinds_cat_rp"] = "RP-Binds"
Localization["character.keybinds_id"] = "ID vorzeigen"
Localization["character.keybinds_roll"] = "Würfeln"
Localization["character.manager"] = "Charakterverwaltung"
Localization["character.nofilter"] = "Kein Filter"
Localization["character.faction_invalid"] = "Ungültige Fraktion"
Localization["character.none_online"] = "Keine Charaktere online"
Localization["character.load_offline"] = "Charaktere von offline Spielern laden"
Localization["character.deletion_process"] = "Der Charakter wird gelöscht ..."
Localization["character.save"] = "Charakter speichern"
Localization["character.saving_process"] = "Der Charakter wird gespeichert..."
Localization["character.display_owner"] = "Besitzer anzeigen"
Localization["character.set_faction"] = "Fraktion setzen"
Localization["character.set_rank"] = "Rang setzen"
Localization["character.dossier"] = "Akte"
Localization["character.kick"] = "Aus der Fraktion werfen"
Localization["character.deletion_successfull"] = "Der Charakter wurde erfolgreich gelöscht."
Localization["character.deletion_error"] = "Der Charakter konnte nicht gelöscht werden."
Localization["character.saving_successfull"] = "Der Charakter wurde erfolgreich gespeichert."
Localization["character.saving_error"] = "Der Charakter konnte nicht gespeichert werden."
Localization["character.invalid"] = "Ungültiger Charakter"
Localization["character.created_on"] = "Erstellt am:\n"
Localization["character.lastplayed_at"] = "Zuletzt gespielt am:\n"
Localization["character.jailtime"] = "Strafminuten:"
Localization["character.editing"] = "Charakter - Editierung"
Localization["character.here_edit_faction"] = "Hier kannst du die Fraktion des Charakters bearbeiten."
Localization["character.select_faction"] = "Fraktion auswählen"
Localization["character.here_edit_rank"] = "Hier kannst du den Rang des Charakters bearbeiten."
Localization["character.select_rank"] = "Rang auswählen"
Localization["character.here_edit_rank_long"] = "Hier kannst du den Rang des Charakters bearbeiten. Dies beinhaltet die Beförderung oder Degradierung innerhalb der Fraktion."
Localization["character.invite_to_faction"] = "In die Fraktion einladen"
Localization["character.invite"] = "Einladen"
Localization["character.promote_demote"] = "Befördern / Degradieren"
Localization["character.invalid_steamid"] = "Ungültige SteamID64"
Localization["character.invalid_rank_id"] = "Ungültige Rang Id"
Localization["character.invalid_rank"] = "Ungültiger Rang"
Localization["character.name_error"] = "Der Name muss mindestens aus 2 Zeichen und maximal aus 100 Zeichen bestehen"
Localization["character.model_error"] = "Dieses Model ist nicht für den Charakter verfügbar"
Localization["character.invalid_slottype"] = "Ungültiger Slottyp"
Localization["character"] = "Charakter"
Localization["character.main_char"] = "Hauptcharakter"
Localization["character.side_char"] = "Nebencharakter"
Localization["character.no_slot"] = "Kein Slot"
Localization["character.event_char"] = "Eventcharakter"
Localization["character.max_character_count"] = "Maximale Charakteranzahl überschritten"
Localization["character.max_character_count_dynamic"] = "Maximale $1anzahl überschritten"
Localization["character.deleted_spectator"] = "Dein Charakter wurde gelöscht und du wurdest zum Spectator gesetzt."
Localization["character.deleted_rank_spectator"] = "Der Rang deines Charakters wurde gelöscht und du wurdest zum Spectator gesetzt."
Localization["character.roll_bonus"] = "Roll-Bonus"
Localization["character.roll_bonus_description"] = "Bonus, mit dem der Rollwert addiert wird."
Localization["character.advert"] = "Funk"
Localization["character.ladvert"] = "LFunk"
Localization["character.encrypted"] = "[verschl.]"
Localization["character.roll1"] = "hat eine"
Localization["character.roll2"] = " gewürfelt."
Localization["character.plural"] = "Charaktere"
Localization["character.eventlog_created"] = "$1 ($2) hat folgenden Charakter erstellt: $3."
Localization["character.eventlog_edited"] = "$1 ($2) hat folgenden Charakter bearbeitet: $3."
Localization["character.eventlog_deleted"] = "$1 ($2) hat folgenden Charakter gelöscht: $3."
Localization["character.eventlog_switched"] = "$1 ($2) hat zu einem neuen Charakter gewechselt: $3"
Localization["character.eventlog_rank"] = "$1 ($2) ist nun $3"
Localization["character.eventlog_renamed"] = "$1 ($2)'s Charakter mit dem Namen $4 wurde in $3 umbenannt"
Localization["character.eventlog_offline_renamed"] = "$1's Charakter mit dem Namen $3 wurde in $2 umbenannt"
Localization["character.you_dead"] = "Du kannst deinen Charakter nicht wechseln während du tot bist."
Localization["character.meinfo"] = "Chat um Aktionen im Rollenspiel auszuführen\n"
Localization["character.advertinfo"] = "Chat um über längere Distanzen im Rollenspiel zu kommunizieren\n"
Localization["character.ladvertinfo"] = "Lokale Version vom Funk\n"
Localization["character.sadvertinfo"] = "Verschlüsselte Version vom Funk\n"
Localization["character.rollinfo"] = "Werfe einen 100-seitigen Würfel\n"
Localization["character.invalid_faction_id"] = "Unfültige Fraktions Id"
Localization["character.invalid_faction"] = "Fraktion existiert nicht"
Localization["character.invalid_model"] = "Ungültiges Model"
Localization["character.unavailable_model"] = "Model ist nicht Verfügbar"
Localization["character.invalid_owner"] = "Ungültiger Besitzer"
Localization["character.rank_not_available"] = "Rang nicht verfügbar"
Localization["character.kick_error"] = "Charakter konnte nicht geladen werden."
Localization["character.deleted_faction_spectator"] = "Charakter wurde gelöscht. Spieler als Beobachter gesetzt."
Localization["character.invalid_skin_id"] = "Ungültige SkinId"
Localization["character.unavailable_skin"] = "Skin nicht Verfügbar"
-- Chat
Localization["chat.hasjoined"] = "ist dem Spiel beigetreten."
Localization["chat.hasleft"] = "hat den Server verlassen: "
Localization["chat.changerange"] = "Sprachreichweite ändern"
Localization["chat.pm"] = "PM"
Localization["chat.voicerange"] = "Sprachreichweite"
Localization["chat.changedrange"] = "Du hast deine Sprachreichweite auf $1 geändert"
Localization["chat.whisper"] = "Flüstern"
Localization["chat.quiet"] = "Leise"
Localization["chat.shout"] = "Schreien"
Localization["chat.ooc"] = "OOC"
Localization["chat.looc"] = "LOOC"
Localization["chat.admin"] = "ADMIN"
Localization["chat.team"] = "Team"
Localization["chat.noplayerfound"] = "Es konnte kein Spieler klar identifiziert werden. Nutzung: /pm <SPIELER> <NACHRICHT>"
Localization["chat.nomessage"] = "Du musst eine Nachricht angeben. Nutzung: /pm <SPIELER> <NACHRICHT>"
Localization["chat.gooc"] = "GOOC"
Localization["chat.help"] = "Verfügbare Befehle:\n"
Localization["chat.help.header"] = "- $1:\n"
Localization["chat.help.alias"] = "Befehle: $1\n"
Localization["chat.oocinfo"] = "OOC Chat für den gesamten Server\n"
Localization["chat.loocinfo"] = "Lokale Version des OOC\n"
Localization["chat.itinfo"] = "Chat im RP zum Ausführen von Aktionen auf Objekten oder anderen Dingen\n"
Localization["chat.admininfo"] = "Administriver Chat für serverweite Ankündigungen\n"
Localization["chat.helpinfo"] = "Listet alle aktuellen Befehle und Chats auf\n"
Localization["chat.pminfo"] = "Sende eine direkte Nachricht an einen anderen Spieler"
-- Course
Localization["course.invalid_faction_id"] = "Unfültige Fraktions Id"
Localization["course.invalid_faction"] = "Fraktion existiert nicht"
Localization["course.invalid_name"] = "Der Name muss mindestens aus 3 Zeichen bestehen"
Localization["course.invalid_short"] = "Das Kürzel darf maximal 20 Zeichen lang sein"
Localization["course.id_no_table"] = "Fortbildung Ids sind keine Tabelle."
Localization["course.no_faction"] = "Ungülte Charakterfraktion"
Localization["course.not_valid"] = "Ungültige Fortbildung"
Localization["course.not_available"] = "Fortbildung nicht verfügbar"
Localization["course.new"] = "Neue Fortbildung"
Localization["course.duplicate"] = "Fortbildung duplizieren"
Localization["course.delete"] = "Fortbildung löschen"
Localization["course.delete_warning"] = "Fortbildung wird unwiederuflich gelöscht!"
Localization["course.add"] = "Fortbildung hinzufügen"
Localization["course.save"] = "Fortbildung speichern"
Localization["course.name"] = "Name"
Localization["course.name_description"] = "Der Name der Fortbildung"
Localization["course.short"] = "Kürzel"
Localization["course.short_description"] = "Der Kürzel der Fortbidlung"
Localization["course.isPrefix"] = "Prefix / Suffix"
Localization["course.isPrefix_description"] = "Soll der Kürzel vor oder nach dem Rang angezeigt werden?"
Localization["course.isPrefix_yes"] = "Prefix"
Localization["course.isPrefix_no"] = "Suffix"
Localization["course.shortOnName"] = "Kürzel an Name anzeigen"
Localization["course.shortOnName_description"] = "Soll der Kürzel am Rangnamen angezeigt werden?"
Localization["course.shortOnPrefix"] = "Kürzel an Prefix anzeigen"
Localization["course.shortOnPrefix_description"] = "Soll der Kürzel am Rangprefix angezeigt werden?"
Localization["course.inherit"] = "Fortbildung Vererben?"
Localization["course.inherit_description"] = "Soll diese Fortbildung an andere Fraktion vererbt werden?"
Localization["course.character"] = "Fortbildungen"
Localization["course.character_description"] = "Fortbildungen des Charakters"
Localization["course.equipment"] = "Fortbildungs-Whitelist"
Localization["course.equipment_description"] = "Liste von Kursen, die zur Vergabe der Aurüstung nötig sind."
Localization["course.package"] = "Fortbildungsdaten"
Localization["course.invite"] = "Fortbildung - Vergeben"
-- Deathsystem
Localization["deathsystem.respawnready"] = "Bereit zum Respawn"
Localization["deathsystem.unconscious"] = "Du bist Ohnmächtig!"
Localization["deathsystem.dead"] = "Du bist tot!"
Localization["deathsystem.respawn"] = "Respawn"
Localization["deathsystem.revive_scoreboard"] = "Wiederbeleben"
Localization["deathsystem.forcerespawn"] = "Du hast $1 wiederbelebt."
Localization["deathsystem.gotrespawned"] = "Du wurdest von $1 wiederbelebt."
Localization["deathsystem.stunned"] = "Du wurdest betäubt!"
Localization["deathsystem.stun"] = "Betäubt das Ziel!"
Localization["deathsystem.kill"] = "Tötet das Ziel!"
Localization["deathsystem.revive"] = "Wiederbelebt das Ziel!"
-- Eventlog
Localization["eventlog.access_denied"] = "Du hast keinen Zugriff auf die Logs"
Localization["eventlog.title"] = "Logs"
Localization["eventlog.events"] = "Events"
Localization["eventlog.loading"] = "Events werden geladen..."
Localization["eventlog.no_events"] = "Keine Events vorhanden"
Localization["eventlog.log_entry"] = "Log Eintrag"
Localization["eventlog.copy"] = "Der Logeintrag wurde kopiert"
Localization["eventlog.loading_entries"] = "Einträge werden geladen..."
Localization["eventlog.no_entries"] = "Keine Einträge vorhanden"
Localization["eventlog.cat_spawn"] = "Objektspawn"
Localization["eventlog.spawn_vehicle"] = "$1 ($2) hat ein Fahrzeug gespawnt: '$3'."
Localization["eventlog.spawn_swep"] = "$1 ($2) hat ein SWEP gespawnt: '$3'."
Localization["eventlog.spawn_sent"] = "$1 ($2) hat eine Scripted Entity gespawnt: '$3'."
Localization["eventlog.spawn_ragdoll"] = "$1 ($2) hat ein Ragdoll gespawnt. Model: '$3'."
Localization["eventlog.spawn_prop"] = "$1 ($2) hat ein Prop gespawnt: '$3'."
Localization["eventlog.spawn_npc"] = "$1 ($2) hat einen NPC gespawnt: '$3'."
Localization["eventlog.spawn_effect"] = "$1 ($2) hat einen Effect gespawnt: '$3'."
Localization["eventlog.cat_toolgun"] = "Toolgun"
Localization["eventlog.use_tool"] = "$1 ($2) hat versucht das Tool '$3' zu benutzen"
Localization["eventlog.ulx_neutral"] = "$1 ($2) hat den ULX-Command '$3' benutzt."
Localization["eventlog.ulx_personal"] = "$1 ($2) hat den ULX-Command '$3 $4' benutzt."
Localization["eventlog.serverguard_console"] = "Die Konsole hat den Befehl $1 mit den Argumenten $2 ausgeführt"
Localization["eventlog.serverguard_args"] = "$1 ($2) hat den Befehl $3 mit den Argumenten $4 ausgeführt"
Localization["eventlog.serverguard_no_args"] = "$1 ($2) hat den Befehl $3 ausgeführt"
Localization["eventlog.cat_admin"] = "Admin"
-- FactionRank
Localization["faction.name"] = "Fraktion"
Localization["factionrank.name"] = "Name"
Localization["faction.name_description"] = "Der Name der Fraktion"
Localization["faction.prefix"] = "Prefix"
Localization["faction.prefix_description"] = "Der Prefix der Fraktion"
Localization["faction.description"] = "Beschreibung"
Localization["faction.description_description"] = "Die Beschreibung wird in der Charaktererstellung angezeigt"
Localization["faction.color"] = "Farbe"
Localization["faction.color_description"] = "Die Farbe der Fraktion"
Localization["faction.models"] = "Models"
Localization["faction.models_description"] = "Die Models, welche Charaktere der Fraktion wählen dürfen"
Localization["faction.weapons"] = "Waffen"
Localization["faction.weapons_description"] = "Die Waffen, die Charaktere der Fraktion bekommen"
Localization["faction.package"] = "Fraktionsdaten"
Localization["manager.name"] = "Verwaltung"
Localization["manager.access_denied"] = "Du hast keinen Zugriff auf die Verwaltung"
Localization["manager.nothing"] = "Nichts ausgewählt"
Localization["manager.search"] = "Suche: ..."
Localization["faction.add"] = "Fraktion hinzufügen"
Localization["faction.duplicate"] = "Duplizieren"
Localization["faction.duplicate_long"] = "Fraktion duplizieren"
Localization["faction.duplicate_confirmation"] = "Bist du dir sicher, dass du die Fraktion duplizieren möchtest? Wenn ja, dann wähle bitte aus, ob auch die Ränge dupliziert werden sollen. Diese Aktion kann kurzzeitig starke Lags verursachen."
Localization["faction.select"] = "Auswählen"
Localization["faction.rank_duplicate"] = "Ränge duplizieren"
Localization["faction.rank_duplicate_not"] = "Ränge nicht duplizieren"
Localization["faction.delete"] = "Fraktion Löschen"
Localization["faction.delete_warning"] = "Fraktion wird unwiederuflich gelöscht!"
Localization["faction.deleting_process"] = "Die Fraktion wird gelöcht ..."
Localization["faction.deleting_error"] = "Die Fraktion konnte nicht gelöscht werden"
Localization["faction.save"] = "Fraktion speichern"
Localization["faction.saving_process"] = "Die Fraktion wird gespeichert ..."
Localization["rank.right_click"] = "Rechtsklick auf Rang für mehr Optionen"
Localization["rank.plural"] = "Ränge"
Localization["rank.invalid"] = "Rang Invalid"
Localization["rank.duplicate"] = "Rang duplizieren"
Localization["rank.duplicate_confirmation"] = "Dadurch wird der Rang in die gleiche Fraktion dupliziert."
Localization["rank.move"] = "Verschieben"
Localization["rank.select_target_faction"] = "Zielfraktion auswählen"
Localization["rank.remove"] = "Entfernen"
Localization["rank.delete_warning"] = "Rang wird unwiederuflich gelöscht!"
Localization["rank.deleting_process"] = "Der Rang wird gelöscht ..."
Localization["rank.deleting_error"] = "Der Rang konnte nicht gelöscht werden"
Localization["rank.add"] = "Rang hinzufügen"
Localization["faction.saved"] = "Die Fraktion wurde erfolgreich gespeichert."
Localization["faction.saved_error"] = "Die Fraktion konnte nicht gespeichert werden."
Localization["faction.deleted"] = "Die Fraktion wurde erfolgreich gelöscht."
Localization["faction.deleted_error"] = "Die Fraktion konnte nicht gelöscht werden."
Localization["rank.deleted"] = "Der Rang wurde erfolgreich gelöscht."
Localization["rank.deleted_error"] = "Der Rang konnte nicht gelöscht werden."
Localization["faction.invalid"] = "Fraktion Invalid"
Localization["faction.invalid_parent"] = "Parent Fraktion Invalid"
Localization["faction.parentId"] = "Vererbungs-Fraktion"
Localization["faction.parentId_description"] = "Eine Vererbungs-Fraktion verebt Ränge und ähnliches an diese Fraktion."
Localization["faction.creating"] = "Fraktionserstellung"
Localization["faction.create"] = "Erstellen"
Localization["faction.creating_process"] = "Die Fraktion wird erstellt ..."
Localization["faction.creation_success"] = "Die Fraktion wurde erfolgreich erstellt."
Localization["faction.creation_error"] = "Die Fraktion konnte nicht erstellt werden."
Localization["faction.new"] = "Neue Fraktion"
Localization["rank.editing"] = "Rangbearbeitung"
Localization["rank.save"] = "Rang Speichern"
Localization["rank.saving_process"] = "Der Rang wird gespeichert ..."
Localization["rank.creating_process"] = "Der Rang wird erstellt ..."
Localization["rank.creation_success"] = "Der Rang wurde erfolgreich erstellt."
Localization["rank.creation_error"] = "Der Rang konnte nicht erstellt werden."
Localization["rank.saving_success"] = "Der Rang wurde erfolgreich gespeichert."
Localization["rank.saving_error"] = "Der Rang konnte nicht gespeichert werden."
Localization["rank.name"] = "Name"
Localization["rank.name_description"] = "Der Name des Rangs"
Localization["rank.prefix"] = "Prefix"
Localization["rank.prefix_description"] = "Der Prefix des Rangs"
Localization["rank.description"] = "Beschreibung"
Localization["rank.description_description"] = "Die Beschreibung wird in der Charaktererstellung angezeigt"
Localization["rank.team"] = "Teammitglied on Duty-Rank"
Localization["rank.team_description"] = "Ob der Charakter ein Teammitglied ist, wird verwendet um u.a. den Namen aller Spieler zu sehen"
Localization["rank.permission"] = "Befehlsstufe"
Localization["rank.permission_description"] = "Befehlsstufe des Charakters"
Localization["rank.health"] = "Leben"
Localization["rank.health_description"] = "Die Leben von Charakteren dieses Rangs"
Localization["rank.armor"] = "Rüstung"
Localization["rank.armor_description"] = "Die Rüstung von Charakteren dieses Rangs"
Localization["rank.speed"] = "Geschwindigkeit"
Localization["rank.speed_description"] = "Die Geschwindigkeit des Charaters wenn er normal läuft. Rennen ist doppelt so schnell."
Localization["rank.jumpPower"] = "Sprung Höhe"
Localization["rank.jumpPower_description"] = "Die Sprunghöhe des Charakters."
Localization["rank.color"] = "Farbe"
Localization["rank.color_description"] = "Die Farbe des Rangs"
Localization["rank.models"] = "Models"
Localization["rank.models_description"] = "Die Models, welche Charaktere des Rangs wählen dürfen"
Localization["rank.weapons"] = "Waffen"
Localization["rank.weapons_description"] = "Die Waffen, die Charaktere des Rangs bekommen"
Localization["faction.invalid_id"] = "Ungültige Id"
Localization["faction.invalid_created"] = "Ungültiger Erstellzeitpunkt"
Localization["faction.invalid_name"] = "Der Name muss mindestens aus 3 Zeichen bestehen"
Localization["faction.invalid_prefix"] = "Das Kürzel darf maximal 20 Zeichen lang sein"
Localization["rank.invalid_faction_id"] = "Unfültige Fraktions Id"
Localization["rank.invalid_faction"] = "Fraktion existiert nicht"
Localization["rank.invalid_health"] = "Es muss eine positive Zahl für die Leben angegeben werden"
Localization["rank.invalid_armor_low"] = "Es muss ein positiver Wert für die Rüstung angegeben werden"
Localization["rank.invalid_armor_high"] = "Die Rüstung darf maximal 255 betragen"
Localization["rank.invalid_speed_low"] = "Geschwindigkeit muss positiv sein."
Localization["rank.invalid_speed_high"] = "Geschwindigkeit darf nicht grösser als 500 sein."
Localization["faction.plural"] = "Fraktionen"
Localization["faction.eventlog_created"] = "$1 ($2) hat folgende Fraktion erstellt: $3."
Localization["faction.eventlog_edited"] = "$1 ($2) hat folgende Fraktion bearbeitet: $3."
Localization["faction.eventlog_deleted"] = "$1 ($2) hat folgende Fraktion gelöscht: $3."
Localization["rank.eventlog_created"] = "$1 ($2) hat folgenden Rang erstellt: $3."
Localization["rank.eventlog_edited"] = "$1 ($2) hat folgenden Rang bearbeitet: $3."
Localization["rank.eventlog_deleted"] = "$1 ($2) hat folgenden Rang gelöscht: $3."
Localization["faction.copy_addition"] = "(K)"
Localization["rank.package"] = "Rangdaten"
Localization["object.add"] = "Hinzufügen"
Localization["faction.no_faction"] = "Keine Fraktion Ausgewählt"
Localization["object.none"] = "Kein Objekt Ausgewählt"
Localization["object.save_error"] = "Objekt konnte nicht gespeichert werden."
Localization["faction.recursion_parent"] = "Rekursion gefunden! Erstelle keine Vererbungs-Kreise"
Localization["rank.new"] = "Neuer Rang"
Localization["rank.delete"] = "Rang Löschen"
Localization["rank.authorityLevel"] = "Authoritätslevel"
Localization["rank.authorityLevel_description"] = "Ein höherer Wert gibt einem Autorität über Ränge mit niedrigerem Wert."
Localization["rank.permissions"] = "Rechte"
Localization["rank.permissions_description"] = "Eine Liste von Rechten, die einem Rang gegeben werden kann."
Localization["permission.promote"] = "Befördern"
Localization["permission.kick"] = "Herauswerfen"
Localization["permission.invite"] = "Einladen"
Localization["rank.inherit"] = "Rang Vererben"
Localization["rank.inherit_description"] = "Soll dieser Rang an eine Kinds-Fraktion vererbt werden?"
Localization["rank.isStartRank"] = "Start Rang"
Localization["rank.isStartRank_description"] = "Is dies ein initialer Start Rang, in dem Spieler charactere bei Beginn erstellen können?"
Localization["rank.stats"] = "Stats"
-- Equipment
Localization["equipment.category"] = "Ausrüstung"
Localization["equipment.invalid_faction_id"] = "Unfültige Fraktions Id"
Localization["equipment.invalid_faction"] = "Fraktion existiert nicht"
Localization["shared.equipment"] = "Ausrüstung"
Localization["shared.course"] = "Fortbildung"
Localization["equipment.invalid_health"] = "Ungültige Leben"
Localization["equipment.invalid_armor"] = "Ungültige Rüstung"
Localization["equipment.invalid_speed"] = "Ungültige Geschwindigkeit"
Localization["equipment.duplicate"] = "Ausrüstung duplizieren"
Localization["equipment.delete"] = "Ausrüstung löschen"
Localization["equipment.delete_warning"] = "Ausrüstung wird unwiederuflich gelöscht!"
Localization["equipment.add"] = "Ausrüstung hinzufügen"
Localization["equipment.save"] = "Ausrüstung speichern"
Localization["equipment.rankWhitelist"] = "Rang Whitelist"
Localization["equipment.rankWhitelist_description"] = "Eine Liste der Ränge, die das Ausrüstung erhalten sollen."
Localization["equipment.health_bonus"] = "Lebensbonus"
Localization["equipment.health_bonus_description"] = "Zusätzliche Leben, die durch die Ausrüstung verfügbar sind."
Localization["equipment.armor_bonus"] = "Rüstungsbonus"
Localization["equipment.armor_bonus_description"] = "Zusätzliche Rüstung, die durch die Ausrüstung verfügbar ist."
Localization["equipment.speed_bonus"] = "Geschwindigkeitsbonus"
Localization["equipment.speed_bonus_description"] = "Zusätzliche Geschwindigkeit, die durch die Ausrüstung verfügbar ist."
Localization["equipment.jump_bonus"] = "Sprunghöhenbonus"
Localization["equipment.jump_bonus_description"] = "Zusätzliche Sprunghöhe, die durch die Ausrüsrung verfügbar ist."
Localization["equipment.health_plus"] = "HP+"
Localization["equipment.armor_plus"] = "ARM+"
Localization["equipment.speed_plus"] = "SPD+"
Localization["equipment.health_minus"] = "HP-"
Localization["equipment.armor_minus"] = "ARM-"
Localization["equipment.speed_minus"] = "SPD-"
Localization["equipment.no_effect"] = "Kein Effekt"
Localization["equipment.all_ranks"] = "Alle Ränge"
Localization["equipment.no_ranks"] = "Niemand"
Localization["equipment.long_ranks"] = "Manche Ränge"
Localization["equipment.package"] = "Ausrüstungsdaten"
Localization["equipment.blacklist"] = "Blacklist Waffen & Models"
Localization["equipment.blacklist_desciption"] = "Waffen und Models werden stattdessen entfernt."
Localization["equipment.blacklist_yes"] = "Blacklist"
Localization["equipment.blacklist_no"] = "Whitelist"
Localization["equipment.models"] = "Models"
Localization["equipment.models_desciption"] = "Models, die durch das Ausrüstung verfügbar sind."
Localization["equipment.weapons"] = "Waffen"
Localization["equipment.weapons_description"] = "Waffen, die durch das Ausrüstung verfügbar sind."
Localization["equipment.model_blacklist"] = "MDL-"
Localization["equipment.model_whitelist"] = "MDL+"
Localization["equipment.weapon_blacklist"] = "WFN-"
Localization["equipment.weapon_whitelist"] = "WFN+"
Localization["equipment.inherit"] = "Ausrüstung Vererben"
Localization["equipment.inherit_description"] = "Soll dieses Ausrüstung in andere Fraktionen vererbet werden?"
Localization["equipment.conditions"] = "Ausrüstungsbedingungen"
-- Joinmanager
Localization["joinmanager.wrong_password"] = "Das eingegebene Passwort stimmt nicht mit dem\nPasswort des Servers überein.\nBitte überprüfe deine Eingabe."
Localization["joinmanager.banned"] = "Du bist gebannt\n\nAdmin: {adminName}\nGrund: {reason}\nGebannt am: {time}\nVerbleibend: {unban}\n\nEin Entbannantrag kann im Forum eingereicht werden."
Localization["joinmanager.server_full"] = "Reservierte Slots\n\nAlle nicht reservierten Slots sind belegt.\n\nUnterstuetzer und Teammitglieder koennen weiterhin den Server betreten."
Localization["joinmanager.maintenance_hostname"] = "[WARTUNG]"
Localization["joinmanager.maintenance"] = "Wartungsmodus\n\nWir arbeiten aktuell an diesem Server."
-- Keybinds
Localization["keybinds.reset_binds"] = "Binds zurücksetzen"
Localization["keybinds.removed_permanently"] = "Alle Binds werden unwiderruflich gelöscht!"
-- Loading
Localization["loading.package_group_list"] = "Paketgruppenliste erhalten"
Localization["loading.count"] = "Anzahl: $1"
Localization["loading.package_processed"] = "$1 erfolgreich verarbeitet"
Localization["loading.package_error"] = "Warnung: Fehlender Package Group Handler: $1"
Localization["loading.process"] = "$1 werden abgerufen ..."
Localization["loading.finished"] = "Ladevorgang abgeschlossen"
Localization["loading.processing"] = "$1 erfolgreich empfangen, wird verarbeitet ..."
Localization["loading.data_loaded"] = "Alle Daten wurden geladen"
Localization["loading.data_loading"] = "$1 wird geladen"
Localization["loading.waiting"] = "Warte auf Server"
Localization["loading.initialise"] = "Initialisierung (FastLoad v2)"
Localization["loading.percentage"] = "Lade Daten ($1%)..."
Localization["loading.play"] = "Spielen"
Localization["loading.reconnect"] = "Neu verbinden"
Localization["loading.leave"] = "Server verlassen"
Localization["loading.kick"] = "Fehler beim Ladevorgang: Das angefrage Paket existiert nicht!"
-- Player
Localization["player.manager"] = "Spielerverwaltung"
Localization["player.drop_weapon"] = "Waffe Ablegen"
Localization["player.throw_weapon"] = "Waffen Werfen"
Localization["player.administrate"] = "Administrieren"
Localization["player.selection"] = "Spielerauswahl"
Localization["player.none_found"] = "Keine Spieler gefunden"
Localization["player.load_offline"] = "Charaktere von offline Spielern laden"
Localization["player.save"] = "Spieler speichern"
Localization["player.saving_process"] = "Spielerdaten werden gespeichert..."
Localization["player.no_characters"] = "Spieler besitzt keine Charaktere"
Localization["player.download_characters"] = "Charaktere herunterladen"
Localization["player.show_character"] = "Charakter anzeigen"
Localization["player.delete_character"] = "Charakter löschen"
Localization["player.character_delete_warning"] = "Charakter wird unwiederuflich gelöscht!"
Localization["player.character_deletion_process"] = "Der Charakter wird gelöscht..."
Localization["player.character_deletion_success"] = "Der Charakter wurde erfolgreich gelöscht."
Localization["player.character_deletion_error"] = "Der Charakter konnte nicht gelöscht werden."
Localization["player.saved"] = "Spielerdaten wurden erfolgreich gespeichert."
Localization["player.saving_error"] = "Spielerdaten konnten nicht gespeichert werden."
Localization["player.invalid"] = "Spielerdaten Invalid"
Localization["player.created_on"] = "Erstellt am:\n"
Localization["player.last_online"] = "Zuletzt online:\n"
Localization["player.steamId64_list"] = "SteamId64:\n"
Localization["player.steamId_list"] = "SteamId:\n"
Localization["player.name"] = "Spielerdaten"
Localization["player.spectator"] = "Spectator"
Localization["player.goto_console"] = "Du bist die Konsole und kannst dich nicht teleportieren.\n"
Localization["player.goto_dead"] = "Du bist tot!"
Localization["player.goto_in_vehicle"] = "Das Ziel ist in einem Fahrzeug! Aktiviere Noclip bevor du dich dorthin teleportierst."
Localization["player.goto_no_space"] = "Dort ist kein Platz für dich. Aktiviere Noclip bevor du dich dorthin teleportierst."
Localization["player.goto"] = "Telportiert dich zum Ziel."
Localization["player.invalid_id"] = "Ungültige Id"
Localization["player.invalid_steamid64"] = "Ungültige SteamID64"
Localization["player.invalid_created"] = "Ungültiger Erstellzeitpunkt"
Localization["player.display_name"] = "Spieler $1"
Localization["player.eventlog_cat_spawn"] = "Player Spawn"
Localization["player.eventlog_spawn_as"] = "$1 ($2) ist als $3 gespawnt."
Localization["player.eventlog_spawn"] = "$1 ($2) ist gespawnt."
Localization["player.eventlog_respawn"] = "$1 ($2) hat $3 ($4) wiederbelebt."
Localization["player.eventlog_cat_connections"] = "Verbindungsverlauf"
Localization["player.eventlog_weapon"] = "Waffen"
Localization["player.eventlog_weapon_dropped"] = "$1 ($2) hat eine Waffe gedropped: '$3'"
Localization["player.eventlog_weapon_pickedup"] = "$1 ($2) hat eine Waffe aufgehoben: '$3'"
Localization["player.eventlog_weapon_give_other"] = "$1 ($2) hat $3 ($4) eine Waffe übergeben: '$5'"
Localization["player.eventlog_join"] = "$1 ($2) hat den Server betreten."
Localization["player.eventlog_leave"] = "$1 ($2) hat den Server verlassen."
Localization["player.eventlog_cat_death"] = "Tode"
Localization["player.eventlog_falldamage"] = "$1 ($2) ist an Fallschaden gestorben."
Localization["player.eventlog_suicide"] = "$1 ($2) hat sich selbst umgebracht."
Localization["player.eventlog_killed_by"] = "$1 ($2) hat $3 ($4) mit $5 getötet."
Localization["player.eventlog_killed_from"] = "$1 ($2) ist durch $3 gestorben. $4"
Localization["player.eventlog_unknown"] = "Unbekannt"
Localization["player.eventlog_attacker"] = "Angreifer:"
Localization["player.eventlog_cat_damage"] = "Schaden"
Localization["player.eventlog_damage_self_with"] = "$1 ($2) hat sich selbst $3 Schaden zugefügt. Inflictor: $4."
Localization["player.eventlog_damage_self"] = "$1 ($2) hat sich selbst $3 Schaden zugefügt."
Localization["player.eventlog_damage_with"] = "$1 ($2) hat $3 ($4) $5 Schaden mit $6 zugefügt."
Localization["player.eventlog_damage"] = "$1 hat $2 ($3) $4 Schaden zugefügt."
Localization["player.eventlog_admin_on"] = "$1 ($2) hat den Administrationsmodus aktiviert."
Localization["player.eventlog_admin_off"] = "$1 ($2) hat den Administrationsmodus deaktiviert."
Localization["player.kick"] = "Der Server konnte deine Daten nicht laden! (Interner Fehler)"
Localization["player.kick_new"] = "Der Server konnte deine Daten nicht anlegen! (Interner Fehler)"
Localization["player.kick_invalid"] = "Ungültige Spielerdaten"
Localization["player.admin_on"] = "Administrationsmodus aktiviert!"
Localization["player.admin_off"] = "Administrationsmodus deaktiviert!"
Localization["player.dropinfo"] = "Lasse deine Waffe fallen\n"
Localization["player.throwinfo"] = "Werfe deine Waffe\n"
-- Propertymodel
Localization["propertymodel.category_base"] = " Basis"
Localization["propertymodel.yes"] = "Ja"
Localization["propertymodel.no"] = "Nein"
Localization["propertymodel.error_no_exist"] = "$1 existiert nicht"
Localization["propertymodel.error_not_changed"] = "Der Wert hat sich nicht geändert"
Localization["propertymodel.no_exist"] = "Property $1 existiert nicht"
Localization["propertymodel.not_changed"] = "Der Wert der Property hat sich nicht geändert"
Localization["propertymodel.cant_edit"] = "Daten können nicht bearbeitet werden"
Localization["propertymodel.no_change"] = "Es gab keine Änderung"
Localization["propertymodel.no_permission"] = "Fehlende Berechtigung"
Localization["propertymodel.edit_network_not"] = "Edit-Networking ist nicht intialisiert"
Localization["propertymodel.unknown_data"] = "Unbekannte Daten"
Localization["propertymodel.unknown_reason_data"] = "Unbekannter Grund (Data)"
Localization["propertymodel.unknown_property"] = "Unbekanntes Property"
Localization["propertymodel.unknown_readon_property"] = "Unbekannter Grund (Property)"
Localization["propertymodel.not_creation_whitelist"] = "$1 nicht in der Creation Whitelist"
Localization["propertymodel.sql_error"] = "SQL Error"
Localization["propertymodel.copy"] = "$1 (Copy)"
Localization["propertymodel.invalid_value"] = "Invalid Value ($1)"
Localization["propertymodel.invalid_model"] = "Ungültiges Model"
Localization["propertymodel.models_collapse"] = "Skins Ausblenden"
Localization["propertymodel.models_expand"] = "Skins Einblenden"
-- Scoreboard
Localization["scoreboard.column_name"] = "Name"
Localization["scoreboard.column_faction"] = "Fraktion"
Localization["scoreboard.column_rank"] = "Rang"
Localization["scoreboard.column_group"] = "Gruppe"
Localization["scoreboard.bot"] = "Bot"
Localization["scoreboard.column_ping"] = "Ping"
Localization["scoreboard.steam_profile"] = "Steam Profil"
Localization["scoreboard.teleport_to"] = "Zu Spieler teleportieren"
Localization["scoreboard.bring"] = "Spieler zu dir teleportieren"
Localization["scoreboard.return"] = "Spieler  zurückbringen"
Localization["scoreboard.on_map_since"] = "Der Server ist seit $1 auf dieser Map."
Localization["scoreboard.copy_steamid"] = "SteamID kopieren"
-- Settings
Localization["settings.settings"] = "Einstellungen"
Localization["settings.settings_removed_permanently"] = "Alle Einstellungen werden unwiderruflich gelöscht!"
Localization["settings.asay_permission"] = "Die Fähigkeit 'ulx asay' zu sehen"
Localization["settings.admin_message"] = "Admin Nachricht: #s"
Localization["settings.to_team"] = "#P an Team: #s"
Localization["settings.to_team_no_ulx"] = " an Team: "
Localization["settings.hidden_message"] = "Diese Nachricht wurde versteckt weil der @Chat deaktiviert ist."
Localization["settings.message"] = "Nachricht"
Localization["settings.asay_description"] = "Sendet eine Nachricht an alle Teammitglieder auf dem Server."
-- UI
Localization["ui.modalconfirm"] = "Okay"
Localization["ui.year"] = "Jahr"
Localization["ui.yearaddition"] = "e"
Localization["ui.week"] = "Woche"
Localization["ui.weekaddition"] = "n"
Localization["ui.day"] = "Tag"
Localization["ui.dayyaddition"] = "e"
Localization["ui.hour"] = "Stunde"
Localization["ui.houraddition"] = "n"
Localization["ui.minute"] = "Minute"
Localization["ui.minuteaddition"] = "n"
Localization["ui.and"] = "und"
Localization["ui.second"] = "Sekunde"
Localization["ui.secondaddition"] = "n"
-- Whitelist
Localization["whitelist.whitelist"] = "Whitelist"
Localization["whitelist.property_description"] = "Die Ränge in denen der Spieler whitelisted ist"
Localization["whitelist.recruit_rank"] = "Rekrutenrang"
Localization["whitelist.recruit_rank_property"] = "Dieser Rang wird automatisch gelisted wenn ein Spieler den Server betritt."
Localization["whitelist.missing_whitelist"] = "Fehlende Whitelist"
Localization["whitelist.no_longer_listed"] = "Du bist nicht mehr für deinen Charakter gewhitelisted und du wurdest zum Spectator gesetzt."
Localization["whitelist.given"] = "gegeben"
Localization["whitelist.removed"] = "entfernt"
Localization["whitelist.whitelist_given"] = "$1 ($2) hat $3 ($4) die Whitelist für $5 $6."
Localization["whitelist.whitelist_given_server"] = "Der Server hat $1 ($2) die Whitelist für $3 $4."
Localization["whitelist.cant_remove_educated"] = "Du kannst die Rekruten Whitelist nicht entfernen"
Localization["whitelist.cant_update_character"] = "Kann die Whitelist von $1 nicht anzeigen"
-- afk
Localization["afk.message"] = "Du bist seit {time} Minute(n) AFK!"
Localization["afk.returned_message"] = "Du bist nun nicht mehr AFK!"
Localization["afk.kick_message"] = "Du warst seit {time} Minuten AFK"
Localization["afk.warning_message"] = "Achtung! Du wirst in {time} Minuten vom Server gekickt, wenn du weiterhin AFK bleibst."
-- Bodygroups
Localization["bodygroups.appearance"] = "Aussehen"
Localization["bodygroups.changing_room"] = "Umkleidekabine"
Localization["bodygroups.skin"] = "Skin"
Localization["bodygroups.rank_changed"] = "Dein Rang hat sich geändert während du versucht hast dich umzuziehen. Der Vorgang wurde abgebrochen!"
Localization["bodygroups.change"] = "Umziehen..."
Localization["bodygroups.model"] = "Ändert das model eines Spielers"
Localization["bodygroups.notargets"] = "Keine Spieler gefunden"
-- Cloneid
Localization["cloneid.cloneid_enabled"] = "Klon Id"
Localization["cloneid.cloneid_enabled_description"] = "Soll dieser Rang eine ID besitzen?"
Localization["cloneid.custom"] = "Spezielle Id"
Localization["cloneid.custom_description"] = "Hier kann eine spezielle id für Spezial-Charaktere gesetzt werden"
Localization["cloneid.shows_his"] = "$1 zeigt seine ID vor:"
Localization["cloneid.idinfo"] = "Zeige deine Klonid vor\n"
-- Comlink
Localization["comlink.join_active"] = "Aktiv betreten"
Localization["comlink.leave_active"] = "Aktiv verlassen"
Localization["comlink.join_passive"] = "Passiv betreten"
Localization["comlink.leave_passive"] = "Passiv verlassen"
Localization["comlink.channel"] = "Comlink Kanal"
Localization["comlink.channel_short"] = "Kanal"
Localization["comlink.inactive"] = "Dein Comlink ist deaktiviert. Drücke $1!"
Localization["comlink.no_channel"] = "Du bist gerade in keinem Channel. Drücke Shift + $1!"
Localization["comChannel.name"] = "Name"
Localization["comChannel.name_description"] = "Der Name des Comlink Kanals"
Localization["comChannel.announcement"] = "Ankündigung"
Localization["comChannel.announcement_description"] = "Ob der Kanal ein Kanal ist der für Ankündigungen verwendet wird"
Localization["comChannel.password"] = "Passwort"
Localization["comChannel.password_description"] = "Das Passwort des Kanals"
Localization["comChannel.password_protected"] = "Passwortgeschützt"
Localization["comChannel.password_protected_description"] = "Ob der Kanal ein Passwort hat"
Localization["comChannel.factions"] = "Zugreifende Fraktionen"
Localization["comChannel.factions_description"] = "Die Fraktionen, die auf den Kanal zugreifen können"
Localization["comChannel.receiveFactions"] = "Empfangende Fraktionen"
Localization["comChannel.receiveFactions_description"] = "Die Fraktionen, die Ankündigungen auf dem Kanal hören"
Localization["comChannel.package"] = "Comlinkdaten"
Localization["comlink.behaviour"] = "Verhalten"
Localization["comlink.behaviour_description"] = "Das Verhalten des Comlink Kanals der Fraktion"
Localization["comlink.behaviour_none"] = "Kein Comlink"
Localization["comlink.behaviour_private"] = "Privater Comlink"
Localization["comlink.behaviour_shared"] = "Geteilter Comlink"
Localization["comlink.category"] = "Comlink"
Localization["comlink.copy_password"] = "Passwort kopieren"
Localization["comlink.confirmJoinTitle"] = "Comlink beitreten"
Localization["comlink.confirmJoin"] = "Bist du sicher, dass du dem Kanal beitreten möchtest?"
Localization["comlink.confirmCreateTitle"] = "Comlink erstellen"
Localization["comlink.confirmCreate"] = "Bist du sicher, dass du den Kanal erstellen möchtest?"
Localization["comlink.propertyEquipment"] = "Comlinkzugriff"
Localization["comlink.propertyEquipment_description"] = "Ob die Ausrüstung Zugriff auf einen Kanal verleiht"
Localization["comlink.courseHas"] = "Kurs hat Comlink"
Localization["comlink.courseHas_description"] = "Ob der Kurs einen Comlink hat"
Localization["comChannel.new"] = "Neuer Comlink Kanal"
Localization["comChannel.duplicate_long"] = "Kanal duplizieren"
Localization["comChannel.delete"] = "Kanal löschen"
Localization["comChannel.delete_warning"] = "Kanal wird unwiderruflich gelöscht!"
Localization["comChannel.add"] = "Kanal hinzufügen"
Localization["comChannel.save"] = "Kanal speichern"
Localization["comChannel.invalid_name"] = "Der Name muss mindestens aus 3 Zeichen bestehen"
Localization["comChannel.invalid_bool"] = "Ungültiger Wert"
Localization["comChannel.invalid_pass"] = "Das Passwort muss mindestens aus 3 Zeichen bestehen"
Localization["comlink.equipment_access"] = "COM+"
Localization["comlink.create_channel"] = "$1's Kanal"
Localization["comlink.password"] = "Gib ein Passwort ein, um einem Kanel beizutreten oder einen zu erstellen."
Localization["comlink.unlock"] = "Passwort Senden"
Localization["comlink.already_channel"] = "Du hast bereits einen Comlink Kanal erstellt."
Localization["comlink.remove_channel"] = "Kanal entfernen!"
-- Compass
Localization["compass.north"] = "N"
Localization["compass.north_east"] = "NO"
Localization["compass.east"] = "O"
Localization["compass.south_east"] = "SO"
Localization["compass.south"] = "S"
Localization["compass.south_west"] = "SW"
Localization["compass.west"] = "W"
Localization["compass.north_west"] = "NW"
Localization["compass.unknown"] = "???"
-- Donator
Localization["donator.is_player_donator"] = "Ob der Spieler ein $1 ist."
Localization["donator.donator_name"] = "Unterstützer"
Localization["donator.got"] = "$1 ($2) hat von $3 ($4) $5 erhalten."
Localization["donator.removed"] = "$1 ($2) hat von $3 ($4) $5 entfernt bekommen."
Localization["donator.is_now"] = "$1 ($2) ist jetzt ein $3."
Localization["donator.is_no_longer"] = "$1 ($2) ist kein $3 mehr."
Localization["donator.icon"] = "icons/donator/unterstuetzer.png"
Localization["donator.ranks"] = "Donator Ränge"
Localization["donator.ranks_description"] = "Die Donator Ränge des Spielers"
-- Escapescreen
Localization["escapescreen.continue_playing"] = "Weiterspielen"
Localization["escapescreen.server_browser"] = "Server Browser"
Localization["escapescreen.keybinds"] = "Keybinds"
Localization["escapescreen.custom_settings"] = "EGM:RP Einstellungen"
Localization["escapescreen.settings"] = "Einstellungen"
Localization["escapescreen.console"] = "Konsole"
Localization["escapescreen.leave"] = "Server verlassen"
-- Event
Localization["event.lister"] = "Eventlister"
Localization["event.lister_denied"] = "Du hast keinen Zugang zum Eventlister!"
Localization["event.steam_name"] = "Steam Name"
Localization["event.character_name"] = "Charakter Name"
Localization["event.faction"] = "Fraktion"
Localization["event.rank"] = "Rang"
Localization["event.add_to_whitelist"] = "Ränge zur Whitelist der Spieler hinzufügen"
Localization["event.whitelist_success"] = "Du hast erfolgreich die Ränge erfolgreich zur Whitelist hinzugefügt!"
-- Experience
Localization["experience.level"] = "Level"
Localization["experience.level_description"] = "Der Level dieses Charakters."
Localization["experience.perks"] = "Perks"
Localization["experience.skilltree"] = "Skillbaum (Verfügbare Punkte: $1)"
Localization["experience.unknown"] = "???"
Localization["experience.reset"] = "Zurücksetzen"
Localization["experience.new_skill"] = "Neuer Skillpunkt"
Localization["experience.new_skill_description"] = "Du hast einen neuen Skillpunkt freigeschaltet"
Localization["experience.offensive"] = "Offensiv"
Localization["experience.offensive1"] = "Schaden 1"
Localization["experience.offensive1_description"] = "Du machst 5% mehr Schaden"
Localization["experience.offensive2"] = "Schaden 2"
Localization["experience.offensive2_description"] = "Du machst 10% mehr Schaden"
Localization["experience.offensive3"] = "Schaden 3"
Localization["experience.offensive3_description"] = "Du machst 15% mehr Schaden"
Localization["experience.offensive4"] = "Schaden 4"
Localization["experience.offensive4_description"] = "Du machst 20% mehr Schaden"
Localization["experience.offensive5"] = "Schaden 5"
Localization["experience.offensive5_description"] = "Du machst 25% mehr Schaden"
Localization["experience.life"] = "Leben"
Localization["experience.life1"] = "Leben 1"
Localization["experience.life1_description"] = "Du hast 5% mehr Leben"
Localization["experience.life2"] = "Leben 2"
Localization["experience.life2_description"] = "Du hast 10% mehr Leben"
Localization["experience.life3"] = "Leben 3"
Localization["experience.life3_description"] = "Du hast 15% mehr Leben"
Localization["experience.life4"] = "Leben 4"
Localization["experience.life4_description"] = "Du hast 20% mehr Leben"
Localization["experience.life5"] = "Leben 5"
Localization["experience.life5_description"] = "Du hast 25% mehr Leben"
Localization["experience.movement"] = "Bewegung"
Localization["experience.movement1"] = "Bewegung 1"
Localization["experience.movement1_description"] = "Du bewegst dich um 2.5% schneller"
Localization["experience.movement2"] = "Bewegung 2"
Localization["experience.movement2_description"] = "Du bewegst dich um 5% schneller"
Localization["experience.movement3"] = "Bewegung 3"
Localization["experience.movement3_description"] = "Du bewegst dich um 7.5% schneller"
Localization["experience.movement4"] = "Bewegung 4"
Localization["experience.movement4_description"] = "Du bewegst dich um 10% schneller"
Localization["experience.movement5"] = "Bewegung 5"
Localization["experience.movement5_description"] = "Du bewegst dich um 12.5% schneller"
Localization["experience.xp_below_zero"] = "XP unter 0"
Localization["experience.level_below_zero"] = "Level unter 0"
Localization["experience.level_above_max"] = "Level über maximalem Level"
-- Extra Rank
Localization["extra_rank.title"] = "Zusatzrang"
Localization["extra_rank.eFaction_name"] = "Zusatzfraktion"
Localization["extra_rank.eFaction_description"] = "Zweite Fraktion des Charakters"
Localization["extra_rank.no_faction"] = "Keine Fraktion"
Localization["extra_rank.eRank_name"] = "Zusatzrang"
Localization["extra_rank.eRank_description"] = "Zweiter Rang des Charakters"
Localization["extra_rank.no_rank"] = "Kein Rang"
Localization["extra_rank.allowERank_name"] = "Zusatzrang erzwingen"
Localization["extra_rank.allowERank_description"] = "Einen zweiten Rang immer erlauben für Charaktere dieses Ranges"
Localization["extra_rank.onMain_name"] = "Auf Hauptfraktion"
Localization["extra_rank.onMain_description"] = "Ausrüstung auf Haupt Fraktion und Rang anwenden."
Localization["extra_rank.onExtra_name"] = "Auf Zusatzfraktion"
Localization["extra_rank.onExtra_description"] = "Ausrüstung auf Zusatz Fraktion und Rang anwenden."
Localization["extra_rank.edit_rank"] = "Zusatzrang bearbeiten"
Localization["extra_rank.edit_rank_long"] = "Hier kannst du den Zusatzrang des Charakters bearbeiten."
Localization["extra_rank.invite"] = "Einladen (Zusatzfraktion)"
Localization["extra_rank.invite_long"] = "Hier kannst du den Charakter in deine Fraktion als Zusatzfraktion einladen."
Localization["extra_rank.confirm_invite"] = "Du wurdest zu folgendem Zusatzrang eingeladen: $1 $2"
Localization["extra_rank.promote_demote"] = "Befördern / Degradieren (Zusatzfraktion)"
Localization["extra_rank.kick"] = "Aus der Fraktion werfen (Zusatzfraktion)"
Localization["extra_rank.kick_message"] = "Hier kannst du den Charakter aus der Zusatzfraktion werfen."
Localization["shared.equip_extra"] = "Zusatz"
Localization["shared.equip_main"] = "Haupt"
Localization["extra_rank.teaminfo"] = "Schreibe im Teamchat deiner Zusatzfraktion\n"
-- Familyshare
Localization["familyshare.kick"] = "Wir wissen wer du bist ;)"
-- Helmet
Localization["helmet.keybind"] = "Helm aufsetzen/abnehmen"
-- Instructor
Localization["instructor.name"] = "Ausbilder"
Localization["instructor.description"] = "Ob der Spieler ein Ausbilder ist"
Localization["instructor.mentor_name"] = "Ausbildermentor"
Localization["instructor.mentor_description"] = "Ob der Spieler ein Ausbildermentor ist"
Localization["instructor.educated_name"] = "Frisch Ausgebildet"
Localization["instructor.educated_description"] = "Ob Ausgebildete zu diesem Rang gelistet werden können."
Localization["instructor.error"] = "Fehler, Ausbildung kann nicht vollführt werden."
Localization["instructor.process"] = "Ausbildung"
Localization["instructor.process2"] = "Ausbilden"
Localization["instructor.kick"] = "Aus der Fraktion werfen"
Localization["instructor.kick_description"] = "Hier kannst du den Charakter aus der Fraktion werfen."
Localization["instructor.manager"] = "Ausbildermanager"
Localization["instructor.promote"] = "Zu Ausbildermentor befördern"
Localization["instructor.demote"] = "Zum Ausbilder degradieren"
Localization["instructor.promote_low"] = "Zum Ausbilder befördern"
Localization["instructor.demote_low"] = "Entfernen"
Localization["instructor.manager_permission"] = "Du hast keinen Zugriff auf den Ausbildermanager."
Localization["instructor.status"] = "Status"
Localization["instructor.none"] = "Keine Ausbilder online"
Localization["instructor.load_offline"] = "Offline Ausbilder laden"
Localization["instructor.copy"] = "Der Logeintrag wurde erfolgreich kopiert"
Localization["instructor.passed"] = "Ausbildung bestanden"
Localization["instructor.eventlog_passed"] = "$1 ($2) hat $3 ($4) zum $5 ausgebildet."
Localization["instructor.eventlog_promoted_low"] = "$1 ($2) wurde von $3 ($4) zum Ausbilder ernannt."
Localization["instructor.eventlog_demoted_low"] = "$1 ($2) wurde von $3 ($4) als Ausbilder entfernt."
Localization["instructor.eventlog_promoted"] = "$1 ($2) wurde von $3 ($4) zum Ausbilder Mentor ernannt."
Localization["instructor.eventlog_demoted"] = "$1 ($2) wurde von $3 ($4) als Ausbilder Mentor entfernt."
Localization["instructor.invalid_rank"] = "Der ausgewählte Rang existiert nicht"
Localization["instructor.invalid_current_rank"] = "Du hast keinen gültigen Rang."
Localization["instructor.no_recruit"] = "Der aktuelle Charakter des Spielers ist kein Rekrut"
Localization["instructor.success"] = "Du wurdest zum $1 ausgebildet"
Localization["instructor.success2"] = "Der Spieler wurde erfolgreich ausgebildet"
-- Interact
Localization["interact.emotes"] = "Emotes"
Localization["interact.cheer"] = "Jubeln"
Localization["interact.laugh"] = "Lachen"
Localization["interact.salute"] = "Salutieren"
Localization["interact.wave"] = "Winken"
Localization["interact.agree"] = "Zustimmen"
Localization["interact.disagree"] = "Ablehnen"
Localization["interact.forward"] = "Vorwärts"
Localization["interact.stop"] = "Halt"
Localization["interact.group_up"] = "Gruppieren"
Localization["interact.becon"] = "Bei Fuss!"
Localization["interact.admin_menu"] = "Admin Menü"
Localization["interact.close"] = "Schliessen"
Localization["interact.interact_name"] = "Interact"
Localization["interact.interact"] = "Interagieren"
-- Money
Localization["money.pay"] = "$1 zahlen"
Localization["money.character_description"] = "Das aktuelle Geld des Charakters"
Localization["money.paycheck"] = "Paycheck"
Localization["money.peycheck_description"] = "Das Geld, dass man alle $1 Minuten bekommt."
Localization["money.pay_to"] = "$1 zahlen an..."
Localization["money.how_much"] = "Wieviel $1 wollen sie an $2 zahlen?"
Localization["money.name"] = "Credits"
Localization["money.money_not_positive"] = "Geld muss Positiv sein"
Localization["money.paycheck_not_positive"] = "Pacheck muss Positiv sein"
Localization["money.got"] = "Geld bekommen"
Localization["money.got_description"] = "Du hast $1 $2 erhalten."
Localization["money.give"] = "Geld ausgegeben"
Localization["money.give_description"] = "Du hast $1 $2 ausgegeben."
Localization["money.pay_logs"] = "$1 ($2) hat  $3 ($4) $5 $6 gegeben."
-- Multiserver
Localization["multiserver.switch"] = "Server wechseln"
Localization["multiserver.confirm"] = "Du wurdest auf den Server \n\"$1\" eingeladen.\nMöchtest du den Server wechseln?"
Localization["multiserver.send"] = "Auf anderen Server senden"
Localization["multiserver.send_to"] = "Wohin möchtest du den Spieler senden?"
Localization["multiserver.select"] = "Server auswählen"
Localization["multiserver.send_short"] = "Senden"
Localization["multiserver.kick_full"] = "Servergruppe voll\n\nDie Maximale Anzahl an Spielern dieser Servergruppe ist ereicht."
Localization["multiserver.kick_eventserver"] = "Eventserver\n\nBitte verbinde dich mit dem Hauptserver."
Localization["multiserver.radvert"] = "Langstreckenfunk"
Localization["multiserver.radvertinfo"] = "Sende einen Funk auf einen anderen Server\n"
-- Permadeath
Localization["permadeath.death_name"] = "Perma-Death"
Localization["permadeath.death_description"] = "Ob der Charakter tot ist. (Dadurch nicht spielbar)"
-- Permaprops
Localization["permaprops.name"] = "PermaProps"
Localization["permaprops.show"] = "PermaProp anzeigen"
Localization["permaprops.menu"] = "EGM:RP Perma Prop Menu"
Localization["permaprops.reload"] = "Alle PermaProps neu laden"
Localization["permaprops.lag"] = "Dies könnte zu kurzzeitigen Lags führen."
Localization["permaprops.reloaded"] = "PermaProps neu geladen"
Localization["permaprops.reloaded_description"] = "Alle PermaProps wurden neu geladen"
Localization["permaprops.delete_all"] = "Alle Permaprops löschen"
Localization["permaprops.delete_all_description"] = "Alle PermaProps werden unwiderruflich gelöscht!"
Localization["permaprops.really_sure"] = "Wirklich Sicher?"
Localization["permaprops.delete_all_confirm"] = "Alle Props werden unwiderruflich gelöscht!\nEs gibt keinen Weg zurück!\nKein Backup!\nNichts!"
Localization["permaprops.delete_done"] = "PermaProps gelöscht"
Localization["permaprops.delete_done_description"] = "Alle PermaProps wurden gelöscht."
Localization["permaprops.delete_confirm"] = "Ja Verdammt!"
Localization["permaprops.model"] = "Model"
Localization["permaprops.distance"] = "Abstand"
Localization["permaprops.loading"] = "Lade..."
Localization["permaprops.creator"] = "Ersteller:"
Localization["permaprops.teleport_to"] = "Zu Prop teleportieren"
Localization["permaprops.remove_prop"] = "Prop Entfernen"
Localization["permaprops.prop_removing"] = "Das Prop wird unwiderruflich gelöscht!"
Localization["permaprops.prop_removed"] = "PermaProp gelöscht"
Localization["permaprops.prop_removed_description"] = "Das PermaProp wurde gelöscht."
Localization["permaprops.steamprofile"] = "Steamprofil anzeigen"
Localization["permaprops.steamid"] = "SteamID64 kopieren"
Localization["permaprops.lister_menu"] = "EGM:RP Perma Prop Lister"
Localization["permaprops.user"] = "Nutzer"
Localization["permaprops.lister"] = "Listender"
Localization["permaprops.entlist"] = "Entlisten"
Localization["permaprops.user_remove"] = "Der Nutzer wird unwiderruflich entlistet!"
Localization["permaprops.user_steam"] = "Nutzer Steam Profil"
Localization["permaprops.lister_steam"] = "Listender Steam Profil"
Localization["permaprops.list"] = "Listen"
Localization["permaprops.model_blacklisted"] = "Model Blacklisted"
Localization["permaprops.model_blacklisted_description"] = "Dieses Modell kann nicht gepermaproppt werden."
Localization["permaprops.entity_blacklisted"] = "Entity Blacklisted"
Localization["permaprops.entity_blacklisted_description"] = "Dieses Entity kann nicht gepermaproppt werden."
Localization["permaprops.map_prop"] = "Map Prop"
Localization["permaprops.map_prop_description"] = "Map Props können nicht gepermaproppt werden."
Localization["permaprops.saved"] = "Gespeichert!"
Localization["permaprops.saved_description"] = "Entity erfolgreich gespeichert!"
Localization["permaprops.user_unlist"] = "Nutzer entlistet."
Localization["permaprops.user_unlist_description"] = "Der Nutzer wurde entlistet."
-- Rankscale
Localization["rankscale.name"] = "Skalierung"
Localization["rankscale.description"] = "Die Skalierung des Charaktermodels (Max: 10)"
Localization["rankscale.invalid"] = "Skalierung ungültig"
-- Realism
Localization["realism.injuries_toggle"] = "Drücke deinen Keybind um das Verletzungsmenu ein-/auszublenden."
Localization["realism.injuries"] = "Verletzungen"
Localization["realism.kind"] = "Verletzungsart"
Localization["realism.affected"] = "Betroffenes Körperteil"
Localization["realism.severity"] = "Schwere der Verletzung"
Localization["realism.treated"] = "Behandelt"
Localization["realism.untreated"] = "Unbehandelt"
Localization["realism.status"] = "Status"
Localization["realism.crush"] = "Quetschung"
Localization["realism.bullet"] = "Schusswunde"
Localization["realism.cut"] = "Schnittwunde"
Localization["realism.stab"] = "Stichverletzung"
Localization["realism.burn"] = "Verbrennung"
Localization["realism.vehicle"] = "Zertrümmerung"
Localization["realism.fall"] = "Fallschaden"
Localization["realism.blast"] = "Explosion(-sfragmente)"
Localization["realism.club"] = "Platzwunde"
Localization["realism.club2"] = "Prellung"
Localization["realism.shock"] = "Stromschock"
Localization["realism.sonic"] = "Schall"
Localization["realism.laser"] = "Laserverbrennung"
Localization["realism.drown"] = "Erstickt"
Localization["realism.poison"] = "Vergiftet"
Localization["realism.radiation"] = "Verstrahlung"
Localization["realism.blaster"] = "Blasterverbrennung"
Localization["realism.projectile"] = "Projektilwunde"
Localization["realism.projectile_big"] = "Große Projektilwunde"
Localization["realism.projectile_multiple"] = "Multiple Projektilwunde"
Localization["realism.head"] = "Kopf"
Localization["realism.chest"] = "Thorax"
Localization["realism.stomach"] = "Abdomen"
Localization["realism.arm_left"] = "Linker Arm"
Localization["realism.arm_right"] = "Rechter Arm"
Localization["realism.leg_left"] = "Linkes Bein"
Localization["realism.leg_right"] = "Rechtes Bein"
Localization["realism.severity_1"] = "Gering"
Localization["realism.severity_2"] = "Ernsthaft"
Localization["realism.severity_3"] = "Schwer"
Localization["realism.severity_4"] = "Sehr schwer"
Localization["realism.severity_5"] = "Kritisch"
Localization["realism.severity_6"] = "Fatal"
Localization["realism.stamina_invalid"] = "Zahl nicht im angegebenen Bereich"
Localization["realism.stamina_name"] = "Stamina"
Localization["realism.stamina_description"] = "Staminawert (Standard- / Configwert: $1)"
Localization["realism.not_defined"] = "Nicht definierbar"
Localization["realism.injury_keybind"] = "Verletzungen"
Localization["realism.weight"] = "Gewicht"
Localization["realism.weight_tooltip"] = "Wie viel Gewicht Charaktere mit diesem Job tragen können"
-- Reports
Localization["reports.show"] = "Akte Anzeigen"
Localization["reports.name"] = "Akte"
Localization["reports.hour"] = "h"
Localization["reports.minute"] = "m"
Localization["reports.today"] = "Heute"
Localization["reports.one_day_ago"] = "Vor 1 Tag"
Localization["reports.one_week_ago"] = "Vor 1 Woche"
Localization["reports.days_ago"] = "Vor $1 Tagen"
Localization["reports.entry"] = "Eintrag"
Localization["reports.date"] = "Datum"
Localization["reports.delete_entry"] = "Eintrag Löschen"
Localization["reports.add_entry"] = "Eintrag hinzufügen"
Localization["reports.invalid"] = "Invalid Reports"
Localization["reports.success"] = "Akteneintrag gespeichert"
Localization["reports.success2"] = "Eintrag wurde erfolgreich gespeichert"
Localization["reports.promote"] = "$1 wurde von $2 in den Rang $3 der Fraktion $4 gesetzt"
Localization["reports.invited"] = "$1 wurde von $2 in den Rang $3 der Fraktion $4 eingeladen"
Localization["report.create"] = "$1 wurde von $2 mit dem Rang $3 in der Fraktion $4 erstellt"
Localization["reports.view"] = "Akten Anzeigen"
Localization["reports.edit"] = "Akteneintrag hinzufügen"
-- Signs
Localization["signs.sign"] = "Schild"
Localization["signs.signs"] = "Schilder"
Localization["signs.desc"] = "Platziere und editiere Schilder mit gemischten Text und Bild in der Welt"
Localization["signs.controls"] = "Linksklick, um ein Schild zu platzieren. Rechtsklick um ein Schild zu editieren."
Localization["signs.import_export"] = "Importieren / Exportieren"
Localization["signs.export_clipboard"] = "Exportiere Schilddaten zur Zwischenablage"
Localization["signs.paste_data"] = "Schilddaten hier einfügen..."
Localization["signs.import_data"] = "Schilddaten importieren"
Localization["signs.mirror"] = "Schild auf beide Seiten spiegeln?"
Localization["signs.size"] = "Schildgröße"
Localization["signs.lines"] = "Linienanzahl: "
Localization["signs.text"] = "Text"
Localization["signs.image"] = "Bild"
Localization["signs.spacer"] = "Abstand"
Localization["signs.font_size"] = "Schriftgröße"
Localization["signs.image_size"] = "Bildgröße"
Localization["signs.spacer_height"] = "Abstandshöhe"
-- Socket
Localization["socket.chats"] = "Chats"
Localization["socket.goocinfo"] = "Globale version des OOC\n"
-- Spawnpoints
Localization["spawnpoints.denied"] = "Permission Denied"
Localization["spawnpoints.denied_description"] = "Keine Berechtigung um Spawns zu editieren."
-- Special Character
Localization["shared.specialChar"] = "Spezial-Charakter"
Localization["specialChar.new"] = "Neuer Spezial-Charakter"
Localization["specialChar.duplicate"] = "Spezial-Charakter duplizieren."
Localization["specialChar.delete"] = "Spezial-Charakter löschen."
Localization["specialChar.delete_warning"] = "Spezial-Charakter wird unwiderruflich gelöscht!"
Localization["specialChar.add"] = "Spezial-Charakter hinzufügen."
Localization["specialChar.save"] = "Spezial-Charakter speichern."
Localization["specialChar.invalid_faction_id"] = "Ungültige Fraktions-Id"
Localization["specialChar.invalid_faction"] = "Ungültige Fraktion"
Localization["specialChar.invalid_name"] = "Ungültiger Name (Minimum 3 Buchstaben)"
Localization["specialChar.invalid_specialChar_id"] = "Ungültige Spezial Charakter Id"
Localization["specialChar.not_valid"] = "Ungültige Spezial Charakter"
Localization["specialChar.not_available"] = "Spezial Charakter nicht verfügbar."
Localization["specialChar.no_rank"] = "Ungültiger Rang"
Localization["specialChar.not_whitelisted"] = "Spezial Charakter nicht Whitelisted."
Localization["specialCharacter.inheritEquipment"] = "Vererbare Ausrüstung kann nicht von einem Special Charakter Abhängig seinl."
Localization["specialChar.invalid_species_id"] = "Ungültige Spezies Id"
Localization["specialChar.invalid_species"] = "Ungültige Spezies"
Localization["specialChar.invalid_head_model"] = "Ungültiges Kopf Model"
Localization["specialCharacter.name"] = "Name"
Localization["specialCharacter.name_description"] = "Name des Spezial-Charakters"
Localization["specialCharacter.rankWhitelist"] = "Rang Whitelist"
Localization["specialCharacter.rankWhitelist_description"] = "Liste von Rängen, in denen der Spezial Charakter gespielt werden kann."
Localization["specialCharacter.scaleModifier"] = "Skalierungs Multiplikator"
Localization["specialCharacter.scaleModifier_description"] = "Skalierungs Multiplikator, der auf den Spezial Charakter angewandt wird."
Localization["specialCharacter.package"] = "Spezialcharakterdaten"
Localization["specialCharacter.specialCharId"] = "Spezialcharakter"
Localization["specialCharacter.specialCharId_description"] = "Spezialcharakter kann den Charakter, den du spielst überschreiben."
Localization["specialCharacter.none"] = "Kein Spezial Charakter"
Localization["specialCharacter.sCharWhitelist"] = "Spezial Charakter Whitelist"
Localization["specialCharacter.sCharWhitelist_description"] = "Spezial Charakter, der Ausgewählt sein solte, um diese Ausrüstung zu erhalten."
Localization["specialCharacter.speciesId"] = "Spezies"
Localization["specialCharacter.speciesId_description"] = "Überschreibe die Spezies des Spezialcharakters."
Localization["specialCharacter.speciesId_none"] = "Keine Spezies ausgewählt"
Localization["specialCharacter.headModel"] = "Kopf Model"
Localization["specialCharacter.headModel_description"] = "Überschreibe das Kopf Model des Spezialcharakters."
Localization["specialCharacter.headModel_none"] = "Kein Kopf Model ausgewählt"
-- Species
Localization["shared.species"] = "Spezies"
Localization["species.invalid_name"] = "Ungültiger Speziesname"
Localization["species.invalid_blood_color"] = "Ungültige Blutfarbe"
Localization["species.not_whitelisted"] = "Spezies ist im Rang nicht Whitelisted"
Localization["species.invalid"] = "Ungültige Spezies"
Localization["species.invalid_head"] = "Kopf ist nicht als Spezies Model gesetzt."
Localization["species.new"] = "Neue Spezies"
Localization["species.duplicate_long"] = "Spezies duplizieren"
Localization["species.delete"] = "Spezies löschen"
Localization["species.delete_warning"] = "Spezies wird unwiderruflich gelöscht!"
Localization["species.add"] = "Spezies hinzufügen"
Localization["species.save"] = "Spezies speichern"
Localization["species.package"] = "Speziesdaten"
Localization["species.character_info"] = "Spezies: $1"
Localization["species.name"] = "Name"
Localization["species.name_description"] = "Der Name der Spezies."
Localization["species.factionLimit"] = "Fraktionslimit"
Localization["species.factionLimit_description"] = "Limitiert, wie viele Mitglieder dieser Spezies in einer Fraktion gespielt werden können."
Localization["species.characterLimit"] = "Charakterlimit"
Localization["species.characterLimit_description"] = "Limitiert, wie viele Mitglieder dieser Spezies von einem Spieler gespielt werden können."
Localization["species.bloodColor"] = "Blut-Farbe"
Localization["species.bloodColor_description"] = "Wähle aus, ob und wenn ja welche Farbe von Blut für eine Spezies verwendet werden soll."
Localization["species.blood_none"] = "Kein Blut"
Localization["species.blood_red"] = "Rotes Blut"
Localization["species.blood_yellow"] = "Gelbes Blut"
Localization["species.blood_green"] = "Grünes Blut"
Localization["species.blood_sparks"] = "Funken"
Localization["species.blood_antlion"] = "Antlion Blut (Gelb)"
Localization["species.blood_zombie"] = "Zombie Blut (Grün)"
Localization["species.blood_antlion_worker"] = "Antlion Arbeiter Blut (Helles Grün)"
Localization["species.headModels"] = "Kopf Modelle"
Localization["species.headModels_description"] = "Die Köpfe, die von dieser Spezies verwendet werden."
Localization["species.models"] = "Modelle"
Localization["species.bodyModels"] = "Zusätzliche Körper Modelle"
Localization["species.bodyModels_description"] = "Die Körper, die mit dieser Spezies kompatibel sind."
Localization["species.bodyModelGroup"] = "Körper-Modell-Gruppen"
Localization["species.bodyModelGroup_description"] = "Die Körper, die mit dieser Spezies kompatibel sind."
Localization["species.healthBonus"] = "Lebensbonus"
Localization["species.healthBonus_description"] = "Zusätzliche Leben, die durch die Spezies verfügbar sind."
Localization["species.armorBonus"] = "Rüstungsbonus"
Localization["species.armorBonus_description"] = "Zusätzliche Rüstung, die durch die Spezies verfügbar ist."
Localization["species.speedBonus"] = "Geschwindigkeitsbonus"
Localization["species.speedBonus_description"] = "Zusätzliche Geschwindigkeit, die durch die Spezies verfügbar ist."
Localization["species.jumpBonus"] = "Sprunghöhenbonus"
Localization["species.jumpBonus_description"] = "Zusätzliche Sprunghöhe, die durch die Spezies verfügbar ist."
Localization["species.scaleModifier"] = "Skalierungs Multiplikator"
Localization["species.scaleModifier_description"] = "Skalierungs Multiplikator, der auf Charaktere der Spezies angewandt wird."
Localization["species.damageImmunities"] = "Schaden-Immunitäten"
Localization["species.damageImmunities_description"] = "Schaden-Typen, gegen die die Spezies immun ist."
Localization["species.character"] = "Spezies"
Localization["species.character_description"] = "Die Spezies des Charakters."
Localization["species.character_none"] = "Keine Spezies Ausgewählt"
Localization["species.headModel"] = "Kopf Modell"
Localization["species.headModel_description"] = "Wähle den Kopf aus, den du verwenden willst."
Localization["species.speciesWhitelist"] = "Spezies Whitelist"
Localization["species.speciesWhitelist_description"] = "Liste von Spezies, die für Charaktere dieses Ranges erlaubt sind."
Localization["species.speciesWhitelistEquipment_description"] = "Liste von Spezies, die für Charaktere die dieses Equipment verwenden erlaubt sind."
Localization["species.category"] = "Spezies"
Localization["species.characterLimit_error"] = "Charakterlimit ereicht für Spezies: $1"
Localization["species.factionLimit_error"] = "Es sind zu viele $1 Charaktere online in dieser Fraktion!"
Localization["species.weightBonus"] = "Gewicht Bonus"
Localization["species.weightBonus_description"] = "Zusätzliches Gewicht, dass zum maximalen Gewicht des Charakters hinzugefügt wird."
-- Thirdperson
Localization["thirdperson.toggle"] = "Third Person umschalten"
-- Activity
Localization["activity.setactivity_description"] = "Setzt die Aktivität eines Spielers"
Localization["activity.activity"] = "Aktivität"
Localization["activity.getactivity_description"] = "Zeigt dir deine Aktivität"
Localization["activity.your_updated"] = "Deine Aktivität wurde von $1 geupdated"
Localization["activity.you_updated"] = "Du hast die Aktivität von $1 geupdated"
Localization["activity.getactivity"] = "Du hast $1 Stunden und $2 Minuten Aktivität. Das nächste Ziel erreichst du in $3 Stunden und $4 Minuten"
-- Inventory
Localization["inventory.title"] = "Inventar"
Localization["itemType.name"] = "Name"
Localization["itemType.name_description"] = "Name des Item Types"
Localization["itemType.itemClass_name"] = "Item Klasse"
Localization["itemType.itemClass_description"] = "Klasse des Items. Kontrolliert die Funktion des Items"
Localization["itemType.rarity"] = "Item Seltenheit"
Localization["itemType.rarity_description"] = "Wie selten ist das Item? Beeinflusst die Farbe des Item Tooltips"
Localization["itemType.models"] = "Modelle"
Localization["itemType.models_description"] = "Eine Liste von Modellen, die von diesem Item Typ repräsentiert werden."
Localization["itemType.armor"] = "Rüstung"
Localization["itemType.armor_description"] = "Rüstung, die von diesem Item Typ vergeben wird."
Localization["itemType.speed"] = "Geschwindigkeits Bonus"
Localization["itemType.speed_description"] = "Geschwindigkeits Bonus, der von diesem Item Typ vergeben wird."
Localization["itemType.weapons"] = "Waffen"
Localization["itemType.weapons_description"] = "Eine Liste von Waffen, die von diesem Item Typ repräsentiert werden."
Localization["itemType.package"] = "Itemtypdaten"
Localization["inventory.key_name"] = "Inventar"
Localization["inventory.key_description"] = "Öffne das Spielerinventar."
Localization["itemType.name"] = "Item Typ"
Localization["itemType.new"] = "Neuer Item Typ"
Localization["itemType.duplicate_long"] = "Item Typ duplizieren"
Localization["itemType.delete"] = "Item Typ löschen"
Localization["itemType.delete_warning"] = "Item Typ wird unwiderruflich gelöscht!"
Localization["itemType.add"] = "Item Typ hinzufügen"
Localization["itemType.save"] = "Item Typ speichern"
Localization["inventory.invalid_slot"] = "Ungültiger Item Slot"
Localization["inventory.invalid_sub_slot"] = "Ungültiger Item Sub Slot"
Localization["inventory.no_empty_slot"] = "Kein freier Item Slot"
Localization["inventory.invalid_item"] = "Ungültiges Item"
Localization["inventory.invalid_item_type"] = "Ungültiger Item Typ"
Localization["inventory.invalid_item_class"] = "Ungültige Item Klasse"
Localization["inventory.missing_sub_slot"] = "Sub Slot nicht angegeben."
Localization["itemType.invalid_name"] = "Ungültiger Item Typ Name"
Localization["shared.itemType"] = "Item Typ"
Localization["inventory.invalid_item_class_name"] = "Ungültige Item Klassen-Name"
Localization["itemType.model_already_used"] = "Model bereits in Verwendung"
Localization["itemType.weapon_already_used"] = "Waffe bereits in Verwendung"
Localization["inventory.invalid_player"] = "Ungültiger Spieler"
Localization["inventory.invalid_item_type_id"] = "Ungültige Item Typ-Id"
Localization["inventory.not_current_character"] = "Nicht aktiver Charakter"
Localization["inventory.notify_reset_title"] = "Inventar Zurückgesetzt"
Localization["inventory.notify_reset_text"] = "Dein Inventar wurde zurückgesetzt."
Localization["inventory.item_class_armor"] = "Rüstung"
Localization["inventory.armour_integrity"] = "Integrität: $1%"
Localization["inventory.armour_variant"] = "Variante: $1 / $2"
Localization["inventory.no_slots"] = "Itemklasse hat keine Slots"
Localization["inventory.incompatible_slot"] = "Inkompatible Slots"
Localization["inventory.item_class_weapon"] = "Waffe"
Localization["inventory.no_weapon_class"] = "Keine Waffen Klasse"
Localization["inventory.invalid_weapon_class"] = "Ungültige Waffen Klasse"
Localization["inventory.item_class_weapon_big"] = "Große Waffe"
Localization["inventory.item_class_weapon_grenade"] = "Granate"
Localization["inventory.item_class_weapon_small"] = "Kleine Waffe"
Localization["inventory.weapon_already_equipped"] = "Waffe bereits Ausgerüstet"
Localization["inventory.belt_slot"] = "Gürtel"
Localization["inventory.body_slot"] = "Körper"
Localization["inventory.weapon_big_slot"] = "Große Waffe"
Localization["inventory.weapon_consealed_slot"] = "Versteckte Waffe"
Localization["inventory.weapon_small_slot"] = "Kleine Waffe"
Localization["inventory.backpack_slot"] = "Inventar"
Localization["inventory.rarity"] = "Seltenheit: $1"
Localization["inventory.rarity.unknown"] = "Unbekannte Seltenheit"
Localization["inventory.rarity.common"] = "Gewöhnlich"
Localization["inventory.rarity.uncommon"] = "Ungewöhnlich"
Localization["inventory.rarity.rare"] = "Selten"
Localization["inventory.rarity.epic"] = "Episch"
Localization["inventory.rarity.legendary"] = "Legendär"
Localization["inventory.stack_size"] = "Anzahl: $1"
Localization["inventory.drop"] = "Item Ablegen"
Localization["itemType.consealedWeapon"] = "Versteckte Waffe"
Localization["itemType.consealedWeapon_description"] = "Sollte diese Waffe eine versteckte Waffe sein?"
Localization["itemType.backpackSlots"] = "Inventar Slots"
Localization["itemType.backpackSlots_description"] = "Wie viele Inventarslots sollte dieses Item geben? (Item mit dem Höchsten Wert wird genutzt)"
Localization["itemType.invalid_backpack_slots"] = "Maximal $1 Inventarslots"
Localization["inventory.log_category"] = "Inventar"
Localization["inventory.log_item_added"] = "$1 ($2) hat $3 in sein Inventar hinzugefügt."
Localization["inventory.log_item_removed"] = "$1 ($2) hat $3 aus seinem Inventar entfernt."
Localization["inventory.log_item_dropped"] = "$1 ($2) hat $3 fallengelassen."
Localization["inventory.no_backpack_space"] = "Keine Inventarslots verfügbar."
Localization["inventory.no_equipment_space"] = "Keine Ausrüstungsslots verfügbar."
Localization["inventory.invalid_slot_type"] = "Ungültiger Slot Typ"
Localization["inventory.container"] = "Behälter"
Localization["inventory.cannot_drop_container"] = "Der Behälter ist bereits auf dem Boden."
Localization["inventory.maxWeight"] = "Maximales Gewicht"
Localization["inventory.maxWeight_description"] = "Maximales Gewicht, dass von eiem Charakter mit diesem Rang getragen werden kann."
Localization["inventory.weightBonus"] = "Gewicht Bonus"
Localization["inventory.weightBonus_description"] = "Zusätzliches Gewicht, dass zum maximalen Gewicht des Charakters hinzugefügt wird."
Localization["itemType.weight"] = "Gewicht"
Localization["itemType.weight_description"] = "Gewicht des Items"
Localization["inventory.invalid_inventory"] = "Ungültiges Inventar"
Localization["inventory.invalid_item_list"] = "Ungültige Item Liste"
Localization["inventory.empty"] = "Behälter is leer"
Localization["inventory.invalid_container_entity"] = "Ungültige Behälter Entity"
Localization["inventory.invalid_container_item"] = "Ungültige Behälter Item"
Localization["inventory.container_not_backpack"] = "Nicht Rucksack Slot"
Localization["inventory.container_full"] = "Behälter ist voll"
Localization["inventory.weight"] = "Gewicht: $1kg"
Localization["inventory.corpse"] = "Leiche"
Localization["inventory.invalid_character"] = "Ungültiger Charakter"
Localization["inventory.container_item_swapped"] = "Behälter kann nicht bewegt werden."
Localization["inventory.invalid_target_character"] = "Ungültiger Ziel-Charakter"
Localization["inventory.armor_move"] = "Du kannst Rüstung nicht so Bewegen."
Localization["inventory.invalid_container_inventory"] = "Ungültiges Behälter Inventar"
Localization["inventory.container_slot"] = "Behälter"
Localization["itemType.species"] = "Spezies Whitelist"
Localization["itemType.species_description"] = "Welche Spezies können diese Item verwenden?"
Localization["inventory.species_not_allowed"] = "Deine Spezies kann diese Rüstung nicht tragen."
Localization["inventory.unequip_other_first"] = "Du musst andere Items zuerst ausziehen."
Localization["inventory.wont_exist"] = "Dieser Slot wird nicht weiterhin existieren wenn du dies tust."
Localization["inventory.too_many_drops"] = "$1 ($2) versucht viele Items in kurzer Zeit abzuwerfen!"
-- Inventory Storage
Localization["inventory_storage.title"] = "Lager"
Localization["inventory_storage.item_valuable"] = "Item Wertvoll. Löschen Verhindert."
Localization["inventory_storage.entity"] = "Lager"
Localization["inventory_storage.type_supply_utility"] = "Zusatz-Versorgung"
Localization["inventory_storage.type_supply_armour"] = "Rüstungs-Versorgung"
Localization["inventory_storage.type_supply_weapon"] = "Waffen-Versorgung"
Localization["inventory_storage.type_supply"] = "Fraktionsversorgung"
Localization["inventory_storage.type_faction"] = "Fraktionslager"
Localization["inventory_storage.type_private"] = "Privatlager"
Localization["inventory_storage.type_trash"] = "Müll (Löscht Items)"
Localization["inventory_storage.other_item_valuable"] = "Wertvolles Item würde seinen Slot verlieren."
-- Inventory Private
Localization["inventory_private.rank_priv"] = "Privatlager Freischalten"
Localization["inventory_private.rank_priv_description"] = "Sollten Mitglieder dieses Ranges, Unabhängig von der Fraktion, Zugriff auf das Privatlager haben?"
Localization["inventory_private.faction_priv"] = "Privatlager Freischalten"
Localization["inventory_private.faction_priv_description"] = "Sollten alle Mitglieder dieser Fraktion Zugriff auf das Privatlager haben?"
Localization["inventory_private.log_category"] = "Privatlager"
Localization["inventory_private.log_item_added"] = "$1 ($2) hat $3 in sein Privatlager hinzugefügt."
Localization["inventory_private.log_item_removed"] = "$1 ($2) hat $3 aus seinem Privatlager entfernt."
Localization["inventory_private.no_storage"] = "Privatlager nicht verfügbar"
Localization["inventory_private.storage_full"] = "Privatlager ist voll."
Localization["inventory_private.take_multiple"] = "Mehrere Items nehmen"
Localization["inventory_private.take_multiple_long"] = "Wie viele Items willst du nehmen?"
Localization["inventory_private.not_stackable"] = "Item nicht stapelbar"
Localization["inventory_private.invalid_ammount"] = "Ungültige Anzahl"
Localization["inventory_private.invalid_context"] = "Ungültiger Kontext"
-- Inventory Faction
Localization["inventory_faction.hasFacSto"] = "Fraktionslager freischalten"
Localization["inventory_faction.hasFacSto_description"] = "Sollte diese Fraktion ein Fraktionslager haben?"
Localization["inventory_faction.type_faction_sub"] = "Fraktionslager: $1"
Localization["inventory_faction.permission_access"] = "Fraktionslager - Zugriff"
Localization["inventory_faction.permission_logs"] = "Fraktionslager - Logs"
Localization["inventory_faction.log_category"] = "Fraktionslager"
Localization["inventory_faction.log_item_added"] = "$1 ($2) hat $3 in das $4 Fraktionslager hinzugefügt."
Localization["inventory_faction.log_item_removed"] = "$1 ($2) hat $3 aus dem $4 Fraktionslager entfernt."
Localization["inventory_faction.log_item_swapped"] = "$1 ($2) hat $3 aus dem $4 Fraktionslager in das $5 Fraktionslager verschoben."
Localization["faction_inventory.log_filter"] = "$1 Fraktionslager"
Localization["inventory_faction.invalid_faction_id"] = "Ungültige Fraktions Id"
Localization["inventory_faction.invalid_faction"] = "Ungültige Fraktion"
Localization["inventory_faction.no_storage"] = "Fraktionslager nicht verfügbar."
Localization["inventory_faction.storage_full"] = "Fraktionslager ist voll."
-- Inventory Loadout
Localization["inventory_loadout.type"] = "Ausrüstungs-Presets"
Localization["inventory_loadout.equip"] = "Ausrüsten"
Localization["inventory_loadout.equip_confirm"] = "Bist du dir sicher, dass du diese Ausrüstung anlegen willst?"
Localization["inventory_loadout.save"] = "Speichern"
Localization["inventory_loadout.save_confirm"] = "Bist du dir sicher, dass du diese Ausrüstung überschreiben willst?"
Localization["inventory_loadout.private"] = "Privat-Ausrüstung"
Localization["inventory_loadout.faction"] = "Fraktions-Ausrüstung"
Localization["inventory_loadout.invalid_rank"] = "Ungültiger Rang"
Localization["inventory_loadout.permission"] = "Loadout ändern"
Localization["inventory_loadout.no_permission"] = "Zugriff verweigert."
Localization["inventory_loadout.invalid_faction"] = "Ungültige Fraktion"
Localization["inventory_loadout.invalid_loadout"] = "Ungülte Ausrüstung"
-- Inventory Money
Localization["inventory_money.more_item_types"] = "Mehr als ein Geld Item Typ"
Localization["inventory_money.invalid_item_type"] = "Ungültiger Geld Item Typ"
Localization["inventory_money.invalid_ammount"] = "Ungülte Geld Anzahl"
Localization["inventory.no_space"] = "Kein Platz"
Localization["inventory_money.no_money"] = "Kein Geld"
Localization["inventory_money.item_class_money"] = "Geld"
Localization["inventory_money.merge"] = "Alles Geld im Inventar Stacken"
Localization["inventory_money.split"] = "Geld auftrennen"
Localization["inventory_money.split_description"] = "Wie viel Geld willst du auftrennen?"
Localization["inventory_money.givemoney_info"] = "Gibt Geld an den Spieler."
Localization["inventory_money.givemoney"] = "Geld vergeben"
Localization["inventory_money.givemoney_text"] = "Du hast $1 $2 Credits gegeben."
Localization["inventory_money.not_number"] = "$1 ist keine Zahl!"
Localization["inventory_money.not_player"] = "Spieler nicht gefunden!"
-- Inventory Shop
Localization["inventory_shop.title"] = "Shop"
Localization["inventory_shop.price_short"] = "Preis: $1"
Localization["shopEntry.name"] = "Shop Eintrag"
Localization["shopEntry.new"] = "Neuer Shop Eintrag"
Localization["shopEntry.duplicate_long"] = "Shop Eintrag duplizieren"
Localization["shopEntry.delete"] = "Shop Eintrag löschen"
Localization["shopEntry.delete_warning"] = "Shop Eintrag wird unwiderruflich gelöscht!"
Localization["shopEntry.add"] = "Shop Eintrag hinzufügen"
Localization["shopEntry.save"] = "Shop Eintrag speichern"
Localization["shopEntry.shopClass_name"] = "Shop Klasse"
Localization["shopEntry.shopClass_description"] = "Klasse des Shops. Kontrolliert die Funktion des Shops"
Localization["shopEntry.price_name"] = "Preis"
Localization["shopEntry.price_description"] = "Der grundlegende Preis des Shop Eintrages."
Localization["shopEntry.maxStock_name"] = "Maximaler Vorrat"
Localization["shopEntry.maxStock_description"] = "Maximaler Vorrat des Shop Eintrages."
Localization["shopEntry.stockRegen_name"] = "Vorrat Nachschub"
Localization["shopEntry.stockRegen_description"] = "Wie viel Vorrat an einem Tag regeneriert wird."
Localization["shopEntry.package"] = "Shopeintragsdaten"
Localization["inventory_shop.item"] = "Item"
Localization["shopEntry.itemType_name"] = "Item Typ"
Localization["shopEntry.itemType_description"] = "Item Typ, den man von diesem Shop Eintrag erhält."
Localization["shopEntry.itemVariant_name"] = "Item Varianten"
Localization["shopEntry.itemVariant_description"] = "Item Varianten, die man von diesem Shop Eintrag erhält."
Localization["inventory_shop.invalid_shop_class"] = "Ungültige Shop Klasse"
Localization["inventory_shop.invalid_price"] = "Ungülter Preis"
Localization["inventory_shop.invalid_max_stock"] = "Ungülter Maximaler Vorrat"
Localization["inventory_shop.invalid_stock"] = "Ungültiger Vorrat"
Localization["inventory_shop.invalid_stock_regen"] = "Ungültiger Vorrat Nachschub"
Localization["inventory_shop.invalid_last_regen"] = "Ungültiger Letzter Nachschub"
Localization["inventory_shop.invalid_item_type"] = "Ungülter Item Typ"
Localization["inventory_shop.invalid_item_variant"] = "Ungülte Item Variante"
Localization["inventory_shop.not_enough_money"] = "Nicht genug Geld!"
Localization["inventory_shop.money_disappeared"] = "Dein Geld ist verschwunden! BITTE MELDEN!"
Localization["inventory_shop.entity"] = "Shop"
Localization["inventory_shop.money"] = "Geld (Inventar):"
Localization["inventory_shop.storage_money"] = "Geld (Lager):"
Localization["inventory_shop.total"] = "Total Preis:"
Localization["inventory_shop.billing"] = "Warenkorb:"
Localization["inventory_shop.free"] = "Kostenlos"
Localization["inventory_shop.itemVariant_random"] = "Zufällige Variante"
Localization["inventory_shop.name_random"] = "$1 (Zufall)"
Localization["inventory_shop.buy"] = "Kaufen"
Localization["shopEntry.category_name"] = "Kategorie"
Localization["shopEntry.category_description"] = "Kategorie des Shop Eintrages"
Localization["inventory_shop.seller"] = "Verkäufer"
Localization["shopEntry.sellerOnly_name"] = "Nur Verkäufer"
Localization["shopEntry.sellerOnly_description"] = "Der Shop Eintrag kamm nur von Verkäufern gekauft werden."
Localization["shopEntry.sellerPrice_name"] = "Verkäufer Preis"
Localization["shopEntry.sellerPrice_description"] = "Der Preis des Shop Eintrages, wenn er von einem Verkäufer gekauft wird."
Localization["shopEntry.seller_name"] = "Verkäufer"
Localization["shopEntry.seller_description"] = "Sind Charaktere dieses Ranges ein Verkäufer?"
Localization["shopEntry.shopEntries_name"] = "Verkäufer Shop Einträge"
Localization["shopEntry.shopEntries_description"] = "Die Shop Einträge, auf die der Verkäufer exklusiven Zugriff hat."
Localization["inventory_shop.no_access"] = "Du hast keinen Zugriff auf diesen Schop Eintrag."
Localization["inventory_shop.invalid_seller_only"] = "Ungültiger Nur Verkäufer"
Localization["inventory_shop.invalid_seller_price"] = "Ungültiger Verkäufer Preis"
Localization["inventory_shop.invalid_seller"] = "Ungültiger Verkäufer"
Localization["inventory_shop.invalid_shop_entries"] = "Ungültige Verkäufer Shop Einträge"
Localization["inventory_shop.log_category"] = "Shop"
Localization["inventory_shop.log_buy"] = "$1 ($2) hat $3 für $4 gekauft."
Localization["inventory_shop.out_of_stock"] = "Vorrat Aufgebraucht"
Localization["inventory_shop.too_many_items"] = "Du kannst maximal 10 Dinge auf einmal kaufen."
-- Unarmed
Localization["unarmed.swep"] = "Unbewaffnet"
Localization["unarmed.category"] = "Unbewaffnet SWEP"
Localization["unarmed.pickup_corpse"] = "$1 ($2) hebt die Leiche von $3 ($4) auf."
Localization["unarmed.pickup"] = "$1 ($2) hebt eine Leiche auf."
Localization["unarmed.drop_corpse"] = "$1 ($2) legt die Leiche von $3 ($4) ab."
Localization["unarmed.drop"] = "$1 ($2) legt eine Leiche ab."
Localization["unarmed.pick_up_shoulder"] = "Auf Schulter nehmen"
Localization["unarmed.pick_up_title"] = "Auf Schulter nehmen"
Localization["unarmed.pick_up_confirm"] = "Willst du auf die Schulter genommen werden?"
Localization["unarmed.animations"] = "Animationen"
-- Morgue
Localization["morgue.title"] = "Leichenkammer"
Localization["morgue.remove_body_bag"] = "Leichensack entfernen"
Localization["morgue.get_body_bag"] = "Leichensack nehmen"
Localization["morgue.pickup_body"] = "Leiche nehmen"
Localization["morgue.bodybag"] = "Leichensack"
Localization["morgue.category"] = "Leichenkammer"
Localization["morgue.store_corpse"] = "$1 ($2) lagert die Leiche von $3 ($4) in einer Leichenkammer."
Localization["morgue.store"] = "$1 ($2) lagert eine Leiche in einer Leichenkammer."
Localization["morgue.retrieve"] = "$1 ($2) entfernt eine Leiche aus einer Leichenkammer."
Localization["morgue.entity"] = "Leichenkammer"
-- Morgue
Localization["event.not_whitelisted"] = "Eventcharakter nicht Whitelisted."
-- Ammosystem
Localization["ammosystem.equipment"] = "Munitionskiste"
Localization["ammosystem.weight"] = "Gewicht"
Localization["ammosystem.weight_maxweight"] = "Max Gewicht"
Localization["ammosystem.re_equip"] = "Munitionskiste"
Localization["ammosystem.re_equip_message"] = "Munition Ausgerüstet"
--gamemodes/egmrp/gamemode/core/localization/sh_localization.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--      Shared | Localization        --
---------------------------------------

-- Returns the localization for the given key of the set language.
-- Also replaces any mention of $X with the X+1 parameter given to the function.
--
-- @param String key
-- @param? vararg params
-- @return String locString
function egmt(key, ...)
	local locString = Localization[key]
	if isstring(locString) and locString ~= "" then
		for k, param in pairs({...}) do
			if not isstring(param) and not isnumber(param) then continue end

			locString = string.Replace(locString, "$" .. k, param)
		end

		return locString
	end

	return "[MISSING] " .. key
end
--gamemodes/egmrp/gamemode/core/propertymodel/sh_propertymodel.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--      Shared | Property model      --
---------------------------------------

--[[
    Table: PropertyModel.Cache
    PropertyModels can be cached to access them later.
]]
PropertyModel.Cache = PropertyModel.Cache or {}


--[[
    String: PropertyModel.Name
    Used for log messages and networking.
]]
PropertyModel.Name = ""


--[[
    Table: PropertyModel.Data
    The Data of the PropertyModel

    Notes:
        The data of a propertymodel is similar to it's properties, with some differences:

        - There are no default values for the data.
        - It is saved in the sql table, not in the sql properties table (it is static).
        Therefore any change to the data table needs to manually alter the sql table.
        - The data is not accessed with propertyModel:GetProperty(key), but with propertyModel:Get(key).
        - Data is not rendered in the property list.

        One data entry has the following structure:

        String - key = Table data
        String - data.sqlKey - the key in the sql database
        String - data.type - the type of the value: string, number, boolean, table or color
        Function - data.validate(propertyModel, value) - returns whether the value is valid, true by default
        Function - data.sendToClient(propertyModel, ply) - whether to send the property to the client, false by default.
]]
PropertyModel.Data = {}

--[[
    String: PropertyModel.IdKey
    The key in PropertyModel.Data that represents the propertymodel id.
    The value needs to be a number (max 32 bit) and the sql field of this data needs to be unique.
]]
PropertyModel.IdKey = "id"

--[[
    Table: PropertyModel.Properties
    Every attribute of a datamodel needs to be added as a property.
]]
PropertyModel.Properties = {}

--[[
    Bool: PropertyModel.PropertiesAllowedOnCreationWhitelist
    Optional whitelist to specify which property models are allowed to set on creation.
]]
PropertyModel.PropertiesAllowedOnCreationWhitelist = false

--[[
    Function: PropertyModel:HasData
    Checks whether the key exists in the property model data.

    Parameters:
        key - string

    Returns:
        exists - boolean
]]
function PropertyModel:HasData(key)
    return istable(self.Data[key])
end

--[[
    Function: PropertyModel:GetData
    Returns the data of the propery model.

    Parameters:
        key - string

    Returns:
        data - table
]]
function PropertyModel:GetData(key)
    if key then
        return self.Data[key]
    end

    return self.Data
end

--[[
    Function: PropertyModel:GetIdKey
    Returns the name of the key for the id.

    Returns:
        key - string
]]
function PropertyModel:GetIdKey()
    return self.IdKey
end

--[[
    Function: PropertyModel:GetSQLIdKey
    Returns the name of the key for the id.

    Returns:
        sqlKey - string
]]
function PropertyModel:GetSQLIdKey()
    return self.Data[self.IdKey].sqlKey
end

function PropertyModel:AddData(key, type, sqlKey, sqlDefinition, validate, sendToClient)
    self.Data[key] = {
        type = type,
        sqlKey = sqlKey,
        sqlDefinition = sqlDefinition,
        validate = validate,
        sendToClient = sendToClient,
    }
end

-- Add id data.
PropertyModel:AddData(PropertyModel.IdKey, "number", "id", "INT PRIMARY KEY AUTO_INCREMENT",
function(playerData, value)
    if not isnumber(value) or value <= 0 then
        return false, egmt("player.invalid_id")
    end

    return true
end,
function(playerData, ply)
    return true
end)

-- Add created data.
PropertyModel:AddData("created", "number", "created", "INT NOT NULL", -- TODO: For some reason creating a propertymodel without this data does not fail with error, but fails silently.
function(playerData, value)
    if not isnumber(value) or value <= 0 then
        return false, egmt("player.invalid_created")
    end

    return true
end,
function(playerData, ply)
    return true
end)

--[[
    Function: PropertyModel:AddProperty

    Adds a new property to the propertymodel.
    Properties are used to save variables on a propertymodel,
    that are automatically saved to database using the Save() method.

    Parameters:
        key - index - needs to be unique and is limited to 16 characters max.
        type - string
        default - string
        validate(propertyModel, value) - Function - returns true by default.
        sendToClient(propertyModel, ply) - Function - needs to be the same on server and client. false by default.

    Returns:
        success - bool - false on invalid default value type (only string, boolean, number, table)
]]
function PropertyModel:AddProperty(key, type, default, validate, sendToClient)
    if not sendToClient then
        sendToClient = function() return false end
    end

	-- Check, if the key is bigger than 16 characters.
	if string.len(key) > 16 then
		LogError("PropertyModel:AddProperty: Key is too long! Key: " .. key)

		return false
	end

    self.Properties[key] = {
        type = type,
        default = default,
        validate = validate,
        sendToClient = sendToClient
    }

    return true
end

--[[
    Function: PropertyModel:GetProperties

    Returns every added property.

    Returns:
        properties - table
]]
function PropertyModel:GetProperties()
    return self.Properties
end

--[[
    Function: PropertyModel:HasProperty

    Checks whether the property with the given key exists.

    Parameters:
        key - string

    Returns:
        exists - bool
]]
function PropertyModel:HasProperty(key)
    return istable(self.Properties[key])
end

--[[
    Function: PropertyModel:GetProperty

    Returns the property by the given key.

    Parameters:
        key - string

    Returns:
        property - table
]]
function PropertyModel:GetProperty(key)
    return self.Properties[key]
end

--[[
    Function: PropertyModel:CanPlayerCreate

    Checks whether a player is able to create a new property model.

    Parameters:
        ply - Player
        data - table
        properties - table

    Returns:
        canCreate - bool
        error    - string
]]
function PropertyModel:CanPlayerCreate(ply, data, properties)
    -- Check property whitelist. This whitelist cannot be bypassed by a hook.
    if self.PropertiesAllowedOnCreationWhitelist then
        for k, v in pairs(properties) do
            if not table.HasValue(self.PropertiesAllowedOnCreationWhitelist, k) then
                return false, egmt("propertymodel.not_creation_whitelist", k)
            end
        end
    end

    -- Check hooks. Creating can be allowed or disallowed in a hook.
    local canCreate, error = hook.Run(self.Name .. ".CanPlayerCreate", ply, data, properties)
    if canCreate ~= nil then
        return canCreate, error
    end

    return true
end

--[[
    Function: PropertyModel:InitCreationNetworking

    Adds net messages and receivers for creating a property model.
]]
function PropertyModel:InitCreationNetworking()
    if self.CreationNetworkingInitialized then return end

    self.CreationNetworkingInitialized = true

    -- Add net receivers for the client to be able to create property models.
    if SERVER then
        util.AddNetworkString(self.Name .. ".Create")
        util.AddNetworkString(self.Name .. ".CreationSuccess")
        util.AddNetworkString(self.Name .. ".CreationError")

        net.Receive(self.Name .. ".Create", function(_, ply)
            local len = net.ReadInt(32)
            local info = DecompressTable(net.ReadData(len))
            local data = self:FixDataTypes(info.data)
            local properties = self:FixPropertiesTypes(info.properties)

            local canCreate, error = self:CanPlayerCreate(ply, data, properties)
            if not canCreate then
                net.Start(self.Name .. ".CreationError")
                    net.WriteTable({error})
                net.Send(ply)

                return
            end

            -- Override Creation time serverside.
            data.created = os.time()

            self:Create(data, properties, function(success, propertyModel)
                if not IsValid(ply) then return end

                if not success then
                    net.Start(self.Name .. ".CreationError")
                        net.WriteTable(propertyModel)
                    net.Send(ply)
                else
                    net.Start(self.Name .. ".CreationSuccess")
                    net.Send(ply)

                    hook.Run(self.Name .. ".CreatedByPlayer", propertyModel, ply)
                end
            end)
        end)
    end

    if CLIENT then
        -- Handle newly created property models.
        net.Receive(self.Name .. ".Create", function()
            local len = net.ReadInt(32)
            local data = DecompressTable(net.ReadData(len))

            local propertyModel = self:Load(data.data, data.properties)
            propertyModel:Cache()

            hook.Run(self.Name .. ".Created", propertyModel)
        end)

        -- Handle creation success.
        net.Receive(self.Name .. ".CreationSuccess", function()
            hook.Run(self.Name .. ".CreationSuccess")
        end)

        -- Handle creation errors.
        net.Receive(self.Name .. ".CreationError", function()
            local error = net.ReadString()

            hook.Run(self.Name .. ".CreationError", error)
        end)
    end
end


--[[
    Function: PropertyModel:InitEditNetworking

    Adds net messages and receivers for editing a property model.
]]
function PropertyModel:InitEditNetworking()
    if self.EditNetworkingInitialized then return end

    self.EditNetworkingInitialized = true

    -- Add net receivers for the client to be able to edit data and properties of property models.
    if SERVER then
        util.AddNetworkString(self.Name .. ".DataChanged")
        util.AddNetworkString(self.Name .. ".EditData")
        util.AddNetworkString(self.Name .. ".EditDataSuccess")
        util.AddNetworkString(self.Name .. ".EditDataError")

        util.AddNetworkString(self.Name .. ".PropertyChanged")
        util.AddNetworkString(self.Name .. ".EditProperties")
        util.AddNetworkString(self.Name .. ".EditPropertiesSuccess")
        util.AddNetworkString(self.Name .. ".EditPropertiesError")

        net.Receive(self.Name .. ".EditData", function(_, ply)
            local id = net.ReadInt(32)
            local len = net.ReadInt(32)
            local data = self:FixDataTypes(DecompressTable(net.ReadData(len)))
            local propertyModel = self:GetCached(id)

            if propertyModel and propertyModel:CanPlayerEditMultipleData(ply, data) then
                local editSuccess, errors = propertyModel:SetMultipleData(data)
                if editSuccess then
                    propertyModel:SaveData(table.GetKeys(data))

                    net.Start(self.Name .. ".EditDataSuccess")
                    net.Send(ply)

                    hook.Run(self.Name .. ".EditedByPlayer", propertyModel, ply, data)

                    return
                end

                net.Start(self.Name .. ".EditDataError")
                    net.WriteTable(errors)
                net.Send(ply)

                return
            end

            net.Start(self.Name .. ".EditDataError")
            net.Send(ply)
        end)

        net.Receive(self.Name .. ".EditProperties", function(_, ply)
            local id = net.ReadInt(32)
            local len = net.ReadInt(32)
            local properties = self:FixPropertiesTypes(DecompressTable(net.ReadData(len)))
            local propertyModel = self:GetCached(id)

            if propertyModel and propertyModel:CanPlayerEditProperties(ply, properties) then
                local editSuccess, errors = propertyModel:SetProperties(properties)
                if editSuccess then
                    propertyModel:SaveProperties(table.GetKeys(properties))

                    net.Start(self.Name .. ".EditPropertiesSuccess")
                    net.Send(ply)

                    hook.Run(self.Name .. ".EditedByPlayer", propertyModel, ply, nil, properties)

                    return
                end

                net.Start(self.Name .. ".EditPropertiesError")
                    net.WriteTable(errors)
                net.Send(ply)

                return
            end

            net.Start(self.Name .. ".EditPropertiesError")
            net.Send(ply)
        end)
    end

    if CLIENT then
        -- Handle data changes.
        net.Receive(self.Name .. ".DataChanged", function()
            local id = net.ReadInt(32)
            local key = net.ReadString()
            local value = net.ReadType()
            local propertyModel = self:GetCached(id)

            if propertyModel then
                propertyModel:SetData(key, value)
            end
        end)

        -- Handle edit data success.
        net.Receive(self.Name .. ".EditDataSuccess", function()
            hook.Run(self.Name .. ".EditDataSuccess")
        end)

        -- Handle edit data errors.
        net.Receive(self.Name .. ".EditDataError", function()
            local errors = net.ReadTable()

            hook.Run(self.Name .. ".EditDataError", errors)
        end)

        -- Handle property changes.
        net.Receive(self.Name .. ".PropertyChanged", function()
            local id = net.ReadInt(32)
            local key = net.ReadString()
            local value = net.ReadType()
            local propertyModel = self:GetCached(id)

            local property = self:GetProperty(key)
            if property and not self:CheckType(value, property.type) then
                value = self:FixValueType(value, property.type)
            end

            if propertyModel then
                propertyModel:SetProperty(key, value)
            end
        end)

        -- Handle edit properties success.
        net.Receive(self.Name .. ".EditPropertiesSuccess", function()
            hook.Run(self.Name .. ".EditPropertiesSuccess")
        end)

        -- Handle edit properties errors.
        net.Receive(self.Name .. ".EditPropertiesError", function()
            local errors = net.ReadTable()

            hook.Run(self.Name .. ".EditPropertiesError", errors)
        end)
    end
end

--[[
    Function: PropertyModel:InitDeletionNetworking

    Adds net messages and receivers for deleting a property model.
]]
function PropertyModel:InitDeletionNetworking()
    if self.DeletionNetworkingInitialized then return end

    self.DeletionNetworkingInitialized = true

    -- Add net receivers for the client to be able to delete property models.
    if SERVER then
        util.AddNetworkString(self.Name .. ".Delete")
        util.AddNetworkString(self.Name .. ".DeletionSuccess")
        util.AddNetworkString(self.Name .. ".DeletionError")

        net.Receive(self.Name .. ".Delete", function(len, ply)
            local id = net.ReadInt(32)
            local propertyModel = self:GetCached(id)

            if propertyModel then
                if not propertyModel:CanPlayerDelete(ply) then
                    net.Start(self.Name .. ".DeletionError")
                    net.Send(ply)

                    return
                end

                propertyModel:Delete()

                net.Start(self.Name .. ".DeletionSuccess")
                net.Send(ply)

                hook.Run(self.Name .. ".DeletedByPlayer", propertyModel, ply)
            else
                net.Start(self.Name .. ".DeletionError")
                net.Send(ply)
            end
        end)
    end

    if CLIENT then
        -- Handle deleted property models.
        net.Receive(self.Name .. ".Delete", function()
            local id = net.ReadInt(32)
            local propertyModel = self:GetCached(id)

            if propertyModel then
                hook.Run(self.Name .. ".Delete", propertyModel)

                propertyModel:RemoveFromCache()
            end
        end)

        -- Handle deletion success.
        net.Receive(self.Name .. ".DeletionSuccess", function()
            hook.Run(self.Name .. ".DeletionSuccess")
        end)

        -- Handle deletion errors.
        net.Receive(self.Name .. ".DeletionError", function()
            hook.Run(self.Name .. ".DeletionError")
        end)
    end
end

--[[
    Function: PropertyModel:Init

    Initializes a new property model instance.

    Returns:
        propertyModel - table
]]
function PropertyModel:Init()
    local propertyModel = self

    local propertyModelInstance = setmetatable({}, self.Meta)
    propertyModelInstance.data = {}
    propertyModelInstance.properties = {}

    -- Used to access the property model from a property model instance.
    function propertyModelInstance:GetModel()
        return propertyModel
    end

    -- Set default properties, without validating.
    for k, property in pairs(self:GetProperties()) do
        if SERVER then
            propertyModelInstance:InitProperty(k, property.default, false)
        else
            propertyModelInstance:InitProperty(k, property.default, true)
        end
    end

    return propertyModelInstance
end

--[[
    Function: PropertyModel:CheckType

    Checks whether the value is of the given type.

    Parameters:
        value - any
        type - string - string, number, boolean, color or table.

    Returns:
        isType - bool
]]
function PropertyModel:CheckType(value, valueType)
    local override = hook.Run("PropertyModel.CheckType", value, valueType)
    if override ~= nil then
        return override
    end

    if valueType == "string" and not isstring(value)
        or valueType == "number" and not isnumber(value)
        or valueType == "boolean" and not isbool(value)
        or valueType == "vector" and not isvector(value)
        or valueType == "color" and not IsColor(value)
        or valueType == "table" and not istable(value)
    then
        return false
    end

    return true
end

--[[
    Function: PropertyModel:FixValueType

    Converts the value string to the given type.
    This is used when loading the data from database for example.

    Parameters:
        value - string
        type - string - number, boolean, color or table.

    Returns:
        convertedValue - any
]]
function PropertyModel:FixValueType(value, valueType)
    if value == "nil" and valueType ~= "string" then
        -- Convert nil values stored in database.
        value = nil
    elseif valueType == "string" then
        value = tostring(value)
    elseif valueType == "number" then
        value = tonumber(value)
    elseif valueType == "boolean" then
        value = tobool(value)
    elseif valueType == "vector" then
        value = Vector(value) -- will automatically try to parse strings.
    elseif valueType == "color" and isstring(value) then
        value = string.ToColor(value)
    elseif valueType == "table" and isstring(value) then
        value = util.JSONToTable(value)
    end

    local override = hook.Run("PropertyModel.FixValueType", value, valueType)
    if override ~= nil then
        return override
    end

    return value
end

--[[
    Function: PropertyModel:FixDataTypes

    Fixes all value types of the data table.

    Parameters:
        data - table

    Returns:
        data - table
]]
function PropertyModel:FixDataTypes(data)
    for k, v in pairs(data) do
        local info = self:GetData(k)

        if info and not self:CheckType(v, info.type) then
            data[k] = self:FixValueType(v, info.type)
        end
    end

    return data
end

--[[
    Function: PropertyModel:FixPropertiesTypes

    Fixes all value types of the properties table.

    Parameters:
        properties - table

    Returns:
        properties - table
]]
function PropertyModel:FixPropertiesTypes(properties)
    for k, v in pairs(properties) do
        local property = self:GetProperty(k)

        if property and not self:CheckType(v, property.type) then
            properties[k] = self:FixValueType(v, property.type)
        end
    end

    return properties
end

--[[
    Function: PropertyModel:ValueToString

    Converts the type of the value to the type of the property.

    Parameters:
        value - any

    Returns:
        convertedValue - any
]]
function PropertyModel:ValueToString(value)
    if IsColor(value) then
        return string.FromColor(value)
    elseif istable(value) then
        return util.TableToJSON(value)
    end

    return tostring(value)
end

--[[
    Function: PropertyModel:ValuesToString

    Converts multiple values at once to a string.

    Parameters:
        values - table

    Returns:
        values - table
]]
function PropertyModel:ValuesToString(values)
    for k, v in pairs(values) do
        values[k] = self:ValueToString(v)
    end

    return values
end

--[[
    Function: PropertyModel:GetCache

    Returns the whole property model cache.

    Returns:
        cache - table
]]
function PropertyModel:GetCache()
    return self.Cache
end

--[[
    Function: PropertyModel:GetCached

    Returns the cached property model with the given id.

    Parameters:
        id - number

    Returns:
        propertyModel - table
]]
function PropertyModel:GetCached(id)
    local cached = hook.Run(self.Name .. ".GetCached", id)

    if cached == nil then
        return self.Cache[id]
    else
        return cached
    end
end
--gamemodes/egmrp/gamemode/core/propertymodel/propertylist/dropdown.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--       Client | Property List      --
---------------------------------------

function PROPERTY_TYPE:CreatePanel(propertyPanel, propertyListData, propertyModel, canEdit)
	local key = propertyListData.key

	-- No Fallback value set, since there is no common type. propertyListData.default should be set anyways.
	local currentValue = propertyListData.default
	if propertyModel then
		currentValue = propertyModel:GetProperty(key, currentValue)
	end

	local dropdownProperty = vgui.Create("EGMComboBox", propertyPanel)
	propertyPanel.DropdownProperty = dropdownProperty

	dropdownProperty:SetHeight(ScrH() * 0.025)
	dropdownProperty:Dock(FILL)
	dropdownProperty:SetDisabled(not canEdit)
	dropdownProperty:SetDropDownHeight(ScrH() * 0.025)
	dropdownProperty:SetSortItems(false)

	dropdownProperty.Value = currentValue

	for _, choice in SortedPairs(propertyListData.values) do
		-- Don't hide the currently selected value, since the UI breaks otherwise.
		if currentValue ~= choice.data and
		-- Hide the coices, the player can't edit.
		propertyModel and
		not propertyModel:CanPlayerEditProperty(LocalPlayer(), key, choice.data) then
			continue
		end

		dropdownProperty:AddChoice(choice.text, choice.data, choice.data == dropdownProperty.Value)
	end

	function dropdownProperty:OnSelect(index, value, data)
		self.Value = data

		-- Allows the user to add a custom function to be called when the value is changed.
		if isfunction(self.OnSelectCustom) then
			self:OnSelectCustom(index, value, data)
		end
	end

	if not canEdit then
		dropdownProperty:SetMainColor(UI.BackgroundColor2)
	end
end

function PROPERTY_TYPE:GetValue(propertyPanel)
	if not IsValid(propertyPanel.DropdownProperty) then
		return 0
	end

	return propertyPanel.DropdownProperty.Value
end

-- Check, if the player can edit the propertyListData in some way.
--
-- @param table propertyListData
-- @param Player ply
-- @param PropertyModel propertyModel
function PROPERTY_TYPE:CanEdit(ply, propertyListData, propertyModel)
	-- Check if the player can edit the propertyListData at all.
	for _, choice in SortedPairs(propertyListData.values) do
		if propertyModel:CanPlayerEditProperty(ply, propertyListData.key, choice.data) then
			return true
		end
	end

	return false
end
--gamemodes/egmrp/gamemode/core/propertymodel/propertylist/list.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--       Client | Property List      --
---------------------------------------

function PROPERTY_TYPE:CreatePanel(propertyPanel, propertyListData, propertyModel, canEdit)
	local key = propertyListData.key

	local currentValue = propertyListData.default or {}
	if propertyModel then
		currentValue = propertyModel:GetProperty(key, currentValue)
	end

	local tableProperty = vgui.Create("EGMListView", propertyPanel)
	propertyPanel.TableProperty = tableProperty

	tableProperty:SetHeight(ScrH() * 0.2)
	tableProperty:Dock(FILL)
	tableProperty:SetHeaderHeight(0)
	tableProperty:SetDataHeight(ScrH() * 0.02)
	tableProperty.dataFont = "EGMText6"
	tableProperty.headerFont = "EGMText6"

	if not canEdit then
		tableProperty:SetLineSelectedBgColor(Color(80, 80, 80))
	end

	-- Add column for the propertyListData name.
	tableProperty:AddCustomColumn(propertyListData.name)

	-- Select existing or default values
	tableProperty.SelectedValues = {}
	for _, v in pairs(currentValue) do
		table.insert(tableProperty.SelectedValues, v)
	end

	for i, value in SortedPairs(propertyListData.values) do
		local text = value
		local data = value
		if istable(value) then
			text = value.text
			data = value.data
		end

		local line = tableProperty:AddCustomLine(text)
		line.Data = data

		if table.HasValue(tableProperty.SelectedValues, data) then
			line:SetSelected(true)
		end

		line:SetMouseInputEnabled(canEdit)
	end

	function tableProperty:OnRowSelected(index, line)
		local selectedValues = self.SelectedValues or {}

		if not table.HasValue(selectedValues, line.Data) then
			table.insert(selectedValues, line.Data)
		end

		for _, line2 in pairs(self:GetLines()) do
			if table.HasValue(selectedValues, line2.Data) then
				line2:SetSelected(true)
			end
		end
	end
	function tableProperty:OnRowRightClick(index, line)
		line:SetSelected(false)
		table.RemoveByValue(self.SelectedValues, line.Data)
	end
end

function PROPERTY_TYPE:GetValue(propertyPanel)
	if not IsValid(propertyPanel.TableProperty) then
		return {}
	end

	return propertyPanel.TableProperty.SelectedValues
end

-- Check, if the player can edit the propertyListData in some way.
--
-- @param table propertyListData
-- @param Player ply
-- @param PropertyModel propertyModel
function PROPERTY_TYPE:CanEdit(ply, propertyListData, propertyModel)
	-- Simple check, if we are allowed to edit at all.
	-- More complex check is needed, if we want to restrict which values can be selected.
	-- For now, we allow all values or none.
	if propertyModel:CanPlayerEditProperty(ply, propertyListData.key) then
		return true
	end

	return false
end
--gamemodes/egmrp/gamemode/core/propertymodel/propertylist/model.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--       Client | Property List      --
---------------------------------------

function PROPERTY_TYPE:CreatePanel(propertyPanel, propertyListData, propertyModel, canEdit)
	local key = propertyListData.key

	local currentValue = propertyListData.default or ""
	if propertyModel then
		currentValue = propertyModel:GetProperty(key, currentValue)
	end

	local modelProperty = vgui.Create("DPanel", propertyPanel)
	propertyPanel.ModelProperty = modelProperty

	modelProperty:SetHeight(ScrH() * 0.125)
	modelProperty:Dock(FILL)
	function modelProperty:Paint(width, height)
	end

	if isstring(currentValue) then
		modelProperty.SelectedModel = currentValue
	else
		modelProperty.SelectedModel = propertyListData.values[1] or propertyListData.default or ""
	end

	local modelIcon = vgui.Create("EGMModelIcon", modelProperty)
	propertyPanel.ModelIcon = modelIcon

	local model = modelProperty.SelectedModel
	local skinId = 0
	if istable(model) then
		skinId = model.SkinId or 0
		model = model.Model
	end

	modelIcon:SetModel(model, skinId)
	timer.Simple(0, function()
		modelIcon:GenerateIcon()
	end)

	local selectedId = table.KeyFromValue(propertyListData.values, modelProperty.SelectedModel) or 1

	local leftButton = vgui.Create("DButton", modelProperty)
	propertyPanel.LeftButton = leftButton

	leftButton:SetText("")
	leftButton:SetDisabled(not canEdit)

	function leftButton:Paint(width, height)
		draw.RoundedBox(5, 0, 0, width, height, GetColor("gray", 200))

		if not self:GetDisabled() then
			surface.SetDrawColor(UI.ForegroundColor)
		else
			surface.SetDrawColor(Color(180, 180, 180))
		end
		draw.NoTexture()

		surface.DrawPoly({
			{x = width * 0.6, y = height * 0.5 - width * 0.3},
			{x = width * 0.6, y = height * 0.5 - width * 0.2},
			{x = width * 0.4, y = height * 0.5 + 0},
			{x = width * 0.3, y = height * 0.5 + 0}
		})
		surface.DrawPoly({
			{x = width * 0.4, y = height * 0.5 + 0},
			{x = width * 0.6, y = height * 0.5 + width * 0.2},
			{x = width * 0.6, y = height * 0.5 + width * 0.3},
			{x = width * 0.3, y = height * 0.5 + 0}
		})
	end

	function leftButton:DoClick()
		if selectedId - 1 <= 0 then
			selectedId = #propertyListData.values
		else
			selectedId = selectedId - 1
		end

		modelProperty.SelectedModel = propertyListData.values[selectedId]

		model = modelProperty.SelectedModel
		skinId = 0
		if istable(model) then
			skinId = model.SkinId or 0
			model = model.Model
		end

		modelIcon:SetModel(model, skinId)
		modelIcon:GenerateIcon()

		if isfunction(modelProperty.OnChangedCustom) then
			modelProperty:OnChangedCustom(selectedId, propertyListData.values[selectedId])
		end
	end

	local rightButton = vgui.Create("DButton", modelProperty)
	propertyPanel.RightButton = rightButton

	rightButton:SetText("")
	rightButton:SetDisabled(not canEdit)

	function rightButton:Paint(width, height)
		draw.RoundedBox(5, 0, 0, width, height, GetColor("gray", 200))

		if not self:GetDisabled() then
			surface.SetDrawColor(UI.ForegroundColor)
		else
			surface.SetDrawColor(Color(180, 180, 180))
		end
		draw.NoTexture()

		surface.DrawPoly({
			{x = width * 0.6, y = height * 0.5 + 0},
			{x = width * 0.4, y = height * 0.5 - width * 0.2},
			{x = width * 0.4, y = height * 0.5 - width * 0.3},
			{x = width * 0.7, y = height * 0.5 + 0}
		})
		surface.DrawPoly({
			{x = width * 0.4, y = height * 0.5 + width * 0.3},
			{x = width * 0.4, y = height * 0.5 + width * 0.2},
			{x = width * 0.6, y = height * 0.5 + 0},
			{x = width * 0.7, y = height * 0.5 + 0}
		})
	end

	function rightButton:DoClick()
		if selectedId + 1 > #propertyListData.values then
			selectedId = 1
		else
			selectedId = selectedId + 1
		end

		modelProperty.SelectedModel = propertyListData.values[selectedId]

		model = modelProperty.SelectedModel
		skinId = 0
		if istable(model) then
			skinId = model.SkinId or 0
			model = model.Model
		end

		modelIcon:SetModel(model, skinId)
		modelIcon:GenerateIcon()

		if isfunction(modelProperty.OnChangedCustom) then
			modelProperty:OnChangedCustom(selectedId, propertyListData.values[selectedId])
		end
	end

	-- Set size and positions of child components when the panels layout was invalidated.
	-- (Docking support with GetSize)
	function modelProperty:PerformLayout()
		local width, height = self:GetSize()

		modelIcon:SetSize(height, height)
		modelIcon:Center()

		leftButton:SetPos(0, 0)
		leftButton:SetSize(width * 0.15, height)

		rightButton:SetPos(width * 0.85, 0)
		rightButton:SetSize(width * 0.15, height)
	end
end

function PROPERTY_TYPE:GetValue(propertyPanel)
	if not IsValid(propertyPanel.ModelProperty) then
		return ""
	end

	return propertyPanel.ModelProperty.SelectedModel
end

-- Check, if the player can edit the propertyListData in some way.
--
-- @param table propertyListData
-- @param Player ply
-- @param PropertyModel propertyModel
function PROPERTY_TYPE:CanEdit(ply, propertyListData, propertyModel)
	-- Check if the player can edit the propertyListData at all.
	for _, model in pairs(propertyListData.values) do
		if propertyModel:CanPlayerEditProperty(ply, propertyListData.key, model) then
			return true
		end
	end

	return false
end
--gamemodes/egmrp/gamemode/core/propertymodel/propertylist/models.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--       Client | Property List      --
---------------------------------------

-- Models Property status enum.
PROPERTY_TYPE.INACTIVE = 1
PROPERTY_TYPE.SELECTED = 2
PROPERTY_TYPE.INHERITED = 3
PROPERTY_TYPE.INHERITED_SELECTED = 4
PROPERTY_TYPE.INVALID = 5

-- Create a propertyListData panel for the models propertyListData.
function PROPERTY_TYPE:CreatePanel(propertyPanel, propertyListData, propertyModel, canEdit)
	local _self = self

	local key = propertyListData.key

	local currentValue = propertyListData.default or {}
	if propertyModel then
		currentValue = propertyModel:GetProperty(key, currentValue)
	end

	local valuesTable = propertyListData.values
	if not istable(valuesTable) then return end

	local validModels = valuesTable.validModels
	if not istable(validModels) then return end

	local noSkins = valuesTable.noSkins or false
	if not isbool(noSkins) then return end

	local inheritedModels = valuesTable.inheritedModels or {}

	local modelProperty = vgui.Create("EGMScrollPanel", propertyPanel)
	modelProperty:Dock(FILL)
	modelProperty:InvalidateParent(true)
	modelProperty:SetHeight(ScrH() * 0.3)

	local searchBar = vgui.Create("DTextEntry", propertyPanel)
	searchBar:SetHeight(ScrH() * 0.025)
	searchBar:Dock(BOTTOM)
	searchBar:SetValue(egmt("shared.searching"))

	modelProperty.CanEdit = canEdit
	modelProperty.ValidModels = validModels
	modelProperty.InheritedModels = inheritedModels
	modelProperty.NoSkins = noSkins

	modelProperty.SelectedValues = {}

	-- Select existing or default values
	for _, v in pairs(currentValue) do
		if isstring(v) then
			table.insert(modelProperty.SelectedValues, v)
		elseif istable(v) then
			table.insert(modelProperty.SelectedValues, table.Copy(v))
		end
	end

	-- Update the propertyListData panel.
	function modelProperty:Reload()
		_self:PopulatePropertyPanel(modelProperty, searchBar:GetValue())
	end

	modelProperty:Reload()

	-- Update the propertyListData panel.
	function searchBar:OnEnter()
		modelProperty:Reload()
	end

	-- Clear the search bar if it is empty.
	function searchBar:Think()
		if self:IsEditing() then
			if self:GetText() == egmt("shared.searching") then
				self:SetText("")
			end
		else
			if self:GetText() == "" then
				self:SetText(egmt("shared.searching"))
			end
		end
	end

	propertyPanel.ModelProperty = modelProperty
	propertyPanel.SearchBar = searchBar
end

-- Filter the model list.
--
-- @param String searchString
-- @param String model
-- @param? String modelName
-- @return Boolean isVisible
function PROPERTY_TYPE:FilterModel(searchString, model, modelName)
	local lowerSearchString = string.lower(searchString)
	local lowerModel = string.lower(model)
	if string.find(lowerModel, lowerSearchString) then return true end

	if not isstring(modelName) then return true end

	local lowerModelName = string.lower(modelName)
	if string.find(lowerModelName, lowerSearchString) then return true end

	return false
end

-- Search for a model in a list of models and model tables.
--
-- @param Table modelList
-- @param String model
-- @return Boolean modelFound
-- @return? Table modelData
function PROPERTY_TYPE:FindModel(modelList, model)
	for _, modelData in pairs(modelList) do
		if isstring(modelData) and (modelData == model or modelData == "-" .. model) then return true end
		if istable(modelData) and modelData.Model == model then return true, modelData end
	end

	return false
end

-- Optimization for the model list.
--
-- @param Table modelList
-- @param Table modelData
function PROPERTY_TYPE:OptimiseModelData(selectedValues, modelData)
	-- Don't optimise inherited models, because you would have to check the inherited data for the same model.
	if modelData.Inherited then return end

	-- Check, if the model needs to be collapsed.
	local noSkinSelected = true
	local noSkinDeSelected = true
	for _, selected in pairs(modelData.Skins) do
		if selected then
			noSkinSelected = false
		else
			noSkinDeSelected = false
		end
	end

	-- Collapse the model, if no skin is selected.
	if noSkinSelected then
		-- Remove the expanded model.
		table.RemoveByValue(selectedValues, modelData)
	elseif noSkinDeSelected then
		-- Replace the expanded model with the not expanded model.
		local id = table.RemoveByValue(selectedValues, modelData)

		if id == false then
			table.insert(selectedValues, modelData.Model)
		else
			table.insert(selectedValues, id, modelData.Model)
		end
	end
end

-- Expand the model icon into its skins.
--
-- @param Panel modelProperty
-- @param Panel modelPanel
function PROPERTY_TYPE:Expand(modelProperty, modelPanel)
	if modelProperty.NoSkins then return end

	local model = modelPanel.RealModel
	if not isstring(model) then return end

	local currentStatus = modelPanel.Status
	if currentStatus == self.INVALID then return end

	-- Get the skin count of the model, by creating a temporary model.
	local skinCount = GetModelSkinCount(model)

	-- Dont expand models without skins.
	if skinCount <= 1 then return end

	local inherited = (currentStatus == self.INHERITED or currentStatus == self.INHERITED_SELECTED)

	local modelData = {
		Model = model,
		Skins = {},
		Inherited = inherited,
	}

	-- If the inherited model is expanded, just delete the data here.
	if inherited then
		local inheritedModelFound, inheritedModelData = self:FindModel(modelProperty.InheritedModels, model)
		if inheritedModelFound and istable(inheritedModelData) then
			table.RemoveByValue(modelProperty.SelectedValues, "-" .. model)

			modelProperty:Reload()
			return
		end
	end

	for i = 0, skinCount - 1 do
		modelData.Skins[i] = true
	end

	-- Remove the not expanded model.
	local id
	if inherited then
		id = table.RemoveByValue(modelProperty.SelectedValues, "-" .. model)
	else
		id = table.RemoveByValue(modelProperty.SelectedValues, model)
	end

	-- Add the expanded model.
	if id == false then
		table.insert(modelProperty.SelectedValues, modelData)
	else
		table.insert(modelProperty.SelectedValues, id, modelData)
	end

	-- Update the propertyListData panel.
	modelProperty:Reload()
end

-- Collapse the model icon into its model.
--
-- @param Panel modelProperty
-- @param Panel modelPanel
function PROPERTY_TYPE:Collapse(modelProperty, modelPanel)
	local model = modelPanel.RealModel
	if not isstring(model) then return end

	local currentStatus = modelPanel.Status

	-- Remove the expanded invalid model.
	if currentStatus == self.INVALID then
		local modelFound, modelData = self:FindModel(modelProperty.SelectedValues, model)
		if modelFound then
			-- Remove the expanded model.
			table.RemoveByValue(modelProperty.SelectedValues, modelData)

			-- Update the propertyListData panel.
			modelProperty:Reload()
			return
		end
	end

	-- Handle minimizing inherited expanded models, that are not currently selected.
	if currentStatus == self.INHERITED or currentStatus == self.INHERITED_SELECTED then
		local modelFound, modelData = self:FindModel(modelProperty.SelectedValues, model)

		if modelFound then
			if istable(modelData) then
				-- Remove the expanded model.
				local id = table.RemoveByValue(modelProperty.SelectedValues, modelData)

				-- Add the not expanded model.
				if id == false then
					table.insert(modelProperty.SelectedValues, "-" .. model)
				else
					table.insert(modelProperty.SelectedValues, id, "-" .. model)
				end

				-- Update the propertyListData panel.
				modelProperty:Reload()
				return
			end
		else
			-- Add the not expanded model as removed inherited model.
			table.insert(modelProperty.SelectedValues, "-" .. model)

			-- Update the propertyListData panel.
			modelProperty:Reload()
			return
		end
	end

	for id, modelData in ipairs(modelProperty.SelectedValues) do
		if not istable(modelData) then continue end
		if modelData.Model ~= model then continue end

		if modelData.Inherited then
			-- Remove the expanded model.
			table.remove(modelProperty.SelectedValues, id)

			-- Update the propertyListData panel.
			modelProperty:Reload()
			return
		else
			-- Replace the expanded model with the not expanded model.
			modelProperty.SelectedValues[id] = model

			-- Update the propertyListData panel.
			modelProperty:Reload()
			return
		end
	end
end

-- Click on a collapsed model icon.
--
-- @param Panel modelProperty
-- @param Panel modelPanel
function PROPERTY_TYPE:ClickCollapsed(modelProperty, modelPanel)
	local model = modelPanel.RealModel
	if not isstring(model) then return end

	local currentStatus = modelPanel.Status

	-- Deselect the model, if it is invalid, or just selected.
	if currentStatus == self.INVALID or currentStatus == self.SELECTED then
		table.RemoveByValue(modelProperty.SelectedValues, model)
		modelPanel.Status = self.INACTIVE

		return
	end

	-- Select the model, if it is unselected.
	if currentStatus == self.INACTIVE then
		table.insert(modelProperty.SelectedValues, model)
		modelPanel.Status = self.SELECTED

		return
	end

	-- Deselect an inherited model.
	if currentStatus == self.INHERITED_SELECTED then
		table.insert(modelProperty.SelectedValues, "-" .. model)
		modelPanel.Status = self.INHERITED

		return
	end

	-- Select an inherited model.
	if currentStatus == self.INHERITED then
		table.RemoveByValue(modelProperty.SelectedValues, "-" .. model)
		modelPanel.Status = self.INHERITED_SELECTED

		return
	end
end

-- Click on an expanded model icon.
--
-- @param Panel modelProperty
-- @param Panel modelPanel
function PROPERTY_TYPE:ClickExpanded(modelProperty, modelPanel)
	local model = modelPanel.RealModel
	if not isstring(model) then return end

	local skinId = modelPanel.RealSkinId
	if not isnumber(skinId) then return end

	local currentStatus = modelPanel.Status

	local modelFound, modelData = self:FindModel(modelProperty.SelectedValues, model)

	-- Create the model data, if it does not exist.
	if not modelFound then
		local inheritedModelFound, inheritedModelData = self:FindModel(modelProperty.InheritedModels, model)
		if inheritedModelFound then
			modelData = table.Copy(inheritedModelData)
			modelData.Inherited = true

			table.insert(modelProperty.SelectedValues, modelData)
		else
			return
		end
	end

	-- Deselect the entire model group, if it is invalid.
	if currentStatus == self.INVALID then
		-- Remove the expanded model.
		table.RemoveByValue(modelProperty.SelectedValues, modelData)

		-- Immediately update and return.
		modelProperty:Reload()
		return

	-- Select the skin, if it is unselected.
	elseif currentStatus == self.INACTIVE then
		modelData.Skins[skinId] = true
		modelPanel.Status = self.SELECTED

	-- Deselect the skin, if it is selected.
	elseif currentStatus == self.SELECTED then
		modelData.Skins[skinId] = false
		modelPanel.Status = self.INACTIVE

	-- Deselect an inherited skin.
	elseif currentStatus == self.INHERITED_SELECTED then
		modelData.Skins[skinId] = false
		modelPanel.Status = self.INHERITED

	-- Select an inherited skin.
	elseif currentStatus == self.INHERITED then
		modelData.Skins[skinId] = true
		modelPanel.Status = self.INHERITED_SELECTED

	else
		return
	end

	self:OptimiseModelData(modelProperty.SelectedValues, modelData)

	-- Update the propertyListData panel.
	modelProperty:Reload()
end

-- Create the icon for a model.
--
-- @param Panel modelProperty
-- @param Number iconSize
-- @param String model
-- @param Number skinId
-- @param Number status
-- @param? String searchString
-- @param? Boolean expanded
-- @return Boolean success
-- @return Panel modelIconPanel
function PROPERTY_TYPE:CreateModelIcon(modelProperty, iconSize, model, skinId, status, searchString, expanded)
	local _self = self

	if not isstring(model) then return false end

	local validModels = modelProperty.ValidModels
	modelName = table.KeyFromValue(validModels, model)

	-- Apply Search Filter
	if isstring(searchString) and #searchString > 0 and searchString ~= egmt("shared.searching")
	and not self:FilterModel(searchString, model, modelName) then return false end

	local modelPanel = vgui.Create("EGMModelIcon", modelProperty)
	modelPanel:SetSize(iconSize, iconSize)

	modelPanel.RealModel = model
	modelPanel.RealSkinId = skinId

	modelPanel:SetModel(model, skinId)

	-- Override the display type using the internally set model and skinId.
	local displayType = hook.Run("EGMPropertyTypeModel.GetDisplayType", modelPanel.Model, modelPanel.SkinId)
	if isstring(displayType) then
		modelPanel:SetDisplayType(displayType)
	end

	modelPanel:GenerateIcon()

	if not isstring(modelName) or modelName == "" then
		modelName = egmt("propertymodel.invalid_model")
	end

	if expanded then
		modelPanel:SetTooltip(modelName .. " (" .. skinId .. ")")
	else
		modelPanel:SetTooltip(modelName)
	end

	modelPanel.Status = status
	modelPanel.Expanded = expanded

	-- Paint a frame if the model is selected, inherited or invalid.
	function modelPanel:PaintOver(ww, hh)
		local currentStatus = self.Status
		if currentStatus ~= _self.INACTIVE then
			local color
			if currentStatus == _self.SELECTED then
				color = UI.ForegroundColor
			elseif currentStatus == _self.INHERITED_SELECTED then
				color = GetColor("green", 255)
			elseif currentStatus == _self.INVALID then
				color = GetColor("red", 255)
			elseif currentStatus == _self.INHERITED then
				color = GetColor("green", 15)
			end

			if color ~= nil then
				-- Draw Colored frame
				draw.RoundedBox(0, 4,      0, ww - 8, 4, color)
				draw.RoundedBox(0, 4, hh - 4, ww - 8, 4, color)

				draw.RoundedBox(0,      0, 0, 4, hh, color)
				draw.RoundedBox(0, ww - 4, 0, 4, hh, color)
			end
		end

		-- Draw thin white frame on hover.
		if self:IsHovered() then
			draw.RoundedBox(0, 0, 0, ww - 1, 1, color_white)
			draw.RoundedBox(0, 0, hh - 1, ww - 1, 1, color_white)

			draw.RoundedBox(0, 0, 0, 1, hh - 1, color_white)
			draw.RoundedBox(0, ww - 1, 0, 1, hh - 1, color_white)
		end
	end

	-- Toggle the model.
	function modelPanel:DoClick()
		if self.Expanded then
			_self:ClickExpanded(modelProperty, modelPanel)
		else
			_self:ClickCollapsed(modelProperty, modelPanel)
		end
	end

	-- Expand / Collapse the model into its skins.
	function modelPanel:DoRightClick()
		local dermMenu = DermaMenu()

		if self.Expanded then
			dermMenu:AddOption(egmt("propertymodel.models_collapse"), function()
				_self:Collapse(modelProperty, modelPanel)
			end)
		else
			local skinCount = GetModelSkinCount(model)
			if skinCount > 1 and not modelProperty.NoSkins then
				dermMenu:AddOption(egmt("propertymodel.models_expand"), function()
					_self:Expand(modelProperty, modelPanel)
				end)
			end
		end

		dermMenu:Open()
	end

	return true, modelPanel
end

-- Populate the propertyListData panel with the models.
--
-- @param Panel modelProperty
-- @param? String searchString
function PROPERTY_TYPE:PopulatePropertyPanel(modelProperty, searchString)
	local _self = self

	local canEdit = modelProperty.CanEdit
	local validModels = modelProperty.ValidModels
	local inheritedModels = modelProperty.InheritedModels

	modelProperty:Clear()
	modelProperty.ModelPanels = {}

	local iconSize = math.floor(ScrW() * 0.02)
	local margin = math.floor(iconSize * 0.2)
	local offset = iconSize + margin
	local width = modelProperty:GetWide() - offset
	local ammount = math.floor(width / offset)

	-- Center the models.
	local scrollBar = modelProperty:GetVBar()
	local scrollW = scrollBar:GetWide()

	local fullW = ammount * offset
	local startX = ((width - scrollW) - fullW) * 0.5

	local x, y = startX, 0

	-- Internal function to add a model to the list.
	--
	-- @param String model
	-- @param Number skinId
	-- @param Number status
	-- @param? Boolean expanded
	function modelProperty:AddModel(model, skinId, status, expanded, addConnector)
		local success, modelPanel = _self:CreateModelIcon(self, iconSize, model, skinId, status, searchString, expanded)
		if not success then return end

		modelPanel:SetMouseInputEnabled(canEdit)
		modelPanel:SetPos(x, y)

		if addConnector then
			local connectorPanel = vgui.Create("DPanel", self)
			connectorPanel:SetSize(margin, iconSize)
			connectorPanel:SetPos(x + iconSize, y)

			function connectorPanel:Paint(ww, hh)
				draw.RoundedBox(0, 0, 0, ww, hh, ColorAlpha(UI.ForegroundColor2, 127))
			end

			modelPanel.ConnectorPanel = connectorPanel
		end

		x = x + offset
		if x > width then
			x = startX
			y = y + offset
		end
		table.insert(self.ModelPanels, modelPanel)
	end

	-- Add Invalid Models
	for _, model in SortedPairs(modelProperty.SelectedValues) do
		-- Check, if the model is expanded.
		local modelData
		if istable(model) then
			modelData = model
			model = modelData.Model
		end

		-- Skip inherited models.
		if string.StartWith(model, "-") then continue end

		-- Skip valid models.
		if table.HasValue(validModels, model) then continue end

		if istable(modelData) then
			local skins = modelData.Skins
			for skinId, selected in SortedPairs(skins) do
				modelProperty:AddModel(model, skinId, _self.INVALID, true, skinId < table.Count(skins) - 1)
			end
		else
			modelProperty:AddModel(model, 0, _self.INVALID)
		end
	end

	-- Add inherited Models
	for _, model in SortedPairs(inheritedModels) do
		if istable(model) then
			-- Check, if the model has custom data here.
			local modelFound, modelData = _self:FindModel(modelProperty.SelectedValues, model.Model)

			if modelFound then
				if istable(modelData) then
					local skins = modelData.Skins
					for skinId, selected in SortedPairs(skins) do
						local status = selected and _self.INHERITED_SELECTED or _self.INHERITED
						modelProperty:AddModel(model.Model, skinId, status, true, skinId < table.Count(skins) - 1)
					end
				else
					modelProperty:AddModel(model.Model, 0, _self.INHERITED)
				end
			else
				local skins = model.Skins
				for skinId, selected in SortedPairs(skins) do
					local status = selected and _self.INHERITED_SELECTED or _self.INHERITED
					modelProperty:AddModel(model.Model, skinId, status, true, skinId < table.Count(skins) - 1)
				end
			end
		else
			-- Check if the model is selected.
			local modelFound, modelData = _self:FindModel(modelProperty.SelectedValues, model)

			if modelFound then
				if istable(modelData) then
					local skins = modelData.Skins
					for skinId, selected in SortedPairs(skins) do
						local status = selected and _self.INHERITED_SELECTED or _self.INHERITED
						modelProperty:AddModel(model, skinId, status, true, skinId < table.Count(skins) - 1)
					end
				else
					modelProperty:AddModel(model, 0, _self.INHERITED)
				end
			else
				modelProperty:AddModel(model, 0, _self.INHERITED_SELECTED)
			end
		end

	end

	-- Add Valid Selected Models.
	for _, model in SortedPairs(modelProperty.SelectedValues) do
		local modelData
		if istable(model) then
			modelData = model
			model = modelData.Model

			if modelData.Inherited then continue end
		end

		-- Skip inherited models.
		if string.StartWith(model, "-") then continue end

		-- Skip invalid models.
		if not table.HasValue(validModels, model) then continue end

		if istable(modelData) then
			local skins = modelData.Skins
			for skinId, selected in SortedPairs(skins) do
				local status = selected and _self.SELECTED or _self.INACTIVE
				modelProperty:AddModel(model, skinId, status, true, skinId < table.Count(skins) - 1)
			end
		else
			modelProperty:AddModel(model, 0, _self.SELECTED)
		end
	end

	-- Add Valid Unselected Models.
	for _, model in SortedPairs(validModels) do
		-- Skip inherited models.
		if _self:FindModel(inheritedModels, model) then continue end

		-- Skip selected models.
		if _self:FindModel(modelProperty.SelectedValues, model) then continue end

		modelProperty:AddModel(model, 0, _self.INACTIVE)
	end
end

-- Get the value of the propertyListData.
--
-- @param Panel propertyPanel
-- @return? Table selectedValues
function PROPERTY_TYPE:GetValue(propertyPanel)
	local modelProperty = propertyPanel.ModelProperty
	if not IsValid(modelProperty) then
		return {}
	end

	local selectedValues = modelProperty.SelectedValues
	if not istable(selectedValues) then
		return {}
	end

	for _, modelData in pairs(selectedValues) do
		if istable(modelData) then
			self:OptimiseModelData(selectedValues, modelData)
		end
	end

	return selectedValues
end

-- Check, if the player can edit the propertyListData in some way.
--
-- @param table propertyListData
-- @param Player ply
-- @param PropertyModel propertyModel
function PROPERTY_TYPE:CanEdit(ply, propertyListData, propertyModel)
	-- Simple check, if we are allowed to edit at all.
	-- More complex check is needed, if we want to restrict which values can be selected.
	-- For now, we allow all values or none.
	if propertyModel:CanPlayerEditProperty(ply, propertyListData.key) then
		return true
	end

	return false
end
--gamemodes/egmrp/gamemode/core/propertymodel/propertylist/text.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--       Client | Property List      --
---------------------------------------

function PROPERTY_TYPE:CreatePanel(propertyPanel, propertyListData, propertyModel, canEdit)
	local key = propertyListData.key

	local currentValue = propertyListData.default or ""
	if propertyModel then
		currentValue = propertyModel:GetProperty(key, currentValue)
	end

	local textProperty = vgui.Create("DTextEntry", propertyPanel)
	propertyPanel.TextProperty = textProperty

	textProperty:SetHeight(ScrH() * 0.1)
	textProperty:Dock(FILL)
	textProperty:SetValue(currentValue)
	textProperty:SetMultiline(true)
	textProperty:SetDisabled(not canEdit)
	textProperty:SetFont("EGMText6")

	if canEdit then
		values[propertyListData.key] = function()
			return textProperty:GetValue()
		end
	end
end

function PROPERTY_TYPE:GetValue(propertyPanel)
	if not IsValid(propertyPanel.TextProperty) then
		return ""
	end

	return propertyPanel.TextProperty:GetValue()
end

-- Check, if the player can edit the propertyListData in some way.
--
-- @param table propertyListData
-- @param Player ply
-- @param PropertyModel propertyModel
function PROPERTY_TYPE:CanEdit(ply, propertyListData, propertyModel)
	-- Checking an empty string should be sufficient.
	-- If the player can edit an empty string, he can edit all strings.
	if propertyModel:CanPlayerEditProperty(ply, propertyListData.key, propertyListData.default or "") then
		return true
	end

	return false
end
--gamemodes/egmrp/gamemode/core/ui/styles/default/cl_fonts.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--         Default UI | Fonts        --
---------------------------------------

local font = "Roboto"

local function loadFonts()
	for i = 1, 64 do
		surface.CreateFont("EGM" .. "Text" .. i, { -- Seperated to prevent overwriting with search and replace
			font = font,
			size = ScreenScaleH(i),
		})
	end
end

hook.Add("EGMRP.Loaded", "UI.LoadFonts", loadFonts)
hook.Add("OnScreenSizeChanged", "UI.LoadFonts", loadFonts)
--gamemodes/egmrp/gamemode/core/ui/styles/default/vgui/egmcheckbox.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--         VGUI | EGMCheckBox        --
---------------------------------------

ELEMENT.Name = "EGMCheckBox"
ELEMENT.Base = "DCheckBox"

-- Initializes the EGMCheckBox
function ELEMENT:Init()
end

-- Draws the EGMCheckBox
function ELEMENT:Paint(width, height)
    if self:GetDisabled() then
        draw.RoundedBox(5, 0, 0, width, height, ColorAlpha(UI.TextColor, 200))
    else
        draw.RoundedBox(5, 0, 0, width, height, UI.TextColor)
    end

    if self:GetChecked() then
        draw.NoTexture()
        surface.SetDrawColor(GetColor("green"))
        surface.DrawPoly({
            {x = width * 0.4, y = height * 0.6},
            {x = width * 0.9, y = height * 0.1},
            {x = width * 0.95, y = height * 0.15},
            {x = width * 0.4, y = height * 0.8},
            {x = width * 0.1, y = height * 0.5},
            {x = width * 0.15, y = height * 0.45}
        })
    end
end
--gamemodes/egmrp/gamemode/core/ui/styles/default/vgui/egmmodelpanel.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--        VGUI | EGMModelPanel       --
---------------------------------------

ELEMENT.Name = "EGMModelPanel"
ELEMENT.Base = "DModelPanel"

-- Layout code from Arizard's BodyGroupR script.
local function InverseLerp(pos, p1, p2)
	local range = p2 - p1

	if range == 0 then return 1 end

	return (pos - p1) / range
end

-- Initializes the Modelpanel.
function ELEMENT:Init()
	self:SetLookAt(Vector(0, 0, 72 / 2))
	self:SetCamPos(Vector(64, 0, 72 / 2))

	self:SetAmbientLight(Color(10, 15, 50))
	self:SetDirectionalLight(BOX_TOP, Color(220, 190, 100))

	self.rot = 110
	self.fov = 20
	self:SetFOV(self.fov)
	self.dragging = false -- left click
	self.dragging2 = false -- right click
	self.ux = 0
	self.uy = 0
	self.spinmul = 0.4
	self.zoommul = 0.09

	self.xmod = 0
	self.ymod = 0
end

-- Sets the model and skin of the given model.
--
-- @param String model
-- @param Number skinId
function ELEMENT:SetModelSkin(model, skinId)
	if not isstring(model) then
		model = "models/error.mdl"
		skinId = 0
	end

	self.Model = model
	self.SkinId = skinId

	self:SetModel(model)
	if isnumber(skinId) then
		self.Entity:SetSkin(skinId)
	end

	hook.Run("EGMModelPanel.SetModelSkin", self, model, skinId)
end

-- Sets the model of the given character.
--
-- @param Table character
function ELEMENT:SetCharacter(char)
	self.Character = char

	local model, skinId = char:GetModelSkin()
	self:SetModelSkin(model, skinId)

	hook.Run("EGMModelPanel.SetCharacter", self, char)
end

function ELEMENT:OnRemove()
	hook.Run("EGMModelPanel.OnRemove", self)
end

function ELEMENT:LayoutEntity(ent)
	local newrot = self.rot
	local newfov = self:GetFOV()

	if self.dragging == true then
		newrot = self.rot + (gui.MouseX() - self.ux) * self.spinmul
		newfov = self.fov + (self.uy - gui.MouseY()) * self.zoommul
		if newfov < 20 then newfov = 20 end
		if newfov > 75 then newfov = 75 end
	end

	local newxmod, newymod = self.xmod, self.ymod

	if self.dragging2 == true then
		newxmod = self.xmod + (self.ux - gui.MouseX()) * 0.02
		newymod = self.ymod + (self.uy - gui.MouseY()) * 0.02
	end

	newxmod = math.Clamp( newxmod, -16, 16 )
	newymod = math.Clamp( newymod, -16, 16 )

	ent:SetAngles(Angle(0, 0, 0))
	self:SetFOV(newfov)

	-- calculate if we should look at the face
	local height = 72 / 2
	-- fov between 20 and 75,
	-- height between 72 / 2 and 72
	local frac = InverseLerp(newfov, 75, 20)
	height = Lerp(frac, 72 / 2, 64)

	-- calculate look ang
	local norm = (self:GetCamPos() - Vector(0, 0, 64))
	norm:Normalize()
	local lookAng = norm:Angle()

	self:SetLookAt(Vector(0, 0, height - (2 * frac)) - Vector(0, 0, newymod * 2 * (1 - frac)) - lookAng:Right() * newxmod * 2 * (1 - frac))
	self:SetCamPos(Vector(64 * math.sin(newrot * (math.pi / 180)), 64 * math.cos(newrot * (math.pi / 180)), height + 4 * (1 - frac)) - Vector(0, 0, newymod * 2 * (1 - frac)) - lookAng:Right() * newxmod * 2 * (1 - frac))
end

function ELEMENT:OnMousePressed(key)
	self.ux = gui.MouseX()
	self.uy = gui.MouseY()
	self.dragging = key == MOUSE_LEFT
	self.dragging2 = key == MOUSE_RIGHT
end

function ELEMENT:OnMouseReleased(key)
	if self.dragging then
		self.rot = self.rot + (gui.MouseX() - self.ux) * self.spinmul
		self.fov = self.fov + (self.uy - gui.MouseY()) * self.zoommul
		self.fov = math.Clamp(self.fov, 20, 75)
	end

	if self.dragging2 then
		self.xmod = self.xmod + (self.ux - gui.MouseX()) * 0.02
		self.ymod = self.ymod + (self.uy - gui.MouseY()) * 0.02

		self.xmod = math.Clamp(self.xmod, -16, 16)
		self.ymod = math.Clamp(self.ymod, -16, 16)
	end

	self.dragging = false
	self.dragging2 = false
end

function ELEMENT:OnCursorExited()
	if self.dragging or self.dragging2 then
		self:OnMouseReleased()
	end
end

function ELEMENT:PostDrawModel(ent)
	hook.Run("EGMModelPanel.PostDrawModel", self, ent)
end
--gamemodes/egmrp/gamemode/core/ui/styles/default/vgui/egmpageselector.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--      VGUI | EGMPageSelector       --
---------------------------------------

ELEMENT.Name = "EGMPageSelector"
ELEMENT.Base = "DPanel"

-- Initializes the EGMPageSelector.
function ELEMENT:Init()
	local _self = self

	self.Page = 1
	self.Pages = 1

	self.PagePreviousButton = vgui.Create("DButton", self)
	self.PagePreviousButton:Dock(LEFT)
	self.PagePreviousButton:SetText("<")
	self.PagePreviousButton:SetFont("EGMText8")
	self.PagePreviousButton:SetTextColor(GetColor("darkgray"))
	self.PagePreviousButton:SetContentAlignment(5)
	function self.PagePreviousButton:Paint(width, height)
		draw.RoundedBox(0, 0, 0, width, height, UI.BackgroundColor2)
	end
	function self.PagePreviousButton:DoClick()
		if self:GetDisabled() then return end

		local newPage = _self.Page - 1
		if newPage > 0 and newPage <= _self.Pages then
			_self:SetPage(newPage)

			if isfunction(_self.Callback) then
				_self.Callback(newPage)
			end
		end
	end
	function self.PagePreviousButton:Refresh()
		self:SetTextColor((_self.Page > 1) and UI.ForegroundColor or GetColor("darkgray"))
	end

	self.PageNextButton = vgui.Create("DButton", self)
	self.PageNextButton:Dock(RIGHT)
	self.PageNextButton:SetText(">")
	self.PageNextButton:SetFont("EGMText8")
	self.PageNextButton:SetTextColor(GetColor("darkgray"))
	self.PageNextButton:SetContentAlignment(5)
	function self.PageNextButton:Paint(width, height)
		draw.RoundedBox(0, 0, 0, width, height, UI.BackgroundColor2)
	end
	function self.PageNextButton:DoClick()
		if self:GetDisabled() then return end

		local newPage = _self.Page + 1
		if newPage > 0 and newPage <= _self.Pages then
			_self:SetPage(newPage)

			if isfunction(_self.Callback) then
				_self.Callback(newPage)
			end
		end
	end
	function self.PageNextButton:Refresh()
		self:SetTextColor((_self.Page < _self.Pages) and UI.ForegroundColor or GetColor("darkgray"))
	end

	self.PageTextEntry = vgui.Create("DTextEntry", self)
	self.PageTextEntry:SetFont("EGMText8")
	self.PageTextEntry:SetTextColor(GetColor("white"))
	self.PageTextEntry:SetText(self.Page)
	function self.PageTextEntry:Paint(width, height)
		if self:IsEditing() then
			draw.RoundedBox(5, 0, 0, width, height, GetColor("white", 20))
		else
			draw.RoundedBox(5, 0, 0, width, height, GetColor("lightgray", 5))
		end

		draw.DrawText(self:GetValue(), self:GetFont(), width * 0.5, 0, self:GetTextColor(), TEXT_ALIGN_CENTER)
	end
	function self.PageTextEntry:Think()
		if self:IsEditing() then
			if not self.AlreadyCleared then
				self.AlreadyCleared = true
				self.OldText = self:GetText()
				self:SetText("")
			end
		else
			if self.AlreadyCleared then
				self.AlreadyCleared = false
				self:SetText(self.OldText)
			end
		end
	end
	function self.PageTextEntry:OnValueChange(value)
		if self:GetDisabled() then return end

		local newPage = tonumber(value)
		if isnumber(newPage) and newPage > 0 and newPage <= _self.Pages then
			_self:SetPage(newPage)

			if isfunction(_self.Callback) then
				_self.Callback(newPage)
			end

			self.AlreadyCleared = false
		end
	end

	-- We need to do it in the next frame (timer.Simple(0)) to support docking.
	timer.Simple(0, function()
		self:UpdateDockScaling()
	end)
end

-- Update the size of the page selector.
function ELEMENT:UpdateDockScaling()
	if not IsValid(self) then return end

	local w, h = self:GetSize()

	self.PagePreviousButton:SetSize(w * 0.1, h)
	self.PageNextButton:SetSize(w * 0.1, h)

	self.PageTextEntry:SetSize(ScrW() * 0.02, h)
	self.PageTextEntry:SetPos(w * 0.5 - ScrW() * 0.01, 0)
end

-- Update the size of the page selector whenever the panels layout was invalidated.
--
-- @param Number width
-- @param Number height
function ELEMENT:PerformLayout(width, height)
	self:UpdateDockScaling()
end

-- Draws the selector.
--
-- @param Number width
-- @param Number height
function ELEMENT:Paint(width, height)
	draw.RoundedBox(0, 0, 0, width, height, UI.BackgroundColor2)

	draw.DrawText("von " .. self.Pages, "EGMText8", width * 0.5 + ScrW() * 0.01 + 5, 0, Color(255, 255, 255, 255), TEXT_ALIGN_LEFT)
	draw.DrawText("Seite", "EGMText8", width * 0.5 - ScrW() * 0.01 - 6, 0, Color(255, 255, 255, 255), TEXT_ALIGN_RIGHT)
end

-- Refreshes the selector.
function ELEMENT:Refresh()
	self.PagePreviousButton:Refresh()
	self.PageNextButton:Refresh()
end



---------------------------------------
--          Setter Functions         --
---------------------------------------

-- Sets the current page of the selector. Does not call the callback!
--
-- @param Number page
function ELEMENT:SetPage(page)
	if page < 1 then
		page = 1
	elseif page >= self.Pages then
		page = self.Pages
	end

	self.Page = page
	self.PageTextEntry:SetText(page)

	self:Refresh()
end

-- Returns the selected page.
--
-- @return Number page
function ELEMENT:GetPage()
	return self.Page
end

-- Sets the pagecount for all pages.
--
-- @param Number pageCount
function ELEMENT:SetPageCount(pageCount)
	if pageCount < 1 then
		pageCount = 1
	end

	self.Pages = pageCount

	if pageCount < self.Page then
		self:SetPage(pageCount)
	end

	self:Refresh()
end

-- Returns the pagecount for all pages.
--
-- @return Number pageCount
function ELEMENT:GetPageCount()
	return self.Pages
end

-- Sets callback.
--
-- @param Function callback
function ELEMENT:SetCallback(callback)
	self.Callback = callback
end
--gamemodes/egmrp/gamemode/core/ui/styles/default/vgui/egmscrollpanel.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--        VGUI | EGMScrollPanel      --
---------------------------------------

ELEMENT.Name = "EGMScrollPanel"
ELEMENT.Base = "DScrollPanel"

-- Initializes the EGMScrollPanel.
function ELEMENT:Init()
	local _self = self

	self.BackgroundColor = GetColor("darkgray")

	self.ScrollbarColor = GetColor("darkgray")
	self.ScrollbarGripColor = UI.ForegroundColor
	self.ScrollbarButtonColor = GetColor("black")
	self.ScrollbarButtonBackgroundColor = UI.ForegroundColor

	self.CornerRadius = 0

	-- Override Paint functions

	function self.VBar:Paint(width, height)
		draw.RoundedBox(0, 0, 0, width, height, _self.ScrollbarColor)
	end

	function self.VBar.btnGrip:Paint(width, height)
		draw.RoundedBox(0, 0, 0, width, height, _self.ScrollbarGripColor)
	end

	function self.VBar.btnUp:Paint(width, height)
		draw.RoundedBox(0, 0, 0, width, height, _self.ScrollbarButtonBackgroundColor)

		surface.SetDrawColor(_self.ScrollbarButtonColor)
		draw.NoTexture()
		surface.DrawPoly({
			{x = 3, y = 11.5},
			{x = 7.5, y = 3.5},
			{x = 12, y = 11.5}
		})
	end
	function self.VBar.btnDown:Paint(width, height)
		draw.RoundedBox(0, 0, 0, width, height, _self.ScrollbarButtonBackgroundColor)

		surface.SetDrawColor(_self.ScrollbarButtonColor)
		draw.NoTexture()
		surface.DrawPoly({
			{x = 12, y = 3.5},
			{x = 7.5, y = 11.5},
			{x = 3, y = 3.5}
		})
	end
end

-- Draws the EGMScrollPanel.
--
-- @param Number width
-- @param Number height
function ELEMENT:Paint(width, height)
	draw.RoundedBox(self.CornerRadius, 0, 0, width, height, self.BackgroundColor)
end



---------------------------------------
--          Setter Functions         --
---------------------------------------

-- Sets the backgroundcolor.
--
-- @param Color color
function ELEMENT:SetBackgroundColor(color)
	self.BackgroundColor = color
end

-- Sets the scrollbarcolor.
--
-- @param Color color
function ELEMENT:SetScrollbarColor(color)
	self.ScrollbarColor = color
end

-- Sets the gripcolor.
--
-- @param Color color
function ELEMENT:SetScrollbarGripColor(color)
	self.ScrollbarGripColor = color
end

-- Sets the color of the up-button.
--
-- @param Color color
function ELEMENT:SetScrollbarButtonColor(color)
	self.ScrollbarButtonColor = color
end

-- Sets the backgroundcolor of the up-button.
--
-- @param Color color
function ELEMENT:SetScrollbarButtonBackgroundColor(color)
	self.ScrollbarButtonBackgroundColor = color
end

-- Sets the cornorradius.
--
-- @param Number number
function ELEMENT:SetCornerRadius(number)
	self.CornerRadius = number
end
--gamemodes/egmrp/gamemode/core/settings/sh_index.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--          Settings | Index         --
---------------------------------------

Settings = Settings or {}

if SERVER then
    AddCSLuaFile("sh_settings.lua")
    AddCSLuaFile("cl_settings.lua")
    AddCSLuaFile("cl_settingsmenu.lua")

    include("sh_settings.lua")
    include("sv_settings.lua")
end

if CLIENT then
    include("sh_settings.lua")
    include("cl_settings.lua")
    include("cl_settingsmenu.lua")
end
--gamemodes/egmrp/gamemode/core/permission/sh_index.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--         Permission | Index        --
---------------------------------------

Permission = Permission or {}

if SERVER then
    AddCSLuaFile("sh_config.lua")
    AddCSLuaFile("sh_permission.lua")
    AddCSLuaFile("cl_permission.lua")
    AddCSLuaFile("cl_keybinds.lua")

    include("sh_config.lua")
    include("sh_permission.lua")
    include("sv_permission.lua")
    include("sv_administrate.lua")
    include("sv_chats.lua")
end

if CLIENT then
    include("sh_config.lua")
    include("sh_permission.lua")
    include("cl_permission.lua")
    include("cl_keybinds.lua")
end
--gamemodes/egmrp/gamemode/core/permission/sh_config.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--        Permission | Config        --
---------------------------------------
--  Variables should be overwritten  --
--     in the deriving gamemode!     --
---------------------------------------

-- List of all usergroups.
-- Sorted by permission. The last usergroup has the highest permission.
Permission.UserGroupList = {
    "user",
    "operator",
    "admin",
    "superadmin",
}

Permission.AdminRank = "admin"

Permission.SuperAdminRank = "superadmin"

-- First team rank in the user group list. Determines wich ranks are handles as team members.
Permission.FirstTeamRank = "operator"

-- Keybind, where teammembers will be noclipped and cloaked.
Permission.AdministrateDefaultKey = KEY_V

-- Rank where teammembers can toggle cloak and noclip.
Permission.AdministrateRank = "operator"

-- Wich rank and above should get the DC15-T
Permission.AdministrateWeaponRank = "admin"

-- Weapon given to Admin+ When noclipping.
Permission.AdminWeapons = {}

-- Clientside restrictions.
if CLIENT then
    -- Minimum group at which a player is able to open the spawn menu. false to allow it to everyone.
    Permission.OpenSpawnMenu = false

    -- Minimum group at which a player is able to open the context menu (C-menu).
    Permission.MinimumContextMenuGroup = "user"
end

if SERVER then
    -- Minimum group at which a player is able to spawn any object. Global restriction for spawning.
    Permission.SpawnObjects = "operator"

    -- Minimum group at which a player is able to spawn props.
    Permission.SpawnProp = "operator"

    -- Minimum group at which a player is able to spawn NPCs.
    Permission.SpawnNPC = "operator"

    -- Minimum group at which a player is able to use the contextmenu-options (C-Menu -> remove etc.).
    Permission.CanProperty = "operator"

    -- Minimum group at which a player is able to use the context-menu optionns for map props.
    Permission.CanPropertyMap = "admin"

    -- Minimum group at which a player is able to use tools.
    Permission.CanTool = "operator"

    Permission.LimitedCanTool = {
--        ["rank"] = {
--            ["toolname"] = true,
--            ["toolname"] = false,
--            ["toolname"] = false
--        }
    }

    -- Minim group at which a player is able to tool the map. The creator tool is ignored.
    Permission.CanRemoveMap = "admin"

    -- Minimum group at which a player is able to spawn ragdolls.
    Permission.SpawnRagdoll = "operator"

    -- Minimum group at which a player is able to spawn scripted entities.
    Permission.SpawnSENT = "operator"

    -- Minimum group at which a player is able to spawn effects.
    Permission.SpawnEffect = "operator"

    -- Minimum group at which a player is able to spawn vehicle.
    Permission.SpawnVehicle = "operator"

    -- Minimum group at which a player is able to spawn and give weapons via spawnmenu (Q-menu).
    Permission.SpawnGiveWeapon = "operator"

    -- Whether players will be allowed to allow sprays.
    Permission.AllowSprays = false

    -- Whether to allow suiciding (kill command).
    -- - Boolean false to disallow suicide for everyone.
    -- - Boolean true to allow it for everyone.
    -- - String userGroup to allow it for everyone above the usergroup.
    Permission.AllowSuicide = false
end

-- Group that is required for "vanishing".
Permission.VanishRank = "superadmin"
--gamemodes/egmrp/gamemode/core/eventlog/sh_config.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--     Server | Event Log Config     --
---------------------------------------
--  Variables should be overwritten  --
--     in the deriving gamemode!     --
---------------------------------------

-- Specifies how long (in days) logs should be kept. false to not delete old logs.
EventLog.Expire = 30

-- The maximum number of elements a page can have in the player manager. The higher the number the higher the loading time.
EventLog.PageSize = 50

-- The minimum group required to access the event logs.
EventLog.MinAccessGroup = "operator"

-- The background image of the event log menu.
EventLog.Background = "backgrounds/olmate_ubafest_shrine_of_the_physgod.jpg"

-- The default key to open the event logs.
EventLog.DefaultKey = KEY_F9

-- Delay in seconds between each save of the event logs.
EventLog.SaveTimer = 30
--gamemodes/egmrp/gamemode/core/chat/cl_chat.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--           Chat | Client           --
---------------------------------------

if SCB_LOADED then
    Chat.SCBFadeOutTime = GetConVar("scb_message_fade_out_time"):GetFloat()
    cvars.AddChangeCallback("scb_message_fade_out_time", function(_, _, value_new)
        Chat.SCBFadeOutTime = value_new
    end)

    Chat.SCBShowTimestamps = GetConVar("scb_show_timestamps"):GetBool()
    cvars.AddChangeCallback("scb_show_timestamps", function(_, _, value_new)
        Chat.SCBShowTimestamps = tobool(value_new)
    end)

    Chat.SCBShowAvatars = GetConVar("scb_show_avatars"):GetBool()
    cvars.AddChangeCallback("scb_show_avatars", function(_, _, value_new)
        Chat.SCBShowAvatars = tobool(value_new)
    end)
end

net.Receive("ChatMessage", function()
    local message = {}

    -- If atlaschat or SCB is not enabled, we are converting player entities to strings so that we
    -- can display a player with custom names or colors (atlaschat has this feature builtin).
    if atlaschat or SCB_LOADED then
        message = net.ReadTable()
    else
        for k, v in SortedPairs(net.ReadTable()) do
            if type(v) == "Player" then
                table.insert(message, team.GetColor(v:Team()))
                table.insert(message, v:GetName())
            else
                table.insert(message, v)
            end
        end
    end

    if message[2] == "[GOOC]" and not tobool(Settings:Get("GOOC")) then return end -- TODO: Move into socket module!

    if SCB_LOADED and scb.chatbox then
        -- Taken from SCB Code and modified.
        -- (C) SCB Chatbox
        local scroll_panel = scb.chatbox.scroll_panel
        local down = scroll_panel:ShouldScrollDown()

        local line = scroll_panel:Add("SCB.ChatLine")
        line:HideAfterTime(Chat.SCBFadeOutTime)

        line.parsing = true
        line.time = os.date(scb.config.timestamps_format)

        if Chat.SCBShowTimestamps then
            line:SetFont(SCB_16)
            line:NewLabel(line.time .. " ", Color(164, 164, 164))
            line:SetFont(SCB_18)
        end

        local current_color = line.text_color
        for i, v in pairs(message) do
            local t = scb.type(v)

            if t == "table" then
                current_color = Color(v.r, v.g, v.b, v.a)
            elseif t == "Color" then
                current_color = v
            elseif t == "string" then
                if string.StartWith(v, "<avatar=") then
                    local split = string.Split(v, ">")
                    local steamid = string.sub(split[1], 9)
                    local steamid64 = util.SteamIDTo64(steamid)
                    line:NewAvatar(steamid64)
                    line.steamid = steamid64

                    v = split[2]
                end

                if scb.config.parse_in_chat then
                    line:Parse(v, current_color)
                else
                    line:NewLabel(v, current_color)
                end
            elseif scb.isentity(v) and not IsValid(v) and not v:IsWorld() then
                line:NewLabel("NULL", current_color)
            elseif t == "Player" then
                if Chat.SCBShowAvatars then
                    line:NewAvatar(v)
                end

                line:NewLabel(v:Name(), team.GetColor(v:Team()))
            elseif t == "Entity" then
                line:NewLabel(v:GetClass(), current_color)
            end
        end

        line.parsing = nil

        line:SizeToChildren(false, true)

        if down then
            scroll_panel:ScrollToBottom()
        end
    else
        chat.AddText(unpack(message))
    end

    chat.PlaySound()
end)

-- Disable Default Join / Leave and Convar Messages
hook.Add("ChatText", "Chat.PreventDefaultJoin", function(index, name, text, messageType)
    if messageType == "joinleave" or messageType == "servermsg" then
        return true
    end
end)

-- Join / Leave messages. Atlaschat /SCB integration: It has it's own messages.
if Chat.JoinLeaveMessages and not atlaschat and not SCB_LOADED then
    net.Receive("Chat.PlayerConnected", function(len)
        local name = net.ReadString()
        local steamid = net.ReadString()

        chat.AddText(
            Config.PrefixColor,
            Config.Prefix,
            GetColor("white"),
            " " .. egmt("shared.player") .. " ",
            GetColor("green"),
            name,
            GetColor("lightgray"),
            " (" .. steamid .. ") ",
            GetColor("white"),
            egmt("chat.hasjoined")
        )
    end)

    gameevent.Listen("player_disconnect")
    hook.Add("player_disconnect", "Chat.PlayerDisconnected", function(data)
        chat.AddText(
            Config.PrefixColor,
            Config.Prefix,
            GetColor("white"),
            egmt("shared.player") .. " ",
            GetColor("red"),
            data.name,
            GetColor("lightgray"),
            " (" .. data.networkid .. ") ",
            GetColor("white"),
            egmt("chat.hasleft"),
            GetColor("lightgray"),
            data.reason
        )
    end)
end
--gamemodes/egmrp/gamemode/core/voicechat/cl_ui.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2024          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--       Client | Voicechat UI       --
---------------------------------------

local voice_mat = Material("talkicon/voice.png")
function VoiceChat:ShowVoiceUI()
	surface.SetDrawColor(UI.ForegroundColor)
	surface.SetMaterial(voice_mat)
	surface.DrawTexturedRect(ScrW() * 0.79, ScrH() * 0.02, ScrW() * 0.025, ScrW() * 0.025)
end

hook.Add("PlayerStartVoice", "VoiceChat.HideVoiceUI", function(ply)
	if ply == LocalPlayer() then
		hook.Add("HUDPaint", "VoiceChat.ShowVoiceUI", VoiceChat.ShowVoiceUI)
		return true
	end

	if not VoiceChat.ShowVoiceUI then
		return true
	end
end)

hook.Add("PlayerEndVoice", "VoiceChat.HideVoiceUI", function(ply)
	if ply == LocalPlayer() then
		hook.Remove("HUDPaint", "VoiceChat.ShowVoiceUI")
	end
end)
--gamemodes/egmrp/gamemode/core/manager/cl_manager.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--          Manager | Client         --
---------------------------------------

-- List of all object categories available in the manager.
Manager.ObjectCategories = Manager.ObjectCategories or {}

-- Register an object category for the manager.
--
-- @param String categoryType
-- @param String name
-- @param Function getObjects
-- @param Function openObject
-- @param Function getPropertyList
-- @param String duplicate
-- @param String delete
-- @param String deleteModal
-- @param String add
-- @param String save
-- @param String defaultChild
function Manager:RegisterObjectCategory(categoryType, name, getObjects, addObject, getPropertyList, duplicate, delete, deleteModal, add, save, defaultChild)
    local categoryData = {
        CategoryType = categoryType,
        Name = name,

        GetObjects = getObjects,
        AddObject = addObject,
        GetPropertyList = getPropertyList,

        Duplicate = duplicate,
        Delete = delete,
        DeleteModal = deleteModal,
        Add = add,
        Save = save,

        DefaultChild = defaultChild,
    }

    self:RegisterCategoryHooks(categoryType)

    self.ObjectCategories[categoryType] = categoryData
end

-- List of object Types available in the manager.
Manager.ObjectTypes = Manager.ObjectTypes or {}

-- Register an object type for the manager.
--
-- @param String categoryType
-- @param String objectType
-- @param String name
-- @param Function getObjects
-- @param Function openObject
-- @param Function getPropertyList
-- @param String duplicate
-- @param String delete
-- @param String deleteModal
-- @param String add
-- @param String save
function Manager:RegisterObjectType(categoryType, objectType, name, getObjects, addObject, getPropertyList, duplicate, delete, deleteModal, add, save)
    local objectTypeData = {
        CategoryType = categoryType,
        ObjectType = objectType,
        Name = name,

        GetObjects = getObjects,
        AddObject = addObject,
        GetPropertyList = getPropertyList,

        Duplicate = duplicate,
        Delete = delete,
        DeleteModal = deleteModal,
        Add = add,
        Save = save,
    }

    self:RegisterObjectHooks(objectType)

    self.ObjectTypes[categoryType] = self.ObjectTypes[categoryType] or {}
    self.ObjectTypes[categoryType][objectType] = objectTypeData
end



---------------------------------------
--              UI Setup             --
---------------------------------------

-- Closes the manager.
function Manager:Close()
    if IsValid(self.Frame) then
        self.Frame:Close()
    end
end

-- Opens the manager.
function Manager:Open()
    if not LocalPlayer():IsAtLeast(self.MinAccessGroup) then
        Notify:Danger(egmt("shared.access_denied"), egmt("manager.access_denied"))

        return
    end

    -- Close the manager if it is already open.
    self:Close()

    self.Frame = vgui.Create("EGMFrame")
    self.Frame:SetBackground(self.Background)
    self.Frame:SetSubTitle(egmt("manager.name"))

    local defaultId = self:CreateCategoryList()
    self:CreateObjectList()
    self:CreateObjectProperties()

    local categoryPanel = self.CategoryPanel
    if not IsValid(categoryPanel) then
        return
    end

    -- Enable the faction panel by default.
    self.CategoryPanel:SetActive(true)

    local categorySelector = categoryPanel.Selector
    if not IsValid(categorySelector) then
        return
    end

    -- Select default if available.
    if isnumber(defaultId) then
        categorySelector:ChooseOptionID(defaultId)
    end

    hook.Run("Manager.Open", self)

    self.Frame:MakePopup()
end

-- Creeates a selection panel used by category and object list.
--
-- @param Panel parent
-- @param Function onEntryTypeSelected
-- @param Function onEntrySelected
function Manager:CreateSelectionPanel(parent, onEntryTypeSelected, onEntrySelected)
    local _self = self

    if not IsValid(parent) then
        return
    end

    local w, h = ScrW(), ScrH()

    parent.SelectedEntryType = nil
    parent.Filter = nil
    function parent:Paint(ww, hh)
        draw.RoundedBox(0, 0, 0, ww, hh, UI.BackgroundColor2)
    end

    -- Create the category selector, which allows you to select an entry type.
    local selector = vgui.Create("EGMComboBox", parent)
    selector:Dock(TOP)
    selector:DockMargin(w * 0.003, h * 0.005, w * 0.003, h * 0.005)
    selector:SetHeight(h * 0.03)
    selector:SetText(egmt("manager.nothing"))
    selector:SetDropDownHeight(h * 0.03)

    -- Create the entry list, which shows all entries of the selected entry type.
    local entryList = vgui.Create("EGMListView", parent)
    entryList:Dock(FILL)
    entryList:DockMargin(w * 0.003, 0, w * 0.003, h * 0.005)
    entryList:SetHeaderHeight(0)
    entryList:SetDataHeight(h * 0.03)
    entryList:SetMultiSelect(false)
    entryList:AddCustomColumn("Name")
    local sortColumn = entryList:AddCustomColumn("Sort")
    sortColumn:SetMaxWidth(0)

    -- Create the add button, which allows you to add a new entry.
    local addButton = vgui.Create("EGMButton", parent)
    addButton:Dock(BOTTOM)
    addButton:DockMargin(w * 0.003, 0, w * 0.003, h * 0.005)
    addButton:SetHeight(h * 0.03)
    addButton:SetTextColor(UI.TextColor)
    addButton:SetFont("EGMText8")
    addButton:SetText(egmt("manager.nothing"))

    -- Create a search bar for the entry list.
    local searchBar = vgui.Create("DTextEntry", parent)
    searchBar:Dock(BOTTOM)
    searchBar:DockMargin(w * 0.003, 0, w * 0.003, h * 0.005)
    searchBar:SetHeight(h * 0.03)
    searchBar:SetPlaceholderText(egmt("manager.search"))
    searchBar:SetFont("EGMText8")

    -- Select an entry type, which upates the entry list.
    function selector:OnSelect(_, _, entryTypeData)
        addButton:SetText(entryTypeData.Add)

        -- Update the selection panel with the new entry type objects.
        parent.SelectedEntryType = entryTypeData
        _self:UpdateSelectionPanel(parent)

        if isfunction(onEntryTypeSelected) then
            onEntryTypeSelected(entryTypeData)
        end

        local propertyPanel = _self.PropertiesPanel
        if not IsValid(propertyPanel) then
            return
        end

        propertyPanel:SetActive(false)
    end

    -- Select an entry, which updates some child panels.
    function entryList:OnRowSelected(index, line)
        if isfunction(onEntrySelected) then
            onEntrySelected(line.Object)
        end

        local propertyPanel = _self.PropertiesPanel
        if not IsValid(propertyPanel) then
            return
        end

        propertyPanel.SelectedObject = line.Object
        propertyPanel.SelectedObjectType = parent.SelectedEntryType
        propertyPanel.ParentObject = parent.ParentObject

        _self:UpdatePropertiesPanel()
    end

    -- Right click an entry, which opens a context menu.
    function entryList:OnRowRightClick(index, line)
        local selectedEntryType = parent.SelectedEntryType
        if not istable(selectedEntryType) then
            return
        end

        local object = line.Object
        if not object then
            return
        end

        -- Create a right-click context menu.
        local context = DermaMenu()

        if not isfunction(object.GetParent) or parent.ParentObject == nil or object:GetParent() == parent.ParentObject then
            -- Copy the entry.
            context:AddOption(selectedEntryType.Duplicate, function()
                object:Copy()
            end):SetImage("icon16/page_white_copy.png")

            -- Delete the entry.
            context:AddOption(selectedEntryType.Delete, function()
                local modal = vgui.Create("EGMModal")
				modal:SetCustomTitle(egmt("shared.are_you_sure"))
                modal:Confirm(selectedEntryType.DeleteModal, function()
                    object:Delete()
                end)
            end):SetImage("icon16/cross.png")

			-- Add "Get Id" option to the context menu.
			context:AddOption("Get ID", function()
				SetClipboardText(object:GetId())
			end):SetImage("icon16/page_white_copy.png")
        end

        hook.Run("Manager.EntryRightClick", context, selectedEntryType, object)

        -- Open the context menu.
        context:Open()
    end

    -- Click the add button, which opens a modal to create a new entry.
    function addButton:DoClick()
        local selectedEntryType = parent.SelectedEntryType
        if not istable(selectedEntryType) then
            return
        end

        local success, errors = selectedEntryType.AddObject(parent.ParentObject)
        if not success then
            local errorString = table.concat(errors, "\n")
            Notify:Danger(egmt("shared.error"), errorString)
            PrintTable(errors)

            return
        end
    end

    -- Search for entries in the entry list.
    function searchBar:OnValueChange(value)
        -- Update the selection panel with the new filter.
        parent.Filter = value

        _self:UpdateSelectionPanel(parent)
    end

    -- Set the active state of the parent.
    function parent:SetActive(active)
        self:SetMouseInputEnabled(active)

        if active then
            selector:SetMainColor(UI.ForegroundColor)

            addButton:SetButtonColor(UI.ForegroundColor)
        else
            selector:SetMainColor(UI.BackgroundColor2)
            selector:Clear()
            selector:SetText(egmt("manager.nothing"))

            entryList:Clear()

            addButton:SetButtonColor(UI.BackgroundColor2)
            addButton:SetText(egmt("manager.nothing"))

            parent.SelectedEntryType = nil
        end
    end

    -- Set inactive by default.
    parent:SetActive(false)

    parent.Selector = selector
    parent.EntryList = entryList
    parent.AddButton = addButton
end

-- Creates the category list.
function Manager:CreateCategoryList()
    local _self = self

    if IsValid(self.CategoryPanel) then
        self.CategoryPanel:Remove()
    end

    local w, h = ScrW(), ScrH()

    -- Create the panel for the category list.
    local panel = vgui.Create("DPanel", self.Frame)
    panel:SetPos(w * 0.04, h * 0.25)
    panel:SetSize(w * 0.2, h * 0.7)

    -- Generate the selection panel.
    self:CreateSelectionPanel(panel, function(entryTypeData)
        local objectPanel = _self.ObjectPanel
        if not IsValid(objectPanel) then
            return
        end

        objectPanel.ParentObject = nil
        objectPanel:SetActive(false)
    end, function(object)
        local selectedCategoryType = panel.SelectedEntryType
        if not istable(selectedCategoryType) then
            return
        end

        local categoryType = selectedCategoryType.CategoryType
        if not isstring(categoryType) then
            return
        end

        local objectPanel = _self.ObjectPanel
        if not IsValid(objectPanel) then
            return
        end

        objectPanel.ParentObject = object
        objectPanel:SetActive(true)

        local objectSelector = objectPanel.Selector
        if not IsValid(objectSelector) then
            return
        end

        local defaultType = selectedCategoryType.DefaultChild
        local selectedObjectType = objectPanel.SelectedEntryType
        if istable(selectedObjectType) then
            defaultType = selectedObjectType.ObjectType
        end

        objectSelector:Clear()

        local objectTypes = _self.ObjectTypes[categoryType] or {}
        if table.Count(objectTypes) == 0 then
            _self.ObjectPanel:SetActive(false)

            return
        end

        local defaultId
        for objectType, objectTypeData in pairs(_self.ObjectTypes[categoryType] or {}) do
            local id = objectSelector:AddChoice(objectTypeData.Name, objectTypeData)

            if objectType == defaultType then
                defaultId = id
            end
        end

        -- Select default if available.
        if isnumber(defaultId) then
            objectSelector:ChooseOptionID(defaultId)
        end
    end)

    local categorySelector = panel.Selector
    if not IsValid(categorySelector) then
        return
    end

    -- Add all entry types to the selector.
    local defaultId
    for categoryType, categoryData in pairs(self.ObjectCategories) do
        local id = categorySelector:AddChoice(categoryData.Name, categoryData)

        if categoryType == self.DefaultCategory then
            defaultId = id
        end
    end

    self.CategoryPanel = panel

    return defaultId
end

-- Creates the object list.
function Manager:CreateObjectList()
    if IsValid(self.ObjectPanel) then
        self.ObjectPanel:Remove()
    end

    local w, h = ScrW(), ScrH()

    -- Create the panel for the object list.
    local panel = vgui.Create("DPanel", self.Frame)
    panel:SetPos(w * 0.28, h * 0.25)
    panel:SetSize(w * 0.2, h * 0.7)

    -- Generate the selection panel.
    self:CreateSelectionPanel(panel)

    self.ObjectPanel = panel
end

-- Creates the object properties.
function Manager:CreateObjectProperties()
    if IsValid(self.PropertyPanel) then
        self.PropertyPanel:Remove()
    end

    local w, h = ScrW(), ScrH()

    local panel = vgui.Create("DPanel", self.Frame)
    panel:SetPos(w * 0.52, h * 0.25)
    panel:SetSize(w * 0.44, h * 0.7)
    function panel:Paint(ww, hh)
        draw.RoundedBox(0, 0, 0, ww, hh, UI.BackgroundColor2)
    end

    local objectName = vgui.Create("DLabel", panel)
    objectName:Dock(TOP)
    objectName:DockMargin(w * 0.003, h * 0.005, w * 0.003, h * 0.005)
    objectName:SetHeight(h * 0.03)
    objectName:SetTextColor(Color(0, 0, 0, 0))
    objectName:SetText(egmt("manager.nothing"))

    local objectPropertiesList = vgui.Create("EGMScrollPanel", panel)
    objectPropertiesList:Dock(FILL)
    objectPropertiesList:DockMargin(w * 0.003, 0, w * 0.003, h * 0.005)
    objectPropertiesList:SetBackgroundColor(Color(0, 0, 0, 0))

    local objectSaveButton = vgui.Create("EGMButton", panel)
    objectSaveButton:Dock(BOTTOM)
    objectSaveButton:DockMargin(w * 0.003, 0, w * 0.003, h * 0.005)
    objectSaveButton:SetHeight(h * 0.03)
    objectSaveButton:SetTextColor(UI.TextColor)
    objectSaveButton:SetFont("EGMText8")
    objectSaveButton:SetText(egmt("manager.nothing"))

    panel.ObjectName = objectName
    panel.ObjectPropertiesList = objectPropertiesList
    panel.ObjectSaveButton = objectSaveButton

    function objectName:Paint(width, height)
        if panel:IsMouseInputEnabled() and objectSaveButton:IsMouseInputEnabled() then
            draw.RoundedBox(0, 0, 0, width, height, UI.ForegroundColor)
        else
            draw.RoundedBox(0, 0, 0, width, height, UI.BackgroundColor2)
        end

        local text = self:GetText()
        if text ~= "" then
            draw.SimpleText(text, "EGMText8", width * 0.5, height * 0.5, UI.TextColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
        end
    end

    -- Set the active state of the panel.
    function panel:SetActive(active)
        self:SetMouseInputEnabled(active)

        if active then
            objectSaveButton:SetButtonColor(UI.ForegroundColor)
        else
            objectName:SetText(egmt("manager.nothing"))

            objectPropertiesList:Clear()

            objectSaveButton:SetButtonColor(UI.BackgroundColor2)
            objectSaveButton:SetText(egmt("manager.nothing"))

            panel.SelectedObject = nil
            panel.SelectedObjectType = nil
            panel.ParentObject = nil

            panel.CurrentValues = nil
        end
    end

    -- Save the current object.
    function objectSaveButton:DoClick()
        local selectedObject = panel.SelectedObject
        if not istable(selectedObject) then
            return
        end

        local currentValues = panel.CurrentValues
        if not istable(currentValues) then
            return
        end

        local objectProperties = {}
        for k, v in pairs(currentValues) do
            objectProperties[k] = v()
        end

        local success, errors = selectedObject:EditProperties(objectProperties)
        if not success then
            local errorString = table.concat(errors, "\n")
            Notify:Danger(egmt("shared.error"), errorString)
            PrintTable(errors)
        end
    end

    -- Set inactive by default.
    panel:SetActive(false)

    self.PropertiesPanel = panel
end



---------------------------------------
--            UI Updating            --
---------------------------------------

-- Updates the selection panel with the current selected entry type.
--
-- @param Panel parent
function Manager:UpdateSelectionPanel(parent)
    local selectedEntryType = parent.SelectedEntryType
    if not istable(selectedEntryType) then
        return
    end

    local entryList = parent.EntryList
    if not IsValid(entryList) then
        return
    end

    local filter = parent.Filter
    if not isstring(filter) then
        filter = false
    end

    entryList:Clear()

    for _, object in pairs(selectedEntryType.GetObjects(parent.ParentObject)) do
        local name = object:GetName()
        if filter and not string.find(name:lower(), filter:lower()) then
            continue
        end

        local line = entryList:AddCustomLine(name, object:GetSort())
        line.Object = object

        if not object:IsValid() then
            line:SetCustomTextColor(GetColor("red"))
        end

        if isfunction(object.GetParent) and parent.ParentObject and object:GetParent() ~= parent.ParentObject then
            line:SetCustomTextColor(GetColor("yellow"))
        end
    end

    -- Name Column is sorted first, so it is alphabetically sorted.
    entryList:SortByColumn(1, false)
    -- Then the sort column is sorted, so it is sorted by the sort value.
    entryList:SortByColumn(2, false)
    -- This causes objects with the same sort value to be sorted alphabetically.
end

-- Updates the properties panel with the current selected object.
function Manager:UpdatePropertiesPanel()
    local propertyPanel = self.PropertiesPanel
    if not IsValid(propertyPanel) then
        return
    end

    local selectedObject = propertyPanel.SelectedObject
    if not istable(selectedObject) then
        return
    end

    local selectedObjectType = propertyPanel.SelectedObjectType
    if not istable(selectedObjectType) then
        return
    end

    propertyPanel:SetActive(true)

    local objectName = propertyPanel.ObjectName
    if not IsValid(objectName) then
        return
    end

    objectName:SetText(selectedObject:GetName())

    local objectSaveButton = propertyPanel.ObjectSaveButton
    if not IsValid(objectSaveButton) then
        return
    end

    objectSaveButton:SetText(selectedObjectType.Save)

    local objectPropertiesList = propertyPanel.ObjectPropertiesList
    if not IsValid(objectPropertiesList) then
        return
    end

    local propertyList
    if isfunction(selectedObjectType.GetPropertyList) then
        propertyList = selectedObjectType.GetPropertyList(propertyPanel.ParentObject, selectedObject)
    else
        propertyList = selectedObject:GetModel():GetPropertyList(selectedObject)
    end

    local overrideCanEdit = false
    if propertyPanel.ParentObject ~= nil and isfunction(selectedObject.GetParent) and selectedObject:GetParent() ~= propertyPanel.ParentObject then
        overrideCanEdit = true
    end

    local values, canEdit = PropertyList:CreatePropertyList(objectPropertiesList, propertyList, selectedObject, overrideCanEdit)
    propertyPanel.CurrentValues = values

    if canEdit then
        objectSaveButton:SetMouseInputEnabled(true)
        objectSaveButton:SetButtonColor(UI.ForegroundColor)
    else
        objectSaveButton:SetMouseInputEnabled(false)
        objectSaveButton:SetButtonColor(UI.BackgroundColor2)
    end
end

-- Register Hooks, to update the manager, if a category object is created, edited or deleted.
function Manager:RegisterCategoryHooks(categoryType)
    -- Update the list, if a new object is created.
    hook.Add(categoryType .. ".Created", "Manager.OnCreate", function(object)
        local categoryPanel = Manager.CategoryPanel
        if not IsValid(categoryPanel) then
            return
        end

        Manager:UpdateSelectionPanel(categoryPanel)
    end)

    -- Update the list, if an object is deleted.
    hook.Add(categoryType .. ".PostDelete", "Manager.OnDelete", function(object)
        local categoryPanel = Manager.CategoryPanel
        if not IsValid(categoryPanel) then
            return
        end

        Manager:UpdateSelectionPanel(categoryPanel)

        -- If the deleted object is the selected category, close the object panel.
        local objectPanel = Manager.ObjectPanel
        if not IsValid(objectPanel) then
            return
        end

        if objectPanel.ParentObject == object then
            objectPanel:SetActive(false)
        end

        -- If the deleted object is the selected object or if it is the parent of the selected object, close the property panel.
        local propertyPanel = Manager.PropertiesPanel
        if not IsValid(propertyPanel) then
            return
        end

        if propertyPanel.SelectedObject == object or propertyPanel.ParentObject == object then
            propertyPanel:SetActive(false)
        end
    end)

    -- Update the list, if an object has its data changed.
    hook.Add(categoryType .. ".DataChanged", "Manager.OnDataChanged", function(object)
        local categoryPanel = Manager.CategoryPanel
        if not IsValid(categoryPanel) then
            return
        end

        Manager:UpdateSelectionPanel(categoryPanel)

        -- If the edited object is the selected object, update the property panel.
        local propertyPanel = Manager.PropertiesPanel
        if not IsValid(propertyPanel) then
            return
        end

        if propertyPanel.SelectedObject == object or propertyPanel.ParentObject == object then
            Manager:UpdatePropertiesPanel()
        end
    end)

    -- Update the list, if an object has its properties changed.
    hook.Add(categoryType .. ".PropertyChanged", "Manager.OnPropertyChanged", function(object)
        local categoryPanel = Manager.CategoryPanel
        if not IsValid(categoryPanel) then
            return
        end

        Manager:UpdateSelectionPanel(categoryPanel)

        -- If the edited object is the selected object, update the property panel.
        local propertyPanel = Manager.PropertiesPanel
        if not IsValid(propertyPanel) then
            return
        end

        if propertyPanel.SelectedObject == object or propertyPanel.ParentObject == object then
            Manager:UpdatePropertiesPanel()
        end
    end)
end

-- Register Hooks, to update the manager, if an object is created, edited or deleted.
function Manager:RegisterObjectHooks(objectType)
    -- Update the list, if a new object is created.
    hook.Add(objectType .. ".Created", "Manager.OnCreate", function(object)
        local objectPanel = Manager.ObjectPanel
        if not IsValid(objectPanel) then
            return
        end

        Manager:UpdateSelectionPanel(objectPanel)
    end)

    -- Update the list, if an object is deleted.
    hook.Add(objectType .. ".PostDelete", "Manager.OnDelete", function(object)
        local objectPanel = Manager.ObjectPanel
        if not IsValid(objectPanel) then
            return
        end

        Manager:UpdateSelectionPanel(objectPanel)

        -- If the deleted object is the selected object, close the property panel.
        local propertyPanel = Manager.PropertiesPanel
        if not IsValid(propertyPanel) then
            return
        end

        if propertyPanel.SelectedObject == object then
            propertyPanel:SetActive(false)
        end
    end)

    -- Update the list, if an object has its data changed.
    hook.Add(objectType .. ".DataChanged", "Manager.OnDataChanged", function(object)
        local objectPanel = Manager.ObjectPanel
        if not IsValid(objectPanel) then
            return
        end

        Manager:UpdateSelectionPanel(objectPanel)

        -- If the edited object is the selected object, update the property panel.
        local propertyPanel = Manager.PropertiesPanel
        if not IsValid(propertyPanel) then
            return
        end

        if propertyPanel.SelectedObject == object then
            Manager:UpdatePropertiesPanel()
        end
    end)

    -- Update the list, if an object has its properties changed.
    hook.Add(objectType .. ".PropertyChanged", "Manager.OnPropertyChanged", function(object)
        local objectPanel = Manager.ObjectPanel
        if not IsValid(objectPanel) then
            return
        end

        Manager:UpdateSelectionPanel(objectPanel)

        -- If the edited object is the selected object, update the property panel.
        local propertyPanel = Manager.PropertiesPanel
        if not IsValid(propertyPanel) then
            return
        end

        if propertyPanel.SelectedObject == object then
            Manager:UpdatePropertiesPanel()
        end
    end)
end
--gamemodes/egmrp/gamemode/core/player/sh_index.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--        Playersystem index         --
---------------------------------------

PlayerConfig = PlayerConfig or {}
PlayerData = PlayerData or table.Copy(PropertyModel)
PlayerManager = PlayerManager or {}
Restriction = Restriction or {}

if SERVER then
    AddCSLuaFile("sh_config.lua")
    AddCSLuaFile("sh_player.lua")
    AddCSLuaFile("sh_playerintegration.lua")

    AddCSLuaFile("cl_player.lua")
    AddCSLuaFile("cl_playerintegration.lua")

    AddCSLuaFile("cl_manager.lua")
    AddCSLuaFile("cl_keybinds.lua")

    include("sh_config.lua")
    include("sh_player.lua")
    include("sh_playerintegration.lua")

    include("sv_player.lua")

    include("sv_manager.lua")
    include("sv_eventlog.lua")
    include("sv_weapondrop.lua")
end

if CLIENT then
    include("sh_config.lua")
    include("sh_player.lua")
    include("sh_playerintegration.lua")

    include("cl_player.lua")
    include("cl_playerintegration.lua")

    include("cl_manager.lua")
    include("cl_keybinds.lua")
end
--gamemodes/egmrp/gamemode/core/faction/cl_manager.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--      Client | Faction Manager     --
---------------------------------------

Manager:RegisterObjectCategory(
    Faction.Name,
    egmt("faction.name"),
    function()
        return Faction:GetCache()
    end,
    function()
        return Faction:Create({}, {name = egmt("faction.new")})
    end,
    nil,
    egmt("faction.duplicate_long"),
    egmt("faction.delete"),
    egmt("faction.delete_warning"),
    egmt("faction.add"),
    egmt("faction.save"),

    "Rank"
)
--gamemodes/egmrp/gamemode/core/rank/sh_config.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--           Rank | Config           --
---------------------------------------
--  Variables should be overwritten  --
--     in the deriving gamemode!     --
---------------------------------------

-- Every possible slot type a rank can have.
Rank.SlotTypes = {
    mainSlot = {
        name = egmt("character.main_char"),
        usesGlobalSlot = true,
        slots = function(ply)
            return 2
        end
    },
    sideSlot = {
        name = egmt("character.side_char"),
        usesGlobalSlot = true,
        slots = function(ply)
            return -1
        end
    },
    noSlot = {
        name = egmt("character.no_slot"),
        usesGlobalSlot = false,
        slots = function(ply)
            return -1
        end
    }
-- Add This block, when using the event module!
--    event = {
--        name = egmt("character.event_char"),
--        usesGlobalSlot = false,
--        slots = function(ply)
--            return 3
--        end
--    }
}

-- The default slot type of a rank.
Rank.DefaultSlotType = "mainSlot"

-- Function to return the maximum number of slots.
Rank.MaxGlobalSlots = function(ply)
    if ply.IsDonator and ply:IsDonator("donator") then
        return 5
    end

    return 3
end
--gamemodes/egmrp/gamemode/core/equipment/cl_equipment.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--         Client | Equipment        --
---------------------------------------

-- Clear property list to avoid duplicate entries.
Equipment.PropertyList = {}

Equipment:AddPropertyToList("rankWhitelist", egmt("equipment.rankWhitelist"), egmt("equipment.rankWhitelist_description"), "list", function(faction)
    local ranks = {}

    for _, rank in SortedPairs(faction:GetSortedRanks()) do
        table.insert(ranks, {
            text = rank:GetName(),
            data = rank:GetId(),
        })
    end

    return ranks
end, nil, 1, egmt("equipment.conditions"))

Equipment:AddPropertyToList("inheritEquipment", egmt("equipment.inherit"), egmt("equipment.inherit_description"), "boolean", nil, nil, 2, egmt("equipment.conditions"))

Equipment:AddPropertyToList("healthBonus", egmt("equipment.health_bonus"), egmt("equipment.health_bonus_description"), "slider", function()
    return {min = -1000, max = 1000}
end, nil, 1, egmt("rank.stats"))

Equipment:AddPropertyToList("armorBonus", egmt("equipment.armor_bonus"), egmt("equipment.armor_bonus_description"), "slider", function()
    return {min = -255, max = 255}
end, nil, 2, egmt("rank.stats"))

Equipment:AddPropertyToList("speedBonus", egmt("equipment.speed_bonus"), egmt("equipment.speed_bonus_description"), "slider", function()
    return {min = -500, max = 500}
end, nil, 3, egmt("rank.stats"))

Equipment:AddPropertyToList("jumpBonus", egmt("equipment.jump_bonus"), egmt("equipment.jump_bonus_description"), "slider", function()
	return {min = -500, max = 500}
end, nil, 4, egmt("rank.stats"))

Equipment:AddPropertyToList("blacklist", egmt("equipment.blacklist"), egmt("equipment.blacklist_description"), "boolean", function()
    return {egmt("equipment.blacklist_yes"), egmt("equipment.blacklist_no")}
end, nil, 1, egmt("equipment.category"))

Equipment:AddPropertyToList("models", egmt("equipment.models"), egmt("equipment.models_description"), "models", function(faction, equipment)
    local validModels = table.Copy(player_manager.AllValidModels())
	hook.Run("Equipment.AddModels", faction, equipment, validModels)
	hook.Run("Equipment.RemoveModels", faction, equipment, validModels)

    return {validModels = validModels, inheritedModels = {}}
end, nil, 2, egmt("equipment.category"))

Equipment:AddPropertyToList("weapons", egmt("equipment.weapons"), egmt("equipment.weapons_description"), "table", function(faction, equipment)
    local values = {
        validValues = {}
    }

    for weaponClass, weaponData in SortedPairs(list.Get("Weapon")) do
        if Manager.HideUnspawnableWeapons and not weaponData.Spawnable then continue end
        if table.HasValue(Character.DefaultWeapons, weaponClass) then continue end

        values.validValues[weaponClass] = weaponData.PrintName or weaponClass
    end

	-- Allow other modules to add or remove weapons.
	hook.Run("Equipment.AddWeapons", values.validValues, faction, equipment)
	hook.Run("Equipment.RemoveWeapons", values.validValues, faction, equipment)

    return values
end, nil, 3, egmt("equipment.category"))

-- Register equipment package type.
Loading:RegisterPackageType("equipment", egmt("equipment.package"), function(packageData)
    for k, eData in pairs(packageData) do
        Equipment:Load(eData.data, eData.properties):Cache()
    end
end)
--gamemodes/egmrp/gamemode/core/deathsystem/sh_config.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--       DeathSystem | Config        --
---------------------------------------
--  Variables should be overwritten  --
--     in the deriving gamemode!     --
---------------------------------------

-- How long it takes before you can respawn.
DeathSystem.RespawnTime = 180

-- Minimum group that is required to be able to respawn a player.
DeathSystem.RespawnAccess = "operator"

-- Weapon that is set when player is stunned to prevent interactions.
DeathSystem.StunWeapon = "weapon_fists"

-- Dont remove the corpse after respawn.
DeathSystem.KeepCorpse = true
--gamemodes/egmrp/gamemode/modules/unarmed/weapons/egmrp_unarmed/cl_init.lua:
---------------------------------------
---------------------------------------
--	     	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--            Created by             --
--       Jan 'Oninoni' Ziegler       --
--       		Deltaa       		 --
--                                   --
--   This software is only allowed   --
--    on official 'Einfach Gaming'   --
--     servers owned by 'P4sca1'     --
---------------------------------------
---------------------------------------

---------------------------------------
--       Unarmed SWEP | Client       --
---------------------------------------

include("shared.lua")

SWEP.Author         = "Oninoni"
SWEP.Contact        = "Discord: Oninoni#8830"
SWEP.Purpose        = "Basic, unarmed SWEP"
SWEP.Instructions   = "Pick up things, trigger animations or control consoles."
SWEP.Category       = "EGM:RP"

SWEP.DrawAmmo      = false
SWEP.DrawCrosshair = true

function SWEP:Initialize()
	self:SetHoldType("normal")
end

-- Do nothing, when left-clicking.
function SWEP:PrimaryAttack()
end

-- Open Animation Menu, when right-clicking.
function SWEP:SecondaryAttack()
	if not IsFirstTimePredicted() then
		return
	end

	local owner = self:GetOwner()
	if not IsValid(owner) then
		return
	end

	if owner:GetNWBool("Unarmed.AnimationActive") then
		return
	end

	if owner:GetNWBool("Unarmed.CarryingRagdoll") then
		return
	end

	Interact:OpenCategory("animations")
end

-- Hide the viewmodel.
function SWEP:PreDrawViewModel(vm, pl, wep)
	return true
end
--gamemodes/egmrp/gamemode/modules/inventory/cl_itemtype.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--         Client | Item Type        --
---------------------------------------

-- Clear property list to avoid duplicate entries.
ItemType.PropertyList = {}

-- Add item type properties to list. These are editable in item type edit.
ItemType:AddPropertyToList("name", egmt("itemType.name"), egmt("itemType.name_description"), "string", nil, nil, 1, nil)

ItemType:AddPropertyToList("itemClass", egmt("itemType.itemClass_name"), egmt("itemType.itemClass_description"), "dropdown", function(itemType)
	local itemClasses = {}

	for itemClass, itemClassData in pairs(Inventory.ItemClasses) do
		if #itemClassData.Slots == 0 then continue end

		table.insert(itemClasses, {
			text = itemClassData.Name,
			data = itemClass,
		})
	end

	return itemClasses
end, nil, 2, nil)

ItemType:AddPropertyToList("rarity", egmt("itemType.rarity"), egmt("itemType.rarity_description"), "dropdown", function(itemType)
	local rarities = {}

	for rarity, rarityData in SortedPairs(Inventory.Rarities) do
		table.insert(rarities, {
			text = rarityData.Name,
			data = rarity,
		})
	end

	return rarities
end, nil, 3, nil)

-- Register item type package type.
Loading:RegisterPackageType("itemType", egmt("itemType.package"), function(packageData)
	for k, iData in pairs(packageData) do
		ItemType:Load(iData.data, iData.properties):Cache()
	end
end)



---------------------------------------
--        Filtered Properties        --
---------------------------------------

-- List of properties that should always be shown.
ItemType.AlwaysShowProperties = { "name", "itemClass", "rarity" }

-- Filter the property list dynamically, to only show properties that should be shown.
hook.Add("ItemType.GetPropertyList", "Inventory.FilterProperties", function(propertyList, itemType)
	local itemClass = itemType:GetItemClass()
	if not itemClass then return end

	for _, categoryData in pairs(propertyList) do
		local toBeDeleted = {}
		for _, property in pairs(categoryData) do
			local key = property.key

			-- Skip properties that should always be shown.
			if table.HasValue(ItemType.AlwaysShowProperties, key) then continue end

			-- Hook for adding properties that should be shown.
			if hook.Run("ItemClass.ShouldShowProperty", itemClass, key) then continue end

			-- Skip properties that should be shown by the item class.
			if itemClass:ShouldShowProperty(key) then continue end

			table.insert(toBeDeleted, property)
		end

		for _, property in pairs(toBeDeleted) do
			table.RemoveByValue(categoryData, property)
		end
	end

	local toBeDeleted = {}
	for _, categoryData in pairs(propertyList) do
		if #categoryData == 0 then
			table.insert(toBeDeleted, categoryData)
		end
	end

	for _, categoryData in pairs(toBeDeleted) do
		table.RemoveByValue(propertyList, categoryData)
	end
end)

-- Add the filtered properties to the property list.
ItemType:AddPropertyToList("models", egmt("itemType.models"), egmt("itemType.models_description"), "models", function(itemType)
	local validModels = table.Copy(player_manager.AllValidModels())
	hook.Run("ItemType.AddModels", itemType, validModels)
	hook.Run("ItemType.RemoveModels", itemType, validModels)

	return {validModels = validModels, inheritedModels = {}}
end, nil, 1, egmt("equipment.category"))

ItemType:AddPropertyToList("weapons", egmt("itemType.weapons"), egmt("itemType.weapons_description"), "table", function(itemType)
	local values = {
		validValues = {},
	}

	for weaponClass, weaponData in SortedPairs(list.Get("Weapon")) do
		if Manager.HideUnspawnableWeapons and not weaponData.Spawnable then continue end
		if table.HasValue(Character.DefaultWeapons, weaponClass) then continue end

		if Inventory.ExclusiveWeapons and not itemType:IsWeaponFree(weaponClass) then continue end

		values.validValues[weaponClass] = weaponData.PrintName or weaponClass
	end

	-- Allow other modules to add or remove weapons.
	hook.Run("ItemType.AddWeapons", values.validValues, itemType)
	hook.Run("ItemType.RemoveWeapons", values.validValues, itemType)

	return values
end, nil, 2, egmt("equipment.category"))

ItemType:AddPropertyToList("armorBonus", egmt("itemType.armor"), egmt("itemType.armor_description"), "number", function(itemType)
	return {min = 0, max = 255}
end, nil, 1, egmt("rank.stats"))

ItemType:AddPropertyToList("speedBonus", egmt("itemType.speed"), egmt("itemType.speed_description"), "number", function(itemType)
	return {min = -500, max = 500}
end, nil, 2, egmt("rank.stats"))

ItemType:AddPropertyToList("consealedWeapon", egmt("itemType.consealedWeapon"), egmt("itemType.consealedWeapon_description"), "boolean", nil, nil, 1, egmt("inventory.title"))

ItemType:AddPropertyToList("backpackSlots", egmt("itemType.backpackSlots"), egmt("itemType.backpackSlots_description"), "number", function(itemType)
	return {min = 0, max = 44}
end, nil, 2, egmt("inventory.title"))

if Config.Modules["species"] then
	ItemType:AddPropertyToList("species", egmt("itemType.species"), egmt("itemType.species_description"), "table", function(itemType)
		local values = {
			validValues = {},
		}

		for speciesId, species in pairs(Species:GetCache()) do
			values.validValues[speciesId] = species:GetName()
		end

		return values
	end, nil, 3, egmt("shared.species"))
end
--gamemodes/egmrp/gamemode/modules/inventory/item_classes/armor/cl_init.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--        Client | Armor Item        --
---------------------------------------

local ITEM_CLASS = ITEM_CLASS

-- Display name for the type used in UI elements.
ITEM_CLASS.Name = egmt("inventory.item_class_armor")

-- List of properties that should be shown in the manager, if this item class is used.
ITEM_CLASS.PropertyList = {"models", "armorBonus", "speedBonus", "consealedWeapon", "backpackSlots", "species"}

-- Create the item panel for the item.
--
-- @param Panel parent
-- @param Table itemData
function ITEM_CLASS:CreateItemPanel(parent, itemData)
	ITEM_CLASS.Base.CreateItemPanel(self, parent, itemData)
	function parent:Paint(ww, hh)
	end

	local modelIcon = vgui.Create("EGMModelIcon", parent)
	modelIcon:Dock(FILL)
	modelIcon:SetMouseInputEnabled(false)

	modelIcon:SetModel(itemData.Model, itemData.SkinId)
	modelIcon:SetDisplayType("Body")

	modelIcon:SetSize(math.floor(ScrW() * 0.1), math.floor(ScrW() * 0.1))
	modelIcon:GenerateIcon()

	parent.ModelIcon = modelIcon
end

-- Callback run, when the item is equipped.
--
-- @param Player ply
-- @param Character char
-- @param ItemType itemType
-- @param Table itemData
function ITEM_CLASS:OnEquip(ply, char, itemType, itemData)
	-- print("\n Armor:OnEquip", ply, char, itemType, itemData)

	char.CurrentArmorItem = itemData
end

-- Callback run, when the item is unequipped.
-- Clientside this includes the item being dropped.
--
-- @param Player ply
-- @param Character char
-- @param ItemType itemType
-- @param Table itemData
function ITEM_CLASS:OnUnequip(ply, char, itemType, itemData)
	-- print("\n Armor:OnUnequip", ply, char, itemType, itemData)

	char.CurrentArmorItem = nil
end



---------------------------------------
--              Tooltip              --
---------------------------------------

-- Callback run, when the item is showing in the inventory tooltip.
--
-- @param ItemType itemType
-- @param Table itemData
-- @param Table lines
function ITEM_CLASS:AddDescriptionLines(itemType, itemData, lines)
	table.insert(lines, {
		Text = itemType:GetName(),
		Color = UI.ForegroundColor2,
		Align = TEXT_ALIGN_LEFT
	})

	local model = itemData.Model
	local skinCount = GetModelSkinCount(model)
	if skinCount > 1 then
		local skinId = itemData.SkinId or 0

		if isnumber(skinId) then
			table.insert(lines, {
				Text = egmt("inventory.armour_variant", skinId + 1, skinCount),
				Color = UI.ForegroundColor2,
				Align = TEXT_ALIGN_LEFT
			})
		end
	end

	-- If the armor is equipped, do not show the armor bonus.
	-- This is done, since the armor value is only calculated, when the armor is unequipped.
	local slotId = itemData.SlotId
	if not isstring(slotId) or not Inventory:IsEquipmentSlot(slotId) then
		local itemArmorBonus = itemType:GetArmorBonus()
		local armor = itemData.Armor or itemArmorBonus
		local percent = math.Round(armor / itemArmorBonus * 100)

		local color = UI.ForegroundColor2
		if percent < 25 then
			color = UI.DangerColor
		end

		table.insert(lines, {})
		table.insert(lines, {
			Text = egmt("inventory.armour_integrity", armor, percent),
			Color = color,
			Align = TEXT_ALIGN_LEFT
		})
	end

	local itemBodygroups = itemData.Bodygroups or {}
	if table.Count(itemBodygroups) > 0 then
		table.insert(lines, {})

		local ent = ClientsideModel(model)
		local bodygroups = ent:GetBodyGroups()
		ent:Remove()

		for id, data in pairs(bodygroups) do
			local value = itemBodygroups[id - 1] or 0
			if value == 0 then continue end

			table.insert(lines, {
				Text = "- " .. data.name,
				Color = UI.TextColor,
				Align = TEXT_ALIGN_LEFT
			})
		end
	end
end



---------------------------------------
--               Hooks               --
---------------------------------------

-- Skip armor models in the character creation.
hook.Add("Character.CreationSkipModel", "Inventory.SkipArmor", function(model, faction, rank, relevantEquipment)
	if ItemType:FindByModel(model) then
		return true
	end
end)

-- Remove all models from the changing room, if an armor is equipped.
hook.Add("BodyGroups.RemoveValidModels", "Inventory.RemoveItems", function(char, validModels)
	local currentArmor = Inventory:GetCurrentArmor(char)
	if not currentArmor then return end

	-- Remove all models, that are not the current armor model.
	local toBeRemoved = {}
	for _, model in pairs(validModels) do
		if model == currentArmor.Model then continue end

		table.insert(toBeRemoved, model)
	end

	for _, model in pairs(toBeRemoved) do
		table.RemoveByValue(validModels, model)
	end
end)

-- Remove all skins from the changing room, if an armor is equipped.
hook.Add("BodyGroups.RemoveValidSkins", "Inventory.RemoveItems", function(char, model, validSkins)
	local currentArmor = Inventory:GetCurrentArmor(char)
	if not currentArmor then return end

	-- Remove all skins, that are not the current armor skin.
	local toBeRemoved = {}
	for _, skinId in pairs(validSkins) do
		if model == currentArmor.Model and skinId == currentArmor.SkinId then continue end

		table.insert(toBeRemoved, skinId)
	end

	for _, skinId in pairs(toBeRemoved) do
		table.RemoveByValue(validSkins, skinId)
	end
end)

-- Override the bodygroups, if an armor is equipped.
hook.Add("BodyGroups.OverrideBodygroups", "Inventory.ArmorOverride", function(char, bodygroups)
	local currentArmor = Inventory:GetCurrentArmor(char)
	if not currentArmor then return end

	return currentArmor.Bodygroups
end)

-- Update Head model, if the inventory is changed.
hook.Add("Species.ShouldHeadModelUpdate", "Inventory.UpdateOnInventory", function(char, key, value, oldValue)
	if key ~= "inventory" then return end

	return true
end)

-- Network armor bodygroups to the server and reset the bodygroups table to the character bodygroups.
hook.Add("BodyGroups.Save", "Inventory.FilterBodygroups", function(char, model, skinId, bodygroups)
	local currentArmor = Inventory:GetCurrentArmor(char)
	if not currentArmor then return end

	local armorBodygroups = {}

	-- Move all normal bodygroups to the armor bodygroup.
	for id, value in pairs(bodygroups) do
		if not isnumber(id) then continue end

		bodygroups[id] = nil
		if value == 0 then continue end

		armorBodygroups[id] = value
	end

	-- Add the non-armor bodygroups back into the bodygroups table.
	local currentBodygroups = char:GetBodyGroups()
	for id, value in pairs(currentBodygroups) do
		if not isnumber(id) then continue end

		bodygroups[id] = value
	end

	if table.Count(armorBodygroups) == 0 then return end

	-- Network the armor bodygroups to the server.
	net.Start("Inventory.SetArmorBodygroups")
		net.WriteTable(armorBodygroups)
	net.SendToServer()

	char.SkipSaveBodygroups = true
end)
--gamemodes/egmrp/gamemode/modules/inventory/item_slots/body/cl_init.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--      Client | Back Item Slot      --
---------------------------------------

local ITEM_SLOT = ITEM_SLOT

-- Name of the item slot displayed in the inventory.
ITEM_SLOT.Name = egmt("inventory.body_slot")

-- Number of rows, the items should be displayed in.
ITEM_SLOT.Rows = 1
--gamemodes/egmrp/gamemode/modules/inventory/item_slots/weapon_big/cl_init.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--     Client | Pistol Item Slot     --
---------------------------------------

local ITEM_SLOT = ITEM_SLOT

-- Name of the item slot displayed in the inventory.
ITEM_SLOT.Name = egmt("inventory.weapon_big_slot")

-- Number of rows, the items should be displayed in.
ITEM_SLOT.Rows = 1
--gamemodes/egmrp/gamemode/modules/inventory/item_slots/weapon_small/shared.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--     Shared | Pistol Item Slot     --
---------------------------------------

local ITEM_SLOT = ITEM_SLOT

-- Base Item slot, from which functions and such should be inherited.
ITEM_SLOT.BaseItemSlot = "base"

-- Number of items that can be stored in this slot.
ITEM_SLOT.Count = 1

-- Are items equipped as useable items?
ITEM_SLOT.Equipment = true
--gamemodes/egmrp/gamemode/modules/inventory/item_slots/weapon_small/cl_init.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--     Client | Pistol Item Slot     --
---------------------------------------

local ITEM_SLOT = ITEM_SLOT

-- Name of the item slot displayed in the inventory.
ITEM_SLOT.Name = egmt("inventory.weapon_small_slot")

-- Number of rows, the items should be displayed in.
ITEM_SLOT.Rows = 1
--gamemodes/egmrp/gamemode/modules/comlink/cl_comchannel.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--        Client | ComChannel        --
---------------------------------------

-- Clear property list to avoid duplicate entries.
ComChannel.PropertyList = {}

ComChannel:AddPropertyToList("name", egmt("comChannel.name"), egmt("comChannel.name_description"), "string", nil, nil, 1, nil)

ComChannel:AddPropertyToList("factions", egmt("comChannel.factions"), egmt("comChannel.faction_description"), "list", function(comChannel)
	local values = {}
	local factions = Faction:GetCache()

	for k, v in pairs(factions) do
		table.insert(values, { text = v:GetName(), data = v:GetId() })
	end

	return values
end, nil, 2, nil)

ComChannel:AddPropertyToList("announcement", egmt("comChannel.announcement"), egmt("comChannel.announcement_description"), "boolean", nil, nil, 1, egmt("comChannel.announcement"))

-- Register item type package type.
Loading:RegisterPackageType("comChannel", egmt("comChannel.package"), function(packageData)
	for k, iData in pairs(packageData) do
		ComChannel:Load(iData.data, iData.properties):Cache()
	end
end)



---------------------------------------
--        Filtered Properties        --
---------------------------------------

-- List of properties that should always be shown.
ComChannel.AlwaysShowProperties = { "name", "announcement", "factions" }

ComChannel:AddPropertyToList("receiveFactions", egmt("comChannel.receiveFactions"), egmt("comChannel.faction_receive_description"), "list", function(comChannel)
	local values = {}
	local factions = Faction:GetCache()

	for k, v in pairs(factions) do
		table.insert(values, { text = v:GetName(), data = v:GetId() })
	end

	return values
end, nil, 2, egmt("comChannel.announcement"))

-- Filter the property list dynamically, to only show properties that should be shown.
hook.Add("ComChannel.GetPropertyList", "Comlink.LimitProperties", function(propertyList, comChannel)
	local itemName = comChannel:GetName()
	if not itemName then return end

	for _, categoryData in pairs(propertyList) do
		local toBeDeleted = {}
		for _, property in pairs(categoryData) do
			local key = property.key

			-- Skip properties that should always be shown.
			if table.HasValue(ComChannel.AlwaysShowProperties, key) then continue end

			-- Hook for adding properties that should be shown.
			if hook.Run("ComChannel.ShouldShowProperty", comChannel, key, comChannel:IsAnnouncement() ) then continue end

			table.insert(toBeDeleted, property)
		end

		for _, property in pairs(toBeDeleted) do
			table.RemoveByValue(categoryData, property)
		end
	end

	local toBeDeleted = {}
	for _, categoryData in pairs(propertyList) do
		if #categoryData == 0 then
			table.insert(toBeDeleted, categoryData)
		end
	end

	for _, categoryData in pairs(toBeDeleted) do
		table.RemoveByValue(propertyList, categoryData)
	end
end)

-- Show the receiveFactions property only if the announcement property is set to true.
hook.Add("ComChannel.ShouldShowProperty", "Comlink.ShowReceiveFactions", function(comChannel, key, isAnnouncement)
	if key == "receiveFactions" then
		return isAnnouncement
	end
end)
--gamemodes/egmrp/gamemode/modules/comlink/styles/default/vgui/egmvoicepanel.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2024          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--            EGMVoicePanel          --
---------------------------------------

ELEMENT.Name = "EGMVoicePanel"
ELEMENT.Base = "DPanel"

function ELEMENT:Init()
	self.PlayerName = vgui.Create( "DLabel", self )
	self.PlayerName:SetFont( "EGMText7" )
	self.PlayerName:Dock( TOP )
	self.PlayerName:DockMargin( 8, 3, 0, 3 )
	self.PlayerName:SetTextColor(UI.TextColor)

	self.ChannelName = vgui.Create( "DLabel", self )
	self.ChannelName:SetFont( "EGMText6" )
	self.ChannelName:Dock( TOP )
	self.ChannelName:DockMargin( 8, 0, 0, 0 )
	self.ChannelName:SetTextColor(UI.TextColor)

	self.Character = vgui.Create("EGMModelPanel", self)
	self.Character:Dock( LEFT )
	self.Character:SetSize(50, 50)
	self.Character:SetZPos(-1)

	self.Color = UI.BackgroundColor
	self:SetBackgroundColor(UI.BackgroundColor)
	self:SetPaintBackground(true)

	self:SetSize( 400, 50 + 8 )
	self:DockPadding( 4, 4, 4, 4 )
	self:DockMargin( 2, 2, 2, 2 )
	self:Dock( TOP )
end

function ELEMENT:Setup(ply)
	self.Channel = ply:GetNWString("ActiveComlinkChannel", "")

	if Comlink.Channels[self.Channel] then
		self.ChannelName:SetText(Comlink.Channels[self.Channel].Name)
	end

	self.PlayerName:SetText(ply:Nick())

	local playerChar = ply:GetCurrentCharacter()
	if playerChar then
		self.Character:SetCharacter(playerChar)
	end

	self.Color = team.GetColor(ply:Team())

	self:InvalidateLayout()
end
--gamemodes/egmrp/gamemode/modules/bonemerge/sh_index.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--         Index | BoneMerge         --
---------------------------------------

BoneMerge = BoneMerge or {}

if SERVER then
	AddCSLuaFile("cl_bonemerge.lua")

	AddCSLuaFile("cl_modelpanel.lua")
	AddCSLuaFile("cl_corpse.lua")
end

if CLIENT then
	include("cl_bonemerge.lua")

	include("cl_modelpanel.lua")
	include("cl_corpse.lua")
end
--gamemodes/starwarsrp/gamemode/modules/inventory_bonemerge/cl_inventory_bonemerge.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--    Client | Inventory BoneMerge   --
---------------------------------------

-- Get all available bone merge models.
--
-- @return Table validModels
function InventoryBoneMerge:GetBoneMergeModels()
	local validModels = {}

	for model, baseModelData in pairs(InventoryBoneMerge.BaseModels) do
		validModels[baseModelData.Name] = model
	end

	return validModels
end

Faction:AddPropertyToList("bmModels", "Bone Merge Models", "Models, die als Item an den Spieler angehängt werden.", "models", function(faction)
	local inheritedModels = {}
	local parent = faction:GetParent()
	if parent then
		inheritedModels = parent:GetBoneMergeModels()
	end

	return {
		validModels = InventoryBoneMerge:GetBoneMergeModels(),
		inheritedModels = inheritedModels,
	}
end, nil, 4, egmt("equipment.category"))

Rank:AddPropertyToList("bmModels", "Bone Merge Models", "Models, die als Item an den Spieler angehängt werden.", "models", function(faction, rank)
	return {
		validModels = InventoryBoneMerge:GetBoneMergeModels(),
		inheritedModels = faction:GetBoneMergeModels(),
	}
end, nil, 4, egmt("equipment.category"))

Equipment:AddPropertyToList("bmModels", "Bone Merge Models", "Models, die als Item an den Spieler angehängt werden.", "models", function(faction, equipment)
	return {
		validModels = InventoryBoneMerge:GetBoneMergeModels(),
		inheritedModels = {},
	}
end, nil, 4, egmt("equipment.category"))

ItemType:AddPropertyToList("requiredArmor", "Required Armor", "The armor required to use this item.", "table", function(itemType)
	local values = {
		validValues = {},
	}

	for _, otherItemTye in pairs(ItemType:GetCache()) do
		local itemClass = otherItemTye:GetItemClass()
		if not itemClass then continue end

		if not itemClass.IsArmor then continue end

		values.validValues[otherItemTye:GetId()] = otherItemTye:GetName()
	end

	return values
end, nil, 10, egmt("inventory.title"))

-- Add bone merged models to the material sets selection in the manager.
hook.Add("BaseModel.AddMaterialSetModels", "InventoryBoneMerge.AddBonemergeModels", function(models, faction, rank, equipment)
	if faction then
		MergeTableByValue(models, faction:GetBoneMergeModels())
	end

	if rank then
		MergeTableByValue(models, rank:GetBoneMergeModels())
	end

	if equipment then
		MergeTableByValue(models, equipment:GetBoneMergeModels())
	end
end)



---------------------------------------
--           Base Functions          --
---------------------------------------

InventoryBoneMerge.Types = {}

-- Register a new Character model type.
--
-- @param String type
-- @param Function getModel
-- @param Function applyModel
function InventoryBoneMerge:RegisterCharacterModel(type, getModel, applyModel)
	BoneMerge:RegisterCharacterModel(type, getModel, applyModel)

	table.insert(InventoryBoneMerge.Types, type)
end



---------------------------------------
--               Hooks               --
---------------------------------------

-- Update all registered BoneMerge Types, when the inventory of a character changes.
hook.Add("Character.PropertyChanged", "InventoryBoneMerge.UpdateOnModelChanged", function(char, key, value, oldValue)
	if key ~= "inventory" then return end

	-- Update all registered BoneMerge Types.
	for _, type in pairs(InventoryBoneMerge.Types) do
		BoneMerge:UpdateCharacterModel(char, type)
	end
end)

-- Override the model name for the bone merged base models.
hook.Add("BaseModel.OverrideModelName", "InventoryBoneMerge.OverrideModelName", function(model, modelName)
	local baseModelData = InventoryBoneMerge.BaseModels[model]
	if not istable(baseModelData) then return end

	return baseModelData.Name
end)

-- Add bone merged base models to the bodygroup selection.
hook.Add("BaseModel.AddBodygroupModels", "InventoryBoneMerge.AddBodygroupModels", function(models, faction, rank, equipment)
	if faction then
		MergeTableByValue(models, faction:GetBoneMergeModels())
	end

	if rank then
		MergeTableByValue(models, rank:GetBoneMergeModels())
	end

	if equipment then
		MergeTableByValue(models, equipment:GetBoneMergeModels())
	end
end)

-- Filter Item Types shown in the manager.
hook.Add("ItemType.RemoveModels", "InventoryBoneMerge.FilterModels", function(itemType, validModels)
	local itemClass = itemType:GetItemClass()
	if not itemClass then return end

	-- Skip all items that are not bone merged.
	if not itemClass.IsBoneMerged then return end

	table.Empty(validModels)
	for model, baseModelData in pairs(InventoryBoneMerge.BaseModels) do
		local skipModel = hook.Run("InventoryBoneMerge.FilterModel", itemType, model, baseModelData)
		if skipModel then continue end

		validModels[baseModelData.Name] = model
	end

	-- Force return
	return true
end)

-- Override the display type for the bone merged base models in the manager.
hook.Add("EGMPropertyTypeModel.GetDisplayType", "InventoryBoneMerge.OverrideDisplayType", function(model, skinId)
	local baseModelData = InventoryBoneMerge.BaseModels[model]
	if not istable(baseModelData) then return end

	local successFind, itemType = ItemType:FindByModel(model, skinId)
	if not successFind then return end

	local itemClass = itemType:GetItemClass()
	if not itemClass then return end

	-- Skip all items that are not bone merged.
	if not itemClass.IsBoneMerged then return end

	return baseModelData.Type
end)

local reloading = false

-- Add bone merged entities to the body group selection.
hook.Add("BodyGroups.AddBodyGroups", "InventoryBoneMerge.AddBodyGroups", function(bodyGroupSelection, char, ent)
	local entTable = BoneMerge.Models[ent]
	if not istable(entTable) then return end

	-- Reset the body groups, when the model changed.
	if not reloading then
		InventoryBoneMerge.BodyGroups = {}

		for _, type in pairs(InventoryBoneMerge.Types) do
			local typeEnt = entTable[type]
			if not IsValid(typeEnt) then continue end

			InventoryBoneMerge.BodyGroups[type] = {}

			for id, bodyGroup in SortedPairs(typeEnt:GetBodyGroups()) do
				if bodyGroup.num <= 1 then continue end

				InventoryBoneMerge.BodyGroups[type][id - 1] = typeEnt:GetBodygroup(id - 1)
			end
		end
	end

	for _, type in pairs(InventoryBoneMerge.Types) do
		local typeEnt = entTable[type]
		if not IsValid(typeEnt) then continue end

		local currentItem = InventoryBoneMerge:GetCurrentItem(type, char)
		if not currentItem then continue end

		local validBodygroups = currentItem.ValidBodygroups
		if not istable(validBodygroups) then continue end

		for id, bodyGroup in SortedPairs(typeEnt:GetBodyGroups()) do
			if bodyGroup.num <= 1 then continue end
			if not table.HasValue(validBodygroups, bodyGroup.id) then continue end

			bodyGroupSelection:AddBodyGroup(type .. "_" .. id - 1, bodyGroup.name, bodyGroup.num)
		end
	end
end)

-- Override the body group menu for bone merged entities.
hook.Add("BodyGroups.OverrideBodyGroup", "InventoryBoneMerge.Override", function(button, ent, id, name, i)
	local entTable = BoneMerge.Models[ent]
	if not istable(entTable) then return end

	local split = string.Split(id, "_")
	if #split ~= 2 then return end

	local type = split[1]
	local bodyGroupId = tonumber(split[2])

	local typeEnt = entTable[type]
	if not IsValid(typeEnt) then return end

	local bodyGroup = InventoryBoneMerge.BodyGroups[type]
	if not istable(bodyGroup) then return end

	local value = bodyGroup[bodyGroupId]
	local selected = (value == i - 1)

	local color = GetColor("lightgray")
	if selected then
		color = UI.ForegroundColor2
	end

	local incompatibleSuccess = BodyGroups:ApplyIncompatibility(typeEnt, bodyGroup, bodyGroupId, name)
	if incompatibleSuccess and selected then
		color = GetColor("red")
	end

	local dependencySuccess = BodyGroups:ApplyDependency(typeEnt, bodyGroup, bodyGroupId, name)
	if dependencySuccess and selected then
		color = UI.ForegroundColor
	end

	button:SetButtonColor(color)

	function button:DoClick()
		surface.PlaySound(UI.ButtonSound)

		bodyGroup[bodyGroupId] = i - 1

		BodyGroups:ApplyInternal(typeEnt, bodyGroup)

		reloading = true
		BodyGroups.BodyGroupSelection:Reload()
		reloading = false
	end

	return true
end)

-- Send the selected body groups to the server.
hook.Add("BodyGroups.Save", "InventoryBoneMerge.Save", function(char, model, skinId, _)
	local ent = BodyGroups.ModelPreview.Entity
	if not IsValid(ent) then return end

	local entTable = BoneMerge.Models[ent]
	if not istable(entTable) then return end

	local bodyGroups = InventoryBoneMerge.BodyGroups
	if not istable(bodyGroups) then return end

	local bodyGroupsSend = {}
	for type, bodyGroup in pairs(bodyGroups) do
		local typeEnt = entTable[type]
		if not IsValid(typeEnt) then continue end

		bodyGroupsSend[type] = {}

		for id, value in pairs(bodyGroup) do
			if value == 0 then continue end

			bodyGroupsSend[type][id] = value
		end
	end

	if table.Count(bodyGroupsSend) == 0 then return end

	net.Start("InventoryBoneMerge.SaveBodygroups")
		net.WriteTable(bodyGroupsSend)
	net.SendToServer()
end)
--gamemodes/egmrp/gamemode/modules/thirdperson/sh_index.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--       Third Person System         --
---------------------------------------

ThirdPerson = ThirdPerson or {}

if SERVER then
    AddCSLuaFile("cl_config.lua")
    AddCSLuaFile("cl_thirdperson.lua")
    AddCSLuaFile("cl_keybinds.lua")
end

if CLIENT then
    include("cl_config.lua")
    include("cl_thirdperson.lua")
    include("cl_keybinds.lua")
end
--gamemodes/egmrp/gamemode/modules/thirdperson/cl_thirdperson.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--       Third Person System         --
---------------------------------------

-- Cookie for the thirdperson status, so that it saves after disconnect.
cookie.Set("EGMRP.ThirdPerson.Enabled", cookie.GetString("EGMRP.ThirdPerson.Enabled") or "false")

ThirdPerson.Enabled = tobool(cookie.GetString("EGMRP.ThirdPerson.Enabled")) -- Read cooky for current enabled status.
ThirdPerson.NextThink = ThirdPerson.NextThink or 0

-- Toggles between Ego-Perspective and Third-Person
function ThirdPerson:Toggle()
	self.Enabled = not self.Enabled
	cookie.Set("EGMRP.ThirdPerson.Enabled", tostring(self.Enabled))
end

function ThirdPerson:IsActive()
	-- Check if the thirdperson is enabled.
	if not ThirdPerson.Enabled then
		return false
	end

	-- Check if the player is in a vehicle
	if LocalPlayer():InVehicle() then
		return false
	end

	-- Check if the player is in observer mode.
	if LocalPlayer():GetObserverMode() ~= OBS_MODE_NONE then
		return false
	end

	if hook.Run("ThirdPerson.CanThirdPerson", LocalPlayer()) == false then
		return false
	end

	return true
end

hook.Add("Think", "ThirdPerson", function()
	local ply = LocalPlayer()

	local curTime = CurTime()
	if ThirdPerson.NextThink < curTime then
		ThirdPerson.Filter = {}
		for _, otherPly in pairs(player.GetHumans()) do
			if otherPly == ply or otherPly:GetNWBool("Administrate", false) then -- TODO: This should not be needed anymore.
				table.insert(ThirdPerson.Filter, otherPly)
			end
		end

		ThirdPerson.NextThink = curTime + 1
	end
end)

-- Calculate the view in thirdperson. Draw the camera behind the player.
hook.Add("CalcView", "ThirdPerson", function(ply, pos, angle)
	if ThirdPerson:IsActive() then
		local view = {}
		view.drawviewer = true

		-- We start a trace from the players eyePos to the third person camera position (behind the player).
		local traceData = {}
		traceData.start = ply:EyePos()
		traceData.endpos = traceData.start + angle:Forward() * -ThirdPerson.Distance
		traceData.filter = ThirdPerson.Filter

		local trace = util.TraceLine(traceData)

		-- The position of the camera will be the point where the trace hit an object or completely behind a player.
		pos = trace.HitPos

		-- If we hit something, then we manipulate the position, so that the player can't look through an object.
		if trace.Fraction < 1 then
			pos = pos + trace.HitNormal * 5
		end

		view.origin = pos

		-- Save the Position for use in other code.
		ply.ThirdPersonOrigin = pos

		return view
	end
end)

-- Used to get the Tauntcam, wich controls camera, movement, and more of when you are using an "act" command.
local PLAYER = baseclass.Get("player_sandbox")

-- Old camera functionality (used for thirdperson)
if not ThirdPerson.OldTauntCalcView then
	ThirdPerson.OldTauntCalcView = PLAYER.TauntCam.CalcView
end

-- Disables thirdperson camera when taunting when you are not actually in thirdperson.
PLAYER.TauntCam.CalcView = function(self, view, ply, on)
	if ThirdPerson:IsActive() then
		return ThirdPerson.OldTauntCalcView(self, view, ply, on)
	end

	return false
end

-- Disables the freezing when taunting. Allows you to move when taunting.
PLAYER.TauntCam.CreateMove = function(self, cmd, ply, on)
	return false
end

-- Disables rendering the player when taunting when you are in first person. would be awesome to render everything except the head. This way you could see the hand but i doubt this would work properly.
PLAYER.TauntCam.ShouldDrawLocalPlayer = function(self, ply, on)
	if hook.Run("ThirdPerson.CanThirdPerson", ply) == false then return false end

	return ThirdPerson:IsActive()
end
--gamemodes/egmrp/gamemode/modules/extrarank/sh_index.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--         Index | Extra Rank        --
---------------------------------------

ExtraRank = ExtraRank or {}

if SERVER then
	AddCSLuaFile("sh_extra_rank.lua")
	AddCSLuaFile("cl_extra_rank.lua")

	AddCSLuaFile("cl_scoreboard.lua")

	include("sh_extra_rank.lua")
	include("sv_extra_rank.lua")

	include("sv_chats.lua")
end

if CLIENT then
	include("sh_extra_rank.lua")
	include("cl_extra_rank.lua")

	include("cl_scoreboard.lua")
end
--gamemodes/starwarsrp/gamemode/modules/cwutils/sh_keycards.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--    on official 'Einfach Gaming'   --
--     servers owned by 'P4sca1'     --
--                                   --
-- Copyright © 2020 Pascal Sthamer,  --
--      Konstantin Zisiadis und      --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--      Shared | Keycard Access      --
---------------------------------------

Faction:AddProperty("keycardaccess", "table", {}, function(faction, value)
	if not istable(value) then
		return false, egmt("shared.invalid_type")
	end

	return true
end,
function(faction, ply)
	return true
end)

-- Get the keycard access for a faction.
--
-- @return table keycardAccess
function Faction.Meta:GetKeycardAccess()
	local keycardAccess = self:GetProperty("keycardaccess", {})

	local parentFaction = self:GetParent()
	if parentFaction then
		MergeTableByValue(keycardAccess, parentFaction:GetKeycardAccess())
	end

	return keycardAccess
end

Rank:AddProperty("keycardaccess", "table", {}, function(rank, value)
	if not istable(value) then
		return false, egmt("shared.invalid_type")
	end

	return true
end,
function(rank, ply)
	return true
end)

Equipment:AddProperty("keycardaccess", "table", {}, function(equipment, value)
	if not istable(value) then
		return false, egmt("shared.invalid_type")
	end

	return true
end,
function(equipment, ply)
	return true
end)

-- Add material sets to the effect list.
hook.Add("Equipment.GetEffectList", "Keycards.EquipmentEffect", function(equip, effectList)
	local keycardAccess = equip:GetProperty("keycardaccess", {})
	if istable(keycardAccess) and table.Count(keycardAccess) > 0 then
		table.insert(effectList, "KEY")
	end
end)

if CLIENT then
	Faction:AddPropertyToList("keycardaccess", "Keycard Groups", "Groups, that this Faction has Access to", "table", function()
		local levels = {
			validValues = {},
		}

		if bKeypads then
			for _, levelData in pairs(bKeypads.Keycards.Levels) do
				if levelData.Ignore then continue end

				levels.validValues[levelData.Name] = levelData.Name
			end
		end

		return levels
	end, nil, 1, "Keycard Access")

	Rank:AddPropertyToList("keycardaccess", "Keycard Groups", "Groups, that this Rank has Access to", "table", function()
		local levels = {
			validValues = {},
		}

		if bKeypads then
			for _, levelData in pairs(bKeypads.Keycards.Levels) do
				if levelData.Ignore then continue end

				levels.validValues[levelData.Name] = levelData.Name
			end
		end

		return levels
	end, nil, 1, "Keycard Access")

	Equipment:AddPropertyToList("keycardaccess", "Keycard Groups", "Groups, that this Equipment has Access to", "table", function()
		local levels = {
			validValues = {},
		}

		if bKeypads then
			for _, levelData in pairs(bKeypads.Keycards.Levels) do
				if levelData.Ignore then continue end

				levels.validValues[levelData.Name] = levelData.Name
			end
		end

		return levels
	end, nil, 1, "Keycard Access")
end

local Player = FindMetaTable("Player")

function Player:HasKeycardAccess(type)
	local character = self:GetCurrentCharacter()
	if not character then
		return false
	end

	local faction = character:GetFaction()
	if faction then
		local keycardAccess = faction:GetKeycardAccess()
		if keycardAccess and table.HasValue(keycardAccess, type) then
			return true
		end
	end

	local extraFaction = character:GetExtraFaction()
	if extraFaction then
		local keycardAccess = extraFaction:GetKeycardAccess()
		if keycardAccess and table.HasValue(keycardAccess, type) then
			return true
		end
	end

	local rank = character:GetRank()
	if rank then
		local keycardAccess = rank:GetProperty("keycardaccess", {})
		if keycardAccess and table.HasValue(keycardAccess, type) then
			return true
		end
	end

	local extraRank = character:GetExtraRank()
	if extraRank then
		local keycardAccess = extraRank:GetProperty("keycardaccess", {})
		if keycardAccess and table.HasValue(keycardAccess, type) then
			return true
		end
	end

	local relevantEquipment = character:GetRelevantEquipment()
	for _, equip in pairs(relevantEquipment) do
		local keycardAccess = equip:GetProperty("keycardaccess", {})
		if keycardAccess and table.HasValue(keycardAccess, type) then
			return true
		end
	end

	return false
end
--gamemodes/egmrp/gamemode/modules/inventory_money/sh_index.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--       Index | InventoryMoney      --
---------------------------------------

if not RequireModules({"inventory", "inventory_private"}) then
	return false
end

InventoryMoney = InventoryMoney or {}

if SERVER then
	AddCSLuaFile("sh_config.lua")

	AddCSLuaFile("sh_money.lua")
	AddCSLuaFile("cl_money.lua")

	include("sh_config.lua")

	include("sh_money.lua")
	include("sv_money.lua")
	include("sv_net.lua")

	include("sv_chats.lua")
end

if CLIENT then
	include("sh_config.lua")

	include("sh_money.lua")
	include("cl_money.lua")
end
--gamemodes/egmrp/gamemode/modules/inventory_storage/sh_config.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--     Config | Inventory Storage    --
---------------------------------------
--  Variables should be overwritten  --
--     in the deriving gamemode!     --
---------------------------------------

-- Fallback model for the storage entity.
InventoryStorage.Model = "models/Items/ammocrate_smg1.mdl"

-- Default mode for the storage entity.
InventoryStorage.DefaultMode = "supply"
--gamemodes/egmrp/gamemode/modules/inventory_storage/item_slots/storage/cl_init.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--     Client | Storage Item Slot    --
---------------------------------------

local ITEM_SLOT = ITEM_SLOT

-- Name of the item slot displayed in the inventory.
ITEM_SLOT.Name = ""

-- Number of rows, the items should be displayed in.
ITEM_SLOT.Rows = true

-- Prevent Right Click Interaction on supply slots.
function ITEM_SLOT:OnRightClick(slot)
end
--gamemodes/egmrp/gamemode/modules/inventory_storage/item_slots/supply/cl_init.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--     Client | Supply Item Slot     --
---------------------------------------

local ITEM_SLOT = ITEM_SLOT

-- Name of the item slot displayed in the inventory.
ITEM_SLOT.Name = ""

-- Number of rows, the items should be displayed in.
ITEM_SLOT.Rows = true

-- Prevent Right Click Interaction on supply slots.
function ITEM_SLOT:OnRightClick(slot)
end
--gamemodes/egmrp/gamemode/modules/inventory_storage/item_slots/trash/shared.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--      Shared | Trash Item Slot     --
---------------------------------------

local ITEM_SLOT = ITEM_SLOT

-- Base Item slot, from which functions and such should be inherited.
ITEM_SLOT.BaseItemSlot = "base"

-- Number of items that can be stored in this slot.
ITEM_SLOT.Count = 1

-- Are items equipped as useable items?
ITEM_SLOT.Equipment = false
--gamemodes/egmrp/gamemode/modules/inventory_private/cl_inventory_private.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--     Client | Inventory Private    --
---------------------------------------

-- Add properties to the property list.
Rank:AddPropertyToList("hasPrivSto", egmt("inventory_private.rank_priv"), egmt("inventory_private.rank_priv_description"), "boolean", nil, nil, 2, egmt("inventory.title"))

Faction:AddPropertyToList("hasPrivSto", egmt("inventory_private.faction_priv"), egmt("inventory_private.faction_priv_description"), "boolean", nil, nil, 1, egmt("inventory.title"))

---------------------------------------
--        Private Storage Tab        --
---------------------------------------

-- Create the private storage panel.
function InventoryPrivate:CreatePrivateStorage(parent, char, ent)
	local privateStorage = InventoryStorage:CreateStoragePanel(parent, egmt("inventory_storage.type_private"))
	parent.PrivateStorage = privateStorage
end

-- Apply the private storage to the private storage panel.
--
-- @param Panel parent
-- @param Table privateStorageItemData
function InventoryPrivate:ApplyPrivateStorage(parent, privateStorageItemData)
	InventoryStorage:ApplyStoragePanel(parent.PrivateStorage, "storage", "private_storage", privateStorageItemData)
end

-- Register Storage Tab: Private Storage
-- This is the default private storage tab, storing the items, accessible for the character only.
InventoryStorage:RegisterStorageTab("private_storage", egmt("inventory_storage.type_private"),
function(parent, char, ent)
	InventoryPrivate:CreatePrivateStorage(parent, char, ent)

	hook.Run("InventoryPrivate.CreateStorage", parent, char, ent)
end,
function(char, ent)
	local slotLimit = char:GetPrivateStorageLimit()
	if slotLimit <= 0 then return false end

	return true
end, function(parent, char, ent)
	local privateStorageItemData = char:GetStorage()
	InventoryPrivate:ApplyPrivateStorage(parent, privateStorageItemData)
end)



---------------------------------------
--               Hooks               --
---------------------------------------

-- Update the invntory, if the property changes.
hook.Add("Character.PropertyChanged", "PrivateStorage.Update", function(char, key, value)
	if not IsValid(InventoryStorage.Frame) then return end

	if char:GetOwner() ~= LocalPlayer() then return end
	if not char:IsCurrentCharacter() then return end

	if key == "storage" then
		local storageTabs = InventoryStorage.StorageTabs
		if not istable(storageTabs) then return end

		local tabButton = storageTabs["private_storage"]
		if not IsValid(tabButton) then return end

		local content = tabButton.Content
		if not IsValid(content) then return end

		InventoryPrivate:ApplyPrivateStorage(content, value)
	end
end)

-- Override Drag and Drop functionallity to allow multiple items to be taken from the private storage.
hook.Add("Inventory.OnDragDrop", "PrivateStorage.MultiTakeFromStorage", function(itemClass, slot, dragSlot, itemType, itemData)
	if not itemClass.AlwaysStack then return end

	local dragSlotId, dragSubId, dragContext = dragSlot:GetId()
	local slotId, subId, context = slot:GetId()

	-- Only change behaviour when dragging from the private storage.
	if context ~= dragContext .. "_player" then return end
	if not string.EndsWith(dragContext, "_storage") then return end

	local modal = vgui.Create("EGMModal")
	modal:SetCustomTitle(egmt("inventory_private.take_multiple"))
	modal:Slider(egmt("inventory_private.take_multiple_long"), function(ammount)
		net.Start("InventoryPrivate.TakeMultiple")
			net.WriteString(dragSlotId)
			net.WriteUInt(dragSubId, 16)
			net.WriteString(dragContext)
			net.WriteString(slotId)
			net.WriteUInt(subId, 16)
			net.WriteUInt(ammount, 32)
		net.SendToServer()
	end, nil, 1, itemData.StackSize, 0)

	return true
end)
--gamemodes/egmrp/gamemode/modules/inventory_private/item_slots/storage/cl_init.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--     Client | Storage Item Slot    --
---------------------------------------

local ITEM_SLOT = ITEM_SLOT

-- Name of the item slot displayed in the inventory.
ITEM_SLOT.Name = ""

-- Number of rows, the items should be displayed in.
ITEM_SLOT.Rows = true

-- Prevent Right Click Interaction on supply slots.
function ITEM_SLOT:OnRightClick(slot)
end
--gamemodes/egmrp/gamemode/modules/instructor/cl_manager.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--         Instructor | Menu         --
---------------------------------------

-- Options for the instructor context menu.
local instructorOptions = {
	{
		name = egmt("instructor.promote"),
		func = function(ply, target)
			target:EditProperty("instructorMentor", true)

			local modal = vgui.Create("EGMModal")
			modal:SetCustomTitle(egmt("shared.please_wait"))
			modal:Notify(egmt("player.saving_process"), false)
			InstructorManager.PlayerDataEditModal = modal
			InstructorManager.PlayerDataEditModal.instructor = true
			InstructorManager.PlayerDataEditModal.instructorMentor = true
		end,
		shouldShow = function(target)
			return LocalPlayer():IsAtLeast(Instructor.MinAccessGroup)
				and target:GetProperty("instructor", false)
				and not target:GetProperty("instructorMentor", false)
		end,
		icon = "icon16/award_star_gold_2.png"
	},
	{
		name = egmt("instructor.demote"),
		func = function(ply, target)
			target:EditProperty("instructorMentor", false)

			local modal = vgui.Create("EGMModal")
			modal:SetCustomTitle(egmt("shared.please_wait"))
			modal:Notify(egmt("player.saving_process"), false)
			InstructorManager.PlayerDataEditModal = modal
			InstructorManager.PlayerDataEditModal.instructor = true
			InstructorManager.PlayerDataEditModal.instructorMentor = false
		end,
		shouldShow = function(target)
			return LocalPlayer():IsAtLeast(Instructor.MinAccessGroup)
				and target:GetProperty("instructorMentor", false)
		end,
		icon = "icon16/award_star_bronze_1.png",
	},
	{
		name = egmt("instructor.promote_low"),
		func = function(ply, target)
			target:EditProperty("instructor", true)

			local modal = vgui.Create("EGMModal")
			modal:SetCustomTitle(egmt("shared.please_wait"))
			modal:Notify(egmt("player.saving_process"), false)
			InstructorManager.PlayerDataEditModal = modal
			InstructorManager.PlayerDataEditModal.instructor = true
			InstructorManager.PlayerDataEditModal.instructorMentor = false
		end,
		shouldShow = function(target)
			return (LocalPlayer():IsAtLeast(Instructor.MinAccessGroup) or LocalPlayer():GetData():GetProperty("instructorMentor", false))
			and not target:GetProperty("instructor", false)
		end,
		icon = "icon16/award_star_gold_2.png",
	},
	{
		name = egmt("instructor.demote_low"),
		func = function(ply, target)
			target:EditProperties({instructorMentor = false, instructor = false})

			local modal = vgui.Create("EGMModal")
			modal:SetCustomTitle(egmt("shared.please_wait"))
			modal:Notify(egmt("player.saving_process"), false)
			InstructorManager.PlayerDataEditModal = modal
			InstructorManager.PlayerDataEditModal.instructor = false
			InstructorManager.PlayerDataEditModal.instructorMentor = false
		end,
		shouldShow = function(target)
			return (LocalPlayer():IsAtLeast(Instructor.MinAccessGroup) or LocalPlayer():GetData():GetProperty("instructorMentor", false))
				and target:GetProperty("instructor", false) and not target:GetProperty("instructorMentor", false)
		end,
		icon = "icon16/award_star_delete.png",
	},
}

-- Inform about successfull PlayerData edit.
hook.Add("PlayerData.EditPropertiesSuccess", "InstructorManager.CharacterEditPropertiesSuccess", function()
	if InstructorManager.PlayerDataEditModal then
		InstructorManager.PlayerDataEditModal:SetCustomTitle(egmt("shared.success"))
		InstructorManager.PlayerDataEditModal:SetBarColor(GetColor("green"))
		InstructorManager.PlayerDataEditModal:Notify(egmt("player.saved"), nil, nil, GetColor("lightgray"), function()
			-- Manually set the changed instructor status for offline players.
			-- This is not done automatically, because changes of offline data is not synced.
			local playerData = InstructorManager.InstructorList:GetLine(InstructorManager.InstructorList:GetSelectedLine()).instructor
			if playerData and not playerData:GetPlayer() then
				-- The new instructor status is saved in the modal.
				local instructor = InstructorManager.PlayerDataEditModal.instructor
				local instructorMentor = InstructorManager.PlayerDataEditModal.instructorMentor

				playerData:SetProperties({instructor = instructor, instructorMentor = instructorMentor}, true)

				-- Call this hook so that the menu gets refreshed.
				hook.Run("PlayerData.PropertyChanged", playerData)
			end

			InstructorManager.PlayerDataEditModal = nil
		end)
	end
end)

-- Inform about character PlayerData error.
hook.Add("PlayerData.EditPropertiesError", "InstructorManager.CharacterEditError", function()
	if InstructorManager.PlayerDataEditModal then
		InstructorManager.PlayerDataEditModal:SetCustomTitle(egmt("shared.error"))
		InstructorManager.PlayerDataEditModal:SetBarColor(GetColor("red"))
		InstructorManager.PlayerDataEditModal:Notify(egmt("player.saving_error"), nil, nil, GetColor("lightgray"), function()
			InstructorManager.PlayerDataEditModal = nil
		end)
	end
end)

-- Opens the instructor manager.
function InstructorManager:Open()
	self:Close()

	if not (LocalPlayer():IsAtLeast(Instructor.MinAccessGroup) or LocalPlayer():IsInstructorMentor()) then
		chat.AddText(
			Config.PrefixColor,
			"[" .. Config.Prefix .. "] ",
			GetColor("white"),
			egmt("instructor.manager_permission")
		)

		return
	end

	self.Frame = vgui.Create("EGMFrame")
	self.Frame:SetSubTitle(egmt("instructor.manager"))
	self.Frame:ShowCloseButton(false)
	self.Frame:SetBackground(InstructorManager.Background)
	function self.Frame:Paint(width, height)
		draw.RoundedBox(0, 0, 0, width, height, ColorAlpha(UI.BackgroundColor, 255))
	end
	function self.Frame:OnClose()
		-- Reset runtime variables on close.
		InstructorManager.LoadingInstructors = nil
		InstructorManager.LoadingLogs = nil
	end

	-- Instructor List.
	self.InstructorList = vgui.Create("EGMListView", self.Frame)
	self.InstructorList:SetPos(ScrW() * 0.1, ScrH() * 0.25)
	self.InstructorList:SetSize(ScrW() * 0.3, ScrH() * 0.7)
	self.InstructorList:SetHeaderHeight(ScrH() * 0.05)
	self.InstructorList:SetDataHeight(ScrH() * 0.03)
	self.InstructorList:SetMultiSelect(false)
	self.InstructorList:SetHeaderFont("EGMText10")
	self.InstructorList:SetDataFont("EGMText6")
	self.InstructorList:AddCustomColumn(egmt("instructor.name"))
	self.InstructorList:AddCustomColumn(egmt("instructor.status"))
	-- Invisible column for sorting.
	function self.InstructorList:OnRowRightClick(index, line)
		local instructor = line.instructor
		local contextMenu = DermaMenu(line)

		function contextMenu:Paint(width, height)
			draw.RoundedBox(0, 0, 0, width, height, GetColor("white"))
			surface.SetDrawColor(UI.ForegroundColor)
			self:DrawOutlinedRect()
		end

		for k, option in SortedPairs(instructorOptions) do
			if option.shouldShow(instructor) then
				local optionPanel = contextMenu:AddOption(option.name, function()
					option.func(LocalPlayer(), instructor)
				end)

				optionPanel:SetColor(GetColor("white"))
				optionPanel:SetFont("DermaDefaultBold")

				function optionPanel:Paint(width, height)
					if self:IsHovered() then
						draw.RoundedBox(0, 0, 0, width, height, GetColor("blue"))
					elseif k % 2 == 0 then
						draw.RoundedBox(0, 0, 0, width, height, GetColor("darkgray"))
					else
						draw.RoundedBox(0, 0, 0, width, height, GetColor("gray"))
					end
				end

				local icon = vgui.Create("DImage", optionPanel)
				icon:SetPos(optionPanel:GetWide() * 0.075, optionPanel:GetTall() * 0.05)
				icon:SetSize(16, 16)
				icon:SetImage(option.icon)
			end
		end

		contextMenu:Open()
	end

	self.InstructorListLoadingHint = vgui.Create("DLabel", self.InstructorList)
	self.InstructorListLoadingHint:Dock(FILL)
	self.InstructorListLoadingHint:SetText("")
	function self.InstructorListLoadingHint:Paint(width, height)
		if InstructorManager.LoadingInstructors then
			draw.SimpleText(egmt("shared.loading_content"), "EGMText12", width / 2, height / 2, UI.TextColor, TEXT_ALIGN_CENTER)
		elseif #InstructorManager.InstructorList:GetLines() == 0 then
			if InstructorManager.LoadOfflineInstructorsCheckBox:GetChecked() then
				draw.SimpleText(egmt("shared.no_results"), "EGMText12", width / 2, height / 2, UI.TextColor, TEXT_ALIGN_CENTER)
			else
				draw.SimpleText(egmt("instructor.none"), "EGMText12", width / 2, height / 2, UI.TextColor, TEXT_ALIGN_CENTER)
			end
		end
	end

	self.LoadOfflineInstructorsCheckBox = vgui.Create("EGMCheckBox", self.InstructorList)
	self.LoadOfflineInstructorsCheckBox:SetPos(ScrW() * 0.01, ScrH() * 0.0125)
	self.LoadOfflineInstructorsCheckBox:SetSize(ScrH() * 0.025, ScrH() * 0.025)
	self.LoadOfflineInstructorsCheckBox:SetZPos(100) -- Render in front of the list view.
	self.LoadOfflineInstructorsCheckBox:SetChecked(false)
	self.LoadOfflineInstructorsCheckBox:SetTooltip(egmt("instructor.load_offline"))
	function self.LoadOfflineInstructorsCheckBox:OnChange()
		InstructorManager:LoadInstructors()
	end
	function self.LoadOfflineInstructorsCheckBox:Think()
		if InstructorManager.LoadingInstructors then
			self:SetEnabled(false)
		else
			self:SetEnabled(true)
		end
	end

	self.InstructorFilter = vgui.Create("DTextEntry", self.InstructorList)
	self.InstructorFilter:SetHeight(ScrH() * 0.025)
	self.InstructorFilter:Dock(BOTTOM)
	self.InstructorFilter:SetPlaceholderText(egmt("shared.searching"))
	function self.InstructorFilter:OnValueChange(newFilter)
		InstructorManager:LoadInstructors()
	end

	-- Log panel.
	self.LogPanel = vgui.Create("DPanel", self.Frame)
	self.LogPanel:SetPos(ScrW() * 0.45, ScrH() * 0.25)
	self.LogPanel:SetSize(ScrW() * 0.5, ScrH() * 0.7)
	function self.LogPanel:Paint(width, height)
		draw.RoundedBox(0, 0, 0, width, height, ColorAlpha(UI.BackgroundColor, 255))
	end

	self.Log = vgui.Create("EGMListView", self.LogPanel)
	self.Log:Dock(FILL)
	self.Log:SetHeaderHeight(ScrH() * 0.05)
	self.Log:SetDataHeight(ScrH() * 0.03)
	self.Log:SetMultiSelect(false)
	self.Log:AddCustomColumn("Text")
	self.Log:AddCustomColumn(egmt("shared.time")):SetFixedWidth(ScrW() * 0.1)
	self.Log:SortByColumns(2, true, 1, false) -- Sort descending
	function self.Log:OnRowRightClick(index, line)
		SetClipboardText(line:GetValue(2) .. " | " .. line:GetValue(1))
		Notify:Info(egmt("eventlog.title"), egmt("instructor.copy"))
	end

	self.LogLoadingHint = vgui.Create("DLabel", self.Log)
	self.LogLoadingHint:Dock(FILL)
	self.LogLoadingHint:SetText("")
	function self.LogLoadingHint:Paint(width, height)
		if InstructorManager.LoadingLogs then
			draw.SimpleText(egmt("shared.loading_content"), "EGMText12", width / 2, height / 2, UI.TextColor, TEXT_ALIGN_CENTER)
		elseif #InstructorManager.Log:GetLines() == 0 then
			draw.SimpleText(egmt("shared.no_results"), "EGMText12", width / 2, height / 2, UI.TextColor, TEXT_ALIGN_CENTER)
		end
	end

	self.LogFilter = vgui.Create("DTextEntry", self.LogPanel)
	self.LogFilter:SetHeight(ScrH() * 0.025)
	self.LogFilter:Dock(BOTTOM)
	self.LogFilter:SetPlaceholderText(egmt("shared.searching"))
	function self.LogFilter:OnValueChange(newFilter)
		-- Reset pages when selecting a new filter.
		InstructorManager.LogPageSelection:SetPage(1)
		InstructorManager.LogPageSelection:SetPageCount(1)

		InstructorManager:LoadLogs()
	end
	function self.LogFilter:Think()
		if InstructorManager.LoadingLogs then
			self:SetEnabled(false)
		else
			self:SetEnabled(true)
		end
	end

	self.LogPageSelection = vgui.Create("EGMPageSelector", self.LogPanel)
	self.LogPageSelection:SetHeight(ScrH() * 0.025)
	self.LogPageSelection:Dock(BOTTOM)
	self.LogPageSelection:SetPage(1)
	self.LogPageSelection:SetPageCount(1)
	self.LogPageSelection:SetCallback(function(newPage)
		InstructorManager:LoadLogs()
	end)
	function self.LogPageSelection:Think()
		if InstructorManager.LoadingLogs then
			self:SetEnabled(false)
		else
			self:SetEnabled(true)
		end
	end

	self:LoadInstructors()
	self:LoadLogs()
	self.Frame:MakePopup()
end

-- Loads the instructors based on filter and loadOffline value.
-- Called when the load offline or filter got changed.
function InstructorManager:LoadInstructors()
	self.InstructorList:Clear()

	local loadOffline = self.LoadOfflineInstructorsCheckBox:GetChecked()
	local filter = self.InstructorFilter:GetValue()

	if not loadOffline then
		for k, playerData in pairs(PlayerData:GetCache()) do
			if string.find(playerData:GetName(), filter) then
				local status = egmt("shared.normal")
				local sort = 0

				if playerData:GetProperty("instructorMentor", false) then
					status = egmt("instructor.mentor_name")
					sort = 2
				elseif playerData:GetProperty("instructor", false) then
					status = egmt("instructor.name")
					sort = 1
				end

				local line = self.InstructorList:AddSortedLine(playerData:GetName(), nil, status, sort)
				line.instructor = playerData
			end
		end

		-- Sort instructors by their status.
		self.InstructorList:SortByColumns(2, true)
	else
		self.LoadingInstructors = true

		net.Start("InstructorManager.OfflineInstructors")
			net.WriteString(filter)
		net.SendToServer()
	end
end

-- Net Receiver for offline instructors.
net.Receive("InstructorManager.OfflineInstructors", function()
	InstructorManager.LoadingInstructors = false

	local len = net.ReadInt(32)
	local instructors = DecompressTable(net.ReadData(len))

	for k, data in pairs(instructors) do
		local instructor = PlayerData:Load(data.data, data.properties)
		local isMentor = instructor:GetProperty("instructorMentor", false)
		local line = InstructorManager.InstructorList:AddSortedLine(instructor:GetName(), nil, isMentor and egmt("instructor.mentor_name") or egmt("instructor.name"), isMentor and 2 or 1)
		line.instructor = instructor
	end

	-- Sort instructors by their status.
	InstructorManager.InstructorList:SortByColumns(2, true)
end)

-- Net receiver for loading errors.
net.Receive("InstructorManager.OfflineInstructorsError", function(len, ply)
	InstructorManager:CloseMenu()
	Notify:Danger(egmt("shared.error"), egmt("shared.offline_error"))
end)

-- Loads the logs based on filter and page.
-- Called when the filter or page got changed.
function InstructorManager:LoadLogs()
	self.Log:Clear()

	local filter = self.LogFilter:GetValue()
	local page = self.LogPageSelection:GetPage()

	self.LoadingLogs = true

	net.Start("InstructorManager.Logs")
		net.WriteString(filter)
		net.WriteInt(page, 32)
	net.SendToServer()
end

-- Net Receiver for logs.
net.Receive("InstructorManager.Logs", function()
	InstructorManager.LoadingLogs = false

	local len = net.ReadInt(32)
	local logs = DecompressTable(net.ReadData(len))
	local count = net.ReadInt(32)

	for k, v in pairs(logs) do
		InstructorManager.Log:AddSortedLine(v.text, "", os.date(egmt("shared.date_time"), v.created), v.created)
	end

	InstructorManager.Log:SortByColumns(2, true, 1, false) -- Sort descending.

	InstructorManager.LogPageSelection:SetPageCount(math.ceil(count / InstructorManager.PageSize))
end)

-- Net receiver for loading errors.
net.Receive("InstructorManager.LogsError", function(len, ply)
	InstructorManager:CloseMenu()
	Notify:Danger(egmt("shared.error"), egmt("shared.offline_error"))
end)

-- Closes the instructor manager.
function InstructorManager:Close()
	if IsValid(self.Frame) then
		self.Frame:Close()
	end
end

------------------------------------------
--    The following code is for live    --
--     refreshing. If any data gets     --
--  changed, it is updated in the menu. --
------------------------------------------

-- Refresh menu when a player data property got changed.
-- Only works for online players.
hook.Add("PlayerData.PropertyChanged", "InstructorManager.RefreshPlayer", function(playerData)
	if IsValid(InstructorManager.Frame) then
		-- Update Entry in list.
		for k, line in pairs(InstructorManager.InstructorList:GetLines()) do
			if line.instructor and line.instructor:GetId() == playerData:GetId() then
				local status = egmt("shared.normal")

				if playerData:GetProperty("instructorMentor", false) then
					status = egmt("instructor.mentor_name")
				elseif playerData:GetProperty("instructor", false) then
					status = egmt("instructor.name")
				end

				line.instructor = playerData

				-- Update text in the EGMListView.
				line.Columns[1].Value = playerData:GetName()
				line.Columns[2].Value = status

				-- Resort, because sorting values might have changed.
				InstructorManager.InstructorList:SortByColumns(2, true, 1, false)

				break
			end
		end
	end
end)
--gamemodes/egmrp/gamemode/modules/instructor/cl_scoreboard.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
-- Instructor - Scoreboard | Client  --
---------------------------------------

-- Adds the "Ausbildung bestanden" button to the scoreboard.
Scoreboard:AddOption(
	egmt("instructor.passed"),
	"icon16/medal_gold_add.png",
	700,
	function(target)
		Instructor:OpenEducateMenu(target)
	end,
	function(target)
		local ply = LocalPlayer()
		if not ply:CanEducate() then return false end

		local character = target:GetCurrentCharacter()
		if not character then return false end

		local rank = character:GetRank()
		if not rank then return false end

		if not rank:IsStartRank() then return false end

		return true
	end
)
--gamemodes/starwarsrp/gamemode/modules/medicmenu/sh_index.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--    on official 'Einfach Gaming'   --
--     servers owned by 'P4sca1'     --
--                                   --
-- Copyright © 2020 Pascal Sthamer,  --
--      Konstantin Zisiadis und      --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--         Medic Menu Index          --
---------------------------------------

if not RequireModules({"keybinds"}) then
	return false
end

MedicMenu = MedicMenu or {}
MedicMenu.Drugs = MedicMenu.Drugs or {}

if SERVER then
	AddCSLuaFile("sh_config.lua")
	AddCSLuaFile("sh_medicmenu.lua")
	AddCSLuaFile("cl_medicmenu.lua")

	include("sh_config.lua")
	include("sh_medicmenu.lua")
	include("sv_medicmenu.lua")
end

if CLIENT then
	include("sh_config.lua")
	include("sh_medicmenu.lua")
	include("cl_medicmenu.lua")
end
--gamemodes/starwarsrp/gamemode/modules/backpack/item_classes/sidebag/shared.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--       Shared | Sidebag Item       --
---------------------------------------

local ITEM_CLASS = ITEM_CLASS

-- Base Item class, from which functions and such should be inherited.
ITEM_CLASS.BaseItemClass = "backpack"

-- List of item slots, which the item can be equipped to.
ITEM_CLASS.Slots = {
	"belt",
	"backpack",
}

-- Sorting order of the item.
ITEM_CLASS.Sort = 2

-- Helper boolean to check if the item is an backpack item.
ITEM_CLASS.IsSidebag = true



---------------------------------------
--        Item Class Function        --
---------------------------------------

-- Check, if the item can be added to the given slot.
--
-- @param Character char
-- @param ItemType itemType
-- @param Table itemData
-- @param? String slotType
-- @return Boolean canAdd
-- @return? String error
function ITEM_CLASS:CanEquipInto(inventory, itemType, itemData, slotType)
	local currentSidebag = Inventory:GetCurrentSidebag(nil, inventory)
	if currentSidebag and (currentSidebag.SlotId ~= itemData.SlotId or currentSidebag.SubId ~= itemData.SubId) then
		return false, "Du trägst bereits eine Seitentasche."
	end

	local success, err = ITEM_CLASS.Base.CanEquipInto(self, inventory, itemType, itemData, slotType)
	if not success then
		return false, err
	end

	return true
end



---------------------------------------
--           Util Functions          --
---------------------------------------

-- Gets the current sidebag of the character.
--
-- @param? Character char
-- @param? Table inventory
-- @return? Table itemData
function Inventory:GetCurrentSidebag(char, inventory)
	return InventoryBoneMerge:GetCurrentItem("Sidebag", char, inventory)
end
--gamemodes/starwarsrp/gamemode/modules/backpack/item_slots/back/cl_init.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--      Client | Back Item Slot      --
---------------------------------------

local ITEM_SLOT = ITEM_SLOT

-- Name of the item slot displayed in the inventory.
ITEM_SLOT.Name = "Rücken"

-- Number of rows, the items should be displayed in.
ITEM_SLOT.Rows = 1
--gamemodes/starwarsrp/gamemode/modules/jetpack/cl_keybinds.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--          Client | Jetpack         --
---------------------------------------

-- Register a keybind for toggling the jetpack.
KeyBind:Register("Toggle Jetpack", egmt("shared.normal"), function()
	net.Start("Jetpack.Toggle")
	net.SendToServer()
end, KEY_J)
--gamemodes/starwarsrp/gamemode/modules/medicsystem_cwrp/sh_index.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--            Medicsystem            --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--      Medicsystem | SH Index       --
---------------------------------------

if not RequireModules({"medicsystem", "medicsystem_droid"}) then return end

if SERVER then
	AddCSLuaFile("sh_config.lua")

	include("sh_config.lua")
	include("sv_hooks.lua")
end

if CLIENT then
	include("sh_config.lua")
end

hook.Add("EGMRP.Loaded", "Medicsystem.LoadData", function()
	if SERVER then
		local mainpath = GAMEMODE.FolderName .. "/gamemode/modules/medicsystem_cwrp"
		local treatmentFiles = file.Find(mainpath .. "/treatments/" .. "*.lua", "LUA")
		for k, fileName in pairs(treatmentFiles) do
			AddCSLuaFile(mainpath .. "/treatments/" .. fileName)
			include(mainpath .. "/treatments/" .. fileName)
		end

		local injuryFiles = file.Find(mainpath .. "/injuries/" .. "*.lua", "LUA")
		for k, fileName in pairs(injuryFiles) do
			AddCSLuaFile(mainpath .. "/injuries/" .. fileName)
			include(mainpath .. "/injuries/" .. fileName)
		end
	else
		local mainpath = GAMEMODE.FolderName .. "/gamemode/modules/medicsystem_cwrp"
		local treatmentFiles = file.Find(mainpath .. "/treatments/" .. "*.lua", "LUA")
		for k, fileName in pairs(treatmentFiles) do
			include(mainpath .. "/treatments/" .. fileName)
		end

		local injuryFiles = file.Find(mainpath .. "/injuries/" .. "*.lua", "LUA")
		for k, fileName in pairs(injuryFiles) do
			include(mainpath .. "/injuries/" .. fileName)
		end
	end
end)
--gamemodes/starwarsrp/gamemode/modules/medicsystem/sh_index.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--            Medicsystem            --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--      Medicsystem | SH Index       --
---------------------------------------

if not RequireModules({"chat", "interact", "settings", "eventlog"}) then return end

Medicsystem = Medicsystem || {}
Medicsystem.Config = Medicsystem.Config || {}

Medicsystem.Treatments = Medicsystem.Treatments || {}

Medicsystem.Injuries = Medicsystem.Injuries || {}
Medicsystem.InjuryNames = Medicsystem.InjuryNames || {}

if SERVER then
	AddCSLuaFile("sh_config.lua")
	AddCSLuaFile("cl_medicsystem.lua")
	AddCSLuaFile("cl_effects.lua")
	AddCSLuaFile("cl_modal.lua")
	AddCSLuaFile("cl_interact.lua")
	AddCSLuaFile("cl_settings.lua")
	AddCSLuaFile("cl_hooks.lua")
	AddCSLuaFile("sh_medicsystem.lua")

	include("sh_config.lua")
	include("sh_medicsystem.lua")
	include("sv_medicsystem.lua")
	include("sv_hooks.lua")
	include("sv_net.lua")
end

if CLIENT then
	include("sh_config.lua")
	include("cl_medicsystem.lua")
	include("cl_effects.lua")
	include("cl_modal.lua")
	include("cl_interact.lua")
	include("cl_settings.lua")
	include("cl_hooks.lua")
	include("sh_medicsystem.lua")
end
--gamemodes/starwarsrp/gamemode/modules/medicsystem/entities/medicsystem_refill_crate/cl_init.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--            Medicsystem            --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--     Medicsystem | Refill Crate    --
---------------------------------------

include("shared.lua")

function ENT:Draw()
	self:DrawModel()

	if LocalPlayer():GetPos():DistToSqr(self:GetPos()) < 512 * 512 then
		local plyAng = self:GetAngles()

		local ang = Angle(plyAng.x, plyAng.y, plyAng.z)
		ang:RotateAroundAxis(ang:Forward(), 90)
		ang:RotateAroundAxis(ang:Right(), -90)

		cam.Start3D2D(self:GetPos() + self:GetForward() + self:GetUp() * 7, ang, .15)
			draw.RoundedBox(5, -180, -250, 350, 45, Color(0, 0, 0, 230))
			draw.DrawText("Medizinisches Lager", "header", -1, -245, Color(66, 224, 245, 255), TEXT_ALIGN_CENTER)
		cam.End3D2D()
	end
end
--gamemodes/starwarsrp/gamemode/modules/medicsystem/entities/medicsystem_refill_crate/shared.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--            Medicsystem            --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--     Medicsystem | Refill Crate    --
---------------------------------------

ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "Medizinisches Lager"
ENT.Category = "CW:RP Medizin"
ENT.Author = "Deltaa"
ENT.Purpose = ""

ENT.Spawnable = true
ENT.AdminOnly = false

ENT.ChargeableSweps = {
	["weapon_swrp_medic_faidkit"] = true,
	["weapon_swrp_medic_injector"] = true,
	["weapon_swrp_medic_kit"] = true,
	["weapon_swrp_medic_opkit"] = true,
	["weapon_swrp_medic_jedi"] = true,
	["weapon_swrp_medic_injector_swt"] = true,
	["weapon_swrp_medic_repairkit"] = true
}
--gamemodes/starwarsrp/gamemode/modules/medicsystem_droid/sh_index.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--            Medicsystem            --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--      Medicsystem | SH Index       --
---------------------------------------

if not RequireModules({"medicsystem"}) then return end

if SERVER then
	AddCSLuaFile("sh_medicsystem.lua")

	include("sh_medicsystem.lua")
	include("sv_medicsystem.lua")
end

if CLIENT then
	include("sh_medicsystem.lua")
end

hook.Add("EGMRP.Loaded", "Medicsystem_Droid.LoadData", function()
	if SERVER then
		local mainpath = GAMEMODE.FolderName .. "/gamemode/modules/medicsystem_droid"
		local treatmentFiles = file.Find(mainpath .. "/treatments/" .. "*.lua", "LUA")
		for k, fileName in pairs(treatmentFiles) do
			AddCSLuaFile(mainpath .. "/treatments/" .. fileName)
			include(mainpath .. "/treatments/" .. fileName)
		end

		local injuryFiles = file.Find(mainpath .. "/injuries/" .. "*.lua", "LUA")
		for k, fileName in pairs(injuryFiles) do
			AddCSLuaFile(mainpath .. "/injuries/" .. fileName)
			include(mainpath .. "/injuries/" .. fileName)
		end
	else
		local mainpath = GAMEMODE.FolderName .. "/gamemode/modules/medicsystem_droid"
		local treatmentFiles = file.Find(mainpath .. "/treatments/" .. "*.lua", "LUA")
		for k, fileName in pairs(treatmentFiles) do
			include(mainpath .. "/treatments/" .. fileName)
		end

		local injuryFiles = file.Find(mainpath .. "/injuries/" .. "*.lua", "LUA")
		for k, fileName in pairs(injuryFiles) do
			include(mainpath .. "/injuries/" .. fileName)
		end
	end
end)
--gamemodes/starwarsrp/gamemode/modules/medicsystem_cwrp/weapons/weapon_swrp_medic_faidkit/shared.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--            Medicsystem            --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--    Medicsystem | First Aid Kit    --
---------------------------------------

SWEP.Base 					= "weapon_swrp_medic_base"

SWEP.PrintName			  	= "Erste Hilfe Kit"
SWEP.Category			   	= "SW:RP (Medicsystem)"
SWEP.Type				   	= "Medical Supply Equipment"
SWEP.Manufacturer		   	= "Bac-Tech Industries"

SWEP.Author 				= "Deltaa"
SWEP.Purpose 				= "Wähle mit 'R' eine Behandlung aus."
SWEP.Contact 				= "https://www.einfach-gaming.de/user/4179-deltaa/"
SWEP.Instructions 			= "Linksklick zur Anwendung bei jemand anderem \nRechtsklick zur Eigenanwendung"
SWEP.Spawnable 				= true

SWEP.ItemType 				= "FirstAid"

SWEP.ViewModelFOV 			= 80
SWEP.ViewModelFlip			= false
SWEP.ViewModel 				= "models/bf2017/c_scoutblaster.mdl"
SWEP.WorldModel 			= "models/shells/pellet.mdl"

SWEP.Slot 					= 2
SWEP.SlotPos 				= 0

SWEP.UseHands 				= false

SWEP.VElements = {
	["Tube"] = {
		type = "Model",
		model = "models/lt_c/sci_fi/coffee_mug.mdl",
		bone = "v_scoutblaster_reference001",
		rel = "",
		pos = Vector(-1, 17, 2),
		angle = Angle(17, 10, -31),
		size = Vector(0.4, 0.4, 0.4),
		color = Color(255, 0, 0, 255),
		surpresslightning = false,
		material = "",
		skin = 0,
		bodygroup = {}
	},
	["tip"] = {
		type = "Model",
		model = "models/lt_c/sci_fi/am_container.mdl",
		bone = "v_scoutblaster_reference001",
		rel = "Tube",
		pos = Vector(0, 0, 3.5),
		angle = Angle(0, 54, 0),
		size = Vector(0.039, 0.039, 0.039),
		color = Color(0, 255, 0, 255),
		surpresslightning = false,
		material = "",
		skin = 0,
		bodygroup = {}
	}
}

SWEP.WElements = {
	["Tube"] = {
		type = "Model",
		model = "models/lt_c/sci_fi/coffee_mug.mdl",
		bone = "ValveBiped.Bip01_R_Hand",
		rel = "",
		pos = Vector(2.599, 1.6, 1),
		angle = Angle(29.221, -8.183, 180),
		size = Vector(0.699, 0.699, 0.699),
		color = Color(255, 0, 0, 255),
		surpresslightning = false,
		material = "",
		skin = 0,
		bodygroup = {}
	},

	["tip"] = {
		type = "Model",
		model = "models/lt_c/sci_fi/am_container.mdl",
		bone = "ValveBiped.Bip01_R_Hand",
		rel = "Tube",
		pos = Vector(0, 0, 5.8),
		angle = Angle(0, 54.935, 0),
		size = Vector(0.07, 0.07, 0.07),
		color = Color(0, 255, 0, 255),
		surpresslightning = false,
		material = "",
		skin = 0,
		bodygroup = {}
	}
}

SWEP.Primary.ClipSize = 10
SWEP.Primary.DefaultClip = 10
SWEP.Primary.Ammo = "none"

-- Aiming
SWEP.IronSightsPos = Vector(0, 0, -2)
SWEP.IronSightsAng = Vector(0, 0, 0)

-- Running
SWEP.RunSightsPos = Vector(0, 0, -2)
SWEP.RunSightsAng = Vector(0, 0, 0)

-- Inspecting
SWEP.InspectPos = Vector(0, 0, -2)
SWEP.InspectAng = Vector(0, 0, 0)
--gamemodes/starwarsrp/gamemode/modules/medicsystem_cwrp/weapons/weapon_swrp_medic_kit/shared.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--            Medicsystem            --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--    Medicsystem | Treatment Kit    --
---------------------------------------

SWEP.Base 					= "weapon_swrp_medic_base"

SWEP.PrintName			  	= "Behandlungskit"
SWEP.Category			   	= "SW:RP (Medicsystem)"
SWEP.Type				   	= "Medical Supply Equipment"
SWEP.Manufacturer		   	= "Bac-Tech Industries"

SWEP.Author 				= "Deltaa"
SWEP.Purpose 				= "Wähle mit 'R' eine Behandlung aus."
SWEP.Contact 				= "https://www.einfach-gaming.de/user/4179-deltaa/"
SWEP.Instructions 			= "Linksklick zur Anwendung bei jemand anderem \nRechtsklick zur Eigenanwendung"
SWEP.Spawnable 				= true

SWEP.ViewModelFOV 			= 80
SWEP.ViewModelFlip			= false
SWEP.ViewModel 				= "models/bf2017/c_scoutblaster.mdl"
SWEP.WorldModel 			= "models/shells/pellet.mdl"

SWEP.Slot 					= 2
SWEP.SlotPos 				= 0

SWEP.ItemType 				= "Kit"
SWEP.UseHands 				= false

SWEP.VElements = {
	["Tube"] = {
		type = "Model",
		model = "models/lt_c/sci_fi/coffee_mug.mdl",
		bone = "v_scoutblaster_reference001",
		rel = "",
		pos = Vector(-1, 17, 2),
		angle = Angle(17, 10, -31),
		size = Vector(0.4, 0.4, 0.4),
		color = Color(255, 0, 0, 255),
		surpresslightning = false,
		material = "",
		skin = 0,
		bodygroup = {}
	},
	["tip"] = {
		type = "Model",
		model = "models/lt_c/sci_fi/am_container.mdl",
		bone = "v_scoutblaster_reference001",
		rel = "Tube",
		pos = Vector(0, 0, 3.5),
		angle = Angle(0, 54, 0),
		size = Vector(0.039, 0.039, 0.039),
		color = Color(0, 255, 0, 255),
		surpresslightning = false,
		material = "",
		skin = 0,
		bodygroup = {}
	}
}

SWEP.WElements = {
	["Tube"] = {
		type = "Model",
		model = "models/lt_c/sci_fi/coffee_mug.mdl",
		bone = "ValveBiped.Bip01_R_Hand",
		rel = "",
		pos = Vector(2.599, 1.6, 1),
		angle = Angle(29.221, -8.183, 180),
		size = Vector(0.699, 0.699, 0.699),
		color = Color(255, 0, 0, 255),
		surpresslightning = false,
		material = "",
		skin = 0,
		bodygroup = {}
	},

	["tip"] = {
		type = "Model",
		model = "models/lt_c/sci_fi/am_container.mdl",
		bone = "ValveBiped.Bip01_R_Hand",
		rel = "Tube",
		pos = Vector(0, 0, 5.8),
		angle = Angle(0, 54.935, 0),
		size = Vector(0.07, 0.07, 0.07),
		color = Color(0, 255, 0, 255),
		surpresslightning = false,
		material = "",
		skin = 0,
		bodygroup = {}
	}
}

SWEP.Primary.ClipSize = 40
SWEP.Primary.DefaultClip = 40
SWEP.Primary.Ammo = "none"

-- Aiming
SWEP.IronSightsPos = Vector(0, 0, -2)
SWEP.IronSightsAng = Vector(0, 0, 0)

-- Running
SWEP.RunSightsPos = Vector(0, 0, -2)
SWEP.RunSightsAng = Vector(0, 0, 0)

-- Inspecting
SWEP.InspectPos = Vector(0, 0, -2)
SWEP.InspectAng = Vector(0, 0, 0)
--gamemodes/starwarsrp/gamemode/modules/gravitylock/sh_config.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--           Gravity Lock            --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--       Gravity Lock | Config       --
---------------------------------------

-- The model for the small gravity lock
Gravitylock.Config.ModelSmall = "models/niksacokica/tech/tech_support.mdl"

-- The model for the big gravity lock
Gravitylock.Config.ModelBig = "models/niksacokica/tech/tech_support_02.mdl"

-- The health of the small gravity lock
Gravitylock.Config.HealthSmall = 2500

-- The health of the big gravity lock
Gravitylock.Config.HealthBig = 5000

-- The list of vehicles, which can locked by the gravity lock (must be lfs)
Gravitylock.Config.Vehicles = {
	["Big"] = {
		["lvs_walker_atte"] = {
			pos = Vector(5, -205, -5),
			angles = Angle(0, 85, 0)
		},

		["lvs_repulsorlift_gunship_carrier"] = {
			pos = Vector(50, 0, 5),
			angles = Angle(0, 0, 0)
		},

		["lvs_repulsorlift_gunship"] = {
			pos = Vector(380, 0, -5),
			angles = Angle(0, 180, 0)
		},

		["lvs_repulsorlift_gunship_medic"] = {
			pos = Vector(380, 0, -5),
			angles = Angle(0, 180, 0)
		},

		["lvs_repulsorlift_gunship_aarc"] = {
			pos = Vector(380, 0, -5),
			angles = Angle(0, 180, 0)
		},

		["lvs_starfighter_arc"] = {
			pos = Vector(120, 55, -80),
			angles = Angle(0, -90, 0)
		},


		["lvs_repulsorlift_nuclass"] = {
			pos = Vector(410, 125, 35),
			angles = Angle(0, 270, 0)
		},


		["lvs_starfighter_ywing"] = {
			pos = Vector(-100, -286, -10),
			angles = Angle(0, 90, 0)
		},


		-- ["lunasflightschool_utat"] = {
		-- 	pos = Vector(340, -275, -10),
		-- 	angles = Angle(0, 90, 0)
		-- },

		["lvs_repulsorlift_stealth"] = {
			pos = Vector(-28, -80, 0),
			angles = Angle(0, 90, 0)
		},

		["lvs_repulsorlift_gunship_le"] = {
			pos = Vector(-185, 0, -5),
			angles = Angle(0, 0, 0)
		},
    	["lvs_starfighter_ebonhawk"] = {
            pos = Vector(-621, 0, -15),
			angles = Angle(-2, 0, 0)
		},    
    	["lvs_starfighter_firespray"] = {
            pos = Vector(-173, -280, 380),
			angles = Angle(-0, 90, 87)
		}, 
    	["lvs_starfighter_gauntlet"] = {
            pos = Vector(-502, 0, 84),
			angles = Angle(-0, 0, 0)
		},
    	["lvs_starfighter_interceptor"] = {
            pos = Vector(-180, -332, -77),
			angles = Angle(-0, 90, 0)
		},
    	["lvs_starfighter_liberator"] = {
            pos = Vector(-200, -0, -55),
			angles = Angle(-0, 0, 0)
		},
    	["lvs_starfighter_missileboat"] = {
            pos = Vector(-285, -0, -90),
			angles = Angle(-0, 0, 0)
		},
    	["lvs_starfighter_n1"] = {
            pos = Vector(100, -200, -0),
			angles = Angle(-0, 90, 0)
		}
    	

    
	},

	["Small"] = {
		["lvs_fakehover_barc"] = {
			pos = Vector(-45, 45, -25),
			angles = Angle(0, -90, 0)
		},

		["lvs_fakehover_barc_medic"] = {
			pos = Vector(-45, 45, -25),
			angles = Angle(0, -90, 0)
		},

		["lvs_fakehover_tx130"] = {
			pos = Vector(90, 0, -20),
			angles = Angle(0, 180, 0),
		},

		["lvs_starfighter_z95"] = {
			pos = Vector(-257, 0, 5),
			angles = Angle(0, 0, 0),
		},

		["lvs_starfighter_wwing"] = {
			pos = Vector(-155, 0, -10),
			angles = Angle(0, 0, 0),
		},

		["lvs_starfighter_vwing"] = {
			pos = Vector(-30, 90, -40),
			angles = Angle(0, -90, 0)
		},

		["lvs_starfighter_v19"] = {
			pos = Vector(120, 0, -45),
			angles = Angle(0, 180, 0)
		},

		["lvs_starfighter_delta7"] = {
			pos = Vector(-98, 98, 6),
			angles = Angle(2, -75, -2.5)
		},

		["lvs_starfighter_delta7b"] = {
			pos = Vector(-98, 98, 6),
			angles = Angle(2, -75, -2.5)
		},

		["lvs_starfighter_eta2"] = {
			pos = Vector(5, 100, -2),
			angles = Angle(0, -96, 0)
		},

		["lvs_fakehover_isp"] = {
			pos = Vector(-130, 0, -20),
			angles = Angle(0, 0, 0)
		},

		["lvs_fakehover_swoop"] = {
			pos = Vector(146.4, 00, 0),
			angles = Angle(0, 180, 0)
		},

		["lvs_starfighter_n1"] = {
			pos = Vector(110, 189.5, 0),
			angles = Angle(0, -90, 0)
		},

		["lvs_starfighter_shuttle_jedi"] = {
			pos = Vector(5, 70, 0),
			angles = Angle(0, -96, 0)
		},

		["lvs_walker_atrt"] = {
			pos = Vector(5, 45, 0),
			angles = Angle(0, -96, 0)
		},
        ["lvs_fakehover_45z"] = {
        	pos = Vector(-75, 0, -35),
			angles = Angle(0, 0, 0)
		},
        ["lvs_repulsorlift_airspeeder"] = {
        	pos = Vector(-150, 0, -18),
			angles = Angle(-8, 0, 0)
		},
        ["lvs_starfighter_alligator"] = {
        	pos = Vector(-240, 0, -4),
			angles = Angle(-0, 0, 0)
		},
        ["lvs_fakehover_armis"] = {
        	pos = Vector(-111, 0, -4),
			angles = Angle(-0, 0, 0)
		},
       ["lvs_fakehover_aurum"] = {
        	pos = Vector(-95, 0, -0),
			angles = Angle(-0, 0, 0)
		},

        ["lvs_fakehover_casus"] = {
            pos = Vector(-74, 0, -13),
			angles = Angle(-0, 0, 0)
		},
        ["lvs_fakehover_celeritas"] = {
            pos = Vector(-65, 0, -13),
			angles = Angle(-0, 0, 0)
		},
        ["lvs_starfighter_spiral"] = {
            pos = Vector(-123, 0, -0),
			angles = Angle(-0, 0, 0)
		},
        ["lvs_fakehover_czerka"] = {
            pos = Vector(-37, 0, -13),
			angles = Angle(-0, 0, 0)
		},
        ["lvs_fakehover_extum"] = {
            pos = Vector(-83, 0, -12),
			angles = Angle(-0, 0, 0)
		},
        ["lvs_fakehover_hammerhead"] = {
            pos = Vector(-126, 0, -12),
			angles = Angle(-0, 0, 0)            
		},
        ["lvs_starfighter_havoc"] = {
            pos = Vector(164, 0, -22),
			angles = Angle(-8, 180, 0)  
		},
    	["lvs_starfighter_starchaser"] = {
            pos = Vector(360, 0, 5),
			angles = Angle(-0,180, 0)  
		},
        ["lvs_starfighter_shuttle"] = {
            pos = Vector(5, 70, 0),
			angles = Angle(0, -96, 0)
		},
    	["lvs_starfighter_shuttle_armed"] = {
            pos = Vector(5, 70, 0),
			angles = Angle(0, -96, 0)
		},
        ["lvs_repulsorlift_transporter"] = {
            pos = Vector(288, 0, -110),
			angles = Angle(0, -180, 0)
		},
    	["lvs_starfighter_transporter_civ"] = {
            pos = Vector(-300, 112, -30),
			angles = Angle(-0, -70, 0)
		},
        ["lvs_fakehover_sanctum"] = {
            pos = Vector(-75, 0, -25),
			angles = Angle(0, 0, 0)
		},
        ["lvs_fakehover_scavenger"] = {
            pos = Vector(-135, 0, -25),
			angles = Angle(0, 0, 0)
		},
        ["lvs_fakehover_cagespeeder"] = {
            pos = Vector(-40, -38, -12),
			angles = Angle(0, 90, 0)
		},
        ["lvs_fakehover_x34"] = {
            pos = Vector(-20, -64, -25),
			angles = Angle(0, 90, 0)
		},
        ["lvs_fakehover_x34_gun"] = {
            pos = Vector(-20, -64, -25),
			angles = Angle(0, 90, 0)
		}
    
	}
}

--gamemodes/egmrp/gamemode/modules/morgue/cl_interact.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--         Morgue | Interact         --
---------------------------------------

-- Morgue Interact, to remove body bags.
Interact:RegisterOption(nil, egmt("morgue.remove_body_bag"), 1, function()
	local ply = LocalPlayer()

	local trace = ply:GetEyeTrace()
	if not trace.Hit then
		Interact.Menu:Remove()

		return
	end

	local distance = ply:EyePos():Distance(trace.HitPos)
	if distance > 100 then return end

	local ent = trace.Entity
	if ent:IsRagdoll() and Morgue.BodyBagModels[ent:GetModel()] then
		if not ent:GetNWBool("IsBodyBag") then return end

		net.Start("Morgue.UnWrapBody")
			net.WriteEntity(ent)
		net.SendToServer()
	end

	Interact.Menu:Remove()
end, function()
	local ply = LocalPlayer()
	local trace = ply:GetEyeTrace()
	if not trace.Hit then return false end

	local distance = ply:EyePos():Distance(trace.HitPos)
	if distance > 100 then return false end

	local ent = trace.Entity
	if ent:IsRagdoll() and Morgue.BodyBagModels[ent:GetModel()] then
		if not ent:GetNWBool("IsBodyBag") then return false end

		return true
	end

	return false
end)
--gamemodes/egmrp/gamemode/modules/morgue/weapons/egmrp_bodybag/cl_init.lua:
---------------------------------------
---------------------------------------
--	     	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--            Created by             --
--       Jan 'Oninoni' Ziegler       --
--       		Deltaa       		 --
--                                   --
--   This software is only allowed   --
--    on official 'Einfach Gaming'   --
--     servers owned by 'P4sca1'     --
---------------------------------------
---------------------------------------

---------------------------------------
--       Bodybag SWEP | Client       --
---------------------------------------

include("shared.lua")

SWEP.Author         = "Oninoni"
SWEP.Contact        = "Discord: Oninoni#8830"
SWEP.Purpose        = "Base SWEP for the Bodybag."
SWEP.Instructions   = "Wrap a body in a bodybag."
SWEP.Category       = "EGM:RP"

SWEP.DrawAmmo      = false
SWEP.DrawCrosshair = true

function SWEP:Initialize()
	self:SetHoldType("slam")
end

-- Do nothing, when right-clicking.
function SWEP:PrimaryAttack()
end

-- Do nothing, when right-clicking.
function SWEP:SecondaryAttack()
end

-- Hide the viewmodel.
function SWEP:PreDrawViewModel(vm, pl, wep)
	return true
end

-- Draw the ammo count.
function SWEP:DrawHUD()
	if self.BagCount <= 1 then return end

	ammoText = self:GetNWInt("BagCount", 0) .. " / " .. self.BagCount

	draw.SimpleText(ammoText, "EGMText8", ScrW() * 0.925, ScrH() * 0.9735, UI.ForegroundColor, TEXT_ALIGN_CENTER)
end
--gamemodes/egmrp/gamemode/modules/permaprops/sh_config.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--        Permaprop | Config         --
---------------------------------------
--  Variables should be overwritten  --
--     in the deriving gamemode!     --
---------------------------------------

-- Maximum amount of permaprops per map.
PermaProps.MaxProps = 750

-- Maximum amount of displayed items in the list.
PermaProps.PerMenuPage = 100

-- Minimum Rank to Permaprop something and list new users
PermaProps.MinimumGroup = "admin"

--Minimum Rank to get whitelisted as Permaprop User.
PermaProps.MinimumListGroup = "operator"

-- should the prop actually be removed from the world when it's removed as a permaprop?
PermaProps.RemoveEntOnRemove = false

-- Deriving maps share the perma props of a base map.
PermaProps.DerivingMaps = {
    --["derivingMap"] = "baseMap"
}

-- Blacklist for models when creating permaprops. Does not affect already saved permaprops.
PermaProps.ModelBlacklist = {
    --"models/props_debris/metal_panel02a.mdl"
}

-- Blacklist for entity classes when creating permaprops. Does not affect already saved permaprops.
PermaProps.EntityBlacklist = {
    --"prop_physics"
}

-- Delay after wich a permapropped weapon respawns if picked up in the weaponslots system.
PermaProps.WeaponRespawnDelay = 120
--gamemodes/egmrp/gamemode/modules/permaprops/sh_stool_removeprops.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--    Shared | Remove Props STool    --
---------------------------------------

local TOOL = {}

TOOL.Category       =   "EGM:RP"
TOOL.Name            =    "RemoveProps"
TOOL.Command        =    nil
TOOL.ConfigName        =    ""

if CLIENT then
    language.Add("Tool.removeprops.name", "RemoveProps")
    language.Add("Tool.removeprops.desc", "Remove a props permanently")
    language.Add("Tool.removeprops.0", "LeftClick: Add RightClick: OpenMenu")
end

if SERVER then
    util.AddNetworkString("ContentRmvProps")
    util.AddNetworkString("RemoveProps.Remove")

    hook.Add("SQL.CreateTables", "RemoveProps.CreateTable", function()
        SQL:CreateTableIfNotExists("removeprops", {
            { name = "id", definition = "INT PRIMARY KEY AUTO_INCREMENT" },
            { name = "map", definition = "TEXT NOT NULL" },
            { name = "map_creation_id", definition = "INT NOT NULL" }
        })
    end)

    local function RemovePropsRemove( um, ply )
        local mapCreationId = net.ReadFloat()

        if not ply:IsAdmin() then return end

        SQL:PreparedQuery("DELETE FROM `removeprops` WHERE `map_creation_id` = ?", mapCreationId)
    end
    net.Receive("RemoveProps.Remove", RemovePropsRemove)

    local RemovePropsList = RemovePropsList or {}

    local function RemoveProp(mapCreationId)
        local ent = ents.GetMapCreatedEntity(mapCreationId)

        RemovePropsList[mapCreationId] = {
            name = ent:GetClass(),
            model = ent:GetModel(),
            pos = ent:GetPos(),
            angle = ent:GetAngles(),
        }

        if IsValid(ent) then
            ent:Remove()
        end
    end

    local function RemoveProps()
        SQL:Query([[SELECT * FROM `removeprops`]], function(success, results)
            if not success then
                return
            end

            for k, v in pairs(results[1].data) do
                if game.GetMap() == v.map then
                    RemoveProp(v.map_creation_id)
                end
            end
        end)
    end
    hook.Add("SQL.Ready", "InitializeRemoveProps", RemoveProps)
    hook.Add("PostCleanupMap", "WhenCleanUpRemoveProps", RemoveProps)

    function TOOL:LeftClick(trace)
        local ply = self:GetOwner()
        local ent = trace.Entity

        if not self:GetOwner():IsAdmin() then return false end
        if ent:IsWorld() then Notify:Warning(ply, "Fehler!", "Du kannst nicht die Map entfernen DUDE!" ) return false end
        if not (ent and IsValid(ent)) then Notify:Warning(ply, "Fehler!", "Das ist nichtmal eine Entity!" ) return false end

        if ent:IsPlayer() then Notify:Warning(ply, "Fehler!", "Das ist ein Spieler!" ) return false end
        if ent:MapCreationID() == -1 then Notify:Warning(ply, "Fehler!", "Das ist kein Map-Prop!") return false end

        SQL:Insert("removeprops", {
            map = game.GetMap(),
            map_creation_id = ent:MapCreationID(),
        }, function(success, results)
            if success then
                RemoveProp(ent:MapCreationID())

                Notify:Warning(ply, "RemoveProps", "Das Prop wurde permanent entfernt!")

                local effectdata = EffectData()
                effectdata:SetOrigin(ent:GetPos())
                effectdata:SetMagnitude(2)
                effectdata:SetScale(2)
                effectdata:SetRadius(3)
                util.Effect("Sparks", effectdata)
            end
        end)

        return true
    end

    function TOOL:RightClick(trace)

        SQL:Query([[SELECT * FROM `removeprops`]], function(success, results)
            if not success then
                return
            end

            local SendTable = {}
            for k, v in pairs(results[1].data) do
                if game.GetMap() == v.map then
                    local data = RemovePropsList[v.map_creation_id]
                    data.ID = v.map_creation_id

                    table.insert(SendTable, data)
                end
            end

            net.Start("ContentRmvProps")
            net.WriteTable(SendTable)
            net.Send(self:GetOwner())
        end)

        return false
    end

    function TOOL:Reload(trace)
        return false
    end
end

function TOOL.BuildCPanel(panel)
    panel:AddControl("Header",{Text = "Perma Remove Props", Description = "Remove a server props for restarts\nBy Malboro"})
end

local function ContentRmvProps()
    local Content = net.ReadTable()

    local DermaPanel = vgui.Create( "DFrame" )
    DermaPanel:SetSize( 500, 200 )
    DermaPanel:SetTitle( "Removed props" )
    DermaPanel:Center()
    DermaPanel:MakePopup()

    local DermaListView = vgui.Create("DListView", DermaPanel)
    DermaListView:SetPos(25, 30)
    DermaListView:SetSize(450, 125)
    DermaListView:SetMultiSelect(false)
    local Col1 = DermaListView:AddColumn("ID")
    local Col2 = DermaListView:AddColumn("Name")
    DermaListView:AddColumn("Model")
    Col1:SetMinWidth(50)
    Col1:SetMaxWidth(50)
    Col2:SetMinWidth(80)
    Col2:SetMaxWidth(80)
    DermaListView.OnRowRightClick = function(panel, line)
        local MenuButtonOptions = DermaMenu()
        MenuButtonOptions:AddOption("Draw entity", function()
            if not LocalPlayer().DrawRemovedEnt or not istable(LocalPlayer().DrawRemovedEnt) then LocalPlayer().DrawRemovedEnt = {} end

            if LocalPlayer().DrawRemovedEnt[Content[DermaListView:GetLine(line):GetValue(1)].ID] and LocalPlayer().DrawRemovedEnt[Content[DermaListView:GetLine(line):GetValue(1)].ID]:IsValid() then return end

            local ent = ents.CreateClientProp( Content[DermaListView:GetLine(line):GetValue(1)].Model )
            ent:SetPos( Content[DermaListView:GetLine(line):GetValue(1)].Pos )
            ent:SetAngles( Content[DermaListView:GetLine(line):GetValue(1)].Angle )

            LocalPlayer().DrawRemovedEnt[Content[DermaListView:GetLine(line):GetValue(1)].ID] = ent
        end )

        if LocalPlayer().DrawRemovedEnt and LocalPlayer().DrawRemovedEnt[Content[DermaListView:GetLine(line):GetValue(1)].ID] ~= nil then
            MenuButtonOptions:AddOption("Stop Drawing", function()

                LocalPlayer().DrawRemovedEnt[Content[DermaListView:GetLine(line):GetValue(1)].ID]:Remove()
                LocalPlayer().DrawRemovedEnt[Content[DermaListView:GetLine(line):GetValue(1)].ID] = nil

            end )
        end

        MenuButtonOptions:AddOption("Remove", function()
            net.Start("RemoveProps.Remove")
                net.WriteFloat(Content[DermaListView:GetLine(line):GetValue(1)].ID)
            net.SendToServer()

            if LocalPlayer().DrawRemovedEnt and LocalPlayer().DrawRemovedEnt[Content[DermaListView:GetLine(line):GetValue(1)].ID] ~= nil then

                LocalPlayer().DrawRemovedEnt[Content[DermaListView:GetLine(line):GetValue(1)].ID]:Remove()
                LocalPlayer().DrawRemovedEnt[Content[DermaListView:GetLine(line):GetValue(1)].ID] = nil

            end

            DermaListView:RemoveLine(line)

            LocalPlayer():ChatPrint("Removed successfully from the database ! ( Need server restart )")
        end )
        MenuButtonOptions:Open()
    end

    for k, v in pairs(Content) do
        DermaListView:AddLine(k, v.name, v.model)
    end
end
net.Receive("ContentRmvProps", ContentRmvProps)

local function RemoverViewer()
    if not LocalPlayer().DrawRemovedEnt or not istable(LocalPlayer().DrawRemovedEnt) then return end

    local pos = LocalPlayer():EyePos() + LocalPlayer():EyeAngles():Forward() * 10
    local ang = LocalPlayer():EyeAngles()

    ang = Angle(ang.p + 90, ang.y, 0)

    for k, v in pairs(LocalPlayer().DrawRemovedEnt) do
        if not v or not v:IsValid() then LocalPlayer().DrawRemovedEnt[k] = nil continue end

        render.ClearStencil()
        render.SetStencilEnable(true)
            render.SetStencilWriteMask(255)
            render.SetStencilTestMask(255)
            render.SetStencilReferenceValue(15)
            render.SetStencilFailOperation(STENCILOPERATION_REPLACE)
            render.SetStencilZFailOperation(STENCILOPERATION_REPLACE)
            render.SetStencilPassOperation(STENCILOPERATION_KEEP)
            render.SetStencilCompareFunction(STENCILCOMPARISONFUNCTION_ALWAYS)
            render.SetBlend(0)
            v:DrawModel()
            render.SetBlend(1)
            render.SetStencilCompareFunction(STENCILCOMPARISONFUNCTION_EQUAL)
            cam.Start3D2D(pos, ang, 1)
                    surface.SetDrawColor(255, 0, 0, 255)
                    surface.DrawRect(-ScrW(), -ScrH(), ScrW() * 2, ScrH() * 2)
            cam.End3D2D()
            v:DrawModel()
        render.SetStencilEnable(false)
    end
end
hook.Add("PostDrawOpaqueRenderables", "RemoverViewer", RemoverViewer)

stools.Register(TOOL, "removeprops")
--gamemodes/egmrp/gamemode/modules/permaprops/cl_permaprops.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--         Permaprop Client          --
---------------------------------------

PermaProps.CurrentProps = PermaProps.CurrentProps or 0

-- Opens the perma props menu.
--
-- @param? Number page
-- @param? Number ppid
function PermaProps:OpenMenu(page)
    page = page or 1

    if not LocalPlayer():CanPermaProp() then
        chat.AddText(egmt("propertymodel.no_permission"))

        return false
    end

    if IsValid(self.Menu) then
        self.Menu:Close()
    end

    if IsValid(self.Lister) then
        self.Lister:Close()
    end

    local w, h = ScrW() * 0.6, ScrH() * 0.7

    self.Menu = vgui.Create("DFrame")
    self.Menu:SetSize(w, h)
    self.Menu:Center()
    self.Menu:SetTitle("")
    self.Menu:SetDraggable(true)
    self.Menu:ShowCloseButton(false)
    function self.Menu:Paint(width, height)
        draw.RoundedBox(0, 0, 0, width, height, ColorAlpha(UI.BackgroundColor, 250))
    end
    function self.Menu:OnClose()
        net.Start("PermaProps.RemovePVSVisibility")
        net.SendToServer()
    end

    self.Title = vgui.Create("DPanel", self.Menu)
    self.Title:SetPos(w * 0.15, 0)
    self.Title:SetSize(w - w * 0.15 * 2, h * 0.1)
    function self.Title:Paint(width, height)
        draw.RoundedBox(0, w * 0.05, 0, width - w * 0.05 * 2, height, UI.BackgroundColor2)

        surface.SetDrawColor(UI.BackgroundColor2)
        draw.NoTexture()

        surface.DrawPoly({
            {x = 0, y = 0},
            {x = w * 0.051, y = 0},
            {x = w * 0.051, y = height}
        })
        surface.DrawPoly({
            {x = width - w * 0.051, y = 0},
            {x = width, y = 0},
            {x = width - w * 0.051, y = height}
        })

        draw.DrawText(egmt("permaprops.menu"), "EGMText12", width / 2, height * 0.15, UI.ForegroundColor, TEXT_ALIGN_CENTER)
    end

    self.Close = vgui.Create("EGMCloseButton", self.Menu)
    self.Close:SetPos(w * 0.965, h * 0.01)
    self.Close:SetSize(w * 0.03, h * 0.05)
    self.Close:SetPanel(self.Menu)

    self.PropAmount = vgui.Create("DPanel", self.Menu)
    self.PropAmount:SetPos(w * 0.01, h * 0.01)
    self.PropAmount:SetSize(w * 0.15, h *  0.07)
    function self.PropAmount:Paint(width, height)
        draw.SimpleText(
            PermaProps.CurrentProps .. " | " .. PermaProps.MaxProps,
            "EGMText12",
            width * 0.1, height * 0.1,
            GetColor("blue"),
            TEXT_ALIGN_LEFT
        )
    end

    self.ButtonFrame = vgui.Create("DPanel", self.Menu)
    self.ButtonFrame:Dock(BOTTOM)
    self.ButtonFrame:SetSize(w, h * 0.06)
    self.ButtonFrame:DockMargin(w * 0.005, h * 0.01, w * 0.005, 0)
    function self.ButtonFrame:Paint(width, height)
        draw.RoundedBox(0, 0, 0, width, height, UI.BackgroundColor2)
    end

    self.ReloadButton = vgui.Create("EGMButton", self.ButtonFrame)
    self.ReloadButton:DockMargin(0, h * 0.005, w * 0.005, h * 0.005)
    if LocalPlayer():IsAtLeast(PermaProps.MinimumGroup) then
       self.ReloadButton:SetSize(w * 0.31, h * 0.05)
    else
       self.ReloadButton:SetSize(w * 0.48, h * 0.05)
    end
    self.ReloadButton:Dock(LEFT)
    self.ReloadButton:SetTextColor(UI.TextColor)
    self.ReloadButton:SetFont("EGMText10")
    self.ReloadButton:SetText(egmt("permaprops.reload"))
    function self.ReloadButton:DoClick()
        local modal = vgui.Create("EGMModal")
		modal:SetCustomTitle(egmt("shared.are_you_sure"))
        modal:Confirm(egmt("permaprops.lag"), function()
            net.Start("PermaProps.Reload")
            net.SendToServer()

            Notify:Info(egmt("permaprops.reloaded"), egmt("permaprops.reloaded_description"), 5)
        end)
    end

    if LocalPlayer():IsAtLeast(PermaProps.MinimumListGroup) then
        self.WhitelistButton = vgui.Create("EGMButton", self.ButtonFrame)
        self.WhitelistButton:DockMargin(w * 0.005, h * 0.005, w * 0.005, h * 0.005)
        self.WhitelistButton:Dock(FILL)
        self.WhitelistButton:SetTextColor(UI.TextColor)
        self.WhitelistButton:SetFont("EGMText10")
        self.WhitelistButton:SetText(egmt("whitelist.whitelist"))
        function self.WhitelistButton:DoClick()
            PermaProps.Menu:Close()
            PermaProps:OpenLister()
        end
    end

    self.DeleteButton = vgui.Create("EGMButton", self.ButtonFrame)
    self.DeleteButton:DockMargin(w * 0.005, h * 0.005, 0, h * 0.005)
    if LocalPlayer():IsAtLeast(PermaProps.MinimumGroup) then
       self.DeleteButton:SetSize(w * 0.31, h * 0.05)
    else
       self.DeleteButton:SetSize(w * 0.48, h * 0.05)
    end
    self.DeleteButton:Dock(RIGHT)
    self.DeleteButton:SetTextColor(UI.TextColor)
    self.DeleteButton:SetFont("EGMText10")
    self.DeleteButton:SetText(egmt("permaprops.delete_all"))
    self.DeleteButton:SetButtonColor(Color(255, 31, 31))
    function self.DeleteButton:DoClick()
        local modal = vgui.Create("EGMModal")
		modal:SetCustomTitle(egmt("shared.are_you_sure"))
        modal:Confirm(egmt("permaprops.delete_all_description"), function()
			local modal2 = vgui.Create("EGMModal")
            modal2:SetCustomTitle(egmt("permaprops.really_sure"))
            modal2:Confirm(egmt("permaprops.delete_all_confirm"), function()
                PermaProps.PropList:Clear()
                PermaProps.CurrentProps = 0

                net.Start("PermaProps.RemoveAll")
                net.SendToServer()

                Notify:Info(egmt("permaprops.delete_done"), egmt("permaprops.delete_done_description"), 5)
            end, egmt("permaprops.delete_confirm"))
        end)
    end

    self.PropListPanel = vgui.Create("DPanel", self.Menu)
    self.PropListPanel:Dock(LEFT)
    self.PropListPanel:DockMargin(w * 0.005, h * 0.08, w * 0.005, 0)
    self.PropListPanel:SetWidth(w * 0.5)
    function self.PropListPanel:Paint() end

    self.PropList = vgui.Create("EGMListView", self.PropListPanel)
    self.PropList:Dock(FILL)
    self.PropList:SetMultiSelect(false)
    self.PropList:SetHeaderHeight(w * 0.04)
    self.PropList:SetDataHeight(w * 0.03)
    self.PropList:AddCustomColumn(egmt("permaprops.model"))
    self.PropList:AddCustomColumn(egmt("permaprops.distance")):SetFixedWidth(w * 0.1)
    self.PropList:AddCustomColumn(egmt("shared.time")):SetFixedWidth(w * 0.15)
    function self.PropList:OnRowSelected(index, line)
        PermaProps:ShowProp(line.prop)
    end
    function self.PropList:Refresh()
        self:Clear()

        net.Start("PermaProps.List")
            net.WriteInt(PermaProps.PageSelection:GetPage(), 32)
        net.SendToServer()

        PermaProps.PageSelection:SetDisabled(true)
    end

    self.PageSelection = vgui.Create("EGMPageSelector", self.PropListPanel)
    self.PageSelection:SetHeight(ScrH() * 0.025)
    self.PageSelection:Dock(BOTTOM)
    self.PageSelection:SetPageCount(page)
    self.PageSelection:SetPage(page)
    self.PageSelection:SetCallback(function()
        PermaProps.PropList:Refresh()
    end)

    self.PropPanel = vgui.Create("DPanel", self.Menu)
    self.PropPanel:Dock(FILL)
    self.PropPanel:DockMargin(0, h * 0.08, 0, 0)
    self.PropPanel:SetVisible(false)
    self.PropPanel.Time = 0

    function self.PropPanel:Paint(width, height)
        if not self.Prop or not self.Creator then return end
        if not self.DistanceToModel then
            local ent = PermaProps:GetProp(self.Prop.id)
            if not IsValid(ent) then
                draw.SimpleText(egmt("permaprops.loading"), "EGMText14", width * 0.5, height * 0.5, UI.TextColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
                return
            end

            local v1, v2 = ent:GetModelBounds()
            self.DistanceToModel = math.max(math.abs(v1.x - v2.x), math.abs(v1.y - v2.y), math.abs(v1.z - v2.z))
        end

        local origin = self.Prop.pos + Vector(
            math.cos(self.Time) * self.DistanceToModel,
            math.sin(self.Time) * self.DistanceToModel,
            self.DistanceToModel * 0.5
        )
        local angles = (self.Prop.pos - origin):Angle()
        local gX, gY = PermaProps.Menu:GetPos()
        local x, y = self:GetPos()
        x = x + gX
        y = y + gY

        self.Time = self.Time + FrameTime() * 0.5

        render.RenderView({
            origin = origin,
            angles = angles,
            x = x, y = y,
            w = width, h = height,
            aspectratio = width / height,
            zfar = 1000000000,
        })

        draw.RoundedBox(0, 0, 0, width, height * 0.1, UI.BackgroundColor2)
        draw.RoundedBox(0, 0, height * 0.82, width, height * 0.2, UI.BackgroundColor2)

        draw.SimpleText(self.Prop.class, "EGMText8", width * 0.5, height * 0.02, UI.ForegroundColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
        draw.SimpleText(self.Prop.model, "EGMText8", width * 0.5, height * 0.07, UI.ForegroundColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)

        draw.SimpleText(egmt("permaprops.creator"), "EGMText10", width * 0.02, height * 0.85, UI.ForegroundColor, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
        draw.SimpleText(self.Creator, "EGMText10", width * 0.98, height * 0.85, UI.ForegroundColor, TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER)
    end

    self.PropButtonPanel = vgui.Create("DPanel", self.PropPanel)
    self.PropButtonPanel:SetHeight(h * 0.05)
    self.PropButtonPanel:DockMargin(0, 0, 0, w * 0.005)
    self.PropButtonPanel:Dock(BOTTOM)
    function self.PropButtonPanel:Paint(width, height)
    end

    self.PropGotoButton = vgui.Create("EGMButton", self.PropButtonPanel)
    self.PropGotoButton:SetWidth(w * 0.235)
    self.PropGotoButton:DockMargin(w * 0.005, h * 0.01, w * 0.005, 0)
    self.PropGotoButton:Dock(LEFT)
    self.PropGotoButton:SetTextColor(UI.TextColor)
    self.PropGotoButton:SetFont("EGMText8")
    self.PropGotoButton:SetText(egmt("permaprops.teleport_to"))
    function self.PropGotoButton:DoClick()
        net.Start("PermaProps.Teleport")
            net.WriteInt(PermaProps.PropPanel.Prop.id, 32)
        net.SendToServer()
    end

    self.PropDeleteButton = vgui.Create("EGMButton", self.PropButtonPanel)
    self.PropDeleteButton:SetWidth(w * 0.235)
    self.PropDeleteButton:DockMargin(w * 0.005, h * 0.01, w * 0.005, 0)
    self.PropDeleteButton:Dock(RIGHT)
    self.PropDeleteButton:SetTextColor(UI.TextColor)
    self.PropDeleteButton:SetFont("EGMText8")
    self.PropDeleteButton:SetText(egmt("permaprops.remove_prop"))
    self.PropDeleteButton:SetButtonColor(Color(255, 31, 31))
    function self.PropDeleteButton:DoClick()
        local modal = vgui.Create("EGMModal")
		modal:SetCustomTitle(egmt("shared.are_you_sure"))
        modal:Confirm(egmt("permaprops.prop_removing"), function()
            net.Start("PermaProps.Remove")
                net.WriteInt(PermaProps.PropPanel.Prop.id, 32)
            net.SendToServer()

            PermaProps.PropList:RemoveLine(PermaProps.PropList:GetSelectedLine())
            PermaProps.CurrentProps = PermaProps.CurrentProps - 1

            Notify:Info(egmt("permaprops.prop_removed"), egmt("permaprops.prop_removed_description"), 5)
        end)
    end

    self.PropSteamIdButtonPanel = vgui.Create("DPanel", self.PropPanel)
    self.PropSteamIdButtonPanel:SetHeight(h * 0.05)
    self.PropSteamIdButtonPanel:Dock(BOTTOM)
    function self.PropSteamIdButtonPanel:Paint(width, height)
    end

    self.OpenSteamProfileButton = vgui.Create("EGMButton", self.PropSteamIdButtonPanel)
    self.OpenSteamProfileButton:SetWidth(w * 0.235)
    self.OpenSteamProfileButton:DockMargin(w * 0.005, h * 0.01, w * 0.005, 0)
    self.OpenSteamProfileButton:Dock(RIGHT)
    self.OpenSteamProfileButton:SetTextColor(UI.TextColor)
    self.OpenSteamProfileButton:SetFont("EGMText8")
    self.OpenSteamProfileButton:SetText(egmt("permaprops.steamprofile"))
    function self.OpenSteamProfileButton:DoClick()
        gui.OpenURL("https://steamcommunity.com/profiles/" .. PermaProps.PropPanel.Prop.playerSteamId64)
    end

    self.CopySteamIdButton = vgui.Create("EGMButton", self.PropSteamIdButtonPanel)
    self.CopySteamIdButton:SetWidth(w * 0.235)
    self.CopySteamIdButton:DockMargin(w * 0.005, h * 0.01, w * 0.005, 0)
    self.CopySteamIdButton:Dock(LEFT)
    self.CopySteamIdButton:SetTextColor(UI.TextColor)
    self.CopySteamIdButton:SetFont("EGMText8")
    self.CopySteamIdButton:SetText(egmt("permaprops.steamid"))
    function self.CopySteamIdButton:DoClick()
        SetClipboardText(PermaProps.PropPanel.Prop.playerSteamId64)
    end

    self.Menu:MakePopup()
    self.PropList:Refresh()
end

function PermaProps:ShowProp(prop)
    self.PropPanel:SetVisible(true)

    self.PropPanel.Prop = prop
    self.PropPanel.DistanceToModel = nil

    self.PropPanel.Creator = prop.playerSteamId64
    steamworks.RequestPlayerInfo( prop.playerSteamId64, function(steamName)
        if self.PropPanel.Prop == prop then
            self.PropPanel.Creator = steamName
        end
    end)

    net.Start("PermaProps.AddPVSVisibility")
        net.WriteVector(prop.pos)
    net.SendToServer()
end

-- Opens the PermaProp Lister
function PermaProps:OpenLister()
    if not LocalPlayer():IsAtLeast(PermaProps.MinimumGroup) then
        chat.AddText(egmt("propertymodel.no_permission"))
        return false
    end

    if IsValid(self.Menu) then
        self.Menu:Close()
    end

    if IsValid(self.Lister) then
        self.Lister:Close()
    end

    local w, h = ScrW() * 0.6, ScrH() * 0.7

    self.Lister = vgui.Create("DFrame")
    self.Lister:SetSize(w, h)
    self.Lister:Center()
    self.Lister:SetTitle("")
    self.Lister:SetDraggable(true)
    self.Lister:ShowCloseButton(false)
    function self.Lister:Paint(width, height)
        draw.RoundedBox(0, 0, 0, width, height, ColorAlpha(UI.BackgroundColor, 250))
    end

    self.ListerTitle = vgui.Create("DPanel", self.Lister)
    self.ListerTitle:SetPos(w * 0.15, 0)
    self.ListerTitle:SetSize(w - w * 0.15 * 2, h * 0.1)
    function self.ListerTitle:Paint(width, height)
        draw.RoundedBox(0, w * 0.05, 0, width - w * 0.05 * 2, height, UI.BackgroundColor2)

        surface.SetDrawColor(UI.BackgroundColor2)
        draw.NoTexture()

        surface.DrawPoly({
            {x = 0, y = 0},
            {x = w * 0.051, y = 0},
            {x = w * 0.051, y = height}
        })
        surface.DrawPoly({
            {x = width - w * 0.051, y = 0},
            {x = width, y = 0},
            {x = width - w * 0.051, y = height}
        })

        draw.DrawText(egmt("permaprops.lister_menu"), "EGMText12", width / 2, height * 0.15, UI.ForegroundColor, TEXT_ALIGN_CENTER)
    end

    self.CloseLister = vgui.Create("EGMCloseButton", self.Lister)
    self.CloseLister:SetPos(w * 0.965, h * 0.01)
    self.CloseLister:SetSize(w * 0.03, h * 0.05)
    self.CloseLister:SetPanel(self.Lister)

    self.ListerList = vgui.Create("EGMListView", self.Lister)
    self.ListerList:Dock(FILL)
    self.ListerList:DockMargin(w * 0.01, h * 0.1, w * 0.01, 0)
    self.ListerList:SetMultiSelect(false)
    self.ListerList:SetHeaderHeight(w * 0.04)
    self.ListerList:SetDataHeight(w * 0.03)
    self.ListerList:AddCustomColumn(egmt("permaprops.user"))
    self.ListerList:AddCustomColumn(egmt("permaprops.lister"))
    self.ListerList:AddCustomColumn(egmt("shared.time"))
    function self.ListerList:OnRowRightClick(line, isSelected)
        local listercontext = DermaMenu(PermaProps.ListerList)
        function listercontext:Paint(width, height)
            draw.RoundedBox(0, 0, 0, width, height, UI.TextColor)
            surface.SetDrawColor(UI.ForegroundColor)
            self:DrawOutlinedRect()
        end
            listercontext:AddOption(egmt("permaprops.entlist"), function()
            local modal = vgui.Create("EGMModal")
			modal:SetCustomTitle(egmt("shared.are_you_sure"))
            modal:Confirm(egmt("permaprops.user_remove"), function()
                net.Start("PermaProps.RemovePlayerFromWhitelist")
                    net.WriteString(self:GetLine(line).UserSteamID64)
                net.SendToServer()

                self:RemoveLine(line)
            end)
            end):SetImage("icon16/cross.png")

            listercontext:AddOption(egmt("permaprops.user_steam"), function()
                gui.OpenURL("https://steamcommunity.com/profiles/" .. self:GetLine(line).UserSteamID64)
            end):SetImage("icon16/user.png")

            listercontext:AddOption(egmt("permaprops.lister_steam"), function()
                gui.OpenURL("https://steamcommunity.com/profiles/" .. self:GetLine(line).ListerSteamID64)
            end):SetImage("icon16/user.png")

            listercontext:Open()
    end
    function self.ListerList:Refresh()
        self:Clear()
        net.Start("PermaProps.PlayerWhitelist")
        net.SendToServer()
    end

    self.ListerButtonFrame = vgui.Create("DPanel", self.Lister)
    self.ListerButtonFrame:Dock(BOTTOM)
    self.ListerButtonFrame:SetSize(w, h * 0.06)
    self.ListerButtonFrame:DockMargin(w * 0.01, h * 0.01, w * 0.01, 0)
    function self.ListerButtonFrame:Paint(width, height)
        draw.RoundedBox(0, 0, 0, width, height, UI.BackgroundColor2)
    end

    self.MenuButton = vgui.Create("EGMButton", self.ListerButtonFrame)
    self.MenuButton:DockMargin(w * 0.005, h * 0.005, w * 0.005, h * 0.005)
    self.MenuButton:SetSize(w * 0.327, h * 0.05)
    self.MenuButton:Dock(LEFT)

    self.MenuButton:SetTextColor(UI.TextColor)
    self.MenuButton:SetFont("EGMText10")
    self.MenuButton:SetText(egmt("shared.back"))
    function self.MenuButton:DoClick()
        PermaProps.Lister:Close()
        PermaProps:OpenMenu()
    end

    self.ListerDropdown = vgui.Create("DComboBox", self.ListerButtonFrame)
    self.ListerDropdown:DockMargin(w * 0.005, h * 0.005, w * 0.005, h * 0.005)
    self.ListerDropdown:SetSize(w * 0.31, h * 0.05)
    self.ListerDropdown:Dock(LEFT)
    for k, ply in pairs(player.GetHumans()) do
        if ply:IsAtLeast(PermaProps.MinimumListGroup) and not ply:IsAtLeast(PermaProps.MinimumGroup) then
            self.ListerDropdown:AddChoice(ply:Nick(), ply)
        end
    end
    self.ListerDropdown:SetSortItems(false)
    self.ListerDropdown:SetFont("EGMText8")
    self.ListerDropdown:SetTextColor(GetColor("black"))

    self.ListButton = vgui.Create("EGMButton", self.ListerButtonFrame)
    self.ListButton:DockMargin(w * 0.005, h * 0.005, w * 0.005, h * 0.005)
    self.ListButton:SetSize(w * 0.31, h * 0.05)
    self.ListButton:Dock(RIGHT)
    self.ListButton:SetTextColor(UI.TextColor)
    self.ListButton:SetFont("EGMText10")
    self.ListButton:SetText(egmt("permaprops.list"))
    function self.ListButton:DoClick()
        if PermaProps.ListerDropdown:GetSelectedID() then
            local listedID = PermaProps.ListerDropdown:GetOptionData(PermaProps.ListerDropdown:GetSelectedID())
            net.Start("PermaProps.AddPlayerToWhitelist")
                    net.WriteString(listedID:SteamID64())
            net.SendToServer()

            local line = PermaProps.ListerList:AddCustomLine(
                listedID:SteamName(),
                LocalPlayer():SteamName(),
                os.date(egmt("shared.date_time"), os.time())
            )

            line.UserSteamID64 = listedID:SteamID64()
            line.ListerSteamID64 = LocalPlayer():SteamID64()
        end
    end

    self.Lister:MakePopup()
    self.ListerList:Refresh()
end

-- Concommand that opens the perma prop menu, needed for the tool.
concommand.Add("perma_prop_menu", function()
    PermaProps:OpenMenu()
end)

-- Handle receiving the list of permaprops, displayed in the menu.
net.Receive("PermaProps.List", function()
    if not IsValid(PermaProps.Menu) then return end

    local len = net.ReadInt(32)
    local props = DecompressTable(net.ReadData(len))
    local count = net.ReadInt(32)

    -- Save old page.
    local oldPage = PermaProps.PageSelection:GetPage()

    -- Clear current pages and prop list.
    PermaProps.PropList:Clear()

    -- Insert loaded props and safe count.
    PermaProps.CurrentProps = count

    for k, prop in pairs(props) do
        local line = PermaProps.PropList:AddCustomLine(
            string.Replace(prop.model, "models/", ""),
            math.Round(prop.pos:Distance(LocalPlayer():GetPos()), 0),
            os.date(egmt("shared.date_time"), prop.createdAt)
        )

        line.prop = prop

        if PermaProps.PPIDToOpen and PermaProps.PPIDToOpen >= 0 and prop.id == PermaProps.PPIDToOpen then
            PermaProps.PropList:SelectItem(line)
        end
    end

    PermaProps.PPIDToOpen = -1

    -- Generate new pages.
    local pages = math.ceil(PermaProps.CurrentProps / PermaProps.PerMenuPage)

    PermaProps.PageSelection:SetPageCount(pages)
    PermaProps.PageSelection:SetPage(oldPage)

    -- Re-enable page selection.
    PermaProps.PageSelection:SetDisabled(false)
end)

-- Handle receiving the list of permaprops, displayed in the menu.
net.Receive("PermaProps.PlayerWhitelist", function()
    if not IsValid(PermaProps.Lister) then return end

    local len = net.ReadInt(32)
    local whitelist = DecompressTable(net.ReadData(len))

    -- Clear current lister list.
    PermaProps.ListerList:Clear()

    for k, listed in pairs(whitelist) do
        local line = PermaProps.ListerList:AddCustomLine(
            listed.steamId64,
            listed.listerSteamid64,
            os.date(egmt("shared.date_time"), listed.listedAt)
        )

        line.UserSteamID64 = listed.steamId64
        line.ListerSteamID64 = listed.listerSteamid64

        steamworks.RequestPlayerInfo( listed.steamId64, function(steamName)
            line.Columns[1].Value = steamName
        end)

        steamworks.RequestPlayerInfo( listed.listerSteamid64, function(steamName)
            line.Columns[2].Value = steamName
        end)
    end
end)
--gamemodes/egmrp/gamemode/modules/reports/sh_reports.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--      Shared | Reports System      --
---------------------------------------

Character:AddProperty("reports", "table", {}, function(character, value)
	if not istable(value) then
		return false, egmt("reports.invalid")
	end

	return true
end,
function(character, ply)
	-- Networking is done manually, because data can get quite big.
	return false
end)

-- Register rank permission: reports
RANK_PERMISSION_REPORTS = "reports"
Rank:RegisterPermission(RANK_PERMISSION_REPORTS, egmt("reports.view"))

-- Register rank permission: reports_edit
RANK_PERMISSION_REPORTS_EDIT = "reports_edit"
Rank:RegisterPermission(RANK_PERMISSION_REPORTS_EDIT, egmt("reports.edit"))

local Player = FindMetaTable("Player")

-- Internal check, if a faction and rank combination is allowed to view reports.
--
-- @param Faction playerFaction
-- @param Rank playerRank
-- @param Faction targetFaction
-- @param Rank targetRank
-- @return Boolean canViewReports
function Reports:CanViewReportsInternal(playerFaction, playerRank, targetFaction, targetRank)
	if playerFaction == nil or playerRank == nil or targetFaction == nil or targetRank == nil then
		return false
	end

	-- Check if the player is in the same faction.
	if playerFaction ~= targetFaction then
		return false
	end

	-- Check permission.
	if not playerRank:HasPermission(RANK_PERMISSION_REPORTS) then
		return false
	end

	-- Check authority levels.
	if playerRank:GetAuthorityLevel() <= targetRank:GetAuthorityLevel() then
		return false
	end

	return true
end

-- Internal check, if a faction and rank combination is allowed to edit reports.
--
-- @param Faction playerFaction
-- @param Rank playerRank
-- @param Faction targetFaction
-- @param Rank targetRank
-- @return Boolean canEditReports
function Reports:CanEditReportsInternal(playerFaction, playerRank, targetFaction, targetRank)
	if playerFaction == nil or playerRank == nil or targetFaction == nil or targetRank == nil then
		return false
	end

	-- Check if the player is in the same faction.
	if playerFaction ~= targetFaction then
		return false
	end

	-- Check permission.
	if not playerRank:HasPermission(RANK_PERMISSION_REPORTS_EDIT) then
		return false
	end

	-- Check authority levels.
	if playerRank:GetAuthorityLevel() <= targetRank:GetAuthorityLevel() then
		return false
	end

	return true
end

-- Checks whether a player can view the reports of the character.
--
-- @param Table character
-- @return Boolean canViewReports
function Player:CanViewReports(character)
	if self:IsAtLeast(Reports.MinAccessGroup) then
		return true
	end

	-- You always check your own reports even from other characters.
	if character:BelongsTo(self) then
		return true
	end

	local playerCharacter = self:GetCurrentCharacter()
	if not playerCharacter then
		return false
	end

	local override = hook.Run("Reports.CanViewReports", playerCharacter, character)
	if isbool(override) then
		return override
	end

	local playerFaction = playerCharacter:GetFaction()
	local playerRank = playerCharacter:GetRank()

	local targetFaction = character:GetFaction()
	local targetRank = character:GetRank()

	return Reports:CanViewReportsInternal(playerFaction, playerRank, targetFaction, targetRank)
end

-- Checks whether the player is allowed to add reports to the character.
--
-- @param Table character
-- @return Boolean canAddReport
function Player:CanAddReport(character)
	if self:IsAtLeast(Reports.MinAccessGroup) then
		return true
	end

	local playerCharacter = self:GetCurrentCharacter()
	if not playerCharacter then
		return false
	end

	local override = hook.Run("Reports.CanAddReport", playerCharacter, character)
	if isbool(override) then
		return override
	end

	local playerFaction = playerCharacter:GetFaction()
	local playerRank = playerCharacter:GetRank()

	local targetFaction = character:GetFaction()
	local targetRank = character:GetRank()

	return Reports:CanEditReportsInternal(playerFaction, playerRank, targetFaction, targetRank)
end
--gamemodes/egmrp/gamemode/modules/socket/sh_index.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--          Socket | Index           --
---------------------------------------

Socket = Socket or {}

if SERVER then
    AddCSLuaFile("cl_socket.lua")

    include("sv_config.lua")
    include("sv_socket_core.lua")
    include("sv_socket.lua")
    include("sv_chats.lua")
end

if CLIENT then
    include("cl_socket.lua")
end
--gamemodes/egmrp/gamemode/modules/experience/sh_perks.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--          Shared | Perks           --
---------------------------------------

-- Add a property for the perks.
Character:AddProperty("perks", "table", {}, function(character, value)
    if not istable(value) then
        return false, egmt("shared.invalid_type")
    end

    return true
end,
function(character, ply)
    -- Only the owner of the character needs to know the perks.
    return character:BelongsTo(ply)
end)

-- Alias function for getting the perks of a character.
function Character.Meta:GetPerks()
    return self:GetProperty("perks", {})
end

-- Calculates how many skillpoints are available for the character.
--
-- @return Number availableSkillPoints
function Character.Meta:GetAvailableSkillPoints()
    local perks = self:GetPerks()
    local pointsAvailable = math.floor(self:GetLevel() / Experience.LevelPerSkillPoint)

    -- Check how many perks the player has skilled.
    for perk, v in pairs(Experience.Perks) do
        if perks[perk] then
            pointsAvailable = pointsAvailable - perks[perk]
        end
    end

    return pointsAvailable
end

-- Alias functions on the player for getting the perks / available skill points of his current character.
local Player = FindMetaTable("Player")

function Player:GetPerks()
    local character = self:GetCurrentCharacter()

    if character then
        return character:GetPerks()
    end

    return {}
end

function Player:GetAvailableSkillPoints()
    local character = self:GetCurrentCharacter()

    if character then
        return character:GetAvailableSkillPoints()
    end

    return 0
end

-- Increase HP by the current perk value.
hook.Add("Character.GetStats", "Perks.GetStats", function(character, stats)
	local perks = character:GetProperty("perks", {})

	if Experience.Perks.health and perks.health then
		local healthMultiplier = Experience.Perks.health.values[perks.health].value

		stats[1] = stats[1] * healthMultiplier
	end
end)

-- Increase Speed by the current perk value.
hook.Add("Character.GetMovement", "Perks.GetMovement", function(character, movement)
	local perks = character:GetProperty("perks", {})

	if Experience.Perks.movement and perks.movement then
		local movementMultiplier = Experience.Perks.movement.values[perks.movement].value

		movement[1] = movement[1] * movementMultiplier
	end
end)
--gamemodes/starwarsrp/gamemode/modules/bactainjector/sh_config.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--          Bacta Injector           --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--    Bacta Injector | SH Config     --
---------------------------------------

BactaInjector.Models = {
	["models/egm/core/clone_commando/clone_commando.mdl"] = true,
}
--gamemodes/starwarsrp/gamemode/modules/soundboard/sh_index.lua:
--------------------------------
--       Einfach-Gaming       --
--        Soundboard          --
--                            --
--     Created by Deltaa      --
--------------------------------

--------------------------------
--		  SH | Index		  --
--------------------------------

Soundboard = Soundboard || {}
Soundboard.Config = Soundboard.Config || {}


if SERVER then
	AddCSLuaFile("cl_interact.lua")
	AddCSLuaFile("sh_config.lua")

	include("sh_config.lua")
	include("sv_soundboard.lua")
end

if CLIENT then
	include("cl_interact.lua")
	include("sh_config.lua")
end
--gamemodes/starwarsrp/gamemode/modules/soundboard/cl_interact.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--    on official 'Einfach Gaming'   --
--     servers owned by 'P4sca1'     --
--                                   --
-- Copyright © 2020 Pascal Sthamer,  --
--      Konstantin Zisiadis und      --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--        Client | Soundboard        --
---------------------------------------

hook.Add("EGMRP.Loaded", "Soundboard.Interact", function()
	Interact:RegisterCategory("soundboard", nil, "Soundboard", 4, 8, function()
		local exists = false

		for name, data in pairs(Soundboard.Config.Sounds) do
			if !data.models[LocalPlayer():GetModel()] then
				continue
			else
				exists = true
				break
			end
		end

		return exists
	end)

	local i = 0
	for name, data in SortedPairs(Soundboard.Config.Sounds) do
		Interact:RegisterOption("soundboard", name, i, function()
			net.Start("Soundboard:Playsound")
				net.WriteString(name)
			net.SendToServer()

			Interact.Menu:Remove()
		end, function()
			if data and istable(data.models) then
				return data.models[LocalPlayer():GetModel()]
			end
		end)

		i = i + 1
	end
end)
--gamemodes/egmrp/gamemode/modules/afk/sh_index.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--            AFK | Index            --
---------------------------------------

AFK = AFK or {}

if SERVER then
    AddCSLuaFile("sh_afk.lua")
    AddCSLuaFile("cl_afk.lua")

    include("sv_config.lua")
    include("sh_afk.lua")
    include("sv_afk.lua")
end

if CLIENT then
    include("sh_afk.lua")
    include("cl_afk.lua")
end
--gamemodes/starwarsrp/gamemode/modules/helmet/cl_helmet.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--          Client | Helmet          --
---------------------------------------

ItemType:AddPropertyToList("helmetSlot", "Helm Slot", "Sollte die Rüstung einen Helm Slot haben?", "boolean", nil, nil, 4, egmt("inventory.title"))

ItemType:AddPropertyToList("hideHead", "Kopf verstecken", "Sollte der Kopf versteckt werden?", "boolean", nil, nil, 5, egmt("inventory.title"))

-- Show the back slot.
hook.Add("ItemClass.ShouldShowProperty", "Helmet.ShowProperties", function(itemClass, propertyName)
	if itemClass.IsArmor and propertyName == "helmetSlot" then
		return true
	end
end)



---------------------------------------
--       BoneMerge Integration       --
---------------------------------------

-- Add the species head model to the bone merge system.
InventoryBoneMerge:RegisterCharacterModel("Helmet", function(char)
	local currentHelmet = Inventory:GetCurrentHelmet(char)
	if not currentHelmet then return end

	return currentHelmet.Model
end, function(char, clientEnt)
	local currentHelmet = Inventory:GetCurrentHelmet(char)
	if not currentHelmet then return end

	local model = currentHelmet.Model
	local materialSetId = currentHelmet.SkinId
	if isstring(model) and materialSetId ~= nil then
		BaseModel:ApplyBaseModel(clientEnt, model, materialSetId)
	end

	local bodygroups = currentHelmet.Bodygroups
	if istable(bodygroups) then
		BodyGroups:ApplyInternal(clientEnt, bodygroups)
	end
end)

-- Hide the head, if there is a helmet on the corpse.
hook.Add("Species.SkipCorpseHeadModel", "", function(ent, headModel)
	local modelSkin = ent:GetNWString("IBM.ModelSkin.Helmet", "")
	if not isstring(modelSkin) or modelSkin == "" or modelSkin == "|" then return end

	return true
end)
--gamemodes/starwarsrp/gamemode/modules/helmet/item_slots/head/shared.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--      Shared | Head Item Slot      --
---------------------------------------

local ITEM_SLOT = ITEM_SLOT

-- Base Item slot, from which functions and such should be inherited.
ITEM_SLOT.BaseItemSlot = "base"

-- Number of items that can be stored in this slot.
ITEM_SLOT.Count = 1

-- Are items equipped as useable items?
ITEM_SLOT.Equipment = true
--gamemodes/starwarsrp/gamemode/modules/charban/cl_charban.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--           Character Ban           --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--        Character Ban | CL         --
---------------------------------------

-- Adds a character property for the info of char ban
Character:AddPropertyToList("charban", "Character-Sperre", "Zeigt an, ob der Charakter eine Sperre hat.", "number", {}, function(rank, faction, character)
	if character then
		local unbanTime = character:GetProperty("charban", 0)

		if unbanTime <= os.time() then
			return false
		end

		return true
	end
end)

-- Adds a faction property to set the character ban on death
Faction:AddPropertyToList("charban", "Todesbann", "Wie lang soll ein Charakter dieser Fraktion beim Tod gebannt sein? (0 = Kein Charbann)", "number" )
--gamemodes/egmrp/gamemode/modules/ammosystem/entities/egmrp_ammolocker/cl_init.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--      Client | Ammolocker Entity   --
---------------------------------------

AddCSLuaFile("shared.lua")
include("shared.lua")

-- Drawing the model.
function ENT:Draw()
    self:DrawModel()
end
--gamemodes/egmrp/gamemode/modules/signs/sh_signs.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--           Signs | Shared          --
---------------------------------------

-- Hash  a table with sign data into a persistent string.
--
-- @param Table signData
-- @return String hash
function Signs:HashSignData(signData)
    local sortedString = ""

    for key, data in SortedPairs(signData) do
        if istable(data) then
            sortedString = sortedString .. tostring(key) .. self:HashSignData(data)
        else
            sortedString = sortedString .. tostring(key) .. tostring(data)
        end
    end

    return util.SHA1(sortedString)
end
--gamemodes/egmrp/gamemode/modules/inventory_weight/cl_inventory_weight.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--     Client | Inventory Weight     --
---------------------------------------

-- Add rank properties to list. These are editable in item rank edit.
Rank:AddPropertyToList("maxWeight", egmt("inventory.maxWeight"), egmt("inventory.maxWeight_description"), "number", nil, nil, 1, egmt("inventory.title"))

Equipment:AddPropertyToList("weightBonus", egmt("inventory.weightBonus"), egmt("inventory.weightBonus_description"), "slider", function()
	return {min = -1000, max = 1000}
end, nil, 1, egmt("inventory.title"))

ItemType:AddPropertyToList("weight", egmt("itemType.weight"), egmt("itemType.weight_description"), "number", function(itemType)
	return {min = 0, max = 200}
end, nil, 4, nil)

-- Show the weight property
hook.Add("ItemClass.ShouldShowProperty", "InventoryWeight.ShowProperties", function(itemClass, propertyName)
	if propertyName == "weight" then
		return true
	end
end)

-- Create the weight bar for the inventory.
--
-- @param Panel content
-- @param Character char
function InventoryWeight:CreateWeightBar(content, char)
	-- Remove the weight bar.
	if IsValid(self.WeightBar) then
		self.WeightBar:Remove()
	end

	-- Add Weight bar.
	local weightBar = vgui.Create("DPanel", content)
	weightBar:DockMargin(ScrW() * 0.013, 0, ScrW() * 0.015, ScrH() * 0.005)
	weightBar:Dock(BOTTOM)
	weightBar:SetTall(ScrH() * 0.025)

	function weightBar:Paint(ww, hh)
		local weight = char:GetInventoryWeight()
		local maxWeight = char:GetMaxWeight()

		local weightPercentage = math.Clamp(weight / (maxWeight * 1.25), 0, 1)

		local color = UI.ForegroundColor
		if weightPercentage > 0.8 then
			color = Color(255, 0, 0)
		elseif weightPercentage > 0.6 then
			color = Color(255, 127, 0)
		end

		draw.RoundedBox(4, 0, hh * 0.5, ww, hh * 0.5, UI.BackgroundColor2)
		draw.RoundedBoxEx(4, ww * 0.8, hh * 0.5, ww * 0.2, hh * 0.5, ColorAlpha(UI.DangerColor, 16), false, true, false, true)

		draw.RoundedBox(0, 0, hh * 0.625, ww * weightPercentage, hh * 0.25, color)

		draw.SimpleText(weight .. "kg / " .. maxWeight .. "kg", "EGMText8", ww * 0.5, hh * 0.25, UI.TextColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
	end

	self.WeightBar = weightBar
end



---------------------------------------
--               Hooks               --
---------------------------------------

-- Add the weight bar to the inventory.
hook.Add("Inventory.CreatePlayerInventory", "InventoryWeight.AddWeightBar", function(content, char)
	InventoryWeight:CreateWeightBar(content, char)
end)

-- Add the weight info to the tooltip.
hook.Add("Inventory.AddTooltipLines", "InventoryWeight.AddWeightInfo", function(itemClass, itemType, itemData, detailed, lines)
	local weight = itemType:GetWeight()
	if weight > 0 then
		table.insert(lines, {
			Text = egmt("inventory.weight", weight),
			Color = UI.TextColor,
			Align = TEXT_ALIGN_RIGHT
		})
	end
end)
--gamemodes/egmrp/gamemode/modules/special_character/sh_config.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--    Config | Special Character    --
---------------------------------------
--  Variables should be overwritten  --
--     in the deriving gamemode!     --
---------------------------------------

-- Minimum usergroup to edit Courses.
SpecialCharacter.MinAccessGroup = "operator"

-- Minimum usergroup to assign Courses.
SpecialCharacter.MinAssignGroup = "operator"
--gamemodes/egmrp/gamemode/modules/special_character/cl_manager.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--     Client | Special Character    --
---------------------------------------

-- Add the special Character type to the faction manager.
Manager:RegisterObjectType(
    Faction.Name,
    SpecialCharacter.Name,
    egmt("shared.specialChar"),
    function(faction)
        return faction:GetSpecialCharacters()
    end,
    function(faction)
        return SpecialCharacter:Create({factionId = faction:GetId()}, {name = egmt("specialChar.new")})
    end,
    function(faction, specialChar)
        return specialChar:GetModel():GetPropertyList(faction, specialChar)
    end,
    egmt("specialChar.duplicate"),
    egmt("specialChar.delete"),
    egmt("specialChar.delete_warning"),
    egmt("specialChar.add"),
    egmt("specialChar.save")
)
--gamemodes/egmrp/gamemode/modules/inventory_shop/cl_shop_entry.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--        Client | Shop Entry        --
---------------------------------------

-- Clear property list to avoid duplicate entries.
ShopEntry.PropertyList = {}

-- Add shop entry properties to list. These are editable in shop entry edit.
ShopEntry:AddPropertyToList("category", egmt("shopEntry.category_name"), egmt("shopEntry.category_description"), "string", nil, nil, 1, nil)

ShopEntry:AddPropertyToList("shopClass", egmt("shopEntry.shopClass_name"), egmt("shopEntry.shopClass_description"), "dropdown", function(shopEntry)
	local shopClasses = {}

	for shopClass, shopClassData in pairs(InventoryShop.ShopClasses) do
		if shopClass == "base" then continue end

		table.insert(shopClasses, {
			text = shopClassData.Name,
			data = shopClass,
		})
	end

	return shopClasses
end, nil, 2, nil)

ShopEntry:AddPropertyToList("price", egmt("shopEntry.price_name"), egmt("shopEntry.price_description"), "number", nil, nil, 1, egmt("inventory_shop.title"))

ShopEntry:AddPropertyToList("maxStock", egmt("shopEntry.maxStock_name"), egmt("shopEntry.maxStock_description"), "number", nil, nil, 2, egmt("inventory_shop.title"))

ShopEntry:AddPropertyToList("stockRegen", egmt("shopEntry.stockRegen_name"), egmt("shopEntry.stockRegen_description"), "number", nil, nil, 3, egmt("inventory_shop.title"))

-- Register item type package type.
Loading:RegisterPackageType("shopEntry", egmt("shopEntry.package"), function(packageData)
	for k, sData in pairs(packageData) do
		ShopEntry:Load(sData.data, sData.properties):Cache()
	end
end)



---------------------------------------
--       Filtered Shop Entries       --
---------------------------------------

ShopEntry:AddPropertyToList("sellerOnly", egmt("shopEntry.sellerOnly_name"), egmt("shopEntry.sellerOnly_description"), "boolean", nil, nil, 1, egmt("inventory_shop.seller"))

ShopEntry:AddPropertyToList("sellerPrice", egmt("shopEntry.sellerPrice_name"), egmt("shopEntry.sellerPrice_description"), "number", nil, nil, 2, egmt("inventory_shop.seller"))

Rank:AddPropertyToList("seller", egmt("shopEntry.seller_name"), egmt("shopEntry.seller_description"), "boolean", nil, nil, 1, egmt("inventory_shop.seller"))

Rank:AddPropertyToList("shopEntries", egmt("shopEntry.shopEntries_name"), egmt("shopEntry.shopEntries_description"), "table", function(faction, rank)
	if not rank:IsSeller() then return {
		validValues = {},
		inheritedValues = {}
	} end

	local shopEntries = {}

	for _, shopEntry in pairs(ShopEntry:GetCache()) do
		if shopEntry:IsSellerOnly() then
			shopEntries[shopEntry:GetId()] = shopEntry:GetName()
		end
	end

	return {
		validValues = shopEntries,
		inheritedValues = {}
	}
end, nil, 2, egmt("inventory_shop.seller"))



---------------------------------------
--        Filtered Properties        --
---------------------------------------

-- List of properties that should always be shown.
ShopEntry.AlwaysShowProperties = { "category", "shopClass", "price", "maxStock", "stockRegen", "sellerOnly", "sellerPrice" }

-- Filter the property list dynamically, to only show properties that should be shown.
hook.Add("ShopEntry.GetPropertyList", "InventoryShop.FilterProperties", function(propertyList, shopEntry)
	local shopClass = shopEntry:GetShopClass()
	if not shopClass then return end

	for _, categoryData in pairs(propertyList) do
		local toBeDeleted = {}
		for _, property in pairs(categoryData) do
			local key = property.key

			-- Skip properties that should always be shown.
			if table.HasValue(ShopEntry.AlwaysShowProperties, key) then continue end

			-- Hook for adding properties that should be shown.
			if hook.Run("ShopEntry.ShouldShowProperty", shopEntry, key) then continue end

			-- Skip properties that should be shown by the item class.
			if shopClass:ShouldShowProperty(key) then continue end

			table.insert(toBeDeleted, property)
		end

		for _, property in pairs(toBeDeleted) do
			table.RemoveByValue(categoryData, property)
		end
	end

	local toBeDeleted = {}
	for _, categoryData in pairs(propertyList) do
		if #categoryData == 0 then
			table.insert(toBeDeleted, categoryData)
		end
	end

	for _, categoryData in pairs(toBeDeleted) do
		table.RemoveByValue(propertyList, categoryData)
	end
end)

-- Add the filtered properties to the property list.
ShopEntry:AddPropertyToList("itemType", egmt("shopEntry.itemType_name"), egmt("shopEntry.itemType_description"), "dropdown", function(shopEntry)
	local itemTypes = {}

	for id, itemType in pairs(ItemType:GetCache()) do
		local itemClass = itemType:GetItemClass()
		if not itemClass then continue end

		-- Skip money items.
		if itemClass.IsMoney then continue end

		table.insert(itemTypes, {
			text = itemType:GetName(),
			data = id,
		})
	end

	return itemTypes
end, nil, 1, egmt("inventory_shop.item"))

ShopEntry:AddPropertyToList("itemVariant", egmt("shopEntry.itemVariant_name"), egmt("shopEntry.itemVariant_description"), "dropdown", function(shopEntry)
	local itemType = shopEntry:GetItemType()
	if not itemType then return {} end

	local itemClass = itemType:GetItemClass()
	if not itemClass then return {} end

	local itemVariants = itemClass:GetVariants(itemType)

	local itemVariantsList = {}
	for variant, name in SortedPairs(itemVariants) do
		table.insert(itemVariantsList, {
			text = name,
			data = variant,
		})
	end

	table.insert(itemVariantsList, {
		text = egmt("inventory_shop.itemVariant_random"),
		data = "",
	})

	return itemVariantsList
end, nil, 2, egmt("inventory_shop.item"))
--gamemodes/egmrp/gamemode/modules/inventory_shop/cl_net.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--      Client | Inventory Shop      --
---------------------------------------

-- Open the storage box menu.
net.Receive("InventoryShop.OpenEntityMenu", function()
	local ent = net.ReadEntity()
	if not IsValid(ent) then return end
	if not ent.IsInventoryShop then return end

	local ply = LocalPlayer()
	if not IsValid(ply) then return end

	local char = ply:GetCurrentCharacter()
	if not char then return end

	InventoryShop:Open(char, ent)
end)

-- Receive the stock of the shop.
net.Receive("InventoryShop.Stock", function()
	local len = net.ReadInt(32)
	local compressedData = net.ReadData(len)

	local stockData = DecompressTable(compressedData)

	InventoryShop:ApplyShopPanel(stockData)
end)
--gamemodes/egmrp/gamemode/modules/inventory_shop/shop_classes/base/cl_init.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--         Client | Base Shop        --
---------------------------------------

local SHOP_CLASS = SHOP_CLASS

-- Display name for the shop used in UI elements.
SHOP_CLASS.Name = "Base Shop"

-- List of properties that should be shown in the manager, if this shop is used.
SHOP_CLASS.PropertyList = {}

-- Determine if a propertymodel property should be shown, if this item is used.
--
-- @param String propertyName
-- @return Boolean shouldShow
function SHOP_CLASS:ShouldShowProperty(propertyName)
	return table.HasValue(self.PropertyList, propertyName)
end

-- Create the shop panel for the shop.
--
-- @param Panel parent
-- @param ShopEntry shopEntry
function SHOP_CLASS:CreateShopPanel(parent, shopEntry)
	function parent:Paint(ww, hh)
		draw.SimpleText("[???]", "EGMText20", ww / 2, hh / 2, Color(255, 0, 0, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
	end
end
--gamemodes/starwarsrp/gamemode/modules/garage_shop/sh_garage_shop.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--        Shared | Garage Shop       --
---------------------------------------

-- Add shop entry property: vehicle
ShopEntry:AddProperty("vehicle", "string", "", function(shopEntry, value)
	if not isstring(value) then
		return false, egmt("shared.invalid_type")
	end

	return true
end,
function(shopEntry, ply)
	return true
end)

-- Get the vehicle class of the shop entry.
function ShopEntry.Meta:GetVehicleClass()
	return self:GetProperty("vehicle")
end

-- Only allow the owner of the vehicle, to store it in the garage.
hook.Add("Garage.CanStoreVehicle", "GarageShop.CanStoreVehicle", function(ply, vehicle)
	local vehicleOwner = vehicle:GetNWString("VehicleOwner", "")
	if vehicleOwner ~= ply:SteamID64() then
		return "Das ist nicht dein Fahrzeug!"
	end
end)
--gamemodes/starwarsrp/gamemode/modules/express/sh_index.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--          Express | Index          --
---------------------------------------

-- Check, if gm_express is loaded.
if not istable(express) then
	LogError("gm_express is not loaded! Please make sure, that the addon is installed correctly!")
end

Express = Express or {}

if SERVER then
	AddCSLuaFile("cl_express.lua")

	include("sv_express.lua")
end

if CLIENT then
	include("cl_express.lua")
end
--gamemodes/starwarsrp/gamemode/modules/express/cl_express.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--          Express | Client         --
---------------------------------------

-- Override the loading screen.
express.Receive("Loading.Express", function(packages)
	Loading:AppendLog(egmt("loading.package_group_list"), "green")
	Loading:AppendLog(egmt("loading.count", table.Count(packages)), "yellow")

	Loading.PackageTypeCounts = {}

	for typeName, packageData in pairs(packages) do
		local packageType = Loading.PackageTypes[typeName]

		Loading:AppendLog(egmt("loading.processing", packageType.Name))

		packageType.HandleData(packageData)

		Loading:AppendLog(egmt("loading.package_processed", packageType.Name))

		Loading:UpdateProgress()
	end

	Loading:AppendLog(egmt("loading.finished"), "green")

	Loading.CurrentPackageType = nil
	Loading.CurrentPackageIndex = nil
	Loading.CurrentPackage = nil

	Loading:UpdateProgress()

	net.Start("Loading.Finished")
	net.SendToServer()

	hook.Run("Loading.Finished")
end)

-- Override offline player loading.
express.Receive("PlayerManager.OfflinePlayers", function(netData)
	PlayerManager.LoadingPlayerData = false

	local pages = netData.Pages
	local playerDataList = netData.Data
	for k, data in pairs(playerDataList) do
		local playerData = PlayerData:Load(data.data, data.properties)
		local line = PlayerManager.List:AddCustomLine(playerData:GetName())
		line.playerData = playerData

		if not playerData:IsValid() then
			line:SetCustomTextColor(GetColor("red"))
		end
	end

	-- Automatically select the first item, if there is only one.
	if #PlayerManager.List:GetLines() == 1 then
		PlayerManager.List:SelectFirstItem()
	end

	PlayerManager.PageSelection:SetPageCount(pages)
end)

-- Override offline character loading.
express.Receive("CharacterManager.OfflineCharacters", function(netData)
	if not IsValid(CharacterManager.Frame) then return end

	CharacterManager.Loading = false

	local pages = netData.Pages
	local characterData = netData.Data
	for k, data in pairs(characterData) do
		local character = Character:Load(data.data, data.properties)

		local prefix = ""
		local authorityLevel = 0

		local rank = character:GetRank()
		if rank then
			prefix = rank:GetProperty("prefix", "") .. " "
			authorityLevel = rank:GetAuthorityLevel()
		end

		local name = prefix .. character:GetName()

		local line = CharacterManager.CharacterList:AddSortedLine(name, authorityLevel)
		line.character = character

		if character:GetFaction() ~= CharacterManager.SelectedFaction then
			line:SetCustomTextColor(GetColor("green"))
		end
		if not character:IsValid() then
			line:SetCustomTextColor(GetColor("red"))
		end
	end

	-- Sort characters by permission level.
	CharacterManager.CharacterList:SortByColumns(1, false)

	-- Automatically select the first item, if there is only one.
		if #CharacterManager.CharacterList:GetLines() == 1 then
		CharacterManager.CharacterList:SelectFirstItem()
	end

	CharacterManager.PageSelection:SetPageCount(pages)
end)

-- Override loading logs.
express.Receive("EventLog.Logs", function(netData)
	EventLog.LoadingLogs = false

	local logs = netData.Logs
	local count = netData.Count

	-- Fill logs
	for k, entry in pairs(logs) do
		EventLog.LogList:AddSortedLine(entry.text, nil, os.date(egmt("shared.date_time"), entry.created), entry.created)
	end

	-- Sort the list by the created time (descending).
	EventLog.LogList:SortByColumns(2, true)

	-- Set the page count.
	EventLog.PageSelection:SetPageCount(math.ceil(count / EventLog.PageSize))
end)
--gamemodes/starwarsrp/gamemode/modules/stnotes/sh_index.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--    on official 'Einfach Gaming'   --
--     servers owned by 'P4sca1'     --
--                                   --
-- Copyright © 2020 Pascal Sthamer,  --
--      Konstantin Zisiadis und      --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--           STNotes index           --
---------------------------------------

-- Load required modules.
if not RequireModules({"player", "character", "sql"}) then
	return false
end

STNotes = STNotes or {}

if SERVER then
	AddCSLuaFile("sh_config.lua")
	AddCSLuaFile("sh_stnotes.lua")
	AddCSLuaFile("cl_stnotes.lua")

	include("sh_config.lua")
	include("sh_stnotes.lua")
	include("sv_stnotes.lua")

end

if CLIENT then
	include("sh_config.lua")
	include("sh_stnotes.lua")
	include("cl_stnotes.lua")
end
--gamemodes/starwarsrp/gamemode/modules/stnotes/cl_stnotes.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--    on official 'Einfach Gaming'   --
--     servers owned by 'P4sca1'     --
--                                   --
-- Copyright © 2020 Pascal Sthamer,  --
--      Konstantin Zisiadis und      --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--         Client | STNotes          --
---------------------------------------

Character:AddPropertyToList("jailtime", "Strafminuten", "Die Zeit die der Charakter im Gefängnis verbracht hat.", "number")

-- Opens the ST Notes
function STNotes:Open()
	if not hook.Run("STNotes.CanUse", LocalPlayer()) then
		chat.AddText(
			GetColor("red"),
			"[ST Notes] ",
			GetColor("white"),
			"Du hast keinen Zugang zu den ST Notes!"
		)

		return
	end

	self:Close()

	self.Frame = vgui.Create("EGMFrame")
	self.Frame:SetBackground(self.Background)
	self.Frame:SetSubTitle("ST Notes")
	function self.Frame:OnClose()
		-- Clear runtime variables.
		STNotes.CurrentCharacter = nil
		STNotes.CurrentEntry = nil
		STNotes.LoadingPrisoners = nil
		STNotes.LoadingArchive = nil
	end

	self.PropertySheet = vgui.Create("EGMPropertySheet", self.Frame)
	self.PropertySheet:SetPos(ScrW() * 0.1, ScrH() * 0.25)
	self.PropertySheet:SetSize(ScrW() * 0.8, ScrH() * 0.7)

	-- Character panel.
	self.CharacterPanel = vgui.Create("DPanel", self.PropertySheet)
	self.CharacterPanel:Dock(FILL)
	function self.CharacterPanel:Paint(width, height)
		draw.RoundedBox(5, 0, 0, width, height, GetColor("darkgray"))
	end

	self.CharacterListPanel = vgui.Create("DPanel", self.CharacterPanel)
	self.CharacterListPanel:SetWide(ScrW() * 0.3)
	self.CharacterListPanel:DockMargin(ScrW() * 0.01, ScrH() * 0.01, ScrW() * 0.01, ScrH() * 0.01)
	self.CharacterListPanel:Dock(LEFT)

	self.CharacterList = vgui.Create("EGMListView", self.CharacterListPanel)
	self.CharacterList:SetHeaderHeight(ScrH() * 0.04)
	self.CharacterList:SetDataHeight(ScrH() * 0.03)
	self.CharacterList:Dock(FILL)
	self.CharacterList:SetMultiSelect(false)
	self.CharacterList:SetBackgroundColor(GetColor("gray"))
	self.CharacterList:AddCustomColumn("Name")
	self.CharacterList:AddCustomColumn("Fraktion")
	self.CharacterList:AddCustomColumn("Rang")
	function self.CharacterList:OnRowSelected(index, line)
		surface.PlaySound(UI.ButtonSound)

		local character = line.character
		STNotes.CurrentCharacter = character

		STNotes.CharacterInfo:SetText("")

		STNotes.CharacterInfo:InsertColorChange(GetColor2("blue"))
		STNotes.CharacterInfo:AppendText("Name:\n")
		STNotes.CharacterInfo:InsertColorChange(GetColor2("white"))
		STNotes.CharacterInfo:AppendText(character:GetFullName() .. "\n\n")

		if Config.Modules["cloneid"] and character:GetCloneId() then
			STNotes.CharacterInfo:InsertColorChange(GetColor2("blue"))
			STNotes.CharacterInfo:AppendText("ID:\n")
			STNotes.CharacterInfo:InsertColorChange(GetColor2("white"))
			STNotes.CharacterInfo:AppendText(character:GetCloneId() .. "\n\n")
		end

		STNotes.CharacterInfo:InsertColorChange(GetColor2("blue"))
		STNotes.CharacterInfo:AppendText("Fraktion:\n")
		STNotes.CharacterInfo:InsertColorChange(GetColor2("white"))
		STNotes.CharacterInfo:AppendText(character:GetFactionName() .. "\n\n")

		STNotes.CharacterInfo:InsertColorChange(GetColor2("blue"))
		STNotes.CharacterInfo:AppendText("Rang:\n")
		STNotes.CharacterInfo:InsertColorChange(GetColor2("white"))
		STNotes.CharacterInfo:AppendText(character:GetRankName() .. "\n\n")

		STNotes.CharacterInfo:InsertColorChange(GetColor2("blue"))
		STNotes.CharacterInfo:AppendText("Strafminuten:\n")
		STNotes.CharacterInfo:InsertColorChange(GetColor2("white"))
		STNotes.CharacterInfo:AppendText(character:GetProperty("jailtime", 0))

		STNotes.CharacterInfoPanel:SetVisible(true)
	end
	function self.CharacterList:Refresh()
		self:Clear()

		local filter = STNotes.CharacterFilter:GetValue()

		for k, ply in pairs(player.GetHumans()) do
			local character = ply:GetCurrentCharacter()

			if character then
				local rank = character:GetRank()
				local faction = character:GetFaction()

				if rank and faction then
					local name = character:GetName()
					local rankName = rank:GetName()
					local factionName = faction:GetName()

					if not filter or filter == "" or string.find(name, filter) or string.find(rankName, filter) or string.find(factionName, filter) then
						local line = self:AddCustomLine(name, factionName, rankName)
						line.character = character
					end
				end

			end
		end
	end

	self.CharacterFilter = vgui.Create("DTextEntry", self.CharacterListPanel)
	self.CharacterFilter:SetHeight(ScrH() * 0.03)
	self.CharacterFilter:Dock(BOTTOM)
	self.CharacterFilter:SetPlaceholderText("Suchen...")
	self.CharacterFilter:SetUpdateOnType(false)
	function self.CharacterFilter:OnValueChange(filter)
		STNotes.CharacterList:Refresh()
	end

	self.CharacterInfoPanel = vgui.Create("DPanel", self.CharacterPanel)
	self.CharacterInfoPanel:DockMargin(0, ScrH() * 0.01, ScrW() * 0.01, ScrH() * 0.01)
	self.CharacterInfoPanel:Dock(FILL)
	self.CharacterInfoPanel:SetVisible(false)
	function self.CharacterInfoPanel:Paint() end

	self.CharacterInfo = vgui.Create("RichText", self.CharacterInfoPanel)
	self.CharacterInfo:SetHeight(ScrH() * 0.45)
	self.CharacterInfo:Dock(TOP)
	function self.CharacterInfo:PerformLayout()
		self:SetFontInternal("EGMText10")
	end

	self.CharacterInputPanel = vgui.Create("DPanel", self.CharacterInfoPanel)
	self.CharacterInputPanel:Dock(FILL)
	function self.CharacterInputPanel:Paint(width, height)
		draw.RoundedBox(5, 0, 0, width, height, GetColor("gray"))
	end

	self.CharacterEntryDuration = vgui.Create("DComboBox", self.CharacterInputPanel)
	self.CharacterEntryDuration:SetPos(ScrW() * 0.01, ScrH() * 0.01)
	self.CharacterEntryDuration:SetSize(ScrW() * 0.22, ScrH() * 0.05)
	self.CharacterEntryDuration:AddChoice("Verwarnung", 0)
	self.CharacterEntryDuration:AddChoice("5 Minuten", 5)
	self.CharacterEntryDuration:AddChoice("10 Minuten", 10)
	self.CharacterEntryDuration:AddChoice("15 Minuten", 15)
	self.CharacterEntryDuration:AddChoice("20 Minuten", 20)
	self.CharacterEntryDuration:AddChoice("25 Minuten", 25)
	self.CharacterEntryDuration:AddChoice("30 Minuten", 30)
	self.CharacterEntryDuration:SetSortItems(false)
	self.CharacterEntryDuration:ChooseOptionID(1)
	self.CharacterEntryDuration:SetFont("EGMText8")
	self.CharacterEntryDuration:SetTextColor(GetColor("black"))

	self.CharacterSaveButton = vgui.Create("EGMButton", self.CharacterInputPanel)
	self.CharacterSaveButton:SetPos(ScrW() * 0.2425, ScrH() * 0.01)
	self.CharacterSaveButton:SetSize(ScrW() * 0.22, ScrH() * 0.05)
	self.CharacterSaveButton:SetFont("EGMText10")
	self.CharacterSaveButton:SetTextColor(GetColor("darkgray"))
	self.CharacterSaveButton:SetText("Speichern")
	function self.CharacterSaveButton:DoClick()
		surface.PlaySound(UI.ButtonSound)

		local _, delay = STNotes.CharacterEntryDuration:GetSelected()

		net.Start("STNotes.AddEntry")
			net.WriteInt(STNotes.CurrentCharacter:GetId(), 32)
			net.WriteInt(delay, 32)
			net.WriteString(STNotes.TextEntry:GetText())
		net.SendToServer()
	end

	self.TextEntry = vgui.Create("DTextEntry", self.CharacterInputPanel)
	self.TextEntry:SetPos(ScrW() * 0.01, ScrH() * 0.07)
	self.TextEntry:SetSize(ScrW() * 0.45, ScrH() * 0.1)
	self.TextEntry:SetFont("EGMText10")
	self.TextEntry:SetTextColor(GetColor("darkgray"))
	self.TextEntry:SetPlaceholderText("Beschreibung")
	self.TextEntry:SetMultiline(true)

	self.CharacterList:Refresh()
	self.PropertySheet:AddSheet("Charaktere", self.CharacterPanel)

	-- Prisoner panel.
	self.PrisonerPanel = vgui.Create("DPanel", self.PropertySheet)
	self.PrisonerPanel:Dock(FILL)
	function self.PrisonerPanel:Paint(width, height)
		draw.RoundedBox(5, 0, 0, width, height, GetColor("darkgray"))
	end

	self.PrisonerListPanel = vgui.Create("DPanel", self.PrisonerPanel)
	self.PrisonerListPanel:SetWide(ScrW() * 0.4)
	self.PrisonerListPanel:DockMargin(ScrW() * 0.01, ScrH() * 0.01, ScrW() * 0.01, ScrH() * 0.01)
	self.PrisonerListPanel:Dock(LEFT)

	self.PrisonerList = vgui.Create("EGMListView", self.PrisonerListPanel)
	self.PrisonerList:SetHeaderHeight(ScrH() * 0.04)
	self.PrisonerList:SetDataHeight(ScrH() * 0.03)
	self.PrisonerList:Dock(FILL)
	self.PrisonerList:SetMultiSelect(false)
	self.PrisonerList:SetBackgroundColor(GetColor("gray"))
	self.PrisonerList:AddCustomColumn("Gefangener")
	self.PrisonerList:AddCustomColumn("Vollstrecker")
	self.PrisonerList:AddCustomColumn("Freilasstermin"):SetFixedWidth(ScrW() * 0.085)
	function self.PrisonerList:OnRowSelected(index, line)
		surface.PlaySound(UI.ButtonSound)

		local entry = line.entry
		STNotes.CurrentEntry = entry

		STNotes.PrisonerInfo:SetText("")

		STNotes.PrisonerInfo:InsertColorChange(GetColor2("blue"))
		STNotes.PrisonerInfo:AppendText("Gefangener:\n")
		STNotes.PrisonerInfo:InsertColorChange(GetColor2("white"))
		STNotes.PrisonerInfo:AppendText(entry.target_name .. "\n\n")

		STNotes.PrisonerInfo:InsertColorChange(GetColor2("blue"))
		STNotes.PrisonerInfo:AppendText("Vollstrecker:\n")
		STNotes.PrisonerInfo:InsertColorChange(GetColor2("white"))
		STNotes.PrisonerInfo:AppendText(entry.enforcer_name .. "\n\n")

		STNotes.PrisonerInfo:InsertColorChange(GetColor2("blue"))
		STNotes.PrisonerInfo:AppendText("Erstellt:\n")
		STNotes.PrisonerInfo:InsertColorChange(GetColor2("white"))
		STNotes.PrisonerInfo:AppendText(os.date("%d.%m.%Y - %H:%M:%S", entry.created) .. "\n\n")

		STNotes.PrisonerInfo:InsertColorChange(GetColor2("blue"))
		STNotes.PrisonerInfo:AppendText("Strafminuten:\n")
		STNotes.PrisonerInfo:InsertColorChange(GetColor2("white"))
		STNotes.PrisonerInfo:AppendText(entry.time / 60 .. "\n\n")

		STNotes.PrisonerInfo:InsertColorChange(GetColor2("blue"))
		STNotes.PrisonerInfo:AppendText("Beschreibung:\n")
		STNotes.PrisonerInfo:InsertColorChange(GetColor2("white"))
		STNotes.PrisonerInfo:AppendText(entry.text)

		STNotes.PrisonerInfoPanel:SetVisible(true)
	end
	function self.PrisonerList:Refresh()
		self:Clear()

		if STNotes.Prisoners then
			local filter = STNotes.PrisonerFilter:GetValue()

			for k, entry in pairs(STNotes.Prisoners) do
				if not filter or filter == "" or string.find(entry.target_name, filter) or string.find(entry.enforcer_name, filter) or string.find(entry.text, filter) then
					local line = self:AddCustomLine(entry.target_name, entry.enforcer_name, os.date("%d.%m.%Y - %H:%M:%S", entry.created + entry.time))
					line.entry = entry
				end
			end
		end
	end

	self.PrisonerListLoadingHint = vgui.Create("DLabel", self.PrisonerList)
	self.PrisonerListLoadingHint:Dock(FILL)
	self.PrisonerListLoadingHint:SetText("")
	function self.PrisonerListLoadingHint:Paint(width, height)
		if STNotes.LoadingPrisoners then
			draw.SimpleText("Gefangene werden geladen...", "EGMText12", width / 2, height / 2, GetColor("white"), TEXT_ALIGN_CENTER)
		elseif #STNotes.PrisonerList:GetLines() == 0 then
			draw.SimpleText("Keine Gefangenen", "EGMText12", width / 2, height / 2, GetColor("white"), TEXT_ALIGN_CENTER)
		end
	end

	self.PrisonerFilter = vgui.Create("DTextEntry", self.PrisonerListPanel)
	self.PrisonerFilter:SetHeight(ScrH() * 0.03)
	self.PrisonerFilter:Dock(BOTTOM)
	self.PrisonerFilter:SetPlaceholderText("Suchen...")
	self.PrisonerFilter:SetUpdateOnType(false)
	function self.PrisonerFilter:OnValueChange(filter)
		STNotes.PrisonerList:Refresh()
	end

	self.PrisonerInfoPanel = vgui.Create("DPanel", self.PrisonerPanel)
	self.PrisonerInfoPanel:DockMargin(0, ScrH() * 0.01, ScrW() * 0.01, ScrH() * 0.01)
	self.PrisonerInfoPanel:Dock(FILL)
	self.PrisonerInfoPanel:SetVisible(false)
	function self.PrisonerInfoPanel:Paint(width, height) end

	self.PrisonerInfo = vgui.Create("RichText", self.PrisonerInfoPanel)
	self.PrisonerInfo:Dock(FILL)
	function self.PrisonerInfo:PerformLayout()
		self:SetFontInternal("EGMText10")
	end

	self.PrisonerReleaseButton = vgui.Create("EGMButton", self.PrisonerInfoPanel)
	self.PrisonerReleaseButton:Dock(BOTTOM)
	self.PrisonerReleaseButton:SetText("Gefangenen freilassen")
	self.PrisonerReleaseButton:SetHeight(ScrH() * 0.05)
	self.PrisonerReleaseButton:SetFont("EGMText10")
	self.PrisonerReleaseButton:SetTextColor(GetColor("darkgray"))
	function self.PrisonerReleaseButton:DoClick()
		surface.PlaySound(UI.ButtonSound)

		STNotes.Prisoners[STNotes.CurrentEntry.id] = nil
		STNotes.PrisonerList:Refresh()

		net.Start("STNotes.ReleasePrisoner")
			net.WriteInt(STNotes.CurrentEntry.id, 32)
		net.SendToServer()

		STNotes.PrisonerInfoPanel:SetVisible(false)
		STNotes.CurrentEntry = nil
	end

	self.PrisonerAddTimeButton = vgui.Create("EGMButton", self.PrisonerInfoPanel)
	self.PrisonerAddTimeButton:Dock(BOTTOM)
	self.PrisonerAddTimeButton:SetText("Strafzeit verlängern")
	self.PrisonerAddTimeButton:SetHeight(ScrH() * 0.05)
	self.PrisonerAddTimeButton:SetFont("EGMText10")
	self.PrisonerAddTimeButton:SetTextColor(GetColor("darkgray"))
	self.PrisonerAddTimeButton:DockMargin(0, 0, 0, 8)
	function self.PrisonerAddTimeButton:DoClick()
		surface.PlaySound(UI.ButtonSound)

		local modal = vgui.Create("EGMModal")
		modal:SetCustomTitle("Strafzeit verlängern")

		local options = {
			{text = "5 Minuten", data = 5},
			{text = "10 Minuten", data = 10},
			{text = "15 Minuten", data = 15},
			{text = "20 Minuten", data = 20},
			{text = "25 Minuten", data = 25},
			{text = "30 Minuten", data = 30},
		}

		modal:Selection(nil, "Zusätzliche Strafminuten auswählen", options, function(time)
			net.Start("STNotes.AddTime")
				net.WriteInt(STNotes.CurrentEntry.id, 32)
				net.WriteInt(time, 32)
			net.SendToServer()
		end, nil, "Strafminuten hinzufügen")
	end

	self.PropertySheet:AddSheet("Gefangene", self.PrisonerPanel)
	function self.PrisonerPanel:OnSheetSelected()
		STNotes:LoadPrisoners()
	end

	-- Archive panel.
	self.ArchivePanel = vgui.Create("DPanel", self.PropertySheet)
	self.ArchivePanel:Dock(FILL)
	function self.ArchivePanel:Paint(width, height)
		draw.RoundedBox(5, 0, 0, width, height, GetColor("darkgray"))
	end

	self.ArchiveListPanel = vgui.Create("DPanel", self.ArchivePanel)
	self.ArchiveListPanel:SetWide(ScrW() * 0.4)
	self.ArchiveListPanel:DockMargin(ScrW() * 0.01, ScrH() * 0.01, ScrW() * 0.01, ScrH() * 0.01)
	self.ArchiveListPanel:Dock(LEFT)

	self.ArchiveList = vgui.Create("EGMListView", self.ArchiveListPanel)
	self.ArchiveList:SetHeaderHeight(ScrH() * 0.04)
	self.ArchiveList:SetDataHeight(ScrH() * 0.03)
	self.ArchiveList:Dock(FILL)
	self.ArchiveList:SetMultiSelect(false)
	self.ArchiveList:SetBackgroundColor(GetColor("gray"))
	self.ArchiveList:AddCustomColumn("Gefangener")
	self.ArchiveList:AddCustomColumn("Vollstrecker")
	self.ArchiveList:AddCustomColumn("Freilasstermin"):SetFixedWidth(ScrW() * 0.085)
	function self.ArchiveList:OnRowSelected(index, line)
		surface.PlaySound(UI.ButtonSound)

		local entry = line.entry

		STNotes.ArchiveInfo:SetText("")

		STNotes.ArchiveInfo:InsertColorChange(GetColor2("blue"))
		STNotes.ArchiveInfo:AppendText("Gefangener:\n")
		STNotes.ArchiveInfo:InsertColorChange(GetColor2("white"))
		STNotes.ArchiveInfo:AppendText(entry.target_name .. "\n\n")

		STNotes.ArchiveInfo:InsertColorChange(GetColor2("blue"))
		STNotes.ArchiveInfo:AppendText("Vollstrecker:\n")
		STNotes.ArchiveInfo:InsertColorChange(GetColor2("white"))
		STNotes.ArchiveInfo:AppendText(entry.enforcer_name .. "\n\n")

		STNotes.ArchiveInfo:InsertColorChange(GetColor2("blue"))
		STNotes.ArchiveInfo:AppendText("Erstellt:\n")
		STNotes.ArchiveInfo:InsertColorChange(GetColor2("white"))
		STNotes.ArchiveInfo:AppendText(os.date("%d.%m.%Y - %H:%M:%S", entry.created) .. "\n\n")

		STNotes.ArchiveInfo:InsertColorChange(GetColor2("blue"))
		if entry.time == 0 then
			STNotes.ArchiveInfo:AppendText("Verwarnung\n\n")
		else
			STNotes.ArchiveInfo:AppendText("Strafminuten:\n")
			STNotes.ArchiveInfo:InsertColorChange(GetColor2("white"))
			STNotes.ArchiveInfo:AppendText(entry.time / 60 .. "\n\n")
		end

		STNotes.ArchiveInfo:InsertColorChange(GetColor2("blue"))
		STNotes.ArchiveInfo:AppendText("Beschreibung:\n")
		STNotes.ArchiveInfo:InsertColorChange(GetColor2("white"))
		STNotes.ArchiveInfo:AppendText(entry.text)

		STNotes.ArchiveInfo:SetVisible(true)
	end

	self.ArchiveListLoadingHint = vgui.Create("DLabel", self.ArchiveList)
	self.ArchiveListLoadingHint:Dock(FILL)
	self.ArchiveListLoadingHint:SetText("")
	function self.ArchiveListLoadingHint:Paint(width, height)
		if STNotes.LoadingArchive then
			draw.SimpleText("Archiv wird geladen...", "EGMText12", width / 2, height / 2, GetColor("white"), TEXT_ALIGN_CENTER)
		elseif #STNotes.ArchiveList:GetLines() == 0 then
			draw.SimpleText("Keine Daten", "EGMText12", width / 2, height / 2, GetColor("white"), TEXT_ALIGN_CENTER)
		end
	end

	self.ArchiveFilter = vgui.Create("DTextEntry", self.ArchiveListPanel)
	self.ArchiveFilter:SetHeight(ScrH() * 0.03)
	self.ArchiveFilter:Dock(BOTTOM)
	self.ArchiveFilter:SetPlaceholderText("Suchen...")
	self.ArchiveFilter:SetUpdateOnType(false)
	function self.ArchiveFilter:OnValueChange(filter)
		STNotes:LoadArchive()
	end

	self.ArchivePageSelection = vgui.Create("EGMPageSelector", self.ArchiveListPanel)
	self.ArchivePageSelection:SetHeight(ScrH() * 0.025)
	self.ArchivePageSelection:Dock(BOTTOM)
	self.ArchivePageSelection:SetPage(1)
	self.ArchivePageSelection:SetPageCount(1)
	self.ArchivePageSelection:SetCallback(function(page)
		STNotes:LoadArchive()
	end)

	self.ArchiveInfo = vgui.Create("RichText", self.ArchivePanel)
	self.ArchiveInfo:DockMargin(0, ScrH() * 0.01, ScrW() * 0.01, ScrH() * 0.01)
	self.ArchiveInfo:Dock(FILL)
	self.ArchiveInfo:SetVisible(false)
	function self.ArchiveInfo:PerformLayout()
		self:SetFontInternal("EGMText10")
	end

	self.PropertySheet:AddSheet("Archiv", self.ArchivePanel)
	function self.ArchivePanel:OnSheetSelected()
		STNotes:LoadArchive()
	end

	self.Frame:MakePopup()
end

hook.Add("CharcterManager.ShowCharacter", "STNotes.AddDisplay", function(self, character, faction, rank)
	self.CharacterInfoPanel:InsertColorChange(GetColor2("blue"))
	self.CharacterInfoPanel:AppendText(egmt("character.jailtime"))
	self.CharacterInfoPanel:InsertColorChange(GetColor2("white"))
	self.CharacterInfoPanel:AppendText(character:GetProperty("jailtime", 0))
end)

-- Requests the prisoners from the server.
function STNotes:LoadPrisoners()
	if self.LoadingPrisoners then return end

	self.PrisonerList:Clear()
	self.LoadingPrisoners = true

	net.Start("STNotes.Prisoners")
	net.SendToServer()
end

net.Receive("STNotes.Prisoners", function()
	if not IsValid(STNotes.Frame) then return end

	STNotes.LoadingPrisoners = false

	local length = net.ReadInt(32)
	local prisoners = DecompressTable(net.ReadData(length))

	STNotes.Prisoners = prisoners
	STNotes.PrisonerList:Refresh()

	-- Restore old entry, if it still exists.
	local currentEntry = STNotes.CurrentEntry
	if currentEntry then
		for k, line in pairs(STNotes.PrisonerList:GetLines()) do
			if line.entry.id == currentEntry.id then
				STNotes.PrisonerList:SelectItem(line)
			end
		end
	end
end)

-- Requests the prisoner archive from the server.
function STNotes:LoadArchive()
	if self.LoadingArchive then return end

	self.ArchiveList:Clear()
	self.LoadingArchive = true
	self.ArchiveInfo:SetVisible(false)

	net.Start("STNotes.Archive")
		net.WriteString(self.ArchiveFilter:GetValue())
		net.WriteInt(self.ArchivePageSelection:GetPage(), 32)
	net.SendToServer()
end

net.Receive("STNotes.Archive", function()
	if not IsValid(STNotes.Frame) then return end

	STNotes.LoadingArchive = false

	local length = net.ReadInt(32)
	local archive = DecompressTable(net.ReadData(length))
	local pages = net.ReadInt(32)

	STNotes.ArchivePageSelection:SetPageCount(pages)

	STNotes.ArchiveList:Clear()
	for k, entry in pairs(archive) do
		local line = STNotes.ArchiveList:AddCustomLine(entry.target_name, entry.enforcer_name, os.date("%d.%m.%Y - %H:%M:%S", entry.created + entry.time))
		line.entry = entry
	 end
end)

-- Closes the ST Notes.
function STNotes:Close()
	if IsValid(self.Frame) then
		self.Frame:Close()
	end
end
--gamemodes/starwarsrp/gamemode/modules/shiputil/cl_keybinds.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--    on official 'Einfach Gaming'   --
--     servers owned by 'P4sca1'     --
--                                   --
-- Copyright © 2020 Pascal Sthamer,  --
--      Konstantin Zisiadis und      --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--   Client | MultiServer Keybinds   --
---------------------------------------

-- Register a keybind for changing the talking radius.
if Config.Modules["multiserver"] then
	KeyBind:Register("Server wechseln (Fahrzeuge)", "Normal", function()
		local veh = LocalPlayer():GetVehicle()
		if IsValid(veh) and IsValid(veh:GetParent()) then
			local lfsVeh = veh:GetParent()
			if not (lfsVeh.LVS and lfsVeh:GetDriver() == LocalPlayer()) then return end

			ShipUtil:OpenVehicleChangeServerMenu(true)
		end
	end, KEY_K)
end
--gamemodes/egmrp/gamemode/modules/cloneid/cl_cloneid.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--          Client | CloneId         --
---------------------------------------

Rank:AddPropertyToList("cloneIdEnabled", egmt("cloneid.cloneid_enabled"), egmt("cloneid.cloneid_enabled_description"), "boolean", nil, nil, 10, nil)



---------------------------------------
--   Special Character Integration   --
---------------------------------------

if Config.Modules["special_character"] then
	SpecialCharacter:AddPropertyToList("customCloneId", egmt("cloneid.custom"), egmt("cloneid.custom_description"), "string", nil, nil, 10, nil)
end
--gamemodes/starwarsrp/gamemode/modules/cloakdisguise/weapons/weapon_swrp_cloakingdevice/shared.lua:
---------------------------------------
---------------------------------------
--           Cloakdisguise           --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--           SH | Cloaking           --
---------------------------------------

if CLIENT then
	SWEP.WepSelectIcon = surface.GetTextureID("camo/camo_wepselecticon.vmt")
end

SWEP.Base 					= "weapon_base"

SWEP.Author					= "Deltaa"
SWEP.Instructions 			= "Linksklick: Aktiviere/Deaktiviere das Tarngerät \nRechtsklick: Nutze die Magnetplatten"

SWEP.Category 				= "SW:RP (Sonstiges)"

SWEP.Spawnable				= false
SWEP.AdminSpawnable 		= true

SWEP.HoldType 				= "normal"
SWEP.UseHands 				= false


SWEP.Primary.ClipSize 		= -1
SWEP.Primary.DefaultClip 	= -1
SWEP.Primary.Ammo 			= "none"
SWEP.DrawAmmo 				= false
SWEP.Slot = 3

function SWEP:Initialize()
	self:SetHoldType(self.HoldType)
end

function SWEP:CanPrimaryAttack()
	-- Don't allow the player to cloak while disguised
	-- if self:GetOwner():IsDisguised() then return false end

	local configData = Cloaking.Types[self.Id]
	if configData.whitelist and not configData.whitelist[self:GetOwner():GetModel()] then
		return false
	end

	return true
end

function SWEP:CanSecondaryAttack()
	-- Don't allow the player to use the magnet while cloaked
	if self:GetOwner():IsCloaked() then return false end

	--[[

	local configData = Cloaking.Types[self.Id]
	if not self:GetOwner():IsDisguised() and configData.whitelist and not configData.whitelist[self:GetOwner():GetModel()] then
		return false
	elseif configData.disguiser then
		return true
	end

	]]

	return false
end

function SWEP:Deploy()
	self:SetNextPrimaryFire(CurTime() + 2)
	self:GetOwner():DrawViewModel(false)
end

function SWEP:DrawWorldModel()
	return false
end

function SWEP:Reload()
	return
end
--gamemodes/starwarsrp/gamemode/modules/nextbotspawner/entities/npc_swrp_b3_ubg/shared.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--				(CW:RP)		 	 	 --
--                                   --
--           NextBot Spawner         --
--                                   --
--            Created by             --
--				Oninoni				 --
---------------------------------------
---------------------------------------

ENT.Base 			= "npc_swrp_nextbot_base"

ENT.PrintName = "B3 Ultra Battle Droid"
ENT.Author = "Oninoni"
ENT.Information = ""
ENT.Category = "EGM:RP"

ENT.Spawnable		= true
ENT.AdminOnly		= false

-- Default model the npc uses.
ENT.DefaultModel = "models/player/hydro/b2_battledroid/b2_battledroid.mdl"

-- Default weapon the npc uses.
ENT.DefaultWeapon = "weapon_vfirethrower"

-- How much Health the NPC should have.
ENT.MaxHealth = 1000000

-- Speed value of the character. Scales running aswell.
ENT.WalkSpeed = 100

ENT.AttackRange = 500

ENT.AnimIdle = ACT_HL2MP_IDLE
ENT.AnimWalk = ACT_HL2MP_WALK
ENT.AnimIdleAim = ACT_HL2MP_IDLE_PISTOL
ENT.AnimWalkAim = ACT_HL2MP_RUN_PISTOL

-- Missiles Setup
ENT.MissileDelay = 10
ENT.MissileBurst = 10

-- Blaster Setup
ENT.BlasterTargetingDelay = 2
ENT.BlasterDelay = 0.2
ENT.MaxBlasterTarget = 2

function ENT:Initialize()
	local baseTable = scripted_ents.GetStored("npc_swrp_nextbot_base").t
	baseTable.Initialize(self)

	if SERVER then
		self:SetModelScale(3)
		self:PhysicsInit(self:GetSolid())

		local weapon = self:GetActiveWeapon()
		weapon:SetRenderMode(RENDERMODE_TRANSALPHA)
		weapon:SetColor(Color(0, 0, 0, 0))
		weapon.Primary.Range = 500

		self.NextMissile = CurTime() + self.MissileDelay
		self.NextBlasterTarget = CurTime()
		self.NextBlaster = CurTime() + self.BlasterDelay
	end
end
--gamemodes/starwarsrp/gamemode/modules/nextbotspawner/weapons/weapon_npc_crab.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--				(CW:RP)		 	 	 --
--                                   --
--           NextBot Spawner         --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

AddCSLuaFile()

SWEP.Base   = "weapon_npcbase"

SWEP.PrintName = "NPC: Crap-Droid"
SWEP.Spawnable = false
SWEP.Author = "Deltaa"

SWEP.WorldModel = false
SWEP.Weight = 3

SWEP.NextShoot = 0.5
SWEP.Sound = "w/dp23.wav"
SWEP.ClipSize = 40
SWEP.Damage = 25
SWEP.NumOfShots = 2

function SWEP:Reload()
	self:SetClip1(self.ClipSize or 40)

	self:EmitSound(self.ReloadSound or "w/heavy.wav")

	self:SetNextPrimaryFire(CurTime() + 3)
	self:SetNextSecondaryFire(CurTime() + 3)
end

--gamemodes/starwarsrp/gamemode/modules/nextbotspawner/weapons/weapon_npc_notarget.lua:
SWEP.Author					= "Mattzi, Deltaa & tschubaki"
SWEP.Purpose				= "No Target for hostile NPCs."
SWEP.Instructions 			= "Click to turn on/off, click Reload to see status."
SWEP.Category 				= "SW:RP (Sonstiges)"

SWEP.PrintName				= "No Target SWEP"
SWEP.Slot					= 5
SWEP.SlotPos				= 1
SWEP.DrawAmmo				= false

SWEP.Spawnable				= true
SWEP.AdminOnly 				= false

SWEP.DefaultHoldType 		= "normal"

SWEP.ViewModel 				= "models/weapons/v_357.mdl"
SWEP.WorldModel 			= "models/weapons/w_357.mdl"

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= -1
SWEP.Primary.Automatic		= false
SWEP.Primary.Ammo			= "none"

SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Automatic	= false
SWEP.Secondary.Ammo			= "none"

SWEP.Weight					= 0
SWEP.AutoSwitchTo			= false
SWEP.AutoSwitchFrom			= false

function SWEP:DrawWorldModel()
end

function SWEP:PreDrawViewModel()
	render.SetBlend(0)
end

function SWEP:PostDrawViewModel()
	render.SetBlend(1)
end

function SWEP:Initialize()
	self:SetHoldType(self.DefaultHoldType)
end

if CLIENT then
	function SWEP:PrimaryAttack()
		return
	end

	function SWEP:SecondaryAttack()
		return
	end
end

if SERVER then
	function SWEP:SwitchTarget(ply)
		ply.NoTarget = !ply.NoTarget

		if ply.NoTarget then
			for k, ent in pairs(ents.GetAll()) do
				if isfunction(ent.AddEntityRelationship) then
					ent:AddEntityRelationship(ply, D_NU, 99)
				end
			end

			Notify:Success(ply, "Aktiviert", "Du wirst von keinen NPCs mehr angegriffen!")
		else
			for k, ent in pairs(ents.GetAll()) do
				if isfunction(ent.AddEntityRelationship) then
					ent:AddEntityRelationship(ply, D_HT, 99)
				end
			end

			Notify:Warning(ply, "Deaktiviert", "Du wirst wieder von NPCs angegriffen!")
		end
	end

	function SWEP:IsTarget(ply)
		if ply.NoTarget then
			Notify:Success(ply, "Aktiviert", "Du wirst von keinen NPCs angegriffen!")
		else
			Notify:Warning(ply, "Deaktiviert", "Du wirst von NPCs angegriffen!")
		end
	end

	function SWEP:PrimaryAttack()
		self:SwitchTarget(self:GetOwner())
	end

	function SWEP:SecondaryAttack()
		self:SwitchTarget(self:GetOwner())
	end

	function SWEP:Reload()
		self:IsTarget(self:GetOwner())
	end

	function SWEP:Holster()
		return true
	end

	-- Keep the immunity if the player still has the SWEP after respawn/revive/char change, loose it otherwise
	hook.Add("Character.LoadoutDone", "NoTarget.Character.Loadout", function(ply, character)
		if !ply:HasWeapon("weapon_npc_notarget") then
			ply.NoTarget = false
		end
	end)
end
--gamemodes/starwarsrp/gamemode/modules/nextbotspawner/weapons/weapon_npc_umbaran.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--				(CW:RP)		 	 	 --
--                                   --
--           NextBot Spawner         --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

AddCSLuaFile()

SWEP.Base   = "weapon_npcbase"

SWEP.PrintName = "NPC: Umbaran Rifle"
SWEP.Spawnable = false
SWEP.Author = "Deltaa"

SWEP.WorldModel = "models/servius/starwars/cwa2/umbaran_rifle.mdl"
SWEP.Weight = 3

SWEP.NextShoot = 0.2
SWEP.Sound = "weapons/umbaranrifle_fire.ogg"
SWEP.ClipSize = 20
SWEP.Damage = 17

SWEP.Offset = Angle(90, 0, 0)


--gamemodes/starwarsrp/gamemode/modules/education/cl_education.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis   --
--                                   --
--   This software is only allowed   --
--    on official 'Einfach Gaming'   --
--     servers owned by 'P4sca1'     --
---------------------------------------
---------------------------------------

---------------------------------------
--         Client | Education        --
---------------------------------------

local function buildQuestionMenu(questionTable)
	local questionCount = table.Count(questionTable)
	local divHeight = 800 / questionCount
	local ply_cooldown = math.Round(LocalPlayer():GetNWInt("Education.Cooldown", 0) - CurTime(), 0)

	local background = vgui.Create("EGMFrame")
	background:MakePopup()
	background:SetBackground(Education.Background)
	background:SetTitle("Ausbildung - Endabfrage")

	local answerComboboxes = {}

	local headerPanel = vgui.Create("DPanel", background)
	headerPanel:SetSize(ScrW() * .7, ScrH() * .2)
	headerPanel:SetPos(ScrW() * .15, ScrH() * .15)
	headerPanel.Paint = function(self, w, h)
		draw.RoundedBox(5, 0, 0, w, h, Color(0,0,0,200))
		draw.SimpleText( "Herzlich willkommen zur Endabfrage", "EGMText12", ScrW() * .01, ScrH() * .01, color_white )
		draw.RoundedBox(0, 0, ScrH() * .055, w, h * .01, color_white)
	end

	local infotext = vgui.Create("DLabel", background)
	infotext:SetSize(ScrW() * .68, ScrH() * .2)
	infotext:SetPos(ScrW() * .16, ScrH() * .22)
	infotext:SetFont("EGMText8")
	infotext:SetExpensiveShadow( 1, Color( 0, 0, 0, 190 ) )
	infotext:SetText("Es folgt nun weiter unten ein Test, in welchem du über die Ausbildungsinhalte abgefragt wirst. Solltest du den Test nicht bestehen, erhälst du einen 5-minütigen Cooldown auf den Test. Lese dir also alles genau durch. Solltest du irgendetwas nicht verstehen oder sonst Hilfe benötigen, kannst du im Chat mit ´/ooc Ich brauche einen Ausbilder´ jederzeit einen Ausbilder rufen.\n\nViel Erfolg :)")
	infotext:SetWrap(true)
	infotext:SetAutoStretchVertical( true )

	if ply_cooldown > 0 then
		local cooldownPanel = vgui.Create("DPanel", background)
		cooldownPanel:SetSize(ScrW() * .7, ScrH() * .12)
		cooldownPanel:SetPos(ScrW() * .15, ScrH() * .45)
		cooldownPanel.Paint = function(self, w, h)
			draw.RoundedBox(5, 0, 0, w, h, Color(0,0,0,200))
			draw.SimpleText( "Cooldown", "EGMText12", ScrW() * .01, ScrH() * .01, Color(255, 89, 95) )
			draw.RoundedBox(0, 0, ScrH() * .055, w, h * .01, Color(255, 89, 95))
		end

		local cdText = vgui.Create("DLabel", background)
		cdText:SetSize(ScrW() * .68, ScrH() * .2)
		cdText:SetPos(ScrW() * .16, ScrH() * .513)
		cdText:SetFont("EGMText8")
		cdText:SetText("Du hast einen aktiven Cooldown für die Endabfrage.\nVerbleibende Zeit: " .. ply_cooldown .. " Sekunden")
		cdText:SetWrap(true)
		cdText:SetColor(Color(255, 89, 95))
		cdText:SetAutoStretchVertical( true )

		local closeButton = vgui.Create("EGMButton", background)
		closeButton:SetSize(ScrW() * .5925, ScrH() * .05)
		closeButton:SetPos(ScrW() * .2, ScrH() * .59)
		closeButton:SetText( "Schließen" )
		closeButton:SetFont("EGMText8")
		closeButton:SetDisabled(false)
		closeButton:SetButtonColor(GetColor("red"))
		closeButton.DoClick = function()
			background:Remove()
		end
	else
		local pan = vgui.Create("DPanel", background)
		pan:SetSize(ScrW(), ScrH() * .5)
		pan:SetPos(0, ScrH() * .4)
		pan.Paint = function(self, w, h)
			draw.RoundedBox(5, 0, 0, w, h, Color(0,0,0,0))
		end

		local ScrollBar1 = vgui.Create( "DScrollPanel", pan )
		ScrollBar1:Dock( FILL )

		local button = vgui.Create("EGMButton", background)
		button:SetSize(ScrW() * .5925, ScrH() * .05)
		button:SetPos(ScrW() * .2, ScrH() * .9)
		button:SetText( "Auswerten" )
		button:SetFont("EGMText8")
		button:SetDisabled(false)
		button:SetButtonColor(GetColor("green"))
		button.DoClick = function()
			local modal = vgui.Create("EGMModal")
			modal:SetCustomTitle(egmt("shared.are_you_sure"))
			modal:Confirm("Hast du dir alles genau durchgelesen und möchtest den Text abschicken?", function()
			background:Remove()
			local answers = {}
			for k, v in pairs(answerComboboxes) do
				local answer = {}
				answer.question = v.question
				answer.answer = v.combobox:GetSelected()
				table.insert(answers, answer)
			end
				net.Start("Education.CorrectNewbieAnswers")
				net.WriteTable(answers)
				net.SendToServer()
			end)
		end

		local cancelButton = vgui.Create("EGMButton", background)
		cancelButton:SetSize(ScrW() * .5925, ScrH() * .05)
		cancelButton:SetPos(ScrW() * .2, ScrH() * .95)
		cancelButton:SetText( "Endabfrage abbrechen" )
		cancelButton:SetFont("EGMText8")
		cancelButton:SetDisabled(false)
		cancelButton:SetButtonColor(GetColor("red"))
		cancelButton.DoClick = function()
			local modal = vgui.Create("EGMModal")
			modal:SetCustomTitle(egmt("shared.are_you_sure"))
			modal:Confirm("Bist du dir sicher, dass du die Endabfrage abbrechen möchtest? Es wird als Fehler gewertet.", function()
			background:Remove()
			local answers = {}
			for k, v in pairs(answerComboboxes) do
				local answer = {}
				answer.question = v.question
				answer.answer = nil
				table.insert(answers, answer)
			end

				net.Start("Education.CorrectNewbieAnswers")
				net.WriteTable(answers)
				net.SendToServer()
			end)
		end

		for key, question in pairs(questionTable) do
			local questionFrame = ScrollBar1:Add("DPanel")
			--local questionFrame = vgui.Create("DPanel", pan)
			questionFrame:SetSize(ScrW() * .4, ScrH() * .1)
			questionFrame:Dock(TOP)
			questionFrame:DockMargin(ScrW() * .2, 0, ScrW() * .2, 0)
			questionFrame.Paint = function( self, w, h )
				draw.RoundedBox( 0, 0, 0, w, h, Color( 0, 0, 0, 200))
			end

			local questionLabel = vgui.Create("DLabel", questionFrame)
			questionLabel:SetText(question.message)
			questionLabel:SetSize(ScrW() * .01, ScrH() * .04)
			questionLabel:SetExpensiveShadow( 1, Color( 0, 0, 0, 190 ) )
			questionLabel:SetFont("EGMText8")
			questionLabel:SetPos(ScrW() * .01, ScrH() * .001)
			questionLabel:SetSize(1300, (divHeight / 2) - 20)

			local comboBox = vgui.Create("DComboBox", questionFrame)

			comboBox:SetSize(ScrW() * .5, ScrH() * .03)
			comboBox:SetPos(ScrW() * .01, ScrH() * .04)
			comboBox:SetFont("EGMText8")
			comboBox:SetText("Antwort auswählen (" .. key .. ")")

			for k, v in pairs(question.answers) do
				comboBox:AddChoice(v)
			end

			local tempObj = {}
			tempObj.combobox = comboBox
			tempObj.question = question

			table.insert(answerComboboxes, tempObj)
		end
	end
end

---------------------------

function Education:OpenTutorial(id)
	local w = ScrW() * 0.5
	local h = ScrH() * 0.5

	if id == nil then
		id = 1
	end

	local eduTutorialFrame = vgui.Create("DFrame")
	eduTutorialFrame:SetPos(ScrW() * 0.5 - w / 2, ScrH() * 0.5 - h / 2)
	eduTutorialFrame:SetSize(w, h)
	eduTutorialFrame:SetTitle("")
	eduTutorialFrame:ShowCloseButton(false)
	eduTutorialFrame:SetDraggable(false)
	eduTutorialFrame:MakePopup()
	eduTutorialFrame:SetAlpha(0)
	function eduTutorialFrame:Paint(width, height)
		draw.RoundedBox(2, 0, 0, width, height, GetColor("darkgray"))

		draw.DrawText("Education (" .. id .. "/" .. #Education.Images .. ")", "EGMText12", width * 0.01, height * 0.01, GetColor("yellow"), TEXT_ALIGN_LEFT)

		surface.SetDrawColor(GetColor("yellow"))
		surface.DrawRect(0, height * .1, width, height * .01)
	end
	eduTutorialFrame:AlphaTo(255, 0.2)

	local eduTutorialClose = vgui.Create("EGMCloseButton", eduTutorialFrame)
	eduTutorialClose:SetPanel(eduTutorialFrame)
	eduTutorialClose:SetPos(w * 0.95, h * 0.015)
	eduTutorialClose:SetSize(w * 0.04, w * 0.04)

	local eduTutorialImage = vgui.Create("DImage", eduTutorialFrame)
	eduTutorialImage:SetPos(0, h * 0.1)
	eduTutorialImage:SetSize(ScrW() / 2, ScrH() / 2)
	eduTutorialImage:SetImage(Education.Images[id])

	local eduTutorialNext = vgui.Create("EGMButton", eduTutorialFrame)
	eduTutorialNext:SetHeight(h * 0.1)
	eduTutorialNext:SetDisabled(false)
	eduTutorialNext:SetPos(w * .87, h * .85)
	eduTutorialNext:SetSize(w * .1, h * .1)
	eduTutorialNext:SetFont("Trebuchet24")
	eduTutorialNext:SetText("Nächste")

	if id == #Education.Images then
		eduTutorialNext:SetDisabled(true)
	end

	eduTutorialNext.DoClick = function()
		eduTutorialFrame:Remove()
		self:OpenTutorial(id + 1)
	end

	local eduTutorialBack = vgui.Create("EGMButton", eduTutorialFrame)
	eduTutorialBack:SetHeight(h * 0.1)
	eduTutorialBack:SetPos(w * .76, h * .85)
	eduTutorialBack:SetSize(w * .1, h * .1)
	eduTutorialBack:SetFont("Trebuchet24")
	eduTutorialBack:SetText("Zurück")

	if id == 1 then
		eduTutorialBack:SetDisabled(true)
	end

	eduTutorialBack.DoClick = function()
		eduTutorialFrame:Remove()
		self:OpenTutorial(id-1)
	end

	if id == #Education.Images then
		local char = LocalPlayer():GetCurrentCharacter()
		if not char:GetRank() or not char:GetRank():IsStartRank() or LocalPlayer():IsInstructor() then return end
		local eduTutorialTest = vgui.Create("EGMButton", eduTutorialFrame)
		eduTutorialTest:SetHeight(h * 0.1)
		eduTutorialTest:SetDisabled(false)
		eduTutorialTest:SetPos(w * .03, h * .85)
		eduTutorialTest:SetSize(w * .3, h * .1)
		eduTutorialTest:SetFont("Trebuchet24")
		eduTutorialTest:SetText("Endabfrage starten")

		eduTutorialTest.DoClick = function()
			local modal = vgui.Create("EGMModal")
			modal:SetCustomTitle(egmt("shared.are_you_sure"))
			modal:Confirm("Hast du dir alles genau durchgelesen? Es folgt jetzt ein kleiner Test, in welchem du über die Ausbildungsinhalte abgefragt wirst.", function()
				eduTutorialFrame:Remove()

				local questions = {}
				local i = 0;

				while i < Education.QuestionCount do
					local random = math.random(table.Count(Education.Newbie))
					local alreadyIn = false
					local message = Education.Newbie[random].message
					for k, v in pairs(questions) do
						if v.message == message then
							alreadyIn = true
							break
						end
					end
					if alreadyIn then
						continue
					else
						table.insert(questions, table.Copy(Education.Newbie[random]))
						i = i + 1
					end

					if table.Count(questions) < 1 then
						table.insert(questions, table.Copy(Education.Newbie[random]))
						i = i + 1
					end
				end

				buildQuestionMenu(questions)
			end)
		end
	end
end

Scoreboard:AddOption(
	"Endabfrage Cooldown resetten",
	"icon16/clock_red.png",
	700,
	function(target)
		target:SetNWInt("Education.Cooldown", 0)
		Notify:Success("Ausbildung", "Erfolgreich den Cooldown von " .. target:Nick() .. " zurückgesetzt.")
	end,
	function(target)
		local character = target:GetCurrentCharacter()
		if not character then return false end

		local ply = LocalPlayer()
		if not ply:IsInstructor() or not ply:IsAtLeast(Instructor.MinAccessGroup) then return false end

		local rank = character:GetRank()
		if not rank or not rank:IsStartRank() then return false end

		return true
	end
)
--gamemodes/starwarsrp/gamemode/modules/voicenotify/sh_index.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--            Voicenotify            --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--      Voicenotify | SH Index       --
---------------------------------------

Voicenotify = Voicenotify || {}

if SERVER then
	AddCSLuaFile("sh_config.lua")
	AddCSLuaFile("cl_voicenotify.lua")
	AddCSLuaFile("cl_vgui_comlink.lua")
	AddCSLuaFile("cl_vgui_default.lua")

	include("sh_config.lua")
end

if CLIENT then
	Voicenotify.PlayerVoicePanels = {}
	Voicenotify.ComlinkVoicePanels = {}

	include("sh_config.lua")
	include("cl_vgui_comlink.lua")
	include("cl_vgui_default.lua")
	include("cl_voicenotify.lua")
end
--gamemodes/starwarsrp/gamemode/modules/lightsaber_crafting/weapons/lightsaber_inventory.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--        Lightsaber Crafting        --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--     Lightsaber Crafting | SH      --
---------------------------------------

SWEP.Base = "weapon_swrp_egm_base"

SWEP.PrintName = "Inventar (Laserschwert)"
SWEP.Author = "Deltaa"
SWEP.Contact = "https://www.einfach-gaming.de/user/4179-deltaa/"
SWEP.Purpose = "Eine Waffe für den SW:RP Spielmodus"
SWEP.Instructions = "Linksklick: Öffnet das Lichtschwert-Inventar"

SWEP.Category = "SW:RP (Jedi)"
SWEP.Type = "Inventory"
SWEP.Manufacturer = "Exploration Corps"

SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.ViewModelFOV = 60
SWEP.Slot = 2
SWEP.SlotPos = 0

SWEP.HoldType = "slam"
SWEP.UseHands = true

SWEP.NextReload = 0

SWEP.Primary.ClipSize = 0
SWEP.Primary.DefaultClip = 0
SWEP.Primary.Ammo = "none"

SWEP.data = {}
SWEP.data.ironsights = 0

SWEP.ViewModel = "models/weapons/c_bugbait.mdl"
SWEP.WorldModel = "models/weapons/w_datapad.mdl"

function SWEP:PreDrawViewModel()
	render.SetBlend(0)
end

-- Switches between the available options
--
function SWEP:Reload()
	return
end

-- Depending on the mode, selects the corresponding function
--
function SWEP:PrimaryAttack()
	if self:GetNextPrimaryFire() > CurTime() then return end
	self:SetNextPrimaryFire(CurTime() + 3)

	self:OpenInventory()
end

function SWEP:SecondaryAttack()
	self:PrimaryAttack()
end

-- Opens the inventory
--
function SWEP:OpenInventory()
	if SERVER then return end

	LightsaberCrafting:OpenInventory()
end


function SWEP:ProcessFireMode()

end

function SWEP:IronSights()

end

function SWEP:DrawHUDAmmo()
	return false
end
--gamemodes/egmrp/gamemode/modules/course/sh_course.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--          Course | Shared          --
---------------------------------------

Course.Name = "Course"

Course:AddData("factionId", "number", "faction_id", "INT NOT NULL",
function(course, value)
    if not isnumber(value) then
        return false, egmt("course.invalid_faction_id")
    end

    local faction = Faction:GetCached(value)

    if not (faction and faction:IsValid()) then
        return false, egmt("course.invalid_faction")
    end

    return true
end,
function(course, ply)
    return true
end)

-- Returns the Faction of the course.
--
-- @return Table faction
function Course.Meta:GetFaction()
    return Faction:GetCached(self:Get("factionId"))
end

-- Alias for Course:GetFaction used in the manager.
--
-- @return Table faction
function Course.Meta:GetParent()
    return self:GetFaction()
end

-- Gets every course belonging to the given faction.
--
-- @param Number factionId
-- @param Boolean hideInherited
-- @return Table courses
function Course:GetByFaction(factionId, hideInherited)
    local courses = {}

    for id, course in pairs(self:GetCache()) do
        if course:Get("factionId") ~= factionId then
            continue
        end

        if hideInherited and not course:GetProperty("inheritCourse", true) then
            continue
        end

        table.insert(courses, course)
    end

    local faction = Faction:GetCached(factionId)
    local parent = faction:GetParent()
    if parent then
        local parentCourses = self:GetByFaction(parent:GetId(), true)
        MergeTableByValue(courses, parentCourses)
    end

    return courses
end

-- Alias function for Course:GetByFaction.
--
-- @param Boolean hideInherited
-- @return Table courses
function Faction.Meta:GetCourses(hideInherited)
    return Course:GetByFaction(self:GetId(), hideInherited)
end

-- Checks, if a course is available in the faction.
--
-- @param Course course
-- @return Boolean available
function Faction.Meta:HasCourse(course)
    local courses = self:GetCourses()

    return table.HasValue(courses, course)
end

-- Get the available courses of a character.
--
-- @return Table courses
function Character.Meta:GetAvailableCourses()
	local faction = self:GetFaction()
	if not faction then return {} end

	local courses = faction:GetCourses()

	hook.Run("Character.GetCourses", self, courses)

	return courses
end

-- Checks, if a character has a course.
--
-- @param Course course
-- @return Boolean hasCourse
function Character.Meta:HasCourse(course)
	local courses = self:GetAvailableCourses()

	return table.HasValue(courses, course)
end

-- Initialize networking.
Course:InitCreationNetworking()
Course:InitEditNetworking()
Course:InitDeletionNetworking()

-- Add course property: name
Course:AddProperty("name", "string", nil, function(course, value)
    if not isstring(value) or #value < 3 then
        return false, egmt("course.invalid_name")
    end

    return true
end,
function(course, ply)
    return true
end)

-- Used to get the name of a course. Will use the name property or the id as a fallback.
--
-- @return String name
function Course.Meta:GetName()
    return self:GetProperty("name") or egmt("shared.course") .. " " .. self:GetId()
end

-- Add course property: short
Course:AddProperty("short", "string", "", function(course, value)
    if not isstring(value) or #value > 20 then
        return false, egmt("course.invalid_short")
    end

    return true
end,
function(course, ply)
    return true
end)

-- Used to get the short of a course.
--
-- @return String short
function Course.Meta:GetShort()
    return self:GetProperty("short", "")
end

-- Add course property: isPrefix
Course:AddProperty("isPrefix", "boolean", false, function(course, value)
    if not isbool(value) then
        return false, egmt("shared.invalid_type")
    end

    return true
end,
function(course, ply)
    return true
end)

-- Used, to check if the course has prefix or suffix.
--
-- @return Boolean isPrefix
function Course.Meta:IsPrefix()
    return self:GetProperty("isPrefix", false)
end

-- Add couse Property: shortOnName
Course:AddProperty("shortOnName", "boolean", true, function(course, value)
    if not isbool(value) then
        return false, egmt("shared.invalid_type")
    end

    return true
end,
function(course, ply)
    return true
end)

-- Used, to check if the short should be displayed on the name.
--
-- @return Boolean isShortOnName
function Course.Meta:IsShortOnName()
    return self:GetProperty("shortOnName", true)
end

-- Add course property: shortOnPrefix
Course:AddProperty("shortOnPrefix", "boolean", true, function(course, value)
    if not isbool(value) then
        return false, egmt("shared.invalid_type")
    end

    return true
end,
function(course, ply)
    return true
end)

-- Used, to check if the short should be displayed on the prefix.
--
-- @return Boolean isShortOnPrefix
function Course.Meta:IsShortOnPrefix()
    return self:GetProperty("shortOnPrefix", true)
end

-- Add course property: inheritCourse
Course:AddProperty("inheritCourse", "boolean", true, function(course, value)
    if not isbool(value) then
        return false, egmt("shared.invalid_type")
    end

    return true
end,
function(course, ply)
    return true
end)

-- Register rank permission: course
RANK_PERMISSION_COURSE = "course"
Rank:RegisterPermission(RANK_PERMISSION_COURSE, egmt("course.invite"))

-- Limit access to the edit functions.
hook.Add("Course.CanPlayerEditProperties", "Course.EditPropertiesPermissions", function(ply, course, properties)
    return ply:IsAtLeast(Course.MinAccessGroup)
end)

hook.Add("Course.CanPlayerEditData.factionId", "Course.EditFactionIdPermissions", function(ply, course, rankId)
    return ply:IsAtLeast(Course.MinAccessGroup)
end)

hook.Add("Course.CanPlayerCreate", "Course.CreatePermissions", function(ply, data, properties)
    return ply:IsAtLeast(Course.MinAccessGroup)
end)

hook.Add("Course.CanPlayerDelete", "Course.DeletePermissions", function(ply, character)
    return ply:IsAtLeast(Course.MinAccessGroup)
end)



---------------------------------------
--       Character Integration       --
---------------------------------------

-- Add character property: courses
Character:AddProperty("courses", "table", {}, function(character, value)
    if not istable(value) then
        return false, egmt("course.id_no_table")
    end

    if #value == 0 then
        return true
    end

    for _, courseId in pairs(value) do
        local course = Course:GetCached(courseId)

        if not course then
            return false, egmt("course.not_valid")
        end

        if not character:HasCourse(course) then
            return false, egmt("course.not_available")
        end
    end

    return true
end, function(character, ply)
    return true
end)

-- Get the courses of a character.
--
-- @return Table courses
function Character.Meta:GetCourses()
	return self:GetProperty("courses", {})
end

local Player = FindMetaTable("Player")

-- Check if a rank has the authority to change the courses of a person in a different rank.
--
-- @param Faction playerFaction
-- @param Rank playerRank
-- @param Faction currentFaction
-- @param Rank currentRank
-- @param Table currentValue
-- @param Table value
-- @param Boolean? selfEdit
function Player:CanChangeCoursesInternal(playerFaction, playerRank, currentFaction, currentRank, currentValue, value, selfEdit)
	-- print("\nPlayer:CanChangeCoursesInternal", playerFaction, playerRank, currentFaction, currentRank, courseIds)

	if not currentFaction or not currentRank then
		return false
	end

	value = value or {}
	currentValue = currentValue or {}

	-- Check, if your faction allows you to add the course.
	for _, courseId in pairs(value) do
		-- Skip, if no change is made.
		if table.HasValue(currentValue, courseId) then continue end

		-- Skip, if the course is invalid.
		local course = Course:GetCached(courseId)
		if not course then continue end

		if not currentFaction:HasCourse(course) then
			return false
		end
	end
	-- Check, if your faction allows you to remove the course.
	for _, courseId in pairs(currentValue) do
		-- Skip, if no change is made.
		if table.HasValue(value, courseId) then continue end

		-- Skip, if the course is invalid.
		local course = Course:GetCached(courseId)
		if not course then continue end

		if not currentFaction:HasCourse(course) then
			return false
		end
	end

	-- Override, if the player is allowed to assign courses, because of his staff rank.
	if self:IsAtLeast(Course.MinAssignGroup) then
		return true
	end

	if not playerFaction or not playerRank then
		return false
	end

	-- Check, if the player is in the same faction.
	if playerFaction:GetId() ~= currentFaction:GetId() then
		return false
	end

	-- Check, if the is allowed to assign courses.
	if not playerRank:HasPermission(RANK_PERMISSION_COURSE) then
		return false
	end

	-- Allow changing your own courses.
	if selfEdit then
		return true
	end

	-- Check, if the player has a higher rank.
	if playerRank:GetAuthorityLevel() <= currentRank:GetAuthorityLevel() then
		return false
	end

	return true
end

-- Permission Check, to assign courses.
hook.Add("Character.CanPlayerEditProperty.courses", "Courses.CanEdit", function(ply, character, value)
	local playerCharacter = ply:GetCurrentCharacter()
	local playerFaction, playerRank
	if playerCharacter then
		playerFaction = playerCharacter:GetFaction()
		playerRank = playerCharacter:GetRank()
	end

	local currentFaction = character:GetFaction()
	local currentRank = character:GetRank()

	local currentValue = character:GetCourses()
	if ply:CanChangeCoursesInternal(playerFaction, playerRank, currentFaction, currentRank, currentValue, value, character == playerCharacter) then
		return true
	end
end)

-- Override the rank name of characters, to include the course prefix and suffix.
hook.Add("Character.GetRankName", "Courses.ExpandRankName", function(character, rankNameTable)
	local courses = character:GetCourses()
	if not istable(courses) then return end
	if #courses == 0 then return end

	local prefix = ""
	local suffix = ""

	for _, courseId in SortedPairs(courses) do
		local course = Course:GetCached(courseId)
		if not course then continue end

		local short = course:GetShort()
		if short == "" then continue end

		local isShortOnName = course:IsShortOnName()
		if not isShortOnName then continue end

		local isPrefix = course:IsPrefix()
		if isPrefix then
			if prefix ~= "" then
				prefix = prefix .. " "
			end

			prefix = prefix .. short
		else
			if suffix ~= "" then
				suffix = suffix .. " "
			end

			suffix = suffix .. short
		end
	end

	if prefix ~= "" then
		rankNameTable[-1] = prefix
	end

	if suffix ~= "" then
		rankNameTable[1] = suffix
	end
end)

-- Override the rank prefix of characters, to include the course prefixPrefix and prefixSuffix.
hook.Add("Character.GetRankPrefix", "Courses.ExpandRankPrefix", function(character, rankPrefixTable)
	local courses = character:GetCourses()
	if not istable(courses) then return end
	if #courses == 0 then return end

	local prefix = ""
	local suffix = ""

	for _, courseId in SortedPairs(courses) do
		local course = Course:GetCached(courseId)
		if not course then continue end

		local short = course:GetShort()
		if short == "" then continue end

		local isShortOnPrefix = course:IsShortOnPrefix()
		if not isShortOnPrefix then continue end

		local isPrefix = course:IsPrefix()
		if isPrefix then
			if prefix ~= "" then
				prefix = prefix .. " "
			end

			prefix = prefix .. short
		else
			if suffix ~= "" then
				suffix = suffix .. " "
			end

			suffix = suffix .. short
		end
	end

	if prefix ~= "" then
		rankPrefixTable[-1] = prefix
	end

	if suffix ~= "" then
		rankPrefixTable[1] = suffix
	end
end)



---------------------------------------
--       Equipment Integration       --
---------------------------------------

-- Add equipment property: requiredCourses
Equipment:AddProperty("requiredCourses", "table", {}, function(equipment, value)
    if not istable(value) then
        return false, egmt("course.id_no_table")
    end

    if #value == 0 then
        return true
    end

    local faction = equipment:GetFaction()
    if not faction then
        return false, egmt("course.no_faction")
    end

    for _, courseId in pairs(value) do
        local course = Course:GetCached(courseId)

        if not course then
            return false, egmt("course.not_valid")
        end

        if not faction:HasCourse(course) then
            return false, egmt("course.not_available")
        end
    end

    return true
end, function(equipment, ply)
    return true
end)

-- Block the equipment, if the player doesn't have the required courses.
hook.Add("Character.BlockEquipment", "Course.BlockEquipment", function(equip, char, faction, rank)
    -- If no required courses are set, allow the equipment.
    local requiredCourses = equip:GetProperty("requiredCourses", {})
    if not istable(requiredCourses) then return end
    if #requiredCourses == 0 then return end

    -- If the character doesnt exist, block the equipment.
    if not char then return true end

    -- If the player has no courses, block the equipment.
    local courses = char:GetCourses()
    if not istable(courses) then return true end
    if #courses == 0 then return true end

    -- Check, if the player has the required courses.
    for _, courseId in pairs(requiredCourses) do
        if not table.HasValue(courses, courseId) then
            return true
        end
    end
end)

-- Add the required courses to the equipment name.
hook.Add("Equipment.AddAffectedBonus", "Course.AddCourseNames", function(equip, affectedBonus)
    local requiredCourses = equip:GetProperty("requiredCourses", {})
    if not istable(requiredCourses) then return end
    if #requiredCourses == 0 then return end

    local courseShorts = ""
    for _, courseId in SortedPairs(requiredCourses) do
        local course = Course:GetCached(courseId)
        if not course then continue end

        local short = course:GetShort()
        if #short == 0 then continue end

        if #courseShorts > 0 then
            courseShorts = courseShorts .. "&"
        end

        courseShorts = courseShorts .. short
    end

    table.insert(affectedBonus, courseShorts)
end)
--gamemodes/egmrp/gamemode/modules/event/sh_event.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--       Shared | Event Lister       --
---------------------------------------

-- Make the event rank visible in the chat.
hook.Add("Player.UserGroupVisible", "Event.ShowRankInChat", function(ply)
    if ply:IsAtLeast(Event.MinAccessGroup) then
        return true
    end
end)

-- Allow People to delete their own event-characters
hook.Add("Character.CanPlayerDelete", "Event.CharacterDeletePermissions", function(ply, character)
	local rank = character:GetRank()

	if rank and rank:GetProperty("slotType") == "event" and character:Get("playerSteamId64") == ply:SteamID64() then
		return true
	end
end)

-- Allow Eventleiter to respawn eventchars
hook.Add("Scoreboard.CanForceRespawn", "Event.CanForceRespawn", function(ply, target)
	if ply:IsAtLeast(Event.MinAccessGroup) then
		local char = target:GetCurrentCharacter()

		if char then
			local rank = char:GetRank()

			if rank and rank:GetProperty("slotType") == "event" then
				return true
			end
		end
	end
end)

-- Implement the whitelist for event characters.
hook.Add("Character.IsPlayable", "Event.Whitelist", function(char, owner)
	local rank = char:GetRank()
	if not rank then return end

	local slotType = rank:GetProperty("slotType")
	if slotType ~= "event" then return end

	local whitelist = owner.EventWhitelist or {}
	if not whitelist[rank:GetId()] then
		return false, egmt("event.not_whitelisted")
	end
end)

-- Implement the whitelist for event characters.
hook.Add("Player.CanCreateCharacter", "Event.Whitelist", function(self, rank)
	if not rank then return end

	local slotType = rank:GetProperty("slotType")
	if slotType ~= "event" then return end

	local whitelist = self.EventWhitelist or {}
	if whitelist[rank:GetId()] then
		return true
	end
end)
--gamemodes/starwarsrp/gamemode/modules/weaponutil/item_classes/weapon_backpack/shared.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--        Shared | Weapon Item       --
---------------------------------------

-- This Item Class is used for weapons, which can be equipped and used by the player.
-- A single weapon cannot be equipped more than once, but multiple weapons can be equipped together, depending on the slots.

local ITEM_CLASS = ITEM_CLASS

-- Base Item class, from which functions and such should be inherited.
ITEM_CLASS.BaseItemClass = "weapon"

-- List of item slots, which the item can be equipped to.
ITEM_CLASS.Slots = {
	"back",
	"backpack",
}

-- Sorting order of the item.
ITEM_CLASS.Sort = 130
--gamemodes/starwarsrp/gamemode/modules/pronemod/sh_config.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--         ProneMod Extension        --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--   ProneMod Extension | SH Config  --
---------------------------------------

ProneMod.DefaultKey = KEY_LCONTROL
--gamemodes/starwarsrp/gamemode/modules/rakghoul/sh_index.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--             Rakghoul              --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--           Rakghoul | SH           --
---------------------------------------

Rakghoul = Rakghoul or {}

if SERVER then
	AddCSLuaFile("sh_config.lua")
	AddCSLuaFile("sh_rakghoul.lua")
	AddCSLuaFile("cl_rakghoul.lua")

	include("sh_config.lua")
	include("sh_rakghoul.lua")
	include("sv_rakghoul.lua")
end

if CLIENT then
	include("sh_config.lua")
	include("sh_rakghoul.lua")
	include("cl_rakghoul.lua")
end

--gamemodes/starwarsrp/gamemode/modules/rakghoul/sh_config.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--             Rakghoul              --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--        Rakghoul | Config          --
---------------------------------------

-- Time of infection, before transforming to rakghoul
Rakghoul.InfectionTime = 120

-- Percent of a infection with the rakghoul virus (30 = 30%)
Rakghoul.InfectionRate = 30

-- Whats the immunity time after serum injection
Rakghoul.ImmunityTime = 900

-- The model, which will set the rakghoul
Rakghoul.Model = "models/grealms/characters/rakghoul/rakghoul.mdl"

-- The health of a rakghoul
Rakghoul.Health = 1000

-- The lowest rank to use the commands
Rakghoul.Permission = "eventleiter"

-- These models cannot be infected by rakghoul
Rakghoul.ProtectedModels = {
	["models/egm/core/clone_synthmesh/clone_synthmesh.mdl"] = 95,

	["models/egm/core/clone_commando/clone_commando.mdl"] = 95,
	-- ["Some Modelpath"] = Percent,
}
--gamemodes/starwarsrp/gamemode/modules/rakghoul/cl_rakghoul.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--             Rakghoul              --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--           Rakghoul | CL           --
---------------------------------------

-- Makes the Screenspace effect
--
hook.Add( "RenderScreenspaceEffects", "Rakghoul:ScreenEffect", function()
	if LocalPlayer():IsRakghoul() then
		DrawSobel(0.08)
		DrawColorModify({
			[ "$pp_colour_addr" ] = 0.02,
			[ "$pp_colour_addg" ] = 0.02,
			[ "$pp_colour_addb" ] = 0,
			[ "$pp_colour_brightness" ] = 0.15,
			[ "$pp_colour_contrast" ] = 1,
			[ "$pp_colour_colour" ] = 3,
			[ "$pp_colour_mulr" ] = 0,
			[ "$pp_colour_mulg" ] = 0.02,
			[ "$pp_colour_mulb" ] = 0})
		DrawMaterialOverlay( "models/props_lab/xencrystal_sheet", 0.0001 )
		DrawMotionBlur( 0.1, 0.39, 0.05 )
	end
end)

-- Creates a halo around all rakghouls
--
hook.Add("PreDrawHalos", "Rakghoul:ShowRakghouls", function()
	if not LocalPlayer():IsRakghoul() then return end

	local rakghouls = {}
	local rakghoulColor = Color(170, 15, 15)

	for _, ply in pairs(player.GetHumans()) do
		if ply == LocalPlayer() then continue end
		if ply:GetNW2Bool("CamoEnabled") then continue end

		if ply:IsRakghoul() or ply:IsTransforming() then
			table.insert(rakghouls, ply)
			continue
		end
	end

	halo.Add(rakghouls, rakghoulColor, 5, 5, 1, true, false)
end)

-- Immunity Bar
--
hook.Add("HUDPaint", "Rakghoul:ImmuneBar", function()
	local ply = LocalPlayer()

	local immunityTime = math.Round(LocalPlayer():GetNWFloat("Rakghoul.Immunity", 0) - CurTime())
	immunityTime = math.Clamp(immunityTime, 0, 99999)
	local immunityMaxTime = Rakghoul.ImmunityTime
	local immunityPercentage = immunityTime / immunityMaxTime

	if ply:GetNWFloat("Rakghoul.Immunity", 0) > CurTime() then
		-- immunity bar
		draw.RoundedBox(0, ScrW() * 0.29, ScrH() * 0.974, ScrW() * 0.1, ScrH() * 0.023, ColorAlpha(UI.BackgroundColor, 255))
		draw.RoundedBox(0, ScrW() * 0.29, ScrH() * 0.974, ScrW() * 0.1 * immunityPercentage, ScrH() * 0.023, GetColor("yellow", 40))

		draw.SimpleText("Immunität: " .. string.ToMinutesSeconds(LocalPlayer():GetNWFloat("Rakghoul.Immunity", 0) - CurTime()), "EGMText8", ScrW() * 0.34, ScrH() * 0.9735, UI.TextColor, TEXT_ALIGN_CENTER)
	end
end)
--gamemodes/starwarsrp/gamemode/config/cl_loading.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--         Loading | Config          --
---------------------------------------

-- Background for the loading screen.
Loading.Background = "materials/wallpaper/181377.jpg"
--gamemodes/starwarsrp/gamemode/config/sh_comlink.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--       Shared | Chat config        --
---------------------------------------

-- Minimum access grou, to access the custom com channels.
ComChannel.MinAccessGroup = "admin"
--gamemodes/starwarsrp/gamemode/config/sh_inventory_faction.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--     Config | Inventory Faction    --
---------------------------------------

-- Slot limit of different items in the faction inventory. (false is unlimited.)
InventoryFaction.SlotLimit = 50

-- Page Size of the faction inventory logs.
InventoryFaction.LogPageSize = 25
--gamemodes/starwarsrp/gamemode/config/sh_inventory_private.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--     Config | Inventory Private    --
---------------------------------------

-- Slot limit of different items in the private inventory. (false is unlimited.)
InventoryPrivate.SlotLimit = 50
--gamemodes/starwarsrp/gamemode/config/sh_inventory_weight.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--     Config | Inventory Weight     --
---------------------------------------

-- Default weight limit for the player inventory.
InventoryWeight.DefaultWeightLimit = 50

-- Minimum speed when overburdened.
-- Default: 100
InventoryWeight.MinimumSpeed = 100

-- Weight of a dead corpse when carrying it.
InventoryWeight.CorpseWeight = 100
--gamemodes/starwarsrp/gamemode/config/sh_morgue.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--          Morgue | Config          --
---------------------------------------

-- Model for the mourge, to dispose of corpses.
Morgue.Model = "models/props_wasteland/laundry_washer003.mdl"

-- If you should be able to take the corpse out of the morgue.
Morgue.TakeBackOut = true

-- If the corpse of a player is put into the morgue, the player can immediately respawn.
Morgue.AllowRespawnWhenMorgue = true

-- List of all body bags and their settings.
-- Models used should be ragdolls.
-- Default uses this addon: https://steamcommunity.com/sharedfiles/filedetails/?id=909047837
Morgue.BodyBagModels = {
	["models/hospitals/bodybag1.mdl"] = { -- Rep
		Name = "Republic Bodybag",
		Category = "EGM:RP",
		ClassName = "egmrp_bodybag_republic",

		BagCount = 1,

		RagdollOffset = Vector(-50, 0, 0),
		RagdollAngle = Angle(0, 90, 90),
		RagdollBone = "ValveBiped.Bip01_Spine2",

		BodyBagOffset = Vector(0, 0, 0),
		BodyBagAngle = Angle(0, 0, 0),
		BodyBagBone = "midup",

		CreateMorgue = true,
		MorgueModel = "models/reizer_props/srsp/sci_fi/armory_02_2/armory_02_2.mdl",
	},
	["models/hospitals/bodybag2.mdl"] = { -- Bio
		Name = "Biohazard Bodybag",
		Category = "EGM:RP",
		ClassName = "egmrp_bodybag_biohazard",

		BagCount = 1,

		RagdollOffset = Vector(-50, 0, 0),
		RagdollAngle = Angle(0, 90, 90),
		RagdollBone = "ValveBiped.Bip01_Spine2",

		BodyBagOffset = Vector(0, 0, 0),
		BodyBagAngle = Angle(0, 0, 0),
		BodyBagBone = "midup",

		CreateMorgue = true,
		MorgueModel = "models/props_wasteland/laundry_washer003.mdl",
	},
	["models/hospitals/bodybag3.mdl"] = { -- Ziv
		Name = "Bodybag",
		Category = "EGM:RP",
		ClassName = "egmrp_bodybag_civilian",

		BagCount = 1,

		RagdollOffset = Vector(-50, 0, 0),
		RagdollAngle = Angle(0, 90, 90),
		RagdollBone = "ValveBiped.Bip01_Spine2",

		BodyBagOffset = Vector(0, 0, 0),
		BodyBagAngle = Angle(0, 0, 0),
		BodyBagBone = "midup",

		CreateMorgue = false,
		MorgueModel = "models/props_wasteland/laundry_washer003.mdl",
	},
}

-- The offset, that is used, to carry ragdoll.
Morgue.BodyBagCarryOffset = Vector(-35, -8, 15)
Morgue.BodyBagCarryAngle = Angle(180, 90, 90)

-- Body bag bone mods if they are carried by a player.
Morgue.BodyBagCarryBoneMods = {
	["bottom"] = Angle(0, 0, 0),
	["midlow"] = Angle(0, 0, 0),
	["midup"] = Angle(90, 0, 0),
	["top"] = Angle(90, 0, 0),
}
--gamemodes/starwarsrp/gamemode/config/sh_player.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--   Shared | Player System Config   --
---------------------------------------

-- Map data like nice names and colors to usergroups.
PlayerConfig.UserGroupData = {
	["neuling"] = {
		["name"] = "Neuling",
		["color"] = Color(255, 255, 255)
	},

	["user"] = {
		["name"] = "Spieler",
		["color"] = Color(255, 255, 255)
	},

	["erfahren"] = {
		["name"] = "Erfahren",
		["color"] = Color(255, 255, 255)
	},

	["elite"] = {
		["name"] = "Elite",
		["color"] = Color(255, 255, 255)
	},

	["legende"] = {
		["name"] = "Legende",
		["color"] = Color(255, 255, 255)
	},

	["ultimate"] = {
		["name"] = "Ultimate",
		["color"] = Color(255, 255, 255)
	},

	["ewiger"] = {
		["name"] = "Ewiger",
		["color"] = Color(255, 255, 255)
	},

	["eventleiter"] = {
		["name"] = "Eventleiter",
		["color"] = Color(28, 134, 238)
	},

	["testmoderator"] = {
		["name"] = "Test Moderator",
		["color"] = Color(21, 161, 52)
	},

	["moderator"] = {
		["name"] = "Moderator",
		["color"] = Color(238, 154, 0)
	},

	["seniormoderator"] = {
		["name"] = "Senior Moderator",
		["color"] = Color(255, 119, 0)
	},

	["admin"] = {
		["name"] = "Admin",
		["color"] = Color(205, 0, 0)
	},

	["superadmin"] = {
		["name"] = "Superadmin",
		["color"] = Color(238, 58, 140)
	},

	["communityleitung"] = {
		["name"] = "Community Leitung",
		["color"] = Color(238, 58, 140)
	},

	["gruender"] = {
		["name"] = "Gründer",
		["color"] = Color(50, 80, 250)
	},
}

-- Weapons a player is not allowed to drop.
PlayerConfig.NoDropWeapons = {
	"gmod_tool",
	"weapon_physgun",
	"weapon_handcuffed",
	"weapon_fists",
	"climb_swep2",
	"egmrp_unarmed",
	"weapon_npc_notarget",
	"lightsaber_inventory",
	"weapon_swrp_rakghoul_swep",
	"weapon_swrp_rakghoul_blank_swep",
	"weapon_swrp_hiddenblade",
	"weapon_swrp_hiddenblade_swt",
	"weapon_swrp_breathingswep",
	"weapon_swrp_medic_jedi",
	"weapon_swrp_jedihands",
	"weapon_swrp_meditation",
	"weapon_swrp_cloakingdevice_swt",
	"weapon_swrp_cloakingdevice_event",
	"weapon_swrp_wrist_blaster",
	"weapon_swrp_wrist_flame",
	"weapon_swrp_wrist_rocket",
}

-- The minimum group a player needs to have to access the player manager.
PlayerManager.MinAccessGroup = "testmoderator"

-- The default key bind for opening the player manager.
PlayerManager.DefaultKey = KEY_F3

-- The background for the player manager.
PlayerManager.Background = "materials/wallpaper/726it0u9h0j11.jpg"

-- The maximum number of elements a page can have in the player manager. The higher the number the higher the loading time.
PlayerManager.PageSize = 50
--gamemodes/starwarsrp/gamemode/config/sh_ui.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--            UI | Config            --
---------------------------------------

-- Currently Selected Style.
UI.SelectedStyle = "default"

-- The path to the watermark displayed in the UI. (False to disable)
UI.Watermark = "materials/icons/egm_logo.png"

-- The path to the sound to be played when a button is clicked.
UI.ButtonSound = "ui/button.mp3"

-- The maximum distance for which the player info is drawn.
UI.PlayerInfoDistance = 500
--gamemodes/starwarsrp/gamemode/config/sh_voicechat.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--         VoiceChat | Config        --
---------------------------------------

-- Different talkranges.
VoiceChat.TalkRanges = {
    {
        ["name"] = egmt("chat.whisper"),
        ["range"] = 100,
        ["textColor"] = GetColor("white", 200)
    },
    {
        ["name"] = egmt("chat.quiet"),
        ["range"] = 250,
        ["textColor"] = GetColor("green", 200)
    },
    {
        ["name"] = egmt("shared.normal"),
        ["range"] = 500,
        ["textColor"] = GetColor("orange", 200)
    },
    {
        ["name"] = egmt("chat.shout"),
        ["range"] = 1000,
        ["textColor"] = GetColor("red", 200)
    }
}

-- Default talkrange.
VoiceChat.DefaultTalkRange = 2

-- Default key to change the talkrange.
VoiceChat.TalkRangeDefaultKey = KEY_PERIOD
--addons/wos-passiveevent/lua/wos/pes/config/general/sh_permissions.lua:
wOS = wOS or {}
wOS.PES = wOS.PES or {}
wOS.PES.Config = wOS.PES.Config or {}

// What user groups can do every action?
wOS.PES.Config.FullPermissionUsergroup = {
	["gruender"] = true,
	["communityleitung"] = true,
	["superadmin"] = true,
	["admin"] = true,
	["moderator"] = true,
	["testmoderator"] = true,
	["eventleiter"] = true,
}

// What user groups can create new events?
wOS.PES.Config.CreateEventUsersgroup = {
	["gruender"] = true,
	["communityleitung"] = true,
	["superadmin"] = true,
	["admin"] = true,
	["moderator"] = true,
	["testmoderator"] = true,
	["eventleiter"] = true,
}

// What user groups can stop an event
wOS.PES.Config.StopUsergroup = {
	["gruender"] = true,
	["communityleitung"] = true,
	["superadmin"] = true,
	["admin"] = true,
	["moderator"] = true,
	["testmoderator"] = true,
	["eventleiter"] = true,
}

wOS.PES.Config.StartUsergroup = {
	["gruender"] = true,
	["communityleitung"] = true,
	["superadmin"] = true,
	["admin"] = true,
	["moderator"] = true,
	["testmoderator"] = true,
	["eventleiter"] = true,
}

wOS.PES.Config.StartTimeUsergroup = {}

wOS.PES.Config.StartRandomUsergroup = {}

wOS.PES.Config.CanSnoozeUsergroup = {}
--addons/wos-passiveevent/lua/wos/pes/addons/scene/cl_core.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2021
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--

























































































































































local addon = {}

local recordingScenes = {}

local textData = {
	Color(255,150,150),
	"[Scene System] "
}

net.Receive("wOS.PES.Scene.StartRecording", function()

	local entIndex = net.ReadDouble()

	for index, dermaE in pairs(recordingScenes) do
		if !IsValid(dermaE) then continue end
		if table.HasValue( dermaE.data, entIndex ) then return end
		dermaE.data[#dermaE.data + 1] = entIndex
	end
end)

addon.StartRecording = function(dermaElement)
	for index, dermaE in pairs(recordingScenes) do
		if IsValid(dermaE) then continue end
		table.RemoveByValue(recordingScenes, dermaE)
	end

	local len = #recordingScenes

	recordingScenes[len + 1] = dermaElement

	if len == 0 then
		chat.AddText(textData[1], textData[2], color_white, "Please spawn props and position them how you want to. Once you are finished open the menu again and press the recording button, ", Color(150,150,150), "if you dont do this it won't save!!!")
	end

	chat.AddText( textData[1], textData[2], color_white, tostring(len + 1), " Active Recordings")

	local decomp = dermaElement.data or {}
	local comp = wOS.SFS_EXTERN:Compress( decomp )

	local checksum = SysTime()

    local NET_CAP = 55000
    if #comp < NET_CAP then
        net.Start( "wOS.PES.Scene.StartRecording" )
            net.WriteDouble( checksum )
            net.WriteUInt( 1, 32 )
            net.WriteUInt( 1, 32 )
            net.WriteUInt( #comp, 32 )
            net.WriteData( comp )
        net.SendToServer()
        return
    end

    local total_segments = math.ceil( #comp / NET_CAP )

    for i=1, total_segments do
        local lim
        if i != total_segments then
            lim = i*NET_CAP
        end
		local str = string.sub( comp, ( (i - 1)*NET_CAP ) + 1, lim )
		timer.Simple( (i-1)*0.5, function() 
			net.Start( "wOS.PES.Scene.StartRecording" )
				net.WriteDouble( checksum )
				net.WriteUInt( total_segments, 32 )
				net.WriteUInt( i, 32 )
				net.WriteUInt( #str, 32 )
				net.WriteData( str )       
			net.SendToServer()
		end )
    end

end

addon.StopRecording = function(dermaElement)
	table.RemoveByValue(recordingScenes, dermaElement)
	if #recordingScenes > 0 then return end
	net.Start("wOS.PES.Scene.StopRecording")
	net.SendToServer()
end

hook.Add("HUDPaint", "wOS.PES.SceneRecord", function()
	if #recordingScenes <= 0 then return end
	draw.SimpleText("You are currently recording a scene","DermaLarge", ScrW()/2, ScrH()- 100, color_white, 1)
end)

local function ClearRecording()
	net.Start( "wOS.PES.Scene.ClearRecording" )
	net.SendToServer()
	recordingScenes = {}
end

hook.Add( "wOS.PES.OnCreatorClose", "wOS.PES.Scene.DeleteStuff", function( creator_type )
	if #recordingScenes <= 0 then return end
	ClearRecording()
end )

hook.Add( "wOS.PES.OnNodeDelete", "wOS.PES.Scene.DeleteStuff", function( node )
	timer.Simple( 0, function()
		if #recordingScenes <= 0 then return end
		for k, dea in pairs( recordingScenes ) do
			if IsValid( dea ) then continue end
			recordingScenes[ k ] = nil
		end
		if #recordingScenes > 0 then return end
		ClearRecording()
	end )
end ) 

wOS.PES.Modules:RegisterAddon( "scene", addon )
--addons/wos-passiveevent/lua/wos/pes/vars/darkrpjob.lua:

--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2021
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--


local VAR = {}

VAR.Name = "DarkRPJob"
VAR.IsValid = function(varTable, value)

    return true
end

VAR.DermaElement = function(varTable, varData)
    local element = vgui.Create("DComboBox")

    for index, jobData in pairs(RPExtraTeams) do
        element:AddChoice(jobData.name, jobData.name == varData)
    end

    return element
end

VAR.GetValue = function(dermaElement)
    return dermaElement:GetSelected()
end

VAR.OnStart = function(node, varData, var)

end

VAR.OnEnd = function(node, varData, var)

end


return VAR, (!DarkRP)

--addons/wos-passiveevent/lua/wos/pes/vars/tentitydatacopy.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2021
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--



local VAR = {}

VAR.Name = "TableEntityData"
VAR.DirtyValidate = true

VAR.ToolTips = {
    { text = "Add the entity data of the entity you are aiming at to the list", key = "gui/lmb.png", },
    { text = "Remove the last added entity data from the list", key = "gui/rmb.png", },
}

VAR.IsValid = function(varTable, value)

    if varTable.Internal then return false end
    if not value or #value < 1 then
        return false
    end
    
    for index, data in pairs(value) do
        if not data.Index then continue end
        local ent = ents.GetByIndex(data.Index)
        if IsValid(ent) then
            if ent:CreatedByMap() then continue end
            value[index] = wOS.PES.ReadEntity(ent)
        end
    end

    return true
end

VAR.UseTool = true

local function OpenOverlayEditor( id, vardata, base_panel )
    local panel = vgui.Create("DPanel")
    panel:SetSize( ScrW(), ScrH() )
    panel.Think = function( pan ) if not IsValid( base_panel ) then pan:Remove() end end
    panel.Paint = function( pan, ww, hh )
        draw.RoundedBox(0, 0, 0, ww, hh, Color( 0, 0, 0, 200 ) )
    end
    panel:MakePopup()

    local frame = vgui.Create( "DFrame", panel )
    frame:ShowCloseButton( true )
    frame:SetTitle("")
    frame:SetDraggable( false )
    frame:SetSize( ScrW()*0.25, ScrH()*0.4 )
    frame:Center()
    frame.OnClose = function( pan )
        panel:Remove()
    end
	frame.Think = function( pan )
		pan:MoveToFront()
	end
 
    local editor = vgui.Create( "WOS_PES_DATACOPY_EDITOR", frame )
    editor:Dock( FILL )
    editor:SetVariableData( vardata )
    editor:SetBasePanel( base_panel )

    local delete_butt = vgui.Create( "DButton", frame )
    delete_butt:SetText( "Delete Entity" )
    delete_butt:Dock( BOTTOM )
    delete_butt.DoClick = function( pan )
        base_panel.Data[ id ] = nil
        base_panel:RefreshList()
        panel:Remove()
    end

    local save_butt = vgui.Create( "DButton", frame )
    save_butt:SetText( "Save Changes" )
    save_butt:Dock( BOTTOM )
    save_butt.DoClick = function( pan )
        base_panel.Data[ id ] = editor:GetVariableData()
        base_panel:RefreshList()
        panel:Remove()
    end

end

VAR.DermaElement = function(varTable, varData)
    varData = varData or {}
    local panel = vgui.Create("DPanel")
    panel:SetTall( 180 )
    
    panel.Data = {}
    for index, data in pairs( varData ) do
        panel.Data[ index ] = data
    end

    local listView = vgui.Create("DListView", panel)
    listView:Dock( FILL )
    listView:AddColumn("Entity")
    listView.RefreshList = function( pan )
        pan:Clear()
        if not panel.Data or #panel.Data < 1 then
            pan:AddLine( "Entities needs to be selected!" )
            return
        end

        for id, edata in pairs( panel.Data or {} ) do
            local name = edata.Class or ( "Entity " .. edata.Index )
            local line = pan:AddLine( name )
            line.ID = id
            line.Data = edata
        end
        
    end

    listView.OnRowRightClick = function( pan, id, line )
       OpenOverlayEditor( line.ID, line.Data, panel )
    end

    listView:RefreshList()
    panel.RefreshList = function() listView:RefreshList() end

    return panel -- make multiple of these through a base panel
end

VAR.GetValue = function(dermaElement)
    if dermaElement.Data then
        //local ent = dermaElement.Data[1]
        --if IsValid(ent) then dermaElement:SetEntity(ent) end
        return dermaElement.Data
    end
end

VAR.PrimaryAttack = function(wep, ply, dermaElement)
    dermaElement.Data = dermaElement.Data || {}

    local ent = ply:GetEyeTrace().Entity
    if IsValid(ent) then
        local allowed = hook.Call( "wOS.CombatSim.CanPlaceEntity", nil, wep, ply, ent:GetPos() )
        if isbool( allowed ) and allowed == false then return end
        dermaElement.Data[#dermaElement.Data + 1] = {
            Position = ent:GetPos(),
            Index = ent:EntIndex()
        }
        ply:ChatPrint( "Entity Added: " .. ent:GetClass() )
        dermaElement:RefreshList()
    end
end

VAR.SecondaryAttack = function(wep, ply, dermaElement)
    dermaElement.Data = dermaElement.Data || {}
    dermaElement.Data[#dermaElement.Data] = nil
end

/*
		Angles	=	-0.125 104.219 0.125
		Class	=	prop_physics
		Color:
				a	=	255
				b	=	255
				g	=	255
				r	=	255
		Model	=	models/props_borealis/bluebarrel001.mdl
		Pos	=	-3299.468750 -2135.687500 90.125000
		SubMaterials:
*/

VAR.Draw3D = function(wep, ply, element)
    local tVec = element.Data || {}

    for index, ent in ipairs(tVec) do
        if not isvector(ent.Position) then continue end

        local vec = ent.Position

        local top = Vector(vec.x, vec.y, vec.z + 200)
        render.DrawLine(vec, top, Color(255, 255, 255), false)
    end
end

return VAR

--addons/wos-passiveevent/lua/wos/pes/core/cl_core.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2021
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--

























































































































































wOS = wOS || {}
wOS.PES = wOS.PES || {}
wOS.PES.Triggers = wOS.PES.Triggers || {}
wOS.PES.Triggers.Data = wOS.PES.Triggers.Data || {}
wOS.PES.Nodes = wOS.PES.Nodes || {}
wOS.PES.Nodes.Data = wOS.PES.Nodes.Data || {}

if wOS.PES.GetActiveMenu then return end

surface.CreateFont( "wOS.PES.NodeText", {
	font = "Arial",
	extended = true,
	size = 25*(ScrH()/1200),
	weight = 1300,
} )

surface.CreateFont( "wOS.PES.CategoryText", {
	font = "Arial",
	extended = true,
	size = 20*(ScrH()/1200),
	weight = 1300,
} )

local nodeMenu
local mainMenu
local missionMenu

local currentPanel

local editingNode
local editingVar

function wOS.PES:GetEditingVar()
    return editingVar
end

function wOS.PES:SetEditingVar(node, varTable)
    local parent = self:GetNodeMenu()
    if not parent then return end
    editingVar = node.varDerma[varTable.Name]
    editingNode = node
    parent:Hide()
end

function wOS.PES:SetActiveMenu( pan )
    currentPanel = pan
end

function wOS.PES:GetActiveMenu()
    return currentPanel
end

function wOS.PES:SetNodeMenu( pan )
    nodeMenu = pan
end

function wOS.PES:GetNodeMenu()
    return nodeMenu
end

function wOS.PES:IsEditingVar()
    local curr_pan = self:GetActiveMenu()
    local nmenu = self:GetNodeMenu()
    local evar = self:GetEditingVar()
    return IsValid( evar ) and IsValid( nmenu ) and curr_pan == nmenu
end

// The entry point into the menus
function wOS.PES:OpenMenu()
    if self:IsEditingVar() then
        local element = wOS.PES:GetEditingVar()
        local varTable = element.varTable
        local varType = wOS.PES.Vars:Get(varTable.Type)
        if varType then
            local value = varType.GetValue(element)
            if value != nil then
                editingNode:SetVar(varTable.Name, value)
            end
        end
    end

    local cur_pan = self:GetActiveMenu()
    if IsValid(cur_pan) then
        if cur_pan.menu then
            if not cur_pan.menu.CreationType or cur_pan.menu.CreationType == WOS_PES.CREATOR.EVENT then 
                cur_pan:Show()
                return
            end
        end
        cur_pan:Remove()
    end

    wOS.PES:OpenMainMenu()
end

// This is the first menu that is shown or the fallback
function wOS.PES:OpenMainMenu()
    if IsValid(mainMenu) then
        mainMenu:Show()
    else
        local pnl = vgui.Create("DFrame")
        pnl:SetTitle( "PES Toolgun" )
        pnl:SetSize(256,512)
        pnl:Center()
        pnl:MakePopup()
        pnl:SetDraggable(false)

        local startMission = vgui.Create("DButton", pnl)
        startMission:SetHeight(128)
        startMission:SetText("Start Event")
        startMission:Dock(TOP)
        startMission:DockPadding(0,3,0,0)
        startMission.DoClick = function()
            mainMenu:Hide()
            wOS.PES:OpenMissionMenu()
        end

        local makeEvent = vgui.Create("DButton", pnl)
        makeEvent:SetHeight(128)
        makeEvent:Dock(TOP)
        makeEvent:DockPadding(0,3,0,3)
        makeEvent:SetText("List Events")

        makeEvent.DoClick = function()
            mainMenu:Hide()
            wOS.PES:OpenNodeMenu()
        end

		local adminMenu = vgui.Create("DButton", pnl)
		adminMenu:SetHeight(128)
		adminMenu:Dock(TOP)
		adminMenu:DockPadding(0,3,0,3)
		adminMenu:SetText("Admin Menu")

		adminMenu.DoClick = function()
			wOS.PES:OpenAdminList()
		end

        mainMenu = pnl
    end

    self:SetActiveMenu( mainMenu )
end

local makeEventButton = function(name, parent)

    local info = vgui.Create("DButton", parent)
    info:SetText(name)
    info:Dock(TOP)
    info:DockMargin(0, 0, 0, 10)

    info.Think = function( pan )
		if name == "+" then return end
        if not IsValid(parent) then return end
        if not parent.MissionName then return end
        if parent.MissionName[name] then return end
        pan:Remove()
    end

    info.DoClick = function( pan )
       parent.EventName = name
    end

    return info
end

// This is the admin selection menu
function wOS.PES:OpenAdminList()
    local cur_pan = self:GetActiveMenu()
	if IsValid(cur_pan) then
		cur_pan:Remove()
	end

	local pnl = vgui.Create("DFrame")
	pnl:SetTitle( "PES Toolgun" )
	local size = ScrH()*(512/1080)
	pnl:SetSize(size/2, size)
	pnl:Center()
	pnl:MakePopup()
    pnl:SetDraggable(false)
	
	self:SetActiveMenu( pnl )

    local startMission = vgui.Create("DButton", pnl)
    startMission:SetHeight(128)
    startMission:SetText("PES Admin Settings")
    startMission:Dock(TOP)
    startMission:DockPadding(0,3,0,0)
    startMission.DoClick = function()
        pnl:Hide()
        self:SetActiveMenu( self:OpenAdminSettings() )
    end

    local makeEvent = vgui.Create("DButton", pnl)
    makeEvent:SetHeight(128)
    makeEvent:Dock(TOP)
    makeEvent:DockPadding(0,3,0,3)
    makeEvent:SetText("List Scheduled Events")

    makeEvent.DoClick = function()
        pnl:Hide()
        self:SetActiveMenu( self:OpenScheduledMenu() )
    end

    local adminMenu = vgui.Create("DButton", pnl)
    adminMenu:SetHeight(128)
    adminMenu:Dock(TOP)
    adminMenu:DockPadding(0,3,0,3)
    adminMenu:SetText("Event Viewer")

    adminMenu.DoClick = function()
        wOS.PES.RequestOpenAdminPreMenu()
    end

end

function wOS.PES:OpenAdminActiveList( events )

    local cur_pan = self:GetActiveMenu()
	if IsValid(cur_pan) then
		cur_pan:Remove()
	end

    local bw, bh = ScrW()*0.27, ScrH()*0.25

	local base = vgui.Create("DFrame")
	base:SetSize( bw, bh )
	base:Center()
	base:MakePopup()
	base:SetDraggable(false)
	base:SetTitle("")
	base:ShowCloseButton(false)
	base.Paint = function(self, w, h)
		surface.SetDrawColor(35.5,35.5,35.5)
		surface.DrawRect(0,0, w, h)

        draw.SimpleText("Currently Running Events", "wOS.PES.NodeText", w*0.02, h*0.04, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
	end

	local close = vgui.Create("DButton", base)
	close:SetSize(bh*0.08,bh*0.08)
	close:SetPos(bw - bh*0.087, 0)
	close:SetText("")
	close.Paint = function(self, w, h)
		local col = Color(255, 255, 255, (self.Hovered and 255) or 150)
        surface.SetDrawColor(col)
		surface.DrawLine(0,0, w, h)
		surface.DrawLine(w,0, 0, h)
    end
	close.DoClick = function() base:Remove() end

	self:SetActiveMenu( base )

    local tabsheet = vgui.Create( "DPropertySheet", base )
    tabsheet:Dock( FILL )

    local manual_sheet = vgui.Create( "DScrollPanel", tabsheet )
    //manual_sheet.Paint = function( self, w, h ) draw.RoundedBox( 4, 0, 0, w, h, Color( 0, 128, 255, self:GetAlpha() ) ) end 
    tabsheet:AddSheet( "Manual Events", manual_sheet, "icon16/joystick.png" )

    local random_sheet = vgui.Create( "DScrollPanel", tabsheet )
    //random_sheet.Paint = function( self, w, h ) draw.RoundedBox( 4, 0, 0, w, h, Color( 255, 128, 0, self:GetAlpha() ) ) end 
    tabsheet:AddSheet( "Random Events", random_sheet, "icon16/arrow_switch.png" )

    local sched_sheet = vgui.Create( "DScrollPanel", tabsheet )
    //sched_sheet.Paint = function( self, w, h ) draw.RoundedBox( 4, 0, 0, w, h, Color( 0, 128, 255, self:GetAlpha() ) ) end 
    tabsheet:AddSheet( "Scheduled Events", sched_sheet, "icon16/clock.png" )

    local sim_sheet = vgui.Create( "DScrollPanel", tabsheet )
    //sim_sheet.Paint = function( self, w, h ) draw.RoundedBox( 4, 0, 0, w, h, Color( 255, 128, 0, self:GetAlpha() ) ) end 
    tabsheet:AddSheet( "Simulations", sim_sheet, "icon16/computer.png" )

    for id, dat in pairs( events ) do
        local name = dat[1]
        local etype = dat[2]
        local sim = dat[3]

        if sim then
            sim = sim .. " - "
        else
            sim = ""
        end

        local ebutton = vgui.Create( "DButton" )
        ebutton.ID = id 
        ebutton.Name = sim .. name
        ebutton.Type = etype
        ebutton:SetText( ebutton.Name )
        -- ebutton.Paint = function( pan, ww, hh )

        -- end
        ebutton.DoClick = function( pan )
            wOS.PES.RequestOpenAdminViewer( pan.ID )
        end

        if etype == WOS_PES.EVENT.MANUAL then
            manual_sheet:AddItem( ebutton )
        elseif etype == WOS_PES.EVENT.RANDOM then
            random_sheet:AddItem( ebutton )
        elseif etype == WOS_PES.EVENT.SCHEDULED then
            sched_sheet:AddItem( ebutton )
        elseif etype == WOS_PES.EVENT.SIMULATION then
            sim_sheet:AddItem( ebutton )
        else
            ebutton:Remove()
            continue
        end
        ebutton:Dock( TOP )
        ebutton:DockMargin( 0, 0, 0, 5 )
    end

    -- local dum_sheet = vgui.Create( "DScrollPanel", tabsheet )
    -- dum_sheet.Paint = function( self, w, h ) draw.RoundedBox( 4, 0, 0, w, h, Color( 0, 128, 255, self:GetAlpha() ) ) end 
    -- tabsheet:AddSheet( "Quests", dum_sheet, "icon16/wand.png" )
end

// Admin viewer of current event
function wOS.PES:OpenAdminEventViewer( id, nodes )
    local cur_pan = self:GetActiveMenu()
	if IsValid(cur_pan) then
		cur_pan:Remove()
	end

	local base = vgui.Create("DFrame")
	base:SetSize(ScrW(), ScrH())
	base:Center()
	base:MakePopup()
	base:SetDraggable(false)
	base:SetTitle("")
	base:ShowCloseButton(false)
	base.Paint = function(self, w, h)
		surface.SetDrawColor(35.5,35.5,35.5)
		surface.DrawRect(0,0, w, h)
	end
	local close = vgui.Create("DButton", base)
	close:SetSize(20,20)
	close:SetPos(ScrW()-20, 0)
	close:SetText("")
	close.Paint = function(self, w, h)
		local col = Color(255, 255, 255, (self.Hovered and 255) or 150)
        surface.SetDrawColor(col)
		surface.DrawLine(0,0, w, h)
		surface.DrawLine(w,0, 0, h)
    end
	close.DoClick = function() base:Remove() end

	local mini = vgui.Create("DButton", base)
	mini:SetSize(20,20)
	mini:SetPos(ScrW()-45, 0)
	mini:SetText("")
	mini.Paint = function(self, w, h)
		local col = Color(255, 255, 255, (self.Hovered and 255) or 150)

		surface.SetDrawColor(col)
		surface.DrawLine(0,h/2, w, h/2)
	end
	mini.DoClick = function() base:Hide() end


	base.menu = vgui.Create("WOS_PES_ViewNodeBG", base)
    local menu = base.menu
    
	menu:Dock(FILL)
    menu:DockMargin(0,0,0,0)
    

	local but = vgui.Create("DButton", base)
	but:SetPos(base:GetWide() - 100, 60)
	but:SetSize(90, 40)
	but:SetText("Stop Current Event")
	but.DoClick = function()
		wOS.PES.RequestStop( id )
        close:DoClick()
	end

	for index, data in ipairs(nodes) do
		local button = menu:AddNode( id )
		button.Links = data.Links
		button.Active = data.Active
		button.Type = data.Type
		button:SetPos(data.Pos.x, data.Pos.y)
		button:SetText("")
        button.TextName = data.Name

	    button:FormLinks()
	end

	self:SetActiveMenu( base )

    // Added some cleansing to the timer so we don't have it residually there
    // Also forced it to close the menu through the close button if the case of no data
	timer.Create("wOS.PES.Admin.Sync", 1, 0, function()

        local cur_pan = wOS.PES:GetActiveMenu()
        if !IsValid(cur_pan) then timer.Destroy( "wOS.PES.Admin.Sync") return end
        if !cur_pan.menu then timer.Destroy( "wOS.PES.Admin.Sync") return end
        if not cur_pan.menu.CreationType then timer.Destroy( "wOS.PES.Admin.Sync") return end 
        if cur_pan.menu.CreationType != WOS_PES.CREATOR.EVENT then timer.Destroy( "wOS.PES.Admin.Sync") return end

        wOS.PES.RequestAdminSync(id, function(len)
            local nodes = net.ReadActivePESEvent()
            if #nodes <= 0 then
                for index, node in pairs(menu.Nodes) do
                    node:Remove()
                end
                timer.Destroy( "wOS.PES.Admin.Sync") 
                close:DoClick()
                return 
            end
            if not menu then return end
            if not menu.Nodes then return end
            for index, data in pairs(nodes) do
                if not IsValid(menu.Nodes[index]) then continue end
                menu.Nodes[index].Active = data.Active
            end
        end)
	end)
end

// Build editor menu
function wOS.PES:OpenNodeMenu( event, dirty, force_reset )
	local nMenu = wOS.PES:GetNodeMenu()
    if IsValid(nMenu) then
        if not event and not force_reset then
            nMenu:Show()
            self:SetActiveMenu( nMenu )
            return
        else
            nMenu:Remove()
        end
    end

    local base = vgui.Create("DFrame")
    base:SetSize(ScrW(), ScrH())
    base:Center()
    base:MakePopup()
    base:SetDraggable(false)
    base:SetTitle("")
    base:ShowCloseButton(false)
    base:SetZPos( 5 )
    base.Paint = function(self, w, h)
        surface.SetDrawColor(35.5, 35.5, 35.5)
        surface.DrawRect(0,0, w, h)
    end

    local close = vgui.Create("DButton", base)
    close:SetSize(20,20)
    close:SetPos(ScrW()-20, 0)
    close:SetText("")
    close:SetZPos( 10 )
    close.Paint = function(self, w, h)
        local col = Color(255, 255, 255, (self.Hovered and 255) or 150)

        surface.SetDrawColor(col)
        surface.DrawLine(0,0, w, h)
        surface.DrawLine(w,0, 0, h)
    end
    close.DoClick = function() hook.Call( "wOS.PES.OnCreatorClose", nil, WOS_PES.CREATOR.EVENT ) base:Remove() end

    local mini = vgui.Create("DButton", base)
    mini:SetSize(20,20)
    mini:SetPos(ScrW()-45, 0)
    mini:SetText("")
    mini:SetZPos( 10 )
    mini.Paint = function(self, w, h)
        local col = Color(255, 255, 255, (self.Hovered and 255) or 150)

        surface.SetDrawColor(col)
        surface.DrawLine(0,h/2, w, h/2)
    end
    mini.DoClick = function() base:Hide() end

    local scroll = vgui.Create("DScrollPanel", base)
    scroll:SetWide(100)
    scroll:SetTall( base:GetTall() )
    scroll:Dock(LEFT)
    scroll:DockPadding(5,5,5,5)
	scroll:DockMargin(16,16,16,16)
    scroll:SetZPos( 10 )
    scroll.Paint = function( pan, ww, hh )
		draw.RoundedBox(4, 0, 0, ww, hh, Color(0, 0, 0, 150))
		draw.RoundedBox(4, 4, 4, ww-8, hh-8, Color(36,36,36))
		draw.RoundedBox(4, 4, 4, ww-8, hh-8, Color(255,255,255,100))
    end
    base.scroll = scroll

	local menu = vgui.Create("WOS_PES_NodeBG", base)
	menu:Dock(FILL)
	menu:DockMargin(0,0,0,0)
	base.menu = menu

    if not event then
	    local start = menu:CreateStartNode()
    else
        menu.Importable = event.Importable
        menu.Name = event.Name
        menu.Description = event.Description
        menu.random = event.random
        menu.DirtyNodes = dirty

        for index, node in pairs(event.Nodes) do
            
            local pNode
            if index == 1 then
                pNode = menu:CreateStartNode()
            else
                pNode = menu:AddNode()
                pNode.Type = node.Type
            end

            pNode:SetPos(node.Pos.x, node.Pos.y )
            
            if pNode.Type != node.Type then continue end
            pNode:SetVars(node._vars, dirty)
		    pNode:SetDisableVars(node._toggles, dirty)
        end

        for index, node in pairs(event.Nodes) do
            if node.Triggers then
                for triggerName, panelTable in pairs(node.Triggers) do
                    for _, otherID in pairs(panelTable) do
                        local pnl, oPnl = menu.Nodes[index], menu.Nodes[otherID]
                        menu:MakeLink(pnl, oPnl, triggerName)
                    end
                end
            end
        end

        for _, node in pairs(menu.Nodes) do
            node:CreateLinks()
        end
    end

    local info = vgui.Create("DButton", base.scroll)
    info:SetText("Event Manager")
    info:Dock(TOP)
    info:DockMargin(0, 0, 0, 10)
    info.DoClick = function()
        wOS.PES.GetImportableEvents( function( events )
            local menu = base.menu
            if not menu then return end
            local tot = {}
            for _, data in pairs( events ) do
                data.Category = data.Category or "Event"
                table.insert( tot, data )
            end
            wOS.PES.GetImportableSimulations( function( sims )
                for _, data in pairs( sims ) do
                    data.Category = data.Category or "Simulation"
                    data.IsSimulation = true
                    data.Settings = nil
                    table.insert( tot, data )
                end
                menu:OpenEventSelector( tot )
            end )
        end, true )
    end

    if event then
        local delin = vgui.Create("DButton", base.scroll)
        delin:SetText("Delete Event")
        delin:Dock(TOP)
        delin:DockMargin( 0, 0, 0, 10 )
        delin.DoClick = function()
            menu:OpenEventDeleter()
        end
    end

    self:SetNodeMenu( base )
    self:SetActiveMenu( base )
end
// Starting an event
function wOS.PES:OpenMissionMenu()
    if IsValid(missionMenu) then
        missionMenu:Show()
        missionMenu:RequestUpdate()
    else
        local hh = ScrH() * 0.4

        local base = vgui.Create("DFrame")
        base:SetTitle( "Mission Menu" )
        base:SetSize(200 + 100, hh)
        base:Center()
        base:MakePopup()
        base:SetDraggable(false)

		base.Paint = function(self, w, h)
			surface.SetDrawColor(0,0,0)
			surface.DrawRect(0,0, w,h)
			if base.scroll and base.scroll.EventName then
				draw.SimpleText(base.scroll.EventName, "DermaDefault", w * 0.3, 10 )
			end
		end

        local scrollpanel = vgui.Create("DScrollPanel", base)
        scrollpanel:SetSize(180, hh - 30)
        scrollpanel:SetPos(10, 30)
        wOS.PES.RequestEventList(function(missionNames)
            base.scroll.MissionName = {}
            for index, name in pairs(missionNames) do
                makeEventButton(name, base.scroll)
                base.scroll.MissionName[name] = true
            end
        end)

		-- instant

		local button = vgui.Create("DButton", base)
		button:SetText("Start Now")
		button:SetSize(80, 30)
		button:SetPos(210, 30)
		button.DoClick = function()
			if base.scroll.EventName then
				wOS.PES.RequestEventStart(base.scroll.EventName)
			end
		end

		local timeStart = vgui.Create("DButton", base)
		timeStart:SetPos(210, 110)
		timeStart:SetSize(80, 30)
		timeStart:SetText("Schedule Later")

		timeStart.DoClick = function()
			if not base.scroll.EventName then return end
			local pnl = vgui.Create("DFrame")
			pnl:SetSize(ScrW()*0.5, ScrH() * 0.5)
			pnl:Center()
			pnl:MakePopup()
            pnl:SetTitle( "Event Scheduler" )
			pnl.Think = function( pan )
				pan:MoveToFront()
			end

			local calendar = vgui.Create("wOSCalendar", pnl)
			calendar:Dock(FILL)

			local confirm = vgui.Create("DButton", pnl)
			confirm:Dock(BOTTOM)
			confirm:DockMargin(5,5,5,5)
			confirm:SetTall(40)
			confirm:SetText("Start Event")
			confirm.DoClick = function( pan )
				wOS.PES.RequestEventStartTime(base.scroll.EventName, calendar:GetTime() )
				base:Remove()
				pan:Remove()
			end
		end

        base.scroll = scrollpanel
        missionMenu = base

        function missionMenu:RequestUpdate()
            wOS.PES.RequestEventList(function(missionNames)
                local oldTable = table.Copy(missionMenu.scroll.MissionName)

                local newTable = {}

                for index, name in pairs(missionNames) do
                    if !oldTable[name] then
                        makeEventButton(name, missionMenu.scroll)
                    end
                    newTable[name] = true
                end
                missionMenu.scroll.MissionName = newTable
            end)
        end
    end
end


// Helper functions
local function charWrap(text, pxWidth)
    local total = 0

    text = text:gsub(".", function(char)
        total = total + surface.GetTextSize(char)

        if total >= pxWidth then
            total = 0
            return "\n" .. char
        end

        return char
    end)

    return text, total
end

function wOS.PES.WrapText(text, font, pxWidth)
    local total = 0

    surface.SetFont(font)

    local spaceSize = surface.GetTextSize(' ')
    text = text:gsub("(%s?[%S]+)", function(word)
            local char = string.sub(word, 1, 1)
            if char == "\n" or char == "\t" then
                total = 0
            end

            local wordlen = surface.GetTextSize(word)
            total = total + wordlen

            if wordlen >= pxWidth then
                local splitWord, splitPoint = charWrap(word, pxWidth - (total - wordlen))
                total = splitPoint
                return splitWord
            elseif total < pxWidth then
                return word
            end

            if char == ' ' then
                total = wordlen - spaceSize
                return '\n' .. string.sub(word, 2)
            end

            total = wordlen
            return '\n' .. word
        end)

    return text
end


hook.Add("PostDrawOpaqueRenderables", "wOS.CombatSim.EditingVar", function()
	local ply = LocalPlayer()

	local wep = ply:GetActiveWeapon()
    if not IsValid( wep ) then return end
	if wep:GetClass() != "wos_pes_tool" and wep:GetClass() != "wos_simulation_tool" then return end

    if not wOS.PES:IsEditingVar() then return end
    
    local element = wOS.PES:GetEditingVar()

    local varTable = element.varTable
    local varType = wOS.PES.Vars:Get(varTable.Type)
    if varType and varType.Draw3D then
        varType.Draw3D(wep, wep.Owner, element)
    end
end)
--addons/wos-passiveevent/lua/wos/pes/core/sh_sfs_extern.lua:
if wOS and wOS.SFS_EXTERN then return end

-- SFS (Srlion's Fast Serializer)
-- we try to avoid NYI operations in luajit as much as possible
-- unforunately, we can't avoid all of them in luajit 2.0.5 - pairs & table.concat
-- https://github.com/tarantool/tarantool/wiki/LuaJIT-Not-Yet-Implemented
-- we don't use string concating because it's also NYI in luajit 2.0.5
-- we never error so we don't get blacklisted by the jit compiler
-- errors return strings instead of throwing errors

-- this is intentionally made for net messages, so you don't have to use pcall to check if there are any errors
-- you should use this without using util.Compress, as this just adds one byte to each value, you will probably end up with a larger string if you compress it

-- this idea is from messagepack which is really smart
-- small numbers (0 ~ 127) and (-32 ~ -1) are encoded as a single byte
-- tables and arrays are encoded with a prefix byte, which is the number of elements in the table or array, but it can be one byte if it's less than 16
-- strings are encoded with a prefix byte, which is the length of the string, but it can be one byte if it's less than 32

local math = math
local HUGE = math.huge
local floor = math.floor
local internal_type = type
local IsColor = IsColor
local type = function(v)
    if IsColor(v) then
        return "Color"
    end
    return internal_type(v)
end

-- string.char is not jit compiled in luajit 2.0.5
local chars = {}; do
    for i = 0, 255 do
        chars[i] = string.char(i)
    end
end

local MAX_NUMBER = 1.7976931348623e+308
local MIN_NUMBER = -MAX_NUMBER

---
local POSITIVE_INT = 0x00
local POSITIVE_INT_END = 0x7f

local TABLE_FIXED = 0x80
local TABLE_FIXED_END = 0x8f

local ARRAY_FIXED = 0x90
local ARRAY_FIXED_END = 0x9f

local STR_FIXED = 0xa0
local STR_FIXED_END = 0xbf

local NIL = 0xc0
local FALSE = 0xc1
local TRUE = 0xc2

local UINT_8 = 0xc3
local UINT_16 = 0xc4
local UINT_32 = 0xc5
local UINT_52 = 0xc6

local NINT_8 = 0xc7
local NINT_16 = 0xc8
local NINT_32 = 0xc9
local NINT_52 = 0xca

local DOUBLE = 0xcb

local STR_8 = 0xcc
local STR_16 = 0xcd
local STR_32 = 0xce

local ARRAY_8 = 0xcf
local ARRAY_16 = 0xd0
local ARRAY_32 = 0xd1

local TABLE_8 = 0xd2
local TABLE_16 = 0xd3
local TABLE_32 = 0xd4

local VECTOR = 0xd5
local ANGLE = 0xd6

local ENTITY = 0xd7
local PLAYER = 0xd8

local COLOR = 0xd9

-- this was added in version 2.0.0
-- it's used for arrays that start at 0, I'm not sure if lua 5.1 has same behavior as luajit 2.0.5
-- but luajit 2.0.5 supports starting arrays at 0 index, so checking if table is an array or not gets messed up and output is wrong
-- so if you supply local t = {[0] = 0, 1, 2, 3} and do next(t, #t) it will return (nil, nil) instead of (0, 0)
local ARRAY_ZERO_BASED_INDEX = 0xda

local FREE_FOR_CUSTOM = 0xdb
local FREE_FOR_CUSTOM_END = 0xdf

local NEGATIVE_INT = 0xe0
local NEGATIVE_INT_END = 0xff
---

local encoders = {}
local Encoder = {
    encoders = encoders
}
do
    local pairs = pairs
    local next = next
    local ceil = math.ceil
    local log = math.log
    local concat = table.concat
    local write, write_unsigned, write_double

    -- garry's mod related
    local Vector_Unpack, Angle_Unpack
    local Entity_EntIndex, Player_UserID
    if FindMetaTable then
        Vector_Unpack = FindMetaTable("Vector").Unpack
        Angle_Unpack = FindMetaTable("Angle").Unpack

        Entity_EntIndex = FindMetaTable("Entity").EntIndex
        Player_UserID = FindMetaTable("Player").UserID
    end
    --

    local get_encoder = function(buf, t)
        local encoder = encoders[type(t)]
        if encoder == nil then
            write(buf, "Unsupported type: ")
            write(buf, type(t))
            return nil
        end
        return encoder
    end

    local buffer = {
        [0] = 0 -- buffer length
    }

    -- this function is obviously not jit compiled in luajit 2.0.5 but internal functions are
    function Encoder.encode(val, max_cache_size)
        max_cache_size = max_cache_size or 2000
        buffer[0] = 0

        local encoder = get_encoder(buffer, val)
        if encoder == nil then
            return nil, concat(buffer, nil, buffer[0] - 1, buffer[0])
        end

        if encoder(buffer, val, arg) == true then -- if it returns true, it means there was an error
            -- error is never compiled, so we never error to avoid that
            -- concating in luajit 2.0.5 is NYI, we make sure that all encoders' functions get jit compiled
            return nil, concat(buffer, nil, buffer[0] - 1, buffer[0])
        end

        local result = concat(buffer, nil, 1, buffer[0])

        if #buffer > max_cache_size then
            buffer = {
                [0] = 0 -- buffer length
            }
        end

        return result
    end

    function Encoder.encode_array(arr, len, max_cache_size)
        max_cache_size = max_cache_size or 2000
        buffer[0] = 0

        if encoders.array(buffer, arr, len) == true then -- if it returns true, it means there was an error
            -- error is never compiled, so we never error to avoid that
            -- concating in luajit 2.0.5 is NYI, we make sure that all encoders' functions get jit compiled
            return nil, concat(buffer, nil, buffer[0] - 1, buffer[0])
        end

        local result = concat(buffer, nil, 1, buffer[0])

        if #buffer > max_cache_size then
            buffer = {
                [0] = 0 -- buffer length
            }
        end

        return result
    end

    function write(buf, chr)
        local buf_len = buf[0] + 1
        buf[0] = buf_len
        buf[buf_len] = chr
    end
    Encoder.write = write

    encoders["nil"] = function(buf)
        write(buf, chars[NIL])
    end

    function encoders.boolean(buf, bool)
        if bool == true then
            write(buf, chars[TRUE])
        else
            write(buf, chars[FALSE])
        end
    end

    function encoders.array(buf, arr, len, start_index)
        start_index = (start_index == nil or start_index ~= 0 and start_index ~= 1) and 1 or start_index

        if len < 0 then
            write(buf, "Array size cannot be negative: ")
            write(buf, len)
            return true
        elseif len > 0xFFFFFFFF then
            write(buf, "Array size too large to encode: ")
            write(buf, len)
            return true
        end

        if len <= 0xF then
            write(buf, chars[ARRAY_FIXED + len])
        else
            write_unsigned(buf, ARRAY_8, len)
        end

        if start_index == 0 then
            write(buf, chars[ARRAY_ZERO_BASED_INDEX])
        end

        for idx = start_index, len do
            local val = arr[idx]
            local encoder = get_encoder(buf, val)
            if encoder == nil then return true end
            encoder(buf, val)
        end
    end

    -- we can't check if a table is an array or not because lua tables are not arrays, they are tables
    -- use Encoder.encode_array if you want to encode an array
    function encoders.table(buf, tbl)
        -- check if it's an array, it's not accurate for arrays with holes but better than nothing
        do
            -- this is the fastest possible way, a lot better than cbor's/messagepack's/pon's way of checking if it's an array
            local tbl_len = #tbl
            if tbl_len > 0 and next(tbl, tbl_len) == nil then
                if tbl[0] ~= nil then
                    return encoders.array(buf, tbl, tbl_len, 0)
                else
                    return encoders.array(buf, tbl, tbl_len)
                end
            end
        end

        local buf_len = buf[0]
        local table_start = buf_len -- we store the start of the table so when we write the table size, we can change the current buffer index to the start of the table
        -- we have no way to get the table size without iterating through it, so we just add 5 empty strings to the buffer as a placeholder
        -- we add 5 empty strings because we don't know if table size is going to be a fixed number, uint8, uint16 or uint32
        -- uint32 takes 5 bytes, so we add 5 empty strings
        do
            for idx = 1, 5 do
                buf[buf_len + idx] = ""
            end
            buf_len = buf_len + 5
            buf[0] = buf_len
        end

        local table_count = 0
        for key, val in pairs(tbl) do
            table_count = table_count + 1

            local encoder_key = get_encoder(buf, key)
            if encoder_key == nil then return true end
            encoder_key(buf, key)

            local encoder_val = get_encoder(buf, val)
            if encoder_val == nil then return true end
            encoder_val(buf, val)
        end

        local table_end = buf[0] -- we store the end of the table because we need to change current buffer index to the start of the table to write the table size
        buf[0] = table_start -- change current buffer index to the start of the table

        -- write the table size
        if table_count <= 0xF then
            write(buf, chars[TABLE_FIXED + table_count])
        else
            if table_count > 0xFFFFFFFF then
                write(buf, "Table size too large to encode: ")
                write(buf, table_count)
                return true
            end
            write_unsigned(buf, TABLE_8, table_count)
        end

        buf[0] = table_end -- change current buffer index back to the end of the table
    end

    function encoders.string(buf, str)
        local str_len = #str
        if str_len > 0xFFFFFFFF then
            write(buf, "String too large to encode: ")
            write(buf, str_len)
            return true
        end

        if str_len <= 0x1F then
            write(buf, chars[STR_FIXED + str_len])
        else
            write_unsigned(buf, STR_8, str_len)
        end
        write(buf, str)
    end

    function encoders.number(buf, num)
        if (num > MAX_NUMBER and num ~= HUGE) or (num < MIN_NUMBER and num ~= -HUGE) then
            write(buf, "Number too large to encode: ")
            write(buf, num)
            return true
        end

        if num % 1 ~= 0 or num > 0xFFFFFFFFFFFFF or num < -0xFFFFFFFFFFFFF then -- DOUBLE
            write_double(buf, DOUBLE, num)
            return
        end

        if num < 0 then
            num = -num
            if num <= 0x1F then
                write(buf, chars[NEGATIVE_INT + num])
            else
                write_unsigned(buf, NINT_8, num)
            end
        else
            if num <= 0x7F then
                write(buf, chars[POSITIVE_INT + num])
            else
                write_unsigned(buf, UINT_8, num)
            end
        end
    end

    function encoders.Vector(buf, vec)
        write(buf, chars[VECTOR])
        local x, y, z = Vector_Unpack(vec)
        encoders.number(buf, x)
        encoders.number(buf, y)
        encoders.number(buf, z)
    end

    function encoders.Angle(buf, ang)
        write(buf, chars[ANGLE])
        local p, y, r = Angle_Unpack(ang)
        encoders.number(buf, p)
        encoders.number(buf, y)
        encoders.number(buf, r)
    end

    function encoders.Entity(buf, ent)
        write(buf, chars[ENTITY])
        encoders.number(buf, Entity_EntIndex(ent))
    end

    function encoders.Player(buf, ply)
        write(buf, chars[PLAYER])
        encoders.number(buf, Player_UserID(ply))
    end

    function encoders.Color(buf, col)
        write(buf, chars[COLOR])
        encoders.number(buf, col.r)
        encoders.number(buf, col.g)
        encoders.number(buf, col.b)
        encoders.number(buf, col.a)
    end

    function write_unsigned(buf, tag, num)
        if num <= 0xFF then -- uint8
            write(buf, chars[tag + 0x00])
            write(buf, chars[num])
        elseif num <= 0xFFFF then -- uint16
            write(buf, chars[tag + 0x01])
            write(buf, chars[floor(num / 256)])
            write(buf, chars[num % 256])
        elseif num <= 0xFFFFFFFF then -- uint32
            write(buf, chars[tag + 0x02])
            write(buf, chars[floor(num / 0x1000000) % 256])
            write(buf, chars[floor(num / 0x10000) % 256])
            write(buf, chars[floor(num / 256) % 256])
            write(buf, chars[num % 256])
        elseif num <= 0xFFFFFFFFFFFFF then -- uint52
            write(buf, chars[tag + 0x3])
            write(buf, chars[num % 256])
            write(buf, chars[floor(num / 256) % 256])
            write(buf, chars[floor(num / 0x10000) % 256])
            write(buf, chars[floor(num / 0x1000000) % 256])
            write(buf, chars[floor(num / 0x100000000) % 256])
            write(buf, chars[floor(num / 0x10000000000) % 256])
            write(buf, chars[floor(num / 0x1000000000000) % 256])
        end
    end
    Encoder.write_unsigned = write_unsigned

    -- i can't remember where i got this from, but it's not mine (i swear i always credit people)
    local log2 = log(2)
    function write_double(buf, tag, value)
        local abs_value = value < 0 and -value or value
        --IEEE double-precision floating point number
        --Specification: https://en.wikipedia.org/wiki/Double-precision_floating-point_format
        --Separate out the sign, exponent and fraction
        local sign = value < 0 and 1 or 0
        local exponent = ceil(log(abs_value) / log2) - 1
        local fraction = abs_value / (2 ^ exponent) - 1
        --Make sure the exponent stays in range - allowed values are -1023 through 1024
        if exponent < -1023 then
            --We allow this case for subnormal numbers and just clamp the exponent and re-calculate the fraction
            --without the offset of 1
            exponent = -1023
            fraction = abs_value / (2 ^ exponent)
        elseif abs_value ~= HUGE and exponent > 1024 then
            write(buf, "Exponent out of range: ")
            write(buf, value)
            return true
        end

        --Handle special cases
        if value == 0 then
            --Zero
            exponent = -1023
            fraction = 0
        elseif abs_value == HUGE then
            --Infinity
            exponent = 1024
            fraction = 0
        elseif value ~= value then
            --NaN
            exponent = 1024
            fraction = 1
        end

        local exp_out = exponent + 1023
        local fraction_out = fraction * 0x10000000000000

        write(buf, chars[tag])
        write(buf, chars[128 * sign + floor(exp_out / 16)])
        write(buf, chars[(exp_out % 16) * 16 + floor(fraction_out / 0x1000000000000)])
        write(buf, chars[floor(fraction_out / 0x10000000000) % 256])
        write(buf, chars[floor(fraction_out / 0x100000000) % 256])
        write(buf, chars[floor(fraction_out / 0x1000000) % 256])
        write(buf, chars[floor(fraction_out / 0x10000) % 256])
        write(buf, chars[floor(fraction_out / 0x100) % 256])
        write(buf, chars[floor(fraction_out % 256)])
    end
    Encoder.write_double = write_double
end

local decoders = {}
local Decoder = {
    decoders = decoders
}
do
    local sub = string.sub

    local read_type, read_byte, read_word, read_dword
    local decode_array, decode_table, decode_string, decode_double

    -- garry's mod related
    local Vector, Angle, Entity, Player, Color = Vector, Angle, Entity, Player, Color
    --

    local str_byte = string.byte
    local byte = function(ctx, size)
        local index = ctx[1]
        if index + size - 1 > ctx[3] then -- buffer length
            return nil, "Attemped to read beyond buffer size"
        elseif index + size - 1 > ctx[4] then -- max size
            return nil, "Max decode size exceeded"
        end
        ctx[1] = index + size
        return str_byte(ctx[2], index, index + size - 1)
    end
    Decoder.byte = byte

    local get_decoder = function(ctx)
        local t = read_type(ctx)
        local decoder = decoders[t]
        if decoder == nil then
            return nil, "Unsupported type: ", t
        end
        return decoder
    end
    Decoder.get_decoder = get_decoder

    local context = {
        1,  -- index
        "", -- buffer
        0,  -- buffer length
        HUGE, -- max size for decode, useful when decoding from user input that was sent over netmessages
    }

    local decode = function()
        if context[3] < 1 then -- this will make string.byte fail
            return nil, "Buffer is empty"
        end

        local err, err_2
        local decoder
        local val

        decoder, err, err_2 = get_decoder(context)
        if err ~= nil then
            return nil, err, err_2
        end

        val, err, err_2 = decoder(context)
        if err ~= nil then
            return nil, err, err_2
        end

        return val
    end

    function Decoder.decode(str)
        context[1] = 1
        context[2] = str
        context[3] = #str
        context[4] = HUGE

        return decode()
    end

    function Decoder.decode_with_max_size(str, max_size)
        if type(max_size) ~= "number" then
            return nil, "max_size is not a number", max_size
        end

        if max_size < 0 then
            return nil, "max_size can either be a positive number or math.huge for unlimited", max_size
        end

        context[1] = 1
        context[2] = str
        context[3] = #str
        context[4] = max_size

        return decode()
    end

    decoders[NIL] = function(ctx)
        ctx[1] = ctx[1] + 1
        return nil
    end

    decoders[FALSE] = function(ctx)
        ctx[1] = ctx[1] + 1
        return false
    end

    decoders[TRUE] = function(ctx)
        ctx[1] = ctx[1] + 1
        return true
    end

    --
    decoders[ARRAY_FIXED] = function(ctx)
        local bty, err = read_byte(ctx)
        if bty == nil then
            return nil, err
        end
        local len = bty - ARRAY_FIXED
        return decode_array(ctx, len)
    end

    for i = ARRAY_FIXED + 1, ARRAY_FIXED_END do
        decoders[i] = decoders[ARRAY_FIXED]
    end
    --

    decoders[ARRAY_8] = function(ctx)
        ctx[1] = ctx[1] + 1
        local len, err = read_byte(ctx)
        if len == nil then
            return nil, err
        end
        return decode_array(ctx, len)
    end

    decoders[ARRAY_16] = function(ctx)
        ctx[1] = ctx[1] + 1
        local len, err = read_word(ctx)
        if err ~= nil then
            return nil, err
        end
        return decode_array(ctx, len)
    end

    decoders[ARRAY_32] = function(ctx)
        ctx[1] = ctx[1] + 1
        local len, err = read_dword(ctx)
        if err ~= nil then
            return nil, err
        end
        return decode_array(ctx, len)
    end

    --
    decoders[TABLE_FIXED] = function(ctx)
        local bty, err = read_byte(ctx)
        if bty == nil then
            return nil, err
        end
        local len = bty - TABLE_FIXED
        return decode_table(ctx, len)
    end

    for i = TABLE_FIXED + 1, TABLE_FIXED_END do
        decoders[i] = decoders[TABLE_FIXED]
    end
    --

    decoders[TABLE_8] = function(ctx)
        ctx[1] = ctx[1] + 1
        local len, err = read_byte(ctx)
        if err ~= nil then
            return nil, err
        end
        return decode_table(ctx, len)
    end

    decoders[TABLE_16] = function(ctx)
        ctx[1] = ctx[1] + 1
        local len, err = read_word(ctx)
        if err ~= nil then
            return nil, err
        end
        return decode_table(ctx, len)
    end

    decoders[TABLE_32] = function(ctx)
        ctx[1] = ctx[1] + 1
        local len, err = read_dword(ctx)
        if err ~= nil then
            return nil, err
        end
        return decode_table(ctx, len)
    end

    --
    decoders[STR_FIXED] = function(ctx)
        local bty, err = read_byte(ctx)
        if err ~= nil then
            return nil, err
        end
        local len = bty - STR_FIXED
        return decode_string(ctx, len)
    end

    for i = STR_FIXED + 1, STR_FIXED_END do
        decoders[i] = decoders[STR_FIXED]
    end
    --

    decoders[STR_8] = function(ctx)
        ctx[1] = ctx[1] + 1
        local len, err = read_byte(ctx)
        if err ~= nil then
            return nil, err
        end
        return decode_string(ctx, len)
    end

    decoders[STR_16] = function(ctx)
        ctx[1] = ctx[1] + 1
        local len, err = read_word(ctx)
        if err ~= nil then
            return nil, err
        end
        return decode_string(ctx, len)
    end

    decoders[STR_32] = function(ctx)
        ctx[1] = ctx[1] + 1
        local len, err = read_dword(ctx)
        if err ~= nil then
            return nil, err
        end
        return decode_string(ctx, len)
    end

    --
    decoders[POSITIVE_INT] = function(ctx)
        local bty, err = read_byte(ctx)
        if err ~= nil then
            return nil, err
        end
        return bty - POSITIVE_INT
    end

    for i = POSITIVE_INT + 1, POSITIVE_INT_END do
        decoders[i] = decoders[POSITIVE_INT]
    end
    --

    decoders[UINT_8] = function(ctx)
        ctx[1] = ctx[1] + 1
        local u8, err = read_byte(ctx)
        if err ~= nil then
            return nil, err
        end
        return u8
    end

    decoders[UINT_16] = function(ctx)
        ctx[1] = ctx[1] + 1
        local u16, err = read_word(ctx)
        if err ~= nil then
            return nil, err
        end
        return u16
    end

    decoders[UINT_32] = function(ctx)
        ctx[1] = ctx[1] + 1
        local u32, err = read_dword(ctx)
        if err ~= nil then
            return nil, err
        end
        return u32
    end

    decoders[UINT_52] = function(ctx)
        ctx[1] = ctx[1] + 1
        local b1, b2, b3, b4, b5, b6, b7 = byte(ctx, 7)
        if b1 == nil then
            return nil, b2
        end
        return b1 + (b2 * 0x100) + (b3 * 0x10000) + (b4 * 0x1000000) + (b5 * 0x100000000) + (b6 * 0x10000000000) + (b7 * 0x1000000000000)
    end

    --
    decoders[NEGATIVE_INT] = function(ctx)
        local bty, err = read_byte(ctx)
        if bty == nil then
            return nil, err
        end
        return NEGATIVE_INT - bty
    end

    for i = NEGATIVE_INT + 1, NEGATIVE_INT_END do
        decoders[i] = decoders[NEGATIVE_INT]
    end
    --

    decoders[NINT_8] = function(ctx)
        ctx[1] = ctx[1] + 1
        local n8, err = read_byte(ctx)
        if n8 == nil then
            return nil, err
        end
        return -n8
    end

    decoders[NINT_16] = function(ctx)
        ctx[1] = ctx[1] + 1
        local n16, err = read_word(ctx)
        if err ~= nil then
            return nil, err
        end
        return -n16
    end

    decoders[NINT_32] = function(ctx)
        ctx[1] = ctx[1] + 1
        local n32, err = read_dword(ctx)
        if err ~= nil then
            return nil, err
        end
        return -n32
    end

    decoders[NINT_52] = function(ctx)
        ctx[1] = ctx[1] + 1
        local b1, b2, b3, b4, b5, b6, b7 = byte(ctx, 7)
        if b1 == nil then
            return nil, b2
        end
        return -(b1 + (b2 * 0x100) + (b3 * 0x10000) + (b4 * 0x1000000) + (b5 * 0x100000000) + (b6 * 0x10000000000) + (b7 * 0x1000000000000))
    end

    decoders[DOUBLE] = function(ctx)
        ctx[1] = ctx[1] + 1
        return decode_double(ctx)
    end

    decoders[VECTOR] = function(ctx)
        ctx[1] = ctx[1] + 1

        local err, err_2
        local decoder
        local x, y, z

        -- x
        decoder, err, err_2 = get_decoder(ctx)
        if err ~= nil then
            return nil, err, err_2
        end

        x, err = decoder(ctx)
        if err ~= nil then
            return nil, err
        end
        --

        -- y
        decoder, err, err_2 = get_decoder(ctx)
        if err ~= nil then
            return nil, err, err_2
        end

        y, err = decoder(ctx)
        if err ~= nil then
            return nil, err
        end
        --

        -- z
        decoder, err, err_2 = get_decoder(ctx)
        if err ~= nil then
            return nil, err, err_2
        end

        z, err = decoder(ctx)
        if err ~= nil then
            return nil, err
        end
        --

        return Vector(x, y, z)
    end

    decoders[ANGLE] = function(ctx)
        ctx[1] = ctx[1] + 1

        local err, err_2
        local decoder
        local p, y, r

        -- p
        decoder, err, err_2 = get_decoder(ctx)
        if err ~= nil then
            return nil, err, err_2
        end

        p, err = decoder(ctx)
        if err ~= nil then
            return nil, err
        end
        --

        -- y
        decoder, err, err_2 = get_decoder(ctx)
        if err ~= nil then
            return nil, err, err_2
        end

        y, err = decoder(ctx)
        if err ~= nil then
            return nil, err
        end
        --

        -- r
        decoder, err, err_2 = get_decoder(ctx)
        if err ~= nil then
            return nil, err, err_2
        end

        r, err = decoder(ctx)
        if err ~= nil then
            return nil, err
        end
        --

        return Angle(p, y, r)
    end

    decoders[ENTITY] = function(ctx)
        ctx[1] = ctx[1] + 1

        local err, err_2
        local decoder
        local ent_index

        decoder, err, err_2 = get_decoder(ctx)
        if err ~= nil then
            return nil, err, err_2
        end

        ent_index, err = decoder(ctx)
        if err ~= nil then
            return nil, err
        end

        return Entity(ent_index)
    end

    decoders[PLAYER] = function(ctx)
        ctx[1] = ctx[1] + 1

        local err, err_2
        local decoder
        local user_id

        decoder, err, err_2 = get_decoder(ctx)
        if err ~= nil then
            return nil, err, err_2
        end

        user_id, err = decoder(ctx)
        if err ~= nil then
            return nil, err
        end

        return Player(user_id)
    end

    decoders[COLOR] = function(ctx)
        ctx[1] = ctx[1] + 1

        local err, err_2
        local decoder
        local r, g, b, a

        -- r
        decoder, err, err_2 = get_decoder(ctx)
        if err ~= nil then
            return nil, err, err_2
        end

        r, err = decoder(ctx)
        if err ~= nil then
            return nil, err
        end
        --

        -- g
        decoder, err, err_2 = get_decoder(ctx)
        if err ~= nil then
            return nil, err, err_2
        end

        g, err = decoder(ctx)
        if err ~= nil then
            return nil, err
        end
        --

        -- b
        decoder, err, err_2 = get_decoder(ctx)
        if err ~= nil then
            return nil, err, err_2
        end

        b, err = decoder(ctx)
        if err ~= nil then
            return nil, err
        end
        --

        -- a
        decoder, err, err_2 = get_decoder(ctx)
        if err ~= nil then
            return nil, err, err_2
        end

        a, err = decoder(ctx)
        if err ~= nil then
            return nil, err
        end
        --

        return Color(r, g, b, a)
    end

    function decode_array(ctx, len)
        -- zzzzz no table.new or table.setn, we try to allocate small space to avoid table resizing for small tables
        local arr = {nil, nil, nil, nil, nil, nil, nil, nil}

        local start_index = 1
        if read_type(ctx) == ARRAY_ZERO_BASED_INDEX then
            ctx[1] = ctx[1] + 1
            start_index = 0
        end

        for idx = start_index, len do
            local err, err_2
            local decoder
            local val

            decoder, err, err_2 = get_decoder(ctx)
            if err ~= nil then
                return nil, err, err_2
            end

            val, err = decoder(ctx)
            if err ~= nil then
                return nil, err
            end

            arr[idx] = val
        end

        return arr
    end
    Decoder.decode_array = decode_array

    function decode_table(ctx, len)
        local err, err_2
        local decoder
        local key, val

        -- zzzzz no table.new or table.setn, we try to allocate small space to avoid table resizing for small tables
        local tbl = {nil, nil, nil, nil, nil, nil, nil, nil}
        for _ = 1, len do
            -- key
            decoder, err, err_2 = get_decoder(ctx)
            if err ~= nil then
                return nil, err, err_2
            end

            key, err = decoder(ctx)
            if err ~= nil then
                return nil, err
            end
            --

            -- val
            decoder, err, err_2 = get_decoder(ctx)
            if err ~= nil then
                return nil, err, err_2
            end

            val, err = decoder(ctx)
            if err ~= nil then
                return nil, err
            end
            --

            tbl[key] = val
        end

        return tbl
    end
    Decoder.decode_table = decode_table

    function decode_string(ctx, len)
        local index = ctx[1]
        if index + len - 1 > ctx[3] then
            return nil, "Attemped to read beyond buffer size"
        elseif index + len - 1 > ctx[4] then
            return nil, "Max decode size exceeded"
        end

        ctx[1] = index + len

        return sub(ctx[2], index, index + len - 1)
    end
    Decoder.decode_string = decode_string

    function decode_double(ctx)
        local b1, b2, b3, b4, b5, b6, b7, b8 = byte(ctx, 8)
        if b1 == nil then
            return nil, b2
        end

        --Separate out the values
        local sign = b1 >= 128 and 1 or 0
        local exponent = (b1 % 128) * 16 + floor(b2 / 16)
        local fraction = (b2 % 16) * 0x1000000000000 + b3 * 0x10000000000 + b4 * 0x100000000 + b5 * 0x1000000 + b6 * 0x10000 + b7 * 0x100 + b8
        --Handle special cases
        if exponent == 2047 then
            --Infinities
            if fraction == 0 then return ((sign == 0 and 1) or -1) * HUGE end
            --NaN
            if fraction == 0xfffffffffffff then return 0 / 0 end
        end

        --Combine the values and return the result
        if exponent == 0 then
            --Handle subnormal numbers
            return ((sign == 0 and 1) or -1) * (2 ^ (exponent - 1023)) * (fraction / 0x10000000000000)
        else
            --Handle normal numbers
            return ((sign == 0 and 1) or -1) * (2 ^ (exponent - 1023)) * ((fraction / 0x10000000000000) + 1)
        end
    end
    Decoder.decode_double = decode_double

    function read_type(ctx)
        local typ = str_byte(ctx[2], ctx[1])
        return typ
    end
    Decoder.read_type = read_type

    function read_byte(ctx)
        local bty, err = byte(ctx, 1)
        if bty == nil then
            return nil, err
        end
        return bty
    end
    Decoder.read_byte = read_byte

    function read_word(ctx)
        local b1, b2 = byte(ctx, 2)
        if b1 == nil then
            return nil, b2
        end
        return b1 * 0x100 + b2
    end
    Decoder.read_word = read_word

    function read_dword(ctx)
        local b1, b2, b3, b4 = byte(ctx, 4)
        if b1 == nil then
            return nil, b2
        end
        return b1 * 0x1000000 + b2 * 0x10000 + b3 * 0x100 + b4
    end
    Decoder.read_dword = read_dword
end

wOS.SFS_EXTERN = {
    Encoder = Encoder, -- to allow usage of internal functions
    Decoder = Decoder, -- to allow usage of internal functions

    encode = Encoder.encode,
    encode_with_buffer = Encoder.encode_with_buffer,
    encode_array = Encoder.encode_array,

    decode = Decoder.decode,
    decode_with_max_size = Decoder.decode_with_max_size,

    set_type_function = function(t_fn) -- this is for me as I have custom type function in sam/scb to allow type function to get jit compiled :c
        type = t_fn
    end,

    add_encoder = function(typ, encoder)
        encoders[typ] = encoder
        if FREE_FOR_CUSTOM == FREE_FOR_CUSTOM_END then
            return nil, "No more free slots for custom encoders"
        end
        FREE_FOR_CUSTOM = FREE_FOR_CUSTOM + 1
        return FREE_FOR_CUSTOM - 1
    end,

    add_decoder = function(typ, decoder)
        decoders[typ] = decoder
    end,

    chars = chars,
    VERSION = "2.0.1"
}

function wOS.SFS_EXTERN:Compress( data_table )
    if not data_table then return nil, "NO DATA PRESENT" end
    local encoded, err = self.encode( data_table )
    if err then return encoded, err end
    return util.Compress( encoded )
end

function wOS.SFS_EXTERN:RawCompress( data_table )
    if not data_table then return nil, "NO DATA PRESENT" end
    local encoded, err = self.encode( data_table )
    if err then return encoded, err end
    return encoded
end

function wOS.SFS_EXTERN:Decompress( data )
    if not data then return nil, "NO DATA PRESENT" end
    local decomp = util.Decompress( data )
    return self.decode( decomp )
end

function wOS.SFS_EXTERN:RawDecompress( data )
    if not data then return nil, "NO DATA PRESENT" end
    return self.decode( data )
end
--addons/wos-passiveevent/lua/wos/pes/core/sh_settings.lua:
// Might want to spilt files up

wOS.PES.Settings = wOS.PES.Settings or {}

wOS.PES.Settings.List = wOS.PES.Settings.List or {}

function wOS.PES.Settings.GetList()
	return wOS.PES.Settings.List
end

function wOS.PES.Settings.Register(tbl)
	wOS.PES.Settings.List[tbl.Name] = tbl
end

wOS.PES.Settings.Register({
	Name = "Random Events Run",
	Description = "",
	Type = "Boolean",
	Default = true,
})

wOS.PES.Settings.Values = wOS.PES.Settings.Values  or {}


function wOS.PES.Settings.Get(varName, fallback)
	if wOS.PES.Settings.Values[varName] != nil then
		return wOS.PES.Settings.Values[varName]
	elseif wOS.PES.Settings.List[varName] then
		return wOS.PES.Settings.List[varName].Default
	end

	return fallback
end


if SERVER then

	hook.Call( "wOS.PES.PostLoaded", "Settings.Sync", function()
		// For the players that missed the auth request

		if file.Exists("wos/pes/settings.json") then
			local json = file.Read("wos/pes/settings.json")

			local tbl = util.JSONToTable(json)
			if tbl then
				wOS.PES.Settings.Values = tbl
			end
		end
		local func = hook.GetTable()["PlayerAuthed"]["wOS.PES.Settings.Sync"]
		for index, ply in ipairs(player.GetAll()) do
			func(ply)
		end
	end )

	util.AddNetworkString("wOS.PES.Sync.Setting")
	util.AddNetworkString("wOS.PES.Sync.Settings")

	function wOS.PES.Settings.Set(varName, value, ply)
		wOS.PES.Settings.Values[varName] = value

		net.Start("wOS.PES.Sync.Setting")
			net.WriteString(varName)
			net.WriteType(value)
		net.Broadcast()

		//hook.Call("wOS.PES.SettingSet" .. varName, nil, varName, value, ply)
		
		timer.Create("wOS.PES.Settings.Save", 0, 1,  function()
			local json = util.TableToJSON(wOS.PES.Settings.Values)
			file.Write("wos/pes/settings.json", json)
		end)
	end

	hook.Add("PlayerAuthed", "wOS.PES.Settings.Sync", function(ply)
		timer.Simple(5, function()
			net.Start("wOS.PES.Sync.Settings")
				local count = table.Count(wOS.PES.Settings.Values)

				net.WriteUInt(count, 8)

				local keyTbl = table.GetKeys(wOS.PES.Settings.Values)
				for x = 1, count do
					net.WriteString(keyTbl[x])
					net.WriteType(wOS.PES.Settings.Values[ keyTbl[x] ])
				end
			net.Send(ply)
		end)
	end)
else
	net.Receive("wOS.PES.Sync.Settings", function()
		local count = net.ReadUInt(8)

		local settings = {}
		for x = 1, count do
			settings[net.ReadString()] = net.ReadType()
		end
	end)

	net.Receive("wOS.PES.Sync.Setting", function()
		wOS.PES.Settings.Values[net.ReadString()] = net.ReadType()
	end)
end

function wOS.PES:SelectableMaps()
	return wOS.PES.Modules:Get("map").Maps
end

function wOS.PES:SpawnableWeapons()
	// Default the HL2 weapons
	local dummy_tbl = {
		["weapon_physgun"] = true,
		["weapon_physcannon"] = true,
		["weapon_crowbar"] = true,
		["weapon_pistol"] = true,
		["weapon_357"] = true,
		["weapon_smg1"] = true,
		["weapon_ar2"] = true,
		["weapon_shotgun"] = true,
		["weapon_crossbow"] = true,
		["weapon_frag"] = true,
		["weapon_rpg"] = true,
		["weapon_bugbait"] = true,
	}
	// Get only real, spawnable weapons
	for _, weapon in pairs(weapons.GetList()) do
		if !weapon.Spawnable then continue end
		dummy_tbl[ weapon.ClassName ] = true
	end

	// Relooping ensures it's in alphabetical order
	local tbl = {}
	for weapon, _ in SortedPairs( dummy_tbl ) do
		table.insert( tbl, weapon )
	end

	return tbl
end
--addons/wos-passiveevent/lua/wos/css/config/sh_config.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2019
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--

wOS = wOS or {}
wOS.CombatSim = wOS.CombatSim or {}

-- wOS.CombatSim.Difficulties = {}
-- 
-- wOS.CombatSim.Difficulties[ 1 ] = { 
-- 	Name = "Practice",
-- 	Icon = "wos/halo/css/normal.png",
-- }
-- 
-- wOS.CombatSim.Difficulties[ 2 ] = { 
-- 	Name = "Normal",
-- 	Icon = "wos/halo/css/normal.png",
-- }
-- 
-- wOS.CombatSim.Difficulties[ 3 ] = { 
-- 	Name = "Heroic",
-- 	Icon = "wos/halo/css/heroic.png",
-- }
-- 
-- wOS.CombatSim.Difficulties[ 4 ] = { 
-- 	Name = "Legendary",
-- 	Icon = "wos/halo/css/legend.png",
-- }
-- 

wOS.CombatSim.FrameColor = Color( 0, 0, 0, 155 )
wOS.CombatSim.BackgroundColor = Color( 0, 0, 0, 200 )
wOS.CombatSim.TextColor = Color( 155, 155, 155, 255 )
--addons/wos-passiveevent/lua/wos/css/vgui/wos_css_scrollpanel.lua:
--[[-------------------------------------------------------------------
	Shooting Range Scroll Panel
		VGUI Element for use in the menus.
			Powered by
						  _ _ _    ___  ____  
				__      _(_) | |_ / _ \/ ___| 
				\ \ /\ / / | | __| | | \___ \ 
				 \ V  V /| | | |_| |_| |___) |
				  \_/\_/ |_|_|\__|\___/|____/ 
											  
 _____         _                 _             _           
|_   _|__  ___| |__  _ __   ___ | | ___   __ _(_) ___  ___ 
  | |/ _ \/ __| '_ \| '_ \ / _ \| |/ _ \ / _` | |/ _ \/ __|
  | |  __/ (__| | | | | | | (_) | | (_) | (_| | |  __/\__ \
  |_|\___|\___|_| |_|_| |_|\___/|_|\___/ \__, |_|\___||___/
                                         |___/             
----------------------------- Copyright 2017, David "King David" Wiltos ]]--[[
							  
	Lua Developer: King David, Oninoni
	Contact: http://steamcommunity.com/groups/wiltostech
		
-- Copyright 2017, David "King David" Wiltos ]]--

local DSRScrollPanel = {}

-- Initializes the DSRScrollPanel.
function DSRScrollPanel:Init()
	self.Panels = {}

	self.XScroll = true
	self.AlignCenter = true

	self.Overflow = 0
end

function DSRScrollPanel:OnSizeChanged(width, height)
	if self.XScroll then
		self.ScrollSize = width
	else
		self.ScrollSize = height
	end
end

function DSRScrollPanel:SetPanelSize(x, y)
	self.XPanelSize = x
	self.YPanelSize = y
end

function DSRScrollPanel:SetPanelSpacing(s)
	self.PanelSpacing = s
end

function DSRScrollPanel:GetScrollPanelSize()
	if self.XScroll then
		return self.XPanelSize
	else
		return self.YPanelSize
	end
end

function DSRScrollPanel:SetPanelScroll(panel, offset)
	offset = offset or 0

	if self.XScroll then
		panel:SetPos(panel.OriginalValue + offset, self.PanelSpacing)
	else
		panel:SetPos(self.PanelSpacing, panel.OriginalValue + offset)
	end
end

function DSRScrollPanel:SetScroll(offset)
	for _, panel in pairs(self.Panels or {}) do
		self:SetPanelScroll(panel, offset)
	end
end

function DSRScrollPanel:Clear()
	for _, panel in pairs(self.Panels or {}) do
		panel:Remove()
	end

	self.Panels = {}
end

function DSRScrollPanel:Think()
	local offset = 0

	if self.AlignCenter then
		offset = self.Overflow / 2
	end

	if self.Overflow < 0 then
		local xMouse, yMouse = gui.MousePos()
		local xLocal, yLocal = self:ScreenToLocal(xMouse, yMouse)

		local xSize, ySize = self:GetSize()

		local scrollLocal = yLocal
		if self.XScroll then
			scrollLocal = xLocal
		end
		
		local panelSize = self:GetScrollPanelSize()

		local targetOffset = math.min(0, math.max(self.Overflow, (scrollLocal - self.PanelSpacing) / (self.ScrollSize - self.PanelSpacing * 2) * self.Overflow))

		offset = Lerp(0.03, self.LastOffset, targetOffset)
		self.LastOffset = offset
	end

	self:SetScroll(offset)
end

function DSRScrollPanel:CreatePanel(class)
	local panel = vgui.Create(class, self)
	panel:SetSize(self.XPanelSize, self.YPanelSize)

	local panelSpacing = self.PanelSpacing
	local panelSize = self:GetScrollPanelSize()
	
	panel.OriginalValue = panelSpacing + (panelSpacing + panelSize) * #self.Panels
	
	self:SetPanelScroll(panel)
	self.LastOffset = 0
	table.insert(self.Panels, panel)

	local totalWidth = panel.OriginalValue + panelSize + panelSpacing

	self.Overflow = self.ScrollSize - totalWidth

	return panel
end

vgui.Register("WOS_CSS_ScrollPanel", DSRScrollPanel, "DPanel")
--addons/wos-passiveevent/lua/wos/css/entities/wos_simulation_system/cl_wos_simulation_system.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2019
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--

local ENT = {}

ENT.Type 			= "anim"
ENT.Base 			= "base_anim"

ENT.Spawnable = false

-- Sets up the NetworkVars for the entity.
function ENT:SetupDataTables()
	self:NetworkVar( "Bool", 0, "Activated" )

	self:NetworkVar( "Int", 0, "Score" )
	self:NetworkVar( "Int", 1, "StartTime" )
	self:NetworkVar( "Int", 2, "EndTime" )
	self:NetworkVar( "Int", 3, "BorderPointCount" )
	self:NetworkVar( "Int", 4, "BorderHeight" )
    
	self:NetworkVar( "String", 0, "SimulatorName" )

	self:NetworkVar( "Float", 0, "BorderUpdate" )
	
end

function ENT:PrepareCheckBorderValues()
	self.PreparedBorderValues = {}
	
	local borderPointCount = self:GetBorderPointCount()

	for i=1, borderPointCount do
		local preparedValue = {
			v = self:GetNW2Vector("BorderPoint" .. i)
		}

		self.PreparedBorderValues[i] = preparedValue
	end

	local j = borderPointCount

	for i=1, borderPointCount do
		local borderI = self.PreparedBorderValues[i].v
		local borderJ = self.PreparedBorderValues[j].v

		if borderJ.y == borderI.y then
			self.PreparedBorderValues[i].c = borderI.x
			self.PreparedBorderValues[i].m = 0
		else
			self.PreparedBorderValues[i].c = borderI.x - (borderI.y * borderJ.x) / (borderJ.y - borderI.y) + (borderI.y * borderI.x) / (borderJ.y - borderI.y)
			self.PreparedBorderValues[i].m = (borderJ.x - borderI.x) / (borderJ.y - borderI.y);
		end

		j = i
	end
end

-- Check if the Vector is inside the 2D border of the sim area.
--
-- @param Vector vec
-- @return Bool inBorders
function ENT:CheckInBorders2D(vec)
	local borderPointCount = self:GetBorderPointCount()

	if not self.PreparedBorderValues or #self.PreparedBorderValues ~= borderPointCount then 
		self:PrepareCheckBorderValues()
	end
	
	local j = borderPointCount
	local inBorders = false

	for i=1, borderPointCount do
		local borderI = self.PreparedBorderValues[i].v
		local borderJ = self.PreparedBorderValues[j].v

		if ((borderI.y<vec.y && borderJ.y>=vec.y || borderJ.y<vec.y && borderI.y>=vec.y)) then
			if (vec.y * self.PreparedBorderValues[i].m + self.PreparedBorderValues[i].c < vec.x) then
				inBorders = not inBorders
			end
	  	end

		j = i
	end

	return inBorders
end

-- Check if the given vector is inside the border of the sim area.
--
-- @param Vector vec
-- @return Bool inBorders
function ENT:CheckInBorders(vec)
	local firstPoint = self:GetNW2Vector("BorderPoint1")

	local heightt = self:GetBorderHeight()
	local below = vec.z - 50 < firstPoint.z + heightt
	local above = vec.z + 50 > firstPoint.z

	if heightt < 0 then
		below = vec.z - 50 < firstPoint.z 
		above = vec.z + 50 > firstPoint.z + heightt
	end

	if below && above then
		if self:CheckInBorders2D(vec) then
			return true
		end
	end

	return false
end

-- Returns the time left until the game ends.
--
-- @return Number timeLeft
function ENT:GetTimeLeft()
	return math.Round(CurTime() - self:GetStartTime(), 0)
end

-- Clientside Initialize
function ENT:Initialize()
	self.Positions = {}
	self.BorderUpdate = 0
end

-- Clientside Think
function ENT:Think()
	if self.BorderUpdate != self:GetBorderUpdate() and self:GetBorderUpdate() < CurTime() then
		self.BorderUpdate = self:GetBorderUpdate()
		self.PreparedBorderValues = nil
	end
end

-- Clientside OnRemove
function ENT:OnRemove()
end

---- Main Draw function.
--function ENT:Draw()
--	self:DrawModel()
--end

scripted_ents.Register(ENT, "wos_simulation_system")
--addons/wos-passiveevent/lua/wos/css/entities/wos_simulation_tool/cl_wos_simulation_tool.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2019
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--

local SWEP = {}

SWEP.ToolNameHeight = 0
SWEP.InfoBoxHeight = 0
SWEP.WepSelectIcon = surface.GetTextureID( "vgui/gmod_tool" )
SWEP.Gradient = surface.GetTextureID( "gui/gradient" )
SWEP.InfoIcon = surface.GetTextureID( "gui/info" )

SWEP.PrintName = "Combat Simulation Tool"
SWEP.Slot = 5
SWEP.SlotPos = 6
SWEP.HoldType = "pistol"
--SWEP.Author	        = "Jan (wiltOS)"

SWEP.DrawAmmo			= false
SWEP.DrawCrosshair		= true

SWEP.Spawnable = true
SWEP.AdminOnly = true

SWEP.ViewModel	= "models/weapons/c_toolgun.mdl"
SWEP.WorldModel = "models/weapons/w_toolgun.mdl"
SWEP.Category = "[wOS] Passive Event"
SWEP.UseHands = true

SWEP.Primary = {}
SWEP.Primary.Swap           = Sound( "weapons/clipempty_rifle.wav" )
SWEP.Primary.Sound			= Sound( "NPC_CombineCamera.Click" )
SWEP.Primary.Delete1		= Sound( "Weapon_StunStick.Melee_Hit" )
SWEP.Primary.Delete			= Sound( "Weapon_StunStick.Melee_HitWorld" )

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= -1
SWEP.Primary.Automatic		= false
SWEP.Primary.Ammo			= "pistol"

SWEP.Secondary = {}
SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Automatic	= false
SWEP.Secondary.Ammo			= "none"

-- TODO: Add "Modify Border Points"

function SWEP:SetupDataTables()
	self:NetworkVar( "Int", 0, "ToolMode" )
	self:NetworkVar( "Int", 1, "ToolStep" )

	self:NetworkVar( "Entity", 0, "SelectedSimulator")
end

function SWEP:DrawWeaponSelection( x, y, wide, tall, alpha )
end

function SWEP:PrimaryAttack()
    if not IsFirstTimePredicted() then return end

	local mode = self:GetToolMode()
	local step = self:GetToolStep()
	local trace = self:GetOwner():GetEyeTrace()

	if mode == WOS_CSS.MODE.INITIAL then
		local ent = trace.Entity
		if !IsValid(ent) then return end
		if ent:GetClass() == "prop_physics" then
			self:CreateSimulator(ent)
		end
	elseif mode == WOS_CSS.MODE.AREASELECT then
		local ent = trace.Entity

		if step == WOS_CSS.AREASELECT.BORDER then
			if IsValid(ent) and ent:GetClass() == "wos_simulation_system" then
				return
			end
			self:SelectBorderPoint(trace)
		elseif step == WOS_CSS.AREASELECT.HEIGHT then
			if IsValid(ent) and ent:GetClass() == "wos_simulation_system" then
				-- TODO: Validation
				self:FinishAreaSelectMode()
				return
			end
			self:SelectHeightPoint(trace)
		end
	elseif mode == WOS_CSS.MODE.POINTSELECT then
		self:DoVarPrimary()
	end
end

function SWEP:SecondaryAttack()
    if not IsFirstTimePredicted() then return end

	local mode = self:GetToolMode()
	local step = self:GetToolStep()
	
	if mode == WOS_CSS.MODE.AREASELECT then
		if step != WOS_CSS.AREASELECT.BORDER then return end
		self:RemoveBorderPoint()
	elseif mode == WOS_CSS.MODE.POINTSELECT then
		self:DoVarSecondary()
	end

end

function SWEP:Reload()
    if not IsFirstTimePredicted() then return end

	timer.Create("wOS.CombatSim.ReloadTime", 1, 1, function()
		self.LastReloadPressed = false
	end)

	if self.LastReloadPressed then return end
	self.LastReloadPressed = true

	local mode = self:GetToolMode()
	local step = self:GetToolStep()

	if mode == WOS_CSS.MODE.POINTSELECT then
		wOS.CombatSim:OpenSimulationCreator(simulator)
		return
	elseif mode == WOS_CSS.MODE.SIMSELECTED then
        wOS.CombatSim:OpenSimulationCreator(simulator)
	end

end

function SWEP:Think()
end

function SWEP:Deploy()
    local cur_pan = wOS.PES:GetActiveMenu()
    if !IsValid(cur_pan) then return end
    if !cur_pan.menu then return end
    if not cur_pan.menu.CreationType then return end 
    if cur_pan.menu.CreationType == WOS_PES.CREATOR.SIMULATION then return end
    cur_pan:Remove()
end

function SWEP:Holster()
	return true
end

function SWEP:CreateSimulator(ent)
	self.SelectedBorderPoints = {}
	self.SelectedHeight = 0
end

function SWEP:SelectBorderPoint(trace)
	table.insert(self.SelectedBorderPoints, trace.HitPos)
end

function SWEP:RemoveBorderPoint()
	self.SelectedBorderPoints[#self.SelectedBorderPoints] = nil
end

function SWEP:SelectHeightPoint(trace)
	local firstPoint = self.SelectedBorderPoints[1]
	
	if isvector(firstPoint) then
		self.SelectedHeight = trace.HitPos.z - firstPoint.z
	end
end

function SWEP:FinishAreaSelectMode()
	wOS.CombatSim:OpenSimulatorNameMenu(self.SelectedBorderPoints, self.SelectedHeight)
end

function SWEP:DoVarPrimary(trace)
	local simulator = self:GetSelectedSimulator()
	if simulator == self then return end
	if not IsValid(simulator) then return end
	if simulator:GetClass() != "wos_simulation_system" then return end
  
	local wtbl = weapons.Get( "wos_pes_tool" )
	if not wtbl then return end

	local hookname = "wOS.CombatSim.EnforceVarPrimaryPlacement." .. self:EntIndex()
	hook.Add( "wOS.CombatSim.CanPlaceEntity", hookname, function( wep, ply, pos ) 
		if wep != self then return end
		if ply != LocalPlayer() then return end
		local inside = simulator:CheckInBorders(pos + Vector(0, 0, 1)) -- Offset because the floor isn't 100% inside.
		if inside then return end
		surface.PlaySound( "buttons/lightswitch2.wav" )
		notification.AddLegacy( "[wOS-PES] You can't operate vars outside the simulation area.", NOTIFY_ERROR, 3 )
		return false
	end )

	local success = wtbl.PrimaryAttack( self )
	hook.Remove( "wOS.CombatSim.CanPlaceEntity", hookname )
end

function SWEP:DoVarSecondary()
	local simulator = self:GetSelectedSimulator()
	if simulator == self then return end
	if not IsValid(simulator) then return end
	if simulator:GetClass() != "wos_simulation_system" then return end
  
	local wtbl = weapons.Get( "wos_pes_tool" )
	if not wtbl then return end

	local hookname = "wOS.CombatSim.EnforceVarSecondaryPlacement." .. self:EntIndex()
	hook.Add( "wOS.CombatSim.CanPlaceEntity", hookname, function( wep, ply, pos ) 
		if wep != self then return end
		if ply != LocalPlayer() then return end
		local inside = simulator:CheckInBorders(pos + Vector(0, 0, 1)) -- Offset because the floor isn't 100% inside.
		if inside then return end
		surface.PlaySound( "buttons/lightswitch2.wav" )
		notification.AddLegacy( "[wOS-PES] You can't operate vars outside the simulation area.", NOTIFY_ERROR, 3 )
		return false
	end )

	local success = wtbl.SecondaryAttack( self )
	hook.Remove( "wOS.CombatSim.CanPlaceEntity", hookname )
end

local w,h = ScrW(), ScrH()
function SWEP:DrawHUD()
	local mode = self:GetToolMode()
	local step = self:GetToolStep()
	
	if mode != WOS_CSS.MODE.POINTSELECT then
		draw.SimpleText("Simulation System Tool", "wOS.CombatSim.MainFont", w * 0.02, h * 0.02, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)
		draw.SimpleText("Create new or configure existing Combat Simulators.", "wOS.CombatSim.SmallFont", w * 0.02, h * 0.05, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)
	end

	if mode == WOS_CSS.MODE.INITIAL then
		draw.SimpleText("Simulator Selection / Creation", "wOS.CombatSim.LeaderFont", w * 0.02, h * 0.09, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)

		draw.SimpleText("Create a new simulator by left-clicking a prop.", "wOS.CombatSim.SmallFont", w * 0.02, h * 0.12, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)
		draw.SimpleText("Select an existing simulator by left-clicking its console.", "wOS.CombatSim.SmallFont", w * 0.02, h * 0.15, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)
	elseif mode == WOS_CSS.MODE.AREASELECT then
		draw.SimpleText("Simulator Area Creation", "wOS.CombatSim.LeaderFont", w * 0.02, h * 0.09, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)

		if step == WOS_CSS.AREASELECT.BORDER then
			draw.SimpleText("Left-click to add a border point to the simulator area.", "wOS.CombatSim.SmallFont", w * 0.02, h * 0.12, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)
			draw.SimpleText("Right-click to remove the last border point from the simulator area.", "wOS.CombatSim.SmallFont", w * 0.02, h * 0.14, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)
			draw.SimpleText("Left-click the simulator console to confirm border.", "wOS.CombatSim.SmallFont", w * 0.02, h * 0.16, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)
		elseif step == WOS_CSS.AREASELECT.HEIGHT then
			draw.SimpleText("Left-click to set the border height of the simulator area.", "wOS.CombatSim.SmallFont", w * 0.02, h * 0.12, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)
			draw.SimpleText("Left-click the simulator console to confirm height.", "wOS.CombatSim.SmallFont", w * 0.02, h * 0.15, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)
		end
		
		draw.SimpleText("Press R to abort creation.", "wOS.CombatSim.SmallFont", w * 0.02, h * 0.18, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)
	elseif mode == WOS_CSS.MODE.SIMSELECTED then
		draw.SimpleText("Simulator | Challenges Creation/Editing", "wOS.CombatSim.LeaderFont", w * 0.02, h * 0.09, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)
	elseif mode == WOS_CSS.MODE.POINTSELECT then
		local wtbl = weapons.Get( "wos_pes_tool" )
		if not wtbl then return end
		local success = wtbl.DrawHUD( self )
		self.RenderScreen = wtbl.RenderScreen
	end
end

weapons.Register(SWEP, "wos_simulation_tool")
--addons/sui/lua/sui/vgui/sui_number_slider.lua:
local surface = surface

local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name

local NUMBER_SLIDER_FONT = SUI.CreateFont("NumberSlider", "Roboto Regular", 14)

local PANEL = {}

sui.scaling_functions(PANEL)

function PANEL:Init()
	self:ScaleInit()

	local slider = vgui.Create(NAME .. ".Slider", self, "NumberSlider")
	slider:Dock(FILL)

	self.slider = slider

	local label = self:Add(NAME .. ".Label")
	label:Dock(RIGHT)
	label:DockMargin(3, 0, 0, 0)
	label:SetFont(NUMBER_SLIDER_FONT)
	self.label = label

	function label:Think()
		self:SetText(slider:GetValue())

		self:SizeToContents()
	end

	self:SetSize(100, 12)
	self:InvalidateLayout(true)
end

sui.register("NumberSlider", PANEL, "Panel")
--addons/sui/lua/sui/vgui/sui_threegrid.lua:
local math = math
local table = table
local ipairs = ipairs

local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name

local Panel = {}

AccessorFunc(Panel, "horizontalMargin", "HorizontalMargin", FORCE_NUMBER)
AccessorFunc(Panel, "verticalMargin", "VerticalMargin", FORCE_NUMBER)
AccessorFunc(Panel, "columns", "Columns", FORCE_NUMBER)
AccessorFunc(Panel, "Wide2", "Wide2", FORCE_NUMBER)

function Panel:Init()
	self:SetHorizontalMargin(0)
	self:SetVerticalMargin(0)
	self.Rows = {}
	self.Cells = {}
end

function Panel:AddCell(pnl)
	local cols = self:GetColumns()
	local idx = math.floor(#self.Cells / cols) + 1

	local rows = self.Rows[idx]
	if not rows then
		rows = self:CreateRow()
		self.Rows[idx] = rows
	end

	local margin = self:GetHorizontalMargin()

	local dockl, dockt, _, dockb = pnl:GetDockMargin()
	pnl:SetParent(rows)
	pnl:Dock(LEFT)
	pnl:DockMargin(dockl, dockt, #rows.Items + 1 < cols and self:GetHorizontalMargin() or 0, dockb)
	pnl:SetWide(((self:GetWide2() or self:GetWide()) - margin * (cols - 1)) / cols)

	table.insert(rows.Items, pnl)
	table.insert(self.Cells, pnl)

	self:CalculateRowHeight(rows)
end

function Panel:CreateRow()
	local row = self:Add("Panel")
	row:Dock(TOP)
	row:DockMargin(0, 0, 0, self:GetVerticalMargin())
	row.Items = {}

	return row
end

function Panel:CalculateRowHeight(row)
	local height = 0

	for k, v in ipairs(row.Items) do
		local _, t, _, b = v:GetDockMargin()
		height = math.max(height, v:GetTall() + t + b)
	end

	row:SetTall(height)
end

function Panel:Skip()
	local cell = vgui.Create("Panel")
	self:AddCell(cell)
end

function Panel:CalculateRowHeights()
	for _, row in ipairs(self.Rows) do
		self:CalculateRowHeight(row)
	end
end

function Panel:Clear()
	for _, row in ipairs(self.Rows) do
		for _, cell in ipairs(row.Items) do
			cell:Remove()
		end

		row:Remove()
	end

	self.Cells, self.Rows = {}, {}
end

Panel.OnRemove = Panel.Clear
sui.register("ThreeGrid", Panel, NAME .. ".ScrollPanel")
--addons/scb_chatbox/lua/scb/settings/cl_settings.lua:
if SCB_LOADED then return end

local vgui = vgui

local IsValid = IsValid
local pairs = pairs
local LocalPlayer = LocalPlayer

local scb = scb

local tabs = {}
for _, f in ipairs(file.Find("scb/settings/tabs/*.lua", "LUA")) do
	local data = include("scb/settings/tabs/" .. f)
	tabs[data.pos or #tabs + 1] = data
end

function scb.open_settings()
	if IsValid(scb.settings_frame) then
		return scb.settings_frame:Remove()
	end

	local frame = vgui.Create("SCB.Frame")
	frame:SetTitle("SCB | " .. scb.language.settings_title)
	frame:MakePopup()
	frame:AddAnimations(382, 420)

	local sheet = frame:Add("SCB.PropertySheet")
	sheet:Dock(FILL)
	sheet:DockMargin(4, 4, 4, 4)
	sheet:InvalidateParent(true)
	sheet:InvalidateLayout(true)

	for k, v in pairs(tabs) do
		if v.check == false or scb.has_permission(LocalPlayer(), "menu") then
			sheet:AddSheet(v.title, v.func)
		end
	end

	scb.settings_frame = frame
end
--addons/scb_chatbox/lua/scb/settings/tabs/tags.lua:
if SCB_LOADED then return end

local scb = scb
local SUI = scb.SUI
local language = scb.language

scb.tags = scb.tags or {}

net.Receive("SCB.SendTags", function()
	local tags = net.ReadData(net.ReadUInt(17))
	tags = util.Decompress(tags)
	scb.tags = scb.mp.unpack(tags)
end)

net.Receive("SCB.AddTag", function()
	local key = net.ReadString()
	local tag = net.ReadString()
	scb.tags[key] = tag

	local old = net.ReadString()

	if old ~= "" then
		scb.tags[old] = nil
	end

	hook.Call("SCB.TagsModified")
end)

net.Receive("SCB.RemoveTag", function()
	scb.tags[net.ReadString()] = nil
	hook.Call("SCB.TagsModified")
end)

local tags_menu = function(title, key, key_tag)
	key = key or ""

	local options = sui.valid_options()

	local querybox = vgui.Create("SCB.QueryBox")
	querybox:SetTitle(title)
	querybox:SetWide(300)

	local name = querybox:Add("SCB.TextEntry")
	name:Dock(TOP)
	name:SetPlaceholder(language.tag_owner)
	name:SetValue(key)

	name:SetCheck(function(_name)
		if _name == "" or (scb.tags[_name] and key ~= _name) then
			return false
		end
	end)

	options.Add(name)

	local tag = querybox:Add("SCB.TextEntry")
	tag:Dock(TOP)
	tag:DockMargin(0, 4, 0, 0)
	tag:SetPlaceholder(language.tag)
	tag:SetValue(key_tag or "")

	tag:SetCheck(function(_tag)
		return _tag ~= ""
	end)

	options.Add(tag)

	local preview = querybox:Add("SCB.ChatLine")
	preview:DockMargin(0, 6, 0, 0)
	preview.x = 3
	preview.emoji_size = 18

	preview:ScaleChanged()
	preview:Parse(tag:GetValue())
	preview:SetMouseInputEnabled(false)

	tag:On("OnValueChange", function(s, v)
		preview.added = {}
		preview:ScaleChanged()
		preview:Parse(v)
		querybox:size_to_children()
	end)

	querybox:SetCallback(function()
		net.Start("SCB.AddTag")
			net.WriteString(name:GetText())
			net.WriteString(tag:GetText())
			net.WriteString(name:GetText() ~= key and key or "")
		net.SendToServer()
	end)

	querybox:Done()
	querybox.save:SetEnabled(true)

	function querybox.save:Think()
		self:SetEnabled(options.IsValid())
	end
end

return {
	title = language.tags_title,
	pos = 2,
	func = function(parent)
		local body = parent:Add("Panel")
		body:Dock(FILL)
		body:DockMargin(0, 1, 0, 0)
		body:InvalidateParent(true)

		SUI.OnScaleChanged(body, function()
			body:Remove()
		end)

		local tags_list = body:Add("SCB.ThreeGrid")
		tags_list:Dock(FILL)
		tags_list:InvalidateLayout(true)
		tags_list:InvalidateParent(true)

		tags_list:SetColumns(2)
		tags_list:SetHorizontalMargin(2)
		tags_list:SetVerticalMargin(2)

		local load_tags = function()
			tags_list:Clear()

			for key, tag in SortedPairs(scb.tags) do
				local pnl = vgui.Create("DButton")
				pnl:SetText("")
				pnl:SetTall(SUI.Scale(560))
				pnl:SUI_TDLib()
					:ClearPaint()
					:FadeHover()

				function pnl:DoClick()
					tags_menu(language.edit .. " '" .. key .. "'", key, tag)
				end

				function pnl:DoRightClick()
					local d_menu = DermaMenu()

					d_menu:AddOption(language.remove, function()
						net.Start("SCB.RemoveTag")
							net.WriteString(key)
						net.SendToServer()
					end)

					d_menu:Open()
					d_menu:MakePopup()

					function pnl:OnRemove()
						d_menu:Remove()
					end
				end
				tags_list:AddCell(pnl)

				local name = pnl:Add("SCB.Label")
				name:Dock(TOP)
				name:SetFont(SCB_16)
				name:SetText(key)
				name:SetTextInset(3, 0)
				name:SetExpensiveShadow(1, color_black)
				name:SizeToContentsY(3)

				local _tag = pnl:Add("SCB.ChatLine")
				_tag:DockMargin(3, 0, 0, 0)
				_tag:SetFont(SCB_16)

				_tag.emoji_size = 16
				_tag:Parse(tag)
				_tag:SetMouseInputEnabled(false)

				pnl:SizeToChildren(false, true)
			end

			for k, v in ipairs(tags_list.Rows) do
				tags_list:CalculateRowHeight(v)
			end
		end
		load_tags()

		hook.Add("SCB.TagsModified", tags_list, load_tags)

		local add = body:Add("SCB.Button")
		add:Dock(BOTTOM)
		add:DockMargin(0, 4, 0, 0)
		add:SetText(language.add_tag:upper())

		add:On("DoClick", function()
			tags_menu(language.add_tag)
		end)

		return body
	end
}
--gamemodes/starwarsrp/gamemode/modules/medicsystem_droid/treatments/booter.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--            Medicsystem            --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--      Medicsystem | Treatment      --
---------------------------------------

local Treatment = {}

Treatment.Name = "Booter"
Treatment.Description = "Rebootet einen Droiden."

Treatment.TreatmentTime = 2
Treatment.ForceCustomMessage = true

Treatment.Type = {["Repairkit"] = true}

Treatment.TreatmentSound = function(self, ply)
	return "HL1/ambience/port_suckin1.wav"
end

Treatment.CanLocalUse = function(self, ply, patient, hitgroup, injury)
	return false
end

Treatment.CanGlobalUse = function(self, ply, patient, hitgroup)
	if not patient:IsDroid() then return false end

	-- Patient must be a dead player
	if patient:IsPlayer() and not patient:Alive() then
		return true
	end

	return false
end

Treatment.GlobalUseFunction = function(self, ply, patient, hitgroup)
	Medicsystem:SendMessage(ply, {
		team.GetColor(ply:Team()),
		ply:GetCurrentCharacterFullName(),
		" verwendete den Booter bei ",
		Medicsystem:GetCurrentCharacterFullName(patient),
		"."
	})

	if patient:GetNWBool("Medicsystem.IsDead", false) then return false end

	timer.Simple(0.3,function()
		if IsValid(patient) then
			DeathSystem:Revive(patient)
			Medicsystem:CalculateHealth(patient)
		end
	end)

	return true
end

Medicsystem:RegisterTreatment("booter", Treatment)




--gamemodes/starwarsrp/gamemode/modules/medicsystem_droid/injuries/hinge.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--            Medicsystem            --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--       Medicsystem | Injury        --
---------------------------------------

local Injury = {}

Injury.Name = "Zersprungenes Gelenk"
Injury.Treatments = {
	["welder"] = true
}

Injury.Detection = {
	["Medicsystem.AddInjury"] = function(ply, hitgroup, dmgInfo)
		-- Player must be a droid
		if not ply:IsDroid() then return end

		-- Checkup fall damage
		local damageTypes = {[DMG_FALL] = true, [DMG_CRUSH] = true}
		if damageTypes[dmgInfo:GetDamageType()] then
			hitgroup = table.Random({"Linker Arm", "Rechter Arm", "Rechtes Bein", "Linkes Bein"})

			-- If the damage is less than 60% of the maximum lives, the player receives a dent.
			-- Elseif the damage is more than 60% of the maximum lives, the player receives a broken hinge.
			local damage = dmgInfo:GetDamage()
			if damage < ply:GetMaxHealth() * 0.6 then
				local success, message = Medicsystem:AddInjury(ply, hitgroup, dmgInfo:GetDamage(), "dent")
				if not success and message then
					LogError("Medicsystem: Couldn't add injury 'dent' to player " .. ply:Nick() .. "(" .. message .. ").")
				end
			else
				local success, message = Medicsystem:AddInjury(ply, hitgroup, dmgInfo:GetDamage(), "hinge")
				if not success and message then
					LogError("Medicsystem: Couldn't add injury 'hinge' to player " .. ply:Nick() .. "(" .. message .. ").")
				end
			end
		end
	end,
}

Medicsystem:RegisterInjury("hinge", Injury)
--gamemodes/starwarsrp/gamemode/modules/medicsystem_droid/injuries/shortcircuit.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--            Medicsystem            --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--       Medicsystem | Injury        --
---------------------------------------

local Injury = {}

Injury.Name = "Kurzschluss"
Injury.Treatments = {
	["welder"] = true
}

Injury.Detection = {
	["Medicsystem.AddInjury"] = function(ply, hitgroup, dmgInfo)
		-- Player must be a droid
		if not ply:IsDroid() then return end

		if dmgInfo:GetDamageType() == DMG_SHOCK then
			local success, message = Medicsystem:AddInjury(ply, hitgroup, dmgInfo:GetDamage(), "shortcircuit")
			if not success and message then
				LogError("Medicsystem: Couldn't add injury 'shortcircuit' to player " .. ply:Nick() .. "(" .. message .. ").")
			end
		end
	end,
}

Medicsystem:RegisterInjury("shortcircuit", Injury)
--gamemodes/starwarsrp/gamemode/modules/medicsystem_droid/injuries/stitch.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--            Medicsystem            --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--       Medicsystem | Injury        --
---------------------------------------

local Injury = {}

Injury.Name = "Einstich"
Injury.Treatments = {
	["plate"] = true,
	["welder"] = true
}

Injury.Detection = {
	["Medicsystem.AddInjury"] = function(ply, hitgroup, dmgInfo)
		-- Player must be a droid
		if not ply:IsDroid() then return end

		if dmgInfo:GetDamageType() == DMG_SLASH then
			local success, message = Medicsystem:AddInjury(ply, hitgroup, dmgInfo:GetDamage(), "stitch")
			if not success and message then
				LogError("Medicsystem: Couldn't add injury 'stitch' to player " .. ply:Nick() .. "(" .. message .. ").")
			end
		end
	end,
}

Medicsystem:RegisterInjury("stitch", Injury)
--gamemodes/starwarsrp/gamemode/modules/medicsystem_cwrp/treatments/latheniol.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--            Medicsystem            --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--      Medicsystem | Treatment      --
---------------------------------------

local Treatment = {}

Treatment.Name = "Latheniol"
Treatment.Description = "Latheniol wird verwendet, um todkranke Patienten zu euthanasieren."

Treatment.TreatmentTime = 8
Treatment.UseMessage = "verwendet Latheniol."

Treatment.Type = {["Injector"] = true}

Treatment.TreatmentSound = function(self, ply)
	return "medkit/squirt.wav"
end

Treatment.CanLocalUse = function(self, ply, patient, hitgroup, injury)
	return false
end

Treatment.CanGlobalUse = function(self, ply, patient, hitgroup)
	-- Patient mustn't be a droid
	if patient:IsDroid() then return false end

	-- Don't inject it yourself
	if patient == ply then return false end

	return patient:IsPlayer()
end

Treatment.GlobalUseFunction = function(self, ply, patient, hitgroup)
	Medicsystem:SendMessage(ply, {
		team.GetColor(ply:Team()),
		ply:GetCurrentCharacterFullName(),
		" injizierte ",
		self.Name,
		" in den/das ",
		hitgroup,
		" von ",
		Medicsystem:GetCurrentCharacterFullName(patient),
		"."
	})

	-- Don't run several latheniol timers
	if timer.Exists("Medicsystem.Latheniol_" .. patient:SteamID64()) then return end

	-- Kills the patient slowly
	if patient:Alive() then
		-- Creates the latheniol kill timer
		local round = 1
		timer.Create("Medicsystem.Latheniol_" .. patient:SteamID64(), 3, 4, function()
			if not IsValid(patient) then return end

			-- If Player is already dead, latheniol kills him finally
			if not patient:Alive() or round > 3 then
				Medicsystem:AddInjury(patient, "Thorax", patient:GetMaxHealth(), "latheniol")
				Medicsystem:Kill(patient)

				timer.Remove("Medicsystem.Latheniol_" .. patient:SteamID64())
				return
			end

			-- Takes 25% of max health
			local damage = patient:GetMaxHealth() * 0.25
			patient:TakeDamage(damage)

			round = round + 1
		end)
	else
		Medicsystem:AddInjury(patient, "Thorax", patient:GetMaxHealth(), "latheniol")
		Medicsystem:Kill(patient)
	end
end

Medicsystem:RegisterTreatment("latheniol", Treatment)




--gamemodes/starwarsrp/gamemode/modules/medicsystem_cwrp/treatments/rakghoul.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--            Medicsystem            --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--      Medicsystem | Treatment      --
---------------------------------------

local Treatment = {}

Treatment.Name = "Rakghoul Serum"
Treatment.Description = "Ein Heilmittel was synthetisiert wurde gegen das Rakghoul Virus."

Treatment.TreatmentTime = 8
Treatment.UseMessage = "verwendet das Rakghoul Serum."

Treatment.Type = {["Injector"] = true}

Treatment.TreatmentSound = function(self, ply)
	return "medkit/squirt.wav"
end

Treatment.CanLocalUse = function(self, ply, patient, hitgroup, injury)
	return false
end

Treatment.CanGlobalUse = function(self, ply, patient, hitgroup)
	-- Patient mustn't be a droid
	if patient:IsDroid() then return false end

	if patient:IsPlayer() then return true end

	return false
end

Treatment.GlobalUseFunction = function(self, ply, patient, hitgroup)
	Medicsystem:SendMessage(ply, {
		team.GetColor(ply:Team()),
		ply:GetCurrentCharacterFullName(),
		" injizierte das ",
		self.Name,
		" in den/das ",
		hitgroup,
		" von ",
		Medicsystem:GetCurrentCharacterFullName(patient),
		"."
	})

	if not patient:IsPlayer() then return false end
	if patient:IsRakghoul() then return false end

	patient:SetImmunity(CurTime() + Rakghoul.ImmunityTime)

	if patient:IsTransforming() then
		patient:StopSound("npc/antlion_guard/growl_idle.wav")
		timer.Remove("Rakghoul.Transforming_" .. patient:SteamID64())
	end

	return false
end

Medicsystem:RegisterTreatment("rakghoul", Treatment)




--gamemodes/starwarsrp/gamemode/modules/medicsystem_cwrp/treatments/synthflesh.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--            Medicsystem            --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--      Medicsystem | Treatment      --
---------------------------------------

local Treatment = {}

Treatment.Name = "Synthfleisch"
Treatment.Description = "Dies ist eine rosafarbene, breiige Masse, welche zur Erstversorgung von tiefen Wunden auf dem Schlachtfeld verwendet wird."

Treatment.TreatmentTime = 8
Treatment.UseMessage = "trägt Synthfleisch auf."

Treatment.Type = {["Kit"] = true}

Treatment.TreatmentSound = function(self, ply)
	return "medkit/cansound.wav"
end

Treatment.CanLocalUse = function(self, ply, patient, hitgroup, injury)
	-- Patient mustn't be a droid
	if patient:IsDroid() then return false end

	return true
end

Treatment.LocalUseFunction = function(self, ply, patient, hitgroup, injury)
	if injury == "innerbleeding" then
		Medicsystem:SendMessage(ply, {
			team.GetColor(ply:Team()),
			ply:GetCurrentCharacterFullName(),
			" verwendete ",
			self.Name,
			" um die ",
			injury.name,
			" von ",
			Medicsystem:GetCurrentCharacterFullName(patient),
			" zu stillen."
		})
	else
		Medicsystem:SendMessage(ply, {
			team.GetColor(ply:Team()),
			ply:GetCurrentCharacterFullName(),
			" trug ",
			self.Name,
			" über ",
			injury.name,
			" von ",
			Medicsystem:GetCurrentCharacterFullName(patient),
			" auf."
		})
	end

	return true
end

Treatment.CanGlobalUse = function(self, ply, patient, hitgroup)
	return false
end

Medicsystem:RegisterTreatment("synthflesh", Treatment)




--gamemodes/starwarsrp/gamemode/modules/medicsystem_cwrp/injuries/crush.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--            Medicsystem            --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--       Medicsystem | Injury        --
---------------------------------------

local Injury = {}

Injury.Name = "Quetschung"
Injury.Treatments = {
	["anticeptind"] = true,
	["nullicaine"] = true,
	["myocaine"] = true,
	["splint"] = true,
	["bactabandage"] = true
}

-- Until which severity a single bacta can heal the injury
Injury.BactaHeal = 2

Injury.Detection = {
	["Medicsystem.AddInjury"] = function(ply, hitgroup, dmgInfo)
		-- Player mustn't be a droid
		if ply:IsDroid() then return end

		if dmgInfo:GetDamageType() == DMG_CRUSH then
			local success, message = Medicsystem:AddInjury(ply, hitgroup, dmgInfo:GetDamage(), "crush")
			if not success and message then
				LogError("Medicsystem: Couldn't add injury 'crush' to player " .. ply:Nick() .. "(" .. message .. ").")
			end

			if dmgInfo:GetDamage() > ply:GetMaxHealth() * 0.8 then
				local injury = "smoothfracture"
				if math.random(0, 1) >= 0.9 then
					injury = "openfracture"
				end

				local success, message = Medicsystem:AddInjury(ply, hitgroup, dmgInfo:GetDamage(), injury)
				if not success and message then
					LogError("Medicsystem: Couldn't add injury '" .. injury .. "' to player " .. ply:Nick() .. "(" .. message .. ").")
				end
			end
		end
	end
}

Medicsystem:RegisterInjury("crush", Injury)
--gamemodes/starwarsrp/gamemode/modules/medicsystem_cwrp/injuries/cut.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--            Medicsystem            --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--       Medicsystem | Injury        --
---------------------------------------

local Injury = {}

Injury.Name = "Schnittwunde"
Injury.Treatments = {
	["anticeptind"] = true,
	["nullicaine"] = true,
	["coagulin"] = true,
	["woundglue"] = true,
	["bactabandage"] = true
}

-- Until which severity a single bacta can heal the injury
Injury.BactaHeal = 2

Injury.Detection = {
	["Medicsystem.AddInjury"] = function(ply, hitgroup, dmgInfo)
		-- Player mustn't be a droid
		if ply:IsDroid() then return end

		if dmgInfo:GetDamageType() == DMG_SLASH then
			local success, message = Medicsystem:AddInjury(ply, hitgroup, dmgInfo:GetDamage(), "cut")
			if not success and message then
				LogError("Medicsystem: Couldn't add injury 'cut' to player " .. ply:Nick() .. "(" .. message .. ").")
			end
		end
	end
}

Medicsystem:RegisterInjury("cut", Injury)
--gamemodes/starwarsrp/gamemode/modules/medicsystem_cwrp/injuries/radiation.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--            Medicsystem            --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--       Medicsystem | Injury        --
---------------------------------------

local Injury = {}

Injury.Name = "Verstrahlung"
Injury.Treatments = {
	["anticeptind"] = true,
	["radiation"] = true
}

Injury.scanNeeded = true

Injury.Detection = {
	["Medicsystem.AddInjury"] = function(ply, hitgroup, dmgInfo)
		-- Player mustn't be a droid
		if ply:IsDroid() then return end

		if dmgInfo:GetDamageType() == DMG_RADIATION then
			local success, message = Medicsystem:AddInjury(ply, "Thorax", dmgInfo:GetDamage(), "radiation")
			if not success and message then
				LogError("Medicsystem: Couldn't add injury 'radiation' to player " .. ply:Nick() .. "(" .. message .. ").")
			end
		end
	end
}

Medicsystem:RegisterInjury("radiation", Injury)
--gamemodes/starwarsrp/gamemode/modules/medicsystem_jedi/treatments/alienum.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--            Medicsystem            --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--      Medicsystem | Treatment      --
---------------------------------------

local Treatment = {}

Treatment.Name = "Alienum Corpus"
Treatment.Description = "Eine spezielle Form der Machtheilung."

Treatment.TreatmentTime = 2
Treatment.ForceCustomMessage = true

Treatment.Type = {["Force"] = true}

Treatment.Injuries = {
	["Explosionsfragmente"] = true,
	["Gehirnerschütterung"] = true,
	["Innere Blutung"] = true
}

Treatment.TreatmentSound = function(self, ply)
	return "lightsaber/force_leap.wav"
end

Treatment.CanLocalUse = function(self, ply, patient, hitgroup, injury)
	return Treatment.Injuries[injury.name]
end

Treatment.LocalUseFunction = function(self, ply, patient, hitgroup, injury)
	local animationTime = ply:SetSequenceOverride("wos_jedi_mindtrick", 1.2)
	timer.Simple(animationTime, function()
		-- Validity check
		if not IsValid(ply) then return end
		if not IsValid(patient) then return end

		-- Sends the message
		Medicsystem:SendMessage(ply, {
			team.GetColor(ply:Team()),
			ply:GetCurrentCharacterFullName(),
			" heilte ",
			injury.name,
			" von ",
			Medicsystem:GetCurrentCharacterFullName(patient),
			" mittels ",
			self.Name,
			"."
		})

		-- Cures the injury
		Medicsystem:InjuryTreated(patient, hitgroup, Medicsystem:TranslateInjury(injury.name))

		-- Heal effect
		local ed = EffectData()
		ed:SetOrigin(ply:GetPos())
		ed:SetEntity(patient)
		util.Effect("rb655_force_heal", ed, true, true)

		return true
	end)
end

Treatment.CanGlobalUse = function(self, ply, patient, hitgroup)
	return false
end

Medicsystem:RegisterTreatment("alienum", Treatment)




--gamemodes/starwarsrp/gamemode/modules/medicsystem_jedi/treatments/curato.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--            Medicsystem            --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--      Medicsystem | Treatment      --
---------------------------------------

local Treatment = {}

Treatment.Name = "Curato Salva"
Treatment.Description = "Eine der grundlegensten Formen der Machtheilung."

Treatment.TreatmentTime = 2
Treatment.ForceCustomMessage = true

Treatment.Type = {["Force"] = true}

Treatment.Injuries = {
	["Brandwunde"] = true,
	["Prellung"] = true,
	["Schnittwunde"] = true,
	["Stromschock"] = true
}

Treatment.TreatmentSound = function(self, ply)
	return "lightsaber/force_leap.wav"
end

Treatment.CanLocalUse = function(self, ply, patient, hitgroup, injury)
	return Treatment.Injuries[injury.name]
end

Treatment.LocalUseFunction = function(self, ply, patient, hitgroup, injury)
	local animationTime = ply:SetSequenceOverride("wos_jedi_mindtrick", 1.2)
	timer.Simple(animationTime, function()
		-- Validity check
		if not IsValid(ply) then return end
		if not IsValid(patient) then return end

		-- Sends the message
		Medicsystem:SendMessage(ply, {
			team.GetColor(ply:Team()),
			ply:GetCurrentCharacterFullName(),
			" heilte ",
			injury.name,
			" von ",
			Medicsystem:GetCurrentCharacterFullName(patient),
			" mittels ",
			self.Name,
			"."
		})

		-- Cures the injury
		Medicsystem:InjuryTreated(patient, hitgroup, Medicsystem:TranslateInjury(injury.name))

		-- Heal effect
		local ed = EffectData()
		ed:SetOrigin(ply:GetPos())
		ed:SetEntity(patient)
		util.Effect("rb655_force_heal", ed, true, true)

		return true
	end)
end

Treatment.CanGlobalUse = function(self, ply, patient, hitgroup)
	return false
end

Medicsystem:RegisterTreatment("curato", Treatment)




--gamemodes/starwarsrp/gamemode/modules/medicsystem_jedi/treatments/fractura.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--            Medicsystem            --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--      Medicsystem | Treatment      --
---------------------------------------

local Treatment = {}

Treatment.Name = "Fractura Salva"
Treatment.Description = "Eine spezielle Form der Machtheilung."

Treatment.TreatmentTime = 2
Treatment.ForceCustomMessage = true

Treatment.Type = {["Force"] = true}

Treatment.Injuries = {
	["Verstauchung"] = true,
	["Quetschung"] = true,
	["Glatter Bruch"] = true,
	["Offener Bruch"] = true
}

Treatment.TreatmentSound = function(self, ply)
	return "lightsaber/force_leap.wav"
end

Treatment.CanLocalUse = function(self, ply, patient, hitgroup, injury)
	return Treatment.Injuries[injury.name]
end

Treatment.LocalUseFunction = function(self, ply, patient, hitgroup, injury)
	local animationTime = ply:SetSequenceOverride("wos_jedi_mindtrick", 1.2)
	timer.Simple(animationTime, function()
		-- Validity check
		if not IsValid(ply) then return end
		if not IsValid(patient) then return end

		-- Sends the message
		Medicsystem:SendMessage(ply, {
			team.GetColor(ply:Team()),
			ply:GetCurrentCharacterFullName(),
			" heilte ",
			injury.name,
			" von ",
			Medicsystem:GetCurrentCharacterFullName(patient),
			" mittels ",
			self.Name,
			"."
		})

		-- Cures the injury
		Medicsystem:InjuryTreated(patient, hitgroup, Medicsystem:TranslateInjury(injury.name))

		-- Heal effect
		local ed = EffectData()
		ed:SetOrigin(ply:GetPos())
		ed:SetEntity(patient)
		util.Effect("rb655_force_heal", ed, true, true)

		return true
	end)
end

Treatment.CanGlobalUse = function(self, ply, patient, hitgroup)
	return false
end

Medicsystem:RegisterTreatment("fractura", Treatment)




--addons/bkeypads/lua/bkeypads_custom_access.lua:
bKeypads.CustomAccess:Reset() --[[ Don't delete this line
               
                  ___          _                      ___                           
                 / __\   _ ___| |_ ___  _ __ ___     / _ \_ __ ___  _   _ _ __  ___ 
                / / | | | / __| __/ _ \| '_ ` _ \   / /_\/ '__/ _ \| | | | '_ \/ __|
               / /__| |_| \__ \ || (_) | | | | | | / /_\\| | | (_) | |_| | |_) \__ \
               \____/\__,_|___/\__\___/|_| |_| |_| \____/|_|  \___/ \__,_| .__/|___/
                                                                         |_|        

In this file you can define custom groups of teams and custom Lua functions which players can use
to authorize people on their keypads.

Some basic knowledge of Lua syntax is required.

By the way, in case you didn't know, DarkRP jobs are the same thing as teams.

====================================================================================================

                             __                           _           
                            /__\_  ____ _ _ __ ___  _ __ | | ___  ___ 
                           /_\ \ \/ / _` | '_ ` _ \| '_ \| |/ _ \/ __|
                          //__  >  < (_| | | | | | | |_) | |  __/\__ \
                          \__/ /_/\_\__,_|_| |_| |_| .__/|_|\___||___/
                                                   |_|                
                            	
Example 1
=========
This example defines a TEAM GROUP which represents all law enforcement teams.

bKeypads:AddTeamGroup("Law Enforcement", {
	TEAM_POLICE,
	TEAM_CHIEF,
	TEAM_MAYOR,
})

Example 2
=========
This example defines a TEAM GROUP which represents all hospital workers.

bKeypads:AddTeamGroup("Hospital Staff", {
	TEAM_PARAMEDIC,
	TEAM_DOCTOR,
	TEAM_NURSE,
	TEAM_COLONOSCOPIST,
})

Example 3
=========
This example defines a LUA FUNCTION which returns whether the player has law enforcement
permissions on DarkRP.

This is basically Example 1, but using a Lua function instead.

bKeypads:AddCustomGroup("Police", function(ply, keypad, keycard)
	-- Note: keycard only exists if the keypad is scanning one
	return ply:isCP()
end)

Example 4
=========
This example defines a TEAM GROUP which represents all Class B personnel on SCP-RP.

bKeypads:AddTeamGroup("Class B", {
	TEAM_RESEARCHER,
	TEAM_SECURITY,
	TEAM_MTF,
	TEAM_MTF_COMMANDER,
	TEAM_O5,
	TEAM_FIELD_AGENT,
})

Yes I'm aware that I've probably spectacularly fucked up the lore there, but it's just an example :D

Example 5
=========
This example defines a LUA FUNCTION which returns whether a player has an SCP keycard whose level falls in a certain range.

This example would obviously only work if you've written a custom SCP keycard system for your server or are using a Workshop addon
or similar which exposes some custom Lua functions. PLAYER:GetSCPKeycardLevel() is a completely arbritrary example.

bKeypads:AddCustomGroup("Level 3", function(ply, keypad, keycard)
	-- Note: keycard only exists if the keypad is scanning one
	return ply:GetSCPKeycardLevel() >= 3
end)

====================================================================================================
                                      WRITE CODE BELOW THESE LINES
====================================================================================================]]

local function addFaction(targetFaction)
	bKeypads:AddCustomGroup(targetFaction:GetName(), function(keypad, ply, keycard)
		local char = ply:GetCurrentCharacter()
		if char then
			local faction = char:GetFaction()
			if faction and faction == targetFaction then
				return true
			end

			local extraFaction = char:GetExtraFaction()
			if extraFaction and extraFaction == targetFaction then
				return true
			end
		end

		return false
	end)
end

if Faction then
	for _, faction in pairs(Faction:GetCache()) do
		addFaction(faction)
	end
end

hook.Add("Faction.Load", "KeycardLoadFaction", function(faction)
	addFaction(faction)
end)

hook.Add("Faction.Created", "KeycardCreatedFaction", function(faction)
	addFaction(faction)
end)

--hook.Add("Faction.Delete", "KeycardDeleteFaction", function(faction)
--	bKeycardScanner.Config.customChecks[faction:GetName()] = nil
--end)

--addons/prone_mod_wos/lua/prone/config.lua:
-------------------
-- General Settings
-------------------
-- What should we multiply fall damage by while prone. Set to 1 to disable.
prone.Config.FallDamageMultiplier = 1


-----------------------
-- Key-related settings
-----------------------
-- NOTICE:	Every setting in this section can later be changed
--			by the user with the "prone_config" command.

-- By default is the bind key enabled.
prone.Config.DefaultBindKey_Enabled = true

-- What is the default bind key set by the server.
-- See http://wiki.garrysmod.com/page/Enums/KEY
prone.Config.DefaultBindKey = KEY_LCONTROL

-- By default should the player double tap the bind key to go prone.
prone.Config.DefaultBindKey_DoubleTap = true

-- By default can the user press the jump key to get up.
prone.Config.DefaultJumpToGetUp = true

-- By default must the user double press the jump key to get up.
prone.Config.DefaultJumpToGetUp_DoubleTap = false

--------------
-- Move speeds
--------------
-- How fast they move while prone.
prone.Config.MoveSpeed = 50

-- How fast they move while getting up or going down.
-- Prefer to keep this at 0, otherwise if they move somewhere they cant fit while getting up
-- they will be forced back into prone.
prone.Config.TransitionSpeed = 0

----------------------------
-- Shooting related settings
----------------------------
-- There are no moving and shooting animations while prone so it would look like
-- players aren't shooting when they are. You probably don't want to change this to false.
prone.Config.MoveShoot_Restrict = true

-- Weapons in this list can be shot while moving
prone.Config.MoveShoot_Whitelist = {
	weapon_physgun			= true,
	weapon_physcannon		= true,		-- Gravity Gun
	gmod_tool				= true,		-- Toolgun
	gmod_camera				= true,
	weapon_medkit			= true,
	weaponchecker			= true,		-- (DarkRP)
	keys					= true,		-- (DarkRP)
	pocket					= true,		-- (DarkRP)
	weapon_keypadchecker	= true,		-- (DarkRP)
	unarrest_stick			= true,		-- (DarkRP)
	arrest_stick			= true,		-- (DarkRP)
	weapon_zm_carry			= true,		-- (TTT) Magneto Stick
	weapon_ttt_binoculars	= true,		-- (TTT)
	weapon_ttt_unarmed		= true		-- (TTT)
}


--------------------------
-- DarkRP related settings
--------------------------
-- Should we restrict prone by job.
prone.Config.Darkrp_RestrictJobs = false

-- Is the job list a whitelist? False for blacklist.
prone.Config.Darkrp_IsWhitelist = true

-- If the above setting is true this is the job whitelist. Blacklist otherwise.
prone.Config.Darkrp_Joblist = {
	TEAM_POLICE,
	TEAM_GANG
}

-- Any players of these ranks can go prone, no matter of their job.
prone.Config.Darkrp_BypassRanks = {
	"superadmin",
	"admin"
}

--------------------
-- Advanced Settings
--------------------
-- Sets the hull height while prone. What you can fit under.
prone.Config.HullHeight = 24

-- Sets how low the player's view will be while prone.
prone.Config.View = Vector(0, 0, 20)

prone.Animations.gettingdown = "pronedown_stand"
prone.Animations.gettingup = "proneup_stand"
prone.Animations.passive = "prone_walkpassive"

-- These two are not in use right now.
prone.Animations.gettingdown_crouch = "pronedown_crouch"
prone.Animations.gettingup_crouch = "proneup_crouch"

prone.Animations.WeaponAnims = {
	moving = {
		ar2			= "prone_walktwohand",
		camera		= "prone_walkonehand",
		crossbow	= "prone_walkcrossbow",
		duel		= "prone_walkcrossbow",
		fist		= "prone_walkpassive",
		grenade		= "prone_walkonehand",
		knife		= "prone_walkpassive",
		magic		= "prone_walkpassive",
		melee		= "prone_walkonehand",
		melee2		= "prone_walkonehand",
		normal		= "prone_walkpassive",
		passive		= "prone_walkpassive",
		pistol		= "prone_walkonehand",
		physgun		= "prone_walkphysgun",
		revolver	= "prone_walkonehand",
		rpg			= "prone_walkrpg",
		shotgun		= "prone_walktwohand",
		slam		= "prone_walkonehand",
		smg			= "prone_walktwohand"
	},

	idle = {
		ar2			= "prone_ar2",
		camera		= "prone_camera",
		crossbow	= "prone_crossbow",
		duel		= "prone_crossbow",
		fist		= "prone_knife",
		grenade		= "prone_grenade",
		knife		= "prone_knife",
		magic		= "prone_knife",
		melee		= "prone_melee",
		melee2		= "prone_melee2",
		normal		= "prone_passive",
		passive		= "prone_passive",
		pistol		= "prone_pistol",
		physgun		= "prone_physgun",
		revolver	= "prone_revolver",
		rpg			= "prone_rpg",
		shotgun		= "prone_shotgun",
		slam		= "prone_slam",
		smg			= "prone_smg1"
	}
}
--lua/prone/sh_thirdparty_compat.lua:
-- This file adds various checks and fixes depending on the gamemode and thirdparty addons.

-- Checked for prone.CanEnter depending on the gamemode.
if DarkRP or GAMEMODE_NAME == "darkrp" or GAMEMODE.DerivedFrom == "darkrp" then
	hook.Add("prone.CanEnter", "prone.CanEnterDarkRP", function(ply)
		if prone.Config.Darkrp_RestrictJobs then
			local rank = ply:GetUserGroup()
			for i, v in ipairs(prone.Config.Darkrp_BypassRanks) do
				if v == rank then
					return true
				end
			end

			local ply_darkrpjob = ply:Team()
			for i, v in ipairs(prone.Config.Darkrp_Joblist) do
				if ply_darkrpjob == v then
					if prone.Config.Darkrp_IsWhitelist then
						return true
					else
						return false
					end
				end
			end

			-- If their job was not on the list and that list was not a whitelist then they can go prone.
			return not prone.Config.Darkrp_IsWhitelist
		end

		return true
	end)

elseif GAMEMODE_NAME == "prop_hunt" or GAMEMODE.DerivedFrom == "prop_hunt" then
	hook.Add("prone.CanEnter", "prone.CanEnterPropHunt", function(ply)
		if not GetGlobalBool("InRound", false) or (GetGlobalFloat("RoundStartTime", 0) + (HUNTER_BLINDLOCK_TIME or 0)) > CurTime() or ply:Team() ~= TEAM_HUNTERS then
			return false
		else
			return true
		end
	end)

elseif Clockwork then
	hook.Add("prone.CanEnter", "prone.CanEnterClockwork", function(ply)
		return not ply:IsRagdolled()
	end)
end

-- Disable viewmodel calcview for CW2.0
hook.Add("prone.ShouldChangeCalcViewModelView", "prone.DisableForCW2", function(localply)
	if CustomizableWeaponry then
		local weapon = localply:GetActiveWeapon()
		if IsValid(weapon) and weapon.CW20Weapon then
			return false
		end
	end
end)


-- TTT Movement support
hook.Add("TTTPlayerSpeed", "prone.RestrictMovement", function(ply)
	if ply:IsProne() then
		return prone.Config.MoveSpeed / 220	-- 220 is the default run speed in TTT
	end
end)

-- CombineControl's weird chatbox support.
if CLIENT and (GAMEMODE_NAME == "combinecontrol" or GAMEMODE.DerivedFrom == "combinecontrol") then
	local lastGetUpPrintTime = 0		-- Last time a print was made.
	local getUpWarningPrintDelay = 2	-- Time it takes before allowing another print.
	function prone.CantGetUpWarning()
		local ct = CurTime()

		if lastGetUpPrintTime < ct then
			GAMEMODE:AddChat(Color(210, 10, 10, 255), "CombineControl.ChatNormal", "There isn't enough room to stand up!", {CB_ALL, CB_IC})
			lastGetUpPrintTime = ct + getUpWarningPrintDelay
		end
	end
end

-- Disable ragdolling while prone to avoid dealing with annoying stuff.
-- This is untested but honestly Im not giving any attention to a commercial, non open-source, out-dated gamemode.
hook.Add("PlayerCanRagdoll", "prone.FixClockworkRagdoll", function(ply)
	if ply:IsProne() then
		return false
	end
end)